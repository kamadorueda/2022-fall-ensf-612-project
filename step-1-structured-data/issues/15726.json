{
  "_url": "https://github.com/PowerShell/PowerShell/issues/15726",
  "author": "dl2n",
  "body": "### Prerequisites\r\n\r\n- [X] Write a descriptive title.\r\n- [X] Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\r\n- [X] Search the existing issues.\r\n- [X] Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\r\n- [X] Refer to [Differences between Windows PowerShell 5.1 and PowerShell](https://docs.microsoft.com/powershell/scripting/whats-new/differences-from-windows-powershell).\r\n\r\n### Steps to reproduce\r\n\r\nI\u2019m stumbling into a detail of error handling that seems bugged. It is consistent between Windows PS 5.1 and PS 7.x, modulo how the errors are presented on the console.\r\n\r\n\u2022\tfunction with a try/finally\r\n\u2022\tset ErrorActionPreference = Stop at the top of the try and (intended case) reset EAP = Continue in finally\r\n\u2022\tIssue\r\n\r\nA parameter binding error, Write-Error and Throw out of a try/finally do indeed result in a terminating error. If the finally does not reset the EAP, all three terminate the function.\r\n\r\nIf the finally resets the EAP = Continue, the parameter binding error is downgraded to a non-terminating error and the function continues. Write-Error and Throw are not downgraded and terminate the function as expected. It appears that \r\nchanging the EAP affects one class of errors in the course of the throw, while not affecting others.\r\n\r\nIn the repro, note that:\r\n\r\n* \"f\" throws out of the finally (does not emit \"after\")\r\n* \"f -reset\" stops the throw (and emits \"after\")\r\n* \"f -write\" and \"f -throw\" with/without -reset all keep throwing\r\n\r\n```powershell\r\nfunction f\r\n{\r\n    param( [switch] $throw, [switch] $write, [switch] $reset )\r\n\r\n    try {\r\n        write-host EAP $ErrorActionPreference\r\n        $originalEAP = $ErrorActionPreference\r\n        $ErrorActionPreference = [System.Management.Automation.ActionPreference]::Stop\r\n\r\n        if ($throw)\r\n        {\r\n            write-host throwing\r\n            throw 'error'\r\n        } elseif ($write) {\r\n            write-host writeerror\r\n            write-error 'error'\r\n        } else {\r\n            write-host invalidparameter\r\n            Start-Transaction -foobar foo\r\n        }\r\n\r\n        write-host continued try\r\n    }\r\n    finally\r\n    {\r\n        if ($reset) {\r\n            $ErrorActionPreference = $originalEAP\r\n        }\r\n        write-host in finally\r\n    }\r\n\r\n    write-host after\r\n} \r\n```\r\n\r\n### Expected behavior\r\n\r\n```console\r\n'''\r\nPS G:\\nt\\src\\onecore\\sdktools\\srvperf\\vmfleet> f -reset\r\nEAP Continue\r\ninvalidparameter\r\nin finally\r\nStart-Transaction:\r\nLine |\r\n  19 |              Start-Transaction -foobar foo\r\n     |              ~~~~~~~~~~~~~~~~~\r\n     | The term 'Start-Transaction' is not recognized as the name of a cmdlet, function, script file, or operable program.\r\nCheck the spelling of the name, or if a path was included, verify that the path is correct and try again.\r\n'''\r\n```\r\n\r\n\r\n### Actual behavior\r\n\r\n```console\r\nNote the 'after' emitted, showing that resetting the EAP affected the throwing error. Compare to behavior if using write-error/thrown error (-write and -throw respectively).\r\n\r\n'''\r\nPS G:\\nt\\src\\onecore\\sdktools\\srvperf\\vmfleet> f -reset\r\nEAP Continue\r\ninvalidparameter\r\nin finally\r\nStart-Transaction:\r\nLine |\r\n  19 |              Start-Transaction -foobar foo\r\n     |              ~~~~~~~~~~~~~~~~~\r\n     | The term 'Start-Transaction' is not recognized as the name of a cmdlet, function, script file, or operable program.\r\nCheck the spelling of the name, or if a path was included, verify that the path is correct and try again.\r\nafter\r\n'''\r\n```\r\n\r\n\r\n### Environment data\r\n\r\n```powershell\r\nPS G:\\nt\\src\\onecore\\sdktools\\srvperf\\vmfleet> $PSVersionTable\r\n\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.0.3\r\nPSEdition                      Core\r\nGitCommitId                    7.0.3\r\nOS                             Microsoft Windows 10.0.19043\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n\r\n\r\n### Visuals\r\n\r\n_No response_",
  "closed_at": null,
  "comments": [
    {
      "author": "jazzdelightsme",
      "author_association": "CONTRIBUTOR",
      "body": "I concur that this behavior has been around for at least a decade.\r\n\r\nThe problem does not repro if there is an Exception Handling (EH) frame in scope (above you on the stack). So, for example, if you write \"`try { f -reset } finally { }`\", then the problem will not repro. (You would think that addition of an empty `finally` block would have no effect, but it does: presence of the EH frame bypasses this bug.)\r\n\r\nFor this reason (to work around this bug), I always write a \"boiler plate\" `try { ` ... `} finally { }` in all my public/exported functions.\r\n",
      "created_at": "2021-07-06T20:10:45Z",
      "updated_at": "2021-07-06T20:10:45Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "Copying from the original email thread to here to bring us closer to a fix:\r\n\r\nSo I finally got a chance to look into this and I think it\u2019s basically a deep and subtle semantics bug in PowerShell\u2019s error handling (because errors in PowerShell are usually so simple\u2026).\r\n\r\nFirst of all, the way PowerShell handles a series of statements is pretty involved; [it sets up a state machine to execute each statement so that non-terminating errors can be resumed immediately](https://github.com/PowerShell/PowerShell/blob/6a21bcc96766a32888bfc8a1aa24e30e21877b8f/src/System.Management.Automation/engine/parser/Compiler.cs#L3128-L3161). The problem is that the sequence of events for a statement that throws is as follows:\r\n\r\n-\tExecute the statement, until it throws\r\n-\tJump to the catch block\r\n-\tCheck the EAP\r\n-\tDepending on that, continue or stop\r\n\r\nIf we imagine the statement that threw also sets the EAP in a finally block, we get this sequence:\r\n\r\n-\tExecute the statement until it throws\r\n-\tSet the EAP to the new value\r\n-\tJump to the catch block\r\n-\tCheck the EAP\r\n-\tDepending on that, continue or stop\r\n\r\nSo the question is: why does this only happen for parameter binding exceptions?\r\n\r\nWhen a non-terminating error is promoted to a terminating one, [it\u2019s reified as an ActionPreferenceStopException](https://github.com/PowerShell/PowerShell/blob/6a21bcc96766a32888bfc8a1aa24e30e21877b8f/src/System.Management.Automation/engine/MshCommandRuntime.cs#L2873-L2881) which [sets a property called SuppressPromptInInterpreter](https://github.com/PowerShell/PowerShell/blob/6a21bcc96766a32888bfc8a1aa24e30e21877b8f/src/System.Management.Automation/utils/ExecutionExceptions.cs#L574), which in turn [marks the exception as a terminating one](https://github.com/PowerShell/PowerShell/blob/6a21bcc96766a32888bfc8a1aa24e30e21877b8f/src/System.Management.Automation/engine/runtime/Operations/MiscOps.cs#L1940). Basically once an error has been made terminating, we mark it to stop checking the EAP when we see it and simply rethrow it up the callstack.\r\n\r\nHowever, a parameter binding exception is not promoted to an ActionPreferenceStopException, but instead is [thrown as a ParameterBindingException](https://github.com/PowerShell/PowerShell/blob/6a21bcc96766a32888bfc8a1aa24e30e21877b8f/src/System.Management.Automation/engine/CmdletParameterBinderController.cs#L878-L887). This bubbles up through a callstack that looks like this:\r\n\r\n![st](https://user-images.githubusercontent.com/7009879/126884286-234c862c-e2cc-450b-961f-75e87ac260f2.png)\r\n\r\nYou can see there are a number of stack frames under System.Management.Automation.Interpreter, which is the very opaque PowerShell interpreter. Essentially, the parameter binding exception occurs under [this compiler-generated call](https://github.com/PowerShell/PowerShell/blob/6a21bcc96766a32888bfc8a1aa24e30e21877b8f/src/System.Management.Automation/engine/parser/Compiler.cs#L3811), which in a try/finally block is [run by the EnterTryCatchFinallyInstruction](https://github.com/PowerShell/PowerShell/blob/6a21bcc96766a32888bfc8a1aa24e30e21877b8f/src/System.Management.Automation/engine/interpreter/ControlFlowInstructions.cs#L358). That thrown exception is then [caught](https://github.com/PowerShell/PowerShell/blob/6a21bcc96766a32888bfc8a1aa24e30e21877b8f/src/System.Management.Automation/engine/interpreter/ControlFlowInstructions.cs#L375) and [handled](https://github.com/PowerShell/PowerShell/blob/6a21bcc96766a32888bfc8a1aa24e30e21877b8f/src/System.Management.Automation/engine/interpreter/ControlFlowInstructions.cs#L392) by that [initial strange code the compiler generated for the state machine](https://github.com/PowerShell/PowerShell/blob/6a21bcc96766a32888bfc8a1aa24e30e21877b8f/src/System.Management.Automation/engine/parser/Compiler.cs#L3155) (the actual codegen for that is [here](https://github.com/PowerShell/PowerShell/blob/6a21bcc96766a32888bfc8a1aa24e30e21877b8f/src/System.Management.Automation/engine/parser/Compiler.cs#L3202-L3210)). That call ends up [back in that check to see if the exception is terminating](https://github.com/PowerShell/PowerShell/blob/6a21bcc96766a32888bfc8a1aa24e30e21877b8f/src/System.Management.Automation/engine/runtime/Operations/MiscOps.cs#L1652-L1655), but because [try/catch blocks set $ExecutionContext.PropagateExceptionsToEnclosingStatementBlock to true](https://github.com/PowerShell/PowerShell/blob/6a21bcc96766a32888bfc8a1aa24e30e21877b8f/src/System.Management.Automation/engine/parser/Compiler.cs#L5213-L5223) the binding error [is thrown](https://github.com/PowerShell/PowerShell/blob/6a21bcc96766a32888bfc8a1aa24e30e21877b8f/src/System.Management.Automation/engine/runtime/Operations/MiscOps.cs#L1937) before [it can be made intrinsically terminating](https://github.com/PowerShell/PowerShell/blob/6a21bcc96766a32888bfc8a1aa24e30e21877b8f/src/System.Management.Automation/engine/runtime/Operations/MiscOps.cs#L1667-L1676).\r\n\r\nSo if we were to fix this, how we would do that? This is pretty complicated and the kind of place where a small change could have unexpected consequences (like the changes that were clearly made here for ErrorAction = Inquire, which I believe introduced this corner case bug). I think the existing catch-and-check-EAP behaviour is right, so the change should happen in the [CheckActionPreference()](https://github.com/PowerShell/PowerShell/blob/6a21bcc96766a32888bfc8a1aa24e30e21877b8f/src/System.Management.Automation/engine/runtime/Operations/MiscOps.cs#L1601-L1687) method. The issue is that the ordering of the current checks is important because we might have the EAP changed by a trap or by EAP = Inquire. I think essentially we need to closely re-evaluate the logic there so that we:\r\n\r\n-\tCheck for traps\r\n-\tThen check to see if the error must be thrown (including checking if the EAP is Stop)\r\n-\tThen check for inquiry\r\n-\tThen continue with other behaviours\r\n\r\nBut all of this comes with the caveat that this is a long-standing corner case bug with a delicate fix, so correcting it might take some time and someone to champion it.",
      "created_at": "2021-07-25T00:56:26Z",
      "updated_at": "2021-07-25T00:56:26Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "/cc @bpayette would be interested in your thoughts here",
      "created_at": "2021-08-05T22:18:24Z",
      "updated_at": "2021-08-05T22:18:24Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> So the question is: why does this only happen for parameter binding exceptions?\r\n\r\nNot just parameter binding errors, but any general exceptions, such as a command-not-found error, exception thrown from an expression (e.g. 1/0), and exception thrown from a method invocation. For those error/exceptions, PowerShell treats them as non-terminating errors by default (with the default error action 'Continue'), unless they happen in a try block. When any of those errors/exceptions happens in a try block, it will be treated as a terminating error to that try block.\r\n\r\n```powershell\r\n## behave like a non-terminating error\r\nPS> & { 1/0; Write-Host 'after' }\r\nRuntimeException: Attempted to divide by zero.\r\nafter\r\n\r\n## when wrapped in try block, behaves like a terminating error within the try block\r\nPS> & { try { 1/0; Write-Host 'in try' } finally { Write-Host 'in finally' }; Write-Host 'after' }\r\nin finally\r\nRuntimeException: Attempted to divide by zero.\r\nafter\r\n\r\n## of course, when error action is 'Stop', behaves like a terminating error to the whole script\r\nPS:1> $ErrorActionPreference = 'stop'\r\nPS:2> & { 1/0; Write-Host 'after' }\r\nParentContainsErrorRecordException: Attempted to divide by zero.\r\nPS:3> & { try { 1/0; Write-Host 'in try' } finally { Write-Host 'in finally' }; Write-Host 'after' }\r\nin finally\r\nParentContainsErrorRecordException: Attempted to divide by zero.\r\n```\r\n\r\nYou did a good summary of how PowerShell handles errors for a statement block:\r\n>the sequence of events for a statement that throws is as follows:\r\n>\r\n>-\tExecute the statement, until it throws\r\n>-\tJump to the catch block\r\n> -\tCheck the EAP\r\n> -\tDepending on that, continue or stop\r\n> \r\n> If we imagine the statement that threw also sets the EAP in a finally block, we get this sequence:\r\n> \r\n> -\tExecute the statement until it throws\r\n> -\tSet the EAP to the new value\r\n> -\t**Jump to the catch block**\r\n> -\t**Check the EAP**\r\n> -\t**Depending on that, continue or stop**\r\n\r\nBack to the repro, the try statement will throw the general exception (from [here](https://github.com/PowerShell/PowerShell/blob/master/src/System.Management.Automation/engine/runtime/Operations/MiscOps.cs#L1652) because `ExecutionContext.PropagateExceptionsToEnclosingStatementBlock` will be set to `true` within a try block), and the EAP is set back to 'Continue', so the steps in **bold** above will find the EAP is 'Continue' and thus treat this general exception as a `non-terminating error`.\r\n\r\nA similar behavior will happen to `f -throw` as well, if EAP is set to `SilentlyContinue` or `Ignore` in the finally block. This is because for `throw` statement, the exception behaves as terminating error in the default error action ('Continue'), but it respects the `SilentlyContinue` and `Ignore` preference.\r\n```powershell\r\nfunction f\r\n{\r\n    param([switch] $reset )\r\n    try {\r\n        write-host EAP $ErrorActionPreference\r\n        $originalEAP = $ErrorActionPreference\r\n        $ErrorActionPreference = [System.Management.Automation.ActionPreference]::Stop\r\n\r\n        write-host throwing\r\n        throw 'error'\r\n\r\n        write-host continued try\r\n    }\r\n    finally\r\n    {\r\n        if ($reset) {\r\n            $ErrorActionPreference = 'SilentlyContinue'\r\n        }\r\n        write-host in finally\r\n    }\r\n\r\n    write-host after\r\n} \r\n\r\nPS:1> f\r\nEAP Continue\r\nthrowing\r\nin finally\r\nException:\r\nLine |\r\n  10 |          throw 'error'\r\n     |          ~~~~~~~~~~~~~\r\n     | error\r\n\r\nPS:2> f -reset\r\nEAP Continue\r\nthrowing\r\nin finally\r\nafter\r\n```\r\n\r\n------------------\r\n\r\nThe error handling in PowerShell has some subtle and not well known behaviors. We probably already see those behaviors a lot in other scenarios, but may never really notice the differences. I have summarized the error handling behaviors in the \"Error Handling\" section of the 'Clean' block RFC (https://github.com/PowerShell/PowerShell-RFC/pull/294).",
      "created_at": "2021-08-18T22:07:40Z",
      "updated_at": "2021-08-18T22:07:40Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "I'm not sure if we should call the reported behavior a bug.\r\n\r\nFor the repro script, the code to restore `$ErrorActionPreference` doesn't need to be put in a finally block. The setting of `$ErrorActionPreference` doesn't affect the value of `$ErrorActionPreference` in the outer scope, so if the script execution gets interrupted by any terminating exception after setting EAP to 'stop', `$ErrorActionPreference` in the outer scope will still have the original value.\r\n\r\nSo, given that, would the following change work for your scenario? @dl2n\r\n```powershell\r\nfunction f\r\n{\r\n    param( [switch] $throw, [switch] $write, [switch] $reset )\r\n\r\n    try {\r\n        ## <same code in try>\r\n        ....\r\n    }\r\n    finally\r\n    {\r\n        write-host in finally\r\n    }\r\n\r\n    ## Move this out from the finally block\r\n    if ($reset) {\r\n        $ErrorActionPreference = $originalEAP\r\n    }\r\n\r\n    write-host after\r\n} \r\n```",
      "created_at": "2021-08-18T22:17:43Z",
      "updated_at": "2021-08-18T22:32:39Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> I'm not sure if we should call the reported behavior a bug... `$ErrorActionPreference` doesn't need to be put in a finally block\r\n\r\nYeah, I see your point there that the `finally` is unneeded. **But**, to me this is a question of error semantics in PowerShell. When you throw an error, should it be overridable in some way by a state change afterward? Should it be different for different errors?\r\n\r\nI think the answer to the second part is pretty clearly *no*. But for the first part it's actually not so simple. Consider this:\r\n\r\n```powershell\r\nfunction f\r\n{\r\n    try\r\n    {\r\n        return 1\r\n    }\r\n    finally\r\n    {\r\n        return 2\r\n    }\r\n}\r\n```\r\n\r\nIt turns out this is a parse error in PowerShell... But in Python it's not:\r\n\r\n```python\r\ndef f():\r\n    try:\r\n        return 1\r\n    finally:\r\n        return 2\r\n\r\nf() # returns 2\r\n```\r\n\r\nAnd equivalently in PowerShell:\r\n\r\n```powershell\r\nfunction f\r\n{\r\n    try\r\n    {\r\n        throw 'bad'\r\n    }\r\n    finally\r\n    {\r\n        throw 'worse'\r\n    }\r\n}\r\n\r\nf     # throws 'worse'\r\n```\r\n\r\nSo we see here that a value that should leave the function in the try block can be altered in the finally block; the finally block truly is final. The question in my mind is: if we throw an error because the EAP was one value, then post-throw alter that value, should it affect the error we're still in the process of throwing?",
      "created_at": "2021-08-18T22:56:35Z",
      "updated_at": "2021-08-18T22:56:35Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> should it be overridable in some way by a state change afterward\r\n\r\nIt was not overridden. The check on EAP 'stop' wasn't even hit in `CheckErrorActionPreference` method for the `throw` case and the general exception case from the repro script. The EAP was hit in the `Write-Error` case, and as you observed, it cannot be overridden afterwards.\r\n\r\nOnce [the check on EAP 'stop' is hit in `CheckErrorActionPreference`](https://github.com/PowerShell/PowerShell/blob/176303d172bcb0726e097ac5139de9f724ecec6b/src/System.Management.Automation/engine/runtime/Operations/MiscOps.cs#L1667-L1676), the exception becomes a terminating error to the whole script and it cannot be overridden.\r\n\r\n> Should it be different for different errors?\r\n\r\nI'm sure there will be different opinions on the current error handling behaviors, especially the subtle ones. But it has been working in this way for a long time, and any change to the current behavior would unfortunately be breaking.\r\n\r\n> It turns out this is a parse error in PowerShell... But in Python it's not:\r\n\r\nIt's a compiling error in C# as well.\r\n\r\n> And equivalently in PowerShell:\r\n\r\nThat's the same behavior in C#.\r\n\r\n> So we see here that a value that should leave the function in the try block can be altered in the finally block; the finally block truly is final.\r\n\r\nAre you still referring to the exception overridden example from the finally block? PowerShell is using the same behavior as in C#.\r\n\r\n> The question in my mind is: if we throw an error because the EAP was one value, then post-throw alter that value, should it affect the error we're still in the process of throwing?\r\n\r\nAgain, the thing is in the repro script, **`throw` and the general exception were not thrown because of EAP is 'stop'** (they will throw even EAP is the default 'Continue'). The check on EAP 'stop' wasn't hit in those 2 cases until the execution leaves the try statement (where the EAP was already changed to 'Continue'). Once it's hit, the exception cannot be altered anymore -- it will be a terminating error to the whole script.\r\n\r\n----------------------------------------\r\n\r\nJust to add a bit more clarification:\r\nThe `throw` and the general exception were re-thrown from [here](https://github.com/PowerShell/PowerShell/blob/master/src/System.Management.Automation/engine/runtime/Operations/MiscOps.cs#L1652) because `ExecutionContext.PropagateExceptionsToEnclosingStatementBlock` gets set to `true` within a try block.",
      "created_at": "2021-08-18T23:23:46Z",
      "updated_at": "2021-08-18T23:42:59Z"
    },
    {
      "author": "dl2n",
      "author_association": "NONE",
      "body": "This observation is correct \u2013 the change to EAP does not need to be in the finally clause other than as a matter of semantic/cosmetic grouping.\n\nThe problem is the subtle landmine of code location which logically does not seem that it should matter at all. What is the overriding documentable behavior? That\u2019s what\u2019s most painful about this.\n",
      "created_at": "2021-08-19T00:25:07Z",
      "updated_at": "2021-08-19T00:25:09Z"
    }
  ],
  "created_at": "2021-07-06T18:32:13Z",
  "number": 15726,
  "state": "open",
  "title": "setting error action preference in finally clause affects terminating parameter binding errors",
  "updated_at": "2022-01-06T23:33:49Z"
}