{
  "_url": "https://github.com/PowerShell/PowerShell/issues/7626",
  "author": "alx9r",
  "body": "This came up during #7593 and #7530.  I _think_ the circumstances where this can occur is wherever all of the following happen:\r\n\r\n1. A scriptblock from one runspace is passed into another instance of the PowerShell class.\r\n2. The two PowerShell instances are invoked concurrently.\r\n3. Each PowerShell instance invokes the scriptblock.\r\n\r\nI'm not sure exactly what should happen when invoking a scriptblock that is bound to a SessionState from another runspace.  I guess I expected it to be cloned and bound to the session state that it found itself in, similar to scriptblocks produced using ScriptBlock.Create(). \r\n\r\nThis is a rather easy scenario to run into wherever there is interaction between runspaces within a process, though.  It seems like at least the crash should be prevented.\r\n\r\nSteps to reproduce\r\n------------------\r\n\r\n```PowerShell\r\n$scriptblock = {\r\n    function fibonacci {\r\n        param([int]$n)\r\n        [bigint]$a=0\r\n        [bigint]$b=1\r\n        foreach ($x in 0..$n)\r\n        {\r\n            $a,$b = $b,($a+$b)\r\n        }\r\n        $b\r\n    }\r\n    fibonacci 100000 | % {'complete'}\r\n}\r\n\r\n$invocations = 1..2 |\r\n    % {\r\n        $powershell = [powershell]::Create().\r\n            AddScript({. $args[0]}).\r\n            AddArgument($scriptblock)\r\n        @{\r\n            PowerShell = $powershell\r\n            Invocation = $powershell.BeginInvoke()\r\n        }\r\n    }\r\n$invocations |\r\n    %{ $_.PowerShell.EndInvoke($_.Invocation)}\r\n```\r\n\r\nExpected behavior\r\n-----------------\r\n\r\n```none\r\ncomplete\r\ncomplete\r\n```\r\n\r\nActual behavior\r\n---------------\r\n\r\nThis is the most verbose output I have witnessed.  The run ended in a \"PowerShell Core 6 has stopped working\" message box.\r\n\r\n```none\r\ncomplete\r\n% : Stack empty.\r\nAt C:\\users\\un1\\Desktop\\test.ps1:26 char:5\r\n+     %{ $_.PowerShell.EndInvoke($_.Invocation)}\r\n+     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n+ CategoryInfo          : NotSpecified: (:) [ForEach-Object], InvalidOperationEx\r\nception\r\n+ FullyQualifiedErrorId : System.InvalidOperationException,Microsoft.PowerShell.\r\nCommands.ForEachObjectCommand\r\n\r\n\r\nAn error has occurred that was not properly handled. Additional information is s\r\nhown below. The PowerShell process will exit.\r\n\r\nUnhandled Exception: System.InvalidOperationException: Stack empty.\r\n   at System.Collections.Generic.Stack`1.ThrowForEmptyStack()\r\n   at System.Collections.Generic.Stack`1.Pop()\r\n   at System.Management.Automation.DlrScriptCommandProcessor.OnRestorePreviousSc\r\nope()\r\n   at System.Management.Automation.CommandProcessorBase.DoComplete()\r\n   at System.Management.Automation.Internal.PipelineProcessor.DoCompleteCore(Com\r\nmandProcessorBase commandRequestingUpstreamCommandsToStop)\r\n   at System.Management.Automation.Internal.PipelineProcessor.SynchronousExecute\r\nEnumerate(Object input)\r\n   at System.Management.Automation.Runspaces.LocalPipeline.InvokeHelper()\r\n   at System.Management.Automation.Runspaces.LocalPipeline.InvokeThreadProc()\r\n   at System.Management.Automation.Runspaces.PipelineThread.WorkerProc()\r\n   at System.Threading.Thread.ThreadMain_ThreadStart()\r\n   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionCo\r\nntext, ContextCallback callback, Object state)\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n```\r\n\r\nEnvironment data\r\n----------------\r\n\r\n<!-- provide the output of $PSVersionTable -->\r\n\r\n```powershell\r\n> $PSVersionTable\r\n\r\nName                           Value\r\n----                           -----\r\nPSVersion                      6.1.0-preview.4\r\nPSEdition                      Core\r\nGitCommitId                    6.1.0-preview.4\r\nOS                             Microsoft Windows 6.3.9600 \r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "This is essentially the problem described in #4003. The current expected behavior is for an affinitized scriptblock to be executed in the runspace where it was created. This can only happen if the runspace is otherwise idle so the invocation is posted as an event to be invoked when the runspace becomes available. That said, it's no longer clear that this is the desired behavior. Some history: PSObject affinity was introduced in V1 so that objects returned from the runspace to the calling code could be evaluated by the calling code directly. PSObject affinity included script methods which included scriptblocks. In V2, I added an explicit affinity to scriptblocks so that invoking a scriptblock returned from a _module_  (i.e. a function exported from a module) would execute in the module context. So scriptblocks are tied to modules which are tied to runspaces thus it makes sense to do this cross runspace invocation. However for concurrent operation, this semantic doesn't work since execution ends up serializing on the invoking runspace. This is one of the areas I'm investigating for #6716.",
      "created_at": "2018-08-24T19:49:35Z",
      "updated_at": "2018-08-24T19:49:35Z"
    }
  ],
  "created_at": "2018-08-23T23:20:27Z",
  "number": 7626,
  "state": "open",
  "title": "Concurrently invoking a ScriptBlock in two runspaces causes InvalidOperationException and pwsh.exe termination",
  "updated_at": "2020-01-30T14:01:05Z"
}