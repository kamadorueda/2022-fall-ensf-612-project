{
  "_url": "https://github.com/PowerShell/PowerShell/issues/6966",
  "author": "mklement0",
  "body": "The filesystem has a number of special folders (a.k.a. known folders): usually preexisting folders that have special meaning to the OS.\r\n\r\nIt would be convenient to be able to target them in the abstract - both for convenience and for platform abstraction - similar to what .NET provides; e.g.:\r\n\r\n```powershell\r\n# E.g., on Windows:\r\nPS> [Environment]::GetFolderPath('Desktop')\r\nC:\\Users\\jdoe\\Desktop\r\n```\r\n\r\n`'Desktop'` translates to an enum value from the [`[Environment+SpecialFolder]`](https://docs.microsoft.com/en-us/dotnet/api/system.environment.specialfolder) enumeration.\r\n\r\n~~Supporting these enum values via a new `-SpecialFolder` (alias `-sf`) parameter natively in PowerShell would be handy:~~\r\n(Example removed.)\r\n\r\n_Update_:  A better way to surface this functionality is via a `sf:` or `SpecialFolder:` _drive_, which would enable the following syntax:\r\n\r\n```powershell\r\nSet-Location $sf:Desktop  # wishful thinking: changes to, e.g., C:\\Users\\jdoe\\Desktop\r\n$sf:Desktop  # wishful thinking; returns that path; short for: Get-Content sf:Desktop\r\n```\r\n\r\n\r\nEnvironment data\r\n----------------\r\n\r\nWritten as of:\r\n\r\n```powershell\r\nPowerShell Core v6.1.0-preview.2\r\n```\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Seems using a prefix for special folders is better UX then parameter. We can not use `~`, maybe `~~MyPictures`?",
      "created_at": "2018-05-31T15:28:30Z",
      "updated_at": "2018-05-31T15:28:30Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov:\r\n\r\nI know that `-SpecialFolder` (or `-SpecialDirectory`, given that PowerShell uses the term _directory_) is lengthy, but the `-sf` alias would mitigate that.\r\n\r\n`~~MyPictures` is, at least hypothetically, a breaking change, because nothing stops you from creating a folder literally named `~~MyPictures`.\r\n(Note that POSIX-like shells support `~<username>` as a shortcut for referring to a different user's home folder (but only if used _unquoted_), but it's an obscure feature that I don't think is worth adopting in PowerShell.)\r\n\r\nMore generally, the meaning of `~` is relative to the provider underlying the _current location_ and therefore generally not suitable to unconditionally refer to a filesystem location.\r\n\r\nA more PowerShell-like solution would be to:\r\n\r\n* Implement a SpecialFolder drive provider that exposes, say, drive `sf:`, \r\n\r\n* which would then allow you to use namespace notation to access its items; e.g., \r\n`Set-Location $sf:MyPictures`",
      "created_at": "2018-05-31T16:10:02Z",
      "updated_at": "2018-05-31T16:10:02Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "Also, `cd ~\\pictures` is less to type.  Ditto with `cd ~\\desktop`.  With tab completion there is even less to type `cd ~\\de<tab>`.  ",
      "created_at": "2018-05-31T16:28:05Z",
      "updated_at": "2018-05-31T16:28:05Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@rkeithhill:\r\n\r\nYes, but that (a) already works and (b) only if the current location is a filesystem location.\r\n\r\nWhile in a filesystem location, `~` is a convenient shortcut (that, unfortunately, is not fully semantically equivalent with (unquoted) `~` in POSIX-like shells such as `bash` due to its current-location sensitivity).\r\n\r\nThe stated limitation aside, you can therefore think of `~` as the _one_ special-folder shorthand in PowerShell that is already available, and for other special folders that _happen to be_ in the home folder's _subtree_, something like `~/Desktop` works well.\r\n\r\nHowever, just like `~` is a useful abstraction - it may refer to, say, `C:\\Users\\jdoe`, `/home/jdoe`, or `/Users/jdoe`, for instance - having abstractions for other well-known folders is equally useful, and that's where the special folders come in.\r\n\r\nFor instance, the `ApplicationData` special folder is something like `C:\\Users\\jdoe\\AppData\\Roaming` on Windows, and `$env:HOME/.config` on Unix-like platforms.\r\n\r\nEven `~` has its conceptual limitations: as @iSazonov  pointed out in https://github.com/PowerShell/PowerShell/issues/6791#issuecomment-393465147, you can think of `~` on _Unix_ corresponding to `~\\Documents` on _Windows_, given that Windows discourages creating user content directly in the profile folder;  \r\nUnlike, `~`, the `MyDocuments` (alias: `Personal`) special folder provides exactly this abstraction: it returns  the equivalent of `~` (`$HOME`) on Unix, and `~/Documents` on Windows.\r\n\r\nThe `~` shorthand doesn't scale well: something like `~~MyDocuments` and `~MyDocuments`, as stated, is a breaking change, but, perhaps more importantly, it would be self-contradictory in the case of _user-independent_ folders, such as `CommonApplicationData` (which is `C:\\ProgramData` on Windows, and `/usr/share` on Unix).\r\n",
      "created_at": "2018-05-31T17:02:35Z",
      "updated_at": "2018-05-31T17:02:35Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "> but that (a) already works\r\n\r\nYup, I'm questioning the value of the proposed feature.\r\n\r\n> the ApplicationData special folder is something like C:\\Users\\jdoe\\AppData\\Roaming on Windows, and $env:HOME/.config on Unix-like platforms.\r\n\r\nTrying to map Windows oriented locations to *nix doesn't sound like a good idea to me.",
      "created_at": "2018-05-31T17:37:03Z",
      "updated_at": "2018-05-31T17:37:03Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> ~~MyPictures is, at least hypothetically, a breaking change, because nothing stops you from creating a folder literally named ~~MyPictures.\r\n\r\nWhy stops? We can use escaping and LiteralPath. \r\nSeems on Unix the ~ is valid name too. And all the other options too.\r\nI think we could enhance ~ and use ~CommonApplicationData.\r\n\r\n> Trying to map Windows oriented locations to *nix doesn't sound like a good idea to me.\r\n\r\nThis has already been implemented in CoreFX and PowerShell Core.",
      "created_at": "2018-05-31T17:46:22Z",
      "updated_at": "2018-05-31T17:46:22Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "> This has already been implemented in CoreFX and PowerShell Core.\r\n\r\nWell, except that a lot of those enumeration values don't make sense on Linux/macOS.  As such, most of those enumerations result in empty string results:\r\n```posh\r\n17:16ms>  $ht = @{}; [Enum]::GetValues('System.Environment+SpecialFolder') | % { $ht[$_] = [Environment]::GetFolderPath($_) }; $ht\r\n\r\nName                           Value\r\n----                           -----\r\nCDBurning\r\nCommonOemLinks\r\nLocalizedResources\r\nResources\r\nCommonVideos\r\nCommonPictures\r\nCommonMusic\r\nAdminTools\r\nCommonAdminTools\r\nCommonDocuments\r\nCommonTemplates\r\nCommonProgramFilesX86\r\nCommonProgramFiles\r\nProgramFilesX86\r\nSystemX86\r\nUserProfile                    /home/hillr\r\nMyPictures\r\nProgramFiles\r\nSystem\r\nWindows\r\nCommonApplicationData          /usr/share\r\nHistory\r\nCookies\r\nInternetCache\r\nLocalApplicationData           /home/hillr/.local/share\r\nPrinterShortcuts\r\nApplicationData                /home/hillr/.config\r\nCommonDesktopDirectory\r\nCommonStartup\r\nCommonPrograms\r\nCommonStartMenu\r\nTemplates\r\nFonts\r\nNetworkShortcuts\r\nMyComputer\r\nDesktopDirectory\r\nMyVideos\r\nMyMusic\r\nStartMenu\r\nSendTo\r\nRecent\r\nStartup\r\nFavorites\r\nMyDocuments                    /home/hillr\r\nPrograms\r\nDesktop\r\n```\r\nConsequently, this would be a Windows-centric feature IMO.",
      "created_at": "2018-05-31T18:27:38Z",
      "updated_at": "2018-05-31T18:27:38Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@rkeithhill:\r\n\r\n> Yup, I'm questioning the value of the proposed feature.\r\n\r\nOn  a meta note: If opposing the cross-platform nature of the feature was your argument to begin with, can I ask you to cut out the \"middle comment\" in the future? \"Also, cd `~\\pictures` is less to type...\" doesn't quite convey that argument, and my lengthy response wouldn't have been necessary (though it's hopefully of interest for the bigger picture).\r\n\r\nAs @iSazonov's statement implies, CoreFx sees value in the feature, given that an explicit decision was made to include it on non-Windows platforms:\r\n\r\nIt is useful for the same reasons that it has always been useful, even while it was Windows-only, working across Windows versions and configuration variations: it provides _reliable abstractions_, given that hard-coded paths may fail.\r\n\r\n**In a _cross-platform_ world, abstractions are even more important to refer to _conceptually equivalent locations_**, IF such equivalents exists, because special-casing determination of the value for each platform in cross-platform code is obviously very cumbersome.\r\n\r\nA related conversation was the need for a platform-abstracted version of the `%TEMP%` Windows environment variable - see #4216\r\n(Again, CoreFx has led the way there with `[System.IO.Path]::GetTempPath()`. As an aside: arguably, the temporary-files location too should be a special folder, which it currently isn't.)\r\n\r\n> Well, except that a lot of those enumeration values don't make sense on Linux/macOS.\r\n\r\nTrue, many special folders only make sense only on Windows, but, fortunately, **CoreFx has already done the work for us by identifying the ones that _do_ make sense across platforms**: returning  an _empty string_ is `[Environment]::GetFolderPath()`'s way of telling us that equivalent locations do _not_ exist.\r\n\r\nWhen authoring cross-platform code, there is no way around knowing what subset makes sense.\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2018-05-31T19:22:36Z",
      "updated_at": "2020-11-19T21:40:27Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "@rkeithhill \r\n> Consequently, this would be a Windows-centric feature IMO.\r\n\r\nIndeed, and since it hasn't really come up much in over a decade of _Windows_ PowerShell (it's been proposed but there wasn't much interest), I'm not sure it adds much value. Most of the interesting folders are more conveniently available off ~.  But I suppose it wouldn't hurt.\r\n\r\n@mklement0 \r\n> While in a filesystem location, ~ is a convenient shortcut (that, unfortunately, is not fully semantically equivalent with (unquoted) ~ in POSIX-like shells such as bash due to its current-location sensitivity).\r\n\r\nIn what way is it not fully semantically equivalent? Do you mean the fact that it takes you to the home location on the current drive?\r\n\r\n>  you can think of ~ on Unix corresponding to ~\\Documents on Windows, given that Windows discourages creating user content directly in the profile folder;\r\n\r\nThese days, most Linux distros as well as MacOS use the same folder structure as Windows, with Documents directory, Pictures, Movies,  etc. So ~ in *sh and ~ in PowerShell are pretty much equivalent. \r\n\r\n",
      "created_at": "2018-05-31T19:22:36Z",
      "updated_at": "2018-05-31T19:22:36Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@BrucePay:\r\n\r\n> Indeed, and since it hasn't really come up much in over a decade of Windows PowerShell (it's been proposed but there wasn't much interest)\r\n\r\nOn Windows, you could typically get away with (semi-)hard-coded paths.\r\nIn a cross-platform world, that's no longer an option, so the special-folder abstractions become more valuable. \r\n\r\n> In what way is it not fully semantically equivalent? Do you mean the fact that it takes you to the home location on the current drive?\r\n\r\nYes: If you come from a Unix background and expect `cd ~\\Desktop` to _always_ take you to `$HOME\\Desktop`, you'll be surprised:\r\n\r\n```powershell\r\nPS> Set-Location Alias:\r\nPS Alias:/> cd ~\\Desktop  # boom\r\ncd : Home location for this provider is not set. To set the home location, call \"(get-psprovider 'Alias').Home = 'path'\".\r\n...\r\n```\r\n\r\n> These days, most Linux distros as well as MacOS use the same folder structure as Windows, with Documents directory, Pictures, Movies, etc. So ~ in *sh and ~ in PowerShell are pretty much equivalent.\r\n\r\nFortunately, yes (though CoreFx has chosen to consider just `~` the equivalent of Windows `~/Documents` via `[Environment]::GetFolderPath('MyDocuments'`, but that wouldn't affect explicit use of `~/Documents`).\r\n\r\nHowever, as implied by the above, scripts should only ever use `$HOME`, not `~` , in order to _reliably_ refer to the user's home folder.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2018-05-31T19:38:07Z",
      "updated_at": "2018-05-31T19:44:33Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov:\r\n\r\n> Why stops? We can use escaping and LiteralPath.\r\n\r\nUnlike in POSIX-like shells, where the _shell_ expands `~`, and _only if unquoted_, `~` in PowerShell _is_ a literal path, and it is _up to the target provider_ to interpret it; the following statements are all equivalent:\r\n\r\n```powershell\r\nSet-Location ~    # implied -Path\r\nSet-Location '~'  # ditto, with quoting\r\nSet-Location -LiteralPath ~\r\nSet-Location -LiteralPath '~'\r\n```\r\n\r\n",
      "created_at": "2018-05-31T19:42:43Z",
      "updated_at": "2018-05-31T19:42:57Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "I think the idea of a special PSDrive is a really good one",
      "created_at": "2018-05-31T21:28:22Z",
      "updated_at": "2018-05-31T21:28:22Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 \r\n> Yes: If you come from a Unix background and expect cd ~\\Desktop to always take you to $HOME\\Desktop, you'll be surprised:\r\n\r\nComing from a Unix/POSIX background, I'll admit that this was a decision I was not thrilled with. We have considered changing it a few times but did not. I wish we'd done it for 6.0. \r\n\r\n> Unlike in POSIX-like shells, where the shell expands ~\r\n\r\nTrue. There is a difference in layers and responsibilities. The upside is this allows us to glob against things like processes without needing to quote. \r\n\r\n> On Windows, you could typically get away with (semi-)hard-coded paths.\r\nIn a cross-platform world, that's no longer an option, so the special-folder abstractions become more valuable.\r\n\r\nThe whole reason for special folders on Windows is because it `wasn't` possible to have hard-code paths. For example, it used to be recommended that you have your documents on a different drive than the system. This sort of thing necessitated redirection. Unix, on the other hand, has been pretty consistent with directory naming (/etc is always /etc). And the various distributions seem to have settled on more or less the same set of user directories. \r\n\r\n> Fortunately, yes (though CoreFx has chosen to consider just ~ the equivalent of Windows ~/Documents via [Environment]::GetFolderPath('MyDocuments', but that wouldn't affect explicit use of ~/Documents).\r\n\r\nI didn't quite follow this. `~` processing is a PowerShell thing, not a Windows or CoreFX thing. At least I'm not aware of them doing anything with `~`.\r\n\r\n@iSazonov  \r\n>  We can not use ~, maybe ~~MyPictures?\r\n\r\nActually that's pretty much the proposal @JamesWTruher and I had way back in V1. `~/<directory>` would have been relative to the home directory but `~documents`, `~ApplicationData` etc. would have been the special folders,  And something like `~ApplicationData/npm` would be a special-folder relative path.  The nice thing with this approach is that you could allow user-defined short cuts e.g. `~src` or `~test/scripts`.\r\n\r\n\r\n",
      "created_at": "2018-05-31T23:53:47Z",
      "updated_at": "2018-05-31T23:53:47Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": ">These days, most Linux distros as well as MacOS use the same folder structure as Windows, with Documents directory, Pictures, Movies, etc. So ~ in *sh and ~ in PowerShell are pretty much equivalent.\r\n\r\nSo I expect that CoreFX will map special folder name wider. Any ported music player can use \"MyMusic\" special folder on any platform.\r\n\r\nOther thoughts about ~.\r\n- I don't like that it conflict with Unix ~user. Can we use another prefix? \r\n- If we look Windows applications like SCCM (system center configuration manager) or GPP (group policy preferences) they use internally %specialfolder% format.\r\nCoreFX has `Environment.ExpandEnvironmentVariables` to expand environment variables and\r\n`Environment.GetFolderPath()` to expand special folder names in paths.\r\nAlso in cmd.exe  `dir %temp%` works but not in PowerShell.\r\nDo we want both expansions to work in PowerShell?",
      "created_at": "2018-06-01T06:18:58Z",
      "updated_at": "2018-06-01T06:18:58Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@BrucePay:\r\n\r\n> For example, it used to be recommended that you have your documents on a different drive than the system. This sort of thing necessitated redirection. \r\n\r\nOn a related note: It looks like what PowerShell reports as `$HOME` is `%USERPROFILE%`, which is _typically_, but not necessarily the same as `%HOMEDRIVE%%HOMEPATH%`; the former is the roaming part of the user profile and the latter is where the user's personal _files_ go.\r\n\r\nIf they do differ, something like `~/Desktop` will not work as intended.\r\n\r\nSo, given that redirection (abstract locations whose machine-specific instantiation is obtained programmatically) is still a necessity in the Windows world, it doesn't even help that Linux distros have standardized locations such as `~/Desktop` - for reliable operation you still need the redirection.\r\n\r\n---\r\n\r\n> I didn't quite follow this. ~ processing is a PowerShell thing, not a Windows or CoreFX thing. At least I'm not aware of them doing anything with ~\r\n\r\nI was using `~` merely as shorthand alias for `$HOME` (Unix) and `%HOMEDRIVE%%HOMEPATH%` (Windows) in my example (I'll call both `$HOME` below).\r\n\r\nI was trying to point out that if you ask the .NET API for the path to the user's documents -  `[Environment]::GetFolderPath('MyDocuments')`:\r\n\r\n* you get `$HOME` _itself_ on Unix\r\n* you get `$HOME\\Documents` on Windows\r\n\r\nIn other words: from the perspective of CoreFx, location `$HOME/Documents` -  even though it does _exist_ on all platforms - is not considered _equivalent_ across platforms.\r\n\r\n---\r\n\r\nTo summarize:\r\n\r\nThe upshot:\r\n\r\n* Even Windows-only scripts benefit from using abstractions, because something like `~\\Desktop` or `$HOME\\Desktop` doesn't always work.\r\n\r\n* Fully cross-platform scripts are limited to a relatively  small subset of the special folders.\r\n\r\n* More abstractions become available for scripts that target Windows + macOS, or Windows + Linux only.\r\n\r\nSpecifically,  here is the list of **which special folders are defined on what platforms**:\r\n\r\n* **Windows:** Since the feature originated there, _all_ special folders are defined.\r\n\r\n* **Shared** - defined on _all_ platforms (note: `Desktop` and `DesktopDir`, though technically distinct, seem to refer to the same location in practice; the former is distinguished from the latter as being the \"logical Desktop rather than the physical file system location\" - not sure what that means).\r\n\r\n  * `ApplicationData`\r\n  * `CommonApplicationData`\r\n  * `Desktop`\r\n  * `DesktopDirectory`\r\n  * `LocalApplicationData`\r\n  * `MyDocuments`\r\n  * `MyMusic`\r\n  * `MyPictures`\r\n  * `UserProfile`\r\n\r\n* additionally, **unique to macOS** (not also on Linux)\r\n\r\n  * `Favorites`\r\n  * `Fonts`\r\n  * `InternetCache`\r\n  * `ProgramFiles`\r\n  * `System`\r\n\r\n* additionally, **unique to Linux** (not also on macOS)\r\n\r\n  * `MyVideos`\r\n  * `Templates`\r\n\r\nThe above was obtained with a modified version of @rkeithhill's helpful command:\r\n\r\n```powershell\r\n$ht = @{}; [Enum]::GetValues([Environment+SpecialFolder]) | % { $ht[$_] = [Environment]::GetFolderPath($_) }; $ht.getEnumerator() | ? Value | Sort-Object {[string] $_.key}\r\n```\r\n",
      "created_at": "2018-06-01T13:37:06Z",
      "updated_at": "2018-06-03T17:09:22Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Re syntax:\r\n\r\n> Can we use another prefix?\r\n> And something like `~ApplicationData/npm` would be a special-folder relative path. \r\n\r\nGenerally, using a special symbol (prefix) - while conveniently concise - is arcane (something you'd expect from Perl, not from PowerShell), even though it builds on a well-known symbol in the _Unix_ world.\r\n   * Also, as stated, given the established meaning of `~` as the _user's_ home folder, something like `~ProgramFiles` - a user-independent location - is self-contradictory.\r\n   * (The `~<username>` syntax in shells such as `bash` is a more natural extension of `~`, but is not widely used.)\r\n\r\nSimilarly, we should stay away from `%specialfolder%`, given that it looks like `cmd.exe`'s environment variables, whereas PowerShell uses `$env:<name>` to surface environment variables.\r\n\r\nBy contrast, using _namespace notation_ still allows for concision while using established PowerShell idioms; e.g.:\r\n\r\n```powershell\r\nSet-Location $sf:Desktop  # tab-completion would work too\r\n```\r\n\r\nImplementing a _provider_ just for this purpose may seem heavy-handed, but doing so is currently a prerequisite for namespace notation.\r\n\r\nSo, the wider question is: perhaps we should support defining namespaces in a more lightweight manner, without needing to implement a full-blown drive provider?\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2018-06-01T13:58:15Z",
      "updated_at": "2018-06-01T13:58:15Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 Thanks! I always like your analysis.\r\n\r\nI like the idea. Only without `$`\r\n```powershell\r\nSet-Location SpecialFolder:Desktop # full name\r\nSet-Location sf:Desktop  # short name\r\n```\r\n\r\n>the wider question is: perhaps we should support defining namespaces in a more lightweight manner, without needing to implement a full-blown drive provider?\r\n\r\nSeems currently no - this will require the alteration of internal interfaces. We have a similar request for providers.\r\nHowever, we could implement this new drive even today :-) - we only need RFC. It was great if you did. Seems it will be very short.\r\n\r\nAlso I would not leave without attention my question about environment variables. They are often used in other shells. We should think about how to use them more easily in PowerShell.\r\n\r\n",
      "created_at": "2018-06-01T14:44:56Z",
      "updated_at": "2018-06-01T14:46:20Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @iSazonov; similarly, I appreciate your tireless efforts and countless contributions.\r\n\r\nOn second thought, you're right: implementing a drive provider is the way to go, and the right solution is to make _implementing_ one more \"lightweight\", i.e.: easier: #5789.\r\n\r\nAs for how that new drive's items must be accessed, let me start with environment variables, because how they are surfaced exemplifies how I think the special folders should be surfaced too:\r\n\r\n> Also I would not leave without attention my question about environment variables. They are often used in other shells. We should think about how to use them more easily in PowerShell.\r\n\r\nI think that PowerShell's way of exposing environment variables works fine and is sufficient:\r\n\r\n* The `env:` drive enumerates all environment variables (e.g., `(Get-Item Env:PATH).Value` reports the value of environment variable `PATH`)\r\n\r\n* The generic namespace-notation feature therefore allows accessing these items using, e.g., `$env:PATH`; in other words: `$<drive-name>:<item-name>` is the concise (and presumably more efficient) equivalent of `(Get-Item <drive-name>:<item-name>).Value`)\r\n\r\nNamespace notation makes for a concise, yet friendly notation that supports tab completion and even direct embedding in expandable strings (without the need for enclosing `$(...)`); e.g.:\r\n`\"PATH: $env:PATH\"`\r\n\r\nIt's a powerful concept, and even though use of the `$env:` namespace is widespread  - because it's the simplest way to access environment variables -  my sense is that not many people know how generic the underlying mechanism is.\r\n\r\nIf we implement a `SpecialFolders` drive provider and surface the special folders via a new drive named `sf:` (we could name it `SpecialFolder:`, but note that there's no concept of drive-name aliases, so from what I understand, if we wanted to support both `sf:` and `SpecialFolder:`, we'd have to define _two_ drives), accessing it via namespace notation looks the way I proposed:\r\n\r\n```powershell\r\nSet-Location $sf:Desktop \r\n```\r\n\r\n~~That would actually obviate the need to extend `Get-Location`, because`Get-Item sf:Desktop`~~ `Get-Content sf:Desktop` would be sufficient - or simply `$sf:Desktop` by itself.\r\n\r\nBy contrast, the syntax you propose would _break_:\r\n\r\n```powershell\r\nSet-Location sf:Desktop   # !! breaks, if sf: is not a file-system provider drive\r\n```\r\n\r\nThis would attempt to navigate to the `sf:` drive's `Desktop` _container_, but `Desktop` isn't a container: it's a _leaf-type item_ analogous to _files_ in the filesystem provider. [_update_: see [below](https://github.com/PowerShell/PowerShell/issues/6966#issuecomment-663890154)]\r\n\r\n(Similarly, `Set-Location Env:PATH` breaks, as would analogous call for all _non-hierarchical_ providers that have just _one_ level of invariably leaf-type items, namely: `Alias:`, `Function:`, `Variable:` - the only path you can navigate to on drives of such providers is the _root_ location; e.g., `Set-Location Env:`.)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2018-06-01T22:02:03Z",
      "updated_at": "2020-07-25T20:45:50Z"
    },
    {
      "author": "Praful",
      "author_association": "NONE",
      "body": "This may be related. I've just installed PowerShell 6.1.2 and when I `cd \\Users\\<user>\\Desktop`, I can't create a folder using `mkdir test`. I can with PowerShell 5.1.17763.124. This is with and without admin access.\r\n\r\nThe error is:\r\n\r\n````\r\n\u25b6 $error[0] |fl * -f\r\n\r\n\r\nwriteErrorStream      : True\r\nPSMessageDetails      :\r\nException             : System.IO.FileNotFoundException: Could not find file\r\n                        'C:\\users\\praful\\Desktop\\test'.\r\n                        File name: 'C:\\users\\praful\\Desktop\\test'\r\n                           at System.IO.FileSystem.CreateDirectory(String fullPath)\r\n                           at System.IO.Directory.CreateDirectory(String path)\r\n                           at Microsoft.PowerShell.Commands.FileSystemProvider.Creat\r\n                        eDirectory(String path, Boolean streamOutput)\r\nTargetObject          : C:\\users\\praful\\Desktop\\test\r\nCategoryInfo          : WriteError: (C:\\users\\praful\\Desktop\\test:String)\r\n                        [New-Item], FileNotFoundException\r\nFullyQualifiedErrorId : CreateDirectoryIOError,Microsoft.PowerShell.Commands.NewItem\r\n                        Command\r\nErrorDetails          :\r\nInvocationInfo        : System.Management.Automation.InvocationInfo\r\nScriptStackTrace      : at <ScriptBlock><Process>, <No file>: line 52\r\n                        at <ScriptBlock>, <No file>: line 1\r\nPipelineIterationInfo : {0, 1}\r\n````\r\n\r\nMaking a directory in `\\Users\\<user>` works. The problems seems to be with the special folders (Desktop, Favourites, Documents, etc) on Windows 10 1809.\r\n\r\nHas something changed?!",
      "created_at": "2019-02-10T16:35:07Z",
      "updated_at": "2019-02-10T16:47:04Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@Praful Please open new Issue with repo steps.",
      "created_at": "2019-02-10T17:14:24Z",
      "updated_at": "2019-02-10T17:14:24Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 Is the discussion ready for PowerShell Committee review? Could you please summorize the discussion?",
      "created_at": "2019-02-10T17:15:37Z",
      "updated_at": "2019-02-10T17:15:37Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for the follow-up, @iSazonov: Yes, I think it's ready; to summarize, the proposal is:\r\n\r\nProvide convenient cross-platform abstractions for well-known folders in a PowerShell-idiomatic manner by surfacing the functionality of [`[Environment]::GetFolderPath()`](https://docs.microsoft.com/en-us/dotnet/api/system.environment.getfolderpath) via namespace variable notation `$sf:<known-folder-name>`, where `sf` stands for _special folder_ and  `<known-folder-name>` is an [`Environment.SpecialFolder`](https://docs.microsoft.com/en-us/dotnet/api/system.environment.specialfolder) enum value - e.g., `$sf:Desktop` would be the equivalent of `[environment]::GetFolderPath('Desktop')`\r\n\r\nNote: Not all well-known folders exist on all platforms - see the bottom section of [this comment](https://github.com/PowerShell/PowerShell/issues/6966#issuecomment-393882898) for details; if they don't, `[Environment]::GetFolderPath()` returns the _empty string_ (e.g., `[environment]::GetFolderPath('CDBurning')` on macOS); we could mirror that practice.\r\n\r\nTo that end:\r\n\r\n* Implement a non-hierarchical, read-only provider that implements the `IContentCmdletProvider` interface and whose items are named for the [`Environment.SpecialFolder`](https://docs.microsoft.com/en-us/dotnet/api/system.environment.specialfolder) enumeration values and whose content is the value of passing their name to [`[Environment]::GetFolderPath()`](https://docs.microsoft.com/en-us/dotnet/api/system.environment.specialfolder)\r\n\r\n* Define a drive named `sf` for that provider.\r\n\r\nAs an optional extension to the proposal above:\r\n\r\n* Accept an additional enum value named, say, `Temp`, to return the platform-specific path to the folder for temporary files that surfaces the value of  `[System.IO.Path]::GetTempPath()`, PowerShell currently has no analog - see #4216; support for `$sf:Temp` would resolve that.\r\n",
      "created_at": "2019-02-11T22:48:46Z",
      "updated_at": "2019-02-11T22:50:08Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@SteveL-MSFT The issue is ready for reviewing by PowerShell committee.",
      "created_at": "2019-02-12T03:56:12Z",
      "updated_at": "2019-02-12T03:56:12Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee started discussing this but didn't reach a conclusion.  One proposal that came up is a folder under `env:` rather than a new PSDrive.  So it would look like `env:/SpecialFolder/Fonts`, for example.  Although `SpecialFolders` are not environment variables, they are folders that are part of the user's environment, so conceptually, it works.  ",
      "created_at": "2019-02-21T04:17:27Z",
      "updated_at": "2019-02-21T04:17:27Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I wouldn't recommend that. Requiring slash separators to access them means that accessing them as though they were variables (like you can with $env:TEMP) becomes cumbersome. Not everyone is aware of braced syntax for variables, after all, it's a bit of a niche thing.\r\n\r\nIt appears the intent here is to make it easier to access these folders, and I don't think burying it in a special subtree of Env: makes any sense towards that end. Everything else in there is single-level, a flat one-dimensional array of strings, effectively... Unless there are further plans to abstract that drive to increase usability and make it more robust as a whole, I very much doubt that creating a special case here will help anything.",
      "created_at": "2019-02-21T05:10:24Z",
      "updated_at": "2019-02-21T05:11:04Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "SpecialFolder-s is still not environment variables.",
      "created_at": "2019-02-21T14:33:12Z",
      "updated_at": "2019-02-21T14:33:12Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "@vexx32 to reiterate some of the concern I had last week, it was really around how people have mentally mapped `$env` in their head. To me (and I'd expect most of the community as well) `$env` and the Environment provider == \"environment variable\". According to @JamesWTruher, `$env` was really supposed to contain any useful information about the environment, more akin to `[System.Environment]` which would then rightfully include the special folders. \r\n\r\nI argued that the original intent is likely not clear to users and that it would make sense to distinguish from `$env` in some way, and was more in favor of something like `$sf`, but that means we need a PSDrive, or it'll be an automatic variable. As @mklement0 argued above, we also felt that a PSDrive would be a little heavy-handed, and it's especially wonky to me because these aren't settable items. You're just accessing some read-only values from the system. \r\n\r\nIf it's an automatic variable, then we have to special-case it as one that somehow parses `:foo`. From an \"I can see what's going on under the hood\" perspective, this is wonky too. I know we have lots of magic in PowerShell, but we're doing our best not to add more (cue people calling me out for wanting magic in the `PSModulePath` RFC :) )\r\n\r\nSo that's why we landed in a place where we wanted to move towards the original intent: to move more information about the environment into the Environment provider. In the future, we could want more there beyond special folders, and it would make sense to set a precedent for that now so we're not arguing for more read-only providers in the future.\r\n\r\nAdditionally, I'd argue that this is feature is way more cross-platform abstraction than it is about ease of typing. There's all sorts of ways you can alias folders you care about to shorthand for your interactive sessions, but this is more about providing a way for PS users to natively abstract these special folders (whether it's cross-platform the ones that happen to have values defined on Linux, as well as to mitigate potentially weird folder locations within pure Windows environments). \r\n\r\nOut of curiosity, is there any reason no one raised a `Get-SpecialFolder` cmdlet? Are there some parse vs. runtime concerns that crop up if we go that route? (Upon which everyone could just alias it to `gsf` or something so that e.g. `(gsf TEMP)` just works.)",
      "created_at": "2019-02-27T18:08:53Z",
      "updated_at": "2019-02-27T18:08:53Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Hm. A cmdlet has a bit more overhead than a provider or some such, but otherwise I see nothing wrong with it.\r\n\r\nI think I can understand that perspective with the Environment PSProvider. The biggest thing at the moment is that it doesn't currently appear to support anything like a container node -- trying to create `Env:\\MyThing\\Var` at the moment (from memory, at least) creates just a single item named `MyThing\\Var`, doesn't it?\r\n\r\nI have no qualm with _changing_ that and making it work, though. Easy access to special folders would be lovely! \ud83d\ude04 ",
      "created_at": "2019-02-27T18:16:56Z",
      "updated_at": "2019-02-27T18:17:24Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": ">To me (and I'd expect most of the community as well) $env and the Environment provider == \"environment variable\".\r\n\r\nHow resolve this? [Docs](https://github.com/MicrosoftDocs/PowerShell-Docs/blob/170a2ed2acb93d0171b844e2afbde5a54baa1f19/reference/3.0/Microsoft.PowerShell.Core/About/about_Environment_Provider.md) says \r\n```\r\nProvides access to the Windows environment variables.\r\n```\r\nAnd we have a conflict - all env variables is in root of the namespace although I would expect:\r\n```\r\n$env:/specialfolders/\r\n$env:/variables/system/\r\n$env:/variables/user/\r\n$env:/computerinfo/\r\n$env:/osinfo/\r\n```\r\nthis look like /proc in Linux.",
      "created_at": "2019-02-27T18:24:44Z",
      "updated_at": "2019-02-28T05:04:56Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee reviewed this, we would also be ok with cmdlets for `Get-SpecialFolder`",
      "created_at": "2019-02-27T23:24:16Z",
      "updated_at": "2019-02-27T23:24:16Z"
    },
    {
      "author": "sba923",
      "author_association": "CONTRIBUTOR",
      "body": "> @PowerShell/powershell-committee reviewed this, we would also be ok with cmdlets for Get-SpecialFolder\r\n\r\nIMO the provider approach (i.e. ``sf:MyPictures``) would make for less typing.",
      "created_at": "2019-08-04T09:25:00Z",
      "updated_at": "2019-08-04T09:25:00Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> This would attempt to navigate to the `sf:` drive's `Desktop` _container_, but `Desktop` isn't a container: it's a _leaf-type item_ analogous to _files_ in the filesystem provider.\r\n\r\n`TEMP:` is a container now, why can\u2019t `sf:Desktop` be?",
      "created_at": "2020-07-25T18:22:35Z",
      "updated_at": "2020-07-25T18:22:35Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I phrased that poorly:\r\n\r\nThe idea is for `$sf:Desktop` (which is the implicit equivalent of `Get-Content sf:Desktop` - not `Get-Item sf:Desktop`) to directly return a _native path string_ that represents the platform-specific Desktop folder, so that you can use it _directly_ in arguments; e.g., `[IO.File]::CreateText(\"$sf:Desktop/foo.txt\")`\r\n\r\nThis behavior is the primary utility of the `$sf:Desktop` syntax, given that a mere provider-path string such as `sf:Desktop` _by itself_ is only meaningful to _PowerShell's provider cmdlets_ (unlike native file-system paths such as `C:\\Users\\Desktop`).\r\n\r\nSo my thinking was that the drive's items do not themselves need to represent _directory_ (container) items, and the only practical need to explicitly call provider cmdlets would be for _discovery_: e.g., `Get-ChildItem sf:` or `Get-Item sf:*music*`\r\n\r\nI suppose we could do _both_, and also treat drive `sf:` like any other PS-drive-based _file-system_ drive, but there's a conceptual problem:\r\n\r\n* What file-system location should `sf:/` - the root of all special folders - represent? There is no natural candidate, yet we don't want to disallow `Set-Location sf:/` altogether, given that it works with other providers (e.g., `Set-Location alias:/` works just fine); if location `sf:/` doesn't represent an actual file-system item - just as `alias:/` doesn't -  the problem doesn't arise.\r\n\r\nAlso, `$PWD` will then report `sf:Desktop` rather than `C:\\Users\\jdoe\\Desktop`, for instance - as with custom PS drives.\r\n\r\n\r\n",
      "created_at": "2020-07-25T19:08:43Z",
      "updated_at": "2020-07-25T19:08:43Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "What file system location does `My Computer` represent?  You can explore it, you can link to it but you cannot pass it to an application that expects a directory.  It is the same situation.",
      "created_at": "2020-07-25T19:22:17Z",
      "updated_at": "2020-07-25T19:22:17Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "It is not, because `My Computer` (`This PC`) is a concept of the Windows _GUI_ shell's namespace, and its abstract locations aren't directly usable in PowerShell, so _the problem doesn't currently exist_ - we would be introducing it to PowerShell.\r\n\r\n(If you try launching a PowerShell console from File Explorer from an abstract location such as `This PC`, you'll get `set-location : Cannot find path '::{20D04FE0-3AEA-1069-A2D8-08002B30309D}' because it does not exist.`, and, similarly, you can't query its children with `Get-ChildItem`.)\r\n\r\nThat said, I'd be fine with, say, mapping location `sf:/` to the root of the system drive (`/` on Unix, and typically `C:\\` on Windows).\r\n\r\nAgain: What matters at the end of the day is that `$sf:Desktop` directly expands to the platform-specific, native file-system path underlying the abstract location.\r\n",
      "created_at": "2020-07-25T19:37:28Z",
      "updated_at": "2020-07-25T19:51:11Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "In keeping with existing providers, it would make the most sense if `SF:` itself mapped to an abstract location from where you can call `Get-ChildItem` and get a list of special folders and their locations:\r\n\r\n```ps1\r\nPS> Get-ChildItem sf:\r\n\r\nName          Location\r\n----          --------\r\nDesktop       C:\\Users\\currentUser\\Desktop\r\nMy Documents  C:\\Users\\currentUser\\My Documents\r\n( ... ) \r\n```",
      "created_at": "2020-07-25T19:59:17Z",
      "updated_at": "2020-07-25T20:00:00Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "[_Update_: See [conclusion below](https://github.com/PowerShell/PowerShell/issues/6966#issuecomment-663910975)]\r\n\r\nYes, @vexx32, but we would get that behavior even if the items themselves do not map directly to file-system locations; as I said above: \r\n\r\n> the drive's items do not themselves need to represent directory (container) items, and the only practical need to explicitly call provider cmdlets would be for _discovery_: e.g., `Get-ChildItem sf:` or `Get-Item sf:*music*`\r\n\r\nThis would work just like `Get-ChildItem alias:/`, for the `alias:` drive, which also does _not_ map to file-system locations.\r\n\r\nTo summarize:\r\n\r\n* What's important is that namespace variable notation - e.g., `$sf:Desktop` - directly expands to the platform-specific, native file-system path underlying the abstract location.\r\n\r\n* I'm personally fine with _also_ making the drive navigable as a special _file-system_ provider (rather than a provider that returns _path strings_), but I think that is far less important:\r\n\r\n  * If we _don't_ make `sf:` a special file-system provider, not much is lost: instead of `Set-Location sf:Desktop` you'd then have to use `Set-Location $sf:Desktop` (analogously for `Get-Item` and `Get-ChildItem`, if you want `[System.IO.DirectoryInfo]` output), which doesn't strike me as a hardship - though there may be potential for confusion.\r\n\r\n  * If we _do_ do that:\r\n     * We need to decide how to handle `Set-Location sf:/`, i.e. navigating to the drive's _root location_, which all providers currently support.\r\n       * Either: Prevent navigating directly to `sf:/`, with a meaningful error message.\r\n       * Or: Map `sf:/` to an ultimnately arbitrary file-system locations, such as the root of the system drive.\r\n     *  Either way, we need to be mindful that after, say, `Set-Location sf:Desktop`, `$PWD` would stringify as `'sf:/Desktop'`, which you cannot  directly use (to compose paths with) in calls that expect native file-system paths. (This applies to _custom_ file-system PS drives equally, but creating those is a deliberate act, whereas in this case users may not expect this behavior; `$PWD.ProviderPath` is the workaround)\r\n\r\n",
      "created_at": "2020-07-25T20:28:05Z",
      "updated_at": "2020-07-25T22:31:58Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 I believe he's just answering your question of:\r\n\r\n> * What file-system location should `sf:/` - the root of all special folders - represent? There is no natural candidate, yet we don't want to disallow `Set-Location sf:/` altogether, given that it works with other providers (e.g., `Set-Location alias:/` works just fine); if location `sf:/` doesn't represent an actual file-system item - just as `alias:/` doesn't -  the problem doesn't arise.\r\n\r\nwith \"it doesn't, it's like `alias:/`\".\r\n\r\n---\r\n\r\nAlso I agree with you that making the *content* of the leaf be the path as a string is the only way to implement it as a provider.  It is gonna be weird though that `Get-ChildItem sf:Desktop` won't work like folks expect.  I know it *can't* do that with how providers work currently, but still maybe too confusing.",
      "created_at": "2020-07-25T21:22:29Z",
      "updated_at": "2020-07-25T21:22:45Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @SeeminglyScience, but I was trying to point out that only if you conceive of the provider underlying the `sf` drive as a _file-system_ provider do you have to solve the problem of what file-system location `sf:/` maps to. So, _if_ we want `Get-ChildItem sf:Desktop` to work - to avoid confusion - we indeed need to implement the provider as a file-system provider - and then we need to solve that problem.",
      "created_at": "2020-07-25T21:40:24Z",
      "updated_at": "2020-07-25T21:40:24Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "I really don't think you can in a way that doesn't cause more confusion.  Unless you just special case all path resolution starting in `sf` in the `FileSystemProvider` itself.\r\n\r\nThe biggest obstacle in any provider implementation that is \"sorta like X provider but with this one difference\" is that you can't do cross provider operations.  So `Copy-Item sf:\\Desktop C:\\temp` is hardwired to throw.  Also how does path resolution transition between providers like `gi sf:\\Desktop\\Chrome.lnk`.  The provider API just isn't built to handle any of that.\r\n\r\nSorry if that's all already been mentioned ITT.",
      "created_at": "2020-07-25T21:48:34Z",
      "updated_at": "2020-07-25T21:48:34Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> Sorry if that's all already been mentioned ITT.\r\n\r\nI don't think it has, @SeeminglyScience, so thanks for clarifying.\r\n\r\nSo it sounds like the conclusion is:\r\n\r\n* A provider underlying the proposed `sf` drive currently cannot be a special-cased  file-system provider, so we currently cannot support calls such as `Set-Location sf:Desktop` or `Get-Item sf:Desktop` ([_update_: while expecting a `[System.IO.DirectoryInfo]` instance as output), even though users may expect it.\r\n\r\n* As a provider whose items simply represent _path strings_, namespace variable notation (e.g, `$sf:Desktop`) works as intended - which is what matters - and it still supports discovery via `Get-ChildItem` / `Get-Item`.\r\n`Set-Location sf:/` - in the absence of needing to map to a file-system location - then presents no conceptual problem.\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-07-25T22:08:30Z",
      "updated_at": "2020-07-25T22:26:09Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> * A provider underlying the proposed `sf` drive currently cannot be a special-cased  file-system provider, so we currently cannot support calls such as `Set-Location sf:Desktop` or `Get-Item sf:Desktop`, even though users may expect it.\r\n\r\nMaybe clarify that `Get-Item` will work, just not return a `DirectoryInfo` object.",
      "created_at": "2020-07-25T22:24:02Z",
      "updated_at": "2020-07-25T22:35:26Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Interesting, we expect  that sf:\\Desktop returns a value but alias:\\% does not return `ForEach-Object`. It looks like a fundamental problem.",
      "created_at": "2020-07-27T11:21:18Z",
      "updated_at": "2020-07-27T11:21:18Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "@iSazonov `${alias:%}` does return `ForEach-Object`",
      "created_at": "2020-07-27T11:54:34Z",
      "updated_at": "2020-07-27T11:54:34Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "But we want Set-Location $sf:Desktop, not Set-Location ${sf:Desktop}",
      "created_at": "2020-07-27T12:00:41Z",
      "updated_at": "2020-07-27T12:00:41Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "`$sf:Desktop` will work just fine, the curly brackets are because <kbd>%</kbd> isn't allowed in variable names.",
      "created_at": "2020-07-27T12:01:49Z",
      "updated_at": "2020-07-27T12:02:58Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "```powershell\r\n>alias:gcm\r\nalias:gcm: The term 'alias:gcm' is not recognized as the name of a cmdlet, function, script file, or operable program.\r\nCheck the spelling of the name, or if a path was included, verify that the path is correct and try again.\r\n```\r\nIt is not expanded to Get-Command.",
      "created_at": "2020-07-27T14:30:56Z",
      "updated_at": "2020-07-27T14:30:56Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "`alias:gcm` is a bareword, there is nothing to expand here.",
      "created_at": "2020-07-27T14:38:07Z",
      "updated_at": "2020-07-27T14:38:07Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov, that is expected, because `alias:gcm` isn't a _file-system_ path that allows _direct execution_. Only the alias _provider_ understands this path, so you'll have to use `Get-Item alias:gcm` (or `Get-Content alias:gcm` to just get the _definition_ of the alias, which is the _string_ `'Get-Command'`).\r\n\r\nTo execute an alias by its PS-provider path (which is obviously a needlessly circuitous way of doing it), you'd have to do this (where `$alias:gcm` is the equivalent of `Get-Content alias:gcm`):\r\n\r\n```powershell\r\n& $alias:gcm\r\n```",
      "created_at": "2020-07-27T14:38:16Z",
      "updated_at": "2020-07-27T17:25:05Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "If we allowed direct execution of variables, we would not need temporary files.  However, such variables should still be named `*.PS1`.  `alias:gcm` does not have this extension, so by no stretch can it be treated as a script.",
      "created_at": "2020-07-27T14:41:52Z",
      "updated_at": "2020-07-27T14:44:41Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> that is expected, because alias:gcm isn't a file-system path\r\n\r\nWhat do we want - sf:Desktop or $sf:Desktop in Set-Location?\r\n",
      "created_at": "2020-07-27T15:42:47Z",
      "updated_at": "2020-07-27T15:42:47Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> What do we want - sf:Desktop or $sf:Desktop in Set-Location?\r\n\r\nThe only way that can work with how providers currently work is `$sf:Desktop`.\r\n\r\nThough I want to state again that I think this design is too confusing for folks who don't know *why* it needs to be like that.  Personally I think this should wait until cross provider path resolution/copy operations work.\r\n\r\n",
      "created_at": "2020-07-27T15:50:29Z",
      "updated_at": "2020-07-27T15:50:29Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@SeeminglyScience \r\n\r\nI get the potential for confusion, but there's no telling if and when cross provider path resolution/copy operation will ever be implemented (or are there specific plans?), so I don't think we should wait for that.\r\n\r\nI see the primary utility of the proposed feature in _composing path strings via string interpolation / concatenation_, where `$sf:Desktop` is the necessary form (e.g., `\"$sf:Desktop/subdir\"` (however, with `Join-Path` the confusion could again arise).\r\n\r\n~~If we implement a provider now and make its items _containers_ of type `[System.IO.DirectoryInfo]` (and the item _content_ their `.FullName` property), then we could conceivably later transition to a fully integrated specialized file-system provider - or am I missing something?~~\r\n\r\n~~Come to think of it: Would that alone enable `Set-Location sf:Desktop`, given that there's no _cross_-provider operation happening? However, you then wouldn't actually change to a location _on drive `sf:`_; instead, you'd change directly to the _native file-system path_ underlying the item - but that is arguably preferable.~~\r\n\r\n[_Update_: See [below](https://github.com/PowerShell/PowerShell/issues/6966#issuecomment-664603897).]\r\n\r\n@yecril71pl \r\n\r\n> If we allowed direct execution of variables\r\n\r\nThere is no _variable_ here (whose _value_ you can invoke with `&`), only a _literal path_ referring to an item exposed by the `Alias` provider (via its one and only `alias:` drive).\r\n\r\n@iSazonov \r\n\r\nPowerShell _conceptually could_ - but currently doesn't - accept path `alias:gcm` as a _command_ to execute, even though the `System.Management.Automation.AliasInfo` instance the path refers to is by definition a command (derives from `System.Management.Automation.CommandInfo`). Given that just `gcm` is sufficient for invocation, however, I don't think that's a shortcoming in practice.\r\nOut of curiosity, @SeeminglyScience: is this problem solvable with how providers currently work?\r\n\r\nBy contrast, for paths such as `sf:Desktop` to become first-class PS file-system citizens, alongside custom PS filesystem drives, we'd need a _specialized file-system provider_, which \r\naccording to [@SeeminglyScience's analysis](https://github.com/PowerShell/PowerShell/issues/6966#issuecomment-663909540) a problem that cannot be solved with how providers currently work.\r\n\r\n\r\n\r\n",
      "created_at": "2020-07-27T18:05:42Z",
      "updated_at": "2020-07-27T19:53:32Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> but there's no telling if and when cross provider path resolution/copy operation will ever be implemented\r\n\r\nYeah I know, still.  A different route should be pursued imo.\r\n\r\n> If we implement a provider now and make its items _containers_ of type `[System.IO.DirectoryInfo]` (and the item _content_ their `.FullName` property), then we could conceivably later transition to a fully integrated specialized file-system provider - or am I missing something?\r\n\r\nI think is a bigger understandability challenge.  The `Get-Item` object is a `DirectoryInfo`, but it's a leaf, and the *content* is the path.  Then later we're going to make them no longer a leaf and throw on `Get-Content`?  Even if that was intuitive, that makes it even harder for a user to determine why `gci sf:/Desktop` or `gi sf:/Desktop/pwsh.lnk` don't work.\r\n\r\n> Come to think of it: Would that alone enable `Set-Location sf:Desktop`, given that there's no _cross_-provider operation happening? However, you then wouldn't actually change to a location _on drive `sf:`_; instead, you'd change directly to the _native file-system path_ underlying the item - but that is arguably preferable.\r\n\r\nNah, you can't set your location to a leaf.\r\n\r\n> PowerShell _conceptually could_ - but currently doesn't - accept path `alias:gcm` as a _command_ to execute, even though the `System.Management.Automation.AliasInfo` instance the path refers to is by definition a command (derives from `System.Management.Automation.CommandInfo`). Given that just `gcm` is sufficient for invocation, however, I don't think that's a shortcoming in practice.\r\n> Out of curiosity, @SeeminglyScience: is this problem solvable with how providers currently work?\r\n\r\nWell `& (gi alias:gcm)` works.  I imagine a really basic version could maybe be hooked up via `ItemCmdletProvider.InvokeDefaultAction` if the breaking change was accepted.  But execution in the same way it works for the filesystem provider could be a big ol' can of worms.\r\n\r\n",
      "created_at": "2020-07-27T18:53:14Z",
      "updated_at": "2020-07-27T18:53:14Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @SeeminglyScience.\r\n\r\n> The Get-Item object is a DirectoryInfo, but it's a leaf\r\n\r\nThe proposal was to make it a _container_, but, yes, allowing `Get-Content` to report the container's _path_ would be an anomaly (something like `Get-Content $HOME` currently fails, as does `${C:\\Windows}`, with `Unable to get content because it is a directory:`)\r\n\r\nHowever, conversely that means that if we wait until we can make the `sf:` drive's provider a specialized, full-fledged file-system provider, it is `$sf:Desktop` that won't work - which takes away what I perceive to be the primary use case: I want to be able to use `$sf:Desktop/file.txt`, and not be forced to use `\"$(Get-Item sf:Desktop)/file.txt\"` or `(Get-Item sf:Desktop/file.txt).FullName` - which is both cumbersome and inefficient.\r\n\r\nSo, to me the pragmatic solution is: implement a provider whose items are _leaf_ items that represent _path strings_ - and make it clear in the documentation that `sf:`-based paths cannot serve directly as file-system items.\r\n\r\n\r\n> Well `& (gi alias:gcm)` works\r\n\r\nSure, and so does `& $alias:gcm` (though a _string_ is returned in that case), but the question was whether the detour via `Get-Item` / namespace variable notation can be avoided in this case.\r\n\r\nThe question was mostly academic, though: given the negligible benefit from enabling this and the potential for pitfalls, I agree that it's not worth tackling.\r\n\r\n",
      "created_at": "2020-07-27T19:51:43Z",
      "updated_at": "2020-07-27T19:52:00Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> The proposal was to make it a _container_, but, yes, allowing `Get-Content` to report the container's _path_ would be an anomaly (something like `Get-Content $HOME` currently fails, as does `${C:\\Windows}`, with `Unable to get content because it is a directory:`)\r\n\r\nThat is again pretty confusing imo.  As an aside I don't think it's a good idea to allow a container to work with `Get-Content` just for this workaround.\r\n\r\n> However, conversely that means that if we wait until we can make the `sf:` drive's provider a specialized, full-fledged file-system provider, it is `$sf:Desktop` that won't work - which takes away what I perceive to be the primary use case: I want to be able to use `$sf:Desktop/file.txt`\r\n\r\nYeah I totally get the use case.  It's still gonna confuse the hell out of folks though.\r\n\r\n> and not be forced to use `\"$(Get-Item sf:Desktop)/file.txt\"` or `(Get-Item sf:Desktop/file.txt).FullName` - which is both cumbersome and inefficient.\r\n\r\nSame way you resolve file system paths though.  Also `Resolve-Path`.\r\n\r\n> So, to me the pragmatic solution is: implement a provider whose items are _leaf_ items that represent _path strings_ - and make it clear in the documentation that `sf:`-based paths cannot serve directly as file-system items.\r\n\r\nIf it had to be added as it's own provider, that'd be the only way that it could be implemented currently.  I don't think it should be though, it'd be way too difficult to understand.\r\n\r\nHonestly I'd rather see it as special casing the `FileSystemProvider`'s path resolution.  I'm not really sure if it's worth the extra complication, but that would at least be very easy to understand.\r\n\r\n> Sure, and so does `& $alias:gcm` (though a _string_ is returned in that case), but the question was whether the detour via `Get-Item` / namespace variable notation can be avoided in this case.\r\n\r\nYeah I gotcha, the rest of the sentence was the direct answer.\r\n\r\n",
      "created_at": "2020-07-27T20:26:11Z",
      "updated_at": "2020-07-27T20:26:11Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": ">  I don't think it's a good idea to allow a container to work with Get-Content just for this workaround.\r\n\r\nAgreed.\r\n\r\n> Same way you resolve file system paths though. Also Resolve-Path\r\n\r\nYes, but that is cumbersome for this use case.\r\n\r\n> If it had to be added as its own provider, that'd be the only way that it could be implemented currently. I don't think it should be though, it'd be way too difficult to understand.\r\n\r\nIf the primary usage is `$sf:Desktop` in path strings, I don't think people would think twice about it, just like they don't think about `$env:HOME` being underpinned by a provider operation that is the equivalent of `Get-Content Env:HOME`.\r\nWith proper tab-completion, you may never need to touch the provider cmdlets, and if you think of `$sf:Desktop` as just a special variable (value), `Set-Content $sf:Desktop` isn't a stretch either.\r\n\r\n\r\n",
      "created_at": "2020-07-27T20:32:48Z",
      "updated_at": "2020-07-27T20:32:48Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> Yes, but that is cumbersome for this use case.\r\n\r\nCould you elaborate? You'd only need to do this if you were passing the path to something that didn't understand PSPath's.  Otherwise it'd work similar to a PSDrive.\r\n\r\n> If the primary usage is `$sf:Desktop` in path strings, I don't think people would think twice about it, just like they don't think about `$env:HOME` being underpinned by a provider operation that is the equivalent of `Get-Content Env:HOME`.\r\n\r\nEnvironment variables aren't just paths though, users already think of them like variables.",
      "created_at": "2020-07-27T21:02:28Z",
      "updated_at": "2020-07-27T21:02:28Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> Could you elaborate?\r\n\r\nI want to be able to use `$sf:Desktop/file.txt`, which I can't if `sf:Desktop` is a container (directory) item.\r\n\r\n> Environment variables aren't just paths though, users already think of them like variables.\r\n\r\nThat's my point: users can and should think of `$sf:Desktop` as (special) variables that contain path strings.\r\nUnderpinning this with a provider is simply a technical requirement to enable this syntax.\r\n\r\n\r\n",
      "created_at": "2020-07-27T21:06:53Z",
      "updated_at": "2020-07-27T21:06:53Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> I want to be able to use `$sf:Desktop/file.txt`, which I can't if `sf:Desktop` is a container (directory) item.\r\n\r\nRight I got that, but why do you want that instead of working it into actual path resolution.\r\n\r\nWhy do you need to do:\r\n\r\n```powershell\r\nCopy-Item $sf:Desktop/pwsh.lnk ./pwsh.lnk\r\n```\r\n\r\nInstead of\r\n\r\n```powershell\r\nCopy-Item sf:/Desktop/pwsh.lnk ./pwsh.lnk\r\n```\r\n\r\n> That's my point: users can and should think of `$sf:Desktop` as (special) variables that contain path strings.\r\n> Underpinning this with a provider is simply a technical requirement to enable this syntax.\r\n\r\nI understand how you *want* it to be viewed, but I think that's challenging.  Introducing a provider whose content is a file system path as a string that you then pass to a different provider to be resolved to an item is inherently difficult to understand.",
      "created_at": "2020-07-27T22:03:27Z",
      "updated_at": "2020-07-27T22:03:27Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> I understand how you _want_ it to be viewed\r\n\r\nIt's more than that: I'm proposing that it be _actively framed this way_: to de-emphasize the provider aspect _as an implementation detail_, which avoids the conceptual problems. Instead, we should frame `$sf:*` as _special variables_ that return _path strings_.\r\n\r\nIn that vein:\r\n\r\n```powershell\r\nCopy-Item sf:/Desktop/pwsh.lnk ./pwsh.lnk\r\n```\r\n\r\nI have no idea what `sf:/Desktop` is (I'm playing ignorant to make a point) - all I know is that `$sf:Desktop` returns the platform-appropriate Desktop _path string_ that I can use as part of larger path strings - just like I would use `$env:` variable notation; e.g.:\r\n\r\n```powershell\r\nCopy-Item $env:ProgramFiles/foo/bar.exe ./bar.exe\r\n```\r\n\r\n\r\n\r\n",
      "created_at": "2020-07-27T22:57:18Z",
      "updated_at": "2020-07-27T22:57:18Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "If `sf:` is a file drive why should it work another than `Temp:` drive?\r\n\r\n`sf:` reminds me Windows Library concept - collect folders in an entity.\r\n",
      "created_at": "2020-07-28T11:00:29Z",
      "updated_at": "2020-07-28T11:03:43Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "Because that would require `sf:` to be a drive in the file system.  And some people dislike this solution as too dirty, intrusive or whatever.  Also, it smells of `My Computer`, which is a Windows GUI thing, which means we would have a killer in the room \ud83d\ude32",
      "created_at": "2020-07-28T11:05:05Z",
      "updated_at": "2020-07-28T12:35:20Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> > If we allowed direct execution of variables\r\n> \r\n> There is no _variable_ here (whose _value_ you can invoke with `&`), only a _literal path_ referring to an item exposed by the `Alias` provider (via its one and only `alias:` drive).\r\n\r\nA variable named `SCRIPT.PS1` has a literal path of `VARIABLE:SCRIPT.PS1`.  So, when I pass `VARIABLE:/SCRIPT.PS1` as a command, I expect the script in the variable to be executed.  But that is not allowed and I have to put the script onto the file system in order to be able to execute it.",
      "created_at": "2020-07-28T11:27:10Z",
      "updated_at": "2020-07-28T11:27:10Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov \r\n\r\n`sf:` would be a _PowerShell_ drive, but not a PowerShell _file-system_ drive - it currently _cannot_ be the latter, for the technical reasons explained by @SeeminglyScience, but even if it could (it's unclear if and when), it would introduce more problems than it solves.\r\n\r\n(I've come full circle on this: the original proposal was to _not_ conceive of it as a file-system drive, then we discussed what it would take to do so, now I'm back to the original proposal).\r\n\r\nJust like `alias:` or `env:` aren't _file-system_ drives, `sf:` wouldn't be either: it would be a drive that exposes items representing _strings_ that happen to be _file-system path strings_ (just like many environment variables on Windows contain file-system paths, such as `$env:ProgramFiles`).\r\n\r\nThe primary purpose of the `sf:` drive would be to _enable namespace variable notation_, so that something like `$sf:Desktop` expands to the _path string_ that is the platform-appropriate native file-system Desktop path, and can be used as-is in building longer paths (`$sf:Desktop/file.txt`) and calls that expect native file-system paths _both in argument and in expression mode_.\r\n\r\nJust like most users rarely, if ever, interact with the `Env:` drive via provider _cmdlets_ - they instead rely on namespace variable notation such as `$env:ProgramFiles` - they would just use `$sf:Desktop`, or tab-completion for discovery. (Of course, they _can_ use `Get-ChildItem sf:` for more convenient and sophisticated discovery, if they choose to.)\r\n\r\n\r\n\r\n\r\n\r\n\r\n \r\n\r\n",
      "created_at": "2020-07-28T14:50:41Z",
      "updated_at": "2020-10-28T14:12:47Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "The only technical reason I can think of is that `SF:/`, unlike `TEMP:/`, would not correspond to any actual location, so it would be a virtual drive with effective links inside, a bit like `\\\\.\\`, which is an interesting idea better left to be implemented by the underlying OS than by ourselves.",
      "created_at": "2020-07-28T15:07:58Z",
      "updated_at": "2020-07-28T15:07:58Z"
    },
    {
      "author": "SamB",
      "author_association": "NONE",
      "body": "@mklement0 \r\n> [...] (note: `Desktop` and `DesktopDir`, though technically distinct, seem to refer to the same location in practice; the former is distinguished from the latter as being the \"logical Desktop rather than the physical file system location\" - not sure what that means).\r\n>   \r\n>   * `Desktop`\r\n>   * `DesktopDirectory`\r\n\r\n_**Note to the uninitiated**: Just to be confusing, \"the shell\" refers to an entirely different component of Windows than PowerShell or cmd.exe. You probably know it as explorer.exe, though naturally most of it is actually implemented in DLLs ..._\r\n\r\nI think this distinction is/was only relevant with [SHGetSpecialFolderLocation](https://docs.microsoft.com/en-us/windows/win32/api/shlobj_core/nf-shlobj_core-shgetspecialfolderlocation) and [SHGetFolderLocation](https://docs.microsoft.com/en-us/windows/win32/api/shlobj_core/nf-shlobj_core-shgetfolderlocation), which build paths in the [shell's namespace](https://docs.microsoft.com/en-us/windows/win32/shell/namespace-intro) (ITEMIDLIST structures, also called PIDLs for some reason). CSIDL_DESKTOP would give you the thing that's actually represented on your desktop; CSIDL_DESKTOPDIRECTORY would give you the place you get to when you type e.g. %USERPROFILE%\\Desktop into Explorer's address bar.\r\n\r\n[The documentation seems to imply that both values do the same thing since Vista, but I'm not going to assume that's actually true.]\r\n\r\nIn particular, CSIDL_DESKTOP would have whatever extra items [Computer, Recycling Bin, etc.] the user has configured to appear on the desktop, as well as items contributed from CSIDL_COMMON_DESKTOPDIRECTORY (i.e. the All Users desktop shortcuts).\r\n\r\nNaturally, none of this is in any way relevant to the return value of [System.Environment.GetFolderPath](https://docs.microsoft.com/en-us/dotnet/api/system.environment.getfolderpath).",
      "created_at": "2020-08-31T05:12:52Z",
      "updated_at": "2020-08-31T05:12:52Z"
    },
    {
      "author": "jberezanski",
      "author_association": "NONE",
      "body": "> is there any reason no one raised a Get-SpecialFolder cmdlet?\r\n\r\nI just got pointed to this issue. The whole subject certainly deserves careful consideration and design, but this may perhaps help someone now:\r\n\r\nSeveral years ago I had created [a PS module](https://github.com/jberezanski/PSKnownFolders) for inspecting and manipulating [known folders](https://docs.microsoft.com/en-us/windows/win32/shell/known-folders) using the COM API (which provides much more functionality than the legacy API used internally by the .NET Environment class). I wanted to ease my pain of mass redirecting the folders (including the Public ones) out of the system drive when setting up multiple computers for several members of my family - by default possible only by clicking in the GUI (and requiring temporarily disabling UAC to move the Public folders). The goal was to be able to write\r\n```powershell\r\n# as any user\r\nGet-KnownFolder | Move-KnownFolder -Destination F:\\Profiles\\$Env:UserName\r\n# single folder, with rename\r\nMove-KnownFolder -SingleFolder (Get-KnownFolder -Name Personal) -NewPath D:\\Data\\$Env:UserName\\Docs\r\n# as admin\r\nGet-KnownFolder -Public | Move-KnownFolder -Destination F:\\Profiles\\Public\r\n```\r\n\r\nThe module is fully functional (I tend to use it any time I set up a new computer); I just ran out of free time and motivation to make the finishing touches - writing some docs/examples and publishing to PSGallery. I could probably make that effort if there is interest.\r\n\r\nFor inspecting the paths we would use:\r\n```powershell\r\nPS C:\\> (Get-KnownFolder -Name Personal).Path\r\nF:\\Profiles\\jberezanski\\Documents\r\n```\r\n\r\nMy implementation is obviously Windows-only; I don't know how many of the Windows Shell concepts are applicable to other platforms. When I thought about exposing more of those concepts in PS, I tended to think in terms of a provider + drive - `Shell:\\`, with the root representing the Shell namespace root (the \"logical\" Desktop). However, I did not come upon actual use cases for navigating that namespace and all my practical needs were satisfied by the two cmdlets mentioned above.",
      "created_at": "2020-10-28T14:37:09Z",
      "updated_at": "2020-10-28T14:37:09Z"
    },
    {
      "author": "jberezanski",
      "author_association": "NONE",
      "body": "(Personally, I'd love to see a cross platform way for referencing the `AppData`/`Local AppData` known folders, so that applications could stop polluting the root of the user profile directory with their config/data files and folders, but that is a different rant altogether.)",
      "created_at": "2020-10-28T14:38:18Z",
      "updated_at": "2020-10-28T14:38:18Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @jberezanski.\r\n\r\n> I don't know how many of the Windows Shell concepts are applicable to other platforms\r\n\r\nI've summarized which known folders apply to which platforms [above](https://github.com/PowerShell/PowerShell/issues/6966#issuecomment-393882898).\r\n\r\nWhile I think that `Get-KnownFolder` would make a nice addition (I've created a function of the same name for myself a while back), I think that something like `$sf:Desktop` is _also_ called for:\r\n\r\nSpecifically, it would lessen the temptation to write code such as `'hi' > $HOME/Desktop/foo.txt`, given that the only fully robust formulation would be the more verbose `'hi' > \"$(Get-KnownFolder Desktop)/foo.txt\"` (note the required double quotes; a `Join-Path` command would be even more verbose).\r\n\r\nBeing able to use `'hi' > $sf:Desktop/foo.txt` is the best of both worlds: robust _and_ convenient.\r\n",
      "created_at": "2020-10-28T16:02:53Z",
      "updated_at": "2020-10-28T16:02:53Z"
    },
    {
      "author": "jberezanski",
      "author_association": "NONE",
      "body": "> Being able to use 'hi' > $sf:Desktop/foo.txt is the best of both worlds: robust and convenient.\r\n\r\nFully agreed.\r\n\r\nI also don't see the syntax as confusing; many commonly used environment variables contain paths and we do things like `mkdir $Env:TEMP\\xyz` all the time. I think it's not that difficult to learn that another prefix gives access to an additional set of paths - that a new provider is in the works there is an implementation detail, not important in the typical use case of just wanting to know the path.",
      "created_at": "2020-10-28T16:31:38Z",
      "updated_at": "2020-10-28T16:31:38Z"
    },
    {
      "author": "jberezanski",
      "author_association": "NONE",
      "body": "And, possibly, _writing_ to `$sf:Something` could perform the equivalent of my `Move-KnownFolder`...\r\n...or maybe not, because then it would be too easy to do it by accident and the operation may be dangerous to user data.",
      "created_at": "2020-10-28T16:40:40Z",
      "updated_at": "2020-10-28T16:40:40Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Yes, I think that would be too dangerous, so a `Move-KnownFolder` cmdlet is preferable, although - unlike `Get-KnownFolder` - it would be Windows-specific.\r\n",
      "created_at": "2020-10-28T16:44:32Z",
      "updated_at": "2020-10-28T16:44:32Z"
    },
    {
      "author": "jberezanski",
      "author_association": "NONE",
      "body": "By the way, the [Environment+SpecialFolder](https://docs.microsoft.com/en-us/dotnet/api/system.environment.specialfolder) enum, being based on the legacy pre-Vista [SHGetFolderPath](https://docs.microsoft.com/en-us/windows/win32/api/shlobj_core/nf-shlobj_core-shgetfolderpatha) function, is missing a lot of Known Folders added in Vista and later (some of them rather useful), like Downloads, CommonDownloads, SavedPictures, Camera Roll, UserProgramFiles, OneDrive and many more.\r\n\r\nIn fact, the Known Folders API allows applications to register new folders with the system, so the list is not fixed.\r\n\r\nI ran this on my system to see which Known Folders with non-empty paths were covered by the SpecialFolder enum/GetFolderPath method and out of 95 such Known Folders 46 are not exposed by GetFolderPath:\r\n```powershell\r\n$specialFolderPaths = [enum]::GetValues([Environment+SpecialFolder]) | % { $p = [Environment]::GetFolderPath($_); [pscustomobject]@{SFName=$_; Path=$p}}\r\n$allKnownFolders = Get-KnownFolder -All\r\n$knownFoldersWithNonEmptyPath = $allKnownFolders | ? Path -ne $null | select Category,Name,CanRedirect,Path\r\n$knownFoldersJoinedWithSpecialFolderPaths = $knownFoldersWithNonEmptyPath | % { $kf = $_; $sfp = $specialFolderPaths | ? Path -eq $kf.Path; $kf | select *,@{Name='SFP';Expression={$sfp}}}\r\n$allKnownFolders | measure | select -expand Count\r\n139\r\n$knownFoldersWithNonEmptyPath | measure | select -expand Count\r\n95\r\n$knownFoldersJoinedWithSpecialFolderPaths | ? SFP -eq $null | measure | select -expand Count\r\n46\r\n```\r\n\r\nOn Windows, I'd like to be able to access all Known Folders present on the system (the implementation could enumerate them during initialization). On other platforms a certain basic set should probably be defined, as described earlier in this thread (but not necessarily limited to [Environment+SpecialFolder] values).\r\n\r\nOne thing to note - some Known Folder names contain spaces (\"Camera Roll\"); this should not be a problem with the proposed syntax, because we already need to deal with problematic characters in environment variable names (`${Env:ProgramFiles(x86)}`).",
      "created_at": "2020-10-29T16:39:09Z",
      "updated_at": "2020-10-29T16:42:18Z"
    }
  ],
  "created_at": "2018-05-31T14:39:00Z",
  "labels": [
    "Issue-Enhancement",
    "Up-for-Grabs",
    "Committee-Reviewed",
    "WG-Cmdlets-Management",
    "WG-Engine-Providers",
    "Area-FileSystem-Provider"
  ],
  "number": 6966,
  "state": "open",
  "title": "Add support for special folders (known folders) via a separate provider / namespace",
  "updated_at": "2021-11-30T15:04:44Z"
}