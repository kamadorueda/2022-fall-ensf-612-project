{
  "_url": "https://github.com/PowerShell/PowerShell/issues/2112",
  "author": "ffeldhaus",
  "body": "Doing multipart requests with PowerShell is quite complicated and requires several extra steps for large file uploads. [An easy example for a small file can be found on StackOverflow](http://stackoverflow.com/questions/36268925/powershell-invoke-restmethod-multipart-form-data). [An in depth discussion can be found in this blog post](http://blog.majcica.com/2016/01/13/powershell-tips-and-tricks-multipartform-data-requests/). \n\nIt would be a huge improvement if the WebRequestPSCmdlets (Invoke-RestMethod and Invoke-WebRequest) could be enhanced so that they support Multipart messages directly.\n\nFor an implementation I would expect the following parameters:\n- MultipartFile (Path)\n- MultipartName (Name to be used in Multipart message)\n\n[.NET Core seems to have support for MultipartContent](https://github.com/dotnet/corefx/blob/d0dc5fc099946adc1035b34a8b1f6042eddb0c75/src/System.Net.Http/src/System/Net/Http/MultipartContent.cs) which may simplify the implementation.\n",
  "closed_at": "2018-01-25T05:17:56Z",
  "comments": [
    {
      "author": "swinster",
      "author_association": "NONE",
      "body": "This is horrendous in Powershell and hasn't moved in an age. I personally would love to see some movement here, as uploading large file is very, very difficult. \r\n\r\nAs some pointer around the topic see my comments here (albeit for PS 5.1) which like to some other sites, namely http://blog.majcica.com/2016/01/13/powershell-tips-and-tricks-multipartform-data-requests/",
      "created_at": "2017-08-22T15:21:06Z",
      "updated_at": "2017-08-22T15:21:06Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@markekraus Could you please look this if you have free time?",
      "created_at": "2017-08-23T08:37:44Z",
      "updated_at": "2017-08-23T08:37:44Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov sure. I will take a look at it. I have seen other requests in the past few years for multipart forms in general as several IoT APIs seem to only work with multipart forms.",
      "created_at": "2017-08-25T11:08:56Z",
      "updated_at": "2017-08-25T11:08:56Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Feel free to ping MSFT experts here if there is compatibility issues.",
      "created_at": "2017-08-25T11:13:22Z",
      "updated_at": "2017-08-25T11:13:22Z"
    },
    {
      "author": "swinster",
      "author_association": "NONE",
      "body": "FWIW, we mainly Python, Django and Apache for our Web interfaace stuff. This is all RESTfull APIs. I am not developer, just attempting to interact with the API as we are seeing more sysadmins wanting to do this. ",
      "created_at": "2017-08-25T12:46:52Z",
      "updated_at": "2017-08-25T12:46:52Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@swinster if you could provide me an exact scenario that would be very useful. Right now, all I have to go off of is to build a out a test API that takes multipart forms and files and hope that fits most scenarios.",
      "created_at": "2017-08-25T12:51:36Z",
      "updated_at": "2017-08-25T12:51:36Z"
    },
    {
      "author": "swinster",
      "author_association": "NONE",
      "body": "@markekraus  sure. I work for Pexip, and the entire platform a can be automated via API calls.  This specific example is required with regard to uploading an upgrade file to the platform, which will be in excess of 1GB. The API documentation can be found here - https://docs.pexip.com/api_manage/api_configuration.htm?Highlight=upgrade\r\n\r\nI can even post here the resultant function created  to achieve this, although this is based on the information post by Mario Maj\u010dica in his blog above.",
      "created_at": "2017-08-25T13:12:36Z",
      "updated_at": "2017-08-25T13:12:36Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@swinster awesome. If I need more I'll reach out. ",
      "created_at": "2017-08-25T13:15:24Z",
      "updated_at": "2017-08-25T13:15:24Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@swinster Can you share your function with me? i want to make sure I'm on the right path.",
      "created_at": "2017-08-25T20:15:58Z",
      "updated_at": "2017-08-25T20:15:58Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "This presents some interesting implementation issues. To truly support Multipart form data, the Cmdlets would need to accept multiple files, a field name for each file, possibly a content type for each file, and the ability to accept a dictionary of field/value pairs at the same time. Additionally, It appears some APIs are particular about the boundary used, so an optional boundary would need to be supplied.  Attempting to make that mesh with the current Cmdlets would be a significant rework almost to the point of justifying separate cmdlets for Multipart support.\r\n\r\nThe issue is in Multipart form data being extremely flexible and radically different from other requests. It would be easy to tack on support for a single file or to convert a `-Body` dictionary, but it would not be simple to mix a file with form data or to support multiple files. Fitting all the Multipart use-cases into the current cmdlets would touch a large portion of code to accommodate a valid but somewhat less common usage of the cmdlets. \r\n\r\nIMO, It would also lead to a somewhat confusing UX. If `-InFile` was used for Multipart files and only accepted multiple files on a Multipart request it would lead to issues with users supplying multiple paths on a standard request, getting errors, and wondering why it accepts an array of paths. Also, explaining that `-Body` and `-InFile` are mutually exclusive except when doing Multipart requests would be somewhat confusing confusing. If files were split into a separate and new parameter like `-MultipartFile`, that might cause confusion as to why `-InFile` doesn't work on Multipart requests or why there needs to be a difference in the first place.\r\n\r\nThe problem I see with simplifying this is that many of the requests I've read for sending Multipart form data through PowerShell have only their own use-case in mind. It might seem simple from that perspective, but when you look a dozen or so of these requests you begin to see they almost all are distinctly different needs falling under the broad category of Multipart form data. A Narrow implementation would leave many use-cases in their current state, a broad implementation would impact a lot of code but for feature addition that is less commonly used. \r\n\r\nWith that in mind, I think a fair compromise and better approach would be to accept a `-Body` object/collection that can be used by the Cmdlets to create the Multipart Form-Data Request. This could be simplified by exposing new cmdlet(s) and new classes to simplify generating that object/collection. Body could simply be adapted to accept `MultipartFormDataContent` at least easing the burden of the user managing an `HttpClient`.\r\n\r\nI could start by adding support for `MultipartFormDataContent` in `-Body`. From there it could be decided to add convenience cmdlets or possibly even wrapper classes to easy creation.\r\n\r\n @JamesWTruher @dantraMSFT @PaulHigin @SteveL-MSFT  What are your thoughts? ",
      "created_at": "2017-08-26T13:52:11Z",
      "updated_at": "2017-08-26T15:30:19Z"
    },
    {
      "author": "swinster",
      "author_association": "NONE",
      "body": "@markekraus FWIW, here is the modified function from Mario's blog.\r\n\r\nThe main addition was the Basic Authentication headers which also required a Base64 encoded version of the authentication credentials. Initially, I decrypted the `PSCredential` password via a separate function, however this was changed to a single line. The Basic Authroziation header is required as although you can provide simple credentials to the the `HTTPClient` (and indeed the `Invoke-WebRequest`), the first request is sent without this header, which is then challenged, thus a second request is made. This means that then entire 1 GB file is uploaded twice - a huge waste of time and resources.\r\n\r\nAs an aside, I have a similar issue (WRT the Basic Authorisation Header) when downloading a large file (3-4 GB), again again leads to a two request issue, and the download of the file is actioned twice), However the `Invoke-WebRequest` is even worse in that case as the entire file is streamed into memory and cause the remote server to lock up when I tried to use this CmdLet. I eventually changed to use the `WebClient` (I couldn't get the `HTTPClient` to work with my lacking programming knowledge) , however, `WebClient` doesn't implement a `timeout` property so you have to build a class to inherit and extend the WebClient. All very, very complex and confusing, especially to someone like me with little programming expertise. As mentioned, this is an aside to this particular issue, but is similar in nature.\r\n\r\n```\r\nfunction Invoke-MultipartFormDataUpload\r\n{\r\n\t[CmdletBinding()]\r\n\tPARAM\r\n\t(\r\n\t\t[string][parameter(Mandatory = $true)][ValidateNotNullOrEmpty()]$InFile,\r\n\t\t[string]$ContentType,\r\n\t\t[Uri][parameter(Mandatory = $true)][ValidateNotNullOrEmpty()]$Uri,\r\n\t\t[System.Management.Automation.PSCredential]$Credential\r\n\t)\r\n\tBEGIN\r\n\t{\r\n\t\tif (-not (Test-Path $InFile))\r\n\t\t{\r\n\t\t\t$errorMessage = (\"File {0} missing or unable to read.\" -f $InFile)\r\n\t\t\t$exception =  New-Object System.Exception $errorMessage\r\n\t\t\t$errorRecord = New-Object System.Management.Automation.ErrorRecord $exception, 'MultipartFormDataUpload', ([System.Management.Automation.ErrorCategory]::InvalidArgument), $InFile\r\n\t\t\t$PSCmdlet.ThrowTerminatingError($errorRecord)\r\n\t\t}\r\n\r\n\t\tif (-not $ContentType)\r\n\t\t{\r\n\t\t\tAdd-Type -AssemblyName System.Web\r\n\r\n\t\t\t$mimeType = [System.Web.MimeMapping]::GetMimeMapping($InFile)\r\n\r\n\t\t\tif ($mimeType)\r\n\t\t\t{\r\n\t\t\t\t$ContentType = $mimeType\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t$ContentType = \"application/octet-stream\"\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tPROCESS\r\n\t{\r\n\t\tAdd-Type -AssemblyName System.Net.Http\r\n\r\n\t\t$httpClientHandler = New-Object System.Net.Http.HttpClientHandler\r\n\r\n\t\tif ($Credential)\r\n\t\t{\r\n\t\t\t$networkCredential = New-Object System.Net.NetworkCredential @($Credential.UserName, $Credential.Password)\r\n\t\t\t$httpClientHandler.Credentials = $networkCredential\r\n\t\t\t$httpClientHandler.PreAuthenticate = $true\r\n\t\t\t$httpClient = New-Object System.Net.Http.Httpclient $httpClientHandler\r\n\t\t\t#$password = Get-PlainText -SecureString $Credential.Password\r\n\t\t\t$Base64Auth = [System.Convert]::ToBase64String([System.Text.Encoding]::GetEncoding(\"iso-8859-1\").GetBytes([String]::Format( \"{0}:{1}\", $Credential.UserName, $Credential.GetNetworkCredential().Password)))\t\t\t\r\n\t\t\t#$Base64Auth = [Convert]::ToBase64String([Text.Encoding]::GetEncoding(\"iso-8859-1\").Getbytes(\"$($Credential.UserName):$($password)\"))\r\n\t\t\t$httpClient.DefaultRequestHeaders.Add(\"Authorization\", \"Basic $Base64Auth\")\r\n\t\t}\r\n\t\telse {\r\n\t\t\t$httpClient = New-Object System.Net.Http.Httpclient $httpClientHandler\r\n\t\t}\r\n\r\n\t\t$httpClient.Timeout = 18000000000\r\n\t\t#$httpClient.DefaultRequestHeaders.Add(\"AUTHORIZATION\", \"Basic YTph\")\r\n\r\n\t\t$packageFileStream = New-Object System.IO.FileStream @($InFile, [System.IO.FileMode]::Open)\r\n\r\n\t\t$contentDispositionHeaderValue = New-Object System.Net.Http.Headers.ContentDispositionHeaderValue \"form-data\"\r\n\t\t$contentDispositionHeaderValue.Name = \"package\"\r\n\t\t$contentDispositionHeaderValue.FileName = (Split-Path $InFile -leaf)\r\n\r\n\t\t$streamContent = New-Object System.Net.Http.StreamContent $packageFileStream\r\n\t\t$streamContent.Headers.ContentDisposition = $contentDispositionHeaderValue\r\n\t\t$streamContent.Headers.ContentType = New-Object System.Net.Http.Headers.MediaTypeHeaderValue $ContentType\r\n\r\n\t\t$content = New-Object System.Net.Http.MultipartFormDataContent\r\n\t\t$content.Add($streamContent)\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\t$response = $httpClient.PostAsync($Uri, $content).Result\r\n\r\n\t\t\tif (!$response.IsSuccessStatusCode)\r\n\t\t\t{\r\n\t\t\t\t$responseBody = $response.Content.ReadAsStringAsync().Result\r\n\t\t\t\t$errorMessage = \"Status code {0}. Reason {1}. Server reported the following message: {2}.\" -f $response.StatusCode, $response.ReasonPhrase, $responseBody\r\n\r\n\t\t\t\tthrow [System.Net.Http.HttpRequestException] $errorMessage\r\n\t\t\t}\r\n\r\n\t\t\t#return $response.Content.ReadAsStringAsync().Result\r\n\t\t\treturn $response\r\n\r\n\t\t}\r\n\t\tcatch [Exception]\r\n\t\t{\r\n\t\t\t$PSCmdlet.ThrowTerminatingError($_)\r\n\t\t\treturn $response\r\n\t\t}\r\n\t\tfinally\r\n\t\t{\r\n\t\t\tif($null -ne $httpClient)\r\n\t\t\t{\r\n\t\t\t\t$httpClient.Dispose()\r\n\t\t\t}\r\n\r\n\t\t\tif($null -ne $response)\r\n\t\t\t{\r\n\t\t\t\t$response.Dispose()\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tEND { }\r\n}\r\n```",
      "created_at": "2017-08-26T14:32:07Z",
      "updated_at": "2017-08-26T14:53:18Z"
    },
    {
      "author": "swinster",
      "author_association": "NONE",
      "body": "I have also hardcoded the `ContentDispositionHeaderValue` value (`package`) which is all that was required for my needs.",
      "created_at": "2017-08-26T14:34:47Z",
      "updated_at": "2017-08-26T14:34:47Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@swinster thanks. I just wanted to confirm you were doing something similar. \r\n\r\nAuthorization Basic is being tracked under #4274\r\n\r\nI'm not familiar with the other issue (using `WebClient` for large files). but if it is a show stopper and someone hasn't already done so, you should open an issue on it. ",
      "created_at": "2017-08-26T15:26:39Z",
      "updated_at": "2017-08-26T15:26:39Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@markekraus We discussed using https://github.com/AngleSharp/AngleSharp with @SteveL-MSFT. We could use the package to cover most features we need including multipart.",
      "created_at": "2017-08-26T18:38:37Z",
      "updated_at": "2017-08-26T18:38:37Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov so that would be part of a larger rework then to use AngelSharp for parsing and submission?",
      "created_at": "2017-08-26T19:15:05Z",
      "updated_at": "2017-08-26T19:15:05Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "We had a Power Commitiiee conclusion https://github.com/PowerShell/PowerShell/issues/3267#issuecomment-286917402 to use AngelSharp for parsing. I believe if the start will be good we could use AngelSharp broader. Yes, it may be a lot of work so I did not start. Related https://github.com/PowerShell/PowerShell/issues/2867",
      "created_at": "2017-08-28T03:47:48Z",
      "updated_at": "2017-08-28T03:48:46Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "I think I may still work at accepting the `MultipartFormDataContent` as a a `-Body` value. It is something that would make it accessible now and still relevant should AngelSharp prove to be used for more than just parsing. ",
      "created_at": "2017-08-28T08:43:56Z",
      "updated_at": "2017-08-28T08:43:56Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "The idea is that we're using AngelSharp library for web the same way we use Newton library for json - we exclude low level web coding and focus efforts at PowerShell web features. Now we have to implement a web client - it is very difficult to implement a full feature web client - we can't compete with browsers. In Windows PowerShell we can use IE as workaround. In PowerShell Core we need a portable solution. Otherwise, we are doomed to endless patches of \"holes\". \r\nIn order to not break anything, we could maintain a new fork our web cmdlets with new names (prefix) as experimental solution and test AngelSharp in the case.",
      "created_at": "2017-08-28T09:51:22Z",
      "updated_at": "2017-08-28T09:51:22Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "Now that #4782 has been merged. It is time to consider some simplified limited implementations.\r\n\r\nWhat I think can be done without much pain and without making any breaking changes is to add `multipart/form-data` support to dictionary `-Body`'s and `-Infile`. This would be facilitated with something like `-AsMultipart` switch. \r\n\r\nIn the case of `-InFile` there would only be support for a single file and it would be added as a `StreamContent`. The `-ContentType` parameter, since it would otherwise be ignore, can be re-purposed for specifying the mime type of the file. \r\n\r\nThe `-Body` dictionary would be converted into `StringContent`. The Key's would be field names and the values would be the content.\r\n\r\nFinally, when `-AsMultipart` is supplied, the `-InFile` and `-Body` dictionary can be used together for a mixed content submission. \r\n\r\nThis would add support for many basic use cases, but would not address complex `multipart/form-data` submissions or multiple files in a single submission. For those use cases, the `MultipartFormDataContent` will still need to be manually created and supplied.\r\n\r\nThis would also require some error detection, such as when something other than a dictionary is supplied to `-Body` when `-AsMultipart` is used. Also, the `-ContentType` will probably cause issues if it is not a valid type (will need to verify). The current logic for conflict resolution between `-Body` and `-InFile` will have to be revisited.\r\n\r\n@iSazonov Can you add/change the label `Area-Cmdlets-Utility`. I'm trying to make it easier to see all the web cmdlet issues. \r\n\r\n",
      "created_at": "2017-09-15T13:00:01Z",
      "updated_at": "2017-09-15T13:00:42Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "OK, I have been mentally planning this one for the past month and I finally have working code\r\n\r\nhttps://github.com/PowerShell/PowerShell/compare/master...markekraus:MultiPartSimplification\r\n\r\nI'm looking for feedback from anyone in this thread.\r\n\r\nI added 2 paramters `-AsMultipart` and `-MultipartFileFieldName`. When submitting a file via multipart a fieldname is required. The logic has been reworked to allow for `-InFile` and `-Body` provided `-AsMultipart` is present and provided the body is either a `IDictionary` or  `MultipartFormDataContent`. \r\n\r\nThe new `-Body` usage in #4782 is still there and doesn't require `-AsMultipart` but I expanded it to work with `-AsMutlipart` and to accept a `-File` (`-Body` is arlready blocked by the `MultipartFormDataContent` so you cant supply both a `MultipartFormDataContent` and an `IDictionary`).\r\n\r\nThis is all somewhat painful.. but I can confirm this works:\r\n\r\n```powershell\r\n\"Test Contents\" | Set-Content -Path C:\\temp\\test.txt\r\n$uri = Get-WebListenerUrl -Test Multipart\r\n$Params = @{\r\n    AsMultipart            = $true\r\n    Body                   = @{Testy=\"testest\"} \r\n    Uri                    = $uri \r\n    Method                 = 'POST' \r\n    InFile                 = \"C:\\temp\\test.txt\" \r\n    ContentType            = 'text/plain' \r\n    MultipartFileFieldName = 'TestFile'\r\n}\r\n$results = Invoke-RestMethod @Params\r\n```",
      "created_at": "2017-10-14T21:40:08Z",
      "updated_at": "2017-10-14T21:40:08Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "Should we adopt a similar syntax to curl?\r\n\r\n```powershell\r\ninvoke-restmethod -Form @{key=value;upload=\"@<filepath>\"}\r\n```\r\n",
      "created_at": "2017-10-14T22:22:45Z",
      "updated_at": "2017-10-14T22:22:45Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT I thought about that, but I have run into APIs that are picky about the Content-Type used for the file uploads, particularly those that are expecting images. I guess in those cases use could still create their own `MultipartFormDataContent` and supply it to `-Body`. Then there is the question of how to escape `@` in something like this `irm -Form @{TwitterUsername=\"@markekraus\"}`.  and how escape that escape sequence... etc.\r\n\r\nusing something like that would definitely make the internal logic easier to deal with and would make multiple file uploads available. \r\n\r\n",
      "created_at": "2017-10-14T23:34:26Z",
      "updated_at": "2017-10-14T23:34:26Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@markekraus I think we should optimize for general usage (80/20 rule).  I like using `@` as it's familiar to curl users and examples, but I'm slightly concerned about setting a precedent within PowerShell.  I think escaping `@` would just follow normal PowerShell rules: ``irm -form @{twitterusername=\"`@steve_msft\"}``",
      "created_at": "2017-10-15T00:03:15Z",
      "updated_at": "2017-10-15T00:03:15Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "> ``irm -form @{twitterusername=\"`@steve_msft\"}``\r\n\r\nWouldn't that just arrive at the cmdlets as `@steve_msft` and then the cmdlet would try to process the `steve_msft` file? `@` has always been problematic in strings because it such a commonly used internet character. It was always painful in curl if you needed an `@` prepended string. In any case, there would need to be string parsing of some kind added. \r\n\r\nI too worry about that precedent.\r\n\r\nFor general usage, I think my current proposal works. Most of the requests I have seen for multipart is for uploading a single file (including the one at the root of this issue).  It doesn't introduce a new syntax and it reuses parameters that users are familiar with. \r\n\r\n```powershell\r\nInvoke-RestMethod -InFile \"C:\\temp\\test.txt\" -method POST -AsMultipart -MultipartFileFieldName Upload\r\n```",
      "created_at": "2017-10-15T00:21:01Z",
      "updated_at": "2017-10-15T00:21:01Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@markekraus you're right, the cmdlet wouldn't know the difference.  If most usage is for upload, then I would be fine with what you're proposing except that `-method POST` should be implied and if `Upload` is pretty standard, perhaps that should be default if `-InFile` is used.",
      "created_at": "2017-10-15T02:59:13Z",
      "updated_at": "2017-10-15T02:59:48Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "I don't think you're going to get a ton of complaints about how you do it, as long as you don't break existing scenarios. People can put up with a little awkwardness, as long as it's documented with examples, and it works.\r\n\r\nHaving said that, I was going to say that since PowerShell is OO, it seems to me that we don't need special markers to tell filenames from strings, because we have objects -- it would make sense to me to use an object ...\r\n\r\nI mean, from the previous example, if you had a FileInfo instead of a string ... \r\n\r\n```posh\r\nInvoke-RestMethod -Form @{ UserName = \"Jaykul\"; Avatar = (Get-Item .\\avatar.png) }\r\n```\r\n\r\n... well, you would know what to do, wouldn't you?",
      "created_at": "2017-10-15T04:53:20Z",
      "updated_at": "2017-10-15T04:53:20Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "We would add an accelerator [File]",
      "created_at": "2017-10-15T07:37:54Z",
      "updated_at": "2017-10-15T07:37:54Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT I agree on the Implicit POST. I don't think `multipart/form-data` is ever used with any other verb and if it is. It could be Implicit based on `-AsMutlipart`.\r\n\r\n@Jaykul That thought occurred to me after I signed off for the night. I'm OK with that. The other thing I thought of is that Having `-Form` in addition to `-InFile` and `-Body` might be a bit confusing, but, there really is no non-confusing way to go about all of this, IMO. so I guess we pick our poison.\r\n\r\nWhat object type should it be detected on? I don't work on the filesystem side of the house often. If `System.IO.FileSystemInfo` sufficient, or is there a better one?\r\n\r\n@iSazonov You know, `[file]` is something that it think has been missing from the language. That would be worth pursuing regardless of this use case, IMO. It would certainly help though:\r\n\r\n```powershell\r\nInvoke-RestMethod -Form @{ UserName = \"markekraus\"; Avatar = [file]\".\\avatar.png\" }\r\n```",
      "created_at": "2017-10-15T09:55:34Z",
      "updated_at": "2017-10-15T10:10:08Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "`System.IO.FileSystemInfo` is the common base class for both `DirectoryInfo` and `FileInfo`.   If this feature only handles a single file then `FileInfo` would make more sense.    ",
      "created_at": "2017-10-16T22:28:33Z",
      "updated_at": "2017-10-16T22:28:33Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "I had this thought this morning, what about also supporting streams? Stream support isn't widely used in PowerShell, but, I think it's been a missed opportunity. In PHP streams were very common for generating things on the fly like images (granted I haven't touched PHP in a really long time).",
      "created_at": "2017-10-16T22:32:31Z",
      "updated_at": "2017-10-16T22:32:31Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@markekraus I think streams would be additive and could be done separately from this one?",
      "created_at": "2017-10-17T00:59:11Z",
      "updated_at": "2017-10-17T00:59:11Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "New Issues to discuss [file]/[directory] and streams we need.",
      "created_at": "2017-10-17T04:06:23Z",
      "updated_at": "2017-10-17T04:06:23Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "For this specific implementation, it is actually simpler and trivial to add Stream support to `-Form`. We will already be doing type evaluation on the dictionary values and `StreamContent` takes a stream by default. It's actually more work, code-wise, to convert a supplied `FileInfo` to a stream and then to a `StreamContent` then it does to just wrap the supplied stream in a `StreamContent`. But if you think it's better to implement later I'm ok with that.",
      "created_at": "2017-10-17T08:52:48Z",
      "updated_at": "2017-10-17T08:52:48Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "If it's simpler to do it now, there's no reason to make it more complicated later.",
      "created_at": "2017-10-17T15:39:30Z",
      "updated_at": "2017-10-17T15:39:30Z"
    },
    {
      "author": "swinster",
      "author_association": "NONE",
      "body": "My tupenth, albeit your implementation talk is out of my knowledge base, when sending large file (think 1GB, indeed we regularly send 4GB files), some of my previous attempt to use PS have completely killed the sending system as the entire thing is read into memory. Streaming the file is the only sane way to do this (see previous comments). IMHO, without this ability, the whole feature falls flat. ",
      "created_at": "2017-10-17T22:54:20Z",
      "updated_at": "2017-10-17T22:54:20Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@swinster Both the current non-multipart `-InFile` and the multipart implementation (whichever one we end up going with) use a `StreamContent` object which stream the file to `HttpClient`. The web cmdlets themselves are not reading the entire file to memory, but that might be what the underlying CoreFX is doing. If you have confirmed this behavior persists in PowerShell core, can you open a new issue with how to reproduce it?",
      "created_at": "2017-10-17T23:08:34Z",
      "updated_at": "2017-10-17T23:08:34Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "[Related acticle](http://www.tugberkugurlu.com/archive/efficiently-streaming-large-http-responses-with-httpclient)",
      "created_at": "2017-10-18T04:12:30Z",
      "updated_at": "2017-10-18T04:12:30Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov That article is on the receiving (server->client) side were I believe there is already an open issue about it. @swinster was saying a similar problem occurs on the sending (client->server) side. I believe we are already efficient on the sending side. I think that problem for sending did exist in earlier versions, but since Core change to the HttpClient, I don't think it is an issue anymore. I have not looked deeply into the receiving side as that direction is complicated by all of the processing we do after the `HttpClient` call.",
      "created_at": "2017-10-18T08:58:34Z",
      "updated_at": "2017-10-18T08:59:00Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "Removing `Review - Committee`, I don't think it necessary for committee to review this anymore.  The current proposal seems fine.",
      "created_at": "2017-10-18T19:56:46Z",
      "updated_at": "2017-10-18T19:56:46Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT which proposal? `-Form` or reusing the existing parameters? Honestly, I was really digging `-Form`",
      "created_at": "2017-10-18T20:44:06Z",
      "updated_at": "2017-10-18T20:44:06Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "I thought this had landed on `-Form`?  (or perhaps that's just what I thought because I prefer it?)",
      "created_at": "2017-10-18T21:26:28Z",
      "updated_at": "2017-10-18T21:26:28Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT \r\nOk. I was just making sure. I'm good with `-Form` but since there were kind of multiple proposals floating about since my code post I wanted to make sure we were all on the same page:\r\n\r\n`-Form` will accept a dictionary where the keys will be the field names. String values will be processed as `StringContent`. `FileInfo` and `Stream` will be processed as `StreamContent`. Any other value type will be the result of `LanguagePrimitives.ConvertTo<string>()` and send as `StringContent`. The `Content-Type` of files and streams will be `application/octet-stream`. When `-Form` is supplied the method will be `POST` and anything passed to `-Method` and `-ContentType` will be ignored . `-Form` will be exclusive to `-Body` and `-InFile` and an terminating error will occur if they are used together.\r\n\r\nNote that users needing more control or advanced Multipart features may still create and supply a `MultipartFormDataContent` object to the `-Body` parameter as provided in #4782.",
      "created_at": "2017-10-18T21:38:04Z",
      "updated_at": "2017-10-18T21:44:02Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT You had reapplied the `Review - Committee` tag to this issue. Do you get a chance to discuss this one yesterday?",
      "created_at": "2017-10-19T08:36:44Z",
      "updated_at": "2017-10-19T08:36:44Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@markekraus no, we ran out of time, will try to get a resolution by next week although Joey and I are at PSConf next week...",
      "created_at": "2017-10-20T02:14:40Z",
      "updated_at": "2017-10-20T02:14:40Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee reviewed this and agree that the Form syntax of using a hashtable makes sense as well as adding appropriate accelerators for [file] and [directory].  Since HTTP Form supports Get in addition to Post, `-Method` is required when using `-Form`.",
      "created_at": "2017-12-06T23:49:27Z",
      "updated_at": "2017-12-06T23:49:27Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "Can you elaborate on `[file]` and `[directory]`? The discussion here mentions `FileInfo` and `DirectoryInfo`, so it's not clear which type mappings are proposed.",
      "created_at": "2017-12-07T00:08:51Z",
      "updated_at": "2017-12-07T00:08:51Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "on that same topic... should this accelerator implementation support provider items? \r\n\r\n```powershell\r\n[File]'somedrive:\\path\\to\\file.txt'\r\n```",
      "created_at": "2017-12-07T00:11:26Z",
      "updated_at": "2017-12-07T00:11:35Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "if `[file] -eq [system.io.fileinfo]`, I think that will cause confusion, e.g.\r\n\r\n```powershell\r\nusing namespace System.IO\r\n[File]::WriteAllLines($path, $line)\r\n```\r\n\r\nClearly that's not meant to be `FileInfo`, but if you don't see the `using`, you might be confused if you get used to see `[File]` in other places.",
      "created_at": "2017-12-07T00:16:09Z",
      "updated_at": "2017-12-07T00:16:09Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "For me, the name isn't so important as just having easy accelerators for files and directories. I'm not a huge fan of `[system.io.fileinfo]` not throwing on the file not existing. ideally this accelerator would be used like this\r\n\r\n```powershell\r\nfunction Get-Widget {\r\n    param([PSFile]$File)\r\n    # Do something with $File\r\n}\r\nGet-Widget -File 'x:\\no\\lo\\existo.nope'\r\n# parameter binding error for non existent file\r\nGet-Widget -File 'c:\\some\\real\\file.txt'\r\n# works with existing file\r\n\r\n$form = @{\r\n    StringField = 'stringValue'\r\n    FileField = [PSFile]'x:\\no\\lo\\existo.nope'\r\n}\r\n# type conversion error on non existing file\r\n$form = @{\r\n    StringField = 'stringValue'\r\n    FileField = [PSFile]'c:\\some\\real\\file.txt'\r\n}\r\n# no error\r\n```",
      "created_at": "2017-12-07T00:26:09Z",
      "updated_at": "2017-12-07T00:28:02Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "also... I'd like to note that the accelerators should not be blocking to the multipart implementation. I can implement this now with out `[file]` and add support for that later. The accelerators should have been tied to a separate issue. while having them would make the UX for the `-Form` feature easier, for now the user can do\r\n\r\n```powershell\r\n$form = @{\r\n    FileField = Get-Item 'c:\\some\\real\\file.txt'\r\n}\r\niwr -Form $form -Method POST -Uri $uri\r\n```",
      "created_at": "2017-12-07T00:34:29Z",
      "updated_at": "2017-12-07T00:34:29Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "The accelerators should be a separate issue and PR.  You can still use [System.IO.FileInfo] for now.",
      "created_at": "2017-12-07T01:47:39Z",
      "updated_at": "2017-12-07T01:47:39Z"
    },
    {
      "author": "swinster",
      "author_association": "NONE",
      "body": "Just a quick question. with regard to this issue, has anything made it to PowerShell v6 as yet ?\r\n\r\nNot sure if the underlying mechanism to retrieve a file will be altered, but it came to light the other day that the way I have the \"working\" at the moment in v5 is a little on the slow side. An HTTP download of a 4GB file from a browser from a server based on the same network takes approximately 30 seconds. In PowerShell v5, this takes around 1 hour !!!",
      "created_at": "2017-12-28T12:22:04Z",
      "updated_at": "2017-12-28T12:22:04Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@swinster PowerShell 6.0.0 includes the ability to supply a `System.Net.Http.MultipartFormDataContent` object to the `-Body` parameter. You can read about this in detail here https://get-powershellblog.blogspot.com/2017/09/multipartform-data-support-for-invoke.html . The simplified `-Form` parameter will be added in 6.1.0 (assuming nothing comes up or blocks it). It is the first feature on my TODO list, but I have a few bugs and some code refactoring I would like to resolve first.",
      "created_at": "2017-12-28T12:42:56Z",
      "updated_at": "2017-12-28T12:42:56Z"
    },
    {
      "author": "swinster",
      "author_association": "NONE",
      "body": "Awesome work, thanks @markekraus . Can't wait to be able to retrieve files with `-outfile`",
      "created_at": "2017-12-28T13:13:06Z",
      "updated_at": "2017-12-28T13:28:19Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": ">  Can't wait to be able to retrieve files with -outfile\r\n\r\n@swinster Can you elaborate on this? You can already download files and use the `-OutFile` parameter to save them. This has been around for several versions at least.\r\n\r\nThe blog post I linked has an earlier version of what was planned for the simplified multipart/form-data support. The planned implimentation has since been revised. You can see a \"demo\" of the currently planned simplified multipart/form-data support here https://get-powershellblog.blogspot.com/2017/12/powershell-core-web-cmdlets-in-depth_24.html#L21 and you can see the proposal here https://github.com/PowerShell/PowerShell/issues/2112#issuecomment-337735585",
      "created_at": "2017-12-28T15:14:04Z",
      "updated_at": "2017-12-28T15:14:04Z"
    },
    {
      "author": "swinster",
      "author_association": "NONE",
      "body": "@markekraus apologies, the comment above was not in the correct place as it related to the underlying method of data retrieval from a simple GET method on the `Invoke-WebRequest`, which _was_ in the order of 200 time slower that a browser request, but actually nothing to do the MultiPart uploads.  However, I have just run the same basic tests using `Invoke-WebRequest` to GET a large file in v6 and v5 simultaneously and honestly there is a HUGE difference - whoever made these changes to the implementation here need some applause as well - even if this is the wrong place!",
      "created_at": "2017-12-28T18:40:21Z",
      "updated_at": "2017-12-28T18:40:21Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "An update for anyone following this issue. I am currently working on implementing the solution as approved by the PowerShell Committee with some minor adjustments. I hope to have a PR submitted in the coming days.\r\n\r\nAfter reading RFC-7578 it became clear that a single field name can be supplied multiple times with different field values. The use case for this is an array of files (multiple file selection) or values for a single form field. To accommodate that, I'm adjusting the implementation slightly to treat collections as multiple field values for the same field name.\r\n\r\nfor example:\r\n\r\n```powershell\r\n$Form = @{\r\n    Files = Get-ChildItem c:\\temp -File\r\n    Names = \"Bill\", \"Sue\", \"Jane\"\r\n    Cars = [System.Collections.Generic.List[String]]::new([String[]]@(\"Smart\", \"Honda\"))\r\n    Description = \"Multiple and single value support.\"\r\n    Image = [System.IO.FileInfo]\"c:\\picture\\me.png\"\r\n}\r\nInvoke-WebRequest -Method POST -Uri $uri -Form $Form\r\n```\r\n\r\nIn the approved implementation, this would result in a collection being converted to a single string. In the implementation I am working on, `Names` would be supplied 3 times with `Bill` as the first value, `Sue` as the second, and `Jane` as the third. It doesn't add much complexity and initial testing shows it works for endpoints that support it. It provides more flexibility at minimal cost. After checking, I personally have an internal use case for this in a form that requires multiple values for a single field.",
      "created_at": "2018-01-20T15:25:44Z",
      "updated_at": "2018-01-20T15:25:44Z"
    }
  ],
  "created_at": "2016-08-28T22:11:08Z",
  "labels": [
    "Issue-Enhancement",
    "Resolution-Fixed",
    "Committee-Reviewed",
    "WG-Cmdlets-Utility"
  ],
  "number": 2112,
  "state": "closed",
  "title": "Simplify usage of Multipart Uploads with WebRequestPSCmdlet",
  "updated_at": "2018-05-26T19:12:30Z"
}