{
  "_url": "https://github.com/PowerShell/PowerShell/issues/4612",
  "author": "bergmeister",
  "body": "#4215: Add ability to create a temporary file with a specific extension to `New-TemporaryFile`\r\nImplemented exactly as described by adding an optional `-Extension` parameter to specify the extension e.g. as `.csv` or just `csv`.\r\nBecause of the required change to call different .NET APIs, the cmdlet had to be slightly rewritten to cater for the special case that the file to be created already exists in the temp folder.\r\n\r\n",
  "closed_at": "2018-02-21T18:26:51Z",
  "comments": [
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "I have addressed the main suggestions but would like to wait until we have reached a consensus on the preferred approaches with the issues of the possibility of not being able to create a temp file and how to deal with it\r\n\r\n- We could use a `Guid` for the filename to minimise the probability of a file name clash instead of `Path.GetRandomFileName()`. @iSazonov has suggested to use [this](https://github.com/PowerShell/PowerShell/blob/02b5f357a20e6dee9f8e60e3adb9025be3c94490/src/System.Management.Automation/utils/PathUtils.cs#L420) existing pattern as an alternative but I struggle to see why as it suffers from the same problem and also does not deal with other exceptions due to e.g. insufficient permissions, disk space. Maybe you can elaborate more on it?\r\n- We could simply let it fail and not have a retry mechanism\r\n\r\nI think in general it is good that we move away from `Get-TempFileName` due to it's limitations (see e.g.\r\n [here](https://github.com/dotnet/cli/issues/6995)) but I am wondering if this is not a also a case for the coreclr to improve the current implementation and possible offer an extension overload...\r\n\r\nI find it great that many people share their thoughts but at the end I would like to have a final word from someone before I make a commit to avoid going back and forth.",
      "created_at": "2017-08-18T21:49:29Z",
      "updated_at": "2017-08-18T21:52:35Z"
    },
    {
      "author": "PaulHigin",
      "author_association": "COLLABORATOR",
      "body": "A GUID based filename would certainly solve the problem but after thinking about it some more I am Ok with the retry loop.  It feels like a reasonable compromise to write an error and fail after 10 tries.  Also I am fine with initializing the new property with \".tmp\".  Using GUIDs feels like overkill.  But maybe we could add a switch to allow it as an option.  Something like:\r\n```powershell\r\nNew-TemporaryFile -GuidBasedName\r\n```",
      "created_at": "2017-08-18T22:43:36Z",
      "updated_at": "2017-08-18T22:43:36Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "@PaulHigin \r\nYes, we could easily add a `-GuidBasedName` switch parameter without making the code complicated.\r\n\r\nJust to recap: Before this PR, the cmdlet was simply calling `GetTempFileName` and letting it handle the error. When you look at the (Windows) implementation of `GetTempFileName` [here](https://github.com/dotnet/coreclr/blob/0ee276fc7512c3cff53870fc5fea65b0fad52300/src/mscorlib/shared/System/IO/Path.Windows.cs#L103) then all it does is call the `Interop.Kernel32.GetTempFileNameW` method [here](https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/shared/Interop/Windows/Kernel32/Interop.GetTempFileNameW.cs), which directly calls the Windows API [here](https://msdn.microsoft.com/en-us/library/windows/desktop/aa364991(v=vs.85).aspx), which states:\r\n>Due to the algorithm used to generate file names, GetTempFileName can perform poorly when creating a large number of files with the same prefix. In such cases, it is recommended that you construct unique file names based on GUIDs.\r\n>... This limits GetTempFileName to a maximum of 65,535 unique file names if the lpPathName and lpPrefixString parameters remain the same.\r\n(NB: The API is called with lpPathName are lpPrefixString remaining the same)\r\n\r\nTo conclude: Without the retry logic, we would have not changed the error behaviour of the cmdlet because it was always just throwing if there is a problem (the Unix implementation of `GetTempFileName` [here](https://github.com/dotnet/coreclr/blob/3a24d8bff0398762745d9f23e10184f102943a80/src/mscorlib/shared/System/IO/Path.Unix.cs#L155) is similar and would suffer from the same problem).\r\nThe final conclusion seems to be:\r\n\r\n- The retry mechanism improves the existing behaviour in case of an unfortunate clash and therefore reduces sporadic failures\r\n- The `Guid` based approach would makes it really robust and also make it possible to have more than 65,535 files in the temp folder.\r\n\r\nTherefore I also agree that keeping the retry mechanism improves the error behaviour without making breaking changes to its past behaviour and the `-GuidBasedName` switch would provide a more robust option going forward.",
      "created_at": "2017-08-18T23:52:26Z",
      "updated_at": "2017-08-19T08:47:32Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@PaulHigin \r\n>A GUID based filename would certainly solve the problem but after thinking about it some more I am Ok with the retry loop.\r\n\r\nWhy do you think this problem exists?\r\nWhy hasn't this been corrected in .Net Framework in the last 15 years and has not been corrected in CoreFX now?\r\nDo we actually have scripts that create more than 50000 temporary files without removing them?\r\nAre there real support cases on this problem?\r\nDoes anyone really need temporary file names based on GUIDs?\r\n\r\nIf so, right way is - we have to open Issue in CoreFX and fix the problem there without complicating PowerShell Core code.",
      "created_at": "2017-08-19T20:49:42Z",
      "updated_at": "2017-08-19T20:49:42Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "After further thinking, I believe that if the CoreFX algorithm is bad, it must be corrected in CoreFX, not here.\r\nSo our code should be simple:\r\n```c#\r\ntry\r\n{\r\n    var tempFile = GetTempFileName();\r\n    if (parameter Extension present)\r\n    {\r\n         replace extension in tempFile\r\n    }\r\n\r\n    WriteObject(tempFile);\r\n}\r\ncatch\r\n{\r\n    WriteError(...) or write terminating error;\r\n}\r\n```",
      "created_at": "2017-08-20T11:01:53Z",
      "updated_at": "2017-08-20T11:01:53Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov In the beginning I was thinking that a fix in corefx would be nicer as well since this is a common problem that also others have (see e.g. [here](https://github.com/dotnet/cli/issues/6995)).\r\nIf you look at my links above to the actual implementations, then you can see that it would be trivial to improve the corefx algorithms (Windows & Unix) to have an overload with a non-default extension but it would require more work to improve the file name uniqueness limitation to 65,535 files due to the Windows API that it calls at the end, etc.\r\nThe reason why I was hesitating to ask for a change in corefx is because corefx is probably not very happy with adding an overload that is not part of .net standard (which would then also require an implementation of the new overload in Xamarin and full .Net). What do others think?",
      "created_at": "2017-08-20T12:16:07Z",
      "updated_at": "2017-08-20T12:16:07Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Sorry for being unclear - I meant that it is better to fix \"the file name uniqueness limitation to 65,535 files\" algorithm in CoreFX not extension - adding new overload for extension require .Net Standard change - it is very long process. Also it will be not approved without real business case - mentioned issue is unuseful because don't contains any arguments.",
      "created_at": "2017-08-21T07:32:45Z",
      "updated_at": "2017-08-21T07:32:45Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@lzybkr Could you please clarify about used algorithm (my comments [here](https://github.com/PowerShell/PowerShell/pull/4612#issuecomment-323546991) and [here](https://github.com/PowerShell/PowerShell/pull/4612#issuecomment-323577938))? I still think we're making an unreasonable complication trying to \"fix\" CoreFX without justifying and business case and adding ` -UseGuid`.",
      "created_at": "2017-08-22T07:35:31Z",
      "updated_at": "2017-08-22T07:35:31Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "Oh, I think `-UseGuid` is overkill, but the retry logic is necessary at some layer, and in the case of wanting an extension that differs from what .Net uses, we can't simply replace the extension, .Net guarantees the original filename is safe, but not the basename + any other extension.",
      "created_at": "2017-08-22T17:09:54Z",
      "updated_at": "2017-08-22T17:09:54Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "@PaulHigin @lzybkr I have made all the requested changes for the test syntax, error message and removed the switch parameter for the Guid file name. The only thing that I noticed at the end was the fact that the cmdlet has always always (before this PR) overridden the `EndProcessing()` method and I was wondering if it should not rather be `ProcessRecord()`?",
      "created_at": "2017-08-22T21:42:08Z",
      "updated_at": "2017-08-22T21:42:08Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "For cmdlets that do not accept any pipeline input, `EndProcessing` is the correct place for the core logic.",
      "created_at": "2017-08-22T21:45:11Z",
      "updated_at": "2017-08-22T21:45:11Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "Ok. Thanks for clarifying it.",
      "created_at": "2017-08-22T22:10:08Z",
      "updated_at": "2017-08-22T22:10:23Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Current algorithm is bad and have security hole on Unix.",
      "created_at": "2017-08-23T13:33:42Z",
      "updated_at": "2017-08-23T13:33:42Z"
    },
    {
      "author": "PaulHigin",
      "author_association": "COLLABORATOR",
      "body": "@iSazonov \r\nPlease explain the security hole.  ",
      "created_at": "2017-08-23T14:14:12Z",
      "updated_at": "2017-08-23T14:14:12Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@PaulHigin Sorry for being short - I was busy.\r\n\r\nDisposition. We use CoreFX method to get a temp file. CoreFX uses system calls to get one (links above) - both Windows and Unix have the functions implemented many years ago and they is well-tested and used everyone without claims. Now we want make the thing _better than_ Windows kernel team and glibc team. We haven't Windows sources (we have a comment from MSDN, see above) but we can review[ glibc implementation](https://github.com/gcc-mirror/gcc/blob/master/libiberty/mkstemps.c) and read [mkstemps](http://man7.org/linux/man-pages/man3/mkstemp.3.html) docs.\r\nWith the PR's algorithm we get two classic problem for both platforms - for Unix they is critical.\r\n1. Race condition. We create a file name then create a file with ten attempts - glibc do >16000 attempts. It is critical for Unix because _all_ processes creates temp files in shared folder `/temp`.\r\n2. Security. We create file with [0666 permissions](https://github.com/dotnet/coreclr/blob/ /src/mscorlib/shared/System/IO/FileStream.Unix.cs#L50) by default. On Unix all temp files is created in shared folder `/temp` and security is critical.  In glibc implementation on Unix all temp files is created in shared folder `/temp` with 0600 permissions to block access to the file from other accounts. \r\n3. It also explains why our attempt to use Guids is bad too.\r\n\r\nSo my conclusion - we can not get better solution than CoreFX. We only can reimplement glibc `mstemps()` and customize it to support any suffix. I believe that our efforts are not worth the result - I don't see the urgent need to create temp files with a different extension (business case?). We should close the PR and Issue with Won't fix.\r\n\r\n",
      "created_at": "2017-08-23T18:55:35Z",
      "updated_at": "2017-08-23T18:55:35Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "Thanks @iSazonov for the analysis - I had your intuition in the back of my mind, but no specifics.\r\n\r\nI do believe there is a real customer need and that the workarounds are probably worse than what is currently implemented in this PR.\r\n\r\nIf we addressed the permissions and the race condition, then I think it's an improvement over the status quo even if it isn't perfect.",
      "created_at": "2017-08-23T20:21:12Z",
      "updated_at": "2017-08-23T20:21:12Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov: \r\n\r\n* As for the business case: Remember that GNU `mktemp` already allows you to specify a custom extension (suffix), via its far more flexible `XXX...` templating feature;  e.g, something like  \r\n `mktemp -t XXX.csv` yields something like `/tmp/kLJ.csv`. (BSD `mktemp` works differently and is less flexible - it only allows you to specify a custom _prefix_.)\r\n\r\n* All great technical points.\r\n\r\nA simple way of rewriting this PR in order to keep `Path.GetTempFileName()` in charge is to:\r\n\r\n* _Always_ start out with `filePath = Path.GetTempFileName()`  - this will ensure the proper permissions.\r\n\r\n* Only if `-Extension` was specified:\r\n  * Use `filePathWithCustomExt = Path.ChangeExtension(filePath, Extension)` and then  _rename_ that file (`File.Move(filePath, filePathWithCustomExt)`) _in a retry loop_.\r\n\r\nA retry loop is then only necessary in the `-Extension` case, which means _we_ have to pick a retry count; picking a high count should be fine, as collisions are unlikely.\r\n\r\n",
      "created_at": "2017-08-23T20:43:01Z",
      "updated_at": "2017-08-23T20:43:01Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@lzybkr @mklement0 Thanks for the discussion!\r\nWithout MSFT CRM \ud83d\ude04  I can not disprove \"I do believe there is a real customer need\" - so we want `-Extension`.\r\nAbout implementation. We could implement simple workaround as @mklement0 suggested to only \"close the hole\". I prefer \"perfect\" solution \ud83d\ude04 \r\nI have no doubt that the right place is CoreFX. This requires an exhancement of the .Net Standard and subsequent implementation - it is a long process - we should open a Issue in CoreFX.\r\nToday we could implement this in PowerShell Core but we have an Issue to create temp directories either in the cmdlet or in new one. And we see a symmetrical situation - Unix has a richer API than Windows. We again should ask CoreFX to enhance API to create temp directories.\r\nHence we should create the proposed API and implement it in our Core Facade block to easily migrate to CoreFX implementations later - nothing new - we used such approach in .Net Core 1.0 time and continue currently with 2.0.\r\nThus we suggest to get Unix mktemp-like functions and re-implement them for both platforms.\r\n\r\n",
      "created_at": "2017-08-24T04:27:52Z",
      "updated_at": "2017-08-24T04:28:22Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov: \ud83d\udc4d \r\n\r\n> I cannot disprove \"I do believe there is a real customer need\" \r\n\r\nWell, I'm a customer, and I have that need. \r\nQ.E.D. \r\n\ud83d\ude1c\r\n",
      "created_at": "2017-08-24T07:42:24Z",
      "updated_at": "2017-08-24T07:42:24Z"
    },
    {
      "author": "PaulHigin",
      "author_association": "COLLABORATOR",
      "body": "@iSazonov \r\nSorry but I am still unclear on the issues.  The latest algorithm in this PR seems Ok to me.  It makes ten attempts to a) generate a random file name then b) create the file.  Each attempt either succeeds or fails.\r\n\r\nBut it sounds like the dotNet implementation of file creation is susceptible to race and file access permission errors where a) two processes end up with access to the same temp file and b) file access permission is incorrect and possibly detrimental to one of the processes owning the file causing a security hole.\r\n\r\nIs this correct?\r\n\r\nSo the conclusion is that currently there is no way to safely create a new file until these dotNet layer bugs are fixed.  You are suggesting that we create our own native layer file creation for both Windows and Linux platforms that do not have these weaknesses, and then try and get these changes into dotNet.  Correct?\r\n\r\nThanks!",
      "created_at": "2017-08-24T15:55:20Z",
      "updated_at": "2017-08-24T15:55:20Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@PaulHigin \r\n>The latest algorithm in this PR seems Ok to me\r\n\r\nFormally it is Ok. Really it has race and security hole. \r\n\r\n>until these dotNet layer bugs are fixed.\r\n\r\nIt is not CoreFX bugs. This is due to the misuse of these functions. With glibc we can get the same - that's why `mkstemps()` was added.\r\n\r\nMy suggestion for CoreFX is add something like:\r\n```c#\r\npublic static string GetTempFileName(string Suffix)\r\npublic static string GetTempFileName(string Prefix)\r\npublic static string GetTempFileName(string InTempDirectory)\r\npublic static string GetTempFileName(string Prefix, string Suffix)\r\npublic static string GetTempFileName(string Prefix, string Suffix, int VariableLength)\r\npublic static string GetTempFileName(string Prefix, string Suffix, int VariableLength, string InTempDirectory)\r\n\r\n// And API to create temp directory\r\n```\r\n\r\nYes, my suggestion is implement the APIs temporary in PowerShell.",
      "created_at": "2017-08-24T16:21:25Z",
      "updated_at": "2017-08-24T16:21:25Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "I think it would be best  to modify the existing algorithm using the proposal of @mklement0 , which sounds like an overal improvement and closes the  'hole' (assuming that the rename method does not change  the file permissions). I am not sure if this 'hole' is a bit superficial because on Windows any other process can edit the generated temporary file and it would only affect security if a developer directly injected content of the temporary file into other methods in their program or script(please correct me if i'm wrong). Any decent developer should know that any input has the possibility of being a vulnerability for injection methods and therefore needs to assess the risk and potentially defend against it. We should probably have a chat with corefx (maybe we don't have enough understanding of the security model that underlines corefx) but trying to do all the low level stuff ourselves makes it look like to me that we are either overegging the pudding or that corefx is unsafe.",
      "created_at": "2017-08-24T20:43:20Z",
      "updated_at": "2017-08-24T20:43:20Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@bergmeister Sorry for the delay.\r\nBased on @lzybkr and @mklement0 conlusion we can continue to follow the @mklement0  proposal:\r\n>A simple way of rewriting this PR in order to keep `Path.GetTempFileName()` in charge is to:\r\n* _Always_ start out with `filePath = Path.GetTempFileName()`  - this will ensure the proper permissions.\r\n\r\n* Only if `-Extension` was specified:\r\n  * Use `filePathWithCustomExt = Path.ChangeExtension(filePath, Extension)` and then  _rename_ that file (`File.Move(filePath, filePathWithCustomExt)`) _in a retry loop_.\r\n\r\n",
      "created_at": "2017-08-31T05:56:46Z",
      "updated_at": "2017-08-31T05:57:12Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov @lzybkr I have committed the change in the algorithm as agreed in the last comment, the only subtle difference was that the retry logic always applies because it was 'free' and allowed to have less and more elegant code this way.",
      "created_at": "2017-08-31T23:18:33Z",
      "updated_at": "2017-08-31T23:18:33Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "I addressed the main points made in the review:\r\n - If the extension is '.tmp', then it goes through the same codepath as before this PR and only otherwise use the new algorithm\r\n - cater for failure if file deletion fails in catch block\r\n - Usage of `Ordinal` string comparison\r\n - improve tests and add Unix specific test for '.TMP' where we expect the file ending in '.tmp' to not exist on Linux",
      "created_at": "2017-09-30T22:59:47Z",
      "updated_at": "2017-10-06T21:38:00Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "I have updated the test to pass since one test did not make sense on Mac due to the the fact that Mac sees files with different casing as the same file similar to Windows.",
      "created_at": "2017-10-06T21:39:55Z",
      "updated_at": "2017-10-06T21:39:55Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Currently we have new API request in CoreFX and CoreFX team has post 2.1 plans to enhance the API. Feel free to vote for the API.\r\nI believe we can close the PR as non-critical and wait CoreFX implementation.",
      "created_at": "2018-02-21T16:19:04Z",
      "updated_at": "2018-02-21T16:19:04Z"
    }
  ],
  "created_at": "2017-08-18T11:51:40Z",
  "number": 4612,
  "state": "closed",
  "title": "Implement -Extension parameter in New-TemporaryFile cmdlet",
  "updated_at": "2018-02-21T18:26:51Z"
}