{
  "_url": "https://github.com/PowerShell/PowerShell/issues/17580",
  "author": "he852100",
  "body": "### Prerequisites\r\n\r\n- [X] Write a descriptive title.\r\n- [X] Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\r\n- [X] Search the existing issues.\r\n- [X] Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\r\n- [X] Refer to [Differences between Windows PowerShell 5.1 and PowerShell](https://docs.microsoft.com/powershell/scripting/whats-new/differences-from-windows-powershell).\r\n\r\n### Steps to reproduce\r\n\r\n```\r\nfunction UnescapeNonIsoChar($inputString) {\r\n    Try {\r\n        [regex]::replace($inputString, '(?:\\\\u[0-9a-f]{4})+', { \r\n            param($m) \r\n            $utf8Bytes = (-split ($m.Value -replace '\\\\u([0-9a-f]{4})', '0x$1 ')).ForEach([byte])\r\n            [text.encoding]::UTF8.GetString($utf8Bytes)\r\n            \r\n        })\r\n    } Catch {\r\n        [regex]::Unescape($inputString)\r\n    }\r\n}\r\n\r\n@'\r\nprofile.header.profile=\\u00e6\\u00aa\\u0094\\u00e6\\u00a1\\u0088\\u00e5\\u0090\\u008d\\u00e7\\u00a8\\u00b1\r\nprofile.header.customer=\\u00e5\\u00ae\\u00a2\\u00e6\\u0088\\u00b6\\u00e5\\u0090\\u008d\\u00e7\\u00a8\\u00b1\r\nprofile.header.account=\\u00e5\\u00b8\\u00b3\\u00e8\\u0099\\u009f/\\u00e6\\u00a2\\u009d\\u00e4\\u00bb\\u00b6\\u00e4\\u00bb\\u00a3\\u00e7\\u00a2\\u00bc\r\nprofile.header.description=\\u00e6\\u008f\\u008f\\u00e8\\u00bf\\u00b0\r\nlayout.msg.updatePrimaryUsersLayout=Kindly save it as a New Layout as Primary user\\u2019s layout cannot be updated.\r\n'@ -split [System.Environment]::NewLine |\r\n    ForEach-Object {\r\n        UnescapeNonIsoChar -inputString $_\r\n    }\r\nHit Variable breakpoint on '$string' (Write access)\r\n\r\nAt line:8 char:13\r\n+             $string=[text.encoding]::UTF8.GetString($utf8Bytes)\r\n+             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n[DBG]: PS C:\\Users\\he123>> [text.encoding]::UTF8.GetString($utf8Bytes)\r\n\u6a94\u6848\u540d\u7a31\r\n[DBG]: PS C:\\Users\\he123>> c\r\nHit Variable breakpoint on '$string' (Write access)\r\n\r\nAt line:8 char:13\r\n+             $string=[text.encoding]::UTF8.GetString($utf8Bytes)\r\n+             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n[DBG]: PS C:\\Users\\he123>> c\r\nprofile.header.profile=\u00e6\u00aa\u00e6\u00a1\u00e5\u00e7\u00a8\u00b1\r\nprofile.header.customer=\u00e5\u00ae\u00a2\u00e6\u00b6\u00e5\u00e7\u00a8\u00b1\r\nprofile.header.account=\u00e5\u00b8\u00b3\u00e8/\u00e6\u00a2\u00e4\u00bb\u00b6\u00e4\u00bb\u00a3\u00e7\u00a2\u00bc\r\nprofile.header.description=\u00e6\u00e8\u00bf\u00b0\r\nlayout.msg.updatePrimaryUsersLayout=Kindly save it as a New Layout as Primary user\u2019s layout cannot be updated.\r\n```\r\n\r\n### Expected behavior\r\n\r\n```console\r\nprofile.header.profile=\u6a94\u6848\u540d\u7a31 \u6a94\u6848\u540d\u7a31\r\nprofile.header.customer=\u5ba2\u6236\u540d\u7a31 \u5ba2\u6236\u540d\u7a31\r\nprofile.header.account=\u5e33\u865f \u5e33\u865f/\u689d\u4ef6\u4ee3\u78bc \u689d\u4ef6\u4ee3\u78bc\r\nprofile.header.description=\u63cf\u8ff0 \u63cf\u8ff0\r\nlayout.msg.updatePrimaryUsersLayout=Kindly save it as a New Layout as Primary user\u2019s layout cannot be updated.\r\n```\r\n\r\n\r\n### Actual behavior\r\n\r\n```console\r\nprofile.header.profile=\u00e6\u00aa\u00e6\u00a1\u00e5\u00e7\u00a8\u00b1\r\nprofile.header.customer=\u00e5\u00ae\u00a2\u00e6\u00b6\u00e5\u00e7\u00a8\u00b1\r\nprofile.header.account=\u00e5\u00b8\u00b3\u00e8/\u00e6\u00a2\u00e4\u00bb\u00b6\u00e4\u00bb\u00a3\u00e7\u00a2\u00bc\r\nprofile.header.description=\u00e6\u00e8\u00bf\u00b0\r\nlayout.msg.updatePrimaryUsersLayout=Kindly save it as a New Layout as Primary user\u2019s layout cannot be updated.\r\n```\r\n\r\n\r\n### Error details\r\n\r\n```console\r\n\u00e6\u00aa\u00e6\u00a1\u00e5\u00e7\u00a8\u00b1\r\n```\r\n\r\n\r\n### Environment data\r\n\r\n```powershell\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.2.5\r\nPSEdition                      Core\r\nGitCommitId                    7.2.5\r\nOS                             Microsoft Windows 10.0.22621\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n\r\n\r\n### Visuals\r\n\r\n_No response_",
  "closed_at": "2022-07-01T00:01:09Z",
  "comments": [
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "I\u2019ve yet to look at the full code but you are trying to convert the unicode codepoint to a byte and treat that as utf-8 bytes. This isn\u2019t correct as the `\\uxxxx` is a unicode codepoint and you can treat it as a representation of a char. For example instead of\r\n\r\n```powershell\r\n$utf8Bytes = (-split ($m.Value -replace '\\\\u([0-9a-f]{4})', '0x$1 ')).ForEach([byte])\r\n[text.encoding]::UTF8.GetString($utf8Bytes)\r\n```\r\n\r\nYou should be doing\r\n\r\n```powershell\r\n[char][int]($m.Value -replace '\\\\u([0-9a-f]{4})', '0x$1') \r\n```\r\n\r\nThis should give you the hex representation of the codepoint (`0x00E6`), cast it to an integer, then finally cast that integer to the char. When it gets replaced back into the string it becomes a string.\r\n\r\nThis is untested so the code you need might be slightly different.",
      "created_at": "2022-06-25T01:23:58Z",
      "updated_at": "2022-06-25T01:23:58Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "If we take a short snippet we can test this out\r\n\r\n```powershell\r\n'profile.header.profile=\\u00e6\\u00aa\\u0094\\u00e6' -replace '\\\\u([0-9a-f]{4})', {\r\n    [char][int]($_.Value -replace '\\\\u([0-9a-f]{4})', '0x$1') \r\n}\r\n```\r\n\r\nThis outputs\r\n\r\n```\r\nprofile.header.profile=\u00e6\u00aa\u00e6\r\n```\r\n\r\nIt's not your expectation but it matches the `\\u` escape values you have.\r\n\r\n* [\\u00e6](https://www.fileformat.info/info/unicode/char/00e6/index.htm) - `\u00e6`\r\n* [\\u00aa](https://www.fileformat.info/info/unicode/char/00aa/index.htm) - `\u00aa`\r\n* [\\u0094](https://www.fileformat.info/info/unicode/char/0094/index.htm) - `\u201d` (seems to be a control character which is why it isn't shown)\r\n* [\\u00e6](https://www.fileformat.info/info/unicode/char/00e6/index.htm) - `\u00e6`\r\n\r\nI have noticed that the expectation is based on each codepoint being a raw byte. So my comments above do not apply.\r\n\r\nWhat is weird is your reproducer does what you want, it is correctly encoding each `\\uxxxx` as a byte and you are correctly encoding those bytes to the proper string character. When I run it in my console I get the expected result back.",
      "created_at": "2022-06-25T01:45:55Z",
      "updated_at": "2022-06-25T01:45:55Z"
    },
    {
      "author": "he852100",
      "author_association": "NONE",
      "body": "It is utf8 encoded\r\n\\u00e6\\u00aa\\u0094\\u00e6\\u00a1\\u0088\\u00e5\\u0090\\u008d\\u00e7\\u00a8\\u00b1\r\ne6aa94\uff1a\u6a94\r\n\\u00e6\\u00a1\\u0088 \r\ne6a188\uff1a\u6848\r\n----\r\n`(-split ($m.Value -replace '\\\\u([0-9a-f]{4})', '0x$1 ')).ForEach([byte])  `\r\nis:\r\n\\u00e6 to 0x00e6 to 230 byte(hex to dec)   \r\n\r\nNo problem with the code\r\n  \r\n![image](https://user-images.githubusercontent.com/26913892/175755988-06d020a9-fb45-44f8-b45b-4f358cd82fec.png)\r\n\r\nYou should note that it works during debugging\uff0cWhen it is saved as a PS1 file, it works properly  \r\nIt always uses **iso-8859-1** no matter how you tweak it",
      "created_at": "2022-06-25T03:10:28Z",
      "updated_at": "2022-06-25T03:29:12Z"
    },
    {
      "author": "kasini3000",
      "author_association": "NONE",
      "body": "> When it is saved as a PS1 file, it works properly It always uses iso-8859-1 no matter how you tweak it\r\n\r\ntry:\r\nsave ps1 file add BOM head,encoding any\r\nps1 \u5185\u82e5\u542b\u6709\u4e2d\u65e5\u97e9\u7b49\u7f16\u7801\uff0c\u5fc5\u987b\u4fdd\u5b58\u6210bom\u5934\uff0c\u7f16\u7801\u4efb\u610f\u3002\r\n\u5373bom+utf8\u53ef\u4ee5\uff0cbom+utf16le\u4e5f\u884c\u3002\r\nbom\u5934\uff0cbom\u5934\uff0c\u6709\u5934\u65e0\u4e71\u7801\u3002\u8fd8\u652f\u6301\u4e2d\u6587\u53d8\u91cf\u540d\uff0c\u97e9\u6587\u53d8\u91cf\u540d\uff0c\u53c2\u6570\u540d\uff0c\u53c2\u6570\u503c\uff0c\u7b49\u3002\r\n\r\n\u6ce8\u610f\uff1a\u4f60\u7684\u4ee3\u7801\uff0c\u53ea\u8981\u52a0\u4e0abom\u5934\u4fdd\u5b58\u3002\u5728powershell 5.1\uff0cpowershell 7.3 preview\u4e2d\u8fd0\u884c\u6beb\u65e0\u95ee\u9898\uff0c\u5df2\u7ecf\u6d4b\u8bd5\u3002\r\n\r\n\\u00e6\\u00aa\\u0094\\u00e6\\u00a1\\u0088\\u00e5\\u0090\\u008d\\u00e7  ----\u8fd9\u4e9b\u4e1c\u897f\u5728\u6211\u773c\u4e2d\u89c6\u4e3a\u5e7a\u86fe\u5b50\u3002\u4f60\u7528\u4efb\u610f\u7f16\u7801\u7684\u5b57\u7b26\u4e32\uff0c\u8f6c\u6210base64\uff0c\u7ee7\u800c\u4f20\u9012\uff0c\u5373\u53ef\u907f\u514d\u5e7a\u86fe\u5b50\u3002\u907f\u514d\u7f16\u7801\u8f6c\u6362\uff0c\u907f\u514d\u7f16\u7801\u4e0d\u8bc6\u522b\u3002\r\n\r\n\r\n ",
      "created_at": "2022-06-25T13:58:33Z",
      "updated_at": "2022-06-25T14:12:43Z"
    },
    {
      "author": "he852100",
      "author_association": "NONE",
      "body": "> > When it is saved as a PS1 file, it works properly It always uses iso-8859-1 no matter how you tweak it\r\n> \r\n> try: save ps1 file add BOM head,encoding any ps1 \u5185\u82e5\u542b\u6709\u4e2d\u65e5\u97e9\u7b49\u7f16\u7801\uff0c\u5fc5\u987b\u4fdd\u5b58\u6210bom\u5934\uff0c\u7f16\u7801\u4efb\u610f\u3002 \u5373bom+utf8\u53ef\u4ee5\uff0cbom+utf16le\u4e5f\u884c\u3002 bom\u5934\uff0cbom\u5934\uff0c\u6709\u5934\u65e0\u4e71\u7801\u3002\u8fd8\u652f\u6301\u4e2d\u6587\u53d8\u91cf\u540d\uff0c\u97e9\u6587\u53d8\u91cf\u540d\uff0c\u53c2\u6570\u540d\uff0c\u53c2\u6570\u503c\uff0c\u7b49\u3002\r\n> \r\n> \u6ce8\u610f\uff1a\u4f60\u7684\u4ee3\u7801\uff0c\u53ea\u8981\u52a0\u4e0abom\u5934\u4fdd\u5b58\u3002\u5728powershell 5.1\uff0cpowershell 7.3 preview\u4e2d\u8fd0\u884c\u6beb\u65e0\u95ee\u9898\uff0c\u5df2\u7ecf\u6d4b\u8bd5\u3002\r\n> \r\n> \\u00e6\\u00aa\\u0094\\u00e6\\u00a1\\u0088\\u00e5\\u0090\\u008d\\u00e7 ----\u8fd9\u4e9b\u4e1c\u897f\u5728\u6211\u773c\u4e2d\u89c6\u4e3a\u5e7a\u86fe\u5b50\u3002\u4f60\u7528\u4efb\u610f\u7f16\u7801\u7684\u5b57\u7b26\u4e32\uff0c\u8f6c\u6210base64\uff0c\u7ee7\u800c\u4f20\u9012\uff0c\u5373\u53ef\u907f\u514d\u5e7a\u86fe\u5b50\u3002\u907f\u514d\u7f16\u7801\u8f6c\u6362\uff0c\u907f\u514d\u7f16\u7801\u4e0d\u8bc6\u522b\u3002\r\n\r\n\u6c42\u6c42\u4f60\uff0c\u4e0d\u4f1a\uff0c\u4e0d\u61c2\u4e0d\u8981\u4e71\u8bf4\u3002",
      "created_at": "2022-06-25T17:32:41Z",
      "updated_at": "2022-06-25T17:32:41Z"
    },
    {
      "author": "kasini3000",
      "author_association": "NONE",
      "body": "Could not reproduce the problem . Fake issue, just change the machine\r\n\r\nwarn:\r\nThis guy always provides, can't reproduce the problem.\r\nThis person does not respect the person answering the question.\r\nFor a long time, the person does not respond to the question follow-up. Don't close the issue either.\r\n\r\nsee:   #16983 ",
      "created_at": "2022-06-25T18:56:51Z",
      "updated_at": "2022-06-25T19:09:23Z"
    },
    {
      "author": "he852100",
      "author_association": "NONE",
      "body": "Omg, he wants to sell me software!  \r\nHis answer is off topic and makes no sense",
      "created_at": "2022-06-25T19:52:52Z",
      "updated_at": "2022-06-25T19:52:52Z"
    },
    {
      "author": "he852100",
      "author_association": "NONE",
      "body": "![image](https://user-images.githubusercontent.com/26913892/175788942-a8874351-5814-4870-895c-eb0e9f0bed10.png)\r\n@kasini3000 \u8fd8\u9700\u8981\u770b\u4ec0\u4e48\u7248\u672c\u6211\u5e2e\u4f60\u6d4b\u8bd5\u54c8\u3002",
      "created_at": "2022-06-25T20:03:50Z",
      "updated_at": "2022-06-25T20:03:50Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "When running on Linux I get your expectations (when running your code).\r\n\r\n![image](https://user-images.githubusercontent.com/8462645/175799111-c8956290-3f29-4d50-967b-f511fd7ff24e.png)\r\n\r\nI notice you are running on Windows whereas I am running on Linux. So this is mostly some problems dealing with the different environments. Looking at your code I see a few things that could be the problem.\r\n\r\n### Splitting your String with -split [System.Environment]::NewLine\r\n\r\nTechnically Windows newlines are both the carriage return and newline `\\r\\n` but in your example you've input a string using a here string. In PowerShell (both WinPS and PowerShell) this results in it being just a newline\r\n\r\n![image](https://user-images.githubusercontent.com/8462645/175799505-c397c3fa-90b7-4dfa-9a7c-a6901664ca0a.png)\r\n\r\nThis means `-split [System.Environment]::NewLine` won't work as you expect on Windows because the output will contain the full text rather than an array of each line\r\n\r\n![image](https://user-images.githubusercontent.com/8462645/175799559-a3d207c6-f738-41a0-bb8e-f833226687a1.png)\r\n\r\nIf you compare that on a non-Windows host where `[System.Environment]::NewLine` is just the `\\n` we see the value is safely split into each line\r\n\r\n![image](https://user-images.githubusercontent.com/8462645/175799600-8ad6254b-28da-43e1-9261-c9ae550e5482.png)\r\n\r\nWhy this is important is explained in the final point.\r\n\r\n### The `\\u2019` example doesn't work with your encoding scheme\r\n\r\nThis goes into my original point where you are treating unicode codepoints as raw bytes that are UTF-8 encoded. This is not what you should be doing with raw unicode codepoints. We can notice this being a problem with the `\\u2019` example in the last example. The `\\u2019` is meant to represent [U+2019](https://www.fileformat.info/info/unicode/char/2019/index.htm) which is a smart right quote `\u2019`. The 2019 is the raw unicode codepoint and you can easily get this value by just casting the hex value to a `[char]` like so\r\n\r\n![image](https://user-images.githubusercontent.com/8462645/175799674-977a342f-2c4f-44c6-98ca-1c9f83542401.png)\r\n\r\nThis goes against your previous encoding scheme where the source text has encoded raw bytes as a `\\uxxxx` format. The code you currently have will convert `2019` to `0x2019` and try to encode that to a byte which fails because it is too large. Even if you had the code to try and convert to the `[byte[]]@(0x20, 0x19)` and then try and decode that using UTF-8 you will get 2 characters; [U+0020 Space](https://www.fileformat.info/info/unicode/char/0020/index.htm) and [U+0019 End of Medium](https://www.fileformat.info/info/unicode/char/0019/index.htm). If you control the code that is generating your text you really need to fix it up so it encodes your characters correctly. For example if you want the first line to be `profile.header.profile=\u6a94\u6848\u540d\u7a31` the escaped string should be\r\n\r\n```\r\nprofile.header.profile=\\u6a94\\u6848\\u540d\\u7a31\r\n```\r\n\r\nEach of the characters you have are represented by their Unicode codepoint values, rather than trying to smuggle in the UTF-8 byte representation. The code then simply becomes\r\n\r\n```powershell\r\n# This is whatever you want to unescape\r\n$content = 'profile.header.profile=\\u6a94\\u6848\\u540d\\u7a31'\r\n\r\n$content -replace '\\\\u([0-9a-f]{4})', {\r\n    [char][int]\"0x$($_.Groups[1])\"\r\n}\r\n```\r\n\r\nIgnoring that fact, the presence of this line causes the regex replace to fail because it's unable to cast the entry `\\u2019`\r\n\r\n> Cannot convert argument \"item\", with value: \"0x2019\", for \"Add\" to type \"System.Byte\": \"Cannot convert value \"0x2019\" to type \"System.Byte\". Error: \"Value was either too large or too small for an unsigned byte.\r\n\r\nThis brings me to my final point\r\n\r\n### A failure on the regex replacement has a fallback\r\n\r\nThe function has a fallback if `[Regex]::Replace` fails by calling `[Regex]::Unescape($inputString)`. Because on Windows you are processing the entire content rather than per line it's always going to fail because it's trying to process `\\u2019`. This means the entire content will be unescaped rather than the line entry.\r\n\r\nLet's see the behaviour of\r\n\r\n```powershell\r\n[Regex]::Unescape(\"profile.header.profile=\\u00e6\\u00aa\\u0094\\u00e6\\u00a1\\u0088\\u00e5\\u0090\\u008d\\u00e7\\u00a8\\u00b1\")\r\n```\r\n\r\nOn both Linux this becomes `profile.header.profile=\u00e6\u00aa\u00e6\u00a1\u00e5\u00e7\u00a8\u00b1` (what you are getting) due to Regex unescaping the raw unicode codepoints as actual unicode codepoints rather than UTF-8 bytes being smuggled into the codepoints. This is directly related to my 2nd point where your input string isn't really done properly.\r\n\r\n### Summary\r\n\r\nAll in all you should fix up whatever is generating this text to properly encode the Unicode characters rather than have it encode it as Unicode codepoints that represent the UTF-8 bytes of the character. For example:\r\n\r\n```powershell\r\n# The string should be this\r\n'profile.header.profile=\\u6a94\\u6848\\u540d\\u7a31'\r\n\r\n# But not this\r\n'profile.header.profile=\\u00e6\\u00aa\\u0094\\u00e6\\u00a1\\u0088\\u00e5\\u0090\\u008d\\u00e7\\u00a8\\u00b1'\r\n```\r\n\r\nIf you cannot change this then you need to fix up the `-spit [System.Environment]::NewLine` to properly split by newlines on Windows. A very nice way to split by newline and not care whether it's `\\r\\n` or `\\n` you can do `-split \"\\r?\\n\"`, so\r\n\r\n```powershell\r\nfunction UnescapeNonIsoChar($inputString) {\r\n    Try {\r\n        [regex]::replace($inputString, '(?:\\\\u[0-9a-f]{4})+', { \r\n            param($m) \r\n            $utf8Bytes = (-split ($m.Value -replace '\\\\u([0-9a-f]{4})', '0x$1 ')).ForEach([byte])\r\n            [text.encoding]::UTF8.GetString($utf8Bytes)\r\n            \r\n        })\r\n    } Catch {\r\n        [regex]::Unescape($inputString)\r\n    }\r\n}\r\n\r\n@'\r\nprofile.header.profile=\\u00e6\\u00aa\\u0094\\u00e6\\u00a1\\u0088\\u00e5\\u0090\\u008d\\u00e7\\u00a8\\u00b1\r\nprofile.header.customer=\\u00e5\\u00ae\\u00a2\\u00e6\\u0088\\u00b6\\u00e5\\u0090\\u008d\\u00e7\\u00a8\\u00b1\r\nprofile.header.account=\\u00e5\\u00b8\\u00b3\\u00e8\\u0099\\u009f/\\u00e6\\u00a2\\u009d\\u00e4\\u00bb\\u00b6\\u00e4\\u00bb\\u00a3\\u00e7\\u00a2\\u00bc\r\nprofile.header.description=\\u00e6\\u008f\\u008f\\u00e8\\u00bf\\u00b0\r\nlayout.msg.updatePrimaryUsersLayout=Kindly save it as a New Layout as Primary user\\u2019s layout cannot be updated.\r\n'@ -split \"\\r?\\n\" | ForEach-Object { UnescapeNonIsoChar -inputString $_ }\r\n```\r\n\r\nI still want to stress you should fix up whatever is generating the strings to generate them properly rather than using this hack but the `-split \"\\r?\\n\"` is a workaround to ensure you process this line by line and any lines that cause a failure in the replacement code won't affect each other.",
      "created_at": "2022-06-26T05:41:15Z",
      "updated_at": "2022-06-26T05:41:15Z"
    },
    {
      "author": "he852100",
      "author_association": "NONE",
      "body": "> I still want to stress you should fix up whatever is generating the strings to generate them properly rather than using this hack but the -split \"\\r?\\n\" is a workaround to ensure you process this line by line and any lines that cause a failure in the replacement code won't affect each other.   \r\n\r\n\r\nI'm feeding back bugs. Please note that it is a utf8 encoded character, not Unicode (utf16)\r\n\r\nhttps://www.youtube.com/watch?v=hNNeldPcTfs\r\n\r\nI don't need to replace methods, it's something they need to fix\r\n\r\n<blockquote><img src=\"https://i.ytimg.com/vi/hNNeldPcTfs/maxresdefault.jpg\" width=\"48\" align=\"right\"><div><img src=\"https://www.youtube.com/s/desktop/f9ccd8c6/img/favicon_144x144.png\" height=\"14\"> YouTube</div><div><strong><a href=\"https://www.youtube.com/watch?v=hNNeldPcTfs\">1</a></strong></div></blockquote>",
      "created_at": "2022-06-26T06:10:00Z",
      "updated_at": "2022-06-26T06:14:26Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": ">  Please note that it is a utf8 encoded character\r\n\r\nI'm sorry but this is just incorrect, text has no explicit encoding until you make it bytes. In this case the `\\uxxxx` represents the Unicode codepoint. This is not UTF-8, UTF-16-, UTF-32, or some other Unicode encoding scheme but where the character fits on the unicode character table. For example the character `\u6a94` https://www.compart.com/en/unicode/U+6A94 is denoted by the Unicode codepoint `U+6A94` and when escaped in a string becomes `\\u6a94`. Notice how the codepoint `U+xxxx` directly corresponds to the `\\uxxxx` value. We can see that yes when represented as UTF-8 the bytes are `0xE6, 0xAA, 0x94` but that does not mean the `\\u` escape sequence for that character is `\\u00e6\\u00aa\\u0094`, it is truly `\\u6a94`. You can even see that by using builtin methods with .NET to escape that\r\n\r\n![image](https://user-images.githubusercontent.com/8462645/175802080-df48559c-3506-43b8-a9d7-1589692692e5.png)\r\n\r\nYou've even done this correctly with your last line\r\n\r\n```\r\nlayout.msg.updatePrimaryUsersLayout=Kindly save it as a New Layout as Primary user\\u2019s layout cannot be updated.\r\n```\r\n\r\nThis contains the `\\u2019` entry which related to https://www.fileformat.info/info/unicode/char/2019/index.htm. If going by your logic where `\\u` should be the UTF-8 bytes then why is it not `\\u00e2\\u0080\\u0099`? If `\\uxxxx` is meant to represent bytes why does it have 4 characters after the `u`, a byte is limited to a max of 255 (`0xFF`) so anything beyond `\\u00ff` can never be represented by just a byte.\r\n\r\nIf you want to continue using the incorrect interpretation that `\\uxxxx` is a way to interpret the UTF-8 encoded form of the codepoint then you need to fix up the `-split` logic so that a failure in 1 line doesn't affect the others. Put simply your code is mixing 2 different ways of doing things and your attempts at working around an error is causing the failure. Nothing PowerShell needs to do here as it's working correctly. I've even given you code that will work on both platforms.\r\n\r\n<blockquote><img src=\"/en/unicode/images/icon/icon-compart.svg\" width=\"48\" align=\"right\"><div>https://www.compart.com/en/unicode/U+6A94</div><div><strong><a href=\"https://www.compart.com/en/unicode/U+6A94\">Unicode</a></strong></div><div>U+6A94 is the unicode hex value of the character CJK Unified Ideograph-6A94. Char U+6A94, Encodings, HTML Entitys:&#27284;,&#x6A94;, UTF-8 (hex), UTF-16 (hex), UTF-32 (hex)</div></blockquote>",
      "created_at": "2022-06-26T06:17:52Z",
      "updated_at": "2022-06-26T06:24:04Z"
    },
    {
      "author": "kasini3000",
      "author_association": "NONE",
      "body": ">\u6211\u5e2e\u4f60\u6d4b\u8bd5\r\n\r\nwhat ? you help me ?   \r\ni will gone and say \uff1a\u201cgoog bye\u201d\r\n\r\n----\r\n\r\nthis issue use new install vm test ,It's easy to spot and can't reproduce the problem.\r\nis support \uff0cnot bug\uff01\r\n\r\n----\r\n\r\nI see that your two issues are related to business. It looks like a Hong Kong banking institution.\r\n I don't recommend finding the ps community team for specific technical support. It is recommended to go to the forum to find FREE business technical support.\r\n\r\n----\r\n\r\nIn general, the ps community team does not provide support outside of powershell.\r\nFor Hong Kong business organizations, slqite libraries and scripts are provided. Is 15$ a lot?\r\n",
      "created_at": "2022-06-26T06:20:55Z",
      "updated_at": "2022-06-26T06:27:04Z"
    },
    {
      "author": "he852100",
      "author_association": "NONE",
      "body": "\r\n\r\n\r\n> If you want to continue using the incorrect interpretation that is a way to interpret the UTF-8 encoded form of the codepoint then you need to fix up the logic so that a failure in 1 line doesn't affect the others. Put simply your code is mixing 2 different ways of doing things and your attempts at working around an error is causing the failure. Nothing PowerShell needs to do here as it's working correctly. I've even given you code that will work on both platforms.`\\uxxxx``-split`\r\n\r\n![image](https://user-images.githubusercontent.com/26913892/175802531-d2ba8d5c-39aa-4ccb-8125-1f56ede937a2.png)\r\n\r\n\r\nIt was explained clearly in my first reply, actually this is just an example, this kind of thing happens quite often during transcoding\r\n\r\n\r\n",
      "created_at": "2022-06-26T06:44:41Z",
      "updated_at": "2022-06-26T06:44:41Z"
    },
    {
      "author": "he852100",
      "author_association": "NONE",
      "body": "> I'm sorry but this is just incorrect, text has no explicit encoding until you make it bytes. In this case the represents the Unicode codepoint. This is not UTF-8, UTF-16-, UTF-32, or some other Unicode encoding scheme but where the character fits on the unicode character table. For example the character https://www.compart.com/en/unicode/U+6A94 is denoted by the Unicode codepoint and when escaped in a string becomes . Notice how the codepoint directly corresponds to the value. We can see that yes when represented as UTF-8 the bytes are but that does not mean the escape sequence for that character is , it is truly . You can even see that by using builtin methods with .NET to escape that\\uxxxx\u6a94U+6A94\\u6a94U+xxxx\\uxxxx0xE6, 0xAA, 0x94\\u\\u00e6\\u00aa\\u0094\\u6a94\r\n\r\nIt can be any form: \r\n\r\n\\uxxxx,    \r\n0x0000,    \r\n0x00,     \r\n000000    \r\nor ababababab, it doesn't matter what form it is. \\uxxxx, 0x0000, 0x00 will eventually become continuous characters like '000000', just convert it into a byte array. Here it is utf8 encoding.\r\nYou can make a valid judgment here by decoding the entire string, instead of decoding a single unicode character using something like '[char]', in this example you fall into a trap, and you end up with a messy string\r\n\r\n**I noticed you wanted to tell me that [Regex]::Unescape() only supports unicode, thanks**\r\n@jborean93 \r\nThere seems to be some truth to what I said, and I was almost convinced.\r\nBut, has the problem gone away? No, there is no such problem when running ps1 files, also when you run in linux console everything works fine. You see no problem with the windows powershell console not interpreting the text correctly\r\n",
      "created_at": "2022-06-26T17:47:10Z",
      "updated_at": "2022-06-26T20:00:01Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "This is my last try, if you don't understand what is wrong after this you are on your own.\r\n\r\nYes it can be any form but mostly languages go for the `\\uxxxx` format where `xxxx` is the Unicode codepoint value. Using `\u6a94` as an example again we can find the Unicode information at https://www.compart.com/en/unicode/U+6A94. It has the following properties\r\n\r\n* The Unicode codepoint is `U+6a94`\r\n* The UTF-8 byte representation is `0xE6, 0xAA, 0x94`\r\n* The UTF-16-LE byte representation is `0x6A, 0x94`\r\n* The UTF-32-LE byte representation is `0x00, 0x00, 0x6A, 0x94`\r\n\r\nA few extra things I want to stress\r\n\r\n* Unicode != UTF-16-LE\r\n  * Microsoft products sometimes lumps them into the same thing but\r\n  * Unicode is the standard\r\n  * UTF-16 is an encoding scheme of how Unicode characters are encoded to bytes\r\n* The Unicode codepoint `U+6a94` is pretty much the UTF-16-le byte representation but that's just a coincidence\r\n  * Due to how UTF-16 was originally written, any Unicode characters in the `0x7FFF` range are encoded as their codepoint which is why they match\r\n  * You don't really need to know this fact, just that when I talk about `\\uxxxx` I am talking about the Unicode codepoint and not the UTF-16-LE byte representation\r\n\r\nWhat you are doing is you are taking the UTF-8 byte representation and trying to smuggle it in using escaped Unicode codepoint sequences so it becomes `\\u00e6\\u00aa\\u0094`. This is not strictly correct as this character when represented by the proper unicode codepoint is `\\u6a94` (because it's `U+6a94`, the code you have technically works because you are interpreting `\\uxxxx` as the UTF-8 bytes. Ignoring PowerShell and dotnet you can see that other language prove me correct in this statement, to display `\u6a94` I need to use `\\u6a94` and not `\\u00e6\\u00aa\\u0094`\r\n\r\n![image](https://user-images.githubusercontent.com/8462645/175833454-ce13526e-c998-4371-88e9-6485213bed32.png)\r\n\r\nOne thing I do need to mention, `U+6a94` is pretty much the equivalent of both of the UTF-16-LE bytes. This is just how UTF-16 works. Ignore that coincidence for now as UTF-16 was originally designed to map the Unicode codepoint values until they found out the space wasn't large enough. Just know that the value of the Unicode codepoint (what starts with `U+xxxx`) is what we are talking about.\r\n\r\nNotice that I am running in Python which is completely unrelated to PowerShell and their documentation mentioned the `\\uxxxx` https://docs.python.org/3/howto/unicode.html format\r\n\r\nPowerShell even has it's own standard by using the backtick u escape sequence and the value hex value of the Unicode codepoint (not necessarily the UTF-16-LE byte representation).\r\n\r\n```powershell\r\n`u{xxxx}`\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/8462645/175833561-e065451c-2b12-49c4-8126-e67507b02175.png)\r\n\r\nNotice how yet again only the Unicode codepoint `U+6a94` works in the scenario. Trying to use the UTF-8 bytes as the value for each codepoint results in that erroneous string you mentioned.\r\n\r\nHopefully this convinces you why I am saying doing `\\u00e6\\u00aa\\u0094` to represent the character `\u6a94` is incorrect. In saying that the code you've written does correctly escape the `\\uxxxx` codepoints as UTF-8 bytes as I you can see by just running it against your first line\r\n\r\n```powershell\r\nfunction UnescapeNonIsoChar($inputString) {\r\n    Try {\r\n        [regex]::replace($inputString, '(?:\\\\u[0-9a-f]{4})+', { \r\n            param($m) \r\n            $utf8Bytes = (-split ($m.Value -replace '\\\\u([0-9a-f]{4})', '0x$1 ')).ForEach([byte])\r\n            [text.encoding]::UTF8.GetString($utf8Bytes)\r\n            \r\n        })\r\n    } Catch {\r\n        [regex]::Unescape($inputString)\r\n    }\r\n}\r\n\r\nUnescapeNonIsoChar -inputString 'profile.header.profile=\\u00e6\\u00aa\\u0094\\u00e6\\u00a1\\u0088\\u00e5\\u0090\\u008d\\u00e7\\u00a8\\u00b1'\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/8462645/175833375-fc0e7c61-29f0-4999-83d9-b29368adbd35.png)\r\n\r\nNotice how this is the exact same code as what you have and the output is correct. This is even running on Windows to replicate the platform you are on.\r\n\r\nNotice what happens when you try and do the first and last line\r\n\r\n```powershell\r\nfunction UnescapeNonIsoChar($inputString) {\r\n    Try {\r\n        [regex]::replace($inputString, '(?:\\\\u[0-9a-f]{4})+', { \r\n            param($m) \r\n            $utf8Bytes = (-split ($m.Value -replace '\\\\u([0-9a-f]{4})', '0x$1 ')).ForEach([byte])\r\n            [text.encoding]::UTF8.GetString($utf8Bytes)\r\n            \r\n        })\r\n    } Catch {\r\n        [regex]::Unescape($inputString)\r\n    }\r\n}\r\n\r\nUnescapeNonIsoChar -inputString @'\r\nprofile.header.profile=\\u00e6\\u00aa\\u0094\\u00e6\\u00a1\\u0088\\u00e5\\u0090\\u008d\\u00e7\\u00a8\\u00b1\r\nlayout.msg.updatePrimaryUsersLayout=Kindly save it as a New Layout as Primary user\\u2019s layout cannot be updated.\r\n'@\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/8462645/175833855-95da6ff2-0fcc-4c0b-8351-557e40f3613f.png)\r\n\r\nThe text that worked before is now failing. This is because of the entry `\\u2019` in the last line causing the `[Regex]::Replace` call to fail and the input string falling back to `[Regex]::Unespace($inputString)` to be called. The reason why this is failing because `\\u2019` cannot be converted to a single byte\r\n\r\n![image](https://user-images.githubusercontent.com/8462645/175833933-7e8be393-6713-46c8-83d5-c63b0e66b54e.png)\r\n\r\nIn fact what `\\u2019` presents is the [Right Single Quotation Mark](https://www.compart.com/en/unicode/U+2019). Notice how this codepoint is `u+2019` and it matches the same value as `\\u2019` in the text. The presence of this value in the string causes the entire regex replacement to fail, moving it to the `[regex]::Unescape($inputString)` call in your catch block. This `Unespace` method is unescaping `\\uxxxx` as per the rules I've talked about above which is why you get the different strings.\r\n\r\nThis is critical to understand, a failure in the `[Regex]::Replace` method causes it to go through `[Regex]::Unescape` which is why you get the wrong output back. When you combine this with the fact that the `-split [System.Environment]::NewLine` isn't actually splitting your here string you can notice that the whole function is being called on the full string rather than line by line. The full string contains the `\\u2019` entry causing the failure with your logic which causes the `\\uxxxx` entries in the previous lines to be escaped by their Unicode codepoint value.\r\n\r\nTo prove that the split doesn't work look at the result of this\r\n\r\n```powershell\r\nFunction Test-PerLine {\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(ValueFromPipeline)]\r\n        [string]\r\n        $InputObject\r\n    )\r\n    \r\n    begin { $i = 0 }\r\n    process {\r\n        $i++\r\n        \"Line: $InputObject\"\r\n    }\r\n    end {\r\n        \"Lines processed; $i\"\r\n    }\r\n}\r\n\r\n@'\r\nline 1\r\nline 2\r\n'@ -split [System.Environment]::NewLine | Test-PerLine\r\n\r\n@'\r\nline 1\r\nline 2\r\n'@ -split \"\\r?\\n\" | Test-PerLine\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/8462645/175834145-3bf25ed1-3e27-48fc-aaf2-a93e526dd501.png)\r\n\r\nNotice how when `-split [System.Environment]::NewLine` was used the function was only called once (`Lines process: 1`) whereas when `-split \"\\r?\\n\"` was used it was passed in line by line. If you were to adjust your code so it did `-split \"\\r?\\n` you will notice it works\r\n\r\n```powershell\r\nfunction UnescapeNonIsoChar($inputString) {\r\n    Try {\r\n        [regex]::replace($inputString, '(?:\\\\u[0-9a-f]{4})+', { \r\n            param($m) \r\n            $utf8Bytes = (-split ($m.Value -replace '\\\\u([0-9a-f]{4})', '0x$1 ')).ForEach([byte])\r\n            [text.encoding]::UTF8.GetString($utf8Bytes)\r\n            \r\n        })\r\n    } Catch {\r\n        [regex]::Unescape($inputString)\r\n    }\r\n}\r\n\r\n@'\r\nprofile.header.profile=\\u00e6\\u00aa\\u0094\\u00e6\\u00a1\\u0088\\u00e5\\u0090\\u008d\\u00e7\\u00a8\\u00b1\r\nprofile.header.customer=\\u00e5\\u00ae\\u00a2\\u00e6\\u0088\\u00b6\\u00e5\\u0090\\u008d\\u00e7\\u00a8\\u00b1\r\nprofile.header.account=\\u00e5\\u00b8\\u00b3\\u00e8\\u0099\\u009f/\\u00e6\\u00a2\\u009d\\u00e4\\u00bb\\u00b6\\u00e4\\u00bb\\u00a3\\u00e7\\u00a2\\u00bc\r\nprofile.header.description=\\u00e6\\u008f\\u008f\\u00e8\\u00bf\\u00b0\r\nlayout.msg.updatePrimaryUsersLayout=Kindly save it as a New Layout as Primary user\\u2019s layout cannot be updated.\r\n'@ -split \"\\r?\\n\" |\r\n    ForEach-Object {\r\n        UnescapeNonIsoChar -inputString $_\r\n    }\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/8462645/175834254-403ecd0a-1462-469e-b33c-0ed7230c1c84.png)\r\n\r\nThe reason why goes into all my points above. Each line is now being processed one by one (`UnescapeNonIsoChar` is called per line rather than the whole thing). Each line is being converted using your regex replace logic of treating `\\uxxxx` as UTF-8 bytes. Even the last line where `\\u2019` is failing to be replaced with your logic is falling back to the `[Regex]::Unescape` which will convert `\\u2019` using the Unicode codepoint logic. This gives you exactly what you want. The only caveat will be if you have a line that contains both the logic where `\\uxxxx` is a UTF-8 byte representation and the Unicode codepoint. This is why I am recommending that you fix up whatever is generating the text to do it properly.\r\n\r\nIf you don't believe me after this I'm not sure what else I can do to convince you. PowerShell is acting sane here. There is no bug here as other languages treat `\\uxxxx` in the same manner as `[Regex]::Unescape` and what I am telling you. Good luck with your work.\n\n<blockquote><img src=\"/en/unicode/images/icon/icon-compart.svg\" width=\"48\" align=\"right\"><div>https://www.compart.com/en/unicode/U+6A94</div><div><strong><a href=\"https://www.compart.com/en/unicode/U+6A94\">Unicode</a></strong></div><div>U+6A94 is the unicode hex value of the character CJK Unified Ideograph-6A94. Char U+6A94, Encodings, HTML Entitys:&#27284;,&#x6A94;, UTF-8 (hex), UTF-16 (hex), UTF-32 (hex)</div></blockquote>\n<blockquote><img src=\"../_static/py.svg\" width=\"48\" align=\"right\"><div><strong><a href=\"https://docs.python.org/3/howto/unicode.html\">Unicode HOWTO \u2014 Python 3.10.5 documentation</a></strong></div></blockquote>",
      "created_at": "2022-06-26T21:25:53Z",
      "updated_at": "2022-06-26T21:25:55Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@jborean93 Thanks for your replies, I surely learnt something in this discussion \ud83d\udc4d ",
      "created_at": "2022-06-28T18:54:45Z",
      "updated_at": "2022-06-28T18:54:45Z"
    },
    {
      "author": "kasini3000",
      "author_association": "NONE",
      "body": "thanks @jborean93 ,\r\nbtw: my name is Usain2.Bolt, would you like to learn to gone faster with me?  ;)",
      "created_at": "2022-06-29T14:34:04Z",
      "updated_at": "2022-06-29T14:35:42Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This issue has been marked as answered and has not had any activity for **1 day**. It has been closed for housekeeping purposes.",
      "created_at": "2022-07-01T00:01:09Z",
      "updated_at": "2022-07-01T00:01:09Z"
    },
    {
      "author": "he852100",
      "author_association": "NONE",
      "body": "@jborean93 Thanks for your popular science,I don't want to know if it gives an error, what I want to express is that it outputs garbled characters\r\n\r\n@daxian-dbw \u6211\u8bf4\u4e71\u7801\u4e86\u4ed6\u7ed9\u6211\u89e3\u91ca\u4e00\u901a\u5982\u4f55\u7f16\u7801\u3002\u4e0d\u77e5\u9053\u7f16\u7801\u6211\u4f1a\u8fd9\u4e48\u5199\u4e48\u3002\u51fa\u9519\u4f1a\u5bfc\u81f4\u8f93\u51fa\u7f16\u7801\u6539\u53d8\uff08\u6211\u7684\u7406\u89e3\uff09\u3002\u4f46\u8fd0\u884cps1\u6ca1\u8fd9\u95ee\u9898\uff0c\r\n\u8bf4\u4e71\u7801\u4e86\uff0c\u6709\u4eba\u8fc7\u6765\u8ddf\u6211\u8bf4\u4f60\u6709\u4e00\u4e2a\u9519\u522b\u5b57\u3002\u4e0d\u8bf4\u662f\u5426\u56e0\u4e3a\u6709\u4e00\u4e2a\u9519\u522b\u5b57\u5bfc\u81f4\u5176\u4ed6\u6240\u6709\u6b63\u786e\u7684\u5b57\u7b26\u53d8\u6210\u9519\u522b\u5b57\u7684\u95ee\u9898",
      "created_at": "2022-07-01T05:44:34Z",
      "updated_at": "2022-07-01T06:14:20Z"
    }
  ],
  "created_at": "2022-06-25T01:10:16Z",
  "number": 17580,
  "state": "closed",
  "title": "text.encoding Invalid",
  "updated_at": "2022-07-01T06:14:20Z"
}