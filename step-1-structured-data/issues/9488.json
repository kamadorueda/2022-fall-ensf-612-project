{
  "_url": "https://github.com/PowerShell/PowerShell/issues/9488",
  "author": "vexx32",
  "body": "Attempting to load a module that requires p/invoke from a third-party native library fails to load the library from the same folder as the DLL doing the p/invoking.\r\n\r\nThis _used to work_ in PowerShell Core 6.1.0 but regressed between 6.2.0-preview1 and 6.2.0-preview2. It still works in Windows PowerShell.\r\n\r\nThe native library it's failing to locate is located in the same folder as the SkiaSharp.dll that is trying to locate it. See https://github.com/PowerShell/PowerShell/issues/8861#issuecomment-462362391 and that issue thread for why it was done in that fashion.\r\n\r\n# Steps to reproduce\r\n\r\n```powershell\r\nInstall-Module PSWordCloud\r\nNew-WordCloud\r\n```\r\n\r\n# Expected behavior\r\n\r\n```none\r\ncmdlet New-WordCloud at command pipeline position 1\r\nSupply values for the following parameters:\r\nInputObject:\r\n```\r\n\r\n# Actual behavior\r\n\r\n```none\r\nnew-wordcloud : The type initializer for 'PSWordCloud.WCUtils' threw an exception.\r\nAt line:1 char:1\r\n+ new-wordcloud\r\n+ ~~~~~~~~~~~~~\r\n+ CategoryInfo          : NotSpecified: (:) [], TypeInitializationException\r\n+ FullyQualifiedErrorId : System.TypeInitializationException\r\n```\r\n\r\nQuerying for the base exception with `$Error[0].Exception.GetBaseException() | Format-List * -F` yields the following:\r\n\r\n```\r\nMessage        : Unable to load DLL 'libSkiaSharp' or one of its dependencies: The specified module could not be\r\n                 found. (Exception from HRESULT: 0x8007007E)\r\nTypeName       :\r\nData           : {}\r\nInnerException :\r\nTargetSite     : IntPtr sk_fontmgr_ref_default()\r\nStackTrace     :    at SkiaSharp.SkiaApi.sk_fontmgr_ref_default()\r\n                    at SkiaSharp.SKFontManager.get_Default()\r\n                    at PSWordCloud.WCUtils..cctor()\r\nHelpLink       :\r\nSource         : SkiaSharp\r\nHResult        : -2146233052\r\n```\r\n\r\n# Environment data\r\n\r\n<!-- provide the output of $PSVersionTable -->\r\n\r\n```none\r\nName                           Value\r\n----                           -----\r\nPSVersion                      6.2.0\r\nPSEdition                      Core\r\nGitCommitId                    6.2.0\r\nOS                             Microsoft Windows 10.0.17763\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n\r\n_Note:_ The same was tested in a Mac environment (thanks @steviecoaster!) and also failed in the same way. I suspect it will be identical on Linux distros as well.\r\n\r\n/cc @SteveL-MSFT ",
  "closed_at": "2019-12-09T20:03:54Z",
  "comments": [
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@adityapatwardhan can you take a look at this?",
      "created_at": "2019-04-27T14:12:36Z",
      "updated_at": "2019-04-27T14:12:36Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "You could look used paths with `procmon`  utility and then try to fix with [HintPath ](https://medium.com/@tonerdo/referencing-a-net-dll-directly-using-the-net-core-toolchain-16f0af46a4dc)",
      "created_at": "2019-04-27T18:04:42Z",
      "updated_at": "2019-04-27T18:04:42Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I'll give that a look but given this isn't a library I'm loading directly (it's loaded by the main SkiaSharp.dll itself) I'm not that confident in that doing too much. The fact that there are four possible library files to load depending on platform also complicates things.\r\n\r\nBut regardless, this doesn't seem like an intentional change so the regression should probably be addressed. \r\n\r\n",
      "created_at": "2019-04-27T18:12:14Z",
      "updated_at": "2019-04-27T18:12:14Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "MSFT team works hard on vNext p/invokes in .Net Core 3.0 and perhaps they back-ported something to 2.1. I don't remember that we changed anything in PowerShell related dll loading.",
      "created_at": "2019-04-27T18:18:46Z",
      "updated_at": "2019-04-27T18:20:14Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "There was #8073 and several `Internal`-marked changes in 6.2.0-preview2. I have no idea what else may have changed during those. \ud83d\ude15 ",
      "created_at": "2019-04-27T18:32:31Z",
      "updated_at": "2022-09-12T17:35:03Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "The PR change is to load module dll from module folder first then from GAC. Your problem is that the module dll reference second dll and auto dll loading (it does Core not PowerShell ) doesn't found the dll. My suggestion is to explicitly add hintpath to the dll in project file.",
      "created_at": "2019-04-27T19:35:40Z",
      "updated_at": "2019-04-27T19:36:59Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@iSazonov I added some HintPath references to my csproj, but all I get is a warning when I `dotnet publish`. There is no change in behaviour of the module once loaded.\r\n\r\nFrom a bit of reading up on it, it looks like the HintPath is used to reference external assemblies that _aren't included_ in the project build itself. The SkiaSharp assemblies are included, so adding a HintPath for compile/build doesn't affect the Skia DLLs or the paths they look up at runtime. \r\n\r\nFor reference, this is my csproj:\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n\r\n  <PropertyGroup>\r\n    <TargetFramework>netstandard2.0</TargetFramework>\r\n  </PropertyGroup>\r\n\r\n  <ItemGroup>\r\n    <PackageReference Include=\"PowerShellStandard.Library\" Version=\"5.1.1\" PrivateAssets=\"All\" />\r\n    <PackageReference Include=\"SkiaSharp\" Version=\"1.68.0\" />\r\n    <PackageReference Include=\"SkiaSharp.NativeAssets.Linux\" Version=\"1.68.0\" />\r\n  </ItemGroup>\r\n\r\n</Project>\r\n```\r\n\r\nI added the following lines to no effect (other than a build/publish time warning that they can't be found, because, well, they don't exist until after the publish is completed anyway):\r\n\r\n```xml\r\n  <ItemGroup>\r\n    <Reference Include=\"libSkiaSharp\">\r\n        <HintPath>win-x86/libSkiaSharp.dll</HintPath>\r\n        <HintPath>win-x64/libSkiaSharp.dll</HintPath>\r\n        <HintPath>osx/libSkiaSharp.dylib</HintPath>\r\n        <HintPath>linux-x64/libSkiaSharp.dylib</HintPath>\r\n    </Reference>\r\n</ItemGroup>\r\n```\r\n\r\nFrom what I've read on HintPath, it doesn't seem to have any effect on what paths are searched when loading a DLL, or that DLL tries to load other DLLs for p/invoke purposes.",
      "created_at": "2019-04-27T23:46:33Z",
      "updated_at": "2019-04-27T23:52:28Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "_That_ HintPath is a compile-time thing only.",
      "created_at": "2019-04-28T03:57:54Z",
      "updated_at": "2019-04-28T03:57:54Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "The way you say that makes it sound like there's another I missed?",
      "created_at": "2019-04-28T04:38:25Z",
      "updated_at": "2019-04-28T04:38:25Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@vexx32 If you have simple repo code you could ask in CoreCLR repository.",
      "created_at": "2019-04-28T04:48:02Z",
      "updated_at": "2019-04-28T04:48:02Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I'm unsure if I can rule out a Powershell-specific change just yet. I might have to put a small test together for a console app and see how that goes.",
      "created_at": "2019-04-28T05:06:22Z",
      "updated_at": "2019-04-28T05:06:22Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Thanks to a tip from @Jaykul, I've managed to put together a stop-gap solution. Executing this from the PSM1 before importing the cmdlet and the main Skia DLL seems to resolve the issue.\r\n\r\n```powershell\r\nAdd-Type -TypeDefinition @\"\r\n    using System.Runtime.InteropServices;\r\n\r\n    public class DllLoadPath\r\n    {\r\n        [DllImport(\"kernel32\", CharSet=CharSet.Unicode)]\r\n        public static extern int SetDllDirectory(string NewDirectory);\r\n    }\r\n\"@\r\n\r\n# ...\r\n\r\n[DllLoadPath]::SetDllDirectory($NativeRuntimeFolder)\r\n```\r\n\r\nHowever, the fact that it _requires_ additional p/invoke to make this work is kind of ridiculous. I'm also very confused as to what changed and removed the loaded SkiaSharp.dll's own directory path from the standard search locations as documented [here](https://docs.microsoft.com/en-us/windows/desktop/Dlls/dynamic-link-library-search-order).",
      "created_at": "2019-04-28T06:25:00Z",
      "updated_at": "2019-04-28T06:25:00Z"
    },
    {
      "author": "adityapatwardhan",
      "author_association": "MEMBER",
      "body": "@vexx32 I was not able to reproduce the issue. Did I miss something in the repro? Maybe a specific version if PSWordCloud?\r\n\r\n```powershell\r\nPS> Install-Module PSWordCloud                                                               \r\nUntrusted repository\r\nYou are installing the modules from an untrusted repository. If you trust this repository, change its\r\nInstallationPolicy value by running the Set-PSRepository cmdlet. Are you sure you want to install the modules from\r\n'PSGallery'?\r\n[Y] Yes  [A] Yes to All  [N] No  [L] No to All  [S] Suspend  [?] Help (default is \"N\"): y\r\n\r\nPS> New-WordCloud                                                                            \r\ncmdlet New-WordCloud at command pipeline position 1\r\nSupply values for the following parameters:\r\nInputObject:\r\nPath:\r\n\r\nPS> $PSVersionTable                                                                          \r\nName                           Value\r\n----                           -----\r\nPSVersion                      6.2.0\r\nPSEdition                      Core\r\nGitCommitId                    6.2.0\r\nOS                             Microsoft Windows 10.0.18885\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```",
      "created_at": "2019-04-30T16:59:37Z",
      "updated_at": "2022-09-12T17:35:04Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Sorry, as mentioned I rectified it in 2.1.1.\r\n\r\nIf you install 2.1.0 specifically you'll see the failure, as it's lacking the above p/invoke workaround.",
      "created_at": "2019-04-30T17:17:12Z",
      "updated_at": "2019-04-30T18:00:10Z"
    },
    {
      "author": "adityapatwardhan",
      "author_association": "MEMBER",
      "body": "Ok, I can repro now. I will have a look.",
      "created_at": "2019-04-30T17:28:41Z",
      "updated_at": "2019-04-30T17:28:41Z"
    },
    {
      "author": "adityapatwardhan",
      "author_association": "MEMBER",
      "body": "@vexx32 It seems that we load all the file listed in `FileList` of the `psd1`. Do you need to have that? When I removed all the entries from `FileList` I cannot repro the issue any more.",
      "created_at": "2019-04-30T18:35:31Z",
      "updated_at": "2019-04-30T18:35:31Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Is that so? That's very strange. No, I don't particularly need that and probably will remove it anyway as I don't really want to have to constantly update it, but that has been there for a few versions. \r\n\r\nSeems weird that that would affect DLL loading all of a sudden, though.",
      "created_at": "2019-04-30T19:20:29Z",
      "updated_at": "2019-04-30T19:20:29Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": ">  It seems that we load all the file listed in FileList of the psd1.\r\n\r\nWe have an issue to support \"if\" in .psd1 files. So we could load platform specific dlls. ",
      "created_at": "2019-05-01T09:52:28Z",
      "updated_at": "2019-05-01T09:52:28Z"
    },
    {
      "author": "fMichaleczek",
      "author_association": "NONE",
      "body": "@iSazonov it's [#5541](https://github.com/PowerShell/PowerShell/issues/5541).  I will give you update soon.",
      "created_at": "2019-05-01T14:27:39Z",
      "updated_at": "2019-05-01T14:27:39Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "That is a possibility. What I'm wondering _now_ is if simply adding the path to the native libraries (all of them) in the FileList is sufficient here... I might not even need the p/invoke. I'll do some testing! \ud83d\ude0a \r\n\r\nEDIT: Nope, I'm not seeing that have any effect. :(",
      "created_at": "2019-05-01T14:31:55Z",
      "updated_at": "2022-09-12T17:35:04Z"
    },
    {
      "author": "adityapatwardhan",
      "author_association": "MEMBER",
      "body": "We call `Assembly.Load()` that only loads managed assemblies.\r\n\r\nWe made a [change](https://github.com/PowerShell/PowerShell/pull/8073) in 6.2.0-preview.2 where we started loading DLLs from module folder before looking up in the GAC. The side effect of that change is we also load DLLs in FileList. ",
      "created_at": "2019-05-01T17:01:10Z",
      "updated_at": "2019-05-01T17:07:41Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "That makes sense. Do we have a doc issue open for that? It seems like this sort of change that will be very hard to track down if someone runs into it and we haven't documented it. We should probably document that you don't want to put native assemblies in the filelist for that reason.\r\n\r\nAppreciate the help tracking it down! For now the P/invoke solution I mentioned gives me the most flexibility, but it might be sensible to add handling for such things in module loading. \r\n\r\nFor example, let's say in PrivateData we add an entry called RuntimeLibPaths, which is a hashtable where the keys match supported platform names / architectures, and the values are the path to the folder containing the native library. The appropriate folder(s) are added to the dll search paths on import by PowerShell internally rather than having to be added by the module itself on import.",
      "created_at": "2019-05-01T17:43:26Z",
      "updated_at": "2019-05-01T17:43:26Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": ">  Do we have a doc issue open for that?\r\n\r\nWe haven't.",
      "created_at": "2019-05-01T17:54:43Z",
      "updated_at": "2019-05-01T17:54:43Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@adityapatwardhan @SteveL-MSFT  thanks to @TylerLeonhardt (unintentionally) reminding me that this has to work on non-Windows things too if I want to be thorough... I need a more complete solution.\r\n\r\nThere currently does not appear to be any clear documentation on how native interop is supposed to be handled in .NET Core itself. All I can find is [this](https://docs.microsoft.com/en-us/dotnet/standard/native-interop/) page for .NET Framework in MS docs.\r\n\r\nIs it handled via Mono or something? If it's via Mono, looking at [this page](https://www.mono-project.com/docs/advanced/pinvoke/) there is actually a _bug in Mono_ on Mac OS that prevents the library load paths being properly respected...\r\n\r\nPowerShell... needs to handle this. I'm not sure there _is_ a way to handle this appropriately from all platforms from the module itself.",
      "created_at": "2019-05-08T04:20:10Z",
      "updated_at": "2019-05-08T04:21:34Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@vexx32 don't know the details, if you can produce a repro in C# that doesn't include PowerShell, I would suggest opening an issue in the CoreCLR repo",
      "created_at": "2019-05-08T20:54:01Z",
      "updated_at": "2019-05-08T20:54:01Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@steveL-msft that's the issue, I think. It seems to work fine elsewhere, with some caveats still. For example, loading the native lib works if it's in the same folder as the main SkiaSharp.dll, but for PS that doesn't work due to the change @adityapatwardhan mentions. That just multiplies the difficulty in the case of working with PowerShell and how it handles modules.\r\n\r\nIn most situations in working with such native libraries it can be abstracted away, because you can just package it for each supported platform anyway. We quite simply don't have that luxury for PS modules, unless I want to package and maintain three or more completely separate gallery modules, which is unfortunately really bad for discoverability and the end user experience.\r\n\r\nGiven that PS is a cross platform tool, we need some way to handle native libraries in modules, or we need some way to have the PackageManagement module recognise that there need to be separate libraries extracted on a per-platform basis from the nupkg.\r\n\r\nI'm open to alternate solutions, but it seems the deck here is pretty scarce. :confused:",
      "created_at": "2019-05-08T21:24:17Z",
      "updated_at": "2019-05-08T21:24:44Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@vexx32 I think you want something like this https://github.com/PowerShell/PowerShellGet/issues/273",
      "created_at": "2019-05-09T01:04:09Z",
      "updated_at": "2019-05-09T01:04:09Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "In CoreFX 3.0 we get some new APIs for pinoke native libraries. They are only at the beginning of the road, but they want to do something even better than Mono.",
      "created_at": "2019-05-09T19:19:33Z",
      "updated_at": "2019-05-09T19:19:33Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Currently my ~~solution~~workaround is looking like this:\r\n\r\n1. Native libraries for Mac and Linux are in the module root, as that seems to be the only place I can put them and have them reliably loaded at the moment.\r\n2. A `ScriptsToProcess` handles p/invoke on module import to add either the 32 or 64-bit version of the Windows native library, which must be stored in subfolders as the filenames are, unfortunately, identical.\r\n\r\nNot ideal, and as @TylerLeonhardt can attest from his stream today, this still doesn't work for some reason when running in Azure Functions at the moment.",
      "created_at": "2019-05-09T19:36:29Z",
      "updated_at": "2019-05-09T19:46:27Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "> @vexx32 don't know the details, if you can produce a repro in C# that doesn't include PowerShell, I would suggest opening an issue in the CoreCLR repo\r\n\r\n## Nope: In C# this isn't a problem\r\n\r\nIn C# you either:\r\n1. Develop an app, and release _separate installers_ per platform, and have only _one library search path_ to worry about.\r\n2. Develop a library, and release _NuGet packages_, and nuget gives you a path pattern telling you where to put your libraries, and then studio/msbuild takes care of everything for you.\r\n\r\n----\r\n\r\n> @vexx32 I think you want something like this [PowerShell/PowerShellGet#273](https://github.com/PowerShell/PowerShellGet/issues/273)\r\n\r\n## Nope: This isn't a cross-platform problem\r\n\r\nThat's why this bug was filed. Ever since PowerShell 6.2 @vexx32 can't even get a version that works in _just Windows_ because he can't figure out how to get **PowerShell** to use the right library search path.",
      "created_at": "2019-05-10T04:19:47Z",
      "updated_at": "2019-05-10T04:22:08Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "In Windows at least there's a p/invoke available that lets me mess around with it. That's a _workaround_ but really we need a better fix. \r\n\r\nOn Unix systems, however, there _is no such p/invoke_ available, from what I've been able to find, and for whatever reason PowerShell isn't querying the environment variables that normally indicate which paths to search when you try to DllImport from an assembly loaded by PS.\r\n\r\nSo on basically all platforms this is... extremely unfriendly to do anything with. \ud83d\ude05 \r\n\r\nAs it currently stands there appears to be no other option apart from including any and all Unix native assemblies directly in the module root folder (which limits the platforms you can support, as often there can be name collisions), and then being careful about which folder you add to the search paths on Windows with the p/invoke (if you care about supporting x86 Windows -- and @TylerLeonhardt tells me that Azure Functions runs on x86 for some strange reason, so that's a necessity if you want to work with those.)",
      "created_at": "2019-05-13T19:25:26Z",
      "updated_at": "2022-09-12T17:35:05Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "This is what I use in my psm1 file to pre-load the appropriate native binary for the platform. Note: I only targeted/tested this on Linux and Windows:\r\n```powershell\r\n# Module PSM1 File\r\n$binPath = Join-Path $PSScriptRoot bin $(if ($IsWindows) {\"Windows\"} else {\"Linux\"})\r\nAdd-Type -Path $binPath\\Acme.Api.dll\r\n```\r\nAnd this is the C# code that goes in Acme.Api.dll\r\n```csharp\r\n[Flags]\r\npublic enum DLOpenFlags\r\n{\r\n    RTLD_LAZY = 1,\r\n    RTLD_NOW = 2,\r\n    RTLD_LOCAL = 4,\r\n    RTLD_GLOBAL = 8,\r\n}\r\n\r\npublic static class LinuxNativeMethods\r\n{\r\n    [DllImport(\"libdl.so\", CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]\r\n    public static extern IntPtr dlopen(\r\n        string dlToOpen, \r\n        DLOpenFlags flags);\r\n}\r\n\r\npublic static class Win32NativeMethods\r\n{\r\n    [DllImport(\"kernel32.dll\", EntryPoint=\"LoadLibraryW\")]\r\n    public static extern IntPtr LoadLibrary(\r\n        [InAttribute, MarshalAs(UnmanagedType.LPWStr)] string dllToLoad);\r\n}\r\n\r\npublic static class FooNativeMethods\r\n{\r\n    // On Linux/macOS the shared lib must be named Foo.so and not libFoo.so\r\n    public const string LibName = \"Foo\";\r\n\r\n    static FooNativeMethods()\r\n    {\r\n        string assemblyDir = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);\r\n\r\n        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows)) \r\n        {\r\n            string nativeDllPath = Path.Combine(assemblyDir, \"Windows\", $\"{LibName}.dll\");\r\n            LibHandle = Win32NativeMethods.LoadLibrary(nativeDllPath);\r\n        }\r\n        else\r\n        {\r\n            string nativeSOPath = Path.Combine(assemblyDir, \"Linux\", $\"{LibName}.so\");\r\n            LibHandle = LinuxNativeMethods.dlopen(nativeSOPath, DLOpenFlags.RTLD_LAZY);\r\n        }\r\n    }\r\n  \r\n    public static IntPtr LibHandle { get; private set; }\r\n\r\n    [DllImport(LibName, CallingConvention = CallingConvention.Cdecl)]\r\n    public static extern int getLastError(\r\n        StringBuilder buffer,\r\n        ref int bufferLength);\r\n    \r\n    ...\r\n}\r\n```",
      "created_at": "2019-05-14T03:16:54Z",
      "updated_at": "2019-05-18T19:04:43Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@vexx32 You could open consulting issue in CoreCLR repo. I guess they have that to say.",
      "created_at": "2019-05-14T03:39:21Z",
      "updated_at": "2019-05-14T03:39:21Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@rkeithhill this only works for .NET binaries. I need to load a .NET binary that itself needs to use P/invoke to load a native assembly. That is where it fails and falls apart completely. I have no control over this library, it is a third party library (SkiaSharp, in this instance). I am unable to load this library in my binary module as it needs to be loaded at the same time as code is loaded from my module, as my module is dependent on types only present and functional with SkiaSharp loaded.\r\n\r\n@isazonov as has been covered a couple times in this issue now, this *isn't an issue in .net Core* because you can simply generate separate packages per platform for most applications.\r\n\r\nPowerShell doesn't have any possible way to do this, and it incidentally *removes* some standard paths from the library search paths, making it literally impossible to work with native assemblies in some contexts, and very fragile and particular in the ones that do happen to work.",
      "created_at": "2019-05-14T04:36:15Z",
      "updated_at": "2019-05-14T04:39:05Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "@vexx32 \r\n> I need to load a .NET binary that itself needs to use P/invoke to load a native assembly. That is where in fails and falls apart completely.\r\n\r\nUh, that is **exactly** what this code does. Been using it successfully on 6.2 on both Windows and Linux for a while now.",
      "created_at": "2019-05-14T04:38:34Z",
      "updated_at": "2019-05-14T04:38:34Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Amended, sorry, I wasn't clear. I can't do this in my own binary, the types need to be present as my own module is being loaded; I can't have it import during the command instantiation.... And I shouldn't have to.\r\n\r\nPowerShell shouldnt be *less functional* than .net core when it comes to loading binaries.\r\n\r\nThat said, I'll see if I can adapt some things and improve my workarounds. Appreciate the examples!\r\n\r\nBut really... I don't see why I should have to go to such lengths to work around this. It should just work, and until PowerShell gets involved... It does.",
      "created_at": "2019-05-14T04:42:13Z",
      "updated_at": "2019-05-14T04:42:23Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "Agreed on the hoops being a pain.  Was just trying to show how the native lib loading can be done via p/invoke on Windows and Linux.  :-)",
      "created_at": "2019-05-14T04:45:21Z",
      "updated_at": "2019-05-14T04:47:08Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@vexx32 I see splitting in the discussion. Could you clarify that is a problem - you have a module with native libraries and you need load right library with dependences on specific platform?",
      "created_at": "2019-05-14T05:33:15Z",
      "updated_at": "2019-05-14T05:33:15Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Sort of. This is the layout I have that currently works, but is messy as all heck. Anything I can't define a path for via p/invoke must be in the module root (which runs into name collision problems on some platforms).\r\n\r\n```\r\nPSWordCloud/\r\n|- PSWordCloudCmdlet.dll\r\n|- SkiaSharp.dll\r\n|- libSkiaSharp.so\r\n|- libSkiaSharp.dylib\r\n|- win-x86/\r\n  |- libSkiaSharp.dll\r\n|- win-x64/\r\n  |- libSkiaSharp.dll\r\n```\r\n\r\n**SkiaSharp.dll** is .NET, and is a referenced assembly for my main cmdlet dll. The four **libSkiaSharp** files are native per-platform DLLs. I don't control the code in SkiaSharp.dll, so I can't force that DLL to update the paths before it p/invokes.\r\n\r\nSo... I have a module with a .NET dependency. This dependency depends on a native library that it is loading with DllImport; the exact file is different per platform/architecture (but several of the files have name collisions, so that restricts the platforms I can actually support).\r\n\r\nUsing @rkeithhill's code, I think I can possibly move the Linux native library to a subfolder as well. Not sure about MacOS, there's probably something similar-ish, but I have yet to find any documentation on methods for that.\r\n\r\n_Ideally_, ALL of these files should be at worst in a subfolder out of the way, something like `/PSWordCloud/runtime/<platform>/` -- unfortunately, due to how PowerShell has changed the path loading specifications from the standard settings, only files in the root folder of the module can be loaded via DllImport. Other locations may work, but (at least on Mac/Linux) _all_ of the environment variables on those platforms that are supposed to define native runtime load paths are **completely** ignored by PowerShell.\r\n\r\nI believe `$env:Path` still works (though it shouldn't be using that on Unix platforms, and I haven't tested that since the 6.2 release, so that might be broken as well), but frankly I don't think it's a good idea at all to add a ton of paths to that variable, it makes for a really terrible user experience if the user needs to use that environment variable at all. You load a module, and suddenly your path variable has extra unexpected data that probably shouldn't be there, but _has_ to be there for things to work correctly.\r\n\r\nI think this should be a non-issue; PowerShell should have a more robust method of handling native library load paths if it's going to be overriding .NET Core's predefined methods. I would suggest having some way to specify a native library load path in the module manifest or something along those lines, some way to define where it should be looking per platform when something needs to p/invoke some native code.",
      "created_at": "2019-05-14T12:52:19Z",
      "updated_at": "2019-05-14T12:54:17Z"
    },
    {
      "author": "fMichaleczek",
      "author_association": "NONE",
      "body": "I have the same issue and @vexx32's report contains all elements in the chain.\r\nI'm agree PowerShell should have a more **robust** method of handling native library.\r\n",
      "created_at": "2019-05-14T13:42:24Z",
      "updated_at": "2019-05-14T13:42:24Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": ">  I don't think it's a good idea at all to add a ton of paths to that variable\r\n\r\nAgreed and likewise, I'm not keen on using `SetDllDirectory` because that is also (pwsh) process wide.  The module manifest could be updated to allow module authors to provide a list of native dlls per os-arch combo and then pwsh would pre-load those native dlls before it pre-loaded any assemblies.  That said, **if** someone is going to use your assembly from another language, the assembly really should pre-load its own native dlls.  The user of the assembly shouldn't have to do that IMO.\r\n\r\n@vexx32 I \"think\" `dlopen` works on macOS as well.",
      "created_at": "2019-05-14T14:43:18Z",
      "updated_at": "2019-05-14T14:46:47Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I'll give it a go when I can (mac VMs are a bit... weird heh) but from memory, Mac doesn't use `.so` files so I'd definitely have to give it a try -- most of the native libs I see references to on Macs seem to be `.dylib`.\r\n\r\nThe assembly does its own preloading here (at least, I'm pretty sure it does...), I just have to special-case everything because the assembly doesn't know where to look with how PS handles paths. :/",
      "created_at": "2019-05-14T15:01:19Z",
      "updated_at": "2019-05-14T15:01:19Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "I think macOS uses `.dylib` so you'd need to compile that assembly three times with different macros defined e.g.:\r\n```\r\npublic static class FooNativeMethods\r\n{\r\n    // This unfortunately requires that you compile this assembly twice - once with WIN32 defined and again with\r\n    // it not defined.\r\n#if WIN32        \r\n    public const string LibName = \"Foo\";\r\n#elif MACOS\r\n    public const string LibName = \"libFoo.dylib\";\r\n#else\r\n    public const string LibName = \"libFoo.so\";\r\n#endif      \r\n```\r\nI really wish I didn't have to recompile this for each platform because this is netstandard2 assembly.  But AFAICT the lib name value provided to the `DllImport` attribute has to be a compile time constant.  :-(  ",
      "created_at": "2019-05-14T16:16:35Z",
      "updated_at": "2019-05-14T16:17:06Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Yeah. Since this is a PowerShell module, what I'd actually end up doing is a dynamic on-import compilation with `Add-Type -TypeDefinition $srcString` with a platform check and then point it at the correct directory.  You can use `ScriptsToProcess` in a module manifest for this, thankfully.\r\n\r\nAlso, is `libdl.so` a valid and usable library to do this with on MacOS?\r\n\r\nBut yep, we need a better solution. \ud83d\ude04 ",
      "created_at": "2019-05-14T16:21:32Z",
      "updated_at": "2022-09-12T17:35:06Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@vexx32 Did you look Mono MapDll? The feature allows automatic mapping to appropriate native library based on conditions (arch, platform and etc.). I'd expect that it is that you need. Perhaps SkiaSharp.dll should be recompiled but it can be configured in external config file. Something similar will be implemented in Core.",
      "created_at": "2019-05-15T05:07:42Z",
      "updated_at": "2019-05-15T05:07:42Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "If I recall correctly, .NET Core doesn't use Mono when running on Windows, so it again would only be a partial solution. \r\n\r\nI appreciate very much all the options being offered here, and I will thoroughly examine what my current options are -- but at the end of the day, PowerShell needs to have something in place for cross-platform modules to use for this purpose going forward. \ud83d\ude42 ",
      "created_at": "2019-05-15T12:53:27Z",
      "updated_at": "2022-09-12T17:35:07Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> If I recall correctly, .NET Core doesn't use Mono when running on Windows, so it again would only be a partial solution.\r\n\r\nI say about new features. See \r\nDllmap design document https://github.com/dotnet/coreclr/blob/c3e1bd5ccc482c9a7670762676bda95ebd34707d/Documentation/design-docs/dllmap.md\r\nand previous version of the document\r\nhttps://github.com/dotnet/coreclr/blob/6a48f05c77e80b604d71a9b84cc6b014306e849e/Documentation/design-docs/dllmap.md#\r\n\r\nUpdate: `CurrentContextualReflectionContext` \r\nhttps://github.com/dotnet/designs/blob/master/accepted/runtime-binding.md#rollforward",
      "created_at": "2019-05-15T13:19:03Z",
      "updated_at": "2019-05-25T16:07:53Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "@rkeithhill \r\n\r\n> I really wish I didn't have to recompile this for each platform because this is netstandard2 assembly. But AFAICT the lib name value provided to the DllImport attribute has to be a compile time constant. :-(\r\n\r\nFWIW you can omit the extension for `DllImport`.  We do that for PSES's non-Windows [native dependency](https://github.com/SeeminglyScience/UnixConsoleEcho/blob/11a8886efdaf140514ab495266be87ed0f41312c/src/UnixConsoleEcho/InputEcho.cs#L44-L48). Doesn't help if the base names aren't the same though.\r\n\r\nYou can also probably skip the compiler directives for the `LoadLibrary`/`dlopen` calls by storing them in separate interface implementations.  As long as the method isn't JIT'd it shouldn't throw at runtime.",
      "created_at": "2019-05-15T14:29:44Z",
      "updated_at": "2019-05-15T14:29:44Z"
    },
    {
      "author": "adityapatwardhan",
      "author_association": "MEMBER",
      "body": "I found a possible solution for this problem. I would have to try it out though. I am currently busy working on some releases, so most likely will get to this early next week. I will update this issue with my findings.\r\n\r\nhttps://docs.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext.loadunmanageddll?view=netcore-2.2#System_Runtime_Loader_AssemblyLoadContext_LoadUnmanagedDll_System_String_",
      "created_at": "2019-05-15T15:28:34Z",
      "updated_at": "2019-05-15T15:28:34Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "@adityapatwardhan That looks like a cross-platform wrapper around LoadLibrary/dlopen.  Nice find!",
      "created_at": "2019-05-15T16:03:15Z",
      "updated_at": "2019-05-15T16:03:15Z"
    },
    {
      "author": "fMichaleczek",
      "author_association": "NONE",
      "body": "@adityapatwardhan I found this issue around LoadUnmanagedDll . Maybe irrevelant to our case. \r\n\r\n> We should consider adding a callback that allow folks to supply custom resolution policy for unmanaged libraries. We have intended to do that with AssemblyLoadContext.LoadUnmanagedDll. At the end, it only addressed a small fraction of them problem because of it does not work for default load context. When we have introduced AssemblyLoadContext.LoadUnmanagedDll originally, we allowed overriding the default load context as well but then removed this capability and did not think through the impact on all scenarios.\r\n\r\nSource : [LoadUnmanagedDllFromPath / LoadUnmanagedDll is not working on linux if .so file is present in any other path other than application output directory](https://github.com/dotnet/coreclr/issues/12707)\r\n",
      "created_at": "2019-05-15T16:27:44Z",
      "updated_at": "2019-05-15T16:27:44Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I think my link above on NativeLibrary APIs gives us cross-platform solution (after moving to .Net Core 3.0).",
      "created_at": "2019-05-16T05:12:30Z",
      "updated_at": "2019-05-16T05:12:30Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "CurrentContextualReflectionContext https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/AssemblyLoadContext.ContextualReflection.md\r\n\r\nIt is for plug-in models. This could resolves the issue, #6724, #6426, and some other.\r\n/cc @daxian-dbw ",
      "created_at": "2019-05-25T16:16:50Z",
      "updated_at": "2019-05-25T16:17:49Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "@adityapatwardhan any update since last month? We want to publish the right doc guidance on this",
      "created_at": "2019-06-26T20:42:51Z",
      "updated_at": "2019-06-26T20:42:51Z"
    },
    {
      "author": "adityapatwardhan",
      "author_association": "MEMBER",
      "body": "Have not been able to focus on this, am currently busy with other high priority items. I will update by sometime next week.",
      "created_at": "2019-06-26T20:52:02Z",
      "updated_at": "2019-06-26T20:52:02Z"
    },
    {
      "author": "TylerLeonhardt",
      "author_association": "MEMBER",
      "body": "@adamdriscoll might be able to give some advice since he probably had to do some creative stuff in UniversalDashboard and AvaloniaUI +PowerShell.",
      "created_at": "2019-06-27T00:27:22Z",
      "updated_at": "2019-06-27T00:27:22Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "FWIW the code I presented [above](https://github.com/PowerShell/PowerShell/issues/9488#issuecomment-492063136) is what we use for an internal module that uses a native lib.  It runs without issues on Windows and Linux.   Haven't tested it on macOS but other than tweaks to the `dlopen` pinvoke and changing the name of the shared lib on mac, it should work.  This is on .NET Core 2.2. ",
      "created_at": "2019-06-27T00:58:57Z",
      "updated_at": "2019-06-27T01:00:33Z"
    },
    {
      "author": "adamdriscoll",
      "author_association": "CONTRIBUTOR",
      "body": "UD is doing pretty much the same thing as @rkeithhill's solution. This works on MacOSX as well as Linux and Windows. https://github.com/ironmansoftware/universal-dashboard/blob/master/src/UniversalDashboard/Server/CustomAssemblyLoadContext.cs\r\n\r\nThe issue is that there could be many more variations of the folder paths to load the various binaries so it's a bit of a kluge. If a new binary type is output based on a new dependency, a new folder may pop up and UD won't load the assembly. \r\n\r\n@rkeithhill are you merging all the Windows\\Linux binaries into a single folder? (EDIT: Actually, I get it. You have a wrapper DLL assembly that just loads the target native assembly. Do you do this for all your native assemblies?)\r\n\r\nUD just keeps the publish runtime folder the same as when it was produced with dotnet publish and then the referenced class tries to load all the native binaries based on the correct platform\\architecture. \r\n\r\nIt works but I wish PS could just look at a runtime folder and load the correct binaries. Seems like dotnet must be doing that when it starts up so maybe there is some code to nab there. ",
      "created_at": "2019-06-27T01:07:12Z",
      "updated_at": "2019-06-27T01:09:02Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "I change where I look for native assemblies based on the result `RuntimeInformation.IsOSPlatform(OSPlatform.Windows)`.  If that returns true, I load from the `Windows` folder of the dir the C# assembly is located in.  Otherwise, I load from the `Linux` folder. \r\n\r\n> Do you do this for all your native assemblies?)\r\n\r\nYes but we've only got the one and it doesn't depend on anything else other than system libs (msvcrt, etc).",
      "created_at": "2019-06-27T01:18:46Z",
      "updated_at": "2019-06-27T01:18:53Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Can we have some standard file structure (maybe based on runtime names)? This would allow us to enhance the native dll resolver.",
      "created_at": "2019-06-27T05:45:29Z",
      "updated_at": "2019-06-27T05:45:29Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "> UD just keeps the publish runtime folder the same as when it was produced with dotnet publish and then the referenced class tries to load all the native binaries based on the correct platform\\architecture.\r\n\r\nSo if I'm understanding correctly, you're avoiding using PowerShell to load the native binaries by just having .NET load them under the hood when you load a managed binary that depends on the RID-specific native binaries? \r\n\r\n> It works but I wish PS could just look at a runtime folder and load the correct binaries. Seems like dotnet must be doing that when it starts up so maybe there is some code to nab there.\r\n\r\nYeah, I suspect there's some RID awareness happening within the .NET runtime itself. I've been trying to avoid us having to go down that path, but it sounds like we may need to at some point. ",
      "created_at": "2019-06-28T21:48:28Z",
      "updated_at": "2019-06-28T21:48:28Z"
    },
    {
      "author": "adamdriscoll",
      "author_association": "CONTRIBUTOR",
      "body": "@joeyaiello \r\n\r\n> So if I'm understanding correctly, you're avoiding using PowerShell to load the native binaries by just having .NET load them under the hood when you load a managed binary that depends on the RID-specific native binaries?\r\n\r\nYeah, exactly. UD just loads everything for the target RID. So it's not really smart about what the actual dependencies are. Not sure if there is a good way to even detect that.",
      "created_at": "2019-06-28T21:54:34Z",
      "updated_at": "2019-06-28T21:54:34Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@vexx32 I installed PSWordCloud. Is the folder structure general? If so we can make our resolver more smart. In the case I want to ask you - could you please prepare new Pester test(s) based on simplified PSWordCloud (it is enough for us to get something simple from the native libraries like \"Hello World\")? We would merge that as pending and it will open the way to work on our resolver. Thanks!",
      "created_at": "2019-06-29T05:35:55Z",
      "updated_at": "2019-06-29T05:35:55Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Currently the folder structure of PSWordCloud is not general, no. That can be changed, of course.\r\n\r\nYeah, I can absolutely put together a simple test bed for that. Pester is a bit tricky to do, just based on the nature of the output I suppose, but I _think_ when it fails it produces an exception you can catch, though that exception is thrown from the type initializer if I recall correctly.\r\n\r\nWould it be appropriate to have the test itself pull  the Skia DLLs via dotnet, or would it be better to package them in the repo? I guess if we pull them each time it's not so big a deal if it's flagged as a feature test once it's no longer pending? :thinking: ",
      "created_at": "2019-06-29T12:40:59Z",
      "updated_at": "2019-06-29T12:40:59Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "If you could implement a test nodule with indirect dependence with Skia dlls it would be nice. And yes we could install Skia from nuget. Although the test would be more reliable if we directly put the dlls with the test module in ~our test module folder~ an assert folder.\r\nIt seems Nuget best practice is to put native dlls in RID named folders. Yes?",
      "created_at": "2019-06-29T17:27:35Z",
      "updated_at": "2019-06-29T18:10:57Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Yep, I can do that! I'll have a look at it tommorow. :blush: ",
      "created_at": "2019-06-29T17:34:08Z",
      "updated_at": "2019-06-29T17:34:08Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I updated my comment - please put the test module in an test assert folder.",
      "created_at": "2019-06-29T18:11:41Z",
      "updated_at": "2019-06-29T18:11:41Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@rjmholt I made some attempts to use the code you provided to make it work for PSWordCloud, but it's still not working at all. The load operation completes successfully, but loading the managed SkiaSharp.dll after the unmanaged library still fails to make use of the loaded DLL on Unix platforms. It does manage to work for Windows, though, somehow.\r\n\r\nSee my WIP branch here https://github.com/vexx32/PSWordCloud/tree/FixPInvokes -- run `build.ps1` to build the module and put all the files in the right places. It'll import the module for you, too. Calling `New-WordCloud` after running the build works on Windows, but fails completely on Mac OS.\r\n\r\n@SeeminglyScience you see anything I did wrong there? :/\r\n\r\n<blockquote><img src=\"https://avatars2.githubusercontent.com/u/32407840?s=400&v=4\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicon.ico\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/vexx32/PSWordCloud\">vexx32/PSWordCloud</a></strong></div><div>Create pretty word clouds with PowerShell! Contribute to vexx32/PSWordCloud development by creating an account on GitHub.</div></blockquote>",
      "created_at": "2019-11-11T00:30:43Z",
      "updated_at": "2019-11-11T00:30:54Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@SteveL-MSFT what's the plan for handling native libs at present? \ud83d\ude15 ",
      "created_at": "2019-11-11T00:37:10Z",
      "updated_at": "2022-09-12T17:35:08Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": ":tada:This issue was addressed in #11032, which has now been successfully released as `v7.0.0-rc.1`.:tada:\n\nHandy links:\n* [Release Notes](https://github.com/PowerShell/PowerShell/releases/tag/v7.0.0-rc.1)\n",
      "created_at": "2019-12-16T21:37:42Z",
      "updated_at": "2019-12-16T21:37:42Z"
    }
  ],
  "created_at": "2019-04-27T12:37:13Z",
  "labels": [
    "Issue-Question",
    "Resolution-Fixed"
  ],
  "number": 9488,
  "state": "closed",
  "title": "Loading Native Libraries is broken",
  "updated_at": "2022-09-12T17:35:08Z"
}