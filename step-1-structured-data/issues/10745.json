{
  "_url": "https://github.com/PowerShell/PowerShell/issues/10745",
  "author": "iSazonov",
  "body": "<!-- Anything that looks like this is a comment and can't be seen after the Pull Request is created. -->\r\n\r\n# PR Summary\r\n\r\n- Save environment variables at startup\r\n- Restore these saved environment variables for child process is UseNewEnvironment parameter is used in Start-Process cmdlet\r\n\r\nFormally it is a breaking change in grey area.\r\n\r\nI hope we do not load any additional dlls with the change at startup and slowdown the startup scenario will be minimal.\r\n\r\n## PR Context\r\n\r\nFix #4671\r\nFix #3545\r\n\r\n## PR Checklist\r\n\r\n- [x] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [x] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [ ] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` or `[ WIP ]` to the beginning of the title (the `WIP` bot will keep its status check at `Pending` while the prefix is present) and remove the prefix when the PR is ready.\r\n- **[Breaking changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)**\r\n    - [ ] None\r\n    - **OR**\r\n    - [ ] [Experimental feature(s) needed](https://github.com/MicrosoftDocs/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/About/about_Experimental_Features.md)\r\n        - [ ] Experimental feature name(s): <!-- Experimental feature name(s) here -->\r\n- **User-facing changes**\r\n    - [ ] Not Applicable\r\n    - **OR**\r\n    - [x] [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n- **Testing - New and feature**\r\n    - [ ] N/A or can only be tested interactively\r\n    - **OR**\r\n    - [x] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n- **Tooling**\r\n    - [ ] I have considered the user experience from a tooling perspective and don't believe tooling will be impacted.\r\n    - **OR**\r\n    - [ ] I have considered the user experience from a tooling perspective and enumerated concerns in the summary. This may include:\r\n        - Impact on [PowerShell Editor Services](https://github.com/PowerShell/PowerShellEditorServices) which is used in the [PowerShell extension](https://github.com/PowerShell/vscode-powershell) for VSCode (which runs in a different PS Host).\r\n        - Impact on Completions (both in the console and in editors) - one of PowerShell's most powerful features.\r\n        - Impact on [PSScriptAnalyzer](https://github.com/PowerShell/PSScriptAnalyzer) (which provides linting & formatting in the editor extensions).\r\n        - Impact on [EditorSyntax](https://github.com/PowerShell/EditorSyntax) (which provides syntax highlighting with in VSCode, GitHub, and many other editors).\r\n",
  "closed_at": "2019-10-18T11:39:45Z",
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "/cc @SteveL-MSFT for PowerShell Committee review.",
      "created_at": "2019-10-11T19:51:21Z",
      "updated_at": "2019-10-11T19:51:21Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "Will talk about this with @PowerShell/powershell-committee today, but I think this is a worthwhile change given it's what's the norm across Unix systems. New processes should be expected to set environment state they don't want to be handed by parent processes. \r\n\r\nWould love to understand how this works on Windows today, though, as it was my expectation that things already worked this way:\r\n\r\n```powershell\r\nPowerShell 6.2.1\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\n\r\nhttps://aka.ms/pscore6-docs\r\nType 'help' to get help.\r\n\r\nLoading personal and system profiles took 883ms.\r\nC:\\Users\\jaiello> $env:foo = \"bar\"\r\nC:\\Users\\jaiello> powershell\r\nWindows PowerShell\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\nTry the new cross-platform PowerShell https://aka.ms/pscore6\r\n\r\nPS C:\\Users\\jaiello> $env:foo\r\nbar\r\n```\r\n\r\nThis also is true when I use `Start-Process powershell` and get a new terminal. ",
      "created_at": "2019-10-16T22:00:32Z",
      "updated_at": "2019-10-16T22:00:32Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "I misunderstood the original intent of this PR, apologies (reading too fast).\r\n\r\n@PowerShell/powershell-committee discussion on this was interesting.\r\n\r\nFirst, it looks like `Start-Process -UseNewEnvironment` on Windows gives the equivalent of a fresh login (i.e. Machine and User variables as they're stored in the registry). \r\n\r\nAdditionally, this caching behavior can be somewhat non-deterministic when I'm executed from multiple shells. For instance, I could:\r\n\r\n1. start my login shell as Bash\r\n1. modify my environment\r\n1. start pwsh\r\n1. modify my environment\r\n1. start pwsh\r\n1. modify my environment\r\n1. `Start-Process -UseNewEnvironment pwsh`\r\n\r\nI'm now getting the modified state post-step 4 instead of the original login shell environment post-step 1 (as I'd expect to get on Windows today). \r\n\r\nTherefore, we think the behavior that folks would expect from this is to get the login shell behavior with `-UseNewEnvironment`. On Linux, this would match @rjmholt 's behavior for `pwsh -l` where we use `sh -l` on Linux and `zsh -l` on macOS each in conjunction with `-c export` to retrieve explicitly and only the exported environment variables from the login shell invocation. \r\n\r\nIf you disagree, can you help us understand a scenario where you'd actually want the exact environment state from two shells up your stack? ",
      "created_at": "2019-10-16T22:53:20Z",
      "updated_at": "2019-10-16T22:53:20Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@joeyaiello:\r\n\r\nThe determinism I was going for was:\r\n\r\n* For the child process about to be created, provide the same environment that the current process saw _when it started_.\r\n\r\n* In other words: Ignore all _in-session_ modifications made by the current process.\r\n\r\nThat is indeed not the same as \"provide the same environment a new shell process would see if created directly\", not via another shell instance, but, _pragmatically  speaking_:\r\n\r\n* It may be _good enough_ (you don't typically _nest_ shells, and the need to ignore _in-session_ changes strikes me as the typical use case)\r\n\r\n* It is easy to implement consistently, in a platform-neutral manner (and easy to explain and document).\r\n\r\n----\r\n\r\nAs for \"provide the same environment a new shell process would see if created directly\" functionality:\r\n\r\nIf it can be done, consistently across all platforms, I agree that it is the better choice.\r\n\r\n* Windows (where the feature is [currently half broken](https://github.com/PowerShell/PowerShell/issues/4671#issue-252911712), also in Windows PowerShell):\r\n \r\n  * @geelaw mentions in https://github.com/PowerShell/PowerShell/issues/3545#issuecomment-398105462 that the [`CreateEnvironmentBlock`](https://docs.microsoft.com/en-us/windows/win32/api/userenv/nf-userenv-createenvironmentblock) WinAPI function may be the right solution, but it also states:\r\n  > User-specific environment variables such as `%USERPROFILE%` are set only when the user's profile is loaded. To load a user's profile, call the `LoadUserProfile` function.\r\n\r\n  * @SteveL-MSFT just posted a thought at https://github.com/PowerShell/PowerShell/issues/4671#issuecomment-543346250:\r\n\r\n> on Windows, the current code clears the env block, then fills it from the system profile (hence username is system) and then the user profile overwriting any that exist in the system. Hence Path is incomplete. It seems the fix here is to merge Path (append user PATH to end of machine PATH). USERNAME should be special cased to the user. \r\n\r\n* Unix-like platforms:\r\n\r\n  * macOS: A login-shell like environment seems appropriate - but the CLI's `-l` workaround (launching via a hidden `sh` instance) is not really an option here; not sure how to get the right environment directly.\r\n\r\n  * Linux: ? (No personal knowledge - no need for a _login_ shell) \r\n\r\n",
      "created_at": "2019-10-17T20:38:53Z",
      "updated_at": "2019-10-17T20:50:30Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "P.S.: Forgot to mention that `cmd.exe`'s `start /I` feature - which is presumably what `Start-Process -UseNewEnvironment` was inspired by - indeed uses the use-the-shell's-own-startup-environment approach, as originally suggested:\r\n\r\n```powershell\r\n# Opens a new cmd.exe window that DOES see $env:FOO,\r\n# because it was present in the startup environment in the intermediate cmd.exe instance,\r\n# but not $env:FOO2\r\n$env:FOO='bar'; cmd /c \"set FOO2=no & start /I cmd /k echo %FOO%-%FOO2%\"\r\n```\r\n\r\n",
      "created_at": "2019-10-17T20:55:36Z",
      "updated_at": "2019-10-17T20:55:36Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Replaced by #10830",
      "created_at": "2019-10-18T11:39:45Z",
      "updated_at": "2019-10-18T11:39:45Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thinking about this some more:\r\n\r\n* **Unix** platforms have _no_ native programmatic mechanism that I know of for \"give me a pristine but functional environment\":\r\n\r\n  * Utility `env` with `-i` _radically clears_ the environment, which makes for a non-functional environment that `bash` itself happens to compensate for by having _hard-coded defaults_.\r\n\r\n  * Someone who truly needs to start with a pristine environment can use `env -i` on Unix and manually reconstruct the essential system variables, if really needed - and using `env -i`  is also an option _from PowerShell_.\r\n\r\n  * I'm not sure anyone would miss that ability on Windows, since it has never been there.\r\n\r\n* On **Windows**, the original feature _similar_ to \"give me a pristine but functional environment\" was actually \"give me a copy of _this process'_ original environment, without any _in-session_ changes\" in the form of `cmd.exe`'s `start /I`\r\n\r\n  * Windows PowerShell _tried to_ implement \"give me a pristine but functional environment\", but failed to do so (it is what #10830 now tries to fix).\r\n\r\n---\r\n\r\nIn short: There's no _existing_ PowerShell functionality that we're really beholden to, on either platform.\r\n\r\nBased on the pragmatic arguments made above:\r\n\r\n* \"give me a copy of _this process'_ original environment, before _in-session_ changes\" is _typically_ the same as the pristine-environment feature.\r\n\r\n* the former is easy to explain, easy to document, easy to implement across platforms\r\n\r\nmy vote is therefore to implement the \"give me a copy of _this process'_ original environment, without any _in-session_ changes\"  - unless someone knows how to - robustly, in a conceptually clean manner - implement the pristine-environment feature on macOS and Linux.\r\n\r\nI think that is preferable to having the pristine-environment feature, but _on Windows only_.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2019-10-19T17:10:11Z",
      "updated_at": "2019-10-19T17:10:11Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 Thanks for great comment!\r\n\r\nAs for Unix-s my current thought is to use Robert's workaround for login shell. ",
      "created_at": "2019-10-19T17:35:37Z",
      "updated_at": "2019-10-19T19:29:50Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov:\r\n\r\nA _login_ shell is only appropriate for macOS, not Linux.\r\n\r\nIn case you're thinking of the `/bin/sh -c 'exec pwsh ...`  workaround (please clarify):\r\n\r\nThat will (a) require you to start with a cleared environment, as with `env -i`, which (b) will _not_ give you a functional environment, even with `-l`:\r\n\r\n```sh\r\n$ env -i /bin/sh -l -c printenv\r\nPATH=/usr/local/bin:/usr/bin:/bin:...\r\nSHLVL=1\r\n_=/usr/bin/printenv\r\n```\r\n\r\nAs you can see, vital environment variables such as `USER`, `SHELL`, `LANG`, ... are missing.",
      "created_at": "2019-10-19T18:40:40Z",
      "updated_at": "2019-10-19T18:40:40Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> As you can see, vital environment variables such as USER, SHELL, LANG, ... are missing.\r\n\r\nWhere do these variables come from?",
      "created_at": "2019-10-19T18:59:39Z",
      "updated_at": "2019-10-19T18:59:39Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "It all relates to the unspoken premise of the \"give me a pristine but functional environment\" feature: A pristine environment _obtained how_?\r\n\r\nIn terms of _effect_, you'd want the same kind of environment you get:\r\n\r\n* on Windows: when you open a new shell window via the Start Menu or the `Run` dialog, for instance.\r\n\r\n* on Unix: when you use the default terminal program to open a new shell window.\r\n\r\nMy point is that we - certainly I - _don't know how to do that programmatically_ or even whether it's feasible on all Unix platforms (and at this point I'm also not convinced that the Windows-only #10830 is fully functional).\r\n\r\nSo, instead of going down that rabbit hole, we could implement the \"give me a copy of this process' original environment, without any in-session changes\" approach, document it, and be done.\r\n\r\nI suspect no one will complain, because:\r\n\r\n* it's the only _functioning_ approach currently available on Windows, via `cmd.exe`'s  `start /I`\r\n\r\n* neither feature currently exists on Unix (only the clear-all feature does, which continues to be available via `env -i`)\r\n\r\n* in the _typical_ use case it will be the same as \"give me a pristine but functional environment\" ",
      "created_at": "2019-10-19T19:20:19Z",
      "updated_at": "2019-10-19T19:20:19Z"
    }
  ],
  "created_at": "2019-10-09T14:08:16Z",
  "number": 10745,
  "state": "closed",
  "title": "UseNewEnvironment restores environment variables for child process",
  "updated_at": "2020-03-04T23:54:19Z"
}