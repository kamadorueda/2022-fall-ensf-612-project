{
  "_url": "https://github.com/PowerShell/PowerShell/issues/11598",
  "author": "mklement0",
  "body": "---\r\n_Update, based on the discussion below:_\r\n\r\nWhat it comes down to is the following _inconsistency_: \r\n\r\n* In `<expression> <redirection>` the redirection has _no effect_ on the expression (except if the success output stream is suppressed); e.g.:\r\n`$result = [int[]] (1, 2) 2>$null; $result.GetType().Name` yields `Int32[]`)  \r\n\r\n* whereas enclosing the same expression _in parentheses_ applies _pipeline logic_ and therefore _enumeration_ of the expression result (and subsequent collection in a regular PS array); e.g.:\r\n` ([int[]] (1, 2) 2>$null).GetType().Name` yields `Object[]`\r\n\r\nGive how exotic this scenario is, no resolution of this inconsistency is planned.\r\n\r\n---\r\n\r\nThis is an edge case, given that applying a redirection such as `*>&1` to a pure _expression_ (one not containing embedded _commands_) is is conceptually pointless, given that it is only ever stream `1` output that is produced.\r\n\r\nStill, the fact that adding such a redirection makes empty-collection expressions turn into `[System.Management.Automation.Internal.AutomationNull]::Value` is puzzling.\r\n\r\n# Steps to reproduce\r\n\r\n```powershell\r\n# OK: an empty array is not the same as $null\r\n$null -eq (@()) | Should -BeFalse\r\n\r\n# !! Unexpectedly fails; the *>&1 redirection makes the expression return $null.\r\n# !! Using specific streams in the redirection - e.g., 3>&1 - fails too.\r\n$null -eq (@() *>&1) | Should -BeFalse\r\n```\r\n\r\n# Expected behavior\r\n\r\nBoth tests should succeed.\r\n\r\n# Actual behavior\r\n\r\nThe 2nd test fails, because the RHS unexpectedly becomes `$null`\r\n\r\n```none\r\nExpected $false, but got $true.\r\n```\r\n\r\nThe behavior is related to the combination of the redirection with  `(...)`, which is a syntactic requirement here, however.\r\n\r\n`$foo = @() *>&1`  works fine, for instance - the `*>&1` has no effect.\r\nBy contrast, `$foo = (@() *>&1)` exhibits the problem (but removing the redirection doesn't).\r\n\r\n# Environment data\r\n\r\n\r\n```none\r\nPowerShell Core 7.0.0-rc.1\r\n```\r\n",
  "closed_at": "2020-01-18T16:22:32Z",
  "comments": [
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "It's the same if you do  \r\n\r\n@() | out-default \r\n\r\n\r\n> `$foo = @() *>&1` works fine, for instance - the `*>&1` has no effect.\r\n\r\nYes it does. \r\n```\r\n>$foo.GetType() \r\nInvalidOperation: You cannot call a method on a null-valued expression.\r\n```\r\nc.f.\r\n\r\n```\r\n>$foo = @()    \r\n>$foo.GetType()     \r\nIsPublic IsSerial Name                                     BaseType\r\n-------- -------- ----                                     --------\r\nTrue     True     Object[]                                 System.Array\r\n```\r\n\r\nWhat you're saying is \"send all members of the empty array to the default output.\" There are no members so the result is null. ",
      "created_at": "2020-01-16T16:19:32Z",
      "updated_at": "2020-01-16T16:19:32Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "`Out-Default` only comes into play if the output is _not_ captured - it is unrelated to this issue.\r\n\r\n> Yes it does.\r\n\r\nIt doesn't for me, neither in WinPS nor in PS Core, and it is the behavior that I expect:\r\n\r\n```\r\nPS> $foo = @() *>&1; $foo.GetType().Name\r\nObject[]\r\n```\r\n\r\nThat is, the `*>&1` should be a no-op and indeed is in this case.\r\nNo enumeration takes place nor should it.\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-01-16T16:46:58Z",
      "updated_at": "2020-01-16T16:46:58Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "I copied what you _Just_ did \r\n```\r\n#509 >$test1 = @() *>&1\r\n#510 >$test1.GetType()\r\n\r\nIsPublic IsSerial Name                                     BaseType                                                                                                                          \r\n-------- -------- ----                                     --------                                                                                                                          \r\nTrue     True     Object[]                                 System.Array                                                                                                                      \r\n```\r\nNot the result I got before ... what ? ... different machine ... then I copied what you _first_ gave\r\n```\r\n#511 >$test2 = (@() *>&1)\r\n#512 >$test2.GetType()\r\nYou cannot call a method on a null-valued expression.\r\n```\r\n\r\nThen the penny dropped; in this:  \r\n`>$test1 =   @()    *>&1  `\r\nthe redirection is processed after the assignment - you'd expect  *>&1  to be processed last. Wrapping it in brackets caused it to be processed first. \r\n\r\nWhat I meant about out-default was empty sent through anything is null. \r\n```\r\n#513 >$test3 = (@() | out-default)\r\n#514 >$test3.GetType()\r\nYou cannot call a method on a null-valued expression.\r\n```\r\nMaybe this is better. \r\n```\r\n#515 >$test4 = (@() | Write-Output)\r\n#516 >$test4.GetType()\r\nYou cannot call a method on a null-valued expression.\r\n```\r\nor \r\n\r\n```\r\n#517 >$test3 = (@() | % {$_} )\r\n#518 >$test3.GetType()\r\nYou cannot call a method on a null-valued expression.\r\n```\r\nThese don't need the () because the pipeline is evaluated before the assignment. \r\n\r\n",
      "created_at": "2020-01-16T19:48:59Z",
      "updated_at": "2020-01-16T19:48:59Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> Then the penny dropped; in this:\r\n> `>$test1 = @() *>&1 `\r\n> the redirection is processed after the assignment - you'd expect *>&1 to be processed last. Wrapping it in brackets caused it to be processed first.\r\n\r\nYou'd think based on the results, but non-pipeline statements can't be redirected (language rule).\r\n\r\n```powershell\r\n{ $a = @() *>&1 }.Ast.EndBlock.Statements[0].Right\r\n# Expression Redirections Extent   Parent\r\n# ---------- ------------ ------   ------\r\n# @()        {*>&1}       @() *>&1 $a = @() *>&1\r\n```\r\n\r\nUnless the compiler has some special logic to capture only *part* of it's child expression, that's not what's happening here.",
      "created_at": "2020-01-16T20:14:32Z",
      "updated_at": "2020-01-16T21:32:17Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @SeeminglyScience.\r\n\r\nThat redirections are processed first actually makes sense, otherwise you wouldn't be able to write statements such as `$out = ls / nosuch 2>&1` and have the merged streams captured in `$out`.\r\n\r\n@jhoneill:\r\n\r\n>  then I copied what you first gave\r\n\r\nThe initial post states that `(...)` is somehow involved and contrasts that with the parentheses-free `$foo = @() *>&1`, which preserves the empty array as expected; you previously claimed that the latter also turns to `$null`, which we now agree is not true.\r\n\r\n> empty sent through anything is null.\r\n\r\nIf you assign an _expression_ to a variable, no enumeration is performed. An empty array stays an empty array.\r\n\r\nThe question is whether something like `*>&1` should change that.\r\n\r\nIndeed,  `>` - if wrapped in `(...)` - seems to apply  pipeline enumeration semantics:\r\n\r\n```powershell\r\n# No (): no enumeration\r\nPS> ( $foo = [int[]] (1, 2) *>&1 ).GetType().Name\r\nInt32\r\n\r\n# With (): enumeration, and collection in [object[]] array:\r\nPS> ( $foo = ([int[]] (1, 2) *>&1) ).GetType().Name\r\nObject[]\r\n```\r\n\r\nWhatever behavior you favor (I see no reason for the enumeration), it is clear that we have an inconsistency on our hands.\r\n\r\n\r\n\r\n",
      "created_at": "2020-01-16T20:28:16Z",
      "updated_at": "2020-01-16T20:28:16Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> The initial post states that `(...)` is somehow involved and contrasts that with the parentheses-free `$foo = @() *>&1`, which preserves the empty array as expected; you previously claimed that the latter also turns to `$null`, which we now agree is not true.\r\n\r\nMy missreading - I missed that you'd contracted the title at the end. \r\nThe title should be \"using () causes a change in the order of evaluation\"  :-) \r\n\r\nSomething like this \r\n`>$x = & {@(1) *>&1}`\r\nshows the array gets enumerated not passed through by *>&1  \r\nWithout the () assignment happens first.  Nothing complicated or surprising about either of those. \r\n\r\n\r\n@SeeminglyScience \r\n> You'd think, but non-pipeline statements can't be redirected (language rule).\r\n\r\nBut assignment expressions function as pipeline statement \r\n```\r\n#542 >$a = 42 > delete.me\r\n#543 >cat delete.me      \r\n42\r\n```\r\nWhat's weird is there the value of assignment appears in that redirection but not in `$a = 42 *>&1 `  I've always understood that > was actually doing `| out-file` underneath and that would need everything before the > to be wrapped in ()   *>&1 is doing something different\r\n\r\n\r\n",
      "created_at": "2020-01-16T21:52:43Z",
      "updated_at": "2020-01-16T21:53:28Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> @SeeminglyScience\r\n> \r\n> > You'd think, but non-pipeline statements can't be redirected (language rule).\r\n> \r\n> But assignment expressions function as pipeline statement\r\n\r\nAssignments can't be expressions, they're just statements.  Everything to the right of the <kbd>=</kbd> is then assigned to the variable.\r\n\r\n> ```\r\n> #542 >$a = 42 > delete.me\r\n> #543 >cat delete.me      \r\n> 42\r\n> ```\r\n\r\nYeah, just like `42 > delete.me` would do by itself.  And `$a` is null, because the output was redirected to the file, so there was nothing to assign.\r\n\r\nIf it was redirecting the *assignment* the file would be null and the variable would be populated.\r\n\r\n> \r\n> What's weird is there the value of assignment appears in that redirection but not in `$a = 42 *>&1 ` I've always understood that > was actually doing `| out-file` underneath and that would need everything before the > to be wrapped in () *>&1 is doing something different\r\n\r\nIt's not really that cut and dry, there's more that goes into it than just translating to a command call.  That said, `$a = 42 | Out-File delete.me` acts the same.",
      "created_at": "2020-01-16T22:04:11Z",
      "updated_at": "2020-01-16T22:04:11Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> Something like this\r\n>$x = & {@(1) *>&1}\r\nshows the array gets enumerated \r\n\r\n`& { ... }` _always_  acts this way (it enumerates), whether a redirection is involved or not:\r\n`(& { [int[]] (1,2) }).GetType().Name` -> `Object[]`.\r\n\r\n---\r\n\r\nI've updated the issue title to mention the parentheses.",
      "created_at": "2020-01-16T22:16:18Z",
      "updated_at": "2020-01-16T22:18:53Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> Without the () assignment happens first.\r\n\r\nIt's implied by @SeeminglyScience's explanation, but to spell it out:\r\n\r\nThe assignment does _not_ happen first; if it did, `$a = 42 > delete.me` would result in `$a` containing `42`, but it actually contains \"nothing\" (`[System.Management.Automation.Internal.AutomationNull]::Value`).",
      "created_at": "2020-01-16T22:30:45Z",
      "updated_at": "2020-01-16T22:30:45Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "\r\n> Assignments can't be expressions, they're just statements. Everything to the right of the = is then assigned to the variable.\r\n\r\nSomething I've assumed for a decade or more is showing cracks \r\nI've always fitted = into being an operator, and += etc belonging with + as arithmetic operators. \r\n\r\nTo support this thinking: Brackets **don't** turn a statement into a value \r\n```\r\n >(foreach ($x in 1,2) {$x})\r\nParserError:\r\nLine |\r\n   1 | (foreach ($x in 1,2) {$x})\r\n     |              ^ Unexpected token 'in' in expression or statement.\r\n```\r\nIt needs a leading $ \r\n```\r\n>$(foreach ($x in 1,2) {$x})\r\n1\r\n2\r\n```\r\n\r\nBut assignment does turn into a value with just brackets \r\n```\r\n>($j =1)\r\n1\r\n```\r\nThis works \r\n`if ($s = [datetime]::Now.Second %2) {\"odd $s\"}`\r\nThis fails\r\nif (if ([datetime]::Now.Second %2) {$true}) {\"odd\"}\r\n\r\nSo assignment doesn't belong in the same box as for or while or if \r\n\r\n```\r\n>$j ++ > delete.me\r\n>cat delete.me\r\n1\r\n>$j\r\n2\r\n```\r\nIncrement is a form of assignment, right ? This should be increment $j and write the result \r\n`>$j += 1 > delete.me`\r\n\r\n>$j\r\n2\r\n>cat delete.me\r\n1\r\n\r\nSo that has done $j += (1 > delete.me) \r\nwhich is logical enough because > is actually out-file, which you can see with a broken file name \r\n```\r\n$j ++ > delete:me\r\nOut-File: Cannot find drive. A drive with the name 'delete' does not exist.\r\n```\r\nSo really it $j += 1 > delete.me is `$j += 1 | out-file delete.me` and  we'd expect `$x = something | somethingElse | etc `to  put the result of the whole pipeline into $x,  `($x = something) | somethingelse `  would be crazy. \r\n\r\nOf course the > operator is crazy because you can write it in the middle of a command \r\n`>dir \\foo,'C:\\Program Files\\p*','C:\\Programs\\' > foo.txt -include p*`\r\n\r\nIf that wasn't enough. \r\n```\r\ndir \\foo,'C:\\Program Files\\p*','C:\\Programs\\' > foo.txt -include p* >bar.txt\r\nParserError:\r\nLine |\r\n   1 | dir \\foo,'C:\\Program Files\\p*','C:\\Programs\\' > foo.txt -include p* >bar.txt\r\n     |                                                                     ^ The output stream for this command is already redirected.\r\n```\r\nWell obviously. So I shouldn't be able to pipe the output but this : \r\n`dir \\foo,'C:\\Program Files\\p*','C:\\Programs\\' > foo.txt -include p* | format-table`\r\nRuns\r\n\r\nTo the matter in hand. \r\nAre wer surprised that $x *>&1  enumerates X if it is an array ? \r\n>$y = (@(1) *>&1  )    \r\ngives the same result as \r\n>$y = $(@(1) )\r\nor \r\n$y = (@(1) | % {$_}  )    \r\n\r\n**It's not the enumeration which is odd at all.**  I think @mklement0  has it backwards. What is odd is that \r\n`$y = @(1) *>&1`  assigns the unenumerated array to $y \r\n\r\nBut it has been like that since Windows PowerShell 3 released so I think that boat has sailed, run aground and all aboard have been taken off.  So I'm not sure what the goal is here, go back and change some very old behavior to remove the need for some brackets in a very odd use case ?  \r\n",
      "created_at": "2020-01-17T08:01:41Z",
      "updated_at": "2020-01-17T08:01:41Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> > Assignments can't be expressions, they're just statements. Everything to the right of the = is then assigned to the variable.\r\n> \r\n> Something I've assumed for a decade or more is showing cracks\r\n> I've always fitted = into being an operator, and += etc belonging with + as arithmetic operators.\r\n> \r\n> To support this thinking: Brackets **don't** turn a statement into a value\r\n\r\nWhoops I misspoke, `AssignmentStatementAst` *is* a pipeline... sorta.  It's a subclass of `PipelineBaseAst`, so it can go in most of the places where a pipeline can, *however* `PipelineBaseAst` does not store redirections.  That's `PipelineAst`, which can only store a command or a command expression.\r\n\r\nIt's more of a technicality to allow assignments to be stored in a paren expression, not much more than that though.\r\n\r\n> But assignment does turn into a value with just brackets\r\n> \r\n> ```\r\n> >($j =1)\r\n> 1\r\n> ```\r\n\r\nYeah that's some special casing by the compiler.  They wanted to match C# where an assignment is typically a void statement, but if wrapped in parenthesis it returns the value that was assigned. (Side note, iirc someone wanted assignments to return by default.  That would have been nuts)\r\n\r\n> **It's not the enumeration which is odd at all.** I think @mklement0 has it backwards. What is odd is that\r\n> `$y = @(1) *>&1` assigns the unenumerated array to $y\r\n> \r\n> But it has been like that since Windows PowerShell 3 released so I think that boat has sailed, run aground and all aboard have been taken off. So I'm not sure what the goal is here, go back and change some very old behavior to remove the need for some brackets in a very odd use case ?\r\n\r\nI just want to clarify that I don't really have an opinion on this.  I want to make sure that it's understood *what* is happening, but I don't use redirection and typically advise other folks not to either.",
      "created_at": "2020-01-17T13:13:54Z",
      "updated_at": "2020-01-17T13:16:37Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> Whoops I misspoke, `AssignmentStatementAst` _is_ a pipeline... sorta. It's a subclass of `PipelineBaseAst`, so it can go in most of the places where a pipeline can, _however_ `PipelineBaseAst` does not store redirections. That's `PipelineAst`, which can only store a command or a command expression.\r\n\r\nPhew. I'm not totally nuts then. And it's nice to see someone other than me doing the mis-speaking \r\n> > **It's not the enumeration which is odd at all.**  .... \r\n> > But it has been like that since Windows PowerShell 3  ...  I'm not sure what the goal is here,\r\n> \r\n> I just want to clarify that I don't really have an opinion on this. I want to make sure that it's understood _what_ is happening, but I don't use redirection and typically advise other folks not to either.\r\n\r\nI know (from discussing ansi sequences going into standard output) that you're not a big fan of redirection but \"Send what you printed on the screen to a file\" / \"Send it to std-in of another executable\" is still a common (if less than ideal) scenario.  I don't doubt that mk has found something odd, but I think the oddity is not that `$x = ($array *>&1) `  assigns the result of enumerating the array but that `$x = $array *>&1` assigns the array.    \r\nBut then what ? Do we just congratulate him for finding something so obscure that it's been there for 10 years and no-one has noticed, and leave it alone, on the grounds that changing it has infinitesimally small value , but entails effort and the risk of breaking other things ?",
      "created_at": "2020-01-17T14:01:11Z",
      "updated_at": "2020-01-17T14:01:58Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I think the point of filing the issue is mainly to note that a) it is a thing that happens, though it's a bit of an unusual case to stumble across, and b) to prompt folx like ourselves and also the PS team to think about whether it's something we should be fixing. \ud83d\ude42 \r\n\r\nI think the argument that both cases should behave the same is sensible -- the fact that adding parentheses changes how the expression behaves does seem like the kind of thing that shouldn't happen. Whether it's worth fixing or might break something else to fix it, is something that we should try to determine, I think. \ud83d\ude01 ",
      "created_at": "2020-01-17T14:12:38Z",
      "updated_at": "2020-01-17T14:12:38Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> > Whoops I misspoke, `AssignmentStatementAst` _is_ a pipeline... sorta. It's a subclass of `PipelineBaseAst`, so it can go in most of the places where a pipeline can, _however_ `PipelineBaseAst` does not store redirections. That's `PipelineAst`, which can only store a command or a command expression.\r\n> \r\n> Phew. I'm not totally nuts then. And it's nice to see someone other than me doing the mis-speaking\r\n\r\n\ud83d\ude04 \r\n\r\n> I know (from discussing ansi sequences going into standard output) that you're not a big fan of redirection but \"Send what you printed on the screen to a file\" / \"Send it to std-in of another executable\" is still a common (if less than ideal) scenario.\r\n\r\nWhat I mean is that I don't recommend using the redirection language syntax.  There's plenty of reasons to use `Out-File` and what not.  I don't recommend sending *formatted* data to it, but it's still a useful cmdlet for sure.\r\n\r\n>  I don't doubt that mk has found something odd, but I think the oddity is not that `$x = ($array *>&1) ` assigns the result of enumerating the array but that `$x = $array *>&1` assigns the array.\r\n> But then what ? Do we just congratulate him for finding something so obscure that it's been there for 10 years and no-one has noticed, and leave it alone, on the grounds that changing it has infinitesimally small value , but entails effort and the risk of breaking other things ?\r\n\r\n\ud83e\udd37\u200d\u2642 I don't have an opinion on it.  If I chime in to explain something, some folks could take that to mean that I'm advocating for one side or the other.  In this case I'm not, I'm just making sure that those who *do* care have all the information (basically what @vexx32 said \ud83d\ude42).",
      "created_at": "2020-01-17T14:22:57Z",
      "updated_at": "2020-01-17T14:22:57Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> I think the point of filing the issue is mainly to note that a) it is a thing that happens, though it's a bit of an unusual case to stumble across, and b) to prompt folx like ourselves and also the PS team to think about whether it's something we should be fixing. \ud83d\ude42\r\n\r\nMaybe... but there is a level of obscurity where it is really not worth fixing. Take a couple of things I mentioned along the way \r\n`Get-ChildItem > dir.txt -force `\r\nSyntactically legal and the force applies to GCI , not to the redirection. Or \r\n`Get-ChildItem > dir.txt -force | format-table`\r\nYou can ask for something to be redirected twice.  Are those wrong ? Should they be fixed ? or are the just part of life's rich tapestry ? \r\n\r\n> I think the argument that both cases should behave the same is sensible -- the fact that adding parentheses changes how the expression behaves does seem like the kind of thing that shouldn't happen. Whether it's worth fixing or might break something else to fix it, is something that we should try to determine, I think. \ud83d\ude01\r\n\r\nWorth fixing ...Security risk ? no. Problems in the field ? No ? \r\nI think the change in behaviour with and without brackets is odd.  But normally $x = something-with-redirection , has the redirection fire before the assignment happens and what ever emerges at the end of the redirection goes to the assignment.  Here you have to enclose the redirection to get it to happen, otherwise the assignment happens and nothing gets redirected. \r\n\r\nBut there is other wierdness   What should this do ?\r\n`$y = (1/0) *>&1`\r\nThe divide by zero error should end up in y, right ?  Try it because that isn't what happens. \r\nOK let's wrap it and force it to evaluate \r\n`$y = ((1/0) *>&1)`\r\nThat's got to work right ? No. \r\n\r\nThis works. \r\n`$y = & {(1/0)} *>&1 `\r\n\r\nConclusion I get to is redirecting (or merging the streams of) an expression instead of a command means normal rules might not apply. How urgent is it to fix this ... wash your dog first :-)  \r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-01-17T14:49:39Z",
      "updated_at": "2020-01-17T14:49:39Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Aye, I'll definitely agree it's not an important issue for everyone. But that doesn't mean it's not an important issue for anyone. \ud83d\ude42 ",
      "created_at": "2020-01-17T14:53:52Z",
      "updated_at": "2020-01-17T14:53:52Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Fully agreed, @vexx32, but I think the point from your earlier comment is a more important one that bears repeating:\r\n\r\nAn anomaly / inconsistency is _always_ worth investigating, _wherever it may lead_.\r\n\r\nOnce the behavior and, ideally, the underlying cause is _understood_, appropriate action - if any - can be taken, _whatever it may be_.\r\n\r\n----\r\n\r\nClearly, in the case at hand discussion was needed to get conceptual clarity on the behavior: we've now narrowed down the inconsistency (though we still don't know its precise cause).\r\n\r\nThe stated premise of this issue was that this is an exotic and conceptually pointless use case, but, if you build [the ability to do] it, they will come, if you will - a since-edited [answer on Stack Overflow](https://stackoverflow.com/posts/59761033/timeline) prompted the question.\r\n\r\nPlus, before fully understanding the issue you never know what other, potentially more serious manifestations it may have.\r\n\r\nPersonally, I'm happy with leaving this be, now that I understand the issues involved.\r\n\r\nIf a fix were to be made, I'd be happy with making `>&1` consistently _enumerate_ as well - what matters, in the end, is whether the behavior is _consistent_, not (too) surprising, and easily conceptualized.\r\n\r\nEven if no action is taken, the discussion was worthwhile (most of it), at least to me.\r\n\r\nFinally, in the spirit of furthering a shared understanding, I will address a few more points below.\r\n\r\n----\r\n\r\n> You can ask for something to be redirected twice. Are those wrong ? Should they be fixed ?\r\n\r\nNo. There are no inconsistencies there. `>` in the middle of a command is defensible, though perhaps ill-advised; `Get-ChildItem > dir.txt -force | format-table` is just user error - you can't fully guard against users combining language elements in nonsensical ways.\r\n\r\n> Here you have to enclose the redirection to get it to happen, otherwise the assignment happens and nothing gets redirected.\r\n\r\nFor the primary use case for redirections - calling an external program - _not_ using `(...)` works just fine.\r\n\r\n```powershell\r\n$out = ls / nosuch 2>&1   # captures both stdout and stderr in $out\r\n```\r\n\r\n> What should this do ? `$y = (1/0) *>&1`\r\n\r\n`1/0` is a _statement-terminating_ error, so the entire statement is aborted - `$y` is not created - this example is therefore unrelated to our discussion.\r\n\r\n> $y = (@(1) *>&1 )\r\ngives the same result as\r\n$y = $(@(1) )\r\nor\r\n$y = (@(1) | % {$_} )\r\n\r\n`$(...)` and `@(...)` _always_ enumerate, whereas `(...)` doesn't (except if you use it as the 1st segment of a pipeline).\r\n",
      "created_at": "2020-01-17T19:13:13Z",
      "updated_at": "2020-01-17T19:13:13Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I've updated the initial post with a summary to help future readers, should they stumble across this, and I'm closing the issue. \r\n\r\n@SeeminglyScience, if you're familiar with the technical why of the inconsistency and you can think of a real-world use case (as opposed to the contrived one shown here) where it could manifest, please let us know.\r\n",
      "created_at": "2020-01-18T16:22:32Z",
      "updated_at": "2020-01-18T16:22:32Z"
    }
  ],
  "created_at": "2020-01-16T02:16:37Z",
  "number": 11598,
  "state": "closed",
  "title": "Inside parentheses, adding a redirection to an expression causes enumeration, unlike without parentheses",
  "updated_at": "2020-01-18T16:29:39Z"
}