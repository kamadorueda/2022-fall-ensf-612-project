{
  "_url": "https://github.com/PowerShell/PowerShell/issues/17633",
  "author": "MatejKafka",
  "body": "Back with another obscure issue. :sweat_smile: \r\n\r\n### Steps to reproduce\r\n\r\nBuggy code:\r\n```c#\r\nusing System.Management.Automation;\r\nusing System.Management.Automation.Runspaces;\r\n\r\n[Cmdlet(VerbsLifecycle.Invoke, \"RunspacePrompt\")]\r\npublic class InvokeRunspacePrompt : PSCmdlet, IDisposable {\r\n    private readonly PowerShell _ps = PowerShell.Create();\r\n\r\n    protected override void BeginProcessing() {\r\n        base.BeginProcessing();\r\n        _ps.Runspace = RunspaceFactory.CreateRunspace(Host);\r\n        _ps.Runspace.Open();\r\n        _ps.AddScript(@\"$Host.UI.Write('Input: '); $Host.UI.ReadLine()\");\r\n        _ps.Invoke();\r\n    }\r\n\r\n    protected override void StopProcessing() {\r\n        base.StopProcessing();\r\n        // this call causes the deadlock\r\n        _ps.Stop();\r\n    }\r\n\r\n    public void Dispose() {\r\n        _ps.Runspace?.Dispose();\r\n        _ps.Dispose();\r\n    }\r\n}\r\n```\r\n\r\nSteps to reproduce:\r\n1. Create a cmdlet which creates a new Runspace, which:\r\n   - Uses the same `Host` as the main runspace\r\n   - Runs a script that reads from the host (either using `$Host.UI.ReadLine` directly, or by calling `Read-Host`)\r\n   - The cmdlet implements `StopProcessing`, which stops the runspace.\r\n2. Run the cmdlet.\r\n3. When prompted for input, pres Ctrl-C.\r\n4. The input freezes and you have to kill the whole `pwsh` instance.\r\n\r\n### Expected behavior\r\n\r\nThe runspace is stopped and the cmdlet also stops.\r\n\r\n\r\n### Actual behavior\r\n\r\nThe input freezes and you have to kill the whole `pwsh` instance.\r\n\r\nInterestingly, in PowerShell 5.1, Ctrl-C works correctly the first time, but freezes when you run the cmdlet a second time.\r\n\r\n\r\n### Error details\r\n\r\nIt seems to me that the issue is in the `HandleBreak` thread, which gets stuck and cannot stop the runspace when it's waiting for host input.\r\n\r\nStack of both runspace threads:\r\n- The inner runspace thread, blocked waiting for input in `NativeMethods.ReadConsole`:\r\n```\r\n[Managed to Native Transition]\r\nConsoleControl.NativeMethods.ReadConsole()\r\nConsoleControl.ReadConsole()\r\nConsoleHostUserInterface.ReadLineFromConsole()\r\nConsoleHostUserInterface.ReadLine()\r\nConsoleHostUserInterface.ReadLine()\r\nInternalHostUserInterface.ReadLine()\r\n[Lightweight Method Call]\r\nUpdateDelegates.UpdateAndExecute1<object, object>()\r\nDynamicInstruction<object, object>.Run()\r\nEnterTryCatchFinallyInstruction.Run() [2]\r\nEnterTryCatchFinallyInstruction.Run() [1]\r\nInterpreter.Run()\r\nLightLambda.RunVoid1<System.Management.Automation.Language.FunctionContext>()\r\nDlrScriptCommandProcessor.RunClause()\r\nDlrScriptCommandProcessor.Complete()\r\nCommandProcessorBase.DoComplete()\r\nPipelineProcessor.DoCompleteCore()\r\nPipelineProcessor.SynchronousExecuteEnumerate()\r\nLocalPipeline.InvokeHelper()\r\nLocalPipeline.InvokeThreadProc()\r\nLocalPipeline.InvokeThreadProcImpersonate()\r\nExecutionContext.RunInternal()\r\n[Native to Managed Transition]\r\n```\r\n- The main (original) runspace thread, waiting for script completion in `PowerShell.Invoke`:\r\n```\r\nWaitHandle.WaitOneNoCheck()\r\nPipelineBase.Invoke()\r\nPipeline.Invoke()\r\nPowerShell.Worker.ConstructPipelineAndDoWork()\r\nPowerShell.Worker.CreateRunspaceIfNeededAndDoWork()\r\nPowerShell.CoreInvokeHelper<object, System.Management.Automation.PSObject>()\r\nPowerShell.CoreInvoke<object, System.Management.Automation.PSObject>()\r\nPowerShell.CoreInvoke<System.Management.Automation.PSObject>()\r\nPowerShell.Invoke()\r\nPowerShell.Invoke()\r\nInvokeRunspacePrompt.BeginProcessing()\r\nCmdlet.DoBeginProcessing()\r\nCommandProcessorBase.DoBegin()\r\nCommandProcessor.DoBegin()\r\nPipelineProcessor.Start()\r\nPipelineProcessor.SynchronousExecuteEnumerate() [2]\r\nPipelineOps.InvokePipeline()\r\nActionCallInstruction<object, bool, CommandParameterInternal[][], CommandBaseAst[], CommandRedirection[][], FunctionContext>.Run()\r\nEnterTryCatchFinallyInstruction.Run() [2]\r\nEnterTryCatchFinallyInstruction.Run() [1]\r\nInterpreter.Run()\r\nLightLambda.RunVoid1<System.Management.Automation.Language.FunctionContext>()\r\nDlrScriptCommandProcessor.RunClause()\r\nDlrScriptCommandProcessor.Complete()\r\nCommandProcessorBase.DoComplete()\r\nPipelineProcessor.DoCompleteCore()\r\nPipelineProcessor.SynchronousExecuteEnumerate() [1]\r\nLocalPipeline.InvokeHelper()\r\nLocalPipeline.InvokeThreadProc()\r\nLocalPipeline.InvokeThreadProcImpersonate()\r\nPipelineThread.WorkerProc()\r\nExecutionContext.RunInternal()\r\n[Native to Managed Transition]\r\n```\r\n- The HandleBreak signal handler thread, waiting for **something?** in `PowerShell.Stop`\r\n```\r\nWaitHandle.WaitOneNoCheck()at D:\\_\\JetBrains Rider\\config\\config\\resharper-host\\SourcesCache\\ae38ed1b9f125d13c59ee2eaed08dcf53cfb8dc1cefafbef3d16c2be9752f8\\WaitHandle.cs:line 139\r\nLocalPipeline.StopHelper()at D:\\programming\\_cloned\\PowerShell\\src\\System.Management.Automation\\engine\\hostifaces\\LocalPipeline.cs:line 800 [2]\r\nLocalPipeline.ImplementStop() [2]\r\nPipelineBase.CoreStop() [2]\r\nPipelineBase.Stop() [2]\r\nPowerShell.Worker.Stop()\r\nPowerShell.CoreStop()\r\nPowerShell.Stop()\r\nInvokeRunspacePrompt.StopProcessing()\r\nCmdlet.DoStopProcessing()\r\nPipelineProcessor.Stop()\r\nPipelineStopper.Stop()\r\nLocalPipeline.StopHelper() [1]\r\nLocalPipeline.ImplementStop() [1]\r\nPipelineBase.CoreStop() [1]\r\nPipelineBase.Stop() [1]\r\nExecutor.Cancel()\r\nExecutor.CancelCurrentExecutor()\r\nConsoleHost.HandleBreak()\r\n[Native to Managed Transition]\r\n```\r\n\r\n### Environment data\r\n\r\n```powershell\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.3.0-preview.2\r\nPSEdition                      Core\r\nGitCommitId                    7.3.0-preview.2\r\nOS                             Microsoft Windows 10.0.19044\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n\r\nThe issue also reproduces in 7.3.0-preview.5 and 7.2.5 (stable).\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "MatejKafka",
      "author_association": "NONE",
      "body": "Reading through the stack trace again, it seems that `PowerShell.Stop()` called in `HandleBreak` thread runs almost to the end, but gets stuck waiting for the pipeline to finish. My guess would be that the nested runspace thread responsible for running the pipeline is stuck waiting for host input and doesn't \"notice\" that it should end. The question then probably is, why does this work when there's only one runspace involved, but not when there's a nested runspace?\r\n\r\nIs it incorrect to call `PowerShell.Stop()` in the `StopProcessing` handler, or is this an internal PowerShell issue and this is supposed to work?",
      "created_at": "2022-07-05T21:59:41Z",
      "updated_at": "2022-07-05T22:00:21Z"
    },
    {
      "author": "fMichaleczek",
      "author_association": "NONE",
      "body": "If you use the async methods PowerShell.BeginStop and PowerShell.EndStop, it's working as expected.\r\n\r\n![image](https://user-images.githubusercontent.com/6187529/177456064-e356e11f-95e5-4b88-8b07-cd57e12935f3.png)\r\n\r\n\r\n```cs\r\nusing System;\r\nusing System.Management.Automation;\r\nusing System.Management.Automation.Runspaces;\r\n\r\n[Cmdlet(VerbsLifecycle.Invoke, \"RunspacePrompt\")]\r\npublic class InvokeRunspacePrompt : PSCmdlet, IDisposable {\r\n    private readonly PowerShell _ps = PowerShell.Create();\r\n    protected override void BeginProcessing() {\r\n        base.BeginProcessing();\r\n        _ps.Runspace = RunspaceFactory.CreateRunspace(Host);\r\n        _ps.Runspace.Open();\r\n        _ps.AddScript(@\"$Host.UI.Write('Input: '); $Host.UI.ReadLine()\");\r\n        Console.WriteLine(\"Invoking\");\r\n        _ps.Invoke();\r\n    }\r\n\r\n    protected override void StopProcessing() {\r\n        base.StopProcessing();\r\n        _ps.BeginStop(ar => { _ps.EndStop(ar); /*System.Threading.Thread.Sleep(30000);*/ Console.WriteLine(\"PS Stopped\") ;}, null);\r\n        Console.WriteLine(\"StopProcessing Done.\");\r\n    }\r\n\r\n    public void Dispose() {\r\n        _ps.Runspace?.Dispose();\r\n        _ps.Dispose();\r\n    }\r\n}\r\n```",
      "created_at": "2022-07-06T02:46:42Z",
      "updated_at": "2022-07-06T02:57:43Z"
    },
    {
      "author": "MatejKafka",
      "author_association": "NONE",
      "body": "@fMichaleczek This almost works, but it seems there's a race condition between the child runspace starting to run another command and getting stopped. Try changing\r\n```c#\r\n_ps.AddScript(@\"$Host.UI.Write('Input: '); $Host.UI.ReadLine()\");\r\n```\r\nto\r\n```c#\r\n_ps.AddScript(@\"$Host.UI.Write('Input: '); $Host.UI.ReadLine(); $Host.UI.Write('Input done.')\");\r\n```\r\n\r\nAt least on my machine, the second input prompt triggers before the runspace is stopped:\r\n![image](https://user-images.githubusercontent.com/6414091/177525309-2c53d5b9-6fb4-4479-be4f-d08d2f0e31ce.png)\r\n",
      "created_at": "2022-07-06T10:01:17Z",
      "updated_at": "2022-07-06T10:01:17Z"
    }
  ],
  "created_at": "2022-07-05T21:50:19Z",
  "number": 17633,
  "state": "open",
  "title": "Reading host input from a child runspace causes a deadlock when Ctrl-C is pressed",
  "updated_at": "2022-07-06T10:01:17Z"
}