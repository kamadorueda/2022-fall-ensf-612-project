{
  "_url": "https://github.com/PowerShell/PowerShell/issues/4332",
  "author": "mklement0",
  "body": "<sup>This was first proposed as part of a lengthy exchange in #3996, but I thought it deserved its own post.</sup>\r\n\r\n**tl;dr**\r\n\r\nIn order to collected stderr output (separately) from an external-utility call in memory, I suggest supporting the following **new redirection syntax that allows capturing stderr lines in a _variable_,  akin to the common `-ErrorVariable` parameter for _cmdlets_** (the sample `cmd` command is designed to produce both stdout and stderr output):\r\n\r\n```powershell\r\n# Wishful thinking: Collect stderr lines in given variable $stderrOutput via 2>&\r\n$stdoutOutput = cmd /c ver '&' dir \\nosuch 2>&stderrOutput \r\n```\r\n\r\nInstead of what you must currently do:\r\n\r\n```powershell\r\n$stderrFile = New-TemporaryFile\r\n$stdoutOutput = cmd /c ver '&' dir \\nosuch 2>$stderrFile\r\n$stderrOutput = Get-Content $stdErrFile\r\nRemove-Item $stderrFile\r\n```\r\n\r\n---\r\n\r\nThe current behavior is to pass stderr output generated by external utility calls (e.g., to `git`) through to the console - stderr output is _not_ recorded in `$Error`, which makes sense, given that many utilities write much more than just _error_ information to stderr, and that the presence of stderr input doesn't imply actual errors.\r\n\r\nSometimes it is necessary to inspect stderr output, however, which is currently not easily accomplished:\r\n\r\nYou can _redirect_ stderr output by redirecting PowerShell's error stream: `2>...`, but you're faced with 2 options, neither of which is convenient:\r\n\r\n* Either: redirect stderr output to a _file_ with `2>filename`\r\n\r\n* Or: redirect stderr output into the success stream with `2>&1` to produce a _combined_ stream from which you can later filter out the stderr lines by _type_ (`[System.Management.Automation.ErrorRecord]`).\r\n\r\nTherefore, I propose a new redirection syntax that allows capturing stderr lines in a _variable_,  akin to the common `-ErrorVariable` parameter for _cmdlets_, so that:\r\n\r\n* `foo.exe 2>&errs` would be the external-utility-call equivalent of a (fictitious) `Invoke-Foo -ErrorVariable errs 2>$null` call, with errors getting collected in _variable_ `$errs` in both cases.\r\n\r\n* Additionally, to allow stderr output to _also be passed through_ while being collected:  \r\n`foo.exe 2>&|errs` could be the equivalent of `Invoke-Foo -ErrorVariable errs`\r\n\r\nThe suggestion is to use `>&varName` syntax, because `&` is already established as having into-a-different-target(-stream) semantics, yet currently only a _digit_ is supported after the `&` (the index of a different PS stream).  \r\n(There is still ambiguity, given that `$1` is a valid variable name, but I think that wouldn't be a real-world concern.)\r\n\r\nAlso, given that `-ErrorVariable` supports a `+` prefix to the variable name to indicate that the existing variable value should be _appended_ to, this new syntax should support that too.\r\n\r\n\r\n\r\nEnvironment data\r\n----------------\r\n\r\n<!-- provide the output of $PSVersionTable -->\r\n\r\n```powershell\r\nPowerShell Core v6.0.0-beta.4\r\n```\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "JamesWTruher",
      "author_association": "MEMBER",
      "body": "Rather than this approach which relies on syntactic element, it was possible to create redirection as follows:\r\n```powershell\r\nPS> write-error bad 2>variable:var1\r\n```\r\nand\r\n```powershell\r\n$a = 1..5\r\n6..9 | write-error 2>>variable:a\r\n```\r\nwhile not as terse as a sigil, it required _very_ little change. It also works with native executables ala:\r\n```powershell\r\nPS> $result = /bin/ls -ld . sdfljksdj 2>variable:whoops\r\nPS> $result\r\ndrwxr-xr-x  93 james  staff  2976 Jun 12 12:05 .\r\nPS> $whoops\r\nls: sdfljksdj: No such file or directory\r\n```\r\na further by-product is that now all streams may be redirected to a variable\r\n```powershell\r\n$a = . { \r\n>> write-error bad\r\n>> write-warning warning\r\n>> write-verbose -verbose 'and here'\r\n>> write-debug -debug 'yep, debug too'\r\n>> write-information 'and info'\r\n>> } 2>variable:e 3>variable:w 4>variable:v 5>variable:d 6>variable:i\r\nPS> $e\r\nWrite-Error: bad\r\nPS> $w\r\nWARNING: warning\r\nPS> $v\r\nVERBOSE: and here\r\nPS> $d\r\nDEBUG: yep, debug too\r\nPS> $i\r\nand info\r\n```\r\nand append works too\r\n```powershell\r\nPS> 1..3 | write-error 2>variable:e         \r\nPS> /bin/ls -ld / lsjdflkjsdlj 2>>variable:e\r\ndrwxr-xr-x  23 root  admin  736 Jun  8 14:35 /\r\nPS> $e\r\nWrite-Error: 1\r\nWrite-Error: 2\r\nWrite-Error: 3\r\nls: lsjdflkjsdlj: No such file or directory\r\n```\r\n\r\nI think that using `variable:<name>` is ok - I think it's somewhat natural for the PowerShell  environment.\r\nIt required a relatively simple change to the engine and a small extension to `set-variable`. I can submit a PR if you think this is reasonable.",
      "created_at": "2020-06-12T21:15:40Z",
      "updated_at": "2020-06-12T21:17:11Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Just one question... is this generalizable to all PSProviders/PSDrives that support the Content API now?\r\n\r\nBecause IMO... it should be. \ud83d\ude42 ",
      "created_at": "2020-06-12T21:31:29Z",
      "updated_at": "2020-06-12T21:31:29Z"
    },
    {
      "author": "billkindle",
      "author_association": "NONE",
      "body": "I think this has some potential to be very useful especially on Linux. There\u2019s been a few times where I\u2019ve needed to capture standard output, didn\u2019t care to log it, But needed to perform certain actions based on what type of output it was. ",
      "created_at": "2020-06-12T21:34:46Z",
      "updated_at": "2020-06-12T21:34:46Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @JamesWTruher - I like the idea, and personally I would definitely welcome a PR.\r\n\r\nFollow-up questions:\r\n\r\n* To flesh out @vexx32 's concern: Since this would amount to effectively supporting namespace variable notation as the redirection target, we should probably support _all_ drives:\r\n\r\n  * Among the standard drives, aside from `variable:foo`, only `env:Foo` makes sense (writing to an environment variable), but conceivably there could be other providers whose drives could be meaningfully targeted.\r\n\r\n* The original proposal included an additional feature variation; do we need it, and, if so, what should the syntax be?\r\n  * Optionally also passing a stream _through_ while capturing it (this would be like an in-command `Tee-Object` for any stream targeted).\r\n\r\n\r\n",
      "created_at": "2020-06-12T21:46:17Z",
      "updated_at": "2020-06-12T22:37:28Z"
    },
    {
      "author": "KevinMarquette",
      "author_association": "CONTRIBUTOR",
      "body": "I would like it better as a cmdlet we can pipe to before we make it an operator.",
      "created_at": "2020-06-12T22:16:52Z",
      "updated_at": "2020-06-12T22:16:52Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "I would happily vote yes to making _each and every one_ of the numbered streams generically redirectable to _any content provider_ PSDrive path.  That makes sense, it's always frustrating when something looks like it builds on the content providers and doesn't. \r\n\r\nI think a version of `Tee-Object` that could capture streams beyond **should** be technically **impossible**, because only _output_ goes to cmdlets in a pipeline, and it would be _super confusing_ if there was some magic thing that looked like a cmdlet but could somehow intercept other output before it gets to the host.\r\n\r\nAs a use case / example: we love @dlwyatt's [PowerShellLogging](https://github.com/dlwyatt/PowerShellLoggingModule) module, but what it does is a dirty hack that shims the host. Unless you're going to make interfaces public so that sort of host interception logging would be possible _in every host_ without using private methods, I don't need a cmdlet version of redirection, and I don't want weird new syntax for capturing without redirecting (that is, passthrough capturing)\r\n\r\nP.S. Alias: is a content drive and works just as well as ENV: for holding strings... \ud83e\udd2f ",
      "created_at": "2020-06-12T22:30:29Z",
      "updated_at": "2020-06-12T22:50:29Z"
    },
    {
      "author": "SimonWahlin",
      "author_association": "CONTRIBUTOR",
      "body": "I really like the ability to redirect to a psdrive, please make it work on any content providers drive, not just variable. I guess variable and env are the ones that makes sense currently, but just as jaykul says, having it look like it is using a content provider when it is not will just create a special case that will be hard to explain.",
      "created_at": "2020-06-13T07:07:34Z",
      "updated_at": "2020-06-13T07:07:34Z"
    },
    {
      "author": "qaswani",
      "author_association": "NONE",
      "body": "I love this. I re-implemented `Start-Process` to support this behavior so I could redirect `stderr`/`stdout` to a variable and return a `System.Diagnostics.Process` object with two additional properties that contain any output. Having this feature would simplify a lot of code for parsing command output. It's only a matter of time before my hack runs into a scenario it can't handle.",
      "created_at": "2020-06-13T23:58:34Z",
      "updated_at": "2020-06-13T23:59:12Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@Jaykul \r\n\r\nAgreed re `Tee-Object` cmdlet.\r\n\r\n> Unless you're going to make interfaces public so that sort of host interception logging\r\n\r\nI don't think we should think of this in terms of _hosts_ - the fact that external-program output is sent directly to the host by default should be considered an implementation detail. Instead, we want to be able to target _streams_:\r\n\r\nThe `>` operator already allows you to selectively redirect stderr output (which would by default go to the host, and with the proposal at hand we would now also support variables as targets (potentially among others).\r\n\r\nThe suggestion to enable optional _pass-through_ functionality stems from a gap in functionality with respect to external programs and their stderr output, specifically.\r\n\r\nFor _PowerShell_ commands you can use the `-*Variable` common parameters (e.g., `-ErrorVariable`), optionally via an aux. `Invoke-Command` call, to capture stream output _with pass-through logic_; that is, capturing stream output this way passes through _by default_, and you need to explicitly silence the target stream to suppress that.\r\n\r\nThis ability is currently lacking for _external-program calls_ - you only have the choice between passing through to the host only, or redirecting and thereby _invariably_ silencing the stream.\r\n\r\nIt is conceivable that you want to _both_ see stderr output - and doing so _in context_, interleaved with stdout output is especially important when calling external programs - _and_ capture it.\r\n\r\nYou can actually _somewhat_ emulate this with `Invoke-Command` at the moment though it's both highly obscure and has major side effects, notably polluting the success output stream and changing the output sequencing:\r\n\r\n```powershell\r\n# $e captures stderr output, while still passing it through - albeit invariably\r\n# via the *success* output stream, and out of sequence\r\nInvoke-Command { ls / nosuch 2>&1 } -ErrorVariable e\r\n```\r\n\r\nThat said, if `-ErrorVariable` were able to capture stderr output _as-is_, then we arguably do _not_ need a new syntax (I cannot speak to the technical feasibility):\r\n\r\n```powershell\r\n# WISHFUL THINKING:\r\n# Pass stderr output through, in output order, *and* capture it in variable $e\r\n# (Currently, this records nothing in $e.)\r\nInvoke-Command { ls / nosuch } -ErrorVariable e\r\n```\r\n\r\n---\r\n\r\n> P.S. Alias: is a content drive and works just as well as ENV: for holding strings..\r\n\r\nIndeed; to spell it out: the proposal is to allow targeting drives of all those PS providers that implement the `IContentCmdletProvider` interface, which _technically_ means the following standard providers:\r\n\r\n```powershell\r\nPS> (Get-PSProvider | Where-Object { \r\n      $_.ImplementingType.GetInterfaces() -contains [System.Management.Automation.Provider.IContentCmdletProvider] \r\n    }).Name\r\n\r\nAlias\r\nEnvironment\r\nFileSystem\r\nFunction\r\nVariable\r\n",
      "created_at": "2020-06-14T14:25:44Z",
      "updated_at": "2020-08-16T14:14:05Z"
    }
  ],
  "created_at": "2017-07-24T19:15:33Z",
  "number": 4332,
  "state": "open",
  "title": "Suggestion: Add redirection syntax that allows in-memory collection of stderr lines output by external utilities, akin to the -ErrorVariable common parameter",
  "updated_at": "2020-08-16T14:14:05Z"
}