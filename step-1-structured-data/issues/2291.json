{
  "_url": "https://github.com/PowerShell/PowerShell/issues/2291",
  "author": "vors",
  "body": "<!--\n\nIf it is a bug report:\n- make sure you are able to repro it on the latest released version. \nYou can install the latest version from https://github.com/PowerShell/PowerShell/releases\n- Search the existing issues.\n- Refer to the [FAQ](../docs/FAQ.md).\n- Refer to the [known issues](../docs/KNOWNISSUES.md).\n- Fill out the following repro template\n\nIf it's not a bug, please remove the template and elaborate the issue in your own words.\n-->\n\nThis is follow-up from #2284\n## Steps to reproduce\n\nCreate a simple coreclr app that hosts powershell thru `Microsoft.PowerShell.SDK`\n\n**Note**: the current function of `Microsoft.PowerShell.SDK` is to provide an ability to compile binary modules that then could be imported and used in PowerShell on any platform. This issue asks a question: should we allow the same nuget package to enable **hosting** scenario?\n\nProgram.cs\n\n``` csharp\nusing System;\nusing System.Management.Automation;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        PowerShellAssemblyLoadContextInitializer.SetPowerShellAssemblyLoadContext(AppContext.BaseDirectory);\n\n        using (var ps = PowerShell.Create())\n        {\n        ps.AddScript(\"Get-Process | Out-String\");\n        var result = ps.Invoke()[0];\n            Console.WriteLine(result.ToString());\n        }\n    }\n}\n```\n\nproject.json\n\n``` json\n{\n  \"version\": \"1.0.0-*\",\n  \"buildOptions\": {\n    \"debugType\": \"portable\",\n    \"emitEntryPoint\": true\n  },\n  \"dependencies\": {},\n  \"frameworks\": {\n    \"netcoreapp1.0\": {\n      \"dependencies\": {\n        \"Microsoft.NETCore.App\": {\n          \"type\": \"platform\",\n          \"version\": \"1.0.1\"\n        },\n        \"Microsoft.PowerShell.SDK\" : \"1.0.0-alpha10\"\n      },\n      \"imports\": \"dnxcore50\"\n    }\n  }\n}\n```\n\nnuget.config\n\n``` xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<configuration>\n  <config>\n    <!-- install packages to a custom path -->\n    <add key=\"repositoryPath\" value=\"Packages\"/>\n  </config>\n  <packageSources>\n    <clear />\n    <add key=\"nuget.org\" value=\"https://api.nuget.org/v3/index.json\" />\n    <add key=\"powershell-core\" value=\"https://powershell.myget.org/F/powershell-core/api/v3/index.json\" />\n  </packageSources>\n</configuration>\n```\n\ndotnet restore works fine, dotnet run doesn't\n## Expected behavior\n\nYou should be able to run and execute\n## Actual behavior\n\nOn Unix (note that 6.0.0-alpha10 package doesn't have libs compile under `Unix` configuration, so that's expected)\n\n```\nUnhandled Exception: System.TypeInitializationException: The type initializer for 'System.Management.Automation.Runspaces.RunspaceFactory' threw an exception. ---> System.DllNotFoundException: Unable to load DLL 'api-ms-win-eventing-provider-l1-1-0.dll': The specified module could not be found.\n (Exception from HRESULT: 0x8007007E)\n   at System.Management.Automation.Tracing.EtwActivity.UnsafeNativeMethods.EventActivityIdControl(ActivityControlCode controlCode, Guid& activityId)\n   at System.Management.Automation.Tracing.EtwActivity.GetActivityId()\n   at System.Management.Automation.Runspaces.RunspaceFactory..cctor()\n   --- End of inner exception stack trace ---\n   at System.Management.Automation.Runspaces.RunspaceFactory.CreateRunspace()\n   at System.Management.Automation.PowerShell.Worker.CreateRunspaceIfNeededAndDoWork(Runspace rsToUse, Boolean isSync)\n   at System.Management.Automation.PowerShell.CoreInvokeHelper[TInput,TOutput](PSDataCollection`1 input, PSDataCollection`1 output, PSInvocationSettings settings)\n   at System.Management.Automation.PowerShell.CoreInvoke[TInput,TOutput](PSDataCollection`1 input, PSDataCollection`1 output, PSInvocationSettings settings)\n   at System.Management.Automation.PowerShell.CoreInvoke[TOutput](IEnumerable input, PSDataCollection`1 output, PSInvocationSettings settings)\n   at System.Management.Automation.PowerShell.Invoke(IEnumerable input, PSInvocationSettings settings)\n   at System.Management.Automation.PowerShell.Invoke()\n   at Program.Main(String[] args)\n\n```\n\nOn Windows\n\n```\nUnhandled Exception: System.Management.Automation.Runspaces.PSSnapInException: Cannot load Windows PowerShell snap-in Microsoft.PowerShell.Diagnostics because of the following error: Could not load file or assembly 'Microsoft.PowerShell.Commands'. The system cannot find the file specified.\n   at System.Management.Automation.Runspaces.RunspaceConfigForSingleShell.LoadMshSnapinAssembly(PSSnapInInfo mshsnapinInfo)\n   at System.Management.Automation.Runspaces.RunspaceConfigForSingleShell.LoadPSSnapIn(PSSnapInInfo mshsnapinInfo)\n   at System.Management.Automation.Runspaces.RunspaceConfigForSingleShell.LoadPSSnapIns(Collection`1 mshsnapinInfos, PSConsoleLoadException& warning)\n   at System.Management.Automation.Runspaces.RunspaceConfigForSingleShell.LoadConsole(PSConsoleLoadException& warning)\n   at System.Management.Automation.Runspaces.RunspaceConfigForSingleShell.CreateDefaultConfiguration()\n   at System.Management.Automation.Runspaces.RunspaceConfiguration.Create()\n   at System.Management.Automation.Runspaces.RunspaceFactory.CreateRunspace(PSHost host)\n   at System.Management.Automation.Runspaces.RunspaceFactory.CreateRunspace()\n   at System.Management.Automation.PowerShell.Worker.CreateRunspaceIfNeededAndDoWork(Runspace rsToUse, Boolean isSync)\n   at System.Management.Automation.PowerShell.CoreInvokeHelper[TInput,TOutput](PSDataCollection`1 input, PSDataCollection`1 output, PSInvocationSettings settings)\n   at System.Management.Automation.PowerShell.CoreInvoke[TInput,TOutput](PSDataCollection`1 input, PSDataCollection`1 output, PSInvocationSettings settings)\n   at System.Management.Automation.PowerShell.CoreInvoke[TOutput](IEnumerable input, PSDataCollection`1 output, PSInvocationSettings settings)\n   at System.Management.Automation.PowerShell.Invoke(IEnumerable input, PSInvocationSettings settings)\n   at System.Management.Automation.PowerShell.Invoke()\n   at Program.Main(String[] args)\n```\n## Environment data\n\n<!-- provide the output of $PSVersionTable -->\n\n``` powershell\n> $PSVersionTable\nName                           Value                                                                                                        \n----                           -----                                                                                                        \nPSVersion                      6.0.0-alpha                                                                                                  \nPSEdition                      Core                                                                                                         \nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}                                                                                      \nBuildVersion                   3.0.0.0                                                                                                      \nGitCommitId                    v6.0.0-alpha.10                                                                                              \nCLRVersion                                                                                                                                  \nWSManStackVersion              3.0                                                                                                          \nPSRemotingProtocolVersion      2.3                                                                                                          \nSerializationVersion           1.1.0.1                                                                                                      \n\n```\n",
  "closed_at": "2017-03-25T00:53:25Z",
  "comments": [
    {
      "author": "daviwil",
      "author_association": "CONTRIBUTOR",
      "body": "Hosting PowerShell in your own process is more difficult due to the necessity of loading PowerShell's AssemblyLoadContext before CoreCLR's, or at least this is the impression I came away with after talking to @daxian-dbw.  Dongbo should be able to tell you more about it.\n",
      "created_at": "2016-09-17T17:05:55Z",
      "updated_at": "2016-09-17T17:05:55Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "My understanding is it doesn't have to be **before** loading coreclr. In https://github.com/PowerShell/PowerShell/blob/master/src/powershell/Program.cs we are doing exactly that: initializing ALC in the managed code.\n\nI included a line\n\n```\nPowerShellAssemblyLoadContextInitializer.SetPowerShellAssemblyLoadContext(AppContext.BaseDirectory);\n```\n\nwhich I took from our XUnit tests, but it may need some alterations.\nActually, that's indeed could be the problem with windows version (improper ALC init).\n",
      "created_at": "2016-09-17T17:49:44Z",
      "updated_at": "2016-09-17T17:51:17Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "For a CoreCLR application to host powershell, if the powershell assemblies are in its TPA list, then it has to use one of the `Initialize*` method to call into the actual entry point:\n\n```\nPowerShellAssemblyLoadContextInitializer.InitializeAndLoadEntryAssembly(string basePaths, AssemblyName entryAssemblyName);\nPowerShellAssemblyLoadContextInitializer.InitializeAndCallEntryMethod(string basePaths, AssemblyName entryAssemblyName, string entryTypeName, string entryMethodName, object[] args);\n```\n\nYou can find an example at https://github.com/PowerShell/PowerShell/blob/master/src/powershell/Program.cs#L27\n\n`SetPowerShellAssemblyLoadContext` is for CoreCLR applications that don't have powershell assemblies in their TPA list, which are usually native CoreCLR hosts. `Initialize*` APIs are for CoreCLR applications that have powershell assemblies in their TPA list, which are usually managed hosts that leverage dotnet.exe.\n",
      "created_at": "2016-09-19T17:33:23Z",
      "updated_at": "2016-09-19T17:33:23Z"
    },
    {
      "author": "erwinwildenburg",
      "author_association": "NONE",
      "body": "If I add the following code it works:\n`PowerShellAssemblyLoadContextInitializer.SetPowerShellAssemblyLoadContext(\"C:\\\\Program Files\\\\PowerShell\\\\6.0.0.10\");`\n\nSeems like the required dll's are not being copied to the bin folder.\n\nFor example:\n\n```\nPowerShellAssemblyLoadContextInitializer.SetPowerShellAssemblyLoadContext(\"C:\\\\Program Files\\\\PowerShell\\\\6.0.0.10\");\n\nusing (PowerShell ps = PowerShell.Create())\n{\n    ps.AddScript(\"Write-Host 'It works!'\");\n    var result = ps.Invoke()[0];\n        Console.WriteLine(result.toString());\n}\n```\n\n![capture](https://cloud.githubusercontent.com/assets/3199611/18928152/30b5ebe2-85bf-11e6-959b-c09ccaaf7ffc.PNG)\n",
      "created_at": "2016-09-28T19:04:52Z",
      "updated_at": "2016-09-28T19:04:52Z"
    },
    {
      "author": "iztokp",
      "author_association": "NONE",
      "body": "Any hints on how to make this work on Linux (CentOS)?",
      "created_at": "2017-01-19T14:27:32Z",
      "updated_at": "2017-01-19T14:27:32Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "A documentation about hosting powershell core is added: https://github.com/PowerShell/PowerShell/tree/master/docs/host-powershell\r\n\r\n@iztokp Unfortunately, as [discussed here](https://github.com/PowerShell/PowerShell/pull/3409#issuecomment-288934991), all powershell NuGet packages that have been published so far only contain powershell assemblies built specifically for Windows. We need to publish NuGet packages that contain both Windows and Unix assemblies (#3417 is opened to track this), but `dotnet pack` doesn't seem to support that.",
      "created_at": "2017-03-25T02:48:14Z",
      "updated_at": "2017-03-25T02:48:14Z"
    }
  ],
  "created_at": "2016-09-17T16:41:29Z",
  "labels": [
    "Area-Maintainers-Build",
    "Issue-Meta"
  ],
  "number": 2291,
  "state": "closed",
  "title": "Provide a way to host PowerShell in a CoreCLR application",
  "updated_at": "2017-03-25T02:48:14Z"
}