{
  "_url": "https://github.com/PowerShell/PowerShell/issues/13489",
  "author": "mklement0",
  "body": "Follow-up from https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-676617510.\r\nRelated: #14587 #13488, #6360, #6291\r\n\r\nIn short: Using  $`(...)`, the subexpression operator as (a non-initial) part of an argument normally causes the output from that expression to be stringified and become part of the same argument (that this only applies to _non-initial_ use of `$(...)` may be surprising - see #6467).\r\n\r\nE.g., `Write-Output hi/$('there')` yields a single string argument with verbatim content `hi/there`.\r\n\r\nUnexpectedly, this is _not_ the case if the start of the argument looks something like `-foo:`, i.e. _looks like_ a named PowerShell argument, but _isn't actually one_  - either because the command being invoked is a PowerShell command that doesn't declare a `-foo` parameter or because an external program is being called.\r\n\r\nIn that event, the output from the `$(...)` subexpression is passed as _separate argument(s)_.\r\n\r\nIn the case of calling an external programs, the same symptom as in #13488 then surfaces: the _first_ object output by `$(...)` - only - _is_ attached to the prefix.\r\n\r\n**_Update_: The problem occurs not just with `$(...)`, but also with simple _variable_ references, e.g., `Write-Output -hi:$HOME`, which may make this just a variation of #6360 .\r\nIn short: The argument is then _not_ treated as a single, implicit _expandable string_, even though it should**.\r\nWhen calling external programs, the problem is obscured due to _scalars_ becoming part of the same argument, but in the case of collections only the _first_ element, as in #13488: `printf '%s\\n' -hi:$HOME` (OK) vs. `$arr='a', 'b'; printf '%s\\n' -hi:$a` (broken).\r\n\r\n## Steps to reproduce\r\n\r\n```powershell\r\n# OK: Argument doesn't look like a named PowerShell argument, so it is treated implicitly like an\r\n#        an expandable string (the array output by $(...) is stringified and attached to the 'hi:' prefix).\r\nWrite-Output hi:$('there', '!') | Should -BeExactly 'hi:there !'\r\n\r\n# BROKEN, due to the argument looking like a named argument - the $(...) output is passed separately.\r\nWrite-Output -hi:$('there', '!') | Should -BeExactly '-hi:there !'\r\n\r\n# Unix example.\r\n# BROKEN for external programs too, with a different symptom: the *first* object output by $(...) - only - *is* attached.\r\nprintf '%s\\n' -hi:$('there', '!') | Should -BeExactly '-hi:there !'\r\n```\r\n\r\n## Expected behavior\r\n\r\nThe tests should pass.\r\n\r\n## Actual behavior\r\n\r\nThe second and third tests fail:\r\n\r\nTest 2:\r\n\r\n```none\r\nExpected exactly '-hi:there !', but got @('-hi:', @('there', '!')).\r\n```\r\n\r\nThat is, the `$(...)` output was passed as a separate (array) argument.\r\n\r\nTest 3:\r\n\r\n```none\r\nExpected exactly '-hi:there !', but got @('-hi:there', '!').\r\n```\r\n\r\nThat is, the *first* `$(...)` output object - only - was directly attached to `-hi:`, with the subsequent one unexpectedly passed as a separate argument.\r\n\r\n## Environment data\r\n\r\n```none\r\nPowerShell Core 7.1.0-preview.6\r\n```\r\n",
  "closed_at": null,
  "comments": [],
  "created_at": "2020-08-20T17:31:29Z",
  "labels": [
    "Issue-Question",
    "WG-Engine"
  ],
  "number": 13489,
  "state": "open",
  "title": "Parameter parsing/passing: arguments that look like named PowerShell arguments unexpectedly treat an embedded subexpression or variable reference as a separate argument",
  "updated_at": "2021-01-10T03:11:30Z"
}