{
  "_url": "https://github.com/PowerShell/PowerShell/issues/10201",
  "author": "MarioSchwalbe",
  "body": "Out of curiosity, is there any compelling reason why PowerShell considers empty hashes to be true unlike empty containers (strings, arrays) which are usually false.\r\n\r\n# Steps to reproduce\r\n```powershell\r\nPS> [bool]''\r\nFalse\r\nPS> [bool]@()\r\nFalse\r\nPS> [bool]@{}\r\nTrue\r\n```\r\n\r\n# Expected behavior\r\n\r\nIn programming languages supporting implicit conversion to bool, empty containers usually evaluate false:\r\n\r\n```powershell\r\nPS> [bool]@{}\r\nFalse\r\n```\r\n\r\n# Environment data\r\n\r\nPowerShell 5/6/7 on any supported platform.\r\n",
  "closed_at": "2019-10-02T12:46:13Z",
  "comments": [
    {
      "author": "msftrncs",
      "author_association": "CONTRIBUTOR",
      "body": "Probably for the same reason as these either work or don't:\r\n\r\n```PowerShell\r\n@() | get-member\r\n@{} | get-member\r\n```\r\nEven an empty hashtable isn't empty.  Unlike the array object, it can be added to after it was created (using Add Method), so even though the 'table' is empty, the object itself is not empty.\r\n\r\nNow, I am not saying that this is the right behavior, but I suspect it is.",
      "created_at": "2019-07-24T16:37:06Z",
      "updated_at": "2019-07-24T16:37:06Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Bit of a different issue, really. The issue there @msftrncs is that by design the pipeline enumerates arrays. That's its entire job. If you pass it an empty array, there's nothing inside for it to enumerate, so it passes nothing along. \r\n\r\nThe issue at hand here is the different treatment of `empty array` vs `empty hashtable`, and in a more general sense for those accustomed to C#'s interfaces, probably deals with the difference between an empty `IList` and an empty `ICollection`.\r\n\r\nFor example, a generic `List<T>` object, which also implements `IList`, and is empty (as it has been newly created):\r\n\r\n```ps\r\nPS> [bool][System.Collections.Generic.List[string]]::new()\r\n```\r\n\r\nI can definitely see the argument for treating all collection types equally. If I recall correctly, we should be able to modify the logic such that it not only checks `IList` items for their length or count, but it also checks `ICollection` items (which is, from memory, implemented by _both_ dictionary/hashtable and list/array types, so would cover a **vast** majority of the bases) for their `Count` to see if it should return true or false.\r\n\r\nWhat's being displayed here is the \"fallback\" behaviour in the boolean conversion paths; if an object doesn't have special handling and is a reference-type object, the conversion currently _always_ returns true. `IList` collections are currently specifically targeted as they are one of the most commonly used, if I recall correctly.\r\n\r\n/cc @SteveL-MSFT does this seem like a worthwhile change, or at least one that would have code behave in common-sense ways?\r\n\r\nIt would, of course, be a breaking change in behaviour, but I feel it makes sense, and it seems unlikely to me that people would rely on `[bool]@{}` evaluating to true in any real-world scenarios.",
      "created_at": "2019-07-24T21:56:09Z",
      "updated_at": "2019-07-24T21:56:33Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "@vexx32 Changing the behaviour of hashtables in the pipeline would be a _huge_ breaking change. PowerShell has treated hashtables as \"structs\" from the very beginning. \r\n\r\n@MarioSchwalbe \r\nAs to why an empty hashtable is not treated as false,  I'm sorry - I just don't remember - it was too long ago. But - I can theorize that, because we treated hashtables as structs, we probably don't consider hashtables as false. (@JamesWTruher  or @khansen00  might remember more.)",
      "created_at": "2019-07-24T22:22:33Z",
      "updated_at": "2019-07-24T22:22:33Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "I agree that this is too big a breaking change.",
      "created_at": "2019-07-25T00:41:53Z",
      "updated_at": "2019-07-25T00:41:53Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "If hashtables were being treated as structs, wouldn't the behaviour be working as @MarioSchwalbe (and myself) would consider logical? Empty hashtable -> false? \r\n\r\nI doubt this was a deliberate decision -- all reference types evaluate to true when cast to boolean unless some type conversion has been found or special-cased in the casting logic. It may be too big to change now (seems a weird thing to be considered a big change, but my tired mind has its own ideas of a lot of things \ud83d\ude09) but I'd be curious if anyone can demonstrate a reason it should be the current way nonetheless ^^",
      "created_at": "2019-07-25T04:24:20Z",
      "updated_at": "2019-07-25T04:26:36Z"
    },
    {
      "author": "MarioSchwalbe",
      "author_association": "NONE",
      "body": "To clarify the question: I wrote a script using implicit conversion like that:\r\n```powershell\r\nif ($hash) {\r\n    # use it\r\n}\r\n```\r\nAnd it executes the code even though I expected it not to.\r\n\r\n@vexx32:\r\nI can't really see the special case for enumeration/pipelining. An empty hash is just an object with no elements just like an empty array, so enumeration wouldn't enumerate anything here as well.\r\n\r\n> @msftrncs: Even an empty hashtable isn't empty. Unlike the array object, it can be added to after it was created (using Add Method), so even though the 'table' is empty, the object itself is not empty.\r\n\r\nI read that multiple times, but have to confess, I don't really understand that statement. Is this the internal Powershell implementation? Normally, an empty collection *is* empty (stores nothing). But it's a non-null reference (*has* members). Are you mixing these two concepts?\r\n\r\nIndeed, Powershell seems to be very interesting here:\r\n```powershell\r\n# Empty objects are objects (non-null references):\r\nPS> $l = @()\r\nPS> $l.ToString()\r\nSystem.Object[]\r\nPS> $l.Count\r\n0\r\n\r\nPS> $h = @{}\r\nPS> $h.ToString()\r\nSystem.Collections.Hashtable\r\nPS> $h.Count\r\n0\r\n\r\n# Display members:\r\nPS> $l | Get-Member\r\nGet-Member : You must specify an object for the Get-Member cmdlet.\r\nAt line:1 char:6\r\n+ $l | Get-Member\r\n+      ~~~~~~~~~~\r\n+ CategoryInfo          : CloseError: (:) [Get-Member], InvalidOperationException\r\n+ FullyQualifiedErrorId : NoObjectInGetMember,Microsoft.PowerShell.Commands.GetMemberCommand\r\n\r\nPS> $h | Get-Member\r\n   TypeName: System.Collections.Hashtable\r\nName              MemberType            Definition\r\n----              ----------            ----------\r\nAdd               Method                void Add(System.Object key, System.Object value), void IDictionary.Add(System.Object key, System.O\u2026\r\nClear             Method                void Clear(), void IDictionary.Clear()\r\nClone             Method                System.Object Clone(), System.Object ICloneable.Clone()\r\nContains          Method                bool Contains(System.Object key), bool IDictionary.Contains(System.Object key)\r\nContainsKey       Method                bool ContainsKey(System.Object key)\r\nContainsValue     Method                bool ContainsValue(System.Object value)\r\nCopyTo            Method                void CopyTo(array array, int arrayIndex), void ICollection.CopyTo(array array, int index)\r\nEquals            Method                bool Equals(System.Object obj)\r\nGetEnumerator     Method                System.Collections.IDictionaryEnumerator GetEnumerator(), System.Collections.IDictionaryEnumerator\u2026\r\nGetHashCode       Method                int GetHashCode()\r\nGetObjectData     Method                void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serializati\u2026\r\nGetType           Method                type GetType()\r\nOnDeserialization Method                void OnDeserialization(System.Object sender), void IDeserializationCallback.OnDeserialization(Syst\u2026\r\nRemove            Method                void Remove(System.Object key), void IDictionary.Remove(System.Object key)\r\nToString          Method                string ToString()\r\nItem              ParameterizedProperty System.Object Item(System.Object key) {get;set;}\r\nCount             Property              int Count {get;}\r\nIsFixedSize       Property              bool IsFixedSize {get;}\r\nIsReadOnly        Property              bool IsReadOnly {get;}\r\nIsSynchronized    Property              bool IsSynchronized {get;}\r\nKeys              Property              System.Collections.ICollection Keys {get;}\r\nSyncRoot          Property              System.Object SyncRoot {get;}\r\nValues            Property              System.Collections.ICollection Values {get;}\r\n\r\nPS> $l = @(1)\r\nPS> $l | Get-Member\r\n\r\n   TypeName: System.Int32\r\nName        MemberType Definition\r\n----        ---------- ----------\r\nCompareTo   Method     int CompareTo(System.Object value), int CompareTo(int value), int IComparable.CompareTo(System.Object obj), int ICo\u2026\r\nEquals      Method     bool Equals(System.Object obj), bool Equals(int obj), bool IEquatable[int].Equals(int other)\r\nGetHashCode Method     int GetHashCode()\r\nGetType     Method     type GetType()\r\nGetTypeCode Method     System.TypeCode GetTypeCode(), System.TypeCode IConvertible.GetTypeCode()\r\nToBoolean   Method     bool IConvertible.ToBoolean(System.IFormatProvider provider)\r\nToByte      Method     byte IConvertible.ToByte(System.IFormatProvider provider)\r\nToChar      Method     char IConvertible.ToChar(System.IFormatProvider provider)\r\nToDateTime  Method     datetime IConvertible.ToDateTime(System.IFormatProvider provider)\r\nToDecimal   Method     decimal IConvertible.ToDecimal(System.IFormatProvider provider)\r\nToDouble    Method     double IConvertible.ToDouble(System.IFormatProvider provider)\r\nToInt16     Method     short IConvertible.ToInt16(System.IFormatProvider provider)\r\nToInt32     Method     int IConvertible.ToInt32(System.IFormatProvider provider)\r\nToInt64     Method     long IConvertible.ToInt64(System.IFormatProvider provider)\r\nToSByte     Method     sbyte IConvertible.ToSByte(System.IFormatProvider provider)\r\nToSingle    Method     float IConvertible.ToSingle(System.IFormatProvider provider)\r\nToString    Method     string ToString(), string ToString(string format), string ToString(System.IFormatProvider provider), string ToStrin\u2026\r\nToType      Method     System.Object IConvertible.ToType(type conversionType, System.IFormatProvider provider)\r\nToUInt16    Method     ushort IConvertible.ToUInt16(System.IFormatProvider provider)\r\nToUInt32    Method     uint IConvertible.ToUInt32(System.IFormatProvider provider)\r\nToUInt64    Method     ulong IConvertible.ToUInt64(System.IFormatProvider provider)\r\nTryFormat   Method     bool TryFormat(System.Span[char] destination, [ref] int charsWritten, System.ReadOnlySpan[char] format, System.IFor\u2026\r\n```\r\nWhat is going on here? I cannot enumerate the members of an empty array? But at the same time access properties/call methods? According to the [C# documentation](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/arrays-as-objects), arrays are indeed full objects (unlike C) and can have members.\r\n\r\nI come from C++/Python and in those programming languages, empty collections (and strings) are:\r\n1. Non-null references to objects storing the state `empty` and can be treated like regular objects.\r\n2. Can be iterated with no exceptions, but don't enumerate anything, i.e., it is equivalent to a loop whose initial condition was false.\r\n3. Boolean conversion (Python only) is based upon the number of elements, not its reference.\r\n4. `None`/`nullptr` references (pointers in C++) are false.\r\n\r\nTo my understanding, both of them are (partially) wrong:\r\n- Empty arrays should enumerate members, and\r\n- Empty hashes should evaluate false.",
      "created_at": "2019-07-26T09:54:57Z",
      "updated_at": "2019-07-26T09:56:15Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Yeah, the pipeline enumerates the array. If it didn't you'd not be able to write `1, 2, 3 | ForEarh-Object {$_ + 3}` and get the results you currently do. It doesn't currently enumerate dictionary types at all, so it has no trouble seeing those. Get-Member doesn't \"see\" flat lists and arrays when piping. You need to use `Geh-Member -InputObject @()` to work around that.",
      "created_at": "2019-07-26T10:24:22Z",
      "updated_at": "2019-07-26T10:25:13Z"
    },
    {
      "author": "MarioSchwalbe",
      "author_association": "NONE",
      "body": "Alright:\r\n```powershell\r\n[1] PS> $s = 'text'\r\n[1] PS> $n = 0; $t | foreach { $n++ }; $n\r\n1\r\n[2] PS> $l = @(1, 2, 3)\r\n[2] PS> $n = 0; $l | foreach { $n++ }; $n\r\n3\r\n[3] PS> $h = @{X=1; Y=2; Z=3}\r\n[3] PS> $n = 0; $h | foreach { $n++ }; $n\r\n1\r\n[4] PS> $n = 0; foreach ($e in $h) { $n++ }; $n\r\n1\r\n[5] PS> $n = 0; foreach ($e in $h.GetEnumerator()) { $n++ }; $n\r\n3\r\n```\r\nGot it:\r\n- A pipe plus `foreach` implicitly converts scalar types (non-list-like) to a list with 1 element and iterates it.\r\n- Lists remain lists.\r\n- Other collections such as hashes are considered scalar here.\r\n\r\nMaybe case 3 should enumerate the hashes' keys instead. And also case 4. Would be consistent with the majority of programming languages. Finally, `@() | Get-Member` considers the elements' types (not the array) and errors out if there are no elements. Could be the same with hashes. This is still more confusing than necessary.\r\n\r\n... And it doesn't explain the semantics of boolean conversions.",
      "created_at": "2019-07-26T11:15:45Z",
      "updated_at": "2019-07-26T11:15:45Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> If hashtables were being treated as structs, wouldn't the behaviour be working as @MarioSchwalbe (and myself) would consider logical? Empty hashtable -> false?\r\n\r\nCurrent behavior makes sense to me with that mindset:\r\n\r\n```powershell\r\nAdd-Type -TypeDefinition 'public struct Test {}' -IgnoreWarnings\r\n[bool][test]::new()\r\n# returns True\r\n```",
      "created_at": "2019-07-26T11:47:12Z",
      "updated_at": "2019-07-26T11:47:12Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Huh, interesting. Didn't know PS treated structs that way.\r\n\r\n\ud83e\udd14 \r\n\r\nI dunno there tbh. A hashtable in my mind is a collection. A struct is a single instance/glob of data. I'd venture to say I can't really follow where that mindset is coming from. Structs can't change their shape overall, hashtables.... kind of can? At least in as much of the same way as any list-type collection can, anyway.",
      "created_at": "2019-07-26T13:49:20Z",
      "updated_at": "2019-07-26T13:49:20Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> Huh, interesting. Didn't know PS treated structs that way.\r\n> \r\n> \ud83e\udd14\r\n> \r\n> I dunno there tbh. A hashtable in my mind is a collection. A struct is a single instance/glob of data. I'd venture to say I can't really follow where that mindset is coming from. Structs can't change their shape overall, hashtables.... kind of can? At least in as much of the same way as any list-type collection can, anyway.\r\n\r\nThink of it less like a struct and more like a `PSObject`, I think that's the general idea.  `Hashtable`s in PS are treated less like a dictionary/map and more like an anonymous object.\r\n\r\nTo be clear I'm not saying that I agree with treating them that way, especially when we already have `PSObject`.  I would guess that that decision was made very early on, perhaps before `PSObject` was the obvious choice for that type of thing.",
      "created_at": "2019-07-26T14:13:15Z",
      "updated_at": "2019-07-26T14:13:15Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Yeah I guess I can see it in that way, perhaps... But as you say, not sure it still makes sense to continue down that road. \ud83d\ude42 ",
      "created_at": "2019-07-26T14:15:53Z",
      "updated_at": "2019-07-26T14:15:53Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> Yeah I guess I can see it in that way, perhaps... But as you say, not sure it still makes sense to continue down that road. \ud83d\ude42\r\n\r\nImo the benefit seems very small compared to the pretty overwhelming cost.  It wouldn't make sense to *just* change truthy behavior, you'd also have to make it enumerate across the pipeline for consistency.  That'd be a hefty breaking change.",
      "created_at": "2019-07-26T14:20:05Z",
      "updated_at": "2019-07-26T14:20:05Z"
    },
    {
      "author": "HumanEquivalentUnit",
      "author_association": "CONTRIBUTOR",
      "body": "> Maybe case 3 should enumerate the hashes' keys instead.  Would be consistent with the majority of programming languages. \r\n\r\nThe majority of programming languages don't have pipelines in the same way PowerShell does. It's really arrays which are the special case, they are easy to take apart *and* easy to put back together, and useful to break apart to help stream things down the pipeline: \r\n\r\n    $x = 1,2,3    # $x is an array\r\n    $y = $x | foreach-object { $_ }    # $y is an array\r\n\r\nPretty much any other collection is easy to get the elements out, but harder or impossible to put back together (trees, etc). If hashtables unrolled into their keys you would risk weird behaviour trying to return a hashtable from a function and keep it in one piece:\r\n\r\n    function test {        @{ key1 = 10;  key2 = 20 }       }\r\n    \r\n    test | Another-Cmdlet\r\n    test | foreach-object { $_ } | Another-Cmdlet\r\n\r\nI suggest that you want the input to `Another-Cmdlet` to be a single hashtable, and the same in both situations. Receiving an unrolled array of hashtable keys with the values lost would be surprising, receiving an array of DictionaryEntries (keys and values) would mean you'd have to rebuild it into a hashtable again, and receiving different things in each instance depending on whether there was a loop involved somewhere previously would be surprising, annoying and hard work.\r\n\r\nPowerShell also does not unroll strings into characters, in the same way Python does.\r\n\r\n> Boolean conversion (Python only) is based upon the number of elements, not its reference.\r\n\r\nIt's first based on the [`object.__bool__(self)`](https://docs.python.org/3/reference/datamodel.html#object.__bool__) method; you can make a class which is iterable, is a sequence, has no length, but is still Truthy. What you say may hold for the builtin collections, but you can't be sure of it for every class which behaves like a collection.\r\n\r\nBack to boolean conversion in PS; I was surprised the first time I found this:\r\n\r\n```\r\nPS C:\\> [bool][int]0\r\nFalse\r\nPS C:\\> [bool][decimal]0\r\nFalse\r\nPS C:\\> [bool][bigint]0\r\nTrue\r\n```",
      "created_at": "2019-07-27T21:07:10Z",
      "updated_at": "2019-07-27T21:09:07Z"
    }
  ],
  "created_at": "2019-07-22T13:00:38Z",
  "labels": [
    "Issue-Question",
    "Resolution-By Design"
  ],
  "number": 10201,
  "state": "closed",
  "title": "Empty hashtable evaluates $true in boolean context",
  "updated_at": "2019-10-02T12:46:13Z"
}