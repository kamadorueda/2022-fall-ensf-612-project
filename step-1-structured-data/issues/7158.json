{
  "_url": "https://github.com/PowerShell/PowerShell/issues/7158",
  "author": "mklement0",
  "body": "This may well be by design, but it would be good to understand why - and document it.\r\n\r\nIf it isn't by design, we're looking at nontrivial changes to the parameter binder.\r\n\r\nWhile dynamic parameters can be bound _positionally_ in principle, they are not consulted if a _static_ parameter binds a given argument positionally, even if that binding fails due to a type mismatch or is less specific than what a dynamic parameter could offer.\r\n\r\nThis surfaces with advanced functions that support multiple parameters for positional use in a given position that only differ by type, with at least one of them defined dynamically.\r\n\r\n```powershell\r\nusing namespace System.Management.Automation\r\n\r\nfunction foo {\r\n  [CmdletBinding(PositionalBinding=$False, DefaultParameterSetName='Default')]\r\n  param(\r\n    [Parameter(ParameterSetName='Default', Position=0)]\r\n    [int] $Foo \r\n  )\r\n\r\n  dynamicparam {\r\n    $paramAttr = [ParameterAttribute] @{\r\n      ParameterSetName = 'int'\r\n      Position = 0\r\n    }    \r\n    $paramDict = [RuntimeDefinedParameterDictionary]::new()\r\n    $paramDict.Add('Bar',[RuntimeDefinedParameter]::new('Bar', [string], $paramAttr))\r\n    return $paramDict\r\n  }\r\n\r\n  process {\r\n    @\"\r\nFoo: $Foo\r\nBar: $($PSBoundParameters.Bar)\r\n\"@\r\n  }\r\n}\r\n\r\nfoo one\r\n```\r\n\r\nNote: The intent behind the parameter design is for `foo one` to bind to `-Bar`, and `foo 1` to bind to `-Foo`, simply based on the argument types.\r\n\r\nThe above yields:\r\n\r\n```none\r\nfoo: Cannot process argument transformation on parameter 'Foo'. Cannot convert value \"one\" to type \"System.Int32\"\r\n```\r\n\r\n`foo one` should ideally bind positionally to dynamic parameter `-Bar` - based on the matching `[string]` type - but it seems that the dynamic `-Bar` parameter was never even consulted for positional binding.\r\n\r\nInstead, an attempt was made to bind `-Foo`, even though that attempt cannot succeed, given that `-Foo` is `[int]`-typed.\r\n\r\nIn short: if at least one static parameter binds positionally in principle, binding is only attempted among the static parameters, even if the argument cannot bind due to its type or, if it can, even if the non-consulted dynamic parameters offer a more specific type match.\r\n\r\nNote:\r\n\r\n* If you remove `Position=0` from `-Foo`, positional binding to `-Bar` works.\r\n\r\n* If you defined both `-Foo` and `-Bar` as _static_ parameters, things would work too; that is, in the absence of a _static_ parameter that binds at that position, positionally binding via dynamic parameters works.\r\n\r\n* Using the parameter name explicitly _always_ works (`foo -Bar one`)\r\n\r\n\r\nEnvironment data\r\n----------------\r\n\r\nWritten as of:\r\n\r\n```powershell\r\nPowerShell Core v6.1.0-preview.3\r\n```\r\n",
  "closed_at": null,
  "comments": [],
  "created_at": "2018-06-24T17:31:03Z",
  "labels": [
    "Issue-Question",
    "WG-Engine"
  ],
  "number": 7158,
  "state": "open",
  "title": "Is the inability to use dynamic parameters positionally if static parameters bind in the same position by design?",
  "updated_at": "2018-06-24T20:38:29Z"
}