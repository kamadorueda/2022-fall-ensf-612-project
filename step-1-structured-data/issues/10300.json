{
  "_url": "https://github.com/PowerShell/PowerShell/issues/10300",
  "author": "iSazonov",
  "body": "<!-- Anything that looks like this is a comment and can't be seen after the Pull Request is created. -->\r\n\r\n# PR Summary\r\n\r\nFix #9957\r\nFix #9921\r\nFix #7082\r\nFix #6850\r\nFix #10620\r\n\r\nFor reference #9845\r\n\r\nThe fix was approved by PowerShell Committee.\r\nThe fix is that now we do not change PSModulePath environment variable. Now we only read it and add to a module path cache. Also we add Powershell standard paths in the cache.\r\n\r\nBecause now we don't change PSModulePath environment variable we have no needs to manipulate strings and the module path cache is List\\<string>.\r\n\r\nThere was discovered some bugs. I hope they is related only tests.\r\n- We use `string.Contains()` but correct way is to use PathContainsSubstring()\r\nhttps://github.com/PowerShell/PowerShell/blob/17fb524adb85566aa5cb6041db279905c2700e6d/src/System.Management.Automation/engine/Modules/ModuleIntrinsics.cs#L1357-L1363\r\nAs result the system path was not added in tests because we added a module path like c:\\tmp\\root\\modulename then we were tried to add c:\\tmp\\root (come from test hook) but string.Contains() returns true.\r\n\r\n- We don't removed a root module in CompatiblePSEditions.Module.Tests.ps1 \r\nhttps://github.com/PowerShell/PowerShell/blob/17fb524adb85566aa5cb6041db279905c2700e6d/test/powershell/Modules/Microsoft.PowerShell.Core/CompatiblePSEditions.Module.Tests.ps1#L735-L738\r\nAs result some tests below failed after the PR fix. I hope it is only test issue - please review in depth.\r\n\r\n- Perhaps it is not bug but we need a conclusion. If we add a path to module in PSModulePath and then add a root path from the module path like c:\\tmp\\root\\modulename and c:\\tmp\\root - Get-Module -Listavailable -All returns the module twice. (No regression - Windows PowerShell works the same way.)\r\n\r\nThe PR fix doesn't remove path to PSHome/Module if 7.0 starts from 6.0:\r\n![image](https://user-images.githubusercontent.com/22290914/62530725-876ac680-b85a-11e9-8132-614542d8c9d7.png)\r\nI think it makes no sense to remove the path because 6.0 will deprecated (EOL) soon.\r\n\r\n## PR Context\r\n\r\nSee #9957\r\n\r\n## PR Checklist\r\n\r\n- [x] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [x] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` or `[ WIP ]` to the beginning of the title (the `WIP` bot will keep its status check at `Pending` while the prefix is present) and remove the prefix when the PR is ready.\r\n- **[Breaking changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)**\r\n    - [ ] None\r\n    - **OR**\r\n    - [ ] [Experimental feature(s) needed](https://github.com/MicrosoftDocs/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/About/about_Experimental_Features.md)\r\n        - [ ] Experimental feature name(s): <!-- Experimental feature name(s) here -->\r\n- **User-facing changes**\r\n    - [ ] Not Applicable\r\n    - **OR**\r\n    - [x] [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n- **Testing - New and feature**\r\n    - [ ] N/A or can only be tested interactively\r\n    - **OR**\r\n    - [x] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n- **Tooling**\r\n    - [ ] I have considered the user experience from a tooling perspective and don't believe tooling will be impacted.\r\n    - **OR**\r\n    - [ ] I have considered the user experience from a tooling perspective and enumerated concerns in the summary. This may include:\r\n        - Impact on [PowerShell Editor Services](https://github.com/PowerShell/PowerShellEditorServices) which is used in the [PowerShell extension](https://github.com/PowerShell/vscode-powershell) for VSCode (which runs in a different PS Host).\r\n        - Impact on Completions (both in the console and in editors) - one of PowerShell's most powerful features.\r\n        - Impact on [PSScriptAnalyzer](https://github.com/PowerShell/PSScriptAnalyzer) (which provides linting & formatting in the editor extensions).\r\n        - Impact on [EditorSyntax](https://github.com/PowerShell/EditorSyntax) (which provides syntax highlighting with in VSCode, GitHub, and many other editors).\r\n",
  "closed_at": "2019-11-22T03:47:37Z",
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Current issues with test:\r\n- DSC tests failed on Linux. It is not clear why we run its only on Linux. /cc @amitsara\r\n- Remove-Module test failed on Windows - really an issue is with Get-Module, it returns 2 values instead of 1. It is very amazing because Get-Module tests was passed. Locally the tests is passed too.\r\n- Some HelpSystem tests failed on Windows. Don't know why and how fix.\r\n\r\n@SteveL-MSFT @daxian-dbw @rjmholt @adityapatwardhan I hope you help.\r\n\r\n@mklement0 @KirkMunro @Jaykul for information.",
      "created_at": "2019-08-06T10:29:09Z",
      "updated_at": "2019-08-06T10:29:09Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": ">  It is very amazing because Get-Module tests was passed. Locally the tests is passed too.\r\n\r\nThat sounds like we have different expectations in different tests. Ideally we should fix that.\r\n\r\n> I think it makes no sense to remove the path because 6.0 will deprecated (EOL) soon.\r\n\r\nThe `powershell/6/` module path would also be for 6.1 or 6.2 though -- but I might have misunderstood what you're saying here. Could you clarify? (Also worth noting that `deprecated` =/= `EOL`; the first means it's not recommended for use, but continues to be supported, while the second means there's no support).\r\n\r\nWould you be able to describe the nature of this change @iSazonov?  I understand the issues it addresses, and got some information from the description, but would you be able to write a paragraph at the top of the description describing:\r\n- what specific behaviours this changes\r\n    - specifically, not just what is fixed, but what the new behaviour is, for each fixed item\r\n- any implementation details that are important",
      "created_at": "2019-08-07T20:40:54Z",
      "updated_at": "2019-08-07T20:40:54Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> The powershell/6/ module path would also be for 6.1 or 6.2 though\r\n\r\nI meant all 6.\\*. After 7.0 release 6.* will be out of support soon - it is not LTS version. And I suggest don't clean up the specific 6.* module path. (But we could address this if needed in follow PR. The problem here is that an user could want to preserve the path)\r\n\r\n> Would you be able to describe the nature of this change\r\n\r\nThere is reworded PowerShell Committee conclusion in #9957 and original https://github.com/PowerShell/PowerShell-RFC/pull/133#issuecomment-467192489\r\nIn short PowerShel shouldn't change PSModule environment variable to exclude  impact on other PowerShell versions (side-by-side scenario). Now PowerShell creates internal module path cache and add there all the version and session specific paths and paths from PSModulePath in _right order_. The order is the same as previously - I don't change the logic.",
      "created_at": "2019-08-08T12:41:49Z",
      "updated_at": "2019-08-08T12:43:50Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "Trying to get ahead of our Committee meeting today. Given the complexity of this code, I'm not sure I can validate that it equals the Committee's conclusion on what we wanted to do with `PSModulePath`, but I'm trusting that it meets what we decided on.\r\n\r\nOn the question around whether it's okay for 6's PSHome to stay in the value when launching 7 from 6: I'm also with @iSazonov here. 6.2 is going to EOL 6 months after 7.0 GAs, and I don't expect many people to be launching 7 from 6. \r\n\r\nThat being said, I'd like whatever breakage we have in that scenario to not be catastrophic, and I don't see 7's PSHome being *added* to the PSModulePath in the screenshot you gave above. Obviously, this behavior isn't happening in the existing 7 preview build, but when I add 6's PSHome to my 7 preview PSModulePath, 7 appears to take precedence in autoloading, but I really just smoke tested it:\r\n\r\n```\r\nC:\\Users\\jaiello> $env:psmodulepath\r\nC:\\Users\\jaiello\\Documents\\PowerShell\\Modules;C:\\Program Files\\PowerShell\\Modules;c:\\program files\\powershell\\7-preview\\Modules;C:\\program files\\powershell\\6\\Modules;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules\r\nC:\\Users\\jaiello> $psversiontable\r\n\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.0.0-preview.2\r\nPSEdition                      Core\r\nGitCommitId                    7.0.0-preview.2\r\nOS                             Microsoft Windows 10.0.18959\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n\r\nI'm no expert on the module loading precedence, but it'd probably be a good idea if we revved up PSHome's 6.1.0.0 modules to 7.0.0.0 for our 7 release:\r\n\r\n```\r\n    Directory: C:\\program files\\powershell\\7-preview\\Modules\r\n\r\nModuleType Version    Name                                PSEdition ExportedCommands\r\n---------- -------    ----                                --------- ----------------\r\nManifest   6.1.0.0    CimCmdlets                          Core      {Get-CimAssociatedInstance, Get-CimClass, Get-CimInstance, Get-CimSession\u2026}\r\nManifest   1.2.3.0    Microsoft.PowerShell.Archive        Desk      {Compress-Archive, Expand-Archive}\r\nManifest   6.1.0.0    Microsoft.PowerShell.Diagnostics    Core      {Get-WinEvent, New-WinEvent}\r\nManifest   6.1.0.0    Microsoft.PowerShell.Host           Core      {Start-Transcript, Stop-Transcript}\r\nManifest   6.1.0.0    Microsoft.PowerShell.Management     Core      {Add-Content, Clear-Content, Clear-ItemProperty, Join-Path\u2026}\r\nManifest   6.1.0.0    Microsoft.PowerShell.Security       Core      {Get-Acl, Set-Acl, Get-PfxCertificate, Get-Credential\u2026}\r\nManifest   6.1.0.0    Microsoft.PowerShell.Utility        Core      {Export-Alias, Get-Alias, Import-Alias, New-Alias\u2026}\r\nManifest   6.1.0.0    Microsoft.WSMan.Management          Core      {Disable-WSManCredSSP, Enable-WSManCredSSP, Get-WSManCredSSP, Set-WSManQuickConfig\u2026}\r\nScript     1.4.3      PackageManagement                   Desk      {Find-Package, Get-Package, Get-PackageProvider, Get-PackageSource\u2026}\r\nScript     2.2        PowerShellGet                       Desk      {Find-Command, Find-DSCResource, Find-Module, Find-RoleCapability\u2026}\r\nScript     2.0        PSDesiredStateConfiguration         Core      {Configuration, Get-DscResource}\r\nScript     6.1.0.0    PSDiagnostics                       Core      {Disable-PSTrace, Disable-PSWSManCombinedTrace, Disable-WSManTrace, Enable-PSTrace\u2026}\r\nScript     2.0.0      PSReadLine                          Desk      {Get-PSReadLineKeyHandler, Set-PSReadLineKeyHandler, Remove-PSReadLineKeyHandler, Get-PSReadLineOption\u2026}\r\nBinary     2.0.1      ThreadJob                           Desk      Start-ThreadJob\r\n```\r\n\r\nIn any case, we'll discuss our meeting today. ",
      "created_at": "2019-08-14T20:19:14Z",
      "updated_at": "2019-08-14T20:19:14Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Rebased to get new Get-Module tests.",
      "created_at": "2019-08-15T04:49:52Z",
      "updated_at": "2019-08-15T04:49:52Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> In short PowerShel shouldn't change PSModule environment variable to exclude impact on other PowerShell versions (side-by-side scenario). Now PowerShell creates internal module path cache and add there all the version and session specific paths and paths from PSModulePath in right order. The order is the same as previously - I don't change the logic.\r\n\r\nIt's still not clear to me what this PR is changing, also not clear what is the ask from the committee.\r\nThe PR description and @iSazonov's reply comments suggests that the environment variable `PSModulePath` will no longer reflect the module paths to be probed by PowerShell after this PR. @iSazonov, is that the case?",
      "created_at": "2019-08-21T21:40:05Z",
      "updated_at": "2019-08-21T21:40:05Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> the environment variable PSModulePath will no longer reflect the module paths to be probed by PowerShell after this PR. @iSazonov, is that the case?\r\n\r\nNo, all logic preserved. The change is that pwsh read and modifies PSModulePath as before but not save modified PSModulePath back to environment variable, instead it saves this to internal static buffer.\r\n\r\n> also not clear what is the ask from the committee\r\n\r\nI don't know why @rjmholt ask. As mentioned in the PR description the change was approved by PowerShell Committee (links above). ",
      "created_at": "2019-08-22T08:22:53Z",
      "updated_at": "2019-08-22T08:25:55Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> but not save modified PSModulePath back to environment variable, instead it saves this to internal static buffer.\r\n\r\nThat means the environment variable `PSModulePath` doesn't reflect the truth anymore, and that's a **_huge breaking change_**. I don't think the issue description in #9957 has any intention for that.",
      "created_at": "2019-08-22T17:36:50Z",
      "updated_at": "2019-08-22T17:36:50Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> and that's a huge breaking change\r\n\r\nHence PS committee tag",
      "created_at": "2019-08-23T02:20:45Z",
      "updated_at": "2019-08-23T02:20:45Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Original PowerShell Committee message https://github.com/PowerShell/PowerShell-RFC/pull/133#issuecomment-467192489\r\n> When pwsh is started, we preserve the original $env:PSModulePath.\r\n\r\nI believe is a single way to revolve original issue after PowerShell Committee rejects PSModulePath6",
      "created_at": "2019-08-23T04:36:10Z",
      "updated_at": "2019-08-23T04:36:10Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "> Original PowerShell Committee message [PowerShell/PowerShell-RFC#133 (comment)](https://github.com/PowerShell/PowerShell-RFC/pull/133#issuecomment-467192489)\r\n> \r\n> > When pwsh is started, we preserve the original $env:PSModulePath.\r\n> \r\n> I believe is a single way to revolve original issue after PowerShell Committee rejects PSModulePath6\r\n\r\nIf I recall the original discussion, the intent is that \"preserve\" here means to \"cache\".  So that if powershell.exe or powershell_ise.exe is started we create the env var block with the cached PSModulePath.  The current behavior of PSModulePath needs to be retained for compatibility reasons.",
      "created_at": "2019-08-30T00:17:17Z",
      "updated_at": "2019-08-30T00:17:17Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> The current behavior of PSModulePath needs to be retained for compatibility reasons.\r\n\r\nWhat is the compatibility? What applications depends on PSModulePath? I haven't full understanding. If we run Windows PowerShell from pwsh the Windows PowerShell will create PSModulePath for itself. If we run ISE I am not sure but why do we need a compatibility if MSFT announced 5(?) years ago that the application deprecated? Original issue is just that we always have _insoluble_ conflicts if we modify PSModulePath in different PowerShell versions (for pwsh too).",
      "created_at": "2019-08-30T07:26:36Z",
      "updated_at": "2019-08-30T07:26:36Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> What is the compatibility? What applications depends on PSModulePath?\r\n\r\nA simple examples:\r\n- I as a user want to add another path to the module path, and I do `$env:PSModulePath += ;<mypath>`. Then I expect the modules in `<mypath>` to be discovered. With your change, will this continue to work?\r\n- I as a user want to know what module paths PowerShell is probing, and I will depend on `$env:PSModulePath` for that information. With your change, can I still trust `$env:PSModulePath` for that information?",
      "created_at": "2019-08-30T17:25:10Z",
      "updated_at": "2019-08-30T17:25:10Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> With your change, will this continue to work?\r\n\r\nYes, all current behavior is preserved and we re-read PSModulePath every time.\r\n\r\n> I as a user want to know what module paths PowerShell is probing, and I will depend on $env:PSModulePath for that information\r\n\r\nNow we don't modify PSModulePath. We need to document how PowerShell lookups modules if we still did not do this (again, we don't change the order). If users really need to see the order of the paths we could expose new PS read only variable like $PSModulePaths. Although I don\u2019t think it\u2019s necessary just like C# runtime is looking for assemblies - enough documentation.\r\n\r\nAlso before the change we modify PSModulePath with so complex logic (do we want add more complicity?!) that PSModulePath is not reliable source for information you ask, I mean that if user modify PSModulePath _how he wants_ then the user will be very wonder how PowerShell modifies PSModulePath.",
      "created_at": "2019-08-30T18:56:58Z",
      "updated_at": "2019-08-30T18:58:01Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> Now we don't modify PSModulePath. We need to document how PowerShell lookups modules ...\r\n\r\nDocumentation won't solve the problem. The user need a way to know what paths PowerShell is probing, and your proposed changes will break it.\r\n\r\n> Yes, all current behavior is preserved and we re-read PSModulePath every time.\r\n\r\nI don't think you can keep all current behavior by just re-reading `$env:PSModulePath`.\r\nFor example, when the user run `$env:PSModulePath = c:\\Modules`, how would you know the user's intention? Would it be `replace only the paths that are present in 'PSModulePath' with 'c:\\Modules'`? Or `literally, remove all existing module probing paths, including the internal ones that are not shown by 'PSModulePath', and just use 'c:\\Modules'`? There will be much more scenarios broken by your proposed changes.",
      "created_at": "2019-08-30T21:07:16Z",
      "updated_at": "2019-08-30T21:07:16Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "I've been trying to follow along with the conversation here and in the various issues related to this, and it's very confusing, to me at least.\r\n\r\nWould it be worth taking the time to reiterate the problem that needs to be resolved, provide a few specific examples that highlight that problem, while being mindful of (and providing examples of) existing `$PSModulePath` usage scenarios that need to remain supported while solving this problem?",
      "created_at": "2019-08-30T21:41:49Z",
      "updated_at": "2019-08-30T21:41:49Z"
    },
    {
      "author": "ctmcisco",
      "author_association": "NONE",
      "body": "I am seeing an issue where I would like to hard \"remove\" the PSModulePath location for my Windows Profile but regenerates after launching a new PowerShell Console. Is this something being worked on in PowerShell 7?",
      "created_at": "2019-09-04T13:38:17Z",
      "updated_at": "2019-09-04T13:38:17Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "> Would it be worth taking the time to reiterate the problem that needs to be resolved, provide a few specific examples that highlight that problem, while being mindful of (and providing examples of) existing $PSModulePath usage scenarios that need to remain supported while solving this problem?\r\n\r\nYeah, I think this would be super helpful. @iSazonov I know we made the definitive statement of what we wanted from the @PowerShell/powershell-committee side in that issue, but I'm not sure even we really know what's going on anymore. \r\n\r\n@rjmholt: @JamesWTruher mentioned that you've taken over some of the module stuff. Might you have some time to look at @iSazonov's build and do a before/after of the behavior?",
      "created_at": "2019-09-04T22:22:06Z",
      "updated_at": "2019-09-04T22:22:06Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": ">  but I'm not sure even we really know what's going on anymore.\r\n\r\nI saw two message (in RFC and issue) and saw some controversy. :-)\r\nNevertheless, I believe that I formulated the direction clearly:\r\n- we never fix all related SxS (side-by-side) issues while we modify the _process level_ PSModulePath\r\nReally there are a lot of SxS scenarios:\r\n- powershell -> pwsh. Then we could call powershell again or other pwsh version.\r\n- powershell -> SxS pwsh version. Then ...\r\n- pwsh -> powershell. Then ...\r\n- SxS pwsh version -> powershell. Then ...\r\n- SxS pwsh version -> pwsh. Then ...\r\n\r\nI'd reject ISE scenario because ISE is only Windows PowerShell part and it is deprecated.\r\nI'd reject @daxian-dbw scenario \"I as a user want to know what module paths PowerShell is probing\" because end user scenario is as simple as \"run install-module cmdlet and use installed module\", the end user have no need to know how PowerShell load modules. For advanced users  and developers we could document this or just expose new variable.\r\n\r\nNotice that here we consider only _process level_ PSModulePath env variable. (There could be a question about the OS level variable on Windows).\r\n\r\n",
      "created_at": "2019-09-05T07:22:24Z",
      "updated_at": "2019-09-05T07:22:24Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "I'm really sorry, @iSazonov, but we're still struggling on this one in the @PowerShell/powershell-committee. A few comments here:\r\n\r\n* Removal of this many tests after a series of failures is very worrying, especially around `PSModulePath` where we've explicitly had historical issues.\r\n* We messed up when we posted [this proposal](https://github.com/PowerShell/PowerShell-RFC/pull/133#issuecomment-467192489) without demo examples. When I was talking about scenarios above, that's really what I meant. You enumerated all the scenarios very well, but we really should have a before/after for each of them so we know exactly what behavior we expect. @PowerShell/powershell-committee has pointed to me as the person to do that, but I'm going on vacation tomorrow through Monday, so it'll probably have to happen next week. I'll post in #9957 when I have that\r\n* We all do absolutely collectively agree on the fact that `$env:PSModulePath` should always show the entirety of the modules we're probing. The scenario extends far beyond module installation via `Install-Module`, and we should not hide \"magic\" from the user. For now, users should use .NET's GetEnvironmentVariable with `Machine`/`User` or @JamesWTruher [EnvironmentVariableCmdlet](https://www.powershellgallery.com/packages/EnvironmentVariableCmdlet/0.1.0) to probe the \"pre-modified\" version of the variable. ",
      "created_at": "2019-09-18T22:47:45Z",
      "updated_at": "2019-09-18T22:47:45Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@joeyaiello Thank you for moving forward in this confusing issue!\r\n\r\n> Removal of this many tests after a series of failures is very worrying, especially around PSModulePath where we've explicitly had historical issues\r\n\r\nDo you say about our attempts to address S2S scenarios? If so old removed tests did not explicitly cover such scenarios, they checked the env variable content. Now we do not change PSModulePath and related tests was removed. All tests for S2S scenarios present.\r\n\r\n>  The scenario extends far beyond module installation via Install-Module, and we should not hide \"magic\" from the user.\r\n\r\nCould you please share more about the scenarios? I really never use PSModulePath to look module paths and really have no understanding why we need to keep this.\r\nAnd if we really need this (For now, users should use .NET's GetEnvironmentVariable with Machine/User or @JamesWTruher EnvironmentVariableCmdlet to probe the \"pre-modified\" version of the variable.) we could expose more \"PowerShell native\" tools like Get/Set-PSModulePath cmdlets with user-friendly interface (ex.: Set-PSModulePath -Add \"newpath\" -BeforePSHomePath).\r\n",
      "created_at": "2019-09-19T03:39:12Z",
      "updated_at": "2019-09-19T03:39:12Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@iSazonov after some discussion with @JamesWTruher on what we think is the right behavior, I'm going to author a small RFC",
      "created_at": "2019-11-11T21:21:52Z",
      "updated_at": "2019-11-11T21:21:52Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "Please take look at https://github.com/PowerShell/PowerShell-RFC/pull/233, I'll submit a code PR to validate my logic",
      "created_at": "2019-11-12T01:16:38Z",
      "updated_at": "2019-11-12T01:16:38Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@SteveL-MSFT I have take look the RFC. I see you consider only SxS for Core vs Windows PowerShell, not third-party soft. In the case my proposal resolve all the SxS scenarios in simplest way. I still don't understand why we should expose modified PSModulePath environment variable. If needed for UX and scripts we could introduce `$PSModulePath` variable (also we discussed cmdlets to manipulate paths).",
      "created_at": "2019-11-12T04:16:34Z",
      "updated_at": "2019-11-12T04:16:34Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@iSazonov we modify `$env:PSModulePath` because existing utilities use it to determine module search path",
      "created_at": "2019-11-14T00:47:22Z",
      "updated_at": "2019-11-14T00:47:22Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": ">  because existing utilities use it\r\n\r\nWhat is the utilities?",
      "created_at": "2019-11-14T08:46:49Z",
      "updated_at": "2019-11-14T08:46:49Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@iSazonov I don't have any specific utilities in mind, but a [search on GitHub](https://github.com/search?l=PowerShell&q=%24env%3Apsmodulepath&type=Code) shows lots of scripts manipulating $env:PSModulePath",
      "created_at": "2019-11-15T02:01:35Z",
      "updated_at": "2019-11-15T02:01:35Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@SteveL-MSFT I see that they __add__ custom paths but not extract \"system\"/PowerShell paths.",
      "created_at": "2019-11-15T05:34:28Z",
      "updated_at": "2019-11-15T05:34:28Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@iSazonov I believe https://github.com/PowerShell/PowerShell/pull/11057 should resolve the related issues and also conforms to the desire by @PowerShell/powershell-committee to respect the env var.",
      "created_at": "2019-11-21T21:34:23Z",
      "updated_at": "2019-11-21T21:34:23Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@SteveL-MSFT Thanks! I hope the long story is resolved now for years :-)",
      "created_at": "2019-11-22T03:47:37Z",
      "updated_at": "2019-11-22T03:47:37Z"
    }
  ],
  "created_at": "2019-08-05T13:47:21Z",
  "number": 10300,
  "state": "closed",
  "title": "Preserve PSModulePath environment variable",
  "updated_at": "2019-12-04T22:39:35Z"
}