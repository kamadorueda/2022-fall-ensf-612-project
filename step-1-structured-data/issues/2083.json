{
  "_url": "https://github.com/PowerShell/PowerShell/issues/2083",
  "author": "curiousdev",
  "body": "I'm happy to move this to a feature-request, though I'm not 100% sure. Please advise. We've observed that when we mix 3rd-party module imports from ISV's, it's quite common that we hit assembly version collisions. \n\nA very common example:\n- Module1 depends on Newton.Json, Version 6.0\n- Module2 depends on Newton.Json, Version 9.0\n\nWe can't use both these modules in the same session. If we import Module1, then Module2, the cmdlets from Module2 throw claiming assembly version conflicts with Newton.Json. Our current work around is to kill the powershell process and start over with the other module import.\n\nShould powershell isolate module imports into their own AppDomains? I'm happy to implement a repo, if this is not already filed.\n",
  "closed_at": null,
  "comments": [
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "IIRC AppDomains are not supported in .NET Core.\n",
      "created_at": "2016-08-26T20:29:29Z",
      "updated_at": "2016-08-26T20:29:29Z"
    },
    {
      "author": "curiousdev",
      "author_association": "NONE",
      "body": "Even if AppDomains are not supported in .NET core, the issue still remains. How can powershell support multiple versions of dlls imported in the same powershell process? I can't update 3rd party modules to use newer dlls versions. So I'm stuck having to explicitly know that I can never use Module1 and Module2 cmdlets in the same ps-session.\n",
      "created_at": "2016-08-26T20:32:40Z",
      "updated_at": "2016-08-26T20:41:20Z"
    },
    {
      "author": "gogbg",
      "author_association": "NONE",
      "body": "Any progress on this?\r\n\r\nI have the same issue.\r\nI have a \"JsonSchemaValidation\" module build by myself which should use:\r\nNewtonsoft.Json, Version=10.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed\r\n\r\nAt the same time AzureRm.Profile uses:\r\nNewtonsoft.Json, Version=6.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed\r\n\r\nPowerShell always uses the \"newtonsoft.Json\" dll from the module that is being imported first!\r\nLooking in the appdomain, both DLLs are present.\r\nIn case of AzureRm.Profile is being imported first, my \"JsonSchemaValidation\" cmdlets does not work.",
      "created_at": "2018-01-02T14:57:04Z",
      "updated_at": "2018-01-02T14:57:04Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@gogbg You could try to use `bindingRedirect`.\r\n\r\nAlso it is expected that AppDomain will come back in .Net Core 2.1.0.",
      "created_at": "2018-01-02T17:21:23Z",
      "updated_at": "2018-01-02T17:21:23Z"
    },
    {
      "author": "oskarm93",
      "author_association": "NONE",
      "body": "I have the same issue.\r\nMy binary module has a dependency on assembly version 8 (JSON.NET).\r\nI use it together with another module, which has a dependency on same assembly version 6.\r\n\r\nAs soon as I `Import-Module` both of them, 2 different versions of the same assembly are loaded into the AppDomain. \r\n\r\nThis normally wouldn't present an issue, but my binary module uses features only available in version 8 of dependent assembly. This throws `MissingMethodException`.\r\n\r\n@iSazonov \r\nI tried to handle `AssemblyResolve` event on the current AppDomain. I redirect any previous version of dependent assembly to v8. Unfortunately, this is too late. This event handler kicks in when I run the first cmdlet from my module. At that stage, the current AppDomain already contains v6.\r\nThis would not happen in a normal executable, as assembly redirects or assembly resolve handler would kick in when application attempts to load v6.\r\n\r\n@SteveL-MSFT \r\nIs this issue still being looked at? It makes some of the modules unusable together in the same session.",
      "created_at": "2018-02-01T09:19:47Z",
      "updated_at": "2018-02-01T09:54:02Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "It certainly does not solve this problem in general but If we talk specifically about Newton.Json then we might consider replacing it with System.Json.",
      "created_at": "2018-02-01T11:27:22Z",
      "updated_at": "2018-02-01T11:27:22Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@xenalite yes, this is an issue we are aware of and have had internal discussions about it.  @daxian-dbw perhaps for now we can document some workarounds until we can address this in code",
      "created_at": "2018-02-01T16:58:45Z",
      "updated_at": "2018-02-01T16:58:45Z"
    },
    {
      "author": "astral-keks",
      "author_association": "NONE",
      "body": "Hello everyone!\r\nBTW it also seems that PowerShell itself depends on Newtonsoft.Json:\r\n```\r\nPS> [System.AppDomain]::CurrentDomain.GetAssemblies() | where { $_.Location.Contains(\"Newton\") }\r\n\r\nGAC    Version        Location\r\n---    -------        --------\r\nFalse  v4.0.30319     c:\\Program Files\\PowerShell\\6.0.1\\Newtonsoft.Json.dll (currently - version 10.0.3)\r\n```\r\n\r\nIt means that if someone imports module which depends on newer version of Newtonsoft.Json then some of its commands will fail with error:\r\n```\r\nCould not load file or assembly 'Newtonsoft.Json, Version=11.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed'. Could not find or load a specific file. (Exception from HRESULT: 0x80131621)\r\n```\r\n\r\nBut it seems to me that this issue is rather general. I mean it must have existed even before PowerShell Core and .NET Core. And there is no solution?",
      "created_at": "2018-02-27T21:22:07Z",
      "updated_at": "2018-02-27T21:22:07Z"
    },
    {
      "author": "curiousdev",
      "author_association": "NONE",
      "body": "@SteveL-MSFT @xenalite @daxian-dbw when documenting workarounds please consider the scenario that we cannot recompile the 3rd party compiled modules, nor can we manually add binderRedirects to powershell.exe.config.\r\n\r\nThe only workaround that we've identified is...\r\nUpdate our large ps1 scripts, spawn portions of the work into child powershell.exe's with a collection of decomposed scripts. This anti-pattern results in the mashing of teeth and rending of garments. ",
      "created_at": "2018-02-27T21:31:45Z",
      "updated_at": "2018-02-27T21:31:45Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@curiousdev workarounds are temporal, plan is to have a proper solution.  No ETA at this time as it's not actively being worked on due to other priorities.",
      "created_at": "2018-02-27T21:40:03Z",
      "updated_at": "2018-02-27T21:40:11Z"
    },
    {
      "author": "curiousdev",
      "author_association": "NONE",
      "body": "@SteveL-MSFT Seeing that it's marked `Up-for-Grabs`, what's the best way to discuss the solution so a community member can push forward on this? Can you share internal team discussion? If a solution has been identified, I'm happy to consider implementing it for review. ",
      "created_at": "2018-02-27T21:43:04Z",
      "updated_at": "2018-02-27T21:43:17Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@curiousdev the `Up-for-Grabs` label was removed 26 days ago, but I would greatly appreciate if you would like to take this on!  There hasn't been any internal discussion yet on this so you are free to propose a solution.  @daxian-dbw would be best to review your proposal.  You can just start by having a discussion in this issue.  Should the need arise it may make sense to author a RFC.",
      "created_at": "2018-02-27T22:27:52Z",
      "updated_at": "2018-02-27T22:27:52Z"
    },
    {
      "author": "astral-keks",
      "author_association": "NONE",
      "body": "> Even if AppDomains are not supported in .NET core, the issue still remains\r\n\r\n@curiousdev And even though AppDomains are not supported it looks like they have something new to solve dependency problem - Assembly Load Contexts:\r\nhttps://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/assemblyloadcontext.md",
      "created_at": "2018-02-28T16:15:24Z",
      "updated_at": "2018-02-28T16:15:24Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT This is the issue that we briefly talked about at psconf",
      "created_at": "2018-04-19T15:26:15Z",
      "updated_at": "2018-04-19T15:26:15Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I think we could solve this after .Net Core 2.1 - we get assembly appdomains or context.",
      "created_at": "2018-04-20T04:15:51Z",
      "updated_at": "2018-04-20T04:15:51Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "Now that we have netcore2.1 it makes me sad seeing this now only being considered for 6.2, is thjs due to the complexity of the implementation?\r\nIt would be great if there was at least documentation on it, especially since the special case by @xenalite [here](https://github.com/PowerShell/PowerShell/issues/2083#ref-issue-318485845) causes also issues on Windows PowerShell, which already has AppDomains integration.\r\nWouldn't this issue be a great candidate for the feature flags that you want to trial @SteveL-MSFT  ?",
      "created_at": "2018-05-14T21:08:56Z",
      "updated_at": "2018-05-14T21:08:56Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@bergmeister the challenge for 6.1 is we're getting towards the end and this work wasn't something we initially planned and making the changes now may prove risky (in terms of regression).  ",
      "created_at": "2018-05-14T21:27:21Z",
      "updated_at": "2018-05-14T21:27:21Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "One way we can do things like this is using remoting. If you could remote to your own computer without needing to be elevated, you could do something like this:\r\n\r\n```posh\r\n$s = New-PSSession -Local\r\nImport-Module Storage -PSSession $s\r\n```\r\nAnd we could just make a shortcut by adding a switch to `Import-Module` to simplify it: `-InNewSession`\r\n\r\nAnything _else_ we could do to \"work around\" the inability to load different versions of the same assembly is going to have  _other_ compromises. That's the nature of the problem.\r\n\r\nI mean, one of the _strengths_ of PowerShell is that it's one single app, with all the commands just being methods in classes. That means we can output real objects and pass them around _and call methods on them_ in different commands from different modules.\r\n\r\nEvery layer of abstraction that you add to that (Load Contexts, AppDomains, and even separate Applications) adds extra work that has to be done and/or removes functionality.  If you have separate Applications, you have to serialize your objects, and you loose the ability to call methods, etc. If you have AppDomains you can pass objects, but only if you load the metadata for them on both AppDomains, and it requires remoting calls and object passing, etc.\r\n\r\n---\r\n\r\nIt seemed, a few posts back, that there have been conversations about this on the side which suggest that this could be done with AppDomains or LoadContexts in a way that _would not_ have huge performance implications -- can anyone explain more? My best understanding of AppDomains would add a lot of caveats: we'd be able to load (and possibly unload) multiple versions of the same assembly ...\r\n\r\nBut PowerShell would have to not just load each module in it's own app domain, but all of the module's dependencies.  At least the metadata for every object being referenced (i.e. all the PowerShell classes) has to be loaded in _each_ AppDomain (and if we want unloading, we have to JIT compile each assembly into each AppDomain where you want to use it)\r\n\r\nThen, PowerShell would need to handle inter-domain communication between every command in every pipeline. I can't even imagine the perf impact of doing remoting in between every command in a pipeline.  \r\n\r\nI think we'd have to avoid loading every module into it's own AppDomain, for performance reasons -- so there would have to be some logic to try and minimize the number of AppDomains while still using \"enough\" of them to handle as many versions of an assembly as we need to...\r\n\r\n### How is this different with LoadContexts?\r\n\r\nI can't quite tell from the linked document -- it looks to me like there's very little isolation (and thus, no ability to unload), I want to say maybe there's no need for remoting, since it's not mentioned in the linked article, but I can't tell...\r\n\r\nHow would a script module that loaded a specific version of an assembly avoid using the wrong one?  How would a _unrelated_ script which uses commands from two different modules that perhaps use different versions of, say, a logging module ... know which assembly LoadContext to use?",
      "created_at": "2018-05-15T03:50:00Z",
      "updated_at": "2018-05-15T03:50:00Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": ">I think we'd have to avoid loading every module into it's own AppDomain, for performance reasons -- so there would have to be some logic to try and minimize the number of AppDomains while still using \"enough\" of them to handle as many versions of an assembly as we need to...\r\n\r\nI very hope that we can avoid. Perhaps we could `Import-Module -Isolate` to minimize AppDomains.\r\nAs for performance it seems CoreCLR use a type mappings so I think there is some ways to get a solution without performance lost.\r\n\r\n> How would a unrelated script which uses commands from two different modules that perhaps use different versions of, say, a logging module ... know which assembly LoadContext to use?\r\n\r\nI believe we haven't conflicts if cmdlet types is _mapped_ in global context.",
      "created_at": "2018-05-15T06:49:45Z",
      "updated_at": "2018-05-15T06:49:45Z"
    },
    {
      "author": "Mattacks",
      "author_association": "NONE",
      "body": "What's the resolution for when I need to reference a newer version of NewtonSoft than that which ships with PowerShell core 6? (See @astral-keks comment)",
      "created_at": "2018-07-16T21:16:44Z",
      "updated_at": "2018-07-16T21:16:44Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@Mattacks I guess you could use `application.config` to map a dll to new version.\r\n\r\nCurrently we always use latest version of packages in preview and release PowerShell Core versions.",
      "created_at": "2018-07-17T04:50:24Z",
      "updated_at": "2018-07-17T04:50:24Z"
    },
    {
      "author": "Mattacks",
      "author_association": "NONE",
      "body": "@iSazonov What do you mean by 'application.config'?\r\nNotwithstanding the fact that developers such as ourselves require a specific version because of dependencies we are bringing in, what would be the process if a different version of NewtonSoft would be needed for, e.g., security bug-fix reasons?\r\n",
      "created_at": "2018-07-17T08:14:25Z",
      "updated_at": "2018-07-17T08:14:25Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "We update continuously packages to get latest security fixes.\r\n\r\nRedirecting assemblies https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/redirect-assembly-versions.",
      "created_at": "2018-07-17T08:52:03Z",
      "updated_at": "2018-07-17T08:52:03Z"
    },
    {
      "author": "Mattacks",
      "author_association": "NONE",
      "body": "Wow, you did mean that feature from the .Net ark! I'll look into it, but that can only be a short term hack, can't it - you can't propose it as a long term solution.\r\n\r\nWe ship our product to customers. They might stick with a version of powershell installed on their kit for years. They have historically. That's different from upgrading our modules.\r\n\r\nI think you have a significant issue here. We need to be able to easily reference the version of newtonsoft we need. And when a dependency ups the version, it needs to flow through seamlessly. \r\n\r\nDo I need to raise a separate issue?",
      "created_at": "2018-07-17T09:18:03Z",
      "updated_at": "2018-07-17T09:18:03Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "You could consider using LoadContext to resolve version conflicts https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/assemblyloadcontext.md",
      "created_at": "2018-07-17T13:43:54Z",
      "updated_at": "2018-07-17T13:43:54Z"
    },
    {
      "author": "goldcode",
      "author_association": "NONE",
      "body": "Solution: Load your target version of the assembly\r\nhttps://gist.github.com/JamesRandall/444f3365751edb130bef197f2222cfa5\r\n\r\nworked for me.",
      "created_at": "2019-02-20T11:00:03Z",
      "updated_at": "2019-02-20T11:00:23Z"
    },
    {
      "author": "JustinGrote",
      "author_association": "CONTRIBUTOR",
      "body": "@goldcode this doesn't work if the assembly is native to pwsh, e.g. 'System.Runtime.CompilerServices.Unsafe', it's only if you have two modules that need different version DLLs.\r\n\r\nEven then it's a \"first module wins\" race unless you coordinate loading the modules at the same time (in \"practice\", this means your module has to search all other modules for a potentially newer assembly before loading, and load that one instead) because whatever assembly gets loaded first is the one that \"sticks\", and even that still has problems because what if you add another module via install-module in the same session later?\r\n\r\nLoadContext in .NET 3.0 (and subsequently PS7) solves this problem \"sort of\" for libraries that are not native to PS Core, you can have a Load Context per module (preparing a proof of concept for this), but you need to make sure your module doesn't output any types that are part of that LoadContext, because if another app needs it and the module's loadcontext has the type as a different version, the CLR will see them as different types and you get the super confusing \"Cannot cast MyLoadContextType to type MyLoadContextType\"",
      "created_at": "2019-10-16T16:18:32Z",
      "updated_at": "2019-10-16T16:21:36Z"
    },
    {
      "author": "hbuckle",
      "author_association": "CONTRIBUTOR",
      "body": "I was playing around with this and came up with something that seems to work, I'm not sure if it's a good or safe way of doing things though\r\n\r\nIn the root module I have\r\n\r\n```powershell\r\n$Script:plugins = @{ }\r\n$lc = [System.Runtime.Loader.AssemblyLoadContext]::new($false)\r\n@(\r\n  \"YamlDotNet.dll\"\r\n) | ForEach-Object {\r\n  $path = (Resolve-Path \"$PSScriptRoot/Lib/$_\").Path\r\n  $assemby = $lc.LoadFromAssemblyPath($path)\r\n  $Script:plugins[$assemby.GetName().Name] = $assemby\r\n}\r\n```\r\n\r\nI can then create instances from the load context using\r\n\r\n```powershell\r\nfunction New-PluginInstance {\r\n  param (\r\n    [string]$TypeName,\r\n    [object[]]$Params\r\n  )\r\n  foreach ($plugin in $Script:plugins.GetEnumerator()) {\r\n    $type = $plugin.Value.GetType($TypeName)\r\n    if ($null -ne $type) {\r\n      if ($null -eq $Params) {\r\n        return [System.Activator]::CreateInstance($type)\r\n      }\r\n      else {\r\n        return [System.Activator]::CreateInstance($type, $Params)\r\n      }\r\n    }\r\n  }\r\n  throw \"Type ${TypeName} was not found in the plugin cache\"\r\n}\r\n\r\n$deserializer = (New-PluginInstance -TypeName \"YamlDotNet.Serialization.DeserializerBuilder\").Build()\r\n```\r\n\r\nThis seems to work fine, and I can import the `Az.Aks` module, which has YamlDotNet as a RequiredAssembly, in the same session\r\n\r\n@JustinGrote is this the right way of using LoadContext?",
      "created_at": "2020-03-28T07:15:45Z",
      "updated_at": "2020-03-28T07:15:45Z"
    },
    {
      "author": "JustinGrote",
      "author_association": "CONTRIBUTOR",
      "body": "@hbuckle I can't comment on the \"Right\" way but what I would envision as a design:\r\n\r\n1. Each module gets its own optional loadcontext, a \"runspace\" of sorts to load its own specific assemblies\r\n2. **Modules \"shouldn't\" ever output any types that are utilized in this load context directly**, they should be cast to module-specific types, PS standard native types, or PSCustomObject, to avoid the obtuse \"can't cast [typename] to [typename]\" error that will confuse users\r\n3. Modules would ideally have a hook during unloading the module that would cleanup and remove the loadcontext.",
      "created_at": "2020-03-30T15:09:07Z",
      "updated_at": "2020-03-30T15:09:07Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@JustinGrote Have you an interest to pull RFC?",
      "created_at": "2020-03-30T17:15:43Z",
      "updated_at": "2020-03-30T17:15:43Z"
    },
    {
      "author": "JustinGrote",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov I'm a terrible c# developer, if I have some spare time I can make an effort but for now I probably need to finish some \"old business\" projects before jumping on something new.",
      "created_at": "2020-03-30T17:19:53Z",
      "updated_at": "2020-03-30T17:19:53Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@JustinGrote revealed a key problem about isolating modules -- type identity. That's the main reason why the RFC [Loading Modules into Isolated AssemblyLoadContext](https://github.com/PowerShell/PowerShell-RFC/blob/master/X-Withdrawn/RFC0043-Loading-Module-Into-Isolated-AssemblyLoadContext.md) got withdrawn. But more and more scenarios are affected by the assembly conflict issue and we have to move toward this general solution in PowerShell.\r\nI will update that RFC soon to call out the guidance for module author is to not rely on users to use type exposed from the module directly, but be noted that the Azure PowerShell modules actually heavily depends on allowing users to directly use the types exposed by Azure PowerShell modules, so it's hard to say if that \"guidance\" is acceptable ...",
      "created_at": "2020-03-30T18:00:04Z",
      "updated_at": "2020-03-30T18:00:04Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "It seems we need a new PowerShell abstraction for this like we have provides and provider prefixes. I mean something like `[<loadcontext>::io.fileinfo]`. And maybe switching default context for a scope.",
      "created_at": "2020-03-30T18:29:24Z",
      "updated_at": "2020-03-30T18:29:24Z"
    },
    {
      "author": "hbuckle",
      "author_association": "CONTRIBUTOR",
      "body": "`[<loadcontext>::io.fileinfo]` or something like it seems workable, perhaps with an update to `Add-Type` to accept a load context as well.\r\nThe method I posted above seems to work until this is supported natively although it's quite clunky.\r\n\r\nWhat with the growth in yaml I wouldn't be surprised if yamldotnet becomes the next newtonsoft.json in terms of people including it in modules.",
      "created_at": "2020-03-31T09:07:32Z",
      "updated_at": "2020-03-31T09:07:32Z"
    },
    {
      "author": "gogbg",
      "author_association": "NONE",
      "body": "```powershell\r\nImport-module -name az.aks\r\nImport-module -name platyPS\r\nplatyPS\\New-MarkdownHelp -Module az.aks\r\n```\r\ndoes not work as both platyPS and az.aks depends on YamlDotNet.dll.\r\n\r\nDo we have a workaround for that?\r\nI have tried both approaches, using AppDomain.AssemblyResolve event, or AssemblyLoadContext.Resolving events but without any success.\r\nThe import of the second module fails with:\r\n```powershell\r\nImport-Module: Assembly with same name is already loaded\r\n```\r\n\r\nMy real use case is to generate markdownhelp for module that has az.aks as dependancy :)\r\n",
      "created_at": "2020-04-01T12:30:15Z",
      "updated_at": "2020-04-01T12:35:20Z"
    },
    {
      "author": "JustinGrote",
      "author_association": "CONTRIBUTOR",
      "body": "@gogbg I believe the module itself has to call the assembly and methods from the loadcontext, you can't facilitate it for it, you'd probably have to edit the source of one of the two (platyPS would probably be easier).\r\n\r\nAlso are you doing this in 5.1? An alternative is loading order with PS7, PS7 when doing add-type will do sort of a \"binding redirect\", in the sense that if an assembly is already loaded but with a different version it will just silently continue, so if you load the assembly with the latest version first (and assuming there aren't any backwards incompatible changes), it should work for both modules.",
      "created_at": "2020-04-01T14:19:42Z",
      "updated_at": "2020-04-01T14:19:42Z"
    },
    {
      "author": "gogbg",
      "author_association": "NONE",
      "body": "Actually in PowerShell 6.2.4 i can simultaneously load `az.aks` and `platyPS`\r\n```powershell\r\nPS C:\\> get-module az.aks,platyps\r\n\r\nModuleType Version    Name                                ExportedCommands\r\n---------- -------    ----                                ----------------\r\nScript     1.0.2      Az.Aks                              {Get-AzAks, Import-AzAksCredential, New-AzAks, Remove-AzAks\u2026}\r\nScript     0.14.0     platyPS                             {Get-HelpPreview, Get-MarkdownMetadata, Merge-MarkdownHelp, New-ExternalHelp\u2026}\r\n\r\nPS C:\\> [System.Runtime.Loader.AssemblyLoadContext]::GetLoadedAssemblies() | Where-Object {$_.FullName -like '*YamlDotNet*'} | select fullname\r\n\r\nFullName\r\n--------\r\nYamlDotNet, Version=5.0.0.0, Culture=neutral, PublicKeyToken=ec19458f3c15af5e\r\nYamlDotNet, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\r\n```\r\n\r\nwhereas in PS 7.0.0 I cannot :\r\n```\r\nPS C:\\> Import-Module -Name 'Az.Aks'\r\nPS C:\\> Import-Module -Name 'platyPS'\r\nImport-Module: Assembly with same name is already loaded\r\nPS C:\\>\r\n```\r\n\r\nI can also see some differences in the System.Runtime.Loader.AssemblyLoadContext api.",
      "created_at": "2020-04-01T15:00:03Z",
      "updated_at": "2020-04-01T15:00:03Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "For modules do not exporting binary types (like PlatyPS) we could enhance PowerShell engine to load such modules in custom context. Such modules could have new parameter in PSD1 file like:\r\n```powershell\r\nAssemblyContext = Default          # Default current behavior\r\nAssemblyContext = AutoIsolate   # Load module in random generated assembly context\r\n```\r\nIf engine see the parameter and `RequiredAssemblies = @('Markdown.MAML.dll','YamlDotNet.dll')` it load the assemblies in custom context. ",
      "created_at": "2020-04-02T06:45:03Z",
      "updated_at": "2020-04-02T06:45:03Z"
    },
    {
      "author": "gogbg",
      "author_association": "NONE",
      "body": "@iSazonov are you aware of solution/workaround to import both `Az.Aks` and `platyPS` in PS7 at the same time?",
      "created_at": "2020-04-02T07:13:02Z",
      "updated_at": "2020-04-02T07:13:02Z"
    },
    {
      "author": "gogbg",
      "author_association": "NONE",
      "body": "@iSazonov the `AssemblyContext` key in the psd1 seems a good idea.\r\nI would suggest also adding parameter to Import-Module `-AssemblyContext` so we can handle unpredictable issues on per case base. ",
      "created_at": "2020-04-02T08:03:48Z",
      "updated_at": "2020-04-02T08:03:48Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> adding parameter to Import-Module -AssemblyContext\r\n\r\nSo far I do not see this as necessary because only an author of the module can guarantee the module correct work in custom context. It is simplest case for start. After we get an experience with the feature we can think about the parameter.\r\n\r\nI'd ask @daxian-dbw and @rjmholt to review the idea.\r\n",
      "created_at": "2020-04-02T09:44:22Z",
      "updated_at": "2020-04-02T09:44:22Z"
    },
    {
      "author": "gogbg",
      "author_association": "NONE",
      "body": "@iSazonov the module author cannot predict all the possible cases in which his module will be used, especially for generic modules like platyPS. So for unpredictable cases instead of waiting for the module author to implement fixes for edge cases, it would be good to have the ` Import-Module -AssemblyContext` parameter.\r\n\r\nBasically what I mean is expose the internals `how module assembly to  ALC are being loaded` to the developer/scripters so they can handle edge cases on their own",
      "created_at": "2020-04-02T09:53:13Z",
      "updated_at": "2020-04-02T10:21:45Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@gogbg No, only module developers, not consumers, can ensure whether the module works in isolated context or no. \r\nThe module developers shouldn't expose any types from underlying assembly. They have two option to achieve this:\r\n- do not expose types from the module at all (like PlatyPS)\r\n- expose only module types (like LocalAccounts module do for LocalUser/LocalGroup classes)\r\n\r\nIf users would load a module does not designed for working in isolated context the module would be not operational or continue to conflict with other dll-s.",
      "created_at": "2020-04-02T11:29:47Z",
      "updated_at": "2020-04-02T11:29:47Z"
    },
    {
      "author": "gogbg",
      "author_association": "NONE",
      "body": "@iSazonov I agree with your point.\r\n\r\nMy point is however different. \r\nIn practice a lot of modules can have conflicting dependencies, and the module developer might not event know what AssemblyLoadContext is. So it would be good for me as a consumer to have option to import his module into separate ALC, instead of going to contribute to his codebase as this typically is much slower process.\r\nIf you are afraid that `adding parameter to Import-Module -AssemblyContext` can cause issues in certain cases just add warning message for that, but give me the option to use it in cases where it does not cause issues.\r\n",
      "created_at": "2020-04-02T11:50:17Z",
      "updated_at": "2020-04-02T11:50:17Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@gogbg You say about general scenario. From my current understanding we can not address the scenario in simple way, it would be very complex. I believe we will have to add a new PowerShell language abstraction to address the scenario. \r\nIf we first address a scenario like PlatyPS we will go half way. ",
      "created_at": "2020-04-02T13:20:39Z",
      "updated_at": "2020-04-02T13:20:39Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> I'd ask @daxian-dbw and @rjmholt to review the idea.\r\n\r\nWe actually discussed this at length a little while back. It's not a simple question unfortunately.\r\n\r\nI should start by saying that [we've got an implementation using another ALC running successfully in the wild](https://github.com/PowerShell/PowerShellEditorServices/blob/8c500ee1752201d3c1cc2e5d90f1a2af3b1eb15d/src/PowerShellEditorServices.Hosting/EditorServicesLoader.cs#L80-L112), but it took work to implement correctly and we didn't get everything the first time; some type-based APIs are still not entirely perfect.\r\n\r\nThere are plenty of tricky edge cases, but the biggest one is leaking dependency types in your API, leading to weird exceptions that say things like `unable to cast object of type 'Dependency.ThisObject' to type 'Dependency.ThisObject'`. Basically, putting something in another ALC introduces subtle type equality issues, and just loading something into another ALC doesn't mean you'll be able to call it.\r\n\r\nSo while PowerShell could just load everything into its own ALC, that could lead to pernicious errors. Especially where a set of modules all assume they share a dependency (like many of the Az modules).\r\n\r\nNaturally ALC issues are also compounded by the fact that PowerShell uses reflection pretty much everywhere, so we don't know what else might have holes in it there.\r\n\r\nSimilarly, while we could offer an `-InNewAssemblyContext` module load switch, it wouldn't have any meaning for non-binary modules (and what about modules that load binaries but as nested modules or required modules or not as modules at all?), and there's real potential for it to be abused. One possibility is that users take it up as an \"it just works\" fix that later causes much subtler crashes, and another is that it allows module authors to abrogate the need to fix issues with their module because you can just load it differently.\r\n\r\nThe general assumption is that binary module developers have a better understanding of .NET mechanics than most of the users importing their module, so it possibly makes more sense to expose this to module developers. But again, giving them a big hammer to say \"load my module in a new ALC\" doesn't solve the whole issue; they need to understand what the implications are and ensure that their module can reliably work across ALCs by doing things like making sure they aren't leaking their dependencies' types in their own APIs. That's the kind of analysis that gets done when the module maintainers look at using an ALC themselves.\r\n\r\nI think it still definitely makes sense for PowerShell to provide ALC-isolated module loading, but we need more than a switch basically, since we need to help module authors understand and work with such a functionality.\r\n\r\nWith all this said, we could offer *multiple* ways to load module into a new ALC, especially since any one module doesn't intrinsically have a dependency conflict issue; the module consumer faces the issue because two modules that don't know or care about each other have a conflict. I think it's worth looking into as well, but I should say that:\r\n\r\n- Any solution that PowerShell tries to implement that implicitly or magically resolves things by using a new ALC will eventually just cause problems. Look at how confusing reloading types in classes is today. Whatever we do should be quite explicit and ideally well documented.\r\n- For every way we add to configure this, we add another way for configuration to conflict, possibly invite conflicting (or impossible) expectations about behaviour, possibly introduce subtle corner cases and failure modes, force PowerShell to spend longer at runtime loading a module, and add more cases of intersections of binary modules that we must test (an area that PowerShell could be tested much better in already).\r\n\r\nSo yeah, to respond more specifically:\r\n\r\n> In practice a lot of modules can have conflicting dependencies, and the module developer might not event know what AssemblyLoadContext is. So it would be good for me as a consumer to have option to import his module into separate ALC, instead of going to contribute to his codebase as this typically is much slower process.\r\n\r\nModule developers will need to do their homework even if we implement an ALC loading feature, and they'll need to sift through their public APIs to weed out types from their dependencies. I don't see a fast route here; PowerShell can't abstract this away, since it's a concept in the fabric of the platform. Them going through the slow process of understanding an ALC is kind of required.\r\n\r\nImplementing a user-facing switch to load things into an ALC anyway is possible, but is still a lot of work that we don't have on the board right now. And people using it should understand that there's risk involved.\r\n\r\nThis is definitely an area we'd like to invest in in the future, but because of how fundamental it is, we need to be methodical about it.\r\n\r\nFinally, my personal take on what would be good:\r\n\r\n- A module manifest flag to allow module imports into a new ALC\r\n- An `Import-Module` switch parameter to do the same (and possibly an opt-out to override the module)\r\n- Consensus on the behaviour for nested modules, required modules or loading done by the module (by ipmo or add-type -- `[assembly]::Load` is something we probably can't control)\r\n- Ideally a Roslyn analyser to help weed out type leakage",
      "created_at": "2020-04-07T19:23:33Z",
      "updated_at": "2020-04-07T19:25:25Z"
    },
    {
      "author": "JustinGrote",
      "author_association": "CONTRIBUTOR",
      "body": "@rjmholt nailed my concerns and recommended go-forward.\r\nModule developers should be able to specify one or more assembly load contexts on their own in a \"standard\" way and consume types, methods, and assemblies from those within the module scope, and have some sort of guidance if it is detected they are leaking types from the module scope out into the main scope.\r\n\r\nThe module manifest flag should also be tied into remove-module such to dispose the assembly contexts and free up the dll's to avoid the locking issues today, as well as allow reloading for easier testing and side-by-side usage of modules requiring different assembly versions.\r\n\r\nIn both cases the onus should be on the module developer, but it should be made easy to manage for them like how Export-ModuleMember is used today.",
      "created_at": "2020-04-07T19:33:59Z",
      "updated_at": "2020-04-07T19:33:59Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Do we know scenario without type conflicts? I think yes:\r\n1. If module exposes only cmdlets and does not expose any other types. The scenarios like PlatyPS - stateless manipulating external objects\r\n2. If module works with well-know types.\r\n    - the module's cmdlets emit .Net objects\r\n    - the module's cmdlets emit PSCustom objects\r\n    - the module's cmdlets emit types already present in global (known to PowerShell engine)\r\n\r\nCurrently Engine can only import cmdlets (functions/aliases) to global.\r\nAs we can see PowerShell engine must be enhanced to import module's cmdlet types from custom ALC and can be able to resolve the types. I believe we can implement this _without side effects_ because all will isolated in custom ALC.\r\n\r\nFor more complex scenarios Engine could import module's types from the module custom ALC.\r\n__Since the import process is under Engine control Engine can block/resolve/avoid type conflicts.__\r\n\r\nThen if we implement type prefixes as proposed above Engine can import all needed types from isolated modules. Although here we certainly can\u2019t avoid all the side effects completely.\r\n",
      "created_at": "2020-04-08T07:05:44Z",
      "updated_at": "2020-04-08T07:05:44Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> Do we know scenario without type conflicts? I think yes:\r\n\r\nI think the technical definition here is that any type coming from an assembly in `$PSHome` (PowerShell's broader equivalent of a Base Class Library) is a type that a module can freely use in its APIs. If a module exports its own types, manipulating ALC-internal types from PowerShell probably isn't an issue, but weird things will happen if you try and do something like use the output of a cmdlet from one module as the input to another.\r\n\r\nOne scenario I imagine will be common is wanting to export the types defined by a module, but not those it pulls in as a dependency. A possible solution there is as @iSazonov says; when an assembly is imported as a module, we import those types into the main ALC as well (I believe this is possible, but I'm not 100% sure). That means nested modules work too. It also means those modules wouldn't be able to be unloaded.\r\n\r\nGiven that I see a couple of common patterns:\r\n\r\n- Modules that only expose PS-BCL types, including PSCustomObjects. These modules will have all their .NET types contained within an ALC and be unloadable, but will not be able to export their own types.\r\n- Modules that expose a facade layer and contain their dependencies. Assemblies loaded as modules as part of these modules will be exposed in one way or another to the main ALC, but they will need a custom resolve event to load binary dependencies into a custom ALC. These will not be unloadable. I capture the general architecture of this in https://github.com/PowerShell/PowerShell/issues/11571#issuecomment-574384979.\r\n\r\nThis is in addition to the default of just loading everything into the main ALC.\r\n\r\nThe risk, of course, is that the subtleties of these scenarios will be misunderstood or ignored and that modules will be marked or imported in a way that initially seems to work but causes subtle ALC-caused type errors later.\r\n\r\nI think the best we can do to help that is to gate a module ALC feature on better documentation and tooling, particularly:\r\n\r\n- Documentation describing how to use the feature (that's standard, but putting it here), with examples\r\n- Documentation explaining the concept of ALCs and pointing to the relevant .NET documentation\r\n- Ideally a Roslyn analyzer set that can determine whether a module is breaking its ALC requirements",
      "created_at": "2020-04-13T23:16:30Z",
      "updated_at": "2020-04-13T23:16:30Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "This has been well doc'd by @rjmholt and @sdwheeler at https://docs.microsoft.com/powershell/scripting/dev-cross-plat/resolving-dependency-conflicts\r\n\r\nThat being said, we may want to give an opt-in mode to module owners for this functionality more generally, but it's not going to come in 7.1\n\n<blockquote><img src=\"https://docs.microsoft.com/en-us/media/logos/logo-ms-social.png\" width=\"48\" align=\"right\"><div><strong><a href=\"https://docs.microsoft.com/en-us/powershell/scripting/dev-cross-plat/resolving-dependency-conflicts\">Resolving PowerShell module assembly dependency conflicts - PowerShell</a></strong></div><div>When writing a binary PowerShell module in C#, it's natural to take dependencies on other packages or libraries to provide functionality.</div></blockquote>",
      "created_at": "2020-07-02T18:45:16Z",
      "updated_at": "2020-07-02T18:45:19Z"
    },
    {
      "author": "gogbg",
      "author_association": "NONE",
      "body": "Hey @SteveL-MSFT, \r\nNow that 7.2 is out, are there any improvements on this?",
      "created_at": "2021-11-17T09:15:22Z",
      "updated_at": "2021-11-17T09:15:34Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@gogbg If you develop a module the best you can do is to follow  https://docs.microsoft.com/powershell/scripting/dev-cross-plat/resolving-dependency-conflicts\r\nIt is impossible to resolve the issue in Engine for all scenarios. It is fundamental problem.",
      "created_at": "2021-11-17T14:42:41Z",
      "updated_at": "2021-11-17T14:42:41Z"
    },
    {
      "author": "gogbg",
      "author_association": "NONE",
      "body": "@iSazonov I'm just asking if there are any improvements on the topic.\r\n\r\nI am aware of the guidance your pointed out.\r\n\r\nWe are a team of ~30 powershell engineers/developers that are struggling with such kind of issues on weekly basis.\r\nTo give you more perspective, we are managing huge azure environment (~100 subscriptions) in a gitops way, and for that purpose we have to use the Az* modules, and several other community modules like MSAL.PS. It is impossible to keep up with the new Az* module versions without wasting weeks of troubleshooting `Assembly with same name is already loaded` kind of issues.\r\nAnd to emphasize more on the `Assembly with same name is already loaded` kind of issues: It would a good idea to at least report which is the assembly that cannot be loaded, because in such complex environments it is impossible to figure that out easily.\r\n\r\np.s. At least there is some hope because of fact that Az.Accounts 2.5.4 is utilizing the AssemblyLoadContext\r\n",
      "created_at": "2021-11-17T15:39:01Z",
      "updated_at": "2021-11-17T15:44:29Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "I think the `Assembly with the same name` error is really just a change to a BCL API (or maybe that PowerShell is using a different API from winps code). It seems like that API used to just ignore the second load request when an assembly is already loaded that satisfies the requirement, but now it throws instead. Ideally PowerShell would update the places where it uses this API to just try catch as long as the already loaded assembly satisfies the request.\r\n\r\nWhile not always the case, often when you see that message things will still work fine.  Or if they don't, it's often because the error just stopped the rest of the loading process.\r\n\r\nThe direct answer to your question though is no there's nothing in 7.2 that helps with that afaik.",
      "created_at": "2021-11-17T16:25:31Z",
      "updated_at": "2021-11-17T16:26:27Z"
    },
    {
      "author": "JustinGrote",
      "author_association": "CONTRIBUTOR",
      "body": "@gogbg if you can possibly load the modules that have the latest assemblies first, the other modules will assembly bind redirect transparently to those and you won't get the error (since 6.x+), though that's no guarantee those modules will still work if there was a non-backwards-compatible breaking change in the newer assembly.\r\n\r\nI'm not sure exactly what your processes are but you could consider just pinning modules to a stable state, and since you say you are GitOps shop, set up a github action dependabot style to evaluate new dependencies as a PR to your work and report an error if there is a conflict.",
      "created_at": "2021-11-17T16:35:57Z",
      "updated_at": "2021-11-17T16:35:57Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@gogbg I guess this Azure module situation is a big headache for MSFT and they are unlikely to comment on it.\r\n\r\nNo doubt ALC is not general solution for all scenarios and therefore unlikely to be included in the Engine.\r\n\r\nThe only scenario where ACL works reliably is if a module does not expose types from dependent assemblies, but only its own custom types. In that case the author of the module can hide the dependent assemblies in the ACL and not break other modules.\r\n\r\nFundamental solution is _to have stable public contract_.\r\nFor Azure this assumes they would share a _reference assembly_ for Az.* developers.\r\n\r\nThe easiest thing you can do is what @JustinGrote mentioned - make a function to be loaded first in any session and that will find and load the most high versions of assemblies. This can be implemented in a variety of ways to suit your needs.  We can assume this will work.",
      "created_at": "2021-11-17T17:24:49Z",
      "updated_at": "2021-11-17T17:24:49Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> p.s. At least there is some hope because of fact that Az.Accounts 2.5.4 is utilizing the AssemblyLoadContext\r\n\r\n@gogbg As you already found out, Azure PowerShell already rolled out their own solution by leveraging `AssemblyLoadContext`. @dingmeng-xue can you share some details?",
      "created_at": "2021-11-17T17:42:19Z",
      "updated_at": "2021-11-17T17:42:19Z"
    },
    {
      "author": "isra-fel",
      "author_association": "NONE",
      "body": "@gogbg You are right. Since Az.Accounts v2.5.4 / Az v6.5.0 we started to leveage ALC to solve the dependecy conflict issue.\r\n\r\nBasically we selected a list of assemblies (including Microsoft.Identity.Client aka MSAL) that were (a) shared by all Az.* modules and (b) were also likely to conflict with other well-known modules, and load them into one ALC. That made sure it could work with modules like MSAL.PS.\r\n\r\n> The only scenario where ACL works reliably is if a module does not expose types from dependent assemblies, but only its own custom types. In that case the author of the module can hide the dependent assemblies in the ACL and not break other modules.\r\n\r\n@iSazonov Also true. That's exactly how Az.Compute works together with Az.Storage while they depend on different versions of Storage SDK.",
      "created_at": "2021-11-18T10:04:29Z",
      "updated_at": "2021-11-18T10:04:45Z"
    },
    {
      "author": "gogbg",
      "author_association": "NONE",
      "body": "@iSazonov, @JustinGrote we already do Dependency checks as part of our CICD process, however \"assembly with same name is already leaded\" kind of generic exceptions are not very helpful to understand which module is causing the issue. So for example every time PSScriptAnalyzer assembly that is part of the PowerShell VSCode extension gets updated we waste several hours to understand what is the issue. \r\n\r\n\r\nAnyway as it is perfectly stated in this [comment](https://github.com/PowerShell/PowerShell/pull/10238#issuecomment-826091414) I'm also getting tired of explaining my point on this issue. @SteveL-MSFT @joeyaiello @daxian-dbw ",
      "created_at": "2021-11-22T08:04:48Z",
      "updated_at": "2021-11-22T08:08:47Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@gogbg If you know how implement the better error message feel free to make PR.",
      "created_at": "2021-11-22T17:26:47Z",
      "updated_at": "2021-11-22T17:26:47Z"
    },
    {
      "author": "curiousdev",
      "author_association": "NONE",
      "body": "@SteveL-MSFT \r\n\r\nSeems like this thread is losing sight of the issue at hand.  PowerShell positions itself as an alternative shell. Consequently, users have a base set of assumptions they bring with them.\r\n1. A command cannot break other command's runtime dependencies. \r\n2. Cli/commands being separate processes. \r\n3. Shell is decoupled from how a command is implemented.\r\n\r\nPowerShell _should_ be more considerate of those expectations. Or risk, users giving up on the ecosystem.\r\n\r\nIn your traditional terminal, not PowerShell, vendor exe's from vendor A + B + C can co-exist without issue.  They could share similar runtime dependencies that even conflict. The user does not have to care. \r\n```\r\ntaskA.exe | taskB.exe | taskC.exe\r\n```\r\n\r\n\r\nIn PowerShell, with runtime dependencies directly loaded, the user now assumes the risk that vendors A, B, C have conflicting runtime dependencies. Why are we foisting that risk onto them?\r\n```\r\nInvoke-TaskA | Invoke-TaskB | Invoke-TaskC  // Boom! TaskC needs an older dependency. Sadly TaskA imported the newer one. So sad...\r\n```\r\n\r\nRecommendation: \r\n1. Process isolate commands and pipe serialized structured data between commands.\r\n2. Update dotnet to support multiple versions of dependencies. So that vendor",
      "created_at": "2021-11-23T16:03:45Z",
      "updated_at": "2021-11-23T16:04:00Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> * Process isolate commands and pipe serialized structured data between commands.\r\n\r\nYou already can do this but you lost performance and functionality.\r\n\r\n> * Update dotnet to support multiple versions of dependencies. So that vendor\r\n\r\nThere already is ALC (assembly load context).",
      "created_at": "2021-11-23T18:05:22Z",
      "updated_at": "2021-11-23T18:05:22Z"
    },
    {
      "author": "curiousdev",
      "author_association": "NONE",
      "body": "Does PowerShell do this natively? Or do command/module vendors have to jump through these extra hoops?\r\n\r\nExpecting vendors to do this is not practical in any sense. This should be provided by PowerShell.",
      "created_at": "2021-11-24T19:57:27Z",
      "updated_at": "2021-11-24T19:57:27Z"
    },
    {
      "author": "JustinGrote",
      "author_association": "CONTRIBUTOR",
      "body": "@curiousdev it's not really a PowerShell thing, it's a .NET level thing.\r\n\r\nAs long as assemblies/modules are loaded in descending order of assembly version, then .NET automatically redirects code using \"older\" assemblies to the \"newer\" assembly. This is called a binding redirect. It is not foolproof, especially if there was a breaking change in the code, but for the most part it works well enough.\r\n\r\nThere is no guarantee to the order of assembly loads since assemblies can be loaded at any time in PS from an import-module (or whatever) so you have to manually do this part.\r\n\r\nAs mentioned, the only other option is for Powershell to load whole modules either into separate processes or separate AssemblyLoadContexts, both of which have huge problems around sanitization and serialization that would probably be at least a six month development and fraught with issues and backwards compatibility concerns. It's not an easy task whatsoever and it's not surprising it hasn't been tackled yet.\r\n\r\nCurrently the best option is for module authors to use `AssemblyLoadContexts` themselves, this is seen as successful in modules such as the `Az` module and the `PowershellEditorServices` module, however for the most part this has to be done at the C# level, so there might be a good option to provide some sort of \"helper\" way to load these for script modules.",
      "created_at": "2021-11-24T20:08:23Z",
      "updated_at": "2021-11-24T20:08:41Z"
    },
    {
      "author": "JustinChristensen",
      "author_association": "NONE",
      "body": "I'm relatively new to Windows programming with .NET, so pardon me if I'm missing something obvious here but...\r\n\r\nWhile testing some routines that depend on `System.Text.Json` from Powershell I've been loading my assembly with `Add-Type -Path path\\to\\MyAssembly.dll`, and I ran into what I think is this issue immediately. I've got dependencies that depend on two different versions of `System.Runtime.CompilerServices.Unsafe`, and so that makes sense. \r\n\r\n[That article](https://docs.microsoft.com/en-us/powershell/scripting/dev-cross-plat/resolving-dependency-conflicts?view=powershell-5.1#add-an-assemblyresolve-event-handler-to-create-a-dynamic-binding-redirect) that @sdwheeler and @rjmholt were kind enough to write recommends writing some event handler logic to get out in front of the offending assembly load and perform the redirect ourselves in code. I'm compiling my classlib project with `AutoGenerateBindingRedirects` enabled in my csproj file, and I see that it outputs a configuration file with the redirects it needs. \r\n\r\nGiven that implementing these redirects ourselves is an option (implying that it can be done), what would be stopping the Powershell team from shipping a cmdlet that reads binding redirects from one of those generated configuration files and applies them to the current assembly context? \r\n\r\nSomething like `Add-Redirects path\\to\\MyLibrary.redirects.config; Add-Type -Path path\\to\\MyLibrary.dll`?",
      "created_at": "2022-01-06T05:43:10Z",
      "updated_at": "2022-01-06T05:49:42Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Something like `Add-Redirects path\\to\\MyLibrary.redirects.config; Add-Type -Path path\\to\\MyLibrary.dll`?\r\n\r\nThis is just _another_ way. But like any other methods it is not a universal solution and therefore cannot be adopted by the Engine.",
      "created_at": "2022-01-06T05:56:53Z",
      "updated_at": "2022-01-06T05:56:53Z"
    },
    {
      "author": "JustinChristensen",
      "author_association": "NONE",
      "body": "@iSazonov \r\n\r\nRight, but unless I'm misunderstanding something that article I linked to is recommending that users write code that essentially implements what that cmdlet would be doing, regardless of its universality. \r\n\r\nAnd what is considered to be \"Engine\" here? Are builtin-in powershell modules part of the \"Engine\"? Where this resides seems like an arbitrary distinction. \r\n\r\nThat article is recommending stopgaps that seem to be just good enough. Given the age of this issue, perhaps universality is out of reach. ",
      "created_at": "2022-01-06T06:09:21Z",
      "updated_at": "2022-01-06T06:14:31Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> And what is considered to be \"Engine\" here?\r\n\r\nPowerShell Engine - PowerShell internal APIs. \r\n\r\n> Are builtin-in powershell modules part of the \"Engine\"?\r\n\r\nNo. But they can use internal APIs (it is not good...).\r\n\r\n> ... that article I linked to is recommending ...\r\n> Given the age of this issue, perhaps universality is out of reach.\r\n\r\nYes, it is fundamental problem and there is no single solution. The article explains the problem and offers options.\r\n\r\nIf you develop a module the best you can do is to load dll dependencies to custom ALC and re-map the dll types to custom module types or PSObjects so that users never see types from the underlying dlls.\r\n",
      "created_at": "2022-01-06T06:42:03Z",
      "updated_at": "2022-01-06T06:42:03Z"
    },
    {
      "author": "gogbg",
      "author_association": "NONE",
      "body": "> If you develop a module the best you can do is to load dll dependencies to custom ALC and re-map the dll types to custom module types or PSObjects so that users never see types from the underlying dlls.\r\n\r\nThe majority of the modules developed from the community are script modules, and as far as I am aware in this case there is no option to load assemblies into custom ALC.",
      "created_at": "2022-01-27T08:10:21Z",
      "updated_at": "2022-01-27T08:10:21Z"
    },
    {
      "author": "JustinGrote",
      "author_association": "CONTRIBUTOR",
      "body": "@gogbg you can call the same ALC .NET methods to load DLLs into an ALC, but it's much more difficult to work with than doing it in a binary module.",
      "created_at": "2022-01-27T15:01:49Z",
      "updated_at": "2022-01-27T15:01:49Z"
    },
    {
      "author": "gogbg",
      "author_association": "NONE",
      "body": "@JustinGrote how can I invoke the cmdlet from binary module in custom ALC in script module for example?\r\nDon't tell me that I have to use implementing type in custom ALC using the powershel/c# syntax please :)",
      "created_at": "2022-01-27T15:17:14Z",
      "updated_at": "2022-01-27T15:21:32Z"
    },
    {
      "author": "JustinGrote",
      "author_association": "CONTRIBUTOR",
      "body": "@gogbg not sure about calling an actual cmdlet but you can get the assembly and types via `alc.LoadFromAssemblyName(assemblyname)`, theoretically I guess you could add-type in the Cmdlet class that way, I don't know, I haven't tried, I've only used it when making a PS module to call .NET types/objects/methods in an ALC, but my function itself still lived in the primary runspace and never returned objects from the ALC.",
      "created_at": "2022-01-27T16:16:05Z",
      "updated_at": "2022-01-27T16:16:05Z"
    },
    {
      "author": "gogbg",
      "author_association": "NONE",
      "body": "@JustinGrote thats what I meant by\r\n> Don't tell me that I have to use implementing type in custom ALC using the powershel/c# syntax please\r\n\r\nThis adds to much complication ",
      "created_at": "2022-01-28T07:31:08Z",
      "updated_at": "2022-01-28T07:31:22Z"
    },
    {
      "author": "JustinGrote",
      "author_association": "CONTRIBUTOR",
      "body": "@gogbg currently it's the only way due to how .NET works, unless you have a better suggestion :)",
      "created_at": "2022-01-28T15:29:26Z",
      "updated_at": "2022-01-28T15:29:26Z"
    },
    {
      "author": "gogbg",
      "author_association": "NONE",
      "body": "@JustinGrote my suggestion is to enhance the language so script module developers can control in which ALC certain modules/scrips/functions should be executed. However my understanding from all the comments above is that this is too complex :(",
      "created_at": "2022-01-28T15:54:50Z",
      "updated_at": "2022-01-28T15:54:50Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "A general solution was proposed in https://github.com/PowerShell/PowerShell-RFC/pull/298 and it was declined. Please see https://github.com/PowerShell/PowerShell-RFC/pull/298#issuecomment-1063574319 for why it was declined.\r\n\r\nBasically, we decide to no longer pursue a general solution, but instead, try to make it easy for a binary module to leverage a custom `AssemblyLoadContext` within itself. The PR https://github.com/PowerShell/PowerShell/pull/16889 is one step toward that (the PR has an example module as a test). We also updated the section [\"Assembly resolving handler for side-by-side loading\"](https://docs.microsoft.com/powershell/scripting/dev-cross-plat/resolving-dependency-conflicts?view=powershell-7.2#assembly-resolving-handler-for-side-by-side-loading) in [this article](https://docs.microsoft.com/powershell/scripting/dev-cross-plat/resolving-dependency-conflicts?view=powershell-7.2) to point to the repo [PowerShell-ALC-Samples](https://github.com/daxian-dbw/PowerShell-ALC-Samples/tree/main/Resolving-Event-with-ALC) that contains the sample code and detailed analysis for the alternative solutions -- I will update the `platyPS` module using  one of the solutions, but it's currently low priority.",
      "created_at": "2022-03-10T02:16:42Z",
      "updated_at": "2022-03-10T02:16:42Z"
    },
    {
      "author": "JustinGrote",
      "author_association": "CONTRIBUTOR",
      "body": "@daxian-dbw if you have a \"hybrid\" module, half binary and half PS script cmdlets, will the ps script cmdlets in module scope resolve the assemblies/types in the module ALC?",
      "created_at": "2022-03-10T04:33:24Z",
      "updated_at": "2022-03-10T04:33:24Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@JustinGrote It is for binary modules. See follow great comment in code https://github.com/PowerShell/PowerShell/blob/25bc64f4b05b4a38858c300864c8f902d6977cc3/src/System.Management.Automation/engine/ExecutionContext.cs#L1281",
      "created_at": "2022-03-10T07:09:19Z",
      "updated_at": "2022-03-10T07:09:19Z"
    },
    {
      "author": "JustinGrote",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov right, but my point is, you can make a binary module that also references scripts. Example:\r\nhttps://github.com/justingrote/powerconfig\r\n\r\nI was just wondering if there was a way for the assemblyresolver to recognize module scope and direct to the ALC for the module for scripts that are also in module scope. This way scripts could reference [mycustomtype] in the ALC and as long as they don't output the type directly but simply consume it, makes that kind of authoring a lot simpler.\n\n<blockquote><img src=\"https://opengraph.githubassets.com/4c4e307bb24919585264444366af73ffe3e9686ef58b31e5aa4c20714de9da42/JustinGrote/PowerConfig\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/JustinGrote/PowerConfig\">GitHub - JustinGrote/PowerConfig: Configure your Script or Module with an overlaying config engine. Uses Microsoft.Extensions.Configuration</a></strong></div><div>Configure your Script or Module with an overlaying config engine. Uses Microsoft.Extensions.Configuration - GitHub - JustinGrote/PowerConfig: Configure your Script or Module with an overlaying conf...</div></blockquote>",
      "created_at": "2022-03-10T16:25:31Z",
      "updated_at": "2022-03-10T16:25:34Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@JustinGrote The PR https://github.com/PowerShell/PowerShell/pull/16889 and actually all the solutions described in [this article](https://docs.microsoft.com/powershell/scripting/dev-cross-plat/resolving-dependency-conflicts?view=powershell-7.2) only take into account a pure binary module. If the script coming with the module only needs to access the types that are owned by the module assemblies (not those from the conflicting dependency assemblies), then they will work as expected, because the module assemblies (referenced by `RootModule` or `NestedModules`) are discoverable to the type resolver.\r\n\r\nHowever, if the module script needs to access types from the conflicting dependencies, all the above solutions won't work, because the conflicting assemblies are intentionally loaded to a separate ALC that is not discoverable to the type resolver, to avoid the type-identity issue.\r\n\r\n> I was just wondering if there was a way for the assemblyresolver to recognize module scope and direct to the ALC for the module for scripts that are also in module scope. This way scripts could reference [mycustomtype] in the ALC and as long as they don't output the type directly but simply consume it, makes that kind of authoring a lot simpler.\r\n\r\nThis is also discussed in the RFC. It requires PowerShell to know that a module is loaded into a custom ALC. We will not pursue a solution for the end user to decide when to do this, but there is still room to discuss whether we can add a new key in the module manifest to allow a module to ask PowerShell to always load it into a custom ALC. If we do that, then PowerShell knows the module is loaded into a custom ALC and can do the following special things (described in the RFC):\r\n- type resolution goes through the custom ALC first\r\n- type loading happening in the module script will be targeting the custom ACL (`Add-Type` can be updated to work this way implicitly, but the assembly loading APIs won't work well, such as `Assembly.LoadFrom` and `Assembly.LoadFile`).\r\n- powershell class needs to be loaded into the custom ACL\r\n\r\nThat would require significant amount of work in PowerShell engine (type caching invalidation is also needed), and there will be lots of corner cases too, for example, the type resolution happening during processing a `type.ps1xml` file of a module will need to be handled specially because technically there is no module scope at that point yet. And even this works, it works under the assumption that the module doesn't expose types from the conflicting dependencies to outside of the module (as parameter type or return type). Even if the module author can make sure the assumption is satisfied, an end user can run arbitrary script in a module scope by `& $moduleInfo { .... }`, so types from conflicting dependencies can still be leaked to outside of the module. So, it won't be a bulletproof solution either.\r\n\r\nThat being said, I think it's interesting to think about this \"add a new key in the module manifest to allow a module to ask PowerShell to always load it into a custom ALC\" idea. It will be much more simplified -- we don't need to add functionalities to make the type-identity issue manageable, neither do we need to worry about the root module issue. Maybe I will reuse some content from https://github.com/PowerShell/PowerShell-RFC/pull/298 to submit another RFC for this, but again, it's low priority.",
      "created_at": "2022-03-10T18:35:42Z",
      "updated_at": "2022-03-11T17:26:24Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> That being said, I think it's interesting to think about this \"add a new key in the module manifest to allow a module to ask PowerShell to always load it into a custom ALC\" idea. It will be much more simplified -- we don't need to add functionalities to make the type-identity issue manageable, neither do we need to worry about the root module issue. Maybe I will reuse some content from [PowerShell/PowerShell-RFC#298](https://github.com/PowerShell/PowerShell-RFC/pull/298) to submit another RFC for this, but again, it's low priority.\r\n\r\nSince this is a fundamental problem stemming from .Net itself, perhaps it should be discussed there instead of here.",
      "created_at": "2022-03-11T04:50:38Z",
      "updated_at": "2022-03-11T04:50:38Z"
    },
    {
      "author": "JustinGrote",
      "author_association": "CONTRIBUTOR",
      "body": "> > That being said, I think it's interesting to think about this \"add a new key in the module manifest to allow a module to ask PowerShell to always load it into a custom ALC\" idea. It will be much more simplified -- we don't need to add functionalities to make the type-identity issue manageable, neither do we need to worry about the root module issue. Maybe I will reuse some content from [PowerShell/PowerShell-RFC#298](https://github.com/PowerShell/PowerShell-RFC/pull/298) to submit another RFC for this, but again, it's low priority.\r\n> \r\n> Since this is a fundamental problem stemming from .Net itself, perhaps it should be discussed there instead of here.\r\n\r\nIn this case all of the implementation would be in Powershell, .NET provides the ALC context and it's just a matter of enabling a whole module to load into its own ALC context, similar to the old assembly plug-in model of .NET framework.",
      "created_at": "2022-03-11T14:56:43Z",
      "updated_at": "2022-03-11T14:56:43Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "Quote from https://github.com/PowerShell/PowerShell/issues/2083#issuecomment-1063583411:\r\n\r\n> I will update the `platyPS` module using one of the solutions, but it's currently low priority.\r\n\r\nThe work has been done to the v2 `platyPS` repo by https://github.com/PowerShell/platyPS/pull/587 and https://github.com/PowerShell/platyPS/pull/588",
      "created_at": "2022-09-08T00:09:18Z",
      "updated_at": "2022-09-08T00:09:18Z"
    }
  ],
  "created_at": "2016-08-26T20:23:15Z",
  "labels": [
    "WG-Engine",
    "Issue-Discussion"
  ],
  "number": 2083,
  "state": "open",
  "title": "Unable to load multiple versions of .Net assembly module dependencies.",
  "updated_at": "2022-09-08T00:09:18Z"
}