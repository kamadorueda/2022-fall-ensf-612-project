{
  "_url": "https://github.com/PowerShell/PowerShell/issues/15848",
  "author": "TobiasPSP",
  "body": "### Summary of the new feature / enhancement\r\n\r\nPowerShell is a object-oriented shell. Programmers are familiar with this concept but admins and occasional scripters often are not. This audience primarily uses simple data types and arrays vs. objects.\r\n\r\nBy providing a new cmdlet `Convert-ObjectToArray`, the complexity of generating own objects would be significantly reduced. For example, a user could calculate a number of results, then \"wrap\" them easily into an object and return structured info from own functions:\r\n\r\n```powershell\r\n$date = Get-Date\r\n$lottery = 1..49 | Get-Random -Count 7\r\n$env:username, $date, $lottery | Convert-ArrayToObject -PropertyName UserName, Drawing, Result\r\n```\r\n\r\nResult:\r\n\r\n```\r\nUserName Drawing             Result             \r\n-------- -------             ------             \r\ntobia    30.07.2021 10:07:00 {10, 48, 42, 11...}\r\n```\r\n\r\nExperienced scripters would benefit as well. Often system calls return unstructured array information. With `Convert-ArrayToObject`, it would intuitively be possible to impose a structure on that data.\r\n\r\nThe following example queries the eventlog for the newest five installed updates. The actual update names and other event information is stored inside \"Properties\" as a simple array.\r\n\r\nBy using `Convert-ArrayToObject`, it would be trivial to impose a meaningful object structure to this array and then emit the result as object:\r\n\r\n```powershell\r\n$filter = @{\r\n    LogName = 'System'\r\n    Level = 4,5\r\n    Id = 19\r\n    ProviderName = 'Microsoft-Windows-WindowsUpdateClient'\r\n}\r\n\r\nGet-WinEvent -FilterHashtable $filter -MaxEvents 5 | \r\n  Select-Object -Property TimeCreated, @{N='Values'; E={ $_.Properties.Value | Convert-ArrayToObject -PropertyName Software,GUID,Code  -DiscardRemaining }} |\r\n  Select-Object -Property TimeCreated -ExpandProperty Values\r\n```\r\n\r\nResult:\r\n\r\n```\r\nSoftware                                                                                         GUID                                 Code TimeCre\r\n                                                                                                                                           ated   \r\n--------                                                                                         ----                                 ---- -------\r\n9NMPJ99VJBWV-Microsoft.YourPhone                                                                 892a7e42-d65a-4114-bb83-516048385d2e    1 30.0...\r\n9WZDNCRDTBJJ-MICROSOFT.GETSTARTED                                                                e70f94da-7a66-4183-92c3-913affb4be81    1 30.0...\r\n9MSPC6MP8FM4-Microsoft.Whiteboard                                                                4618c3a8-72c7-4c6a-93fb-52a0a5bbd1b4    1 30.0...\r\nSecurity Intelligence-Update f\u00fcr Microsoft Defender Antivirus - KB2267602 (Version 1.343.1905.0) c809e399-1a7a-427d-8744-75b8005c5778  200 30.0...\r\nSecurity Intelligence-Update f\u00fcr Microsoft Defender Antivirus - KB2267602 (Version 1.343.1769.0) 6f55ed2a-65fc-4499-8439-9a38d86b9189  200 28.0...\r\n```\r\n\r\n\r\n### Proposed technical implementation details (optional)\r\n\r\n`Convert-ArrayToObject` is no rocket sience but it uses technology not commonly known by the admin audience:\r\n\r\n```powershell\r\n\r\nfunction Convert-ArrayToObject\r\n{\r\n    param\r\n    (\r\n        [Object[]]\r\n        [Parameter(Mandatory,ValueFromPipeline)]\r\n        $InputObject,\r\n  \r\n        [String[]]\r\n        [Parameter(Mandatory)]\r\n        $PropertyName,\r\n        \r\n        [Switch]\r\n        $DiscardRemaining,\r\n        \r\n        [Switch]\r\n        $AsHashtable\r\n    )\r\n  \r\n    begin \r\n    { \r\n        $i = 0 \r\n        $overflow = $false\r\n        $maxPropertyIndex = $PropertyName.Count \r\n        $hashtable = [Ordered]@{}\r\n    }\r\n    process\r\n    {\r\n        $InputObject | ForEach-Object {\r\n            if ($i -lt $maxPropertyIndex -and -not $overflow)\r\n            {\r\n                $hashtable[$PropertyName[$i]] = $_\r\n                $i++\r\n            }\r\n            else\r\n            {\r\n                if ($DiscardRemaining)\r\n                {\r\n                    $overflow = $true\r\n                }\r\n                else\r\n                {\r\n                    if (-not $overflow)\r\n                    {\r\n                        $i--\r\n                        $hashtable[$PropertyName[$i]] = [System.Collections.ArrayList]@($hashtable[$PropertyName[$i]])\r\n                        $overflow = $true\r\n                    }\r\n                    $null = $hashtable[$PropertyName[$i]].Add($_)\r\n                }\r\n            }\r\n        }\r\n    }\r\n    end\r\n    {\r\n        if ($AsHashtable)\r\n        {\r\n            return $hashtable\r\n        }\r\n        else\r\n        {\r\n            [PSCustomObject]$hashtable\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nIt takes an array and a list of property names and turns the array into an object:\r\n\r\n```\r\nPS> 1..3 | Convert-ArrayToObject -PropertyName A,B,C\r\n\r\nA B C\r\n- - -\r\n1 2 3\r\n```\r\n\r\nWhen there are not enough property names, all remaining items go into the last property (similar to how variable assignments work):\r\n\r\n```\r\nPS> 1..10 | Convert-ArrayToObject -PropertyName A,B,C\r\n\r\nA B C              \r\n- - -              \r\n1 2 {3, 4, 5, 6...}\r\n```\r\n\r\nThe switch `-DiscardRemaining` in contrast omits overflow items:\r\n\r\n```\r\nPS> 1..10 | Convert-ArrayToObject -PropertyName A,B,C -DiscardRemaining\r\n\r\nA B C\r\n- - -\r\n1 2 3\r\n```\r\n\r\nOn request, the switch `AsHashtable` returns the composed hashtable without converting it to an object:\r\n\r\n```\r\nPS> 1..10 | Convert-ArrayToObject -PropertyName A,B,C -DiscardRemaining -AsHashtable\r\n\r\nName                           Value                                                                                                              \r\n----                           -----                                                                                                              \r\nA                              1                                                                                                                  \r\nB                              2                                                                                                                  \r\nC                              3 \r\n```\r\n\r\n## Note\r\n\r\nThis cmdlet could obviously be created and maintained in the PowerShell Gallery.\r\n\r\nHowever it is just a generic and useful item like i.e. the new ternary operator. It makes sense only when it is part of the shipping language set and does not add additional module dependencies.\r\n\r\nThe function does not add dependencies to PowerShell and won't enlarge the package. It simply shields the complexity of object generation and hashtables from an entry-level audience and provides experienced scripters with a convenient way of performing every-day tasks.\r\n\r\nDuring code reviews, it turned out that even experienced users often use `Add-Member` to compose objects. `Convert-ArrayToObject` could provide a more appropriate alternative in most of these cases as well.\r\n\r\n## Further Thoughts\r\n\r\nIdeally, `Convert-ArrayToObject` would be accompanied by a corresponding `Convert-ObjectToHashtable` in an effort to better support the conversion of simple data to objects and vice versa:\r\n\r\n```powershell\r\nfunction Convert-ObjectToHashtable\r\n{\r\n    <#\r\n            .SYNOPSIS\r\n            Turns an object into a hashtable.\r\n\r\n            .DESCRIPTION\r\n            When an object is turned into a hashtable, it displays one property per line\r\n            which can be better when you want to output the data in a gridview.\r\n\r\n            .PARAMETER ParentObject\r\n            The object you want to convert\r\n\r\n            .PARAMETER ExcludeEmpty\r\n            Exclude empty properties.\r\n\r\n            .PARAMETER SortProperty\r\n            Sort property names\r\n\r\n            .PARAMETER FlattenArray\r\n            Convert arrays to strings\r\n\r\n            .PARAMETER ArrayDelimiter\r\n            Delimiter used for flattening arrays. Default is comma.\r\n\r\n            .PARAMETER ReturnAsNewObject\r\n            Returns the hashtable as object again with all the requested manipulations in place\r\n\r\n            .EXAMPLE\r\n            Get-ComputerInfo | Convert-ObjectToHashtable -ExcludeEmpty -SortProperty | Out-GridView\r\n            Get computer info and show each property in an individual line in gridview.\r\n            Remove Convert-ObjectToHashTable to see the difference.\r\n    #>\r\n\r\n\r\n    param\r\n    (\r\n        [Parameter(Mandatory,ValueFromPipeline)]\r\n        [Object]\r\n        $ParentObject,\r\n        \r\n        [Switch]\r\n        $ExcludeEmpty,\r\n        \r\n        [Switch]\r\n        $SortProperty,\r\n        \r\n        [Switch]\r\n        $FlattenArray,\r\n        \r\n        [string]\r\n        $ArrayDelimiter = ',',\r\n        \r\n        [Switch]\r\n        $ReturnAsNewObject\r\n    )\r\n    \r\n    process\r\n    {\r\n        $properties = $ParentObject.PSObject.Properties | \r\n            Where-Object { !$ExcludeEmpty -or ![String]::IsNullOrWhiteSpace($_.Value) } \r\n            \r\n        if ($SortProperty)\r\n        {\r\n            $properties = $properties | Sort-Object -Property Name\r\n        }\r\n        \r\n           \r\n        $hashtable = [Ordered]@{}\r\n        foreach($property in $properties)\r\n        {\r\n            if ($property.Value -is [Array] -and $FlattenArray)\r\n            {\r\n                $hashtable.Add($property.Name, $property.Value -join $ArrayDelimiter)\r\n            }\r\n            else\r\n            {\r\n                $hashtable.Add($property.Name, $property.Value)\r\n            }\r\n        }\r\n        \r\n        if ($ReturnAsNewObject)\r\n        {\r\n            [PSCustomObject]$hashtable\r\n        }\r\n        else\r\n        {\r\n            $hashtable\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe use case of the latter function would be a plethora of object manipulation, i.e. the exclusion of empty properties, sorting object properties, and displaying object properties line by line:\r\n\r\n```powershell\r\nGet-Service -Name Spooler | Convert-ObjectToHashtable -ExcludeEmpty -SortProperty | Out-GridView\r\n```\r\n\r\nFor reporting purposes, this could be used to sanitize objects: exclude empty properties, sort property names and work around the issue that CSV and excel do not support arrays by automatically flatten arrays, getting rid of those properties that always contain just type names. \r\n\r\n`-ReturnAsObject` would then return the sanitized hashtable as object, ready to be sent to `Export-Csv` or `Export-Excel`:\r\n\r\n```powershell\r\n#requires -Version 3.0 -Modules ImportExcel\r\n\r\nGet-Service | Convert-ObjectToHashtable -SortProperty -FlattenArray -ArrayDelimiter ' ' -ReturnAsNewObject |\r\n    Export-Excel\r\n```\r\n\r\nThis example creates an excel report and correctly shows dependent services that usually would not show in a readable way. To run this example, you need to install the module *ImportExcel* or replace `Export-Excel` by a default cmdlet such as `Export-Csv`:\r\n\r\n```powershell\r\nInstall-Module -Name ImportExcel -Scope CurrentUser \r\n```\r\n\r\nCaveat: removing empty properties via `-ExcludeEmpty`  is safe only when processing a single object which is why the previous example isn't removing empty properties. In the context of a single object, though, automatically removing empty properties can be very useful, i.e. to focus on ActiveDirectory attributes for a particular user that are actually set:\r\n\r\n```powershell\r\nGet-ADUser -Identity $env:USERNAME -Properties * | \r\n  Convert-ObjectToHashtable -ExcludeEmpty -SortProperty | \r\n  Out-GridView\r\n```\r\nIf you process **multiple** input objects, removing empty properties could lead to objects with less hashtable keys than others. While this isn't bad a priori, when outputting these objects, PowerShell would show only the properties present in the first object it encounters (as always).",
  "closed_at": null,
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Looks to tricky being used broadly. It seems using PS classes is more simple and readable.",
      "created_at": "2021-07-30T10:49:31Z",
      "updated_at": "2021-07-30T10:49:31Z"
    },
    {
      "author": "dennisl68-castra",
      "author_association": "NONE",
      "body": "Why not just store the data in a PSCustomObject in the first place?",
      "created_at": "2021-07-30T14:22:18Z",
      "updated_at": "2021-07-30T14:22:18Z"
    },
    {
      "author": "jdhitsolutions",
      "author_association": "COLLABORATOR",
      "body": "My initial thought was to simply use `[pscustomobject]`. But I think what I think Tobias is going after is the less scripting proficient PowerShell user who wants to do this on the fly in the console. Although I don't see what is that difficult with this syntax, once you learn it of course.\r\n\r\n```powershell\r\n$date = Get-Date\r\n$lottery = 1..49 | Get-Random -Count 7\r\n[pscustomobject]@{Username = $env:username; Drawing= $date;Result = $lottery}\r\n```",
      "created_at": "2021-07-30T16:56:33Z",
      "updated_at": "2021-07-30T16:56:33Z"
    },
    {
      "author": "TobiasPSP",
      "author_association": "COLLABORATOR",
      "body": "> Looks to tricky being used broadly. It seems using PS classes is more simple and readable.\r\n\r\njdhitsolutions got the idea. Classes are natural to programmers, not ITPro. PowerShell was not designed to be yet another programming language. It was invented to be a practical scripting language with a low entry point for ITPros. They need a simple way to wrap information into objects. Classes are way out of scope to this audience.\r\n\r\nThat said, I am more than open and curious for other approaches as long as they do the job. Can you (iSazonov) elaborate how you think classes could help here, and how the suggested approach is trickier than using classes? \r\n\r\nPlease consider that we are not in a situation where we own software projects and can design classes and constructors. In the intended target group you have to deal with raw information from a number of sources that are beyond own control, and need a way to wrap them into objects without knowing more than the most basic programming principles.",
      "created_at": "2021-07-30T17:48:57Z",
      "updated_at": "2021-07-30T17:49:39Z"
    },
    {
      "author": "dennisl68-castra",
      "author_association": "NONE",
      "body": "PowerShell already support using and creating classes out of the box.\r\n\r\n[about_Classes](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes?view=powershell-7.1)",
      "created_at": "2021-07-30T17:54:45Z",
      "updated_at": "2021-07-30T17:54:45Z"
    },
    {
      "author": "TobiasPSP",
      "author_association": "COLLABORATOR",
      "body": "> Why not just store the data in a PSCustomObject in the first place?\r\n\r\nThat's a great comment. Most advanced scripters do. But as code review shows, even advanced programmers frequently resort to inappropriate ways like using `Add-Member` to create simple data objects. Entry-level and occasional scripters, which are the primary target group for this suggestion, almost never use [PSCustomObject] simply because they don't know or care much about types and hashtables.\r\n\r\nBasically, anything can be done in PowerShell via direct .NET and types. The ease of use of PowerShell however comes from generic cmdlets which by design shield .NET from the user. So one could argue that we could get rid of all cmdlets since the same can always be done using underlying .NET ;-). So I guess it's a matter of evaluating whether a given cmdlet is simple and reusable enough to be of value, not whether it is unique in what it does.",
      "created_at": "2021-07-30T17:57:18Z",
      "updated_at": "2021-07-30T17:57:18Z"
    },
    {
      "author": "dennisl68-castra",
      "author_association": "NONE",
      "body": "[PSCustomObjects] isn't very hard.\r\nIt just needs to be documented properly in various places (i.e. help Add-Member etc.).\r\nSeveral years passed before I encountered\r\n`$result = New-Object psobject | select Property1, Property2, Property3`",
      "created_at": "2021-07-30T18:07:10Z",
      "updated_at": "2021-07-30T18:07:10Z"
    },
    {
      "author": "TobiasPSP",
      "author_association": "COLLABORATOR",
      "body": "> Although I don't see what is that difficult with this syntax, once you learn it of course.\r\n\r\nI guess it is a question of how deep you want users to dive into programming. I like to view PowerShell as a video game with different levels. In level 1 you learn how to discover and run individual commands, and in level 2 you learn how to couple multiple commands using pipeline and variables. These two levels are where most ITPro live that I encounter in the IT departments I visit every week, so to help them, new tools need to be in these levels.\r\n\r\nLevel 3 would involve hashtables and types, so yes you can argue that users should be at least educated to level 3 to make use of structured output. However my experience is that level 3 is a barrier for many because it also marks the transition from batch scripters to programmers.\r\n\r\nI am not hurt in any way if it turned out I am the only one thinking this way ;-). I do have the feeling though that PowerShell is moving away from its original user base, and I suspect this is because most people actively involved in its development seem to be developers or experienced scripters these days. \r\n",
      "created_at": "2021-07-30T18:08:24Z",
      "updated_at": "2021-07-30T18:08:24Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "I agree that there should be more options for transforming input into objects.  I do worry that this particular design would lead to a lot of enumeration related confusion, especially for the type of folks this would be targeting.\r\n\r\nEither way since this can be done at the command level it would be good to prove the concept with a gallery module like was done with `PSThreadJob`.",
      "created_at": "2021-07-30T18:39:31Z",
      "updated_at": "2021-07-30T18:39:31Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "This request has quiet some similarities with [`#13817` Enhance hash table syntax](https://github.com/PowerShell/PowerShell/issues/13817)\r\nand the suggested [`Join-Object`](https://www.powershellgallery.com/packages/JoinModule/3.5.2) in issue: [`#14994` Add a Join-Object cmdlet to the standard PowerShell equipment](https://github.com/PowerShell/PowerShell/issues/14994) (including the linked issues within)\r\n\r\n```PowerShell\r\n$env:username |Join $date |Join (,$Lottery) -Name UserName, Drawing, Result\r\nUserName Drawing              Result\r\n-------- -------              ------\r\nuser     7/30/2021 8:13:03 PM {2, 30, 4, 5\u2026}\r\n```\r\n\r\nNote the unary comma for the `$lottery` value as you probably also want to be able to a side-by-side [`paste`](https://www.geeksforgeeks.org/paste-command-in-linux-with-examples/) of arrays:\r\n\r\n```PowerShell\r\n$env:username |FullJoin @(1..7) |Join $Lottery -Name UserName, Index, Drawing\r\nUserName Index Drawing\r\n-------- ----- -------\r\nuser         1       2\r\n             2      30\r\n             3       4\r\n             4       5\r\n             5      26\r\n             6      12\r\n             7      32\r\n```\r\n\r\nWhat they all (including the linked cases) have in common, is the search for a syntactic way to **transpose** data: move rows to columns (objects to properties) and/or vice versa.\r\nSaying that, I think if you would just change the name of you purposed cmdlet to `ConvertTo-Property` it will have  a more general perspective. Also knowing that you actually not converting an array but convert *each* ([singular](https://docs.microsoft.com/powershell/scripting/developer/cmdlet/strongly-encouraged-development-guidelines#use-singular-parameter-names)) `$InputObject`  to a property.",
      "created_at": "2021-07-30T18:43:24Z",
      "updated_at": "2021-07-30T18:43:24Z"
    },
    {
      "author": "rw-hardin",
      "author_association": "NONE",
      "body": "I use Powershell daily, both in complex scripts/automation and in one-line commands.....and everywhere in between. Personally, I think this is amazing. There have been a ton of times where I needed to put together some data that would only be used once or twice (making writing some advanced script take more time than just doing it all by hand), as well as converting objects into a decent output to be consumed by another cmdlet or even just dumped out to a file. \r\n\r\nBoth of the functions in this suggestion would definitely be time-saving for ITPros at all levels. Those of us that taught ourselves how to use classes and complexity in Powershell, as well as those who have no idea how to do more than a single one-liner. ",
      "created_at": "2021-07-30T20:55:38Z",
      "updated_at": "2021-07-30T20:55:38Z"
    },
    {
      "author": "dennisl68-castra",
      "author_association": "NONE",
      "body": "I really doesn't see the issue.\r\nThe example is quite doable as is in PowerShell\r\n\r\n```\r\n$date = Get-Date\r\n$lottery = 1..49 | Get-Random -Count 7\r\n$drawing = New-Object pscustomobject | select UserName, Drawing, Result\r\n\r\n$drawing.UserName = $env:USERNAME\r\n$drawing.Drawing = $date\r\n$drawing.Result = $lottery\r\n\r\nPS C:\\> $drawing\r\n\r\nUserName Drawing             Result\r\n-------- -------             ------\r\ndennis   2021-07-30 23:36:43 {40, 4, 46, 14\u2026}\r\n```",
      "created_at": "2021-07-30T21:44:38Z",
      "updated_at": "2021-07-30T21:44:38Z"
    },
    {
      "author": "rw-hardin",
      "author_association": "NONE",
      "body": "Still more complex than what was suggested. What would be the downside to including it as an enhancement?",
      "created_at": "2021-07-30T21:58:17Z",
      "updated_at": "2021-07-30T21:58:17Z"
    },
    {
      "author": "rw-hardin",
      "author_association": "NONE",
      "body": ">  I do have the feeling though that PowerShell is moving away from its original user base, and I suspect this is because most people actively involved in its development seem to be developers or experienced scripters these days.\r\n\r\n@TobiasPSP I 100% agree, I love the complexity that has been added over the years, because Powershell can now do so much more than when I first touched it way back....but if something like this sort of suggestion is scoffed at...\r\n\r\nI was actually relieved when I saw the simplicity of this suggestion. Yes, we can create custom objects, or use the code in the function itself if we wanted to. But I've found myself trying to combine different arrays or hashtables into a single object (usually for a report or some such) before, and it always involves spending time coding/testing/retesting/etc. I know many ops people that would love to have this so they can get those reports for the audit guys breathing down their necks. \r\n\r\nJust my 2 cents. Not worth terribly much, of course.",
      "created_at": "2021-07-30T22:11:02Z",
      "updated_at": "2021-07-30T22:11:02Z"
    },
    {
      "author": "dennisl68-castra",
      "author_association": "NONE",
      "body": "Ok, now I see the issue. But in a wider perspective.\r\n\r\nThe example provided isn't very complicated if hitting [pscustomobject] to begin with.\r\nBut if you consider you actually need to transpose data between objects, then I think what we are actually looking for is the Join-Object suggestion.\r\n\r\nTo wrap my head around the actual data conversion I tried out a oneliner.\r\n(I'm still using a psobject on the receiving end, not a hashtable)\r\nIt got kind a' ugly ;)\r\n\r\n```\r\n# Create the objects\r\n$name = $ENV:USERNAME\r\n$date = Get-Date\r\n$lottery = 1..49 | Get-Random -Count 7\r\n\r\n$drawing = New-Object pscustomobject | Select Username, Drawing, Result\r\n\r\n# Transpose in one line\r\n$nul,@($name,$date,$lottery) | #need a multidimensional array to get the correct count to carry over \r\n    foreach {\r\n        $pipecount = $_.count; \r\n        for ($i=0; $i -lt $pipecount; $i++){\r\n            ($drawing.psobject.properties | select -index $i).value = $_[$i]\r\n        }\r\n    }\r\n\r\n# Output the result\r\n$drawing\r\n\r\nUsername Drawing             Result\r\n-------- -------             ------\r\nsven     2021-07-31 02:25:03 {10, 39, 25, 18\u2026}\r\n```",
      "created_at": "2021-07-31T00:27:55Z",
      "updated_at": "2021-07-31T00:37:42Z"
    },
    {
      "author": "Paxxi",
      "author_association": "NONE",
      "body": "I like this idea and I think it would be great for all experience levels. Having a cmdlet for it means it's more discoverable and more natural to use, especially in oneliners.\r\n\r\nThe naming is good from a discoverability perspective as it will be easy to find on your favorite search engine. It does feel \"wrong\" when looking at the current cmdlets and their naming as it doesn't follow the verb-noun style.\r\n\r\nHow about naming it `ConvertTo-Object` to fit into the naming style? It would make it natural to also have a `ConvertFrom-Object` that does the opposite transformation. The downside is that it might be less discoverable on the name alone.\r\n\r\n```powershell\r\nfunction ConvertTo-Object\r\n{\r\n    param\r\n    (\r\n        [Object[]]\r\n        [Parameter(Mandatory,ValueFromPipeline, ParameterSetName=\"Array\")]\r\n        $InputArray,\r\n  \r\n        [String[]]\r\n        [Parameter(Mandatory, ParameterSetName=\"Array\")]\r\n        $PropertyName,\r\n        \r\n        [Switch]\r\n        [Parameter(ParameterSetName=\"Array\")]\r\n        $DiscardRemaining,\r\n        \r\n        [Switch]\r\n        [Parameter(ParameterSetName=\"Array\")]\r\n        $AsHashtable,\r\n\r\n        [HashTable]\r\n        [Parameter(Mandatory,ValueFromPipeline, ParameterSetName=\"HashTable\")]\r\n        $InputHashTable,\r\n\r\n        [System.Collections.Specialized.OrderedDictionary]\r\n        [Parameter(Mandatory,ValueFromPipeline, ParameterSetName=\"OrderedHashTable\")]\r\n        $InputOrdered,\r\n\r\n        [String[]]\r\n        [Parameter(Mandatory=$false, ParameterSetName=\"OrderedHashTable\")]\r\n        $PropertyName,\r\n    )\r\n...\r\n}\r\n```\r\n\r\nI don't know if that design is technically feasible but it should get the idea across at least. The PropertyName parameter for OrderedDictionary would be to allow renaming properties. I don't think it would be sensible to have that for a HashTable as it would be unpredictable and confusing.\r\n\r\nA `ConvertFrom-Object` could look something like this\r\n```powershell\r\nfunction ConvertFrom-Object\r\n{\r\n    param\r\n    (\r\n        [Object]\r\n        [Parameter(Mandatory,ValueFromPipeline)]\r\n        $InputObject,\r\n        \r\n        [Switch]\r\n        [Parameter(ParameterSetName=\"HashTable\")]\r\n        $AsHashtable,\r\n\r\n        [Switch]\r\n        [Parameter(ParameterSetName=\"Array\")]\r\n        $AsArray\r\n    )\r\n...\r\n}\r\n```\r\n\r\n",
      "created_at": "2021-07-31T09:13:24Z",
      "updated_at": "2021-07-31T09:13:24Z"
    },
    {
      "author": "TobiasPSP",
      "author_association": "COLLABORATOR",
      "body": "Thank you all so much for sharing thoughts. I am trying to sum a number of things up. Let me know if I missed anything.\r\n\r\n## Proposal\r\n\r\nAdd one or more cmdlets to expose object manipulation on discoverable cmdlet level rather than having to use .NET, type conversion, or classes:\r\n\r\n- Convert unstructured data (arrays) to objects/hashtables\r\n- Convert hashtables to objects\r\n- Convert objects to hashtables\r\n- Merge objects\r\n\r\n## Why is that needed?\r\n\r\nOccasional scripters work on cmdlet level and typically have no deep knowledge about types, hashtables, let alone classes. Even experienced scripters seem to often use `Add-Member` to compose simple data objects (rather than using [PSCustomObject] or classes) - likely because `Add-Member` is the only discoverable cmdlet in PowerShell that creates new objects (aside from `Select-Object` which isn't really appropriate in this context).\r\n\r\nThere is currently no intuitive self-learning path to go beyond `Add-Member` on cmdlet level.\r\n\r\nAll other techniques for object creation - however simple they may be - require extra knowledge, i.e. about hashtables or classes, which is an extra barrier for novice users still trying to cope with cmdlets and parameters. \r\n\r\nExperienced users can benefit from these cmdlets, too, as their feature set spans a very powerful range and allows for advanced object manipulation (i.e. sorting properties, removing empty values, merging objects). \r\n\r\n## Is this functionality really needed?\r\n\r\nAnything the proposed cmdlets do can be done via direct .NET access (type conversion, classes). So once you know how to create new objects via [PSCustomObject] or via classes, it is not much more complicated than using the proposed cmdlets.\r\n\r\nYet this proposal was not about teaching PowerShell new tricks in the first place. It is a proposal to lower the barrier for entry-level or occational scripters, and provide generic solutions for common object manipulation tasks.\r\n\r\nThis approach is in good tradition with existing cmdlet design. Cmdlets often exist just to be discoverable or shield the user from .NET. Compare `Get-Alias` with `Get-ChildItem -Path alias:`, same with `Get-Variable`. Look at `Get-Date`: `[DateTime]::Now` isn't hard, either. 'Get-Date -Format yyyyMMdd' could as well be replaced by `[DateTime]::Now.ToString('yyyyMMdd')`. `Get-Process` could be replaced by equally simple `[System.Diagnostics.Process]::GetProcesses()`, etc. pp.\r\n\r\nAnd still there is consensus that it is a great thing that `Get-Date`, `Get-Process` and other cmdlets exist even though they don't really do anything new. Cmdlets exist to be discoverable and versatile.\r\n\r\n## How expensive is it?\r\n\r\nImplenting the proposed cmdlets is trivial from an engineering point of view. There are no dependencies nor would the package grow. All proof-of-concept functions in this thread are short functions which essentially just wrap a discoverable user interface around the existing PowerShell capabilities.\r\n\r\n## Next steps\r\n\r\nI'd suggest to collect the functionality commonly needed to convert unstructured data to structured data and vice versa. Once we know what the feature set should be, we can start composing a cmdlet family and think about naming.\r\n\r\n## Prerequisites\r\n\r\nA prototype module can be developed and hosted on github and the gallery so everyone was invited to add ideas or participate in dev or testing. \r\n\r\nPrereq would be that we get a general thumbs up from the PowerShell working group that ultimately this module can become part of the shipping modules. The proposed cmdlets make no sense if they stay put in a 3rd party module since the target group isn't familiar with the gallery and shouldn't be discriminated in a way that their scripts would only run with a 3rd party helper module being installed.\r\n",
      "created_at": "2021-07-31T11:31:01Z",
      "updated_at": "2021-07-31T11:34:58Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/wg-powershell-cmdlets discussed this and agreed with the scenario of making custom object creation easier for new users particularly from a discovery point of view.  We propose a change to `New-Object` parameter set that takes a hashtable and emit a PSCustomObject.  This is more discoverable than casting a hashtable to a `[PSCustomObject]` for new users.  A `-TypeName` taking an array of strings should also be considered for custom typing (used with formatting).  This should be a bucket 3 breaking change where currently a hashtable doesn't emit something useful used with `New-Object`",
      "created_at": "2021-11-19T23:08:07Z",
      "updated_at": "2021-11-19T23:08:07Z"
    },
    {
      "author": "IISResetMe",
      "author_association": "COLLABORATOR",
      "body": "Pardon my ignorance but... doesn't that already exist @SteveL-MSFT?\r\n\r\n```\r\nPS ~> New-Object -Property @{ A = 1; B = 2; C = 3 } -TypeName PSCustomObject\r\n\r\nA B C\r\n- - -\r\n1 2 3\r\n```",
      "created_at": "2021-12-01T18:58:56Z",
      "updated_at": "2021-12-01T18:58:56Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "It does also support `PSTypeName`, e.g.\r\n\r\n```ps1\r\nNew-Object psobject -Property @{\r\n    PSTypeName = 'CountingInfo'\r\n    A = 1\r\n    B = 2\r\n    C = 3\r\n}\r\n```\r\n\r\nThough if you need property order to be retained you do need `([ordered]@{ ... })`.",
      "created_at": "2021-12-01T19:28:50Z",
      "updated_at": "2021-12-01T19:28:50Z"
    },
    {
      "author": "TobiasPSP",
      "author_association": "COLLABORATOR",
      "body": "> Pardon my ignorance but... doesn't that already exist @SteveL-MSFT?\r\n> \r\n> ```\r\n> PS ~> New-Object -Property @{ A = 1; B = 2; C = 3 } -TypeName PSCustomObject\r\n> \r\n> A B C\r\n> - - -\r\n> 1 2 3\r\n> ```\r\n\r\nYou are absolutely right, the original issue title is a bit misleading, and initially this was about a new cmdlet family for a broad range of data-to-object manipulation (and vice versa). In the course of debate here, a number of low hanging fruit were identified that could easily be integrated into the existing New-Object cmdlet.",
      "created_at": "2021-12-02T05:36:32Z",
      "updated_at": "2021-12-02T05:36:32Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> In the course of debate here, a number of low hanging fruit were identified that could easily be integrated into the existing New-Object cmdlet.\r\n\r\nMaybe open new issue with clear proposal?",
      "created_at": "2021-12-02T10:29:56Z",
      "updated_at": "2021-12-02T10:29:56Z"
    },
    {
      "author": "IISResetMe",
      "author_association": "COLLABORATOR",
      "body": "Thanks for the clarification @TobiasPSP. \r\n\r\nI think it makes perfect sense to\r\n\r\n1. Add pipeline support for the `-Property` dictionary so you could do:\r\n\r\n```\r\n$data = @(\r\n  [ordered]@{ A = 1; B = 2; C = 3 }\r\n  [ordered]@{ A = 1; B = 3; C = 5 }\r\n  [ordered]@{ A = 1; B = 4; C = 7 }\r\n)\r\n\r\n$objects = $data |New-Object\r\n```\r\n\r\n2. Make `-TypeName` default to `PSCustomObject` when absent",
      "created_at": "2021-12-02T12:03:48Z",
      "updated_at": "2021-12-02T12:03:48Z"
    }
  ],
  "created_at": "2021-07-30T08:25:04Z",
  "labels": [
    "Issue-Enhancement",
    "WG-Cmdlets",
    "Up-for-Grabs"
  ],
  "number": 15848,
  "state": "open",
  "title": "Add parameterset to `New-Object` to accept hashtable and emit PSCustomObject",
  "updated_at": "2021-12-02T12:03:49Z"
}