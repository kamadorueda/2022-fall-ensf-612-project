{
  "_url": "https://github.com/PowerShell/PowerShell/issues/12305",
  "author": "schuelermine",
  "body": "# Summary of the new feature/enhancement\r\n\r\n## Motivation\r\n\r\nCmdlets such as `Start-Sleep` offer both `-Seconds` and `-Milliseconds` as parameters.\r\nThis style of time input is functional, but has a few issues:\r\n- Expanding the number of units requires updating the argument handling and the function body itself\r\n- Implementation in custom scripts or cmdlets requires boilerplate\r\n- Available options may not be consistent across cmdlets\r\n\r\n## Proposed solution\r\n\r\nA new syntax expansion that adds support for `TimeSpan` literals, and cmdlets such as `Start-Sleep` accepting `TimeSpan` objects by default.\r\nThis entails adding new suffixes to numeric literals as [described here](https://docs.microsoft.com/en-us/powershell/module/Microsoft.PowerShell.Core/About/about_numeric_literals?view=powershell-7)\r\n\r\nPreliminary list of suffixes:\r\n- `min` minutes\r\n- `sec` seconds\r\n- `ms` milliseconds\r\n- `tick` ticks\r\n- `h` hours\r\n- `day` days\r\n- `year` years (365 days, notably debatable due to calendar and culture issues)\r\n\r\n### Examples:\r\n\r\nItems in each line are equivalent:\r\n\r\n`10sec` = `New-TimeSpan -Seconds 10` = `[TimeSpan]100000000`\r\n`15min` = `New-TimeSpan -Minutes 15` = `[TimeSpan]9000000000`\r\n`0xFFyear` = `New-TimeSpan -Days (0xFF * 365)` = `[TimeSpan]80416800000000000`\r\n\r\n### Advantage over `New-TimeSpan`\r\n\r\nThis solution is significantly more concise than using `New-TimeSpan` (see above).\r\nThe semantics of this method are more clear, as cmdlets with the `New` verb are usually used in variable assignments, i.e. for persistent objects.\r\n\r\n### Considerations\r\n\r\n`Start-Sleep`'s parameter structure must be updated. Ideally, a non-`TimeSpan` input should be interpreted as seconds, while explicitly providing the suffixes remains possible.\r\nThese suffixes ideally do not interfere with the existing suffixes, as the types of the numbers would already be determined by the time unit. For example, `tick` will always be `Int64` (or in case of future changes the type used for `TimeSpan`'s `Ticks` property)\r\n\r\n# Postscriptum\r\n\r\nThis issue pairs well with issue #10712.",
  "closed_at": null,
  "comments": [
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I like the idea as a whole, it'd be nice to have a built in way to reference simple time spans. For the suffixes, I think a couple of them are a bit longer than necessary, though?\r\n\r\n* `tk` ticks\r\n* `dy` days\r\n\r\nAs you mention, years is problematic and I'd be tempted to simply not include a builtin for it. Even in Western calendars, the length of a year varies a decent amount at the best of times, not to mention leap years.\r\n\r\nIn terms of the impact of the change on existing scripts, though... any new number literals we add will restrict the pool of available command names slightly. If someone already has a command named (for example) `50ms`, that command name will no longer resolve by default, and could only be called via the `&` operator.\r\n\r\nI don't know if using this kind of command name is common or not, but it's also worth noting that users do have the ability to override `CommandNotFoundAction` and could be using that to imitate this kind of functionality.\r\n\r\nOn a more implementation focus, would you expect such suffixes to be able to be combined with some other suffix(es)? We have both type suffixes and multiplier suffixes already. I'd imagine multiplier suffixes make the most sense in terms of allowing them to be combined... ",
      "created_at": "2020-04-12T20:18:14Z",
      "updated_at": "2020-04-12T20:18:14Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "Not sure about the need for ticks but I like the idea in general. Here's an example in a language (C++) that has done something similar with `std::literals::chrono_literals`:\r\n\r\n![image](https://user-images.githubusercontent.com/5177512/79079515-d19b2600-7ccc-11ea-9021-499c66b2a31e.png)\r\n\r\nFrom https://en.cppreference.com/w/cpp/chrono/duration\r\n\r\nAn associated issue is that TimeSpan really needs more user-friendly output - perhaps humanized.  Ideally, a single line of information:\r\n```\r\n1 second, 523 milliseconds\r\n# or\r\n1.523 seconds\r\n```\r\n as opposed to this:\r\n```\r\nDays              : 0\r\nHours             : 0\r\nMinutes           : 0\r\nSeconds           : 1\r\nMilliseconds      : 523\r\nTicks             : 15230000\r\nTotalDays         : 1.76273148148148E-05\r\nTotalHours        : 0.000423055555555556\r\nTotalMinutes      : 0.0253833333333333\r\nTotalSeconds      : 1.523\r\nTotalMilliseconds : 1523\r\n```",
      "created_at": "2020-04-12T20:54:56Z",
      "updated_at": "2020-04-12T23:08:37Z"
    },
    {
      "author": "schuelermine",
      "author_association": "CONTRIBUTOR",
      "body": "Adding to the point about readability of the output of `TimeSpan` - why does `Ticks` not follow the rest of the properties' patterns of having an `X` and a `TotalX` property? It would perhaps be more appropriate to have `Ticks` represent the part of the time span that's smaller than one millisecond, and `TotalTicks` represent what `Ticks` currently represents. Maybe that's reaching a bit, though.",
      "created_at": "2020-04-12T22:25:08Z",
      "updated_at": "2020-04-12T22:25:08Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "That's a different issue entirely, and one that comes from .NET Core; PowerShell really has no say in the matter there (short of adding our own implementation of TimeSpan and deviating from the standard).\r\n\r\nBest guess: `Ticks` is the underlying value in all cases, it's what `TimeSpan` actually _is_ on a fundamental level. The other properties are essentially just shortcuts so you don't have to bother figuring out the math yourself. Most folks using `TimeSpan` probably don't see a need for \"ticks remaining after calculating the rest of the properties\" sort of value.",
      "created_at": "2020-04-12T22:46:27Z",
      "updated_at": "2020-04-12T22:46:27Z"
    },
    {
      "author": "schuelermine",
      "author_association": "CONTRIBUTOR",
      "body": "Sounds plausible. When converting to a `TimeSpan` object, the value given in Integer form becomes the new tick count, after all.\r\n\r\nOn an unrelated note, since I'm new to open-source contributing in general, should I incorporate the suggestions posted here into the issue body, or is the intention that you read the whole thread to get the picture? Or should I wait until there's actual code to debate about?",
      "created_at": "2020-04-12T23:00:11Z",
      "updated_at": "2020-04-12T23:00:11Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@schuelermine Right workflow is to create new RFC for New-TimeSpan cmdlet in PowerShell-RFC repository. Please do not add other proposals in the RFC to get fast progress.\r\n",
      "created_at": "2020-04-13T07:07:35Z",
      "updated_at": "2020-04-13T07:07:59Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@iSazonov what does New-TimeSpan have to do with this, exactly?",
      "created_at": "2020-04-13T11:54:31Z",
      "updated_at": "2020-04-13T11:54:31Z"
    },
    {
      "author": "schuelermine",
      "author_association": "CONTRIBUTOR",
      "body": "As far as I can see, PowerShell-RFC doesn't require specifying a cmdlet for RFCs anyways.\r\n\r\nI'm working on an RFC draft right now.",
      "created_at": "2020-04-13T12:12:06Z",
      "updated_at": "2020-04-13T12:12:06Z"
    },
    {
      "author": "schuelermine",
      "author_association": "CONTRIBUTOR",
      "body": "Link to RFC draft pull request: https://github.com/PowerShell/PowerShell-RFC/pull/246",
      "created_at": "2020-04-13T12:49:00Z",
      "updated_at": "2020-04-13T12:57:00Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> In terms of the impact of the change on existing scripts, though... any new number literals we add will restrict the pool of available command names slightly. If someone already has a command named (for example) `50ms`, that command name will no longer resolve by default, and could only be called via the `&` operator.\r\n\r\nDoes it make sense to think about a potential \"literal\" operator?  There's a ton of potential for new post fix operators that don't tend to go anywhere because of this.\r\n\r\nNo idea what symbol would make sense and not have the same problem though.  For some reason I like the idea of `~10sec`, but that can currently be a command as well and makes me read it as \"about 10 seconds\".",
      "created_at": "2020-04-13T13:16:26Z",
      "updated_at": "2020-04-13T13:16:26Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "Also FWIW there is a string format you can *currently* pass to parameters typed as `TimeSpan`.  A literal would definitely be more desirable, but since this isn't super commonly known here's some examples:\r\n\r\n```powershell\r\nfunction Test-TimeSpan {\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Position = 0)]\r\n        [timespan] $TimeSpan\r\n    )\r\n    end {\r\n        return $TimeSpan\r\n    }\r\n}\r\n\r\nfilter Format-TimeSpan {\r\n    $format = '{0:%d} Day(s), {0:%h} Hour(s), {0:%m} Minute(s), {0:%s} Second(s), {0:fff} Millisecond(s)'\r\n    return ($format -f $PSItem) -replace '0+(?=\\d+ Millisecond)', ''\r\n}\r\n\r\nTest-TimeSpan 10.23:59:59.999 | Format-TimeSpan\r\n# 10 Day(s), 23 Hour(s), 59 Minute(s), 59 Second(s), 999 Millisecond(s)\r\n\r\nTest-TimeSpan 10.0:30 | Format-TimeSpan\r\n# 10 Day(s), 0 Hour(s), 30 Minute(s), 0 Second(s), 0 Millisecond(s)\r\n\r\nTest-TimeSpan 0:30 | Format-TimeSpan\r\n# 0 Day(s), 0 Hour(s), 30 Minute(s), 0 Second(s), 0 Millisecond(s)\r\n\r\nTest-TimeSpan 0:0:.001 | Format-TimeSpan\r\n# 0 Day(s), 0 Hour(s), 0 Minute(s), 0 Second(s), 1 Millisecond(s)\r\n```",
      "created_at": "2020-04-13T14:02:39Z",
      "updated_at": "2020-04-13T14:02:39Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> As far as I can see, PowerShell-RFC doesn't require specifying a cmdlet for RFCs anyways.\r\n\r\n@schuelermine I ask you as maintainer and based on my experience. The new cmdlet looks very \"powershelly\" and can be approved very fast by PowerShell Committee. But other proposals are controversial and you will be doomed to wait a very long time (see other RFCs). So I suggest to create simple RFC for the cmdlet and move other proposal in another RFC.\r\n",
      "created_at": "2020-04-14T04:29:35Z",
      "updated_at": "2020-04-14T04:29:35Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "If someone wants to tackle this hopeless topic (Timespan formatting), see # 2595 and related draft PR.\r\n",
      "created_at": "2020-04-14T04:36:16Z",
      "updated_at": "2020-04-14T04:36:16Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Does it make sense to think about a potential \"literal\" operator? There's a ton of potential for new post fix operators that don't tend to go anywhere because of this.\r\n\r\nAh, every time I think about this I come back to \"prefix\" pattern. \r\nFor me this looks very \"powershelly\":\r\n```powershell\r\n[Second]12\r\n[sec]15\r\n[Day]3\r\n[Minute]59\r\n[min]59\r\n[hour]23\r\n[week]10\r\n[century]20\r\n```",
      "created_at": "2020-04-14T04:45:41Z",
      "updated_at": "2020-04-14T04:45:41Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "Observations\r\n\r\n1.  Currently the only Function or cmdlet with a seconds parameter appears to be start-sleep (based on  `get-command -Type Cmdlet,Function | where {$_.Parameters -and $_.parameters.ContainsKey(\"seconds\")}` \r\n2.  Piping a timespan object into something with a seconds parameter with accept pipeline by property name will give the wrong result, timespan seconds is an int from 0 to 59, \r\n3.  An **argument transformer** class could, quite easily, change any value passed to seconds as a timespan type to its TotalSeconds  property. \r\n4.  Such a class would be available to other cmdlets and functions which wanted to use it (but would likely need to be available to load independently so they would not be dependent on a new version of pwsh)\r\n",
      "created_at": "2020-04-14T10:08:25Z",
      "updated_at": "2020-04-14T10:08:25Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "\r\n> Does it make sense to think about a potential \"literal\" operator? There's a ton of potential for new post fix operators that don't tend to go anywhere because of this.\r\n\r\nPersonally I would say \"no\"\r\nToday only one built in command takes a -Seconds  parameter, and that is Start-Sleep. I suspect there are more in other modules, especially where one is adding a time out. \r\nTo date, **people have managed** to write 300 for 5 minutes, or 30 for 0.5 minutes, and it hasn't been a great problem (yes, I know, \"we've always done it that way\" is the worst reason ever)\r\n\r\nTaking an existing function which has a -Timeout parameter and allowing the user to write \r\n`Invoke-MyOldFunction -Timeout 2m`\r\nWill simply break that function as it does not expect a TimeSpan object - this happens now when a timespan is passed to Start-Sleep.     \r\nFor a **small amount of effort saved** writing   \r\n`-Timeout ($m * 60)`  or `-Timeout ($h * 3600)`      \r\n**more effort will be needed** to remove `[int]` from timeout parameters and change     \r\n`$endtime = $now.addSeconds($timeout)`     \r\nstatements  to    \r\n`If ($timeout -is [timespan]) {$endTime = $now.add($timeout)} else { ....` etc\r\n\r\nEven adding a transform class to turn timespans into total seconds  would require re-coding. Since we can be fairly sure that   \r\n(a) Commands will need to keep accepting seconds as a number, to work with existing scripts and   \r\n(b) some commands won't be updated,    \r\n**the smart thing for users to do is to continue to use seconds** even if this is adopted. \r\n\r\n**If literals are to be used** then **PLEASE** use the same naming as already applies to formatting strings, i.e. s or ss for second, m or mm for minute, h or hh for hours (should be no need for H/HH which is 24 hour clock while h/hh is 12 hour). d / dd for day.  yy for year. (Year and Day are needed when specifying things like -MaximumAge, not so much for Sleep :-) )   Milliseconds and ticks can be expressed either as seconds or using f for fraction. \r\n\r\n\r\n\r\n",
      "created_at": "2020-04-14T10:42:09Z",
      "updated_at": "2020-04-14T10:42:09Z"
    },
    {
      "author": "schuelermine",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov OK, I'm making a second RFC for just adding `TimeSpan` support to `Start-Sleep`",
      "created_at": "2020-04-14T11:51:28Z",
      "updated_at": "2020-04-14T11:51:28Z"
    },
    {
      "author": "schuelermine",
      "author_association": "CONTRIBUTOR",
      "body": "@jhoneill I don't quite follow the last paragraph. Could you list your proposed suffixes and their uses?",
      "created_at": "2020-04-14T11:52:18Z",
      "updated_at": "2020-04-14T11:52:18Z"
    },
    {
      "author": "schuelermine",
      "author_association": "CONTRIBUTOR",
      "body": "The second RFC will take a bit of time though, I have something else to do right now.",
      "created_at": "2020-04-14T12:05:20Z",
      "updated_at": "2020-04-14T12:05:20Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "`d` / `dd` alone as a suffix is going to clash with hexadecimal literals and be unusable there. That aside, would be good to see a thorough list of your suggestions as @schuelermine says.",
      "created_at": "2020-04-14T12:18:34Z",
      "updated_at": "2020-04-14T12:18:34Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> Today only one built in command takes a -Seconds parameter, and that is Start-Sleep. I suspect there are more in other modules, especially where one is adding a time out.\r\n>\r\n> To date, **people have managed** to write 300 for 5 minutes, or 30 for 0.5 minutes, and it hasn't been a great problem (yes, I know, \"we've always done it that way\" is the worst reason ever)\r\n\r\nCan you elaborate a little bit more in how that relates to timespan literals?\r\n \r\n> Taking an existing function which has a -Timeout parameter and allowing the user to write\r\n> `Invoke-MyOldFunction -Timeout 2m`\r\n> Will simply break that function as it does not expect a TimeSpan object - this happens now when a timespan is passed to Start-Sleep.\r\n\r\nNah, in the same way that `Write-Host 1mb` writes `1mb` instead of 1048576. When in command argument parsing mode, a literal is created but wrapped in a `PSObject` with knowledge of the original token text.\r\n\r\n> For a **small amount of effort saved** writing\r\n> `-Timeout ($m * 60)` or `-Timeout ($h * 3600)`\r\n> **more effort will be needed** to remove `[int]` from timeout parameters and change\r\n> `$endtime = $now.addSeconds($timeout)`\r\n> statements to\r\n> `If ($timeout -is [timespan]) {$endTime = $now.add($timeout)} else { ....` etc\r\n>\r\n> Even adding a transform class to turn timespans into total seconds would require re-coding. Since we can be fairly sure that\r\n> (a) Commands will need to keep accepting seconds as a number, to work with existing scripts and\r\n> (b) some commands won't be updated,\r\n> **the smart thing for users to do is to continue to use seconds** even if this is adopted.\r\n\r\n\r\nIf you don't type your parameter as `TimeSpan`, nothing will be different.",
      "created_at": "2020-04-14T12:21:44Z",
      "updated_at": "2020-04-14T12:21:44Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> Ah, every time I think about this I come back to \"prefix\" pattern.\r\n> For me this looks very \"powershelly\":\r\n> \r\n> ```powershell\r\n> [Second]12\r\n> [sec]15\r\n> [Day]3\r\n> [Minute]59\r\n> [min]59\r\n> [hour]23\r\n> [week]10\r\n> [century]20\r\n> ```\r\n\r\nAre those all types?  Or would they really convert to `TimeSpan`? We sort of have existing syntax like that with `PSCustomObject` really pointing to `PSObject` and it confuses the heck out of folks.  Also you can't really do mixed measurements like \"1 day 10 hours\".  Also you'd need to wrap it in a paren expression before you could use it in a command argument.",
      "created_at": "2020-04-14T12:25:20Z",
      "updated_at": "2020-04-14T12:25:20Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "Also side note, a lot of the discussion seems to be around command arguments but the uses for this are a lot more imo.  For instance, I'd love to be able to do something like this:\r\n\r\n```powershell\r\n$threshold = (Get-Date) - 30days\r\nGet-ChildItem | ? LastWriteTime -gt $threshold\r\n```",
      "created_at": "2020-04-14T12:30:33Z",
      "updated_at": "2020-04-14T12:30:33Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> @jhoneill I don't quite follow the last paragraph. Could you list your proposed suffixes and their uses?\r\n\r\nOK. To convert date time to string we use  \"yyyy MM dd HH:mm:ss:fffff\"\r\nfor  **y**ear,   **M**onth,  **d**ay, **H**our (24 hour clock in this case), **m**inutes, **s**econds and **f**ractions of seconds \r\n \r\nif we then say in one place we use h or \"hh\" to mean hours and somewhere else we write \"hour\" it will lead to error. \r\nSo I would support the same values as used in .NET format strings. However as already pointed out d and f would clash with supporting hex numbers. \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n> > Ah, every time I think about this I come back to \"prefix\" pattern.\r\n> > For me this looks very \"powershelly\":\r\n> > ```powershell\r\n> > [Second]12\r\n> > [sec]15\r\n> > [Day]3\r\n> > [Minute]59\r\n> > [min]59\r\n> > [hour]23\r\n> > [week]10\r\n> > [century]20\r\n> > ```\r\n> \r\n> Are those all types? Or would they really convert to `TimeSpan`? We sort of have existing syntax like that with `PSCustomObject` really pointing to `PSObject` and it confuses the heck out of folks. Also you can't really do mixed measurements like \"1 day 10 hours\". Also you'd need to wrap it in a paren expression before you could use it in a command argument.\r\n\r\nHaving those as types which derive from Timespan so [day]30 created a timespan of 30 days would \r\nwould give you\r\n```\r\n$threshold = (Get-Date) - [day]30\r\nGet-ChildItem | ? LastWriteTime -gt $threshold\r\n```",
      "created_at": "2020-04-14T13:13:39Z",
      "updated_at": "2020-04-14T13:13:39Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "You would lack the ability to use them directly as arguments, though.\r\n\r\n```ps1\r\nGet-ChildItem | Where-Object LastWriteTime -gt 10days\r\n# vs\r\nGet-ChildItem | Where-Object LastWriteTime -gt ([days]10)\r\n```\r\n\r\nThat option is (IMO) far more awkward. Also, it means having multiple aliases to the same type which do very different things... and as @SeeminglyScience the only case where we currently do this is `[PSCustomObject]` which is already a pretty sore point of confusion for many folks.",
      "created_at": "2020-04-14T13:16:54Z",
      "updated_at": "2020-04-14T13:16:54Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "Also you can't inherit `TimeSpan` as it's a struct.  Each one would have to either be their own type completely or just be aliases to `TimeSpan` with some parser magic (like @vexx32 described currently occurs with `PSCustomObject`).",
      "created_at": "2020-04-14T13:22:32Z",
      "updated_at": "2020-04-14T13:23:15Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> You would lack the ability to use them directly as arguments, though.\r\n> \r\n> ```powershell\r\n> Get-ChildItem | Where-Object LastWriteTime -gt 10days\r\n> # vs\r\n> Get-ChildItem | Where-Object LastWriteTime -gt ([days]10)\r\n> ```\r\nThat's comparing a datetime with a timespan, so the parameter value will always be an expression. Today I use `[datetime]::now.addDays(-10)` which is clunky. \r\nbut I don't think `[datetime]::now.subtract(10days)` is a great deal better. \r\n\r\nWhere it something is naturally a time span I agree ... 10days is more natural to write.  \r\n\r\n\r\n> Also you can't inherit `TimeSpan` as it's a struct. Each one would have to either be their own type completely or just be aliases to `TimeSpan` with some parser magic \r\n\r\nDarn. Parser magic is best avoided. \r\n",
      "created_at": "2020-04-14T13:26:37Z",
      "updated_at": "2020-04-14T13:26:37Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> That's comparing a datetime with a timespan, so the parameter value will always be an expression.\r\n\r\nI mean sure but you get what he means.  Here's a more \"correct\" example:\r\n\r\n```powershell\r\nSet-Date -Adjust 10days\r\n# vs\r\nSet-Date -Adjust ([days]10)\r\n````\r\n\r\n> Today I use `[datetime]::now.addDays(-10)` which is clunky.\r\n> but I don't think `[datetime]::now.subtract(10days)` is a great deal better.\r\n\r\nThat isn't what is being proposed, it would be more like this:\r\n\r\n```powershell\r\n[datetime]::Now - 10days\r\n```",
      "created_at": "2020-04-14T13:41:36Z",
      "updated_at": "2020-04-14T13:41:36Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "Yes, I did get what he meant, but I couldn't think of a built in command which takes a timespan parameter. \r\n`>(get-command -type Cmdlet,Function | where {$_.parameters.values.parametertype.name -contains \"timespan\"})`\r\n\r\nSays the only one is `Set-date` :-) \r\n  \r\nI don't think anyone has done a survey to see where commands ask for age, timeout or whatever as a timespan and where they assume units. Built in we have Start-Sleep which can't take a time span, and Set-Date -adjust which must take one. which isn't much of a sample. \r\n\r\nBut the complaint that you can't write `$now - $then -gt [days]10` and it needs to be `$now - $then -gt ([days]10)` also applies to `-gt (date - 10days)` \r\n\r\nChanging start-sleep so it could take a timespan and introducing these literals mean you go from typing sleep -s[tab] 10  and reading \"Sleep -seconds 10\" \r\nto Sleep -t[tab] 10secs and reading \"Sleep -timespan 10secs\" , but if this goes in a new version the writer is better sticking to -seconds 10 for compatibility. And if I have a timeout in my module, I have to add support for timespan, and if I haven't, or users are working with an old version they need to stick with seconds.  It seems to me like low gain for fairly high cost. \r\n\r\n",
      "created_at": "2020-04-14T14:33:45Z",
      "updated_at": "2020-04-14T14:33:45Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> I don't think anyone has done a survey to see where commands ask for age, timeout or whatever as a timespan and where they assume units. Built in we have Start-Sleep which can't take a time span, and Set-Date -adjust which must take one. which isn't much of a sample.\r\n\r\nTo be fair 100% of people don't use teleporters, doesn't mean we shouldn't invent one.  Using `TimeSpan` kinda sucks right now, so no one uses it.\r\n\r\n> But the complaint that you can't write `$now - $then -gt [days]10` and it needs to be `$now - $then -gt ([days]10)` also applies to `-gt (date - 10days)`\r\n\r\nThose are two very different expressions you're comparing.  Yeah if you need a binary expression as a command argument you'll need to wrap it in a paren expression, but that doesn't stop `-gt 10days` from being valid.\r\n\r\n> Changing start-sleep so it could take a timespan and introducing these literals mean you go from typing sleep -s[tab] 10 and reading \"Sleep -seconds 10\"\r\n> to Sleep -t[tab] 10secs and reading \"Sleep -timespan 10secs\"\r\n\r\nMore accurately `Sleep 10s`.  The `TimeSpan` positional parameter would be a different parameter set, and the selected set would be based on typing.\r\n\r\n> but if this goes in a new version the writer is better sticking to -seconds 10 for compatibility.\r\n\r\nIt's certainly up to the individual whether they'd like to adopt new features of the language, but this would be far from the first one added.  Would it be likely that someone would require whatever version this ships in to run their module specifically for this feature? Nah probably not, but if they already require it then there's no issue using it.\r\n\r\nPlus, that doesn't apply to interactive use.\r\n\r\n> And if I have a timeout in my module, I have to add support for timespan, and if I haven't, or users are working with an old version they need to stick with seconds. It seems to me like low gain for fairly high cost.\r\n\r\nAdding a parameter set isn't that big of a lift imo.",
      "created_at": "2020-04-14T15:01:04Z",
      "updated_at": "2020-04-14T15:01:04Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> > I don't think anyone has done a survey to see where commands ask for age, timeout or whatever as a timespan and where they assume units. Built in we have Start-Sleep which can't take a time span, and Set-Date -adjust which must take one. which isn't much of a sample.\r\n> \r\n> To be fair 100% of people don't use teleporters, doesn't mean we shouldn't invent one. Using `TimeSpan` kinda sucks right now, so no one uses it.\r\n\r\nThat wasn't my point. There is only 1 command with a seconds parameter and one which takes a timespan from my installation of PowerShell. There are bound to be others in modules which I don't have, but the number is hard to quantify.  But  if you want to be on the beta program for teleport ....  :-) DateTime and TimeSpan are what come from .NET and there is a valid discussion to be had around what should PowerShell wrap around them to make either/both less sucky. \r\n\r\n> ...  doesn't stop `-gt 10days` from being valid.\r\nNo. But at present (and maybe because timespan is a bit sucky) the number of places you would compare two timespans is pretty small. $x -gt 10days is fine a nice bit of polish if everything else has been, but $x.totaldays -gt 10 is not terrible.  \r\n\r\n> > if this goes in a new version the writer is better sticking to -seconds 10 for compatibility.\r\n \r\n> It's certainly up to the individual whether they'd like to adopt new features of the language,\r\n\r\nIt isn't though. ...  all first-party cmdlets which specify any kind of duration would need to add TimeSpan support ; e.g. we have `Invoke-RestMethod -TimeoutSec` so first we need to figure out how that will support timespans. Since -Ti is unique now, any new parameter must use different naming to avoid a breaking change, and the least work is the _transformer attribute_ route so people can write -TimeOut 10m and a 10 minute timespan morphs into int 600. \r\nBUT 3rd party modules won't catch up immediately and some won't see the point. So the user quickly learns than 600 works as seconds pretty much everywhere, because it always has, but 10m crashes in most places - which teaches the behaviour of not using it. \r\n\r\n> >...  add support for timespan, and if I haven't, or users are working with an old version they need to stick with seconds. It seems to me like low gain for fairly high cost.\r\n \r\n> Adding a parameter set isn't that big of a lift imo.    \r\n\r\nNo,  it's not big, and adding the conditional logic for each is also a small overhead. If you have 200 functions which take a time out - e.g. a large module which calls rest APIs, Its 200x 2 small tasks - and I have two modules which call invoke-restMethod from ~200 places each, if it is changed to support timespans would I bother updating so my functions did. Maybe, when I had run out of other things to do; but in the short term I'd be one of those things which didn't work and got in the way of adoption. \r\n\r\nAs I said before I'd rather have an argument converter class so if someone passed a timespan to something expecting a number of seconds/milliseconds/nano-fortnights/whatever it just worked.    A quick way to make timespans, well why not , if someone can make the literals workable, and international that's great.      \r\nBut there's no great pressure for timespans as parameters because people don't feel an overpowering need to use one, and no one has cried out for easy ways to make a timespan because (a) [timespan]100  or [timespan]::FromHours(1.5) aren't so terribly, impossibly hard, and (b) the number of places you use them is quite small so although that syntax is clunky it's not annoying day in, day out.    \r\nIt's just seems to me this would be too far down the list of nice-to-haves to ever get worked on. \r\n\r\n",
      "created_at": "2020-04-14T17:45:23Z",
      "updated_at": "2020-04-14T17:45:23Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Also you can't really do mixed measurements like \"1 day 10 hours\".\r\n\r\nThis is a right thing (\"1 day 10 hours\") for PowerShell - it follow English notation like cmdlet names.\r\n\r\nAnd we can easily implement `[TimeSpan]\"1 day 10 hours\"` but it is difficult to get this for arguments.",
      "created_at": "2020-04-14T18:02:46Z",
      "updated_at": "2020-04-14T18:02:46Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> No. But at present (and maybe because timespan is a bit sucky) the number of places you would compare two timespans is pretty small. $x -gt 10days is fine a nice bit of polish if everything else has been, but $x.totaldays -gt 10 is not terrible.\r\n\r\nI think you're reading into the example of `Where-Object` too specifically.  The example wasn't about comparisons, it's about command argument parsing.\r\n\r\n> It isn't though. ... all first-party cmdlets which specify any kind of duration would need to add TimeSpan support\r\n\r\nIdeally they would add that, but they defiinitely wouldn't *have* to and likely wouldn't.  If anything you'd probably see more argument transformation attributes that allow those existing parameters to simply refer to `TotalSeconds` when passed a `TimeSpan` (as you later mention).\r\n\r\n> BUT 3rd party modules won't catch up immediately and some won't see the point. So the user quickly learns than 600 works as seconds pretty much everywhere, because it always has, but 10m crashes in most places - which teaches the behaviour of not using it.\r\n\r\nI don't really think this is an issue.  Especially if the argument transformation attributes were public and surfaced through `Get-Help`.\r\n\r\n> ...  add support for timespan, and if I haven't, or users are working with an old version they need to stick with seconds. It seems to me like low gain for fairly high cost.\r\n\r\nI strongly disagree that the cost is high for adopters or consumers.\r\n\r\n> Maybe, when I had run out of other things to do; but in the short term I'd be one of those things which didn't work and got in the way of adoption.\r\n\r\nYeah and that's fine.\r\n\r\n> But there's no great pressure for timespans as parameters because people don't feel an overpowering need to use one, and no one has cried out for easy ways to make a timespan because (a) [timespan]100 or [timespan]::FromHours(1.5) aren't so terribly, impossibly hard, and (b) the number of places you use them is quite small so although that syntax is clunky it's not annoying day in, day out.\r\n\r\nYes, people don't feel an overpowering need to use one because nothing in PowerShell currently takes them.  Nothing in PowerShell currently takes them because the syntax is bad.",
      "created_at": "2020-04-14T18:32:34Z",
      "updated_at": "2020-04-14T18:32:34Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> > No. But at present (and maybe because timespan is a bit sucky) the number of places you would compare two timespans is pretty small. $x -gt 10days is fine a nice bit of polish if everything else has been, but $x.totaldays -gt 10 is not terrible.\r\n> \r\n> I think you're reading into the example of `Where-Object` too specifically. The example wasn't about comparisons, it's about command argument parsing.\r\nThere are really only two uses for a time span an input. Is the difference between these two times less than / greater than X. And  Add/Subtract this difference to a time. So it's either an operand in an comparison or its a parameter. However the reality is today we can only name one command which takes time span as an input, and everything else takes duration in seconds, or some multiple of seconds.  \r\n\r\n\r\n> > It isn't though. ... all first-party cmdlets which specify any kind of duration would need to add TimeSpan support\r\n> \r\n> Ideally they would add that, but they defiinitely wouldn't _have_ to and likely wouldn't. If anything you'd probably see more argument transformation attributes that allow those existing parameters to simply refer to `TotalSeconds` when passed a `TimeSpan` (as you later mention).\r\n\r\nI think (and other views are valid) that if you introduce something which says \"hey, are you sick of multiplying by 60, just write 5m instead\" it needs to work in as many places as possible, otherwise the user tries it with cmdlet a, fails, cmdlet b, fails, cmdlet c, fails, and goes back to using seconds \"because the new way never works\". And you end up with a bit of arcane syntax which nobody actually uses, so no one supports, and we're back we started.    \r\n How you support it is another matter and the transformer makes coding and use simple.\r\n\r\n> > BUT 3rd party modules won't catch up immediately and some won't see the point. So the user quickly learns than 600 works as seconds pretty much everywhere, because it always has, but 10m crashes in most places - which teaches the behaviour of not using it.\r\n> \r\n> I don't really think this is an issue. Especially if the argument transformation attributes were public and surfaced through `Get-Help`.\r\nNot sure that attributes are, currently. But if the user finds that, OK start-sleep will use it, but this such-and-such a module which calls rest-apis needs seconds, and something else which does SQL queries needs seconds, and that one which tests connectivity needs seconds, then they don't bother using the new way. \r\n\r\n> \r\n> > ...  add support for timespan, and if I haven't, or users are working with an old version they need to stick with seconds. It seems to me like low gain for fairly high cost.\r\n> \r\n> I strongly disagree that the cost is high for adopters or consumers.\r\n> \r\nNo, the cost for people using it is almost nil. They just have to see which commands support the new way for as long as the persevere with it. For me as a developer with 400 commands in two modules which might take a timeout to pass through to Invoke-webRequest I've got a job on my hands to add and test support for timespans as an alternative to seconds. But if users try using it in a few places and give up I'm doing something no-one will use. So effort has gone in, but no-one thinks the product is improved. \r\n\r\n> Yes, people don't feel an overpowering need to use one because nothing in PowerShell currently takes them. Nothing in PowerShell currently takes them because the syntax is bad.\r\n\r\nAnd because it isn't so hard to work in SI units of time (seconds). If you don't make it easier to do than seconds people will fall back to that. \r\n",
      "created_at": "2020-04-15T00:06:35Z",
      "updated_at": "2020-04-15T00:06:35Z"
    },
    {
      "author": "schuelermine",
      "author_association": "CONTRIBUTOR",
      "body": "FYI, I can't write a seperate RFC for just `Start-Sleep` right now, I have some other work to do.",
      "created_at": "2020-04-15T10:30:45Z",
      "updated_at": "2020-04-15T10:30:45Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Interesting, can we consider `days` or `secs` (or `-days`) as unary operator in `10 days` expression?",
      "created_at": "2020-04-15T11:25:49Z",
      "updated_at": "2020-04-15T11:25:49Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "\ud83e\udd14 interesting question. \r\n\r\n_maybe_?\r\n\r\n`-days` would be more consistent with the pattern of operators, but we don't (currently) have any unary postfix operators; all our unary operators are prefixes ( `-join $array` for example)\r\n\r\n`31 -days -eq ($date - $pastDate)` looks a little funny.\r\n\r\nI'm thinking that starts to blur the line between what is an operator and what is (effectively) a value. the `-days` is part of the intended value itself, really. I think I still prefer the suffix on the numeral itself. ",
      "created_at": "2020-04-15T13:53:38Z",
      "updated_at": "2020-04-15T13:55:25Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I am thinking about something universal, extendable. Suffixes looks more problematic in the case.\r\n\r\nAnother thought - we could consider common timespan formats https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-timespan-format-strings This can slow down parser.\n\n<blockquote><div><strong><a href=\"https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-timespan-format-strings\">Standard TimeSpan format strings</a></strong></div></blockquote>",
      "created_at": "2020-04-15T17:13:12Z",
      "updated_at": "2020-04-15T17:13:14Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "I don't see this as too different from the currently supported suffixes e.g.:\r\n```\r\n04-16 18:18:22 1> 10mb\r\n10485760\r\n```\r\nOne difference is that the current suffixes combine only via the various math operators e.g. `+/-`.  I could see using something like `-1day` or `10min` a lot.  And combining with `+` isn't too bad `1day + 2hr + 5min + 2sec`.  Also, like the `kb/mb/gb/tb` suffixes you could use a float value e.g `1.0868day`, `1.5hr`, etc.\r\n",
      "created_at": "2020-04-17T01:14:43Z",
      "updated_at": "2020-04-17T01:16:51Z"
    },
    {
      "author": "schuelermine",
      "author_association": "CONTRIBUTOR",
      "body": "Thinking about it, maybe splitting this up into two RFCs is a good idea, one for `Start-Sleep` accepting `TimeSpan` and one for `TimeSpan` literals. Then again, the first is much more useful with the second (and vice-versa).",
      "created_at": "2020-04-18T23:13:32Z",
      "updated_at": "2020-04-18T23:13:32Z"
    },
    {
      "author": "IISResetMe",
      "author_association": "COLLABORATOR",
      "body": "Is an RFC really necessary for the `Start-Sleep` aspect of this request?\r\n\r\nThis should do IMO https://github.com/IISResetMe/PowerShell/commit/1e9cff9c8cb5f45929056b45f68eede214e3b9db\r\n\r\n![image](https://user-images.githubusercontent.com/7413755/82387556-a926ea00-9a37-11ea-8e25-d248c2935e56.png)\r\n\r\nI realize the screencap does a poor job of conveying the fourth dimension, but you get the idea \ud83d\ude04 ",
      "created_at": "2020-05-19T23:10:39Z",
      "updated_at": "2020-05-19T23:18:30Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "Can we add a type converter from string to TimeSpan that handles the suffices?\r\n",
      "created_at": "2020-05-20T06:57:01Z",
      "updated_at": "2020-05-20T06:57:01Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "These suffices is on English that is not friendly for other languages.",
      "created_at": "2020-05-20T14:03:31Z",
      "updated_at": "2020-05-20T14:03:31Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Localization is indeed something to think about... But I think ultimately if we match the shorthands used in standard format strings or variants thereof we should be fine.",
      "created_at": "2020-05-20T14:26:15Z",
      "updated_at": "2020-05-20T14:26:15Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "> These suffices is on English that is not friendly for other languages.\r\n\r\nWell, we are stuck with English, aren't we?\r\n\r\nAll the operators, keywords, types and commands are in English, so why shouldn't these suffices be the same?",
      "created_at": "2020-05-20T19:39:13Z",
      "updated_at": "2020-05-20T19:39:13Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "I had some holiday morning fun and wrote a simple type converter from string to TimeSpan.\r\n\r\n```powershell\r\n[timespan] \"1d -5m\" | % tostring\r\n23:55:00\r\n\r\n[timespan] \"1d 2h 33s 2ms\" | % tostring\r\n1.02:00:33.0020000\r\n```\r\n\r\nThis could quite easily be used with a datetime converter to:\r\nthink\r\n```powershell\r\n[datetime] 'a year ago'\r\ntisdag 21 maj 2019 11:47:03\r\n[datetime] 'in 2 months'\r\ntisdag 21 juli 2020 11:47:27\r\n```\r\n\r\n\r\n```csharp\r\npublic sealed class StringToTimespanTypeConverter : PSTypeConverter\r\n{\r\n    /// <inheritdoc />\r\n    public override bool CanConvertFrom(object sourceValue, Type destinationType)\r\n    {\r\n        return destinationType == typeof(TimeSpan) && sourceValue is string;\r\n    }\r\n\r\n    enum TimeSuffix\r\n    {\r\n        None,\r\n        Millisecond,\r\n        Second,\r\n        Minute,\r\n        Hour,\r\n        Day,\r\n        Year\r\n    }\r\n\r\n    /// <inheritdoc />\r\n    public override object ConvertFrom(object sourceValue, Type destinationType, IFormatProvider formatProvider, bool ignoreCase)\r\n    {\r\n        static (int num, TimeSuffix suffix) GetNext(ref ReadOnlySpan<char> span)\r\n        {\r\n            if (span.Length == 0)\r\n                return (0, TimeSuffix.None);\r\n            var endIndex = span.IndexOf(' ');\r\n            if (endIndex == -1) endIndex = span.Length;\r\n\r\n            var current = span[0..endIndex];\r\n\r\n            while (endIndex < span.Length && span[endIndex].IsWhitespace())\r\n            {\r\n                endIndex++;\r\n            }\r\n\r\n            span = span[endIndex..];\r\n\r\n            int i = 0;\r\n            while (i < current.Length && (current[i].IsDecimalDigit() || current[i].IsDash()))\r\n            {\r\n                i++;\r\n            }\r\n\r\n            if (i == 0)\r\n            {\r\n                return (0, TimeSuffix.None);\r\n            }\r\n\r\n            var number = current[0..i];\r\n\r\n            if (!int.TryParse(number, NumberStyles.Integer, CultureInfo.InvariantCulture, out int num))\r\n            {\r\n                return (0, TimeSuffix.None);\r\n            }\r\n            var suffix = current[i..];\r\n\r\n            return suffix.Length switch\r\n            {\r\n                1 => suffix[0] switch\r\n                {\r\n                    'd' => (num, TimeSuffix.Day),\r\n                    'h' => (num, TimeSuffix.Hour),\r\n                    'm' => (num, TimeSuffix.Minute),\r\n                    's' => (num, TimeSuffix.Second),\r\n                    'y' => (num, TimeSuffix.Year),\r\n                    _ => (0, TimeSuffix.None),\r\n                },\r\n                2 => \"ms\".AsSpan().SequenceEqual(suffix)\r\n                    ? (num, TimeSuffix.Millisecond)\r\n                    : (0, TimeSuffix.None),\r\n                _ => (0, TimeSuffix.None),\r\n            };\r\n        }\r\n\r\n        if (sourceValue is string str)\r\n        {\r\n            var time = new TimeSpan();\r\n            var span = str.AsSpan();\r\n            while (span.Length != 0)\r\n            {\r\n                (int num, TimeSuffix suffix) =  GetNext(ref span);\r\n                if (suffix == TimeSuffix.None) return TimeSpan.Parse(str);\r\n                var delta = suffix switch\r\n                {                \r\n                    TimeSuffix.Millisecond => TimeSpan.FromMilliseconds(num),\r\n                    TimeSuffix.Second => TimeSpan.FromSeconds(num),\r\n                    TimeSuffix.Minute => TimeSpan.FromMinutes(num),\r\n                    TimeSuffix.Hour => TimeSpan.FromHours(num),\r\n                    TimeSuffix.Day => TimeSpan.FromDays(num),\r\n                    TimeSuffix.Year=> TimeSpan.FromDays(num*365),\r\n                    _ => throw new ArgumentOutOfRangeException()\r\n                };\r\n\r\n                time += delta;\r\n            }\r\n\r\n            return time;\r\n        }\r\n\r\n        throw new PSInvalidCastException(\"InvalidCastNotAValidTimespan\", $\"Cannot convert {sourceValue} to {destinationType}\", null);\r\n    }\r\n\r\n    /// <inheritdoc />\r\n    public override bool CanConvertTo(object sourceValue, Type destinationType)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    /// <inheritdoc />\r\n    public override object ConvertTo(object sourceValue, Type destinationType, IFormatProvider formatProvider, bool ignoreCase)\r\n    {\r\n        throw new NotImplementedException();\r\n    }\r\n}\r\n```",
      "created_at": "2020-05-21T09:48:10Z",
      "updated_at": "2020-05-21T09:48:10Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "Just to clarify: This enables us to use these string in all places where a command uses a `TimeSpan` parameter.",
      "created_at": "2020-05-21T09:49:42Z",
      "updated_at": "2020-05-21T09:49:42Z"
    },
    {
      "author": "schuelermine",
      "author_association": "CONTRIBUTOR",
      "body": "Just wanted to say sorry for not being involved in this recently. My stuff has been a mess recently, sorry",
      "created_at": "2020-05-23T14:22:04Z",
      "updated_at": "2020-05-23T14:22:04Z"
    },
    {
      "author": "MattKotsenas",
      "author_association": "NONE",
      "body": "Hey there! I found this discussion because I was about to propose the same API as @IISResetMe did in IISResetMe@1e9cff9. Regardless of how the `TimeSpan` object gets created, we'll still need to make changes like this one to allow the cmdlets to accept them, correct?\r\n\r\nIf so, is there anything blocking us from moving forward with that part of the change now?",
      "created_at": "2020-08-29T02:00:31Z",
      "updated_at": "2020-08-29T02:00:31Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Don't think so... it's a sensible change to make, really, regardless of whether we get a base timespan syntax built in.",
      "created_at": "2020-08-29T02:12:03Z",
      "updated_at": "2020-08-29T02:12:03Z"
    },
    {
      "author": "IISResetMe",
      "author_association": "COLLABORATOR",
      "body": "@MattKotsenas nothing's blocking, I just haven't found the time to move it forward :) \r\n\r\nThere's one question I've been pondering that I'd like to be able to answer before submitting the PR: \r\n \r\n- Should we treat negative `[timespan]` values as _durations_, _zero-valued_ or _invalid_?\r\n\r\nIn other words, should this statement sleep for 5 seconds, 0 seconds or throw a terminating error:\r\n\r\n```\r\n$negative5Seconds = -(New-TimeSpan -Seconds 5)\r\n\r\nStart-Sleep $negative5Seconds\r\n```\r\n\r\nImplementation in https://github.com/IISResetMe/PowerShell/commit/1e9cff9 treats it as a duration and sleeps for 5 seconds, but I haven't fully convinced myself that it should... \ud83e\udd14 ",
      "created_at": "2020-09-01T18:05:45Z",
      "updated_at": "2020-09-01T18:06:38Z"
    },
    {
      "author": "MattKotsenas",
      "author_association": "NONE",
      "body": "I would expect that `Start-Sleep` would behave similarly between the different parameters, and well as analogous APIs like `Thread.Sleep()`.\r\n\r\n> `Start-Sleep -Seconds -5`\r\n\r\n`System.Management.Automation.ParameterBindingValidationException: Cannot validate argument on parameter 'Seconds'. The -5 argument is less than the minimum\r\nallowed range of 0. Supply an argument that is greater than or equal to 0 and then try the command again.`\r\n\r\n> `[System.Threading.Thread]::Sleep([TimeSpan]::FromSeconds(-5))`\r\n\r\n`ArgumentOutOfRangeException: Number must be either non-negative and less than or equal to Int32.MaxValue or -1 (Parameter 'timeout')`\r\n\r\nSo my vote would be for an error.",
      "created_at": "2020-09-02T17:56:17Z",
      "updated_at": "2020-09-02T17:56:17Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "@PowerShell/powershell-committee reviewed this today. I want to thank you for laying out your proposal so clearly in the RFC and fostering a (very vibrant) discussion here in this issue.\r\n\r\nWe agree on the utility of this proposal, though given a lot of the points made here around year (and others), we think that the literals should be scoped to the `From*` static methods on the `Timespan` type:\r\n\r\n![image](https://user-images.githubusercontent.com/1255187/110538487-f2d0e600-80d8-11eb-90e6-287bab1c9407.png)\r\n\r\nWe personally prefer this list of literals as their equivalents:\r\n* `day` (`dy` seems non standard, and `days` breaks with the rest of these by being plural)\r\n* `h`\r\n* `ms`\r\n* `min`\r\n* `sec`\r\n* `tick`\r\n\r\nAs has been pointed out, this is technically a breaking change (e.g. users could define a `15sec` function that sleeps for 15 seconds), but we consider it a Bucket 3 \"Unlikely Grey Area\", and it should be extremely easy to fix. (You can technically do something like `& ${function:15sec}`, but it'd be easier just to rename the function).\r\n\r\nAlso, there was some question in the discussion about *needing* to support Timespan going forward. I don't think anything we're proposing removes existing parameter sets from our built-ins like `Start-Sleep`, nor breaks modules that expect int or string in parameters like `-Seconds`.\r\n\r\nAt this point, we'd be happy to see an experimental feature implementation submitted as a code PR.",
      "created_at": "2021-03-09T21:30:20Z",
      "updated_at": "2021-03-09T21:30:20Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Awesome! Although I don't think I have the time to do it myself, if anyone's interested in putting together the code, I'm more than happy to help out where I can. I'd imagine it'd probably need to get put in similar code paths as the existing literal suffixes, which I've had plenty of time to rummage around in before. \ud83d\ude42 ",
      "created_at": "2021-03-10T01:19:24Z",
      "updated_at": "2021-03-10T01:19:24Z"
    },
    {
      "author": "IISResetMe",
      "author_association": "COLLABORATOR",
      "body": "@vexx32 I'm gonna try and pick this up in the next couple of weeks, any insights you can share from your effort to recognize more number formats? \r\n\r\nI intend to do something similar:\r\n - Introduce a `TimeSpanToken` in the tokenizer \r\n - Token type immediately parses and validates `[Nday[s]][Nh][Nmin][Nsec][Nms][Ntick]` (where `N` is a string of consecutive integers)\r\n - Parser produces constant expression from (valid) token\r\n",
      "created_at": "2022-01-14T14:12:59Z",
      "updated_at": "2022-01-14T14:12:59Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Hmm. There's a couple ways you can go. Some potentially important questions to think on:\r\n\r\n1. Do you want to support combinations of suffixes? (e.g., `100mingb`). Currently I believe the `gb`, `mb`, etc., suffixes can be combined with the existing type suffixes, but in the current implementation you have to specify the type before the multiplier suffix (`100uyGB` not `100GBuy` -- though neither of those are valid in that particular case since the quantity far exceeds the bounds for a `byte`).\r\n2. Do you support the various prefixes? (e.g., `0x100days`, `0b1001010110min`)\r\n3. You may have some difficulty constraining the suffix to only be valid for integer values -- consider whether it's worth the likely refactor when you get there, or whether it might be better to just accept floating-point values and round in a predictable way to get the timespan.\r\n4. If you're going to stick the logic here in the same pathways, you may consider renaming a method here or there (`TryGetNumberValue` springs to mind) if it seems appropriate.\r\n5. You will _probably_ have some fun tracing around the parser or the compiler the places that number tokens are produced and figuring out how to get them all to understand the value and not treating it like a basic number type when it maybe shouldn't be. Might be some interesting bits in LanguagePrimitives, potentially. If stuff breaks after you get parsing figured out, this is likely to be why.\r\n6. There's a nice big test file somewhere or other with huge lists of numbers for testing that strings get parsed into correct numbers ultimately, probably a good idea to put stuff in there for the most part.",
      "created_at": "2022-01-14T14:36:02Z",
      "updated_at": "2022-01-14T14:37:03Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "Just thinking about making this obvious to people and independent of language \r\n\r\nhttps://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-timespan-format-strings \r\n\r\nIn format d is always \"day\", h, or H is hour, m is in minute (M is month), s is second.  I wonder if  those would be better ways to write them (with S as a floating point number, is there a _need_ for milliseconds and ticks ? They're ways of multiplying the fraction by a power of 10 and using an Int.) . Picking up something @vexx32  said it might be good to allow 1.5m  0.25h  etc, so I would avoid constraining anything to int. \r\n\r\n0x10h yes, I think you should because (a) it is (0x10) Hour-units and (b) 0x10GB works - it's (0x10) GB-units .  But you can't do 10GbMb - those don't combine with anything else -  I can't see anyone _needing_ 1048576 seconds as 1MBSec \r\n\n\n<blockquote><img src=\"https://docs.microsoft.com/dotnet/media/dot-net-cross-platform.png\" width=\"48\" align=\"right\"><div><strong><a href=\"https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-timespan-format-strings\">Custom TimeSpan format strings</a></strong></div><div>Understand custom TimeSpan format strings in .NET. A custom format string contains one or more TimeSpan format specifiers & any number of literal characters.</div></blockquote>",
      "created_at": "2022-01-14T14:59:35Z",
      "updated_at": "2022-01-14T14:59:37Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "`0x10uGB` does work, as an example. I don't expect folks to commonly _need_ the combinations for timespans and those quantities, but it might be something folks expect for one reason or another. If we do disallow things like `10minGB`, we will need to be sure to document that those combinations aren't valid.",
      "created_at": "2022-01-14T15:15:08Z",
      "updated_at": "2022-01-14T15:15:08Z"
    },
    {
      "author": "IISResetMe",
      "author_association": "COLLABORATOR",
      "body": "Thanks @vexx32!\r\n\r\n> Do you want to support combinations of suffixes?\r\n\r\nNo, plan is to never accept any of the existing 2<sup>n</sup> (or any other) multipliers. That's also the main motivation for lexing them as separate (non-number) tokens.\r\n\r\n> Do you support the various prefixes? (e.g., 0x100days, 0b1001010110min)\r\n\r\nNo, I can't think of any case where octal or hexadecimal arithmetic translates meaningfully into the domain of time(happy to reconsider if someone can provide a meaningful use case though)\r\n\r\n> You may have some difficulty constraining the suffix to only be valid for integer values\r\n> [...]\r\n> you may consider renaming a method here or there (`TryGetNumberValue` springs to mind) if it seems appropriate.\r\n\r\nAck, current plan (haven't tested this yet) is to take the same path as numerical scanning, but only attempt TS-parsing after regular number scanner fails (when `TryGetNumberValue` returns false we fall through to a similar `TryGetTimeSpanValue` entry point) - if we stick with proposed suffix scheme, then there's no overlap (`1days` is not a valid numeric literal, and `1d` will have already been consumed when TS-parsing logic is reached).\r\n\r\nI guess [this massive block of test cases in `Parser.Tests.ps1`](https://github.com/PowerShell/PowerShell/blob/master/test/powershell/Language/Parser/Parser.Tests.ps1#L838-L1196) is what you're referring to? :) \r\n\r\n----\r\n\r\n@jhoneill main consideration with the suffix naming is that `d` and `s` are already recognized as numerical suffixes, so an expression like `1s` or `1d` would be completely ambiguous if we stick with .NET's timespan parsing format\r\n\r\nI can definitely see the immediate usefulness of non-integer unit counts (`1.75min`), but it's not strictly _necessary_ - since smaller resolution is possible, the same value can be expressed as 1min45sec (which leaves less room for confusion than `1.75min` IMO)",
      "created_at": "2022-01-14T15:23:33Z",
      "updated_at": "2022-01-14T15:23:33Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "> Ack, current plan (haven't tested this yet) is to take the same path as numerical scanning, but only attempt TS-parsing after regular number scanner fails (when TryGetNumberValue returns false we fall through to a similar TryGetTimeSpanValue entry point) - if we stick with proposed suffix scheme, then there's no overlap (1days is not a valid numeric literal, and 1d will have already been consumed when TS-parsing logic is reached).\r\n\r\nTryGetNumberValue doesn't parse prefixes or suffixes itself, it only gets the raw numbers with some metadata that's already been determined from prefixes/suffixes, so you'll likely need to branch out from the caller instead, I forget what that's called. So if you want to go that route, you will likely need to refactor _part_ of TryGetNumberValue out into a `TryGetIntegerValue` or some similar thing for both TryGetNumberValue and your new timespan method to call into as needed.\r\n\r\nKeep in mind that if you branch too far from the current number scanning you may end up having to scan the timespan token more than once -- it mightn't be a big deal, but if it's avoidable, it's probably worth avoiding re-tokenising it if you can. \ud83d\ude42 \r\n\r\n> I guess this massive block of test cases in Parser.Tests.ps1 is what you're referring to? :)\r\n\r\nThat's the one, there's a few of them, might be good to add a new block, I suppose. ",
      "created_at": "2022-01-14T15:56:30Z",
      "updated_at": "2022-01-14T16:01:48Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "@IISResetMe  Someone pointed out  S and D before, somehow I forgot :-(   and 0xbad  would be 186 days, or just 2989 :-) Forget that part. The problem you then have is \"Day\" isn't going to work too well for (e.g.) French. But the culture settings don't include local words for day, etc. \r\nI think if you do integer-only you'll get complaints of \"I don't want to do 1min + 30sec; I want to do 1.5min\"  ",
      "created_at": "2022-01-14T18:25:15Z",
      "updated_at": "2022-01-14T18:25:15Z"
    }
  ],
  "created_at": "2020-04-12T15:41:09Z",
  "labels": [
    "Issue-Enhancement",
    "WG-Language",
    "Breaking-Change",
    "Committee-Reviewed"
  ],
  "number": 12305,
  "state": "open",
  "title": "A simple method for creating TimeSpan objects to enable more user-friendly and simple usage of time-dependent Cmdlets",
  "updated_at": "2022-01-14T18:25:15Z"
}