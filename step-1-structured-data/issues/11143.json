{
  "_url": "https://github.com/PowerShell/PowerShell/issues/11143",
  "author": "mklement0",
  "body": "_Update_: Closed in favor of  a new proposal at https://github.com/PowerShell/PowerShell/issues/11201#issuecomment-559491980.\r\n\r\n----\r\n\r\nGenerally, if you invoke an advanced function / script with:\r\n\r\n* either: no arguments at all\r\n\r\n* or: only arguments that bind to parameters that aren't explicitly tagged as belonging to an explicit parameter set.\r\n\r\nPowerShell makes the automatic `__AllParameterSets` parameter set the effective one (`$PSCmdlet.ParameterSetName`)\r\n\r\nHowever, this only works if there are either _no_ explicitly defined parameter sets or there is at most _one_.\r\n\r\nWith two or more explicit parameter sets, you're suddenly forced to define a _default_ parameter set via `[CmdletBinding(DefaultParameterSetName='...')]`, or else the invocations described above result in an ambiguous-or-incompatible-parameters-specified error.\r\n\r\nThis situational requirement is obscure, especially given that there's no _logical_ reason to enforce it.\r\n\r\n----\r\n\r\n_Update_: **What I am suggesting comes down to this:**\r\n\r\nIf an advanced function or script _doesn't explicitly declare a default parameter set_ via its `[CmdletBinding()]` attribute:\r\n\r\n* Always allow invocations _without arguments_ as well as invocations comprising _only parameters not explicitly assigned to any parameter set_  - irrespective of the presence of parameters declared as belonging to one or more explicitly named parameter sets and irrespective of whether any of these parameters are declared as _mandatory_ in their sets.\r\n\r\n* Make `$PSCmdlet.ParameterSetName` contain  `__AllParameterSets` in that event.\r\n  * Specifically, do not try to _infer_ a default parameter set from among the explicit ones for parameter-less or only all-parameter-sets parameter invocations.\r\n\r\nAlso see [this alternative (more breaking)  proposal](https://github.com/PowerShell/PowerShell/issues/11201#issuecomment-559491980), which instead proposes enforcing designating a default parameter set explicitly, at parse time.\r\n\r\n---\r\n\r\nSee [the example in this comment](https://github.com/PowerShell/PowerShell/issues/11143#issuecomment-557620471) for how that could be useful in the real world.\r\n\r\n---\r\n\r\nTechnically, **this is a _breaking change_ in the following edge cases**, both of which apply only if _no_ default parameter set is specified:\r\n\r\n* (a) If a function/script has only _one_ explicitly named parameter set, that parameter set currently becomes the effective one _by default_ in parameter-less invocations _if_ at least one parameter in that explicit set is declared as _mandatory_:\r\n  * That is, currently the mandatory parameter is prompted for; aside from the fact that this behavior is questionable, there's a real bug associated with it - see #11201.\r\n  * With the proposed change, this will no longer be the case (but arguably it should never have worked this way): a parameter-less invocation will succeed as-is, and `$PSCmdlet.ParameterSetName` will contain  `__AllParameterSets`.\r\n\r\n* (b) If a function/script has _multiple_ explicitly named parameter sets only _one_ of which does _not_ comprise mandatory parameters, the latter currently becomes the effective one by default in a parameter-less invocation and in all-parameter-sets-only parameters invocations.\r\n  * With the proposed change, this will no longer be the case (but arguably it should never have worked that way): such invocations will then make `$PSCmdlet.ParameterSetName` contain  `__AllParameterSets`.\r\n\r\nExample of (a):\r\n\r\n```powershell\r\nfunction foo {\r\n  [CmdletBinding()]\r\n  param(\r\n    [Parameter(ParameterSetName='ByBar', Mandatory)]\r\n    $Bar\r\n  )\r\n  $PSCmdlet.ParameterSetName\r\n}\r\n# Currently: prompts for -Bar; \r\n# After change: allows parameter-less invocation\r\nfoo \r\n```\r\n\r\nExample of (b):\r\n\r\n```powershell\r\nfunction foo {\r\n  [CmdletBinding()]\r\n  param(\r\n    [Parameter(ParameterSetName='ByBar', Mandatory)]\r\n    $Bar,\r\n    [Parameter(ParameterSetName='ByBaz')]  # non-mandatory\r\n    $Baz,\r\n    $Bam  # all-parameter-sets parameter\r\n  )\r\n  $PSCmdlet.ParameterSetName\r\n}\r\n# Currently: makes $PSCmdlet.ParameterSetName contain 'ByBaz'\r\n# After change: makes $PSCmdlet.ParameterSetName contain '__AllParameterSets'\r\nfoo   # ditto for: foo -Bam arg\r\n```\r\n\r\n# Steps to reproduce\r\n\r\n```powershell\r\n\r\n# Advanced function with 1 explicit parameter set\r\nfunction foo1 { [CmdletBinding()] param($bar1, [Parameter(ParameterSetName='bar2')] $bar2) 'foo1' }\r\n\r\n# Advanced function with 2 explicit parameter sets\r\nfunction foo2 { [CmdletBinding()] param($bar1, [Parameter(ParameterSetName='bar2')] $bar2, [Parameter(ParameterSetName='bar3')] $bar3) 'foo2' }\r\n\r\n# Now invoke the functions without arguments, which should succeed in both cases, due to the\r\n# presence of \"untagged\" parameter $bar1\r\n{ foo1 } | Should -Not -Throw\r\n{ foo2 } | Should -Not -Throw\r\n```\r\n\r\n# Expected behavior\r\n\r\nBoth tests should succeed.\r\n\r\n# Actual behavior\r\n\r\nThe 2nd test fails:\r\n\r\n```none\r\nExpected no exception to be thrown, but an exception \r\n\"Parameter set cannot be resolved using the specified named parameters. \r\nOne or more parameters issued cannot be used together or an insufficient number of parameters were provided.\" was thrown...\r\n```\r\n\r\n# Environment data\r\n\r\n```none\r\nPowerShell Core 7.0.0-preview.6\r\n```\r\n",
  "closed_at": "2019-11-29T14:00:38Z",
  "comments": [
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I've also run into cases where even specifying the default parameter set will not work, especially if you have a default parameter set with no mandatory parameters. It will revert to prompting for mandatory parameters from any other set. ",
      "created_at": "2019-11-21T17:09:11Z",
      "updated_at": "2019-11-21T17:09:11Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "What you are seeing is correct behaviour \r\n```\r\n[Parameter(ParameterSetName='bar2')] $bar2,\r\n[Parameter(ParameterSetName='bar3')] $bar3) \r\n```\r\nSays there are two parameter sets. \r\nIf -Bar2 is passed you are in set \"bar2\" ; if -Bar3 is passed you in are  \"bar3\"  However both parameters are optional so if neither is present you could still be in either of the two sets.  \r\n More experienced authors might write like this. \r\n\r\n`\r\nfunction foo2 { \r\n[CmdletBinding()] \r\nparam($bar1, \r\n[Parameter(ParameterSetName='bar2')] \r\n$bar2, \r\n[Parameter(ParameterSetName='bar3',Mandatory)] \r\n$bar3) \r\n$PSCmdlet.ParameterSetName }`\r\n\r\nPowerShell can now infer that if -Bar3 is not passed, it can not be using set \"bar3\" and it must be in set bar2. \r\n\r\nI _thought_ that the advice was 1 parameter in every non-default set should be mandatory which takes away the need to have a default. \r\n\r\nThere is a complication which I blogged here \r\nhttps://jamesone111.wordpress.com/2016/11/30/powershell-piped-parameter-peculiarities-and-a-palliative-pattern/\r\nfrom something I first hit in 2013. \r\n\r\n \r\n\r\n\n\n<blockquote><img src=\"https://s0.wp.com/i/blank.jpg\" width=\"48\" align=\"right\"><div><img src=\"https://s1.wp.com/i/favicon.ico\" height=\"14\"> James O'Neill's Blog</div><div><strong><a href=\"https://jamesone111.wordpress.com/2016/11/30/powershell-piped-parameter-peculiarities-and-a-palliative-pattern/\">Powershell Piped Parameter Peculiarities (and a Palliative pattern!)</a></strong></div><div>Writing some notes before sharing a PowerShell module,\u00a0 I did a quick fact check and rediscovered a hiccup with piped parameters and (eventually) remembered writing a simplified script to show\u2026</div></blockquote>",
      "created_at": "2019-11-21T20:04:48Z",
      "updated_at": "2019-11-21T20:04:50Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> if neither is present you could still be in either of the two sets.\r\n\r\nNo, you should still be in the automatic `__AllParameterSets` set that the untagged parameter(s) belong to.\r\n\r\nThere's no reason to force you to artificially designate a default parameter set you're not actually using (which is what you need to do to make the problem go away: `[CmdletBinding(DefaultParameterSet='IShouldNotNeedToDoThis')]`)\r\n\r\n",
      "created_at": "2019-11-21T21:17:03Z",
      "updated_at": "2019-11-21T21:17:03Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> > if neither is present you could still be in either of the two sets.\r\n> \r\n> No, you should still be in the automatic `__AllParameterSets` set that the untagged parameter(s) belong to.\r\n\r\nActually no. \r\nWhat should happen if I run this with no parameters ? \r\n```\r\nfunction test1 { \r\n[CmdletBinding()]\r\n  param(\r\n  [Parameter(Mandatory)] $first\r\n  )\r\n$PSCmdlet.ParameterSetName \r\n}\r\n```\r\nIt knows what the default parameter set is, and that it is missing an mandatory parameter so it prompts for it.  _It doesn't create an extra parameter set and say you can run without the parameter._ \r\nLet's try another one.  What should happen here\r\n```\r\nfunction test2a { \r\n[CmdletBinding()]\r\n  param(\r\n  [Parameter(Mandatory,ParameterSetName=\"one\")] $first \r\n  )\r\n$PSCmdlet.ParameterSetName \r\n}\r\n```\r\nShould it prompt ?  Or should it say \"there must be two sets, so we're in  `__AllParameterSets` don't prompt\"  (it prompts)\r\n\r\n```\r\nfunction test2b { \r\n[CmdletBinding()]\r\n  param(\r\n  [Parameter(Mandatory,ParameterSetName=\"one\")] $first,\r\n  [Parameter(Mandatory,ParameterSetName=\"Two\")] $Second\r\n  )\r\n$PSCmdlet.ParameterSetName \r\n}\r\n```\r\nShould this create a third parameter set to run with no parameters ? Most people would look at this and say the command must run with one parameter or the other, but the function has no way to choose a set; and it would be better to set a default and prompt than get \"parameter set cannot be resolved\" but that is down to the programmer to write in the correct way. \r\n\r\nNext we have only one mandatory parameter.  \r\n```\r\nfunction test2c { \r\n[CmdletBinding()]\r\n  param(\r\n  [Parameter(Mandatory,ParameterSetName=\"one\")] $first,\r\n  [Parameter(ParameterSetName=\"Two\")] $Second,\r\n  [Parameter(ParameterSetName=\"Two\")] $twentySecond\r\n  )\r\n$PSCmdlet.ParameterSetName \r\n}\r\n```\r\nWe can tell from the absence of that parameter that we can't be using that set, and there is only one set left. All its parameters are optional. Using second or twentysecond prevents us using first, and vice versa.  Again no extra parameter set is created. No mandatory parameter rules out set \"one\" so we must be in set two even if no optional parameters from that set are given.  That's what I meant about not being able to infer anything from the absence of an optional parameter. Presence of mandatory or optional tells you that a set is selected, Absence of mandatory tells you it isn't selected. even without the optional parameter(s) a set might be the only one left.  \r\n\r\nWith those behaviours it would be odd to say, for the one case where no default is given, **and** there are >= 2 named sets, **and** the set can't be determined from the parameters given (or mandatory parameters not given) then an extra parameter set should be added. \r\n\r\n\r\n> There's no reason to force you to artificially designate a default parameter set you're not actually using (which is what you need to do to make the problem go away: `[CmdletBinding(DefaultParameterSet='IShouldNotNeedToDoThis')]`)\r\n\r\nYou're not forced to. In case you've given you can say either \"bar1 must be present in set 1, but bar2 is optional in set 2\".    Only where you have a or b or c means set1 and d or e or f means set (i.e. you can't make a parameter all in all but one of the set) are forced to name a set for \"neither\". \r\n\r\n ",
      "created_at": "2019-11-22T00:01:13Z",
      "updated_at": "2019-11-22T00:01:13Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "You're missing the premise of this issue: that there are non-mandatory all-parameter-sets parameters.\r\nThey alone unambiguously imply the automatic `__AllParameterSets` parameter set, if either _no_ parameters are given or only said non-mandatory all-parameter-sets parameters are given.\r\n\r\nIf this works - and it does:\r\n\r\n```powershell\r\nfunction foo2 { \r\n    [CmdletBinding(DefaultParameterSetName = 'PleaseDontMakeMeDoThisIBegOfYou')] \r\n    param(\r\n        $bar1, \r\n        [Parameter(ParameterSetName = 'bar2')] $bar2, \r\n        [Parameter(ParameterSetName = 'bar3')] $bar3\r\n    ) \r\n    'foo2' \r\n}\r\n  \r\nfoo2 # OK\r\n```\r\n\r\nThen so should this - which doesn't:\r\n\r\n```powershell\r\nfunction foo2 { \r\n    [CmdletBinding()] \r\n    param(\r\n        $bar1, \r\n        [Parameter(ParameterSetName = 'bar2')] $bar2, \r\n        [Parameter(ParameterSetName = 'bar3')] $bar3\r\n    ) \r\n    'foo2' \r\n}\r\n  \r\nfoo2 # Kaboom!\r\n```\r\nPlease focus on just this specific case in your reply.",
      "created_at": "2019-11-22T02:46:25Z",
      "updated_at": "2019-11-22T02:47:05Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "@mklement0  please stop being obtuse.   There is no reason why the second one should work. \r\n\r\nThe first one fixes an error in the second and where you have a requirement to call with neither parameter but haven't coded that.  What you're saying is that PowerShell shouldn't need that fix, and should guess that there was a requirement to call with neither. \r\n\r\n\r\n- It is pointless defining one parameter set, because even the parameters no assigned to a set belong to it.  \r\n- When you define two or more sets PowerShell needs a way to select a set. \r\n- If you want a an additional set which is \"none of the combinations associated with a declared set\" you have to declare that. PowerShell doesn't do it for you and it shouldn't guess you wanted.  \r\n\r\n\r\nYou have shown that it is possible for someone who doesn't understand this to write something which a user can call in a way which makes it impossible for PowerShell to make a selection.  \r\n\r\nYou're asking for a special case which is, if more than one set is made up entirely of non-mandatory parameters, PowerShell should create an additional parameter set.  I think there should be a special case where 0/0 isn't a divide by zero error but I'm not going to get _that_. :-)\r\n\r\nIf you write \r\n```\r\n    param(\r\n        $bar1, \r\n        [Parameter(ParameterSetName = 'bar2')] $bar2, \r\n        [Parameter(ParameterSetName = 'bar3')] $bar3\r\n    ) \r\n```\r\nit says \"There are two parameter sets 'bar2 and 'bar3' , If the user doesn't specify a parameter for one or the other throw an error\" .But\r\n\r\n```\r\n    param(\r\n        $bar1, \r\n        [Parameter(ParameterSetName = 'bar2')] $bar2, \r\n        [Parameter(ParameterSetName = 'bar3',mandatory=true)] $bar3\r\n    ) \r\n```\r\nsays \"There are two parameter sets 'bar2 and 'bar3' , If the user doesn't specify a parameter for bar3 you can assume bar2\" So does this \r\n\r\n\r\n```\r\n[CmdletBinding(DefaultParameterSetName = 'bar2')]\r\n    param(\r\n        $bar1, \r\n        [Parameter(ParameterSetName = 'bar2')] $bar2, \r\n        [Parameter(ParameterSetName = 'bar3')] $bar3\r\n    ) \r\n```\r\nand this \r\n```\r\n[CmdletBinding(DefaultParameterSetName = 'neither')]\r\n    param(\r\n        $bar1, \r\n        [Parameter(ParameterSetName = 'bar2')] $bar2, \r\n        [Parameter(ParameterSetName = 'bar3',mandatory=true)] $bar3\r\n    ) \r\n```\r\nSays there is a third set. and is equivalent to\r\n```\r\n[CmdletBinding()]\r\n    param(\r\n        [Parameter(ParameterSetName = 'neither')]  \r\n        [Parameter(ParameterSetName = 'bar2')], \r\n        [Parameter(ParameterSetName = 'bar3')] \r\n        $bar1, \r\n        [Parameter(ParameterSetName = 'bar2',mandatory=true)] $bar2, \r\n        [Parameter(ParameterSetName = 'bar3',mandatory=true)] $bar3\r\n    ) \r\n```\r\n\r\nWrite the correct one for the situation.\r\n\r\n\r\nIf you want PowerShell to make guesses. This \r\n```\r\nfunction get-thing { \r\n     param(\r\n       $bar\r\n        [Parameter(ParameterSetName = 'byName',Mandatory)] $Name, \r\n        [Parameter(ParameterSetName = 'byID',Mandatory)] $Id\r\n    ) \r\n    $pscmdlet.ParameterSetName \r\n}\r\n```\r\nSays you must give a name or an ID. The function won't work otherwise. \r\n```\r\nfunction get-thing { \r\n     param(\r\n       $bar\r\n        [Parameter(ParameterSetName = 'byName',Mandatory)] $Name, \r\n    ) \r\n    $pscmdlet.ParameterSetName \r\n}\r\n```\r\nShould this prompt for name or use the \"default\" parameter set. ?  \r\nWhat it does is selects by name. But if $name isn't mandatory it selects _allParameterSets. That's the broken behaviour but it doesn't mater . No one should be writing a functions with a single one parameter set.\r\n\r\nDemanding that everything else behaves like that case is muddled at best \r\n\r\n\r\n\r\n",
      "created_at": "2019-11-22T08:04:19Z",
      "updated_at": "2019-11-22T08:43:00Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "On a quick meta note, @jhoneill:\r\n\r\n> please stop being obtuse.\r\n\r\nPlease remain from making such ad hominem statements and generally from striking a flippant tone in your comments. It adds nothing to the discussion and serves only to antagonize.\r\n",
      "created_at": "2019-11-22T17:24:53Z",
      "updated_at": "2019-11-22T17:24:53Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> here you have a requirement to call with neither parameter but haven't coded that.\r\n\r\nThe point is that there shouldn't be a _need_ to code that, because the desired behavior is _implied_:\r\n\r\n* Whenever you have at least one _untagged_ parameter (not explicitly assigned to any parameter set), it is implicitly in the `__AllParameterSets` set.\r\n\r\n* PowerShell selects the  `__AllParameterSets` parameter set - reflected in `$PSCmdlet.ParameterSetName` - _by default_, if you either specify no arguments or only arguments to parameters that are untagged. (If there are no tagged parameters, `__AllParameterSets` is by definition always the selected parameter set.)\r\n\r\nThat's how it works with untagged-parameters-only functions and those with only _one_ explicit parameter set (assigned to one or more additional parameters).\r\n\r\nThere is no logical reason not to extend that logic to _multiple_ explicit parameter sets: If you specify no parameters or only untagged ones, `__AllParameterSets` is implied.\r\n\r\n> It is pointless defining one parameter set, because even the parameters no assigned to a set belong to it.\r\n\r\nOnly one explicitly defined parameter set may be the rarer use case, but it's definitely not pointless.\r\nFor instance, say you have one untagged parameter, plus two others that must be specified _together_: you'll need to put those two in an explicit parameter set (but the untagged one can remain untagged).\r\n\r\nHere's an example inspired by [this real-world use case](https://stackoverflow.com/q/58822179/45375) (not mine) that caused me to open this issue:\r\n\r\nConsider function `Write-Message`, which should wrap `Write-Host` as follows:\r\n\r\n* Print a default message, if no arguments are passed at all.\r\n* If only a `-Message` argument is passed, print that message as-is.\r\n* If one of the mutually exclusive `-AsError` or `-AsWarning` switches is passed, print the (default or explicit) message in a switch-specific color.\r\n\r\n```powershell\r\nfunction Write-Message {\r\n  [CmdletBinding(DefaultParameterSetName = 'PleaseDontMakeMeDoThis')]\r\n  param(\r\n    [string] $Message = 'Completed.',\r\n\r\n    [Parameter(ParameterSetName = 'err')] [switch] $AsError,\r\n    [Parameter(ParameterSetName = 'warn')] [switch] $AsWarning\r\n  )\r\n\r\n  $writeHostArgs = @{ Object = $Message }\r\n\r\n  if ($AsError) { $writeHostArgs.ForegroundColor = 'Red' }\r\n  elseif ($AsWarning) { $writeHostArgs.ForegroundColor = 'Yellow' }\r\n\r\n  Write-Host @writeHostArgs\r\n\r\n}\r\n```\r\n\r\nAs you can see, the requirement to specify the `PleaseDontMakeMeDoThis` parameter set name is artificial - there's no reason for the code not to work without it, because the automatic `__AllParameterSets` default parameter set could just as well be used instead of the - otherwise unused - `PleaseDontMakeMeDoThis` explicit default parameter set.\r\n\r\nOften you simply don't care or need to care about what `$PSCmdlet.ParameterSetName` contains.\r\n\r\n",
      "created_at": "2019-11-22T17:26:22Z",
      "updated_at": "2019-11-22T17:26:22Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> On a quick meta note, @jhoneill:\r\n> \r\n> > please stop being obtuse.\r\n> \r\n> Please remain from making such ad hominem statements and generally from striking a flippant tone in your comments. It adds nothing to the discussion and serves only to antagonize.\r\n\r\nThe case you are making here is ... whatever.  You make plenty of comments this is only one where I think the line of reasoning amounts to \"being obtuse\". If that felt like a personal attack it wasn't intended that way, and I apologize. Though on the flip side others might call characterizing  a comment on your reasoning as a personal attack as \"antagonistic\". So... shall we both don the metaphorical kid gloves and have a final try ? \r\n\r\n> > here you have a requirement to call with neither parameter but haven't coded that.\r\n> \r\n> The point is that there shouldn't be a _need_ to code that, because the desired behavior is _implied_:\r\n\r\nNo.  There is a behavior which you have not coded, but which you would like the software to deduce that you want from something else which you are doing incorrectly. \r\n\r\n> * Whenever you have at least one _untagged_ parameter (not explicitly assigned to any parameter set), it is implicitly in the `__AllParameterSets` set.\r\n> * PowerShell selects the  `__AllParameterSets` parameter set - reflected in `$PSCmdlet.ParameterSetName` - _by default_, if you either specify no arguments or only arguments to parameters that are untagged. (If there are no tagged parameters, `__AllParameterSets` is by definition always the selected parameter set.)\r\n\r\nNo. There is no `__AllParameterSets` set _as such_.   That is a name which PowerShell uses when it has to create a fictious set, which only happens when there is one set or no sets defined. There is also a flag of the same name which \"says this parameter is in all the sets\". \r\n\r\n```\r\nFunction Test1 {\r\n[cmdletbinding()]\r\nParam ($a,$b ) \r\n$PSCmdlet.ParameterSetName\r\n}\r\n\r\n(get-command test1).ParameterSets.name\r\n__AllParameterSets\r\n\r\n\r\ntest1\r\n__AllParameterSets\r\n```   \r\nTest 1 doesn't have any parameter sets. Where PowerShell needs to give a name to the collection of parameters this \"anonymous set\" gets the label \"__AllParameterSets\"\r\n\r\n```\r\nFunction Test2 {\r\n[cmdletbinding()]\r\nParam (\r\n$a, [parameter(ParameterSetName=\"one\")] $b\r\n) \r\n$PSCmdlet.ParameterSetName\r\n\r\n}\r\n(get-command test2).ParameterSets.name\r\none\r\n```\r\n\r\nTest2 has a parameter set named one. It doesn't have a set named  __AllParameterSets_\r\nBut if it is possible to select \"set one\", it must be possible to select \"not set one\". \r\n```\r\ntest2\r\n__AllParameterSets\r\n```\r\nAgain that label is used for the \"anonymous parameter set\",  but the next case has two named sets. There either you are in set one or you are in set2.   **There will never be an anonymous set once you get to two sets and beyond.**  \r\n```\r\nFunction Test3 {\r\n[cmdletbinding()]\r\nParam (\r\n$a, [parameter(ParameterSetName=\"one\")] $b, [parameter(ParameterSetName=\"two\")] $c\r\n) \r\n$PSCmdlet.ParameterSetName\r\n}\r\n(get-command test3).ParameterSets.name\r\n```\r\n\r\n> For instance, say you have one untagged parameter, plus two others that must be specified _together_: you'll need to put those two in an explicit parameter set (but the untagged one can remain untagged).\r\n\r\nDoesn't work. If you have this \r\n```\r\nFunction Test4 {\r\n[cmdletbinding()]\r\nParam (\r\n$a, [parameter(ParameterSetName=\"one\",Mandatory)] $b, [parameter(ParameterSetName=\"one\",Mandatory)] $c\r\n\r\n) \r\n$PSCmdlet.ParameterSetName\r\n\r\n}\r\n```\r\nRunning test4 with no parameters will prompt for B and C.  You must create a default set to allow only -a  (or for no parameters at all). Then C will be demanded if only B is supplied and vice versa.  \r\n\r\n> Here's an example inspired by [this real-world use case]> Consider function `Write-Message`, which should wrap `Write-Host` as follows:\r\n> \r\n> * Print a default message, if no arguments are passed at all.\r\n> * If only a `-Message` argument is passed, print that message as-is.\r\n> * If one of the mutually exclusive `-AsError` or `-AsWarning` switches is passed, print the (default or explicit) message in a switch-specific color.\r\n> \r\n> ```powershell\r\n> function Write-Message {\r\n>   [CmdletBinding(DefaultParameterSetName = 'PleaseDontMakeMeDoThis')]\r\n>   param(\r\n>     [string] $Message = 'Completed.',\r\n> \r\n>     [Parameter(ParameterSetName = 'err')] [switch] $AsError,\r\n>     [Parameter(ParameterSetName = 'warn')] [switch] $AsWarning\r\n>   )\r\n> \r\n>   $writeHostArgs = @{ Object = $Message }\r\n> \r\n>   if ($AsError) { $writeHostArgs.ForegroundColor = 'Red' }\r\n>   elseif ($AsWarning) { $writeHostArgs.ForegroundColor = 'Yellow' }\r\n> \r\n>   Write-Host @writeHostArgs\r\n> \r\n> }\r\n> ```\r\n**As warning and as error are wrongly specified**.  What you have said is _you can be in Warn without AsWarning_, and _you can be in err without AsErr_ they should be\r\n```\r\n    [Parameter(ParameterSetName = 'err',mandatory)] [switch] $AsError,\r\n    [Parameter(ParameterSetName = 'warn'mandatory)] [switch] $AsWarning\r\n```\r\nWhich says \"You an only be in err if AsError is specified, and only be in warn if asWarning is specified\"\r\nWhere a set has only one parameter that parameter should be mandatory. \r\n\r\nThis is like the` Get-Something `which must be given either ` -ID ` or `-Name.`   If you want a third case you **Should** tell powershell there is a third set.  But you can **cheat,** and let one case be the default and **not** have its parameter as mandatory.  (provided you don't inspect the set name ... see below). \r\n\r\n> As you can see, the requirement to specify the `PleaseDontMakeMeDoThis` parameter set name is artificial - there's no reason for the code not to work without it, because the automatic `__AllParameterSets` default parameter set \r\nIt's _not a parameter set it is a label to use when PowerShell needs to invent a set name_.  I think once you start thinking of it that way it becomes clear. There is no case where `$PSCmdlet.ParameterSetName` will return that as a set name, or the command object has that name when there are 2 or more sets. \r\n\r\nWhat you're saying is that by wrongly coding parameters which are _required_ in order to select a set as _non-mandatory_ members of the set, you are sending a signal to PowerShell to assume you want it to create a third set.  I'm failing to see a strong case for that.  \r\n\r\n> Often you simply don't care or need to care about what `$PSCmdlet.ParameterSetName` contains.\r\nI never use it in real code, I only look at what is in the values or PsboundParameters. I'm only using it in the examples to show what powershell selects. \r\n",
      "created_at": "2019-11-22T18:52:11Z",
      "updated_at": "2019-11-22T18:52:11Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@jhoneill:\r\n\r\nOn the meta issue:\r\n\r\nThanks for apologizing, but to be clear: \"please stop being obtuse\" refers to a person's behavior, not to a line of reasoning; it is the very embodiment of an ad hominem remark.\r\n\r\n---\r\n\r\n>  there is no `__AllParameterSets` set as such\r\n\r\nFor all intents and purposes, there is, as also demonstrated by your examples; most succinctly:\r\n\r\n```powershell\r\nPS> & { [CmdletBinding()] param($foo) $PSCmdlet.ParameterSetName }\r\n__AllParameterSets\r\n```\r\n\r\nThat it would have been better to name this implicit, default parameter set  `Default` I fully agree with.\r\n\r\n> As warning and as error are wrongly specified. What you have said is you can be in Warn without AsWarning, and you can be in err without AsErr they should be\r\n\r\nMaking these switches mandatory  is neither a logical nor an actual requirement. Their mere presence - if specified - selects their specific parameter set.\r\n\r\nIf _neither_ is specified, the default parameter set applies - and there is no reason that that default parameter set _has_ to be given a name by the user, especially given that there is no strict reason to use it inside the function.\r\n\r\n> There will never be an anonymous set once you get to two sets and beyond.\r\n\r\nThere _currently isn't_, but there _should be_, as demonstrated.\r\nThere is no good reason to make the implicit `__AllParameterSets` parameter set go away, just \r\nbecause there happens to be more than one explicit one.\r\n\r\n",
      "created_at": "2019-11-22T19:26:55Z",
      "updated_at": "2019-11-22T19:26:55Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> @jhoneill:\r\n> \r\n> On the meta issue:\r\n> \r\n> Thanks for apologizing, but to be clear: \"please stop being obtuse\" refers to a person's behavior, not to a line of reasoning; it is the very embodiment of an ad hominem remark.\r\n\r\nAd hominem is \"playing the man not the ball\". Was the remark critical of what you are ? Because saying no speech or behaviour can ever be criticized would be absurd.   \r\n\r\n> > there is no `__AllParameterSets` set as such\r\n> \r\n> For all intents and purposes, there is, as also demonstrated by your examples; most succinctly:\r\n> \r\n> ```powershell\r\n> PS> & { [CmdletBinding()] param($foo) $PSCmdlet.ParameterSetName }\r\n> __AllParameterSets\r\n> ```\r\n> \r\n> That it would have been better to name this implicit, default parameter set `Default` I fully agree with.\r\n\r\n> > As warning and as error are wrongly specified. What you have said is you can be in Warn without AsWarning, and you can be in err without AsErr they should be\r\n> \r\n> Making these switches mandatory is neither a logical nor an actual requirement. Their mere presence - if specified - selects their specific parameter set.\r\n\r\nAs written it says \"The parameter set can exist without this parameter\". If there is only one parameter in a set it **is** mandatory but you can get away without saying so. Mostly things will work. Ditto not saying which set should be the default. But it's slippy and  will create parameter combinations where PowerShell can't apply logic which will always be right   \r\n\r\n> If _neither_ is specified, the default parameter set applies - and there is no reason that that default parameter set _has_ to be given a name by the user, especially given that there is no strict reason to use it inside the function.\r\n\r\nNO ! in this \r\n```\r\nfunction Write-Message {\r\n  [CmdletBinding()]\r\n  param(\r\n    [string] $Message = 'Completed.',\r\n\r\n    [Parameter(ParameterSetName = 'err')] [switch] $AsError,\r\n    [Parameter(ParameterSetName = 'warn')] [switch] $AsWarning\r\n  ) \r\n}\r\n```\r\nThere are two parameter sets, **there is no default set;**  Message belongs to both sets.   \r\n```\r\n(Get-Command write-message).ParameterSets[0].Parameters.name\r\nMessage\r\nAsError .... \r\n\r\n(Get-Command write-message).ParameterSets[1].Parameters.name\r\nMessage\r\nAsWarning\r\n```\r\n\r\n> > There will never be an anonymous set once you get to two sets and beyond.\r\n> \r\n> There _currently isn't_, but there _should be_, as demonstrated.\r\nYou've said you want it. That's not a demonstration that anything should be arranged in any particular way. What you've said is such a dreadful imposition to write code properly that Powershell should guess the author's intention rather than follow what they actually wrote. Most of the time that's a bad way to go\r\n\r\n> There is no good reason to make the implicit `__AllParameterSets` parameter set go away, just\r\n> because there happens to be more than one explicit one.\r\n\r\nIt's not \"made to go away\". It's not used as label on an artificial set.  If zero sets are defined everything belongs to a phantom set.  If sets exist at all there must be two or more and PowerShell will add a second to fix \"wrong\" code when there is only one. \r\n\r\n\r\n",
      "created_at": "2019-11-22T22:18:08Z",
      "updated_at": "2019-11-22T22:18:08Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> Was the remark critical of what you are ?\r\n\r\nIt was critical of _my behavior_, based on your _conjecture_ about it  - which has nothing to do with critiquing _arguments I made_.\r\n\r\nIt is unhelpful in general and needlessly makes things personal to speculate on what _motivation_ may or may not underlie others' comments. The only thing worth addressing is the content of the comments themselves.\r\n\r\n> there is no default set; Message belongs to both sets.\r\n\r\nThere _should be_, for the reasons stated. (Of course any untagged parameter belongs to _all_ sets, as always, but that is not the point).\r\n\r\nI think we understand (as opposed to subscribe to) the respective positions, and at this point, to use the old saw, I suggest we agree to disagree.\r\n\r\n",
      "created_at": "2019-11-22T22:26:39Z",
      "updated_at": "2019-11-22T23:14:39Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> > Was the remark critical of what you are ?\r\n> \r\n> It was critical of _my behavior_, based on your _conjecture_ about it - which has nothing to do with critiquing _arguments I made_.\r\n\r\nThe behaviour was the making of a case. \r\n You have one very specific scenario where you want the language to be changed to figure out that that statements you _wrote_ did not specify your intent.   \r\nYou wanted 3 valid combinations of parameters to be valid. \r\nWith A but Not B, \r\nWith B but Not A  \r\nHow is PowerShell meant to know that it should create an ad hoc third set for neither ?  Take this example, which I will say up front is NOT how it should be written.  \r\n```\r\nfunction Set-user {\r\nparam (\r\n    [Parameter(ParameterSet=\"ByID\")]$ID,\r\n    [Parameter(ParameterSet=\"ByName\")]$Name,\r\n    $newProperties\r\n)\r\n```\r\nHere whatever is in the body of the function will NOT do its job properly without an ID or Name. Maybe it it contains something like this \r\n```\r\nIf ($id) {$filter=\"ID = $id\"}\r\nelse    {$filter = \"Name Like '$Name%'\"} \r\nRun-someSql -filter $filter -userProperties $newProperties. \r\n``` \r\nThe author of the code **emphatically did not intend this to run with neither parameter**. \r\nIf that happens it will run apply the changes to any user with a name. \r\nThey **should** have said that the parameters are mandatory, AND if they specified a default set the command would prompt for a value instead of  failing with an error. They didn't and this script has been used for years with no ill-effects. People's data getting deleted would be a strong argument for preserving the status quo. \r\n\r\nAll that you have said to this point says for n valid parameter combinations you only want to give names to n-1 of them, and that you find it to an imposition to give the third one a name (witness the infantile naming you used for that set). \r\nWhen other cases were pointed out to you your response came across as  \"don't bother me with other cases, I only care about the code I've written for write-host.\". (\"Please focus on just this specific case in your reply.\").  It's quite reasonable to ask someone to stop displaying such an attitude and not to demand breaking change in order to save a few keystrokes an area where they demonstrate a lack understanding. Labelling both as \"being obtuse\" requires no special hypothesis about the person's state of mind, it's just a shorthand which, perhaps, doesn't work over cultural boundaries. \r\n",
      "created_at": "2019-11-23T15:50:02Z",
      "updated_at": "2019-11-23T15:50:02Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@jhoneill:\r\n\r\n> The behaviour was the making of a case.\r\n\r\nAnother user argues a point you don't agree with, so you tell them to stop making their point, by telling them to stop exhibiting a [\"a lack of intelligence or sensitivity\"](https://www.ahdictionary.com/word/search.html?q=obtuse), because to you that is the only conceivable reason for making that point?\r\n\r\nI find that disconcerting; it is the opposite of a constructive debate conducted in good faith.\r\n\r\n---\r\n\r\n> You have one very specific scenario where you want the language to be changed\r\n\r\nMy intent is the exact opposite: I want to _generalize useful behavior_ that is currently only available _inconsistently_ (irrespective of what may or may not have been the original design intent):\r\n\r\nIf an advanced function or script _doesn't explicitly declare a default parameter set_ via its `[CmdletBinding()]` attribute:\r\n\r\n* allow invocations without arguments as well as invocations comprising only parameters not explicitly assigned to any parameter set - _irrespective of the presence of parameters belonging to one or more explicitly named parameter sets_ and irrespective of whether these parameters are declared as _mandatory_ in their sets.\r\n\r\n* and make `$PSCmdlet.ParameterSetName` contain  `__AllParameterSets` in that event.\r\n\r\nI've also updated the initial post to make that clear.\r\n@vexx32, I think that would also cover the case [you mentioned above](https://github.com/PowerShell/PowerShell/issues/11143#issuecomment-557181894) (although I haven't personally seen that symptom).\r\n\r\n\r\n@jhoneill : All your `Set-User` example needs is to mark `$ID`, and `$Name` as mandatory, and make either `ById` or `ByName` the default parameter set.\r\nOf course, as the [previous example shows](https://github.com/PowerShell/PowerShell/issues/11143#issuecomment-557620471) it _is_ perfectly legitimate and useful to write functions where _neither_ of these parameters are _required_.\r\n\r\n---\r\n\r\n\r\n",
      "created_at": "2019-11-24T13:07:53Z",
      "updated_at": "2019-11-24T13:07:53Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> @jhoneill:\r\n> \r\n> > The behaviour was the making of a case.\r\n> \r\n> Another user argues a point you don't agree with, so you tell them to stop making their point, by telling them to stop exhibiting a [\"a lack of intelligence or sensitivity\"]\r\n\r\nOK, you've resorted to latin (which doesn't impress me having studied it at school), and no reach for a dictionary (which owning several doesn't impress me either), for reasons I can only guess at - if it was to demonstrate linguistic expertise may be could use it for short reply to \r\n_A response, when  told at length and in detail why a demand is both dangerous to others and bad practice , which takes no account of the explanation and simply repeats the demand without adding supporting matter or addressing the reasons given for turning it down_\r\n\r\nbecause I will gladly accept that it should replace \"Please stop being obtuse\".  \r\n\r\n\r\n> > You have one very specific scenario where you want the language to be changed\r\n> \r\n> My intent is the exact opposite: I want to _generalize useful behavior_ that is currently only available _inconsistently_ (irrespective of what may or may not have been the original design intent):\r\n\r\nThe behaviour you want to genralize is only useful in specific case. In other cases it is potentially dangerous.  \r\n\r\n> @jhoneill : All your `Set-User` example needs is to mark `$ID`, and `$Name` as mandatory, and make either `ById` or `ByName` the default parameter set.\r\nYes. **I know that.**   What were the last words before the script \"This is not how it should be written\"  But there are scripts out in the world which don't do that (I have fixed some of them) and reply on the present behaviour. \r\n\r\nAll your example needs to do is mark one of the two parameters as mandatory. It doesn't even need to set a default set.  You demand that PowerShell should be changed so you don't need to put Mandatory against one of yours (Or strictly n-1) of yours. AND authors who rely on present behaviour go back and change scripts which would then become dangerous. \r\n\r\n> it _is_ perfectly legitimate and useful to write functions where _neither_ of these parameters are _required_.\r\n\r\nIt is . You just need to tell PowerShell and not have it make the assumption because the assumption is not safe.  \r\nOne person can write the [bad] example I gave, another one can write the [bad] example you gave.  PowerShell must make a default assumption, which will favour one of them. The assumption in the original design was to fail safely rather than work dangerously.   Not running safe code because you weren't told that you should (which is what you are complaining about) is better as a principle than Running potentially unsafe code because you weren't told you should not. \r\nWritten with your intent  the author gets a run time error and learns to add a \"mandatory\" or \"defaultset\" option. Written with the intent of my example the author deletes data.  \r\n\r\nHowever you gave this example. \r\n```\r\nfunction Write-Message {\r\n  [CmdletBinding(DefaultParameterSetName = 'PleaseDontMakeMeDoThis')]\r\n  param(\r\n    [string] $Message = 'Completed.',\r\n\r\n    [Parameter(ParameterSetName = 'err')] [switch] $AsError,\r\n    [Parameter(ParameterSetName = 'warn')] [switch] $AsWarning\r\n  )\r\n\r\n  $writeHostArgs = @{ Object = $Message }\r\n\r\n  if ($AsError) { $writeHostArgs.ForegroundColor = 'Red' }\r\n  elseif ($AsWarning) { $writeHostArgs.ForegroundColor = 'Yellow' }\r\n\r\n  Write-Host @writeHostArgs\r\n\r\n}\r\n``` \r\nWhat this shows is a longer way do \r\n`Write-host -fore Red \"xx\" `  by instead typing\r\n`Write-message -error \"xx\" `\r\nIn real-world use it would suggest an author who did not understand _why_ one should write to the error or warning streams and _not_ use write host so let's assume it was _purely_ for demo purposes...  \r\nYou would not use \r\n```\r\n[Parameter(ParameterSetName = 'red')]  [switch]$red,\r\n[Parameter(ParameterSetName = 'green')]  [switch]$green,\r\n[Parameter(ParameterSetName = 'blue')]  [switch]$blue,\r\n[Parameter(ParameterSetName = 'Yellow')]  [switch]$Yellow. \r\n&c  \r\n```\r\nIt would be absurd because those are mutually exclusive values for the same thing.\r\nWhat the example hasn't recognised (possibly because these cases often \"normal\" and \"unusual\" so use a switch) is that it is setting a message \"level\" which may be in one of three states \"Error\", \"Warning\" or \"Normal\" Instead of making those three values for a single parameter (with a Normal as  default), two values are expressed as a parameters which must be in sets to prevent two being given, and there is a need to deduce a the third from the absence of the other two (and the user must deduce there is third state),  ideally it should be  \r\n\r\n```\r\n[validateSet(\"Normal\",\"Error\",\"Warning\")]   \r\n$Level = \"Normal\" \r\n```\r\n\r\nThis allows the user to supply the message and then tab complete values for the level, to see \"normal\" is an option and allow it to be selected explicitly or by default, and the code body is clear that there are three cases not just two.  \r\n\r\nswitch ($level) {\r\n  \"Normal\" {Write-Information $msg} \r\n  \"Error\"     {Write-Error $msg} \r\n  \"Waring\" {Write-Warning $msg}\r\n}\r\n\r\n_Good style_ is not to implement a choice between n possibilities for X, using n-1 switches and an unspecified default. Remove those cases and it comes down to cases like \"Do you want your excel data formatted as a table, and if so, and what sort of table but if not would you like a named range instead\". There are many ways to specify a table so none of the table parameters can be mandatory. \r\nShould PowerShell make me say the single NamedRange parameter _is_ mandatory, or identify a default set? When the answer is \"You have to write your code better\" a change is only needed  \"better\" is very onerous.  How many times could you have tagged one of those parameters as mandatory which would fix your issue with the time that has gone into this discussion. ?\r\n\r\n\r\n   \r\n\r\n\r\n",
      "created_at": "2019-11-24T15:17:19Z",
      "updated_at": "2019-11-24T15:17:19Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Can we please agree drop the personal aspect of this argument? It hasn't furthered this discussion in any way.\r\n\r\nTo your actual point @jhoneill I will simply say that the binder is woefully inadequate in any but very simple circumstances. As soon as you have a number of sets with at least one mandatory parameter each, it is completely impossible to tell the binder that you want to create a set with no mandatory parameters at all.\r\n\r\nFor an exercise in frustration, I invite you to attempt to add a parameter set to Where-Object that takes no mandatory parameters. The binder alternates between other defined sets, but will completely refuse to recognise a set that doesn't contain any mandatory parameters.\r\n\r\nIf you can figure it out, let me know; I've been trying for _weeks_ to get that going so I can resolve a different issue.\r\n\r\nThe binder needs improvement.\r\n\r\nThat said, I do see potential for confusion with users here if we take this suggestion as it is. From what I've seen, at least, it seems quite common for cmdlets and functions to leave optional parameters in \"all sets\" when the design is based around a specific number of sets. I can see how this suggestion would tend to break that.\r\n\r\nI'm not sure what a better solution would be on the whole, at least not without massively complicating the binder and/or the methods in which parameter sets must be defined by the author of a command. \r\n\r\nGiven that the binder is a sensitive area, I would be inclined to think that any changes to it would require at minimum a fairly specific and extensive RFC, so I don't think a great deal is likely to come from this issue itself. There are a lot of edge cases I'd like to fix in the binder, in truth, but I think this suggestion is a bit too likely to break existing cmdlet and function designs.\r\n\r\nI would, however, definitely appreciate some way to indicate to the binder that I _do_ want `__AllParameterSets` to be a valid choice when working through binding logic. There are definitely cases where it would be **significantly** simpler to design parameter sets if that was an available option. It would probably have to be an option in the `[Cmdlet()]` and/or `[CmdletBinding()]` attribute properties somewhere, I would think.",
      "created_at": "2019-11-24T15:44:13Z",
      "updated_at": "2019-11-24T15:44:13Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Fully agreed re the personal aspect, @vexx32 : I wish it had never entered the discussion, and my responses were geared toward eliminating it in the future.\r\n\r\nIn that spirit, allow me one last comment to address that aspect.\r\n\r\n@jhoneill:\r\n\r\nThe sole reason I linked the quoted (English) phrase to the dictionary definition of the word _obtuse_ was to eliminate any uncertainty around  what that word is commonly understood to mean.\r\n",
      "created_at": "2019-11-24T15:55:17Z",
      "updated_at": "2019-11-24T15:57:22Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@vexx32:\r\n\r\nI've updated the initial post to clarify that ~~the behavior should only apply if there's at least one untagged parameter present; in the absence of such, the no-argument invocation should default to the _one_ explicit parameter set, if there's only one~~; otherwise, explicitly naming a default should be _required_, as is already the case (except if there's only _two_ and only _one_ of them has a mandatory parameter).\r\n\r\n> It seems quite common for cmdlets and functions to leave optional parameters in \"all sets\" when the design is based around a specific number of sets.\r\n\r\nTo be clear: I'm not proposing that that be changed at all. Untagged parameters should continue to be implicitly part of all parameter sets. \r\n\r\nWhat may be confusing is that `_AllParameterSets` does double duty:\r\n\r\n* as a \"meta\" parameter-set name simply signaling \"I belong to all parameter sets, whichever ones may be defined\".\r\n\r\n* as a concrete, implicitly defined parameter set that comprises the untagged parameters only, as well as the no-arguments case (if permitted).\r\n\r\nWith the above clarification re the logic only applying in the presence of at least one tagged parameter, I don't actually see any existing cases that would break - only _additional_ use cases would be enabled.\r\n\r\n\r\n",
      "created_at": "2019-11-24T16:05:17Z",
      "updated_at": "2019-11-26T17:43:39Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 it is pretty common from what I've seen where the author doesn't _want_ `__AllParameterSets` to be its own set, when they have multiple defined sets.\r\n\r\nAs an example:\r\nhttps://github.com/vexx32/PSWordCloud/blob/master/Module/src/NewWordCloudCommand.cs\r\n\r\nI have several parameters that need to be in all the regular sets, but if you could call that with __AllParameterSets being the active set, that command would break (and currently works as intended).",
      "created_at": "2019-11-24T16:15:30Z",
      "updated_at": "2019-11-24T16:16:25Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "\r\n@mklement0  Maybe it's a British usage: like the angle \"acute\" means \"sharp\" (and therefore quick-witted etc.) and \"obtuse\" means the opposite but it is used more in the sense \"you're looking at this back-to-front\", than \"you are an idiot\".  (Possibly people muddle up 'approaching it obliquely' and \"going off at tangent\")  But if you got the sense of \"wantonly stupid\" from it that was the never the intent.  I think there are bits of this Joel doesn't get (see below) and I've assumed he has a brain the size of a planet :-) My biggest learning from being a teacher is that people learn things in different sequences and you can't conclude someone is ignorant because they don't know X, they may know Y and Z which are \"advanced topics\".   \r\n\r\n@vexx32  If someone complains about what I've said I tend to apologise or/and justify it, and that's not always the best personality trait.  \r\n  \r\n> to your actual point @jhoneill I will simply say that the binder is woefully inadequate in any but very simple circumstances. As soon as you have a number of sets with at least one mandatory parameter each, it is completely impossible to tell the binder that you want to create a set with no mandatory parameters at all.\r\n\r\nNo,  I have that in multiple places  just write\r\n`[cmdletbinding(defaultParameterSet=\"a\")]`\r\nWhere \"a\" is a set not referenced anywhere else. \r\nsee https://github.com/dfinke/ImportExcel/blob/master/Send-SQLDataToExcel.ps1\r\nfor an example with 4 sets  each has at least one mandatory parameter and set is selected by the presence of one parameter and the absence of another.   Running it with no parameters drops through with a warning message,\r\n\r\nor see https://github.com/dfinke/ImportExcel/blob/master/PivotTable.ps1 where a mandatory parameter - the only one in that set - selects a set and no-parameters-in-either-set selects the other set\r\n\r\n> For an exercise in frustration, I invite you to attempt to add a parameter set to Where-Object that takes no mandatory parameters. The binder alternates between other defined sets, but will completely refuse to recognise a set that doesn't contain any mandatory parameters.\r\n\r\n\r\nLike  this \r\n\r\n```\r\n> New-ProxyCommand Where-Object | clip\r\n#5 minutes later. \r\n\r\n>$x = ($Null ,1,2, $null , 3 )\r\n>$x.Count\r\n5\r\n\r\n>$x = ($Null ,1,2, $null , 3 | where-object) \r\n>$x.count\r\n3\r\n```\r\n  https://gist.github.com/jhoneill/83e263836a12f1ccab1019f3ab0373dd  \r\n\r\n> The binder needs improvement.\r\n**Agree.**  \r\n\r\n> That said, I do see potential for confusion with users here if we take this suggestion as it is.\r\nConfusion as a minimum. Which isn't to say **nothing** should be done, but I think what is suggested here is the wrong thing for the wrong reason.  \r\n\r\n> I would, however, definitely appreciate some way to indicate to the binder that I _do_ want `__AllParameterSets` to be a valid choice when working through binding logic.\r\n\r\nSee what I did above. Create one more set name which only appears as the default set. \r\n\n\n<blockquote><img src=\"https://avatars3.githubusercontent.com/u/67258?s=400&v=4\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicon.ico\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/dfinke/ImportExcel\">dfinke/ImportExcel</a></strong></div><div>PowerShell module to import/export Excel spreadsheets, without Excel - dfinke/ImportExcel</div></blockquote>\n<blockquote><img src=\"https://avatars3.githubusercontent.com/u/67258?s=400&v=4\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicon.ico\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/dfinke/ImportExcel\">dfinke/ImportExcel</a></strong></div><div>PowerShell module to import/export Excel spreadsheets, without Excel - dfinke/ImportExcel</div></blockquote>\n<blockquote><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicon.ico\" height=\"14\"> Gist</div><div><strong><a href=\"https://gist.github.com/jhoneill/83e263836a12f1ccab1019f3ab0373dd\">Where-object with no parameter support</a></strong></div><div>Where-object with no parameter support. GitHub Gist: instantly share code, notes, and snippets.</div></blockquote>",
      "created_at": "2019-11-24T17:17:21Z",
      "updated_at": "2019-11-24T17:17:23Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@vexx32, I don't think my proposal would break your use case, because the intent is definitely to retain the existing belongs-to-ALL-parameter-sets-if-untagged logic.\r\n\r\n`__AllParameterSets` becoming the effective set would apply _if and only if_:\r\n* _no_ default set is explicitly designated in `[CmdletBinding()]`\r\n* _and_ untagged parameters _only_ are bound during invocation\r\n\r\nThat is, in your example, passing just the untagged `-ExcludeWord` parameter (hypothetically) would still make `$PSCmdlet.ParameterSetName` reflect `ColorBackground `, the explicitly designated default set.\r\n\r\nI really wish we could rename `__AllParameterSets` to something more sensible like `Default` _in the specific usage as a concrete, implicit default set_ - but [that ship has obviously sailed](https://github.com/search?q=__AllParameterSets&type=Code).\r\n",
      "created_at": "2019-11-24T17:23:21Z",
      "updated_at": "2019-11-24T17:29:53Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@vexx32, \r\n\r\nI've realized that my proposal does break certain edge cases, which are now summarized in the initial post.\r\n\r\nI've also gone back to proposing that in the absence of an _explicit_ default parameter set parameter-less invocations should always be allowed (whether all-parameter-sets parameters are also declared or not), because the current behavior is questionable in that respect too - and is buggy: see #11201.\r\n\r\nThe proposal in the initial post now lays out simple rules that should be easy to document and remember.\r\n\r\nI realize that nothing may come of this issue directly, but the initial post can now serve as the basis for an RFC and for assessing potential ramifications.\r\n\r\n",
      "created_at": "2019-11-26T18:04:37Z",
      "updated_at": "2019-11-26T18:04:37Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@vexx32:\r\n\r\nAfter more discussion in #11201, I'm closing this in favor of a new proposal in https://github.com/PowerShell/PowerShell/issues/11201#issuecomment-559491980.\r\n\r\nLike the proposal in this issue, it won't go anywhere without an RFC.\r\nIt would undoubtedly be an unacceptable breaking change, but hope it can get the discussion started to at least make it an optional feature.\r\n\r\nThe basic idea is to:\r\n\r\n* (a) _require_ designating a parameter set as the default in the presence of parameters with explicit parameter sets\r\n* (b) enforce that _at parse time_, with specific error messages that provide resolution guidance\r\n* (c) allow designating parameter set `''` (empty string)  as the default to explicitly allow the no-argument and all-parameter-set-parameters-only invocations and have `$PSCmdlet.ParameterSetName` then reflect `''` for such invocations.\r\n* (d) prevent designating default parameter sets that aren't actually (implicitly) defined via `[Parameter()]` attributes.\r\n",
      "created_at": "2019-11-29T13:59:22Z",
      "updated_at": "2019-11-29T13:59:22Z"
    },
    {
      "author": "alx9r",
      "author_association": "NONE",
      "body": "> As soon as you have a number of sets with at least one mandatory parameter each, it is completely impossible to tell the binder that you want to create a set with no mandatory parameters at all.\r\n\r\n@vexx32 I'm trying to interpret this statement.  [I've been using `__AllParameterSets`](https://stackoverflow.com/a/43702599/1404637) to tell the binder that I want to create a set with no mandatory parameters at all:\r\n\r\n```PowerShell\r\nfunction TwoSets{\r\n    [CmdletBinding(DefaultParameterSetName = '__AllParameterSets')]\r\n    param ( $NoSet,\r\n            [parameter(ParameterSetName = 'A', Mandatory = $true)]$A,\r\n            [parameter(ParameterSetName = 'B', Mandatory = $true)]$B  )\r\n    process { $PSCmdlet.ParameterSetName }\r\n}\r\n\r\nTwoSets        # __AllParameterSets\r\nTwoSets -A 'a' # A\r\nTwoSets -B 'b' # B\r\n```\r\n\r\nNow I'm wondering whether that only happens to work in that limited case.  I _think_ the matter of \"creating a set with no mandatory parameters at all\" is the crux of #12619.\r\n\r\nEdit: As @jhoneill suggested, it looks like `DefaultParameterSetname = 'NotUsedForParameters'` creates a set with no mandatory parameters.  So that behavior doesn't seem to depend on `__AllParameterSets`, at least in this limited case.\r\n\r\nDid you mean something different in the statement I quoted?  Would the `__AllParameterSets`/`NotUsedForParameters` solution work for the cases you struggled with?",
      "created_at": "2020-05-12T14:45:54Z",
      "updated_at": "2020-05-12T15:02:10Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Nope. It works in some limited cases, but once you get more than a couple of parameter sets the binder fails to resolve the \"nonexistent\" / \"_AllParameterSets\" set at all, and starts demanding you supply one of the parameters for one of the mandatory sets, or outright fails.",
      "created_at": "2020-05-12T15:06:19Z",
      "updated_at": "2020-05-12T15:06:19Z"
    },
    {
      "author": "alx9r",
      "author_association": "NONE",
      "body": "@vexx32 I see now.  I confirmed as much in [this gist using Where-Object's parameters](https://gist.github.com/alx9r/b2dc04f178b4bd1aaafe784a37c45502).  Indeed merely naming a non-existent default parameter set _does not_ result in binding with no arguments.  \r\n\r\nThe strange part is this: Merely removing the `Not` switch and parameter set _does_ result in binding with no arguments.  \r\n\r\nI can see now why this matter leads to confusion.",
      "created_at": "2020-05-12T15:43:24Z",
      "updated_at": "2020-05-12T15:43:24Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Yeah I'd love to refactor Where-Object to be able to handle things like `1..10 | Where-Object -ne 7` or just `| Where-Object` (to filter out nulls) but the parameter binder does _not_ like working like that unfortunately, the number of sets gets into the insane levels on that command & I can't see a way to make the binder work with that sensibly in its current state.",
      "created_at": "2020-05-12T16:01:59Z",
      "updated_at": "2020-05-12T16:01:59Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "As an aside, @alx9r: Currently, PowerShell doesn't enforce that at least one parameter - whether explicitly or implicitly - be part of the designated default parameter set, so there is no strict need for the `$NoSet` parameter in your code; that said, my [proposal here]( https://github.com/PowerShell/PowerShell/issues/11201#issuecomment-559491980) - unequivocally a breaking change - would change that.\r\n",
      "created_at": "2020-05-13T12:50:27Z",
      "updated_at": "2020-05-13T12:50:37Z"
    }
  ],
  "created_at": "2019-11-21T14:15:03Z",
  "number": 11143,
  "state": "closed",
  "title": "Advanced functions require specifying a default parameter set with two or more explicit parameter sets",
  "updated_at": "2020-05-13T12:50:37Z"
}