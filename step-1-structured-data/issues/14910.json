{
  "_url": "https://github.com/PowerShell/PowerShell/issues/14910",
  "author": "plastikfan",
  "body": "<!--\r\n\r\nFor Windows PowerShell 5.1 issues, suggestions, or feature requests please use the following link instead:\r\nWindows PowerShell [UserVoice](https://windowsserver.uservoice.com/forums/301869-powershell)\r\n\r\nThis repository is **ONLY** for PowerShell Core 6 and PowerShell 7+ issues.\r\n\r\n- Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\r\n- Search the existing issues.\r\n- Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\r\n- Refer to the [known issues](https://docs.microsoft.com/powershell/scripting/whats-new/known-issues-ps6).\r\n\r\n-->\r\n\r\nI discovered this anomoly whilst building some parameter set analysis tools, so the code example below is in relation to accessing a command's parameter set information.\r\n\r\nThe code is in the context of a Pester test case\r\n\r\n## Steps to reproduce\r\n\r\n```powershell\r\nusing namespace System.Management.Automation;\r\n\r\nDescribe 'Hashtable.Count' -Tag 'Bug' {\r\n  BeforeAll {\r\n    function script:Get-CommandDataSet {\r\n      [OutputType([array])]\r\n      param(\r\n        [Parameter()]\r\n        [CommandInfo]$CommandInfo,\r\n\r\n        [Parameter()]\r\n        [CommandParameterSetInfo]$ParamSet\r\n      )\r\n\r\n      [string[]]$commonParamSet = @('Verbose', 'Debug', 'ErrorAction', 'WarningAction',\r\n        'InformationAction', 'VerboseAction', 'DebugAction', 'ProgressAction',\r\n        'ErrorVariable', 'WarningVariable', 'InformationVariable', 'DebugVariable',\r\n        'VerboseVariable', 'ProgressVariable', 'OutVariable', 'OutBuffer',\r\n        'PipelineVariable', 'WhatIf', 'Confirm');\r\n\r\n      [array]$parametersToShow = $ParamSet.Parameters | Where-Object Name -NotIn $commonParamSet;\r\n\r\n      [PSCustomObject[]]$resultSet = ($parametersToShow `\r\n        | Select-Object -Property @(\r\n          'Name'\r\n          @{Name = 'Type'; Expression = { $_.ParameterType.Name }; }\r\n          @{Name = 'Mandatory'; Expression = { $_.IsMandatory } }\r\n          @{Name = 'Pos'; Expression = { if ($_.Position -eq [int]::MinValue) { 'named' } else { $_.Position } } }\r\n          @{Name = 'PipeValue'; Expression = { $_.ValueFromPipeline } }\r\n          @{Name = 'PipeName'; Expression = { $_.ValueFromPipelineByPropertyName } }\r\n          @{Name = 'Alias'; Expression = { $_.Aliases -join ',' } }\r\n        ));\r\n\r\n      $resultSet;\r\n    }\r\n    function script:Get-HashTable {\r\n      param(\r\n        [Parameter()]\r\n        [array]$Data\r\n      )\r\n      [hashtable]$table = @{}\r\n      foreach ($row in $resultSet) {\r\n        [PSCustomObject]$insert = @{}\r\n        foreach ($field in $row.psobject.properties.name) {\r\n          [string]$raw = $row.$field;\r\n          $insert.$field = $raw;\r\n        }\r\n        $table[$row.Name] = $insert;\r\n      }\r\n\r\n      return $table;\r\n    }\r\n  }\r\n\r\n  Context 'given: Clear-History command' {\r\n    It 'why should: Count property cause not IComparable error?' {\r\n      [string]$commandName = 'Clear-History';\r\n      [CommandInfo]$commandInfo = Get-Command $commandName;\r\n      if ($commandInfo) {\r\n        [CommandParameterSetInfo]$paramSet = $($commandInfo.ParameterSets | Where-Object {\r\n          $_.Name -eq 'IDParameter' }\r\n        )?[0];\r\n\r\n        if ($paramSet) {\r\n          [array]$resultSet = Get-CommandDataSet -CommandInfo $commandInfo -ParamSet $paramSet;\r\n          [hashtable]$table = Get-HashTable -Data $resultSet;\r\n\r\n          if ($table.Keys.Count -gt 0) {\r\n            Write-Host \"*** [$commandName] Hash Keys count access Ok\"\r\n          }\r\n          if (0 -lt ($table.Length)) {\r\n            Write-Host \"*** [$commandName] Hash Length access Ok\"\r\n          }\r\n          # Now stir up some mysterious trouble\r\n          #\r\n          if ($table.Count -gt 0) {\r\n            # Reference:\r\n            # https://docs.microsoft.com/en-us/dotnet/api/system.collections.hashtable.count?view=net-5.0\r\n            #\r\n            # Cannot compare \"System.Collections.Hashtable\" because it is not IComparable.\r\n            #\r\n            Write-Host \"*** [$commandName] Hash.Count fails\"\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  Context 'given: Invoke-Command command' {\r\n    It 'why should: Count property cause not IComparable error?' {\r\n      [string]$commandName = 'Invoke-Command';\r\n      [CommandInfo]$commandInfo = Get-Command $commandName;\r\n      if ($commandInfo) {\r\n        [CommandParameterSetInfo]$paramSet = $($commandInfo.ParameterSets | Where-Object {\r\n            $_.Name -eq 'Uri' }\r\n        )?[0];\r\n\r\n        if ($paramSet) {\r\n          [array]$resultSet = Get-CommandDataSet -CommandInfo $commandInfo -ParamSet $paramSet;\r\n          [hashtable]$table = Get-HashTable -Data $resultSet;\r\n\r\n          # Why does this work, when it fails for Clear-History\r\n          #\r\n          if ($table.Count -gt 0) {\r\n            Write-Host \"*** [$commandName] Hash count access Ok\"\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## Expected behavior\r\n\r\n```powershell\r\naccessing the Count property on a hashtable instance should be reliable. There is a workaround and that is to use $hash.Keys.Count instead of $hash.Count\r\n```\r\n\r\n## Actual behavior\r\nSometimes, accessing $hash.Count fails with IComparable error:\r\n\r\n```none\r\n[-] Hashtable.Count.given: Clear-History command.why should: Count property cause not IComparable error? 21ms (20ms|1ms)\r\n RuntimeException: Cannot compare \"System.Collections.Hashtable\" because it is not IComparable.\r\n at <ScriptBlock>, C:\\Users\\Plastikfan\\dev\\github\\PoSh\\Loopz\\Elizium.Loopz\\Tests\\Internal\\utils\\get-ParameterSetTableData.tests.ps1:139\r\n\r\n```\r\n\r\nIt should be noted that I ran my code on all commands currently installed on my windows 10 based system which I retrieved via this command:\r\n\r\n> $sorted = (gcm | Where-Object { -not($_.name.Contains(':')) } | Sort-Object -Property Name -Unique).\r\n\r\nMost commands were fine, but there is a small minority of commands including the failing one in this example: 'Clear-History' for which accessing the hashtable's Count property failed. This inconsistency needs an explanation otherwise its a bug that needs a fix. The fact that $hash.Keys.Count works in all cases and $hash.Count is inconsistent, leads me to think it is a bug.\r\n\r\n## Environment data\r\n\r\n<!-- provide the output of $PSVersionTable -->\r\n\r\n```none\r\n\u03bb $PSVersionTable\r\n\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.1.2\r\nPSEdition                      Core\r\nGitCommitId                    7.1.2\r\nOS                             Microsoft Windows 10.0.19041\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n\r\n```\r\n",
  "closed_at": "2021-02-26T17:06:10Z",
  "comments": [
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "When you use property-access syntax with `IDictionary` instances, _entry keys_ take precedence over _the implementing type's type-native properties_.\r\n\r\nA simple example:\r\n\r\n```powershell\r\n# OK - no name conflict.\r\nPS> @{ Foo = 'Bar' }.Count\r\n1\r\n\r\n# Name conflict between [hashtable]'s own .Count property and the *entry* whose key is 'Count' \r\nPS> @{ Count = 'Chocula' }.Count\r\nChocula  # !! 'Count' *entry* took precedence\r\n```\r\n\r\n`Clear-History` has a parameter named `Count`, which caused the problem.\r\n\r\nThe workarounds are non-obvious, unfortunately:\r\n\r\n```powershell\r\nPS> @{ Count = 'Chocula' }.psbase.Count\r\n1\r\n\r\n# Alternatively:\r\nPS> @{ Count = 'Chocula' }.get_Count()\r\n1\r\n```\r\n",
      "created_at": "2021-02-26T16:55:26Z",
      "updated_at": "2021-02-26T16:55:26Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Actually, this was previously reported in #7758, which was closed as by-design.\r\n\r\nFortunately, the `.psbase` workaround is now mentioned in [`about_Hash_Tables`](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_Hash_Tables).\r\n\r\nThe somewhat unfortunate aspect is that the `IDictionary` logic is the inverse of the logic applied by _member enumeration_:\r\n\r\n```powershell\r\n$coll = [pscustomobject] @{ Foo = 1; Count = 'Chocula' }, [pscustomobject] @{ Foo = 2; Count = 'Dracula' }\r\n\r\nPS> $coll.Foo\r\n1\r\n2\r\n\r\nPS> $coll.Count\r\n2  # !! Collection-type .Count took precedence\r\n```",
      "created_at": "2021-02-26T17:02:17Z",
      "updated_at": "2021-02-26T17:02:17Z"
    },
    {
      "author": "plastikfan",
      "author_association": "NONE",
      "body": "Ok, I'm glad there's a rational explanation for this. So when using IDictionary instances, the safest way to go in general is to avoid using IDictionary's properies directly. I'm gonna have to review all my PowerShell code for these potential hidden timebombs. Thanks for your insight.",
      "created_at": "2021-02-26T17:02:45Z",
      "updated_at": "2021-02-26T17:02:45Z"
    },
    {
      "author": "plastikfan",
      "author_association": "NONE",
      "body": "I realy did try and search for other issues, but I didnt find #7758, so I'll close this one.",
      "created_at": "2021-02-26T17:06:10Z",
      "updated_at": "2021-02-26T17:06:10Z"
    }
  ],
  "created_at": "2021-02-26T16:21:25Z",
  "number": 14910,
  "state": "closed",
  "title": "Why is accessing Count property on Hashtable unreliable?",
  "updated_at": "2021-02-26T17:06:11Z"
}