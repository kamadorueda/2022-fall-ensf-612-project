{
  "_url": "https://github.com/PowerShell/PowerShell/issues/13061",
  "author": "x10an14",
  "body": "<!--\r\n\r\nFor Windows PowerShell 5.1 issues, suggestions, or feature requests please use the following link instead:\r\nWindows PowerShell [UserVoice](https://windowsserver.uservoice.com/forums/301869-powershell)\r\n\r\nThis repository is **ONLY** for PowerShell Core 6 and PowerShell 7+ issues.\r\n\r\n- Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\r\n- Search the existing issues.\r\n- Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\r\n- Refer to the [known issues](https://docs.microsoft.com/powershell/scripting/whats-new/known-issues-ps6).\r\n\r\n-->\r\n\r\n## Steps to reproduce\r\n\r\n```powershell\r\nAdd-Type -AssemblyName System.Net.Http\r\nAdd-Type -AssemblyName System.Net.Security\r\nAdd-Type -AssemblyName System.Security.Cryptography.X509Certificates\r\n\r\n$targetUrls = @{\r\n\t\"https://outlook.com\" = $null\r\n\t\"https://google.com\" = $null\r\n}\r\n\r\n\r\nfunction Invoke-ServerCertificateCusomValidationCallback {\r\n\t<#\r\n\t.SYNOPSIS\r\n\t\tCall-back function for System.Net.Http.HttpClientHandler.ServerCertificateCustomValidationCallback where this script gets access to the HTTPs Requests certificate data.\r\n\t#>\r\n\t[CmdletBinding()]\r\n\tparam (\r\n\t\t[System.Net.Http.HttpRequestMessage]$httpRequestMsg,\r\n\t\t[System.Security.Cryptography.X509Certificates.X509Certificate2]$certificate,\r\n\t\t[System.Security.Cryptography.X509Certificates.X509Chain]$certificateChain,\r\n\t\t[System.Net.Security.SslPolicyErrors]$sslErrors\r\n\t)\r\n\tprocess {\r\n\t\tif ($targetUrls.ContainsKey($httpRequestMsg.RequestUri.ToString())) {\r\n\t\t\t$expirationTimeDelta = (\r\n\t\t\t\t[DateTime]::Parse($certificate.GetExpirationDateString()) -\r\n\t\t\t\t[DateTime]::Today\r\n\t\t\t).Days\r\n\t\t\tWrite-Host \"\\t${$httpRequestMsg.RequestUri} expires in ${$expirationTimeDelta} days!\"\r\n\t\t}\r\n\t}\r\n\tend {\r\n\t\treturn $sslErrors -eq [System.Net.Security.SslPolicyErrors].None\r\n\t}\r\n}\r\n\r\n# Set-up HttpClient & handler\r\n$handler = New-Object -TypeName System.Net.Http.HttpClientHandler\r\n$handler.ServerCertificateCustomValidationCallback = Invoke-ServerCertificateCusomValidationCallback\r\n$client = New-Object -TypeName System.Net.Http.HttpClient -ArgumentList $handler\r\n\r\n# Fetch HTTP Requests Async\r\n$targetUrls.Keys.Clone() | ForEach-Object {\r\n\tWrite-Host \"Initating HTTPs Request to ${$_} ...\"\r\n\t$targetUrls[$_] = $client.GetAsync($_).GetAwaiter()\r\n}\r\n\r\n# Await Async HTTP Requests to return\r\n$targetUrls.Keys.Clone() | ForEach-Object {\r\n\t# These two for-loops does NOT leverage the async functionality of the HTTP requests...\r\n\t$targetUrls[$_].GetResult()\r\n\tWrite-Host \"${$_} returned status code ${$targetUrls[$_].StatusCode}\"\r\n}\r\n```\r\n\r\n## Expected behavior\r\n\r\n```\r\nInitiating HTTPs Request to https://outlook.com ...\r\nInitiating HTTPs Request to https://google.com ...\r\n\thttps://google.com expires in X days!\r\n\thttps://outlook.com expires in X days!\r\nhttps://outlook.com returned status code 200\r\nhttps://google.com returned status code 200\r\n```\r\n\r\n## Actual behavior\r\n\r\nWhen copy-pasting line-by-line into a `pwsh` terminal, I get the below error when copy-pasting the line;\r\n```powershell\r\n$handler.ServerCertificateCustomValidationCallback = Invoke-ServerCertificateCusomValidationCallback\r\n```\r\n\r\n```powershell\r\nPS /home/x10an14> $handler = New-Object -TypeName System.Net.Http.HttpClientHandler\r\nPS /home/x10an14> $handler.ServerCertificateCustomValidationCallback = Invoke-ServerCertificateCusomValidationCallback\r\nInvalidOperation: \r\nLine |\r\n  14 |  if ($targetUrls.ContainsKey($httpRequestMsg.RequestUri.ToString())) {\r\n     |      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n     | You cannot call a method on a null-valued expression.\r\nSetValueInvocationException: Exception setting \"ServerCertificateCustomValidationCallback\": \"Cannot convert value \"True\" to type \"System.Func`5[System.Net.Http.HttpRequestMessage,System.Security.Cryptography.X509Certificates.X509Certificate2,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors,System.Boolean]\". Error: \"Invalid cast from 'System.Boolean' to 'System.Func`5[[System.Net.Http.HttpRequestMessage, System.Net.Http, Version=4.2.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a],[System.Security.Cryptography.X509Certificates.X509Certificate2, System.Security.Cryptography.X509Certificates, Version=4.2.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a],[System.Security.Cryptography.X509Certificates.X509Chain, System.Security.Cryptography.X509Certificates, Version=4.2.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a],[System.Net.Security.SslPolicyErrors, System.Net.Primitives, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a],[System.Boolean, System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]'.\"\"\r\nPS /home/x10an14/Documents/bos/microsoft_csharp_certificates_test> \r\n```\r\n\r\n## Environment data\r\n\r\n<!-- provide the output of $PSVersionTable -->\r\n\r\n```powershell\r\nPS /home/x10an14> $PSVersionTable\r\n\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.0.2\r\nPSEdition                      Core\r\nGitCommitId                    7.0.2\r\nOS                             Linux 4.19.0-9-amd64 #1 SMP Debian 4.19.118-2+deb10u1 (2020-06-07)\r\nPlatform                       Unix\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n\r\n```\r\n",
  "closed_at": "2020-07-01T11:51:17Z",
  "comments": [
    {
      "author": "x10an14",
      "author_association": "NONE",
      "body": "# Worth to note\r\nThe below C# code works, with the output given at the end;\r\n\r\n```csharp\r\nusing System;\r\nusing System.Net.Http;\r\nusing System.Net.Security;\r\nusing System.Security.Cryptography.X509Certificates;\r\n\r\nnamespace microsoft_csharp_certificates_test\r\n{\r\n    class Program\r\n    {\r\n        private static string TargetUrl = \"https://outlook.com\";\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            var handler = new HttpClientHandler();\r\n            handler.ServerCertificateCustomValidationCallback = CustomCallback;\r\n            var client = new HttpClient(handler);\r\n\r\n            HttpResponseMessage response = client.GetAsync(TargetUrl).GetAwaiter().GetResult();\r\n            Console.WriteLine(TargetUrl + \" response; \" + response.StatusCode);\r\n            Console.WriteLine(TargetUrl + \" response status code; \" + (int)response.StatusCode);\r\n        }\r\n\r\n        private static bool CustomCallback(HttpRequestMessage httpRequest, X509Certificate2 certificate, X509Chain arg3, SslPolicyErrors arg4)\r\n        {\r\n            Uri UriUrlMatch = new Uri(TargetUrl);\r\n            if (UriUrlMatch == httpRequest.RequestUri) {\r\n                Console.WriteLine(\"Certificate received for; \" + httpRequest.RequestUri);\r\n                Console.WriteLine(\"\\tCertificate issuer; \" + certificate.Issuer);\r\n                Console.WriteLine(\"\\tCertificate subject; \" + certificate.Subject);\r\n                Console.WriteLine(\"\\tCertificate effective date string; \" + certificate.GetEffectiveDateString());\r\n                Console.WriteLine(\"\\tCertificate expiration date string; \" + certificate.GetExpirationDateString());\r\n\r\n                var expirationTimeDelta = DateTime.Parse(certificate.GetExpirationDateString()) - DateTime.Today;\r\n                Console.WriteLine(\"\\t\\tDays until expiration; \" + expirationTimeDelta.Days);\r\n            }\r\n\r\n            return arg4 == SslPolicyErrors.None;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n```none\r\n-> $ dotnet run\r\nCertificate received for; https://outlook.com/\r\n\tCertificate issuer; CN=DigiCert Cloud Services CA-1, O=DigiCert Inc, C=US\r\n\tCertificate subject; CN=outlook.com, O=Microsoft Corporation, L=Redmond, S=Washington, C=US\r\n\tCertificate effective date string; 18/11/2018 01:00:00\r\n\tCertificate expiration date string; 18/11/2020 13:00:00\r\n\t\tDays until expiration; 141\r\nhttps://outlook.com response; OK\r\nhttps://outlook.com response status code; 200\r\n```",
      "created_at": "2020-06-30T11:59:52Z",
      "updated_at": "2020-06-30T11:59:52Z"
    },
    {
      "author": "x10an14",
      "author_association": "NONE",
      "body": "## Second thing to note\r\nThe purpose of this script is to have;\r\n  - .NET Core based OS-Agnostic PowerShell script \r\n  - which check days until expiration for specified list of HTTPs certificates (read: URLs/FQDNs).",
      "created_at": "2020-06-30T12:20:20Z",
      "updated_at": "2020-06-30T12:21:01Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "When you assign by calling the function itself, you actually are _calling_ (invoking) the function by doing so; you're not assigning a delegate like C# does, you're just assigning the resultant value.\r\n\r\nPowerShell _does_ generally have the capability (in some cases) to cast scriptblocks to `Func<,>` types, for which you'll need to target the scriptblock itself:\r\n\r\n```ps1\r\n$handler.ServerCertificateCustomValidationCallback = ${function:Invoke-ServerCertificateCusomValidationCallback}\r\n```\r\n\r\nYou also have the option of simply saving that scriptblock to a variable or directly assigning it rather than creating a named function if you prefer.\r\n\r\n```ps1\r\n$handler.ServerCertificateCustomValidationCallback = {\r\n\t[CmdletBinding()]\r\n\tparam (\r\n\t\t[System.Net.Http.HttpRequestMessage]$httpRequestMsg,\r\n\t\t[System.Security.Cryptography.X509Certificates.X509Certificate2]$certificate,\r\n\t\t[System.Security.Cryptography.X509Certificates.X509Chain]$certificateChain,\r\n\t\t[System.Net.Security.SslPolicyErrors]$sslErrors\r\n\t)\r\n\tprocess {\r\n\t\tif ($targetUrls.ContainsKey($httpRequestMsg.RequestUri.ToString())) {\r\n\t\t\t$expirationTimeDelta = (\r\n\t\t\t\t[DateTime]::Parse($certificate.GetExpirationDateString()) -\r\n\t\t\t\t[DateTime]::Today\r\n\t\t\t).Days\r\n\t\t\tWrite-Host \"\\t${$httpRequestMsg.RequestUri} expires in ${$expirationTimeDelta} days!\"\r\n\t\t}\r\n\t}\r\n\tend {\r\n\t\treturn $sslErrors -eq [System.Net.Security.SslPolicyErrors].None\r\n\t}\r\n}\r\n```\r\n\r\nI haven't tested this, though, so perhaps you may find the built in conversions for this kind of thing insufficient to handle it.",
      "created_at": "2020-06-30T12:41:22Z",
      "updated_at": "2020-06-30T12:43:10Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "Adding to what @vexx32 said, keep in mind that if the callback is invoked on a different thread the results can be unpredictable.  ",
      "created_at": "2020-06-30T12:44:52Z",
      "updated_at": "2020-06-30T12:44:52Z"
    },
    {
      "author": "x10an14",
      "author_association": "NONE",
      "body": "Given the caveats you've both mentioned @SeeminglyScience and @vexx32, what's your recommended way of achieving my goals?\r\n\r\nGiven the goals listed here; https://github.com/PowerShell/PowerShell/issues/13061#issuecomment-651756023\r\n\r\nAm I still on what you (and/or others) would suggest is the recommended path/track?",
      "created_at": "2020-06-30T12:55:14Z",
      "updated_at": "2020-06-30T12:55:14Z"
    },
    {
      "author": "x10an14",
      "author_association": "NONE",
      "body": "I just attempted with the suggested edit by @vexx32; https://github.com/PowerShell/PowerShell/issues/13061#issuecomment-651765614.\r\n\r\nI think that solved the originally reported issue, but I triggered a new issue;\r\n```powershell\r\nPS /home/x10an14> $client = New-Object -TypeName System.Net.Http.HttpClient -ArgumentList $handler\r\nPS /home/x10an14> \r\nPS /home/x10an14> # Fetch HTTP Requests Async\r\nPS /home/x10an14> $targetUrls.Keys.Clone() | ForEach-Object {\r\n>> $targetUrls[$_] = $client.GetAsync($_).GetAwaiter()\r\n>> }\r\nPS /home/x10an14> \r\nPS /home/x10an14> # Await Async HTTP Requests to return\r\nPS /home/x10an14> $targetUrls.Keys.Clone() | ForEach-Object {\r\n>> # These two for-loops does NOT leverage the async functionality of the HTTP requests...\r\n>> $targetUrls[$_].GetResult()\r\n>> Write-Host \"${$_} returned status code ${$targetUrls[$_].StatusCode}\"\r\n>> }\r\nMethodInvocationException: \r\nLine |\r\n   3 |  $targetUrls[$_].GetResult()\r\n     |  ~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n     | Exception calling \"GetResult\" with \"0\" argument(s): \"The SSL connection could not be established, see inner exception.\"\r\n returned status code \r\nMethodInvocationException: \r\nLine |\r\n   3 |  $targetUrls[$_].GetResult()\r\n     |  ~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n     | Exception calling \"GetResult\" with \"0\" argument(s): \"The SSL connection could not be established, see inner exception.\"\r\n returned status code\r\n```\r\n\r\nIt even happened when I made an attempt by-passing the for-loops/dictonary;\r\n```powershell\r\nPS /home/x10an14> $a = $client.GetAsync(\"https://outlook.com\").GetAwaiter()\r\nPS /home/x10an14> $a.GetResult()\r\nMethodInvocationException: Exception calling \"GetResult\" with \"0\" argument(s): \"The SSL connection could not be established, see inner exception.\"\r\nPS /home/x10an14> $client.GetAsync(\"https://outlook.com\").GetAwaiter().GetResult()\r\nMethodInvocationException: Exception calling \"GetResult\" with \"0\" argument(s): \"The SSL connection could not be established, see inner exception.\"\r\nPS /home/x10an14> \r\n```\r\n\r\nAnyone have any idea/suggestions?",
      "created_at": "2020-06-30T13:05:50Z",
      "updated_at": "2020-06-30T13:06:05Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Hard to say without seeing the exception details; if you call `Get-Error` you should see some more relevant detail.",
      "created_at": "2020-06-30T13:09:26Z",
      "updated_at": "2020-06-30T13:09:26Z"
    },
    {
      "author": "x10an14",
      "author_association": "NONE",
      "body": "Ho damn, that's a long output.\r\nHere goes;\r\n\r\n```powershell\r\nPS /home/x10an14> Get-Error\r\n\r\nException             : \r\n    Type           : System.Management.Automation.MethodInvocationException\r\n    ErrorRecord    : \r\n        Exception             : \r\n            Type    : System.Management.Automation.ParentContainsErrorRecordException\r\n            Message : Exception calling \"GetResult\" with \"0\" argument(s): \"The SSL connection could not be established, see inner exception.\"\r\n            HResult : -2146233087\r\n        CategoryInfo          : NotSpecified: (:) [], ParentContainsErrorRecordException\r\n        FullyQualifiedErrorId : HttpRequestException\r\n        InvocationInfo        : \r\n            ScriptLineNumber : 1\r\n            OffsetInLine     : 1\r\n            HistoryId        : -1\r\n            Line             : $client.GetAsync(\"https://outlook.com\").GetAwaiter().GetResult()\r\n            PositionMessage  : At line:1 char:1\r\n                               + $client.GetAsync(\"https://outlook.com\").GetAwaiter().GetResult()\r\n                               + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n            CommandOrigin    : Internal\r\n        ScriptStackTrace      : at <ScriptBlock>, <No file>: line 1\r\n    TargetSite     : \r\n        Name          : ConvertToMethodInvocationException\r\n        DeclaringType : System.Management.Automation.ExceptionHandlingOps, System.Management.Automation, Version=7.0.2.0, Culture=neutral, \r\nPublicKeyToken=31bf3856ad364e35\r\n        MemberType    : Method\r\n        Module        : System.Management.Automation.dll\r\n    StackTrace     : \r\n   at System.Management.Automation.ExceptionHandlingOps.ConvertToMethodInvocationException(Exception exception, Type typeToThrow, String methodName, Int32 \r\nnumArgs, MemberInfo memberInfo)\r\n   at CallSite.Target(Closure , CallSite , Object )\r\n   at System.Dynamic.UpdateDelegates.UpdateAndExecute1[T0,TRet](CallSite site, T0 arg0)\r\n   at System.Management.Automation.Interpreter.DynamicInstruction`2.Run(InterpretedFrame frame)\r\n   at System.Management.Automation.Interpreter.EnterTryCatchFinallyInstruction.Run(InterpretedFrame frame)\r\n    Message        : Exception calling \"GetResult\" with \"0\" argument(s): \"The SSL connection could not be established, see inner exception.\"\r\n    Data           : System.Collections.ListDictionaryInternal\r\n    InnerException : \r\n        Type           : System.Net.Http.HttpRequestException\r\n        TargetSite     : \r\n            Name          : MoveNext\r\n            DeclaringType : System.Net.Http.ConnectHelper+<EstablishSslConnectionAsyncCore>d__4, System.Net.Http, Version=4.2.2.0, Culture=neutral, \r\nPublicKeyToken=b03f5f7f11d50a3a\r\n            MemberType    : Method\r\n            Module        : System.Net.Http.dll\r\n        StackTrace     : \r\n   at System.Net.Http.ConnectHelper.EstablishSslConnectionAsyncCore(Stream stream, SslClientAuthenticationOptions sslOptions, CancellationToken \r\ncancellationToken)\r\n   at System.Net.Http.HttpConnectionPool.ConnectAsync(HttpRequestMessage request, Boolean allowHttp2, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpConnectionPool.CreateHttp11ConnectionAsync(HttpRequestMessage request, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpConnectionPool.GetHttpConnectionAsync(HttpRequestMessage request, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpConnectionPool.SendWithRetryAsync(HttpRequestMessage request, Boolean doRequestAuth, CancellationToken cancellationToken)\r\n   at System.Net.Http.RedirectHandler.SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpClient.FinishSendAsyncBuffered(Task`1 sendTask, HttpRequestMessage request, CancellationTokenSource cts, Boolean disposeCts)\r\n   at CallSite.Target(Closure , CallSite , Object )\r\n        Message        : The SSL connection could not be established, see inner exception.\r\n        InnerException : \r\n            Type        : System.Management.Automation.PSInvalidOperationException\r\n            ErrorRecord : \r\n                Exception             : \r\n                    Type    : System.Management.Automation.ParentContainsErrorRecordException\r\n                    Message : There is no Runspace available to run scripts in this thread. You can provide one in the DefaultRunspace property of the \r\nSystem.Management.Automation.Runspaces.Runspace type. The script block you attempted to invoke was:\r\n                              [CmdletBinding()]\r\n                              \u2026licyErrors].None\r\n                              }\r\n                              \r\n                    HResult : -2146233087\r\n                CategoryInfo          : InvalidOperation: (:) [], ParentContainsErrorRecordException\r\n                FullyQualifiedErrorId : ScriptBlockDelegateInvokedFromWrongThread\r\n            TargetSite  : \r\n                Name          : GetContextFromTLS\r\n                DeclaringType : scriptblock\r\n                MemberType    : Method\r\n                Module        : System.Management.Automation.dll\r\n            StackTrace  : \r\n   at System.Management.Automation.ScriptBlock.GetContextFromTLS()\r\n   at System.Management.Automation.ScriptBlock.InvokeAsDelegateHelper(Object dollarUnder, Object dollarThis, Object[] args)\r\n   at lambda_method(Closure , HttpRequestMessage , X509Certificate2 , X509Chain , SslPolicyErrors )\r\n   at System.Net.Http.ConnectHelper.<>c__DisplayClass3_0.<EstablishSslConnectionAsync>b__0(Object sender, X509Certificate certificate, X509Chain chain, \r\nSslPolicyErrors sslPolicyErrors)\r\n   at System.Net.Security.SslStream.UserCertValidationCallbackWrapper(String hostName, X509Certificate2 certificate, X509Chain chain, SslPolicyErrors \r\nsslPolicyErrors)\r\n   at System.Net.Security.SecureChannel.VerifyRemoteCertificate(RemoteCertValidationCallback remoteCertValidationCallback, ProtocolToken& alertToken)\r\n   at System.Net.Security.SslStream.CompleteHandshake(ProtocolToken& alertToken)\r\n   at System.Net.Security.SslStream.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)\r\n   at System.Net.Security.SslStream.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest)\r\n   at System.Net.Security.SslStream.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)\r\n   at System.Net.Security.SslStream.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)\r\n   at System.Net.Security.SslStream.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)\r\n   at System.Net.Security.SslStream.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)\r\n   at System.Net.Security.SslStream.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest)\r\n   at System.Net.Security.SslStream.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)\r\n   at System.Net.Security.SslStream.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)\r\n   at System.Net.Security.SslStream.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)\r\n   at System.Net.Security.SslStream.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)\r\n   at System.Net.Security.SslStream.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest)\r\n   at System.Net.Security.SslStream.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)\r\n   at System.Net.Security.SslStream.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)\r\n   at System.Net.Security.SslStream.PartialFrameCallback(AsyncProtocolRequest asyncRequest)\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Net.Security.SslStream.ThrowIfExceptional()\r\n   at System.Net.Security.SslStream.InternalEndProcessAuthentication(LazyAsyncResult lazyResult)\r\n   at System.Net.Security.SslStream.EndProcessAuthentication(IAsyncResult result)\r\n   at System.Net.Security.SslStream.EndAuthenticateAsClient(IAsyncResult asyncResult)\r\n   at System.Net.Security.SslStream.<>c.<AuthenticateAsClientAsync>b__65_1(IAsyncResult iar)\r\n   at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean \r\nrequiresSynchronization)\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Net.Http.ConnectHelper.EstablishSslConnectionAsyncCore(Stream stream, SslClientAuthenticationOptions sslOptions, CancellationToken \r\ncancellationToken)\r\n            Message     : There is no Runspace available to run scripts in this thread. You can provide one in the DefaultRunspace property of the \r\nSystem.Management.Automation.Runspaces.Runspace type. The script block you attempted to invoke was:\r\n                          [CmdletBinding()]\r\n                          \u2026licyErrors].None\r\n                          }\r\n                          \r\n            Source      : System.Management.Automation\r\n            HResult     : -2146233079\r\n        Source         : System.Net.Http\r\n        HResult        : -2146233079\r\n    Source         : System.Management.Automation\r\n    HResult        : -2146233087\r\nCategoryInfo          : NotSpecified: (:) [], MethodInvocationException\r\nFullyQualifiedErrorId : HttpRequestException\r\nInvocationInfo        : \r\n    ScriptLineNumber : 1\r\n    OffsetInLine     : 1\r\n    HistoryId        : -1\r\n    Line             : $client.GetAsync(\"https://outlook.com\").GetAwaiter().GetResult()\r\n    PositionMessage  : At line:1 char:1\r\n                       + $client.GetAsync(\"https://outlook.com\").GetAwaiter().GetResult()\r\n                       + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n    CommandOrigin    : Internal\r\nScriptStackTrace      : at <ScriptBlock>, <No file>: line 1\r\n\r\nPS /home/x10an14> \r\n```",
      "created_at": "2020-06-30T13:12:01Z",
      "updated_at": "2020-06-30T13:29:46Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "Yeah, that's one of the possible outcomes when invoking a scriptblock delegate in a different thread.  Here are your options:\r\n\r\n1. `Add-Type` to create a compiled static method that you then convert to a delegate\r\n1. Manually create a delegate with `System.Linq.Expressions.Expression`\r\n1. Use [PSLambda](https://github.com/SeeminglyScience/PSLambda)\r\n\r\nThe first is probably the most simple and portable.",
      "created_at": "2020-06-30T13:13:46Z",
      "updated_at": "2020-06-30T13:13:46Z"
    },
    {
      "author": "x10an14",
      "author_association": "NONE",
      "body": "@SeeminglyScience Thanks for your suggestions! Much appreciated!\r\n\r\nI'm struggling though to see how I could leverage https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type?view=powershell-7 (in general - I feel a little out of my depth here).\r\nEspecially without losing the filtering I do in C# with the `TargetUrl` class member. Without it, the callback is called on each and every HTTP redirect performed (at least, that was my experience when I wrote the C# equivalent to confirm this worked on Linux).\r\n\r\nAny suggestions on how to leverage `Add-Type` yet only receiving the date information for the \"target URL\"?\r\nOr any of your other alternatives, while respecting the previously mentioned goals?\n\n<blockquote><img src=\"https://docs.microsoft.com/en-us/media/logos/logo-ms-social.png\" width=\"48\" align=\"right\"><div><strong><a href=\"https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type\">Add-Type (Microsoft.PowerShell.Utility)</a></strong></div><div>The Add-Type cmdlet lets you define a Microsoft .NET Core class in your PowerShell session. You can then instantiate objects, by using the New-Object cmdlet, and use the objects just as you would use any .NET Core object. If you add an Add-Type command to your PowerShell profile, the class is available in all PowerShell sessions. You can specify the type by specifying an existing assembly or source code files, or you can specify the source code inline or saved in a variable. You can even specify only a method and Add-Type defines and generates the class. On Windows, you can use this feature to make Platform Invoke (P/Invoke) calls to unmanaged functions in PowerShell. If you specify source code, Add-Type compiles the specified source code and generates an in-memory assembly that contains the new .NET Core types. You can use the parameters of Add-Type to specify an alternate language and compiler, C# is the default, compiler options, assembly dependencies, the class namespace, the names of the type, and the resulting assembly. Beginning in PowerShell 7, Add-Type does not compile a type if a type with the same name already exists. Also, Add-Type looks for assemblies in a ref folder under the folder that contains pwsh.dll. </div></blockquote>",
      "created_at": "2020-06-30T13:29:11Z",
      "updated_at": "2020-06-30T13:29:13Z"
    },
    {
      "author": "x10an14",
      "author_association": "NONE",
      "body": "@iSazonov Why've you added the `Resolution-Answered` label already?\r\nI sure don't feel as I've been given an answer that satisfies the conditions I made efforts to clarify up-front (see https://github.com/PowerShell/PowerShell/issues/13061#issuecomment-651756023).\r\n\r\nAm I not allowed to edit issue as I uncover more specificity/details previously unknown to me?\r\n\r\nOf course, if I was given a solution (which satisfied initial conditions), and decided I didn't like it, then by all means I could live with that.\r\nI may have misunderstood in my ignorance, but as I understand it, that's _not_ the case as of yet.",
      "created_at": "2020-06-30T13:35:50Z",
      "updated_at": "2020-06-30T13:35:50Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "You'd store your state in a static property.  Or if it's not globally applicable you would make delegate source an instance method and create a new delegate/instance per invocation.\r\n\r\n> @iSazonov Why've you added the Resolution-Answered label already?\r\n\r\nThe bit that is relevant to the repo (e.g. \"why doesn't this work\") has already been answered.  This issue board isn't really for support questions.  @vexx32 and I don't mind helping you get where you're going though, chances are if we redirect you to the PowerShell discord it'll be one of us helping you there anyway \ud83d\ude09 ",
      "created_at": "2020-06-30T13:43:17Z",
      "updated_at": "2020-06-30T13:43:17Z"
    },
    {
      "author": "x10an14",
      "author_association": "NONE",
      "body": "Much appreciated for your follow-up answer and clarification @SeeminglyScience! =)\r\n\r\nI'll continue trying to understand how delegate functions (or static PowerShell properties for that matter) work when work resumes again tomorrow.\r\n\r\nIf, as you say, that this issue has technically been answered, feel free to close it as such then!\r\nI'll re-open new ones instead if I hit a new error I am unable to understand!",
      "created_at": "2020-06-30T14:35:12Z",
      "updated_at": "2020-06-30T14:35:12Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Why've you added the Resolution-Answered label already?\r\n\r\nWe can track nothing here for fixing or developing in PowerShell engine. Not every unexpected behavior is a bug. It is better to discuss such issues on other community resources like StackOverflow, forums and so on.",
      "created_at": "2020-06-30T14:35:43Z",
      "updated_at": "2020-06-30T14:35:43Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "@x10an14 You'd basically want to do something like this:\r\n\r\n```powershell\r\nAdd-Type -TypeDefinition '\r\n    using System;\r\n    using System.Collections;\r\n    using System.Collections.Immutable;\r\n    using System.Linq;\r\n    using System.Management.Automation;\r\n    using System.Net.Http;\r\n    using System.Net.Security;\r\n    using System.Security.Cryptography.X509Certificates;\r\n\r\n    public sealed class CCVCallbackClosure\r\n    {\r\n        public CCVCallbackClosure(Hashtable targetUrls)\r\n        {\r\n            TargetUrls = targetUrls.Keys\r\n                .Cast<object>()\r\n                .Select(k => LanguagePrimitives.ConvertTo<string>(k))\r\n                .ToImmutableHashSet(StringComparer.OrdinalIgnoreCase);\r\n\r\n            Callback = CallbackImpl;\r\n        }\r\n\r\n        public ImmutableHashSet<string> TargetUrls { get; }\r\n\r\n        public Func<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> Callback { get; }\r\n\r\n        private bool CallbackImpl(\r\n            HttpRequestMessage message,\r\n            X509Certificate2 cert,\r\n            X509Chain chain,\r\n            SslPolicyErrors policyErrors)\r\n        {\r\n            if (!TargetUrls.Contains(message.RequestUri.AbsoluteUri))\r\n            {\r\n                return true;\r\n            }\r\n\r\n            // Add other logic here.\r\n            return true;\r\n        }\r\n    }'\r\n\r\n$targetUrls = @{\r\n    'https://outlook.com' = $null\r\n    'https://google.com' = $null\r\n}\r\n\r\n$closure = [CCVCallbackClosure]::new($targetUrls)\r\n\r\n$handler.ServerCertificateCustomValidationCallback = $closure.Callback\r\n# etc\r\n```",
      "created_at": "2020-06-30T17:02:09Z",
      "updated_at": "2020-06-30T17:02:09Z"
    },
    {
      "author": "x10an14",
      "author_association": "NONE",
      "body": "Thanks a lot for the help all!\r\n\r\nI got it working to my satisfaction now (although there's still room for improvement, such as proper async utilization).\r\nHere it is for future reference if anyone else drops by with a similar issue;\r\n```powershell\r\nAdd-Type -AssemblyName System.Net.Http\r\n\r\n$targetUrls = @{\r\n\t\"https://github.com\" = $null\r\n\t\"https://google.com\" = $null\r\n\t\"https://outlook.com\" = $null\r\n\t\"https://microsoft.com\" = $null\r\n}\r\n\r\nAdd-Type -TypeDefinition '\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Net.Http;\r\nusing System.Net.Security;\r\nusing System.Security.Cryptography.X509Certificates;\r\n\r\npublic sealed class CCVCallbackClosure {\r\n\tpublic CCVCallbackClosure(string[] targetUrls) {\r\n\t\tthis.TargetUrls = targetUrls\r\n\t\t\t.Select(targetUrl => new Uri(targetUrl))\r\n\t\t\t.ToHashSet<Uri>();\r\n\t\tthis.Callback = CallbackImpl;\r\n\t}\r\n\r\n\tpublic HashSet<Uri> TargetUrls { get; }\r\n\tpublic Func<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> Callback { get; }\r\n\r\n\tprivate bool CallbackImpl(\r\n\t\tHttpRequestMessage message,\r\n\t\tX509Certificate2 cert,\r\n\t\tX509Chain chain,\r\n\t\tSslPolicyErrors policyErrors\r\n\t) {\r\n\r\n\t\tif (TargetUrls.Contains(message.RequestUri)) {\r\n\t\t\tvar expirationTimeDelta = (\r\n\t\t\t\tDateTime.Parse(cert.GetExpirationDateString()) -\r\n\t\t\t\tDateTime.Today\r\n\t\t\t).Days;\r\n\t\t\tConsole.WriteLine(\r\n\t\t\t\t\"\\t\" +\r\n\t\t\t\tmessage.RequestUri + \" expires in\\t\" +\r\n\t\t\t\texpirationTimeDelta + \" days!\"\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn SslPolicyErrors.None == policyErrors;\r\n\t}\r\n}'\r\n$closure = [CCVCallbackClosure]::new($targetUrls.Keys)\r\n\r\n# Set-up HttpClient & handler\r\n$handler = New-Object -TypeName System.Net.Http.HttpClientHandler\r\n$handler.ServerCertificateCustomValidationCallback = $closure.Callback\r\n$client = New-Object -TypeName System.Net.Http.HttpClient -ArgumentList $handler\r\n\r\n# Fetch HTTP Requests Async\r\n$targetUrls.Keys.Clone() | ForEach-Object {\r\n\t$targetUrls[$_] = $client.GetAsync($_).GetAwaiter()\r\n}\r\n\r\n# Await Async HTTP Requests to return\r\n$targetUrls.GetEnumerator() | ForEach-Object {\r\n\t# These two for-loops does NOT leverage the async functionality of the HTTP requests...\r\n\t$responseMessage = $targetUrls[$_.Name].GetResult()\r\n\tWrite-Error \"$($_.Name) System.Net.HttpStatusCode => $($responseMessage.StatusCode).\"\r\n}\r\n```\r\n\r\nEdit: Fix unintended bug where I didn't print the `days left until expiration` + separating between `stdout` and `stderr`.\r\n\r\nHere's output of the above;\r\n```\r\n[2020-07-01 14:10:28] 0 x10an14@x10-desktop:~/Documents/bos/microsoft_certificates_test                                   (master)\r\n-> $ pwsh ./microsoft_powershell_certificates_test.ps1\r\n\thttps://google.com/ expires in\t63 days!\r\n\thttps://microsoft.com/ expires in\t697 days!\r\n\thttps://github.com/ expires in\t678 days!\r\n\thttps://outlook.com/ expires in\t140 days!\r\nWrite-Error: https://outlook.com System.Net.HttpStatusCode => OK.\r\nWrite-Error: https://microsoft.com System.Net.HttpStatusCode => OK.\r\nWrite-Error: https://google.com System.Net.HttpStatusCode => OK.\r\nWrite-Error: https://github.com System.Net.HttpStatusCode => OK.\r\n[2020-07-01 14:10:44] 0 x10an14@x10-desktop:~/Documents/bos/microsoft_certificates_test                                   (master)\r\n-> $ pwsh ./microsoft_powershell_certificates_test.ps1 2>/dev/null\r\n\thttps://google.com/ expires in\t63 days!\r\n\thttps://github.com/ expires in\t678 days!\r\n\thttps://microsoft.com/ expires in\t697 days!\r\n\thttps://outlook.com/ expires in\t140 days!\r\n[2020-07-01 14:10:58] 0 x10an14@x10-desktop:~/Documents/bos/microsoft_certificates_test                                   (master)\r\n-> $\r\n```",
      "created_at": "2020-07-01T11:51:17Z",
      "updated_at": "2020-07-01T12:16:36Z"
    }
  ],
  "created_at": "2020-06-30T11:58:01Z",
  "labels": [
    "Issue-Question",
    "Resolution-Answered"
  ],
  "number": 13061,
  "state": "closed",
  "title": "Unable to assign PowerShell function to .NET Callback, OS-agnostic, and with the option to specify some sort of static variable as an additional input.",
  "updated_at": "2020-07-01T12:16:36Z"
}