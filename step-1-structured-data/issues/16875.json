{
  "_url": "https://github.com/PowerShell/PowerShell/issues/16875",
  "author": "MartinGC94",
  "body": "<!-- Anything that looks like this is a comment and can't be seen after the Pull Request is created. -->\r\n\r\n# PR Summary\r\nFixes https://github.com/PowerShell/PowerShell/issues/16798\r\nFixes https://github.com/PowerShell/PowerShell/issues/3277\r\nFixes https://github.com/PowerShell/PowerShell/issues/14146\r\nFixes https://github.com/PowerShell/PowerShell/issues/7287\r\n<!-- Summarize your PR between here and the checklist. -->\r\n**Fixes the issue where namespaces would be removed from typenames with no regard for type name conflicts:**\r\n```\r\nusing namespace System.Threading\r\nusing namespace System.Timers\r\n[Timer<Tab>\r\n```\r\nNow it will tab complete to the shortest non ambiguous name, in this case it would just be the full name but if a namespace alias or \"using system\" had been defined it would use that instead. Note it won't fall back to type accelerators or type aliases even if they would have been shorter. IMO It would be confusing if the entered type name changed, for example \"System.Sing<Tab>\" turning info \"float\" and it would be annoying not being able to tab complete the real name if you for whatever reason wanted to use it.\r\n\r\n**Fixes the issue where using statements in $profile had no effect on the tab completion.**  \r\nThis is done by first checking the script text for using statements and if none are found, fall back to the session state. The idea here is that if you are writing a script inside an editor the using statements there should have priority over whatever is in your session state.\r\n\r\n**Fixes the issue where powershell defined types are only considered for tab completion if they are defined in the script text.**  \r\nNow it will also include types from `using module` statements in the tab completion and types loaded into the session state.\r\n\r\n**Adds the ability to find types/namespaces based on subnamespaces.**  \r\nFor example you can type in `Generic.List<Tab>` to tab complete to `System.Collections.Generic.List` instead of either having to type the full name, or just `list` and select it from a long list of names.\r\n\r\n**Fixes the issue where quotes around using namespace statements aren't considered when removing the namespace from completion**, for example:\r\n```\r\nusing namespace \"System.Management\"\r\n[token<Tab>\r\n```\r\ncurrently completes to `[tomation.Language.Token]` instead of the proper [Automation.Language.Token]\r\n\r\n**Limit the type completion suggestions to Attribute types when completing an attribute token**, for example:\r\n```\r\n[Parameter<Tab>(\r\n# Results in 1 result \"Parameter\" because the \"(\" makes the parser see it as an attribute\r\n[Parameter<Tab>\r\n# Results in 22 results\r\n```\r\n\r\n**Increases and decreases the type completion performance a bit**\r\nUsing the following snippet to test: `Measure-Command { TabExpansion2 [s} | select Milliseconds`  \r\non fresh console launches it takes on average 177ms to complete. In my normal pwsh install it takes an average of 164.2ms.\r\nTab completing after the type cache has been built averages about 5,46ms with my new code and 9ms with my normal pwsh install. Interestingly there's a lot more variance in my code VS the old code. The old code sits consistently on 9ms while mine fluctuates between 4 and 6.  \r\nThese results make sense to me because my type cache does more work in advance and saves more data but maybe some C# genius can optimize it so it's always faster?\r\n\r\nThe code was designed and tested around the type/namespace alias support that is currently waiting to get reviewed and hopefully merged here: https://github.com/PowerShell/PowerShell/pull/16734 the code specific to that change has been commented out, depending on what gets merged first it may need to get uncommented in a different PR.\r\n\r\nOn a side note, testing this code has made this PSReadline issue: https://github.com/PowerShell/PSReadLine/issues/722 much more apparent to me because there's so many completion items with the same ListItemText for example, tab completing `language` gets me `Microsoft.PowerShell.Commands.Language` instead of my desired `System.Management.Automation.Language`. It should really look at the CompletionText instead, at least for types/namespaces since \"apparent\" duplicates are a lot more common here.\r\n\r\n## PR Context\r\n\r\n<!-- Provide a little reasoning as to why this Pull Request helps and why you have opened it. -->\r\n\r\n## PR Checklist\r\n\r\n- [X] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [X] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [X] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [X] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` or `[ WIP ]` to the beginning of the title (the `WIP` bot will keep its status check at `Pending` while the prefix is present) and remove the prefix when the PR is ready.\r\n- **[Breaking changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)**\r\n    - [X] None\r\n    - **OR**\r\n    - [ ] [Experimental feature(s) needed](https://github.com/MicrosoftDocs/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/About/about_Experimental_Features.md)\r\n        - [ ] Experimental feature name(s): <!-- Experimental feature name(s) here -->\r\n- **User-facing changes**\r\n    - [X] Not Applicable\r\n    - **OR**\r\n    - [ ] [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n- **Testing - New and feature**\r\n    - [ ] N/A or can only be tested interactively\r\n    - **OR**\r\n    - [X] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n- **Tooling**\r\n    - [X] I have considered the user experience from a tooling perspective and don't believe tooling will be impacted.\r\n    - **OR**\r\n    - [ ] I have considered the user experience from a tooling perspective and opened an issue in the relevant tool repository. This may include:\r\n        - [ ] Impact on [PowerShell Editor Services](https://github.com/PowerShell/PowerShellEditorServices) which is used in the [PowerShell extension](https://github.com/PowerShell/vscode-powershell) for VSCode\r\n        (which runs in a different PS Host).\r\n            - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n        - [ ] Impact on Completions (both in the console and in editors) - one of PowerShell's most powerful features.\r\n            - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n        - [ ] Impact on [PSScriptAnalyzer](https://github.com/PowerShell/PSScriptAnalyzer) (which provides linting & formatting in the editor extensions).\r\n            - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n        - [ ] Impact on [EditorSyntax](https://github.com/PowerShell/EditorSyntax) (which provides syntax highlighting with in VSCode, GitHub, and many other editors).\r\n            - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@MartinGC94 Is it possible to split the PR on some more simple and small to speed up the code review?",
      "created_at": "2022-02-12T16:33:50Z",
      "updated_at": "2022-02-12T16:33:50Z"
    },
    {
      "author": "MartinGC94",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov Not in a meaningful way IMO. The code is basically doing this:\r\n\r\n1. Extract interesting information from types to the type cache\r\n2. Build the typecache with this information\r\n3. Analyze script/session state for using statements and PS type definitions\r\n4. Use the type cache, using information and input to find the best/shortest completion names\r\n5. Create the completions\r\n\r\nAside from step 3, every step relies on the previous steps so a PR for step 2 would either not compile, or require the code from step 1 to be included which would just end up making step 5 look exactly like this PR. It would probably also be hard to judge the cache design on its own without seeing how it gets used.\r\n\r\nMaybe a deeper explanation of what I've done and the design will help:\r\nPractically all of the code in the `types` region has been deleted, so you can just ignore all the line removal/changes and just look at it as if that whole section was written from scratch.  \r\nHere's an example of what the type cache looks like:\r\n```\r\nTypeCache\r\n\u251c\u2500\u2500\u2500TypeNameMap\r\n\u2502   \u251c\u2500\u2500\u2500A\r\n\u2502   \u2502   \u251c\u2500\u2500\u2500AutolinkInline\r\n\u2502   \u2502   \u2502    \u2514\u2500\u2500\u2500Markdig.Syntax.Inlines.AutolinkInline\r\n\u2502   \u2502   \u2514\u2500\u2500\u2500AutolinkInlineRenderer\r\n\u2502   \u2502       \u251c\u2500\u2500\u2500Markdig.Renderers.Normalize.Inlines.AutolinkInlineRenderer\r\n\u2502   \u2502       \u2514\u2500\u2500\u2500Markdig.Renderers.Html.Inlines.AutolinkInlineRenderer\r\n\u2502   \u2514\u2500\u2500\u2500B\r\n\u2502       \u251c\u2500\u2500\u2500BlankLineBlock\r\n\u2502       \u2502    \u2514\u2500\u2500\u2500Markdig.Syntax.BlankLineBlock\r\n\u2502       \u2514\u2500\u2500\u2500Block\r\n\u2502           \u2514\u2500\u2500\u2500Markdig.Syntax.Block\r\n\u251c\u2500\u2500\u2500NamespaceMap\r\n\u2502   \u2514\u2500\u2500\u2500A\r\n\u2502       \u251c\u2500\u2500\u2500AutoLinks\r\n\u2502       \u2502    \u2514\u2500\u2500\u2500Markdig.Extensions.AutoLinks\r\n\u2502       \u2514\u2500\u2500\u2500AutoIdentifiers\r\n\u2502           \u2514\u2500\u2500\u2500Markdig.Extensions.AutoIdentifiers\r\n\u251c\u2500\u2500\u2500NamespaceContent\r\n\u2502   \u2514\u2500\u2500\u2500System.Management.Automation\r\n\u2502       \u251c\u2500\u2500\u2500Namespaces\r\n\u2502       \u2502    \u251c\u2500\u2500\u2500System.Management.Automation.Tracing\r\n\u2502       \u2502    \u2514\u2500\u2500\u2500System.Management.Automation.Security\r\n\u2502       \u2514\u2500\u2500\u2500Typenames\r\n\u2502           \u251c\u2500\u2500\u2500PowerShellAssemblyLoadContextInitializer\r\n\u2502           \u2514\u2500\u2500\u2500PowerShellUnsafeAssemblyLoad\r\n\u251c\u2500\u2500\u2500CompletionInfo\r\n\u2502   \u2514\u2500\u2500\u2500Markdig.IMarkdownExtension\r\n\u2502       \u251c\u2500\u2500\u2500ListItemText\r\n\u2502       \u2502   \u2514\u2500\u2500\u2500IMarkdownExtension\r\n\u2502       \u2514\u2500\u2500\u2500ToolTip\r\n\u2502           \u2514\u2500\u2500\u2500Markdig.IMarkdownExtension\r\n\u251c\u2500\u2500\u2500TypeAcceleratorMap\r\n\u2502   \u2514\u2500\u2500\u2500Alias\r\n\u2502       \u251c\u2500\u2500\u2500FullName\r\n\u2502       \u2502   \u2514\u2500\u2500\u2500System.Management.Automation.AliasAttribute\r\n\u2502       \u251c\u2500\u2500\u2500ListItemText\r\n\u2502       \u2502   \u2514\u2500\u2500\u2500AliasAttribute\r\n\u2502       \u2514\u2500\u2500\u2500ToolTip\r\n\u2502           \u2514\u2500\u2500\u2500Class System.Management.Automation.AliasAttribute\r\n\u2514\u2500\u2500\u2500RootNamespaces\r\n    \u251c\u2500\u2500\u2500Markdig\r\n    \u251c\u2500\u2500\u2500Microsoft\r\n    \u2514\u2500\u2500\u2500System\r\n```\r\nTypeNameMap groups short type names by the first character in the short type name, then the short name itself and finally all the full names with that same type name.  \r\nNamespaceMap works just like the typename map, except instead of the short type name it uses the last sub namespace as the key.  \r\nNamespaceContent uses full namespace names as the key to find types/namespaces directly under that namespace.  \r\nCompletionInfo uses the full type names to find the static completion info (ListItemText and ToolTip)  \r\nTypeAcceleratorMap is similar to CompletionInfo except it uses the Type Accelerator name as the key and it also includes the full name. As I'm writing this I'm realizing an optimization here could be to just store the full name and then use the fullname to look up the completion info from the CompletionInfo.  \r\nRootNamespaces just contains a hashset of the root namespaces like \"System\".\r\n\r\nThe basic idea is to quickly be able to look up necessary data when I have a full name and to limit the scope of searches when I only have a partial name.\r\n\r\nHere's a quick summary of the order I would review the methods in and what they do:\r\n1: InitializeTypeCache - Finds types from 3 different sources, hands them off to a different method to extract interesting type info and adds them to the cache.\r\n2: GetTypeInfoForCompletion - Extracts interesting type info using either the type or the full type name. The interesting info is the shortname, fullname, namespace, tooltip and list item text.\r\n3: AddTypeToCache - Uses the type and namespace info from before to create and populate the different tables in the cache\r\n4: GetUsingInfo - Finds using statements in the script or the session state and finds type definitions in the script text or modules specified with `using module`\r\n5: CompleteType Uses the input to search the collected \"using\" info, type definitions and type cache for completions, utilizing GetShortestNonConflictingTypeName to well, get the shortest non conflicting type name for each found type.\r\n6: CompleteNamespace I literally copy pasted CompleteType and removed all the type specific stuff so you've practically already reviewed this at this point.",
      "created_at": "2022-02-12T23:05:21Z",
      "updated_at": "2022-02-12T23:05:21Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@MartinGC94 Thanks for depth explanation! \r\n\r\nDoes InitializeTypeCache start in startup time? My ask is about makes sense prepopulate the cache in build time?",
      "created_at": "2022-02-13T17:17:23Z",
      "updated_at": "2022-02-13T17:17:23Z"
    },
    {
      "author": "MartinGC94",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov when you attempt to complete a namespace or type the cache is initialized if the cache is null. The cache is invalidated AKA changed to null whenever a new assembly is loaded.  \r\nI like the idea of having a factory default cache that is built at compile time that includes all the types that are always available to PowerShell. I don't know how I would implement that though and we would still need a dynamic cache to handle new types from external sources.",
      "created_at": "2022-02-13T18:54:32Z",
      "updated_at": "2022-02-13T18:54:32Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@MartinGC94 My main concern is whether the cache initialized in non-interactive scenarios like schedule task and at startup time in other scenarios - all these could be cause noticeable delay. If yes it makes sense to prepopulate the cache otherwise it is initialized at first tab-completion and I guess users will see no delay really and we have no need to complicate.",
      "created_at": "2022-02-14T05:39:38Z",
      "updated_at": "2022-02-14T05:39:38Z"
    },
    {
      "author": "MartinGC94",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov  Non-interactive scenarios are not affected. As mentioned, it's only initialized when tab completing a namespace/type for the first time, which is the same way it works today.  \r\nI still see value in creating a portion of the cache in advance because a delay of almost 200ms is noticeable, and this is on a good computer. I've seen systems where the first type completion took a few seconds to complete.  \r\nThis is probably not the right PR to introduce this precompiled cache however, since it's already pretty big.",
      "created_at": "2022-02-14T10:36:40Z",
      "updated_at": "2022-02-14T10:37:40Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": ">since it's already pretty big\r\n\r\nSince you rebuild all type cache code it already makes no sense :-) \r\n\r\nI suggest you consider to create Source Generator. You can use follow examples:\r\n\r\n- #15603 - more correct implementation as SG\r\n- https://github.com/iSazonov/PowerShell/commit/f83729faaba404e85b9483717793fb88784d9e23 - more old but more clear to the PR.\r\n\r\nAlso I suggest you consider to have two type cache - (1) prepopulated with SG, (2) created at run time for new loaded dll-s. ",
      "created_at": "2022-02-14T12:32:59Z",
      "updated_at": "2022-02-14T12:32:59Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as Review Needed because it has been there has not been any activity for **7 days**.\nMaintainer, please provide feedback and/or mark it as `Waiting on Author`",
      "created_at": "2022-02-21T14:00:49Z",
      "updated_at": "2022-02-21T14:00:49Z"
    },
    {
      "author": "MartinGC94",
      "author_association": "CONTRIBUTOR",
      "body": "I've thought of something, currently type accelerators use the resolved shortname as the list item text, for example `float` gets `Single` as its list item text but wouldn't it make more sense for it to use the type accelerator name? I mean if you are typing in \"Float\" and you get an IntelliSense menu you would naturally look for \"Float\" and not \"Single\", right?",
      "created_at": "2022-03-04T02:25:30Z",
      "updated_at": "2022-03-04T02:25:30Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "This seems like overcomplicating.",
      "created_at": "2022-03-05T19:17:28Z",
      "updated_at": "2022-03-05T19:17:28Z"
    },
    {
      "author": "MartinGC94",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov What do you mean overcomplicating? Assuming it's in response to my last comment, it's just a matter of changing a single line to use a different property when building the completion result.",
      "created_at": "2022-03-05T19:32:57Z",
      "updated_at": "2022-03-05T19:32:57Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Assuming it's in response to my last comment, it's just a matter of changing a single line to use a different property when building the completion result.\r\n\r\nYes, it is for your comment. Personally I don't like this - looks weird and mislead me.",
      "created_at": "2022-03-07T13:35:04Z",
      "updated_at": "2022-03-07T13:35:04Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "I agree that it would have made sense to have `ListItemText` match the `CompletionText`. That's always been strange to me. The tooltip still shows the underlying type anyway.\r\n\r\nThat said, it will create confusion in some places. Like if you go to complete `[Parameter` you'll get `System.Reflection.Metadata.Parameter` and `ParameterAttribute` with the same list item text. That's sort of it's own issue, because every time I go to do it I forget I need to look for `ParameterAttribute` because I don't want it to complete as that. But anyway worth noting as a potential downside.\r\n\r\n**Edit:** And I see you point out the issue that would create in PSRL as well where it would only ever complete `SRM.Parameter` due to duplicate list item texts :/",
      "created_at": "2022-03-07T14:14:13Z",
      "updated_at": "2022-03-07T15:08:48Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as Review Needed because it has been there has not been any activity for **7 days**.\nMaintainer, please provide feedback and/or mark it as `Waiting on Author`",
      "created_at": "2022-03-16T02:00:44Z",
      "updated_at": "2022-03-16T02:00:44Z"
    },
    {
      "author": "pull-request-quantifier[bot]",
      "author_association": "NONE",
      "body": "### ![](https://img.shields.io/static/v1?label=Quantified&message=Extra%20Large&color=red)\r\n\r\nThis PR has `799` quantified lines of changes. In general, a change size of upto `200` lines is ideal for the best PR experience!\r\n\r\n------\r\n\r\n<details >\r\n    <summary display=\"inline\"> <strong>Quantification details</strong></summary>\r\n    <p />\r\n\r\n```\r\nLabel      : Extra Large\r\nSize       : +521 -278\r\nPercentile : 93.3%\r\n\r\nTotal files changed: 6\r\n\r\nChange summary by file extension:\r\n.cs : +460 -271\r\n.ps1 : +61 -7\r\n```\r\n> Change counts above are quantified counts, based on the [PullRequestQuantifier customizations](https://github.com/microsoft/PullRequestQuantifier/blob/main/docs/prquantifier-yaml.md).\r\n    \r\n</details>\r\n\r\n\r\n<details>\r\n    <summary display=\"inline\"> <strong>Why proper sizing of changes matters</strong> </summary>\r\n    <p/>\r\n    <p/>\r\n\r\nOptimal pull request sizes drive a better predictable PR flow as they strike a\r\nbalance between between PR complexity and PR review overhead. PRs within the\r\noptimal size (typical small, or medium sized PRs) mean:\r\n\r\n- Fast and predictable releases to production:\r\n  - Optimal size changes are more likely to be reviewed faster with fewer\r\niterations.\r\n  - Similarity in low PR complexity drives similar review times.\r\n- Review quality is likely higher as complexity is lower:\r\n  - Bugs are more likely to be detected.\r\n  - Code inconsistencies are more likely to be detected.\r\n- Knowledge sharing is improved within the participants:\r\n  - Small portions can be assimilated better.\r\n- Better engineering practices are exercised:\r\n  - Solving big problems by dividing them in well contained, smaller problems.\r\n  - Exercising separation of concerns within the code changes.\r\n\r\n#### What can I do to optimize my changes\r\n\r\n- Use the PullRequestQuantifier to quantify your PR accurately\r\n  - Create a context profile for your repo using the [context generator](https://github.com/microsoft/PullRequestQuantifier/releases)\r\n  - Exclude files that are not necessary to be reviewed or do not increase the review complexity. Example: Autogenerated code, docs, project IDE setting files, binaries, etc. Check out the `Excluded` section from your `prquantifier.yaml` context profile. \r\n  - Understand your typical change complexity, drive towards the desired complexity by adjusting the label mapping in your `prquantifier.yaml` context profile.\r\n  - Only use the labels that matter to you, [see context specification](./docs/prquantifier-yaml.md) to customize your `prquantifier.yaml` context profile.\r\n- Change your engineering behaviors\r\n  - For PRs that fall outside of the desired spectrum, review the details and check if:\r\n    - Your PR could be split in smaller, self-contained PRs instead\r\n    - Your PR only solves one particular issue. (For example, don't refactor and code new features in the same PR).\r\n\r\n#### How to interpret the change counts in git diff output\r\n\r\n- One line was added: `+1 -0`\r\n- One line was deleted: `+0 -1`\r\n- One line was modified: `+1 -1` (git diff doesn't know about modified, it will\r\ninterpret that line like one addition plus one deletion)\r\n- Change percentiles: Change characteristics (addition, deletion, modification)\r\nof this PR in relation to all other PRs within the repository.\r\n\r\n</details>\r\n\r\n<p />\r\n\r\n------\r\n\r\nWas this comment helpful? <a href=\"https://pullrequestquantifierfeedback.azurewebsites.net/feedback?payload=eyJBdXRob3JOYW1lIjoiTWFydGluR0M5NCIsIlJlcG9zaXRvcnlMaW5rIjoiaHR0cHM6Ly9naXRodWIuY29tL1Bvd2VyU2hlbGwvUG93ZXJTaGVsbCIsIlB1bGxSZXF1ZXN0TGluayI6Imh0dHBzOi8vZ2l0aHViLmNvbS9Qb3dlclNoZWxsL1Bvd2VyU2hlbGwvcHVsbC8xNjg3NSIsIkV2ZW50VHlwZSI6IlRodW1ic1VwIn0=&amp;anonymous=True\" target=\"_blank\" title=\"Thumbs up\"><strong>:thumbsup:</strong></a> <a href=\"https://pullrequestquantifierfeedback.azurewebsites.net/feedback?payload=eyJBdXRob3JOYW1lIjoiTWFydGluR0M5NCIsIlJlcG9zaXRvcnlMaW5rIjoiaHR0cHM6Ly9naXRodWIuY29tL1Bvd2VyU2hlbGwvUG93ZXJTaGVsbCIsIlB1bGxSZXF1ZXN0TGluayI6Imh0dHBzOi8vZ2l0aHViLmNvbS9Qb3dlclNoZWxsL1Bvd2VyU2hlbGwvcHVsbC8xNjg3NSIsIkV2ZW50VHlwZSI6Ik5ldXRyYWwifQ==&amp;anonymous=True\" target=\"_blank\" title=\"Neutral\"><strong>&nbsp;:ok_hand:</strong></a> <a href=\"https://pullrequestquantifierfeedback.azurewebsites.net/feedback?payload=eyJBdXRob3JOYW1lIjoiTWFydGluR0M5NCIsIlJlcG9zaXRvcnlMaW5rIjoiaHR0cHM6Ly9naXRodWIuY29tL1Bvd2VyU2hlbGwvUG93ZXJTaGVsbCIsIlB1bGxSZXF1ZXN0TGluayI6Imh0dHBzOi8vZ2l0aHViLmNvbS9Qb3dlclNoZWxsL1Bvd2VyU2hlbGwvcHVsbC8xNjg3NSIsIkV2ZW50VHlwZSI6IlRodW1ic0Rvd24ifQ==&amp;anonymous=True\" target=\"_blank\" title=\"Thumbs down\"><strong>&nbsp;:thumbsdown:</strong></a> (<a href=\"MAILTO:prquantifier@microsoft.com\" title=\"Mail to prquantifier@microsoft.com\">Email</a>)\r\n[Customize PullRequestQuantifier](https://github.com/PowerShell/PowerShell/blob/master/.github/prquantifier.yaml) for this repository.\r\n\r\n",
      "created_at": "2022-08-20T01:42:18Z",
      "updated_at": "2022-08-20T01:42:18Z"
    }
  ],
  "created_at": "2022-02-11T22:47:07Z",
  "number": 16875,
  "state": "open",
  "title": "Improve type completion",
  "updated_at": "2022-08-20T01:42:19Z"
}