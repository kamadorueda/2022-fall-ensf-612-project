{
  "_url": "https://github.com/PowerShell/PowerShell/issues/15115",
  "author": "BethanyZhou",
  "body": "<!--\r\n\r\nFor Windows PowerShell 5.1 issues, suggestions, or feature requests please use the following link instead:\r\nWindows PowerShell [UserVoice](https://windowsserver.uservoice.com/forums/301869-powershell)\r\n\r\nThis repository is **ONLY** for PowerShell Core 6 and PowerShell 7+ issues.\r\n\r\n- Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\r\n- Search the existing issues.\r\n- Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\r\n- Refer to the [known issues](https://docs.microsoft.com/powershell/scripting/whats-new/known-issues-ps6).\r\n\r\n-->\r\n\r\n## Steps to reproduce\r\n\r\n```powershell\r\n\r\n```\r\n\r\n## Expected behavior\r\n\r\n```none\r\n PowerShell redirects warning messages to warning streams\r\n```\r\n\r\n## Actual behavior\r\nDirectly invoke cli:\r\n![image](https://user-images.githubusercontent.com/19869716/112799230-aad22d00-90a0-11eb-8d5b-27f7441af3db.png)\r\ninvoke through powershell:\r\n![image](https://user-images.githubusercontent.com/19869716/112799274-b887b280-90a0-11eb-9d82-5b33f2471171.png)\r\n\r\nIt turns out PowerShell redirects warning messages to error streams\r\n## Environment data\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.0.0\r\nPSEdition                      Core\r\nGitCommitId                    7.0.0\r\nOS                             Microsoft Windows 10.0.19042\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n\r\n<!-- provide the output of $PSVersionTable -->\r\n\r\n```none\r\n\r\n```\r\n",
  "closed_at": "2021-03-30T02:24:33Z",
  "comments": [
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "It looks like this is just something that `bicep` (native application) wrote to `stderr` and thus was treated as an error record. Native applications have no concepts of the extra streams that PowerShell supports and thus `stdout` goes to the output stream and `stderr` goes to the error stream. There's not much PowerShell can do about this as it's working as expected.",
      "created_at": "2021-03-29T09:38:30Z",
      "updated_at": "2021-03-29T09:38:30Z"
    },
    {
      "author": "BethanyZhou",
      "author_association": "NONE",
      "body": "Thanks for your response @jborean93 . I suspected that this is caused by the stream redirection of the native application. However, No error has been caught when I invoke bicep through a System.Diagnostics.Process directly.\r\n![image](https://user-images.githubusercontent.com/19869716/112818947-a7e23700-90b6-11eb-8dd4-66b15be29122.png)\r\n",
      "created_at": "2021-03-29T09:46:26Z",
      "updated_at": "2021-03-29T09:46:26Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "That part doesn't make much sense to me, maybe having `errorOutput` be `null` causes issues trying to do `+=` in your `ErrorDataRecieved` event handler.\r\n\r\nRegardless here is a reproducer for all this behaviour by using something I know for sure writes to stdout/stderr:\r\n\r\n```powershell\r\n$proc = [Diagnostics.Process]::new()\r\n$proc.StartInfo.FileName = 'powershell.exe'\r\n$proc.StartInfo.Arguments = \"-Command [Console]::Error.WriteLine('stderr'); [Console]::Out.WriteLine('stdout')\"\r\n$proc.StartInfo.UseShellExecute = $false\r\n$proc.StartInfo.RedirectStandardError = $true\r\n$proc.StartInfo.RedirectStandardOutput = $true\r\n\r\n$proc.Start()\r\n$proc.WaitForExit()\r\n\r\n$stdout = $proc.StandardOutput.ReadToEnd()\r\n$stderr = $proc.StandardError.ReadToEnd()\r\n\r\n\"STDOUT: {0}`nSTDERR: {1}`nRC: {2}\" -f $stdout, $stderr, $proc.Exitcode\r\n```\r\n\r\nYou can see that running this same command as a PowerShell script writes the stderr to the error stream\r\n\r\n```powershell\r\n$ps = [PowerShell]::Create()\r\n$stdout = $ps.AddScript('powershell.exe -Command \"[Console]::Error.WriteLine(''stderr''); [Console]::Out.WriteLine(''stdout'')\"').Invoke()[0]\r\n\r\n$stderr = $ps.Streams.Error[0]\r\n\r\n\"OUTPUT: {0}`nERROR: {1}`nHAD_ERRORS: {2}\" -f $stdout, $stderr, $ps.HadErrors\r\n```\r\n\r\nI unfortunately don't have `bicep` installed or an environment set up to test it out but using these examples show how `stderr` data is sent to the error stream.",
      "created_at": "2021-03-29T10:24:30Z",
      "updated_at": "2021-03-29T10:27:07Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Note that in the _console_ (terminal) stderr output from external processes is by default _not_ routed through PowerShell's error stream - instead, it prints straight to the display - _without_ being highlighted in a different color.\r\n\r\nIn other words: in a terminal, you won't be able to tell stdout lines apart from stderr lines, which you can verify with `cmd /c 'echo stdout & echo stderr >&2'` (Windows) / `sh -c 'echo stdout & echo stderr >&2'` (Unix).\r\n\r\nThe rationale is that stderr output cannot be assumed to indicate actual _errors_, given that it must be used for anything that is _not data_, such as status information and warnings, as in this case.\r\n\r\nIf you see different coloring - and if `$Errors` reflects the stderr lines after execution - the implication is that you're using _a PowerShell host that doesn't behave like PowerShell's `ConsoleHost`_.\r\n\r\nNote that, unfortunately, even the `ServerRemoteHost` host that PowerShell uses for its remoting does _not_ behave like a terminal in this respect (more on that below).\r\n\r\n_Update_: Nor does the `Default Host` that the PowerShell SDK uses - see [below](https://github.com/PowerShell/PowerShell/issues/15115#issuecomment-809493832).\r\n\r\n~~What host are _you_ using, i.e. how are you invoking the CLI?~~\r\n\r\n---\r\n\r\nAs an aside:\r\n\r\n_On demand_ you can redirect or suppress stderr output, using `2>`, as usual, though note that each stderr line is wrapped in a [`System.Management.Automation.ErrorRecord`](https://docs.microsoft.com/en-US/dotnet/api/System.Management.Automation.ErrorRecord) instance.\r\n\r\nAs of v7.1, unfortunately, such a redirection causes the lines to be _routed through PowerShell's error stream_, which has two unwanted side effects:\r\n\r\n* the lines are unexpectedly recorded in `$Error`\r\n* more importantly, if `$ErrorActionPreference = 'Stop'` happens to be in effect, the first stderr line emitted by the external process causes execution to _abort_.\r\n\r\nThe current preview versions (of v7.2) have an _experimental feature_ named `PSNotApplyErrorActionToStderr` that opts out of this behavior; while I personally hope this will become an official feature, that's not a given.\r\n\r\nAdditionally, even the feature becomes official, the problem in the context of _remoting_ will persist; e.g., on Windows (assuming remoting is set up on the local machine; run from an _elevated_ session):\r\n\r\n```\r\n# Run as admin.\r\nPS> Invoke-Command -ComputerName . { cmd /c 'echo stdout & echo stderr >&2'; 'more' } -ErrorAction Stop\r\nstdout\r\nstderr   # !! This will print in red, and 'more' never prints, because execution aborted at the first stderr line.\r\n```\r\n\r\nNote that even without `-ErrorAction Stop` the word `stderr` would print in _red_, because it is received via PowerShell's error stream.\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2021-03-29T15:40:48Z",
      "updated_at": "2021-03-29T16:02:07Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Sorry, I originally neglected to address the aspect of your using the PowerShell SDK:\r\n\r\nThe answer is that with SDK use the `Default Host` is used, which indeed appears _not_ to act like a terminal with respect to stdout and stderr _from external processes_ (see below), similar to the `ServerRemoteHost` used in PowerShell remoting, in that _all stderr output is routed through PowerShell's error stream_.\r\n\r\nYou can verify the name of the host with:\r\n\r\n```powershell\r\nPS> [powershell]::create().addScript(' $host.name ').Invoke()\r\nDefault Host\r\n```\r\nAs for the expectation to have warnings emitted through an external process' stderr be routed through PowerShell's _warning_ stream: Unfortunately, given that stderr is used for _anything other than data_, there's no telling what a particular stderr line represents (and _guessing_ by the presence of the word `warning` would be too brittle).\r\n\r\n----\r\n\r\n\r\n<details><summary>Some background information:</summary>\r\n\r\nNote that in the _console_ (terminal) stderr output from external processes is by default _not_ routed through PowerShell's error stream - instead, it prints straight to the display - _without_ being highlighted in a different color.\r\n\r\nIn other words: in a terminal, you won't be able to tell stdout lines apart from stderr lines, which you can verify with `cmd /c 'echo stdout & echo stderr >&2'` (Windows) / `sh -c 'echo stdout & echo stderr >&2'` (Unix).\r\n\r\nThe rationale is that stderr output cannot be assumed to indicate actual _errors_, given that it must be used for anything that is _not data_, such as status information and warnings, as in this case.\r\n\r\nIf you see different coloring - and if `$Errors` reflects the stderr lines after execution - the implication is that you're using _a PowerShell host that doesn't behave like PowerShell's `ConsoleHost`_.\r\n\r\nNote that, unfortunately, not just the `Default Host`, but also the `ServerRemoteHost` host that PowerShell uses for its remoting does _not_ behave like a terminal in this respect (more on that below).\r\n\r\n---\r\n\r\n_On demand_ you can redirect or suppress stderr output, using `2>`, as usual, though note that each stderr line is wrapped in a [`System.Management.Automation.ErrorRecord`](https://docs.microsoft.com/en-US/dotnet/api/System.Management.Automation.ErrorRecord) instance.\r\n\r\nAs of v7.1, unfortunately, such a redirection causes the lines to be _routed through PowerShell's error stream_, which has two unwanted side effects:\r\n\r\n* the lines are unexpectedly recorded in `$Error`\r\n* more importantly, if `$ErrorActionPreference = 'Stop'` happens to be in effect, the first stderr line emitted by the external process causes execution to _abort_.\r\n\r\nThe current preview versions (of v7.2) have an _experimental feature_ named `PSNotApplyErrorActionToStderr` that opts out of this behavior; while I personally hope this will become an official feature, that's not a given.\r\n\r\nAdditionally, even the feature becomes official, the problem in the context of _remoting_ will persist; e.g., on Windows (assuming remoting is set up on the local machine; run from an _elevated_ session):\r\n\r\n```powershell\r\n# Run as admin.\r\nPS> Invoke-Command -ComputerName . { cmd /c 'echo stdout & echo stderr >&2'; 'more' } -ErrorAction Stop\r\nstdout\r\nstderr   # !! This will print in red, and 'more' never prints, because execution aborted at the first stderr line.\r\n```\r\n\r\nNote that even without `-ErrorAction Stop` the word `stderr` would print in _red_, because it is received via PowerShell's error stream.\r\n\r\n</details>",
      "created_at": "2021-03-29T15:53:35Z",
      "updated_at": "2021-03-29T16:20:38Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Sorry again for the noise - I realize I focused on an incidental aspect - host behavior - that should be addressed elsewhere.\r\nI think @jborean93's comments have it all covered (the little mystery about _event_-based stderr collection with direct use of `System.Diagnostics.Process` notwithstanding), but to elaborate on the conceptual aspect:\r\n\r\n* As for the expectation to have warnings emitted through an external process' stderr stream be routed through PowerShell's _warning_ stream: Unfortunately, given that stderr is used for _anything other than data_, there's no telling what a particular stderr line represents (and _guessing_ by the presence of the word `warning` would be too brittle).\r\n\r\n* Routing all stderr output - even though it doesn't necessarily represent _errors_ -  through PowerShell's _error_ stream is what the PowerShell SDK does by design. \r\n  * This generally makes sense, as long as the stderr lines are _not_ treated as actual _errors in a PowerShell sense_, and are therefore neither collected in the automatic `$Error` variable nor subject to `$ErrorActionPreference`.  This is currently (pre-v7.2) only ensured if the experimental `PSNotApplyErrorActionToStderr` feature is in effect.\r\n",
      "created_at": "2021-03-29T16:29:25Z",
      "updated_at": "2021-03-29T18:56:07Z"
    },
    {
      "author": "BethanyZhou",
      "author_association": "NONE",
      "body": "Thank you all @jborean93 , @mklement0 for explanation!!! Will communicate with bicep team and close this issue.",
      "created_at": "2021-03-30T02:24:27Z",
      "updated_at": "2021-03-30T02:24:27Z"
    }
  ],
  "created_at": "2021-03-29T07:20:15Z",
  "labels": [
    "Needs-Triage"
  ],
  "number": 15115,
  "state": "closed",
  "title": "System.Management.Automation.PowerShell returns warning messages as error messages",
  "updated_at": "2021-03-30T02:24:33Z"
}