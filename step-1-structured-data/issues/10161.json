{
  "_url": "https://github.com/PowerShell/PowerShell/issues/10161",
  "author": "daxian-dbw",
  "body": "<!-- Anything that looks like this is a comment and can't be seen after the Pull Request is created. -->\r\n\r\n# PR Summary\r\n\r\nAdd support to ternary operator `<condition> ? <if-true> : <if-false>`. It results in a `TernaryExpressionAst`.\r\n\r\n## PR Context\r\n\r\nTernary operator has lower precedence than binary operator, so you can write `$a -eq $b ? \"Hello World\" : [int]::MaxValue`.\r\n\r\nImplicit line continuance for `?` is supported, so you can write\r\n```\r\n$PSEdition -eq 'Core'\r\n    ? \"PowerShell Core\"\r\n    : \"Windows PowerShell\"\r\n```\r\n\r\nToday, `1?2:3` is parsed as a command name as `1?2:3` is considered as a generic token by the tokenizer.\r\nWe don't want to break that, but in certain situation, we know we are expecting an expression and a generic token like `1?2:3` is not useful. In those cases, we want to make the ternary operator chars `?` and `:` to force ending a number token scan.\r\nA new bool field `ForceEndNumbeOnTernaryOpChars` is added to `Tokenizer` and used when scanning number tokens. When the tokenizer is current in `Expression` mode, `ForceEndNumbeOnTernaryOpChars` is `true`, and the current char is `?` or `:`, we force ending the number token.\r\nWith this, we are able to write `$a -gt 2?[int]::MaxValue:3`, `${true}?3:1`, and `-not 1?2:3`.\r\n\r\nCharacters `?` and `:` are valid chars for a variable name, so `$varName?2:3` will be parsed as a variable. In order to write concise ternary expression with a variable condition, you can do this: `${varName}?2:3`.\r\n\r\n### This PR is a draft, not finished yet\r\n\r\nSend out the draft PR to start collecting feedback.\r\nAlso, exercise the CI builds to find regressions.\r\nPending work:\r\n1. Finish examining all visitor usages, and update appropriately. Example, `VariableAnalysis` needs to be updated to account for the ternary operator.\r\n2. Examine if `UpdatePosition` is correctly called at the right place.\r\n2. Add many tests.\r\n\r\n## PR Checklist\r\n\r\n- [ ] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [ ] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [ ] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [ ] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` or `[ WIP ]` to the beginning of the title (the `WIP` bot will keep its status check at `Pending` while the prefix is present) and remove the prefix when the PR is ready.\r\n- **[Breaking changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)**\r\n    - [ ] None\r\n    - **OR**\r\n    - [ ] [Experimental feature(s) needed](https://github.com/MicrosoftDocs/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/About/about_Experimental_Features.md)\r\n        - [ ] Experimental feature name(s): <!-- Experimental feature name(s) here -->\r\n- **User-facing changes**\r\n    - [ ] Not Applicable\r\n    - **OR**\r\n    - [ ] [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n- **Testing - New and feature**\r\n    - [ ] N/A or can only be tested interactively\r\n    - **OR**\r\n    - [ ] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n",
  "closed_at": "2019-08-15T18:18:29Z",
  "comments": [
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "> Implicit line continuance for `?` is supported\r\n\r\nHooray for implicit line continuance! \ud83c\udf89 \r\n\r\n> A new bool field `ForceEndNumbeOnTernaryOpChars` is added to `Tokenizer` and used when scanning number tokens. When the tokenizer is current in `Expression` mode, `ForceEndNumbeOnTernaryOpChars` is `true`, and the current char is `?` or `:`, we force ending the number token.\r\n\r\nThe description of this PR includes a mispelling. The bool field should be `ForceEndNumberOnTernaryOpChars`.\r\n\r\nAlso that flag sounds a good candidate for an [Optional Feature](https://github.com/PowerShell/PowerShell-RFC/pull/187/files#diff-fe11822524bdb8ad61571a0579d8d3bd). Even with that proposal just in RFC, it would be useful/helpful to consider how it could be used for this optional way to parse ternary operators, so that we work out any kinks in the proposed optional feature design.\r\n\r\n",
      "created_at": "2019-07-15T20:26:51Z",
      "updated_at": "2019-07-15T20:26:51Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> The description of this PR includes a mispelling. The bool field should be `ForceEndNumberOnTernaryOpChars`.\r\n\r\n@KirkMunro Thanks for pointing out this. @kvprasoon also caught it. It has been fixed.",
      "created_at": "2019-07-15T20:52:48Z",
      "updated_at": "2019-07-15T20:52:48Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@daxian-dbw Does the fact that `Where-Object` has an alias of `?` get in the way of implicit continuance using `?` at the start of a line? I don't think it's likely, because you would have to be using `-InputObject` in that scenario, which means working with a collection in `Where-Object` which is unlikely; however, something obscure like this is possible:\r\n\r\n```powershell\r\n$c = @(gps -name pwsh)\r\n$b = $StopProcess -eq $true\r\n? -InputObject $c Count -gt 0\r\n| % {if ($b) {spps $c -whatif}}\r\n```\r\n\r\nThat's messy, and hopefully nothing like that exists in scripts, but I wanted to call out the potential conflict with the `?` alias so that the potential issue is known/documented.",
      "created_at": "2019-07-15T23:15:09Z",
      "updated_at": "2019-07-15T23:15:09Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@KirkMunro Good catch. The continuation of `?` will break `? -InputObject $c Count -gt 0` in that case, so it will be a potential breaking change.\r\nPersonally, I'm not too worried about it. That's a very obscure use of `Where-Object` and I presume the possibility of actually breaking any scripts is very low.\r\nBut we do need the committee review to approve this.",
      "created_at": "2019-07-16T15:33:03Z",
      "updated_at": "2019-07-16T17:12:33Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@daxian-dbw That's my take as well. I at least wanted to capture it so that if this moves forward with implicit continuance (I hope it does), the obscure break would be known/documented.",
      "created_at": "2019-07-16T15:34:23Z",
      "updated_at": "2019-07-16T15:34:23Z"
    },
    {
      "author": "Taoquitok",
      "author_association": "NONE",
      "body": "With `?` already existing as a widely used alias, and Powershell often remaining distinct to common operator designs like `==, >, ||, &&`, would it make sense to consider using something more verbose? So following the design of the rest of the powershell in going for verbosity and readability over shortness?  \r\nFor example, instead of: \r\n`$a -eq $b ? $a : $c`\r\nsomething like `-then` / `-else` ?  \r\n`$a -eq $b -then $a -else $c`  \r\n\r\nOr to save on *included -then, but forgot -else* errors caused by the above, treat it much like `-replace 'a','b'`/`.replace('a','b')`, and have an explicit `-ternary a,b` / `.ternary(a,b)`?\r\n\r\n`($a -eq $b) -ternary $a, $c`\r\n`($a -eq $b).ternary($a, $c)`  \r\n \r\nFinally having ternaries would be great, and so would improving consistency with other languages, but I would be surprised if two uses for `?` didn't cause confusion and readability issues compared to a more verbose, but still short, operator/method.",
      "created_at": "2019-07-17T00:20:30Z",
      "updated_at": "2019-07-17T00:31:16Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "I proposed `-then`/`-else` [here](https://github.com/PowerShell/PowerShell/issues/3239#issuecomment-365072448) so you can see the subsequent discussion.\r\n\r\nHaving spent the past 2 years away from C# and using languages without the `cond ? then : else` syntax (mostly F# and Rust), I think `-then`/`-else` is highly suitable syntax for PowerShell.\r\n\r\nI find the arguments for familiarity weak at best - those used to the familiar syntax are likely to get used to the PowerShell syntax quickly, and for those not familiar, I think the readability of a slightly more verbose syntax is really important.\r\n\r\nMaybe this PR could enable both forms and keep the feature experimental until folks have some experience with it.",
      "created_at": "2019-07-17T00:44:50Z",
      "updated_at": "2019-07-17T00:44:50Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "One downside that is significant (to me at least) is that using `-then`/`-else` syntax would mean implicit line continuation would be a more risky breaking change, since users could have a command called `-then` or `-else`. That may not seem like a big deal, but it will likely be common for users of this feature to want it to span multiple lines (based on this being common in other programming languages), and PowerShell could only support that natively with `-then` or `-else` at the end of the line, which is not as readable as it would be with them at the start of a line.",
      "created_at": "2019-07-17T01:04:14Z",
      "updated_at": "2019-07-17T01:04:14Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "It's curious that a hypothetical command `-then` or `-else` is more worrisome than an actual command `?`.",
      "created_at": "2019-07-17T01:07:47Z",
      "updated_at": "2019-07-17T01:07:47Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "Well, the actual `?` command is an exception in that regard, because:\r\n\r\n- it's designed specifically for pipeline use\r\n- you _can_ use it at the start of a command, but if you do so, you have to use `-InputObject`, which will be an array unless you're using `Where-Object` to filter a single object\r\n- the use cases where you could use `Where-Object` to start a pipeline are obscure at best, and I've never seen it in practice in 12+ years of working with PowerShell.\r\n\r\nIt's such an obscure scenario, I'm highly skeptical that anyone will be affected by it.\r\n\r\nOn the other hand, with respect to the potential for `-then` or `-else` commands, I have literally no data to work with, so I don't have as high of a confidence level that there wouldn't be a conflict/break somewhere.",
      "created_at": "2019-07-17T01:15:05Z",
      "updated_at": "2019-07-17T01:15:05Z"
    },
    {
      "author": "WithHolm",
      "author_association": "NONE",
      "body": "Just a question: Why? \r\n\r\nwhy would this ever be a good idea for Powershell? what would it add? I mean, I get it. Its somewhat easier to write than a simple \"if\" and with this you would also get Elvis notation, that could possibly be helpful, but both the language overhead (if you come from a non-programmer background, this makes no sense) and the possibility that this could break the tokenizer if not properly implemented (especially with ? being used for where-object as stated earlier in this thread), i cannot see any way that this would help the language progress in any way. ",
      "created_at": "2019-07-17T09:29:19Z",
      "updated_at": "2019-07-17T09:29:19Z"
    },
    {
      "author": "JamesLear92",
      "author_association": "NONE",
      "body": "@WithHolm \r\nBecause the ternary operator is one of the most concise and neat abstractions available in many languages.\r\nWhile it could break the tokenizer if not properly implemented, I'd argue that it should be properly implemented.",
      "created_at": "2019-07-17T10:03:22Z",
      "updated_at": "2019-07-17T10:03:22Z"
    },
    {
      "author": "Taoquitok",
      "author_association": "NONE",
      "body": "I'm probably missing something obvious, but are you sure there would be a line continuation issue for the *-then -else* suggestion? Currently you can do the following with multiple operators over multiple lines:  \r\n  \r\n    'string' -replace\r\n        'ing',\r\n        'new_string_ending' -split\r\n            '_'\r\n\r\nso presumably a consistent option would be the same format for -then -else?\r\n\r\n    $a -eq $b -then\r\n        $a -else\r\n        $c\r\n\r\n\r\nAssuming that this isn't viable, why not `-ternary / .ternary()`  ?\r\n\r\nMuch like with the current behaviour of `-replace / .replace()`, which can be spread across lines, using this existing operator format would be consistent with existing behaviours, the below works with `replace`\r\n\r\n    ('test').Replace(\r\n        'te',\r\n        'be'\r\n    )\r\n    # output: best\r\n    'test' -Replace(\r\n        'te',\r\n        'be'\r\n    )\r\n    # output: best\r\n    'test' -Replace\r\n        'te',\r\n        'be'\r\n    # output: best\r\n    $a = 'one'\r\n    $b = 'two'\r\n    $a + $b -replace \r\n        'et',\r\n        ''\r\n    # output: onwo\r\n\r\nSo why not follow the same pattern for ternary?  \r\n  \r\n    # Same line\r\n    $a -eq $b -ternary $a,$c\r\n    ($a -eq $b).ternary($a,$c)\r\n\r\n    # multi-line\r\n    $a -eq $b -ternary \r\n        $a,\r\n        $c\r\n    \r\n    ($a -eq $b).ternary(\r\n        $a,\r\n        $c\r\n    )\r\n    ",
      "created_at": "2019-07-17T10:15:58Z",
      "updated_at": "2019-07-17T11:41:51Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@WithHolm:\r\n\r\n> if you come from a non-programmer background, this makes no sense\r\n\r\nIf you come from a non-programmer background, a lot of PowerShell will initially make no sense. Then you learn how it works, and use what you have learned. This is no different.\r\n\r\n> the possibility that this could break the tokenizer if not properly implemented\r\n\r\nLiterally any feature can break something if it is not properly implemented. If our condition for adding something to the language was whether or not it could break something if it was not properly implemented, the language would never change.\r\n\r\n> (especially with ? being used for where-object as stated earlier in this thread)\r\n\r\nAs also stated earlier in the thread, there is a very, very low probability that the potential collision with `Where-Object` would occur because of how that cmdlet is used. It can only collide if the `?` alias happens to be used to start a pipeline, which while possible, literally nobody ever does, _and_ that line would also have to be on a line immediately following a conditional expression. The chance that would break something is almost non-existent (and may actually be non-existent).\r\n\r\n> why would this ever be a good idea for PowerShell? what would it add? i cannot see any way that this would help the language progress in any way.\r\n\r\nTernary operator support has been requested by many PowerShell users, so there seem to be plenty of folks who would use this. I've wished I had ternary operator support many times when it would make my code more elegant and easier to read. It doesn't absolutely have to come in the form of `?:` for me, but as someone who works with C#, I do like that syntax a lot.",
      "created_at": "2019-07-17T14:04:30Z",
      "updated_at": "2019-07-17T14:04:30Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@Taoquitok:\r\n\r\n> I'm probably missing something obvious, but are you sure there would be a line continuation issue for the _-then -else_ suggestion?\r\n\r\nThe line continuation issue potentially comes up when you're using implicit continuance, with the operators at the start of a line.",
      "created_at": "2019-07-17T14:06:01Z",
      "updated_at": "2019-07-17T14:06:22Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "#3239 has a great discussion about the syntax of the ternary operator. It's definitely worth a read.",
      "created_at": "2019-07-17T16:00:16Z",
      "updated_at": "2019-07-17T16:00:16Z"
    },
    {
      "author": "essentialexch",
      "author_association": "NONE",
      "body": "Since @SteveL-MSFT invited commentary on twitter (I thought this was a \"done deal\")\u2026 overall, I don't see the point. Yes, a ternary operator is more \"terse\" than the \"if(){}else{}\" but not much. (And that terseness makes it slightly less readable to a new PS user or any user who is from a non-C language.) And the 'if' statement has been around forever. And there are no concerns about multi-line parsing or operator precedence or operator confusion.\r\n\r\nIf there is going to be a ternary operator, my personal opinion is that using -then/-else is more PowerShell-y, less confusing to novice users, and eliminates any operator confusion. Recognizing, of course, at that point you've lost most terseness (perhaps all, depending on your style):\r\n\r\n\r\nExisting:\r\n`if($b -eq 1) { 1 } else { 0 }\r\n`\r\n\r\nTwo -then/-else styles\r\n```\r\n$b -eq 1 -then { 1 } -else { 0 }\r\n$b -eq 1 -then 1 -else 0\r\n\r\n```\r\nTwo ?: styles\r\n```\r\n$b -eq 1 ? 1 : 0\r\n$b -eq 1 ? { 1 } : { 0 }\r\n\r\n```\r\n\r\nAlthough based on @BrucePay comments in https://github.com/PowerShell/PowerShell/issues/3239#issuecomment-383776193, it seems that some of those '{}' blocks will actually have to be '()' expressions for ternary statements - which I would find extremely confusing.\r\n\r\nOne more comment, copied from https://github.com/rust-lang/rust/issues/1698#issuecomment-3706301: \"I use the ternary operator a lot in C++, but I think the syntax is poor. You have to spot the ? and : in the middle of a sea of other tokens to see that it's even a conditional.\" Using -then/-else addresses that visibility issues.",
      "created_at": "2019-07-18T18:22:55Z",
      "updated_at": "2019-07-18T18:22:55Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "If the decision is to go with `$b -eq 1 -then 1 -else 0` then it is not worth making the change IMO.  The whole point of the ternary operator is to cut the ceremony for a simple concept: `$foo = $var ? $var : \"default\"`.  And FWIW, I'd like to see that ceremony cut further with a `null-coalescing` operator e.g. `$foo = $var ?? \"default\"`.\r\n\r\nWould folks be happier with Posix param substitution for this scenario e.g.: `$foo = ${var:-'default'}` (or however that concept would map into PowerShell).  I figured `$foo = $var ? $var : \"default\"` would be easier to understand and cover one of the more common cases for assignment.",
      "created_at": "2019-07-18T18:40:40Z",
      "updated_at": "2019-07-18T18:40:40Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Yeah, the point here is the brevity, really. I think the proposed `$condition ? $ifTrue : $ifFalse` is the best way to go that we currently have on the table. `-then` and `-else` _do_ fit in a little better with PowerShell operators, but in terms of terseness they're essentially equivalent to just doing `if ($condition) { $ifTrue } else { $ifFalse }`.\r\n\r\nHaving them as distinct, brief symbols, which are very visually distinct (not word-operators, etc) is the value here; they're small, easily distinguished markers in most cases.",
      "created_at": "2019-07-18T19:00:00Z",
      "updated_at": "2019-07-18T19:00:00Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "I think it would be easy for scripters to grasp the meaning of `$condition ? <true-expr> : <false-expr>`.\r\nIf we go with `-then -else` for ternary operator, then for the null-coalescing operator, maybe something like `-ifnull`, **but for null-conditional operators, we just have to use the cryptic symbols `?.` and `?[]`, which has the `?` in them**. Considering that, it's better to be consistent.",
      "created_at": "2019-07-18T19:22:10Z",
      "updated_at": "2019-07-18T19:22:10Z"
    },
    {
      "author": "essentialexch",
      "author_association": "NONE",
      "body": "I think @Jaykul (Joel Bennet, don't know his github name) had a great idea with -then/-else on twitter (https://twitter.com/Jaykul/status/1151913597930496000):\r\n\r\n```\r\nWould the -then -else still have to be used together?\r\n\r\nCan -else also be a null-coalescing operator?\r\n$ComputerName = $ComputerName -else \"localhost\"\r\n\r\nCan -then be a conditional set operator?\r\n$ComputerName = $ComputerName -eq \".\" -then \"localhost\"\r\n\r\n```\r\nThese are very consistent - and very \"PowerShell-y\" and, in my opinion, are immediately understandable. And eliminates the cryptic characters.\r\n\r\nI guess at some point it's about philosophy.  PS isn't C or C#. You can move it toward them, which ?: does, or continue with its scripting roots, which tends to be a bit more verbose and more accessible to a non-programmer.",
      "created_at": "2019-07-18T19:37:40Z",
      "updated_at": "2019-07-18T19:37:40Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "While I think such a suggestion is worth considering, I don't think it bears relation to this PR. `-then` and/or `-else` could be implemented as binary operators for those cases. In fact, I'd love those ones to be available. But I _don't_ think they should be the same / overlapping with a ternary syntax; would love to talk over some possibilities of those in a separate issue, as I don't think their possible implementation is particularly entwined to this PR itself.\r\n\r\nThis PR introduces a _ternary_ operator syntax. This structure has never been used in PS before, and it will be (as of this PR, anyway) the only instance of a ternary syntax in PS. As such, I think it makes more sense to break away from (somewhat) traditional `-operator` syntax; retaining that syntax will most likely lead to more confusion about the ways you can use the operators or not.\r\n\r\nI think that while, yes, it's important to have features that are verbose for new scripters, we already have that &mdash; `if ($condition) { $val1 } else { $val2 }` conveys that perfectly well. This would simply be a more brief version of that, just like how we have both `Get-ChildItem` and `gci`. Making it more verbose defeats the purpose of the PR, I think. We already have a \"more verbose\" version available. \ud83d\ude42 ",
      "created_at": "2019-07-18T20:10:25Z",
      "updated_at": "2019-07-18T20:12:00Z"
    },
    {
      "author": "essentialexch",
      "author_association": "NONE",
      "body": "@daxian-dbw has already entwined ternary with null-coalescing and null-conditional, in the comment immediately preceding mine. Which is why I mentioned it. I wasn't being hypothetical.\r\n\r\nYou wrote \"retaining that syntax will most likely lead to more confusion about the ways you can use the operators\". What's the justification for that statement? The operators do not currently exist, so I don't see how introducing them leads to confusion. Their meaning is far more clear, in my opinion at least, than ?:.",
      "created_at": "2019-07-18T20:25:14Z",
      "updated_at": "2019-07-18T20:25:14Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I... am not sure what you're referring to, I'm afraid. Both null-coalescing and null-conditional syntaxes have similar but distinct syntaxes in the forms he proposed. With @Jaykul's proposal that you're talking about, the exact same operators would be used in both cases, creating an avenue for confusion.\r\n\r\nAll `-eq` style operators currently are **binary** operators -- they take a left hand and right hand side operand, and they don't take anything else into account.\r\n\r\nThe proposal here is to implement a syntax that depends on three arguments instead of two, with a short-circuiting behaviour such that the branch that doesn't get followed never gets evaluated, so you don't have to worry about side effects. There are currently zero operators that work this way in PowerShell, so I think that grouping it in with a `-then` / `-else` syntax is likely to lead to confusion in usage, with the behaviour unclear when one or both is used, depending how you approach it.\r\n\r\nI simply thing that you're trying to cram a bit much in the one box here. Some PS operators have variant behaviours, but that's always due to a difference in their arguments. None of them currently change based on whether you supply another operator. The `-eq` operator doesn't alter its behaviour if you later use `-ne` -- this _would_ be a very unusual thing.\r\n\r\nI think it makes the most sense to have `-then` and `-else` be separate operators, not rolled into the ternary syntax here.",
      "created_at": "2019-07-18T21:00:08Z",
      "updated_at": "2019-07-18T21:00:08Z"
    },
    {
      "author": "essentialexch",
      "author_association": "NONE",
      "body": "I understand what you are saying. The only avenue for confusion I see is specifying -else/-then as opposed to -then/-else. Which would be a syntax error, just as it is if you specified a standalone else today. All of these are interpreted based on where they are used in the language grammar. That doesn't change. ? is location dependent, : is location dependent, etc.\r\n\r\nI would point out that operator precedence does directly affect how an expression evaluates, both mathematically and logically. So -eq can have an unexpected result, as I'm sure we've all been surprised the first time we write \"-not $a -eq $b\".\r\n\r\nRegardless, I am actually not particularly invested in this. I wrote my first ternary in 1981. The syntax doesn't confuse me and I don't think it's particularly difficult to understand; but it is terse and can be difficult to read. \r\n\r\nI just think PS should stay PS and not try to be a C-family lookalike. I don't think ?: is PowerShell-y at all.\r\n\r\nPeace.\r\n",
      "created_at": "2019-07-18T21:24:10Z",
      "updated_at": "2019-07-18T21:24:10Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "We've definitely had the debate over whether or not to include this already -- but when examples get non-trivial and start wrapping lines, I'm not sure how a person whose first and only language is PowerShell is supposed to understand what's going on.\r\n\r\nThey may know `?` is `Where-Object` and they _might_ have learned that `:label` is used for [breaking](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_break?view=powershell-6) out of looping constructs, but how will they read this?\r\n\r\n```posh\r\n$Script:Config.RemoteServer -eq $ParameterValue\r\n    # Describe what this does\r\n    ? (Invoke-Command -Cn $Script:Config.RemoteServer {\r\n           <# do things #> \r\n    })\r\n    # The parenthesis here are required if it's a command, right?\r\n    : (Do-SomethingElse)\r\n```\r\nAfter all, although it doesn't **appear** to do anything, `? (...)` is perfectly valid syntax that actually does roughly the same thing as `(...)|out-null` right now:\r\n\r\n```PowerShell\r\n? (iwr google.com -OutFile g.html -PassThru)\r\n```\r\n\r\nI'm not concerned you'll break that -- I'm asking how a user is supposed to know that's not what you're doing.\r\n\r\nIf you put the \":\" on the following line, then suddenly the space or parenthesis after it is mandatory, right? Since otherwise `:Whatever` is a valid command name? I don't know. It's giving me a headache.\r\n\r\nImagine how much worse it gets if you're mixing in some null-coalescing and null-conditional calls.\r\n\r\nI think the `-then` and `-else` options are more in line with PowerShell syntax, especially if we overloaded `-else` for null-coalescing:  `$x = 2 * ($Size -else $DefaultSize)` \r\n\r\nI've been thinking the main gain of a conditional operator is the fact that it more explicitly _outputs_ a value, and doesn't require wrapping in `$( )` in order to feed that value to a pipeline and doesn't confuse people when you assign it's output to a variable.\r\n\r\nI'm not sure how often I'll use it, because it's readability is painful for PowerShell. For _anything_ non-trivial, you're going to loose most of the benefit if you have to wrap each clause in a parenthesis...",
      "created_at": "2019-07-18T21:37:51Z",
      "updated_at": "2019-07-18T21:50:44Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "> I just think PS should stay PS and not try to be a C-family lookalike.\r\n\r\nBut `if {} else {}`, `do/while/for/foreach() {}`, `switch () {}` and `try/catch/finally` **all** came from C-family languages.  I mean PS could have used `if fi` and `case ... esac` (ugh, just threw up in my mouth a little on that one).  They specifically chose in the early days to follow C#'s lead WRT syntax. \r\n\r\nThe whole `-<operator>` approach was hotly debated in the early Monad beta days but folks (rightly) couldn't get past using `>` for _greater than_ when in every other shell in the world, that's a redirection operator. \r\n\r\nGiven this conversation, I'm **shocked** we ever got `try/catch/finally` into the language.  We had `trap {}`, why add this new-fangly developer thing to catch exceptions?",
      "created_at": "2019-07-18T21:38:33Z",
      "updated_at": "2019-07-18T21:38:33Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "@rkeithhill if there had been an RFC process, you probably wouldn't have gotten try/catch unless someone implemented it first and demonstrated the performance impact \ud83d\ude09",
      "created_at": "2019-07-18T21:49:40Z",
      "updated_at": "2019-07-18T21:49:40Z"
    },
    {
      "author": "LarryWeiss",
      "author_association": "NONE",
      "body": "As an \"inclusionist\" I want both styles of syntax.  \r\nThe \"C\" like one, and the verbose PowerShell one.\r\nThe terse one I'd use at the command prompt.  The verbose one I'd use in a script.",
      "created_at": "2019-07-18T22:03:22Z",
      "updated_at": "2019-07-18T22:03:22Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "I think the pith motivation for a ternary is indicative; it's like an alias form of `$(if / else)`. In which case we should favour brevity, so `?` and `:`. That also means we can provide `?.` and `?[]` with null-soaking semantics (although the ternary condition should have the usual boolean-coercion falsey semantics) with some syntactical consistency. \r\n\r\nHolistically, PowerShell has a lot of differences from C# and I don't think it should just copy along on that front, but it's clearly in the C-like syntax family I think, so we can justify the `?` and `:` there as well.\r\n\r\nThat wouldn't stop us from adding something like `-then` and `-else` later to behave like `&&` and `||` do in JavaScript/TypeScript (which also have ternary operators).\r\n\r\nOn the newline complexity thing @Jaykul mentions, I'm again motivated by the brevity/pith thing. In Python `lambda`s can only be on a single line (because if it's longer than that you should write a function). Perhaps in PowerShell, if your ternary needs clever newline mangling, it's time to write an `if { } else { }`.",
      "created_at": "2019-07-18T22:16:24Z",
      "updated_at": "2019-07-18T23:12:58Z"
    },
    {
      "author": "rismoney",
      "author_association": "NONE",
      "body": "I think it's also confusing with $? usage.\r\n\r\n```powershell\r\n$? ? $? : '?'\r\n```\r\n\r\nWhy not use unused operators && and || or something else?\r\n\r\n\r\n\r\n",
      "created_at": "2019-07-18T22:55:05Z",
      "updated_at": "2019-07-18T23:52:32Z"
    },
    {
      "author": "WithHolm",
      "author_association": "NONE",
      "body": "I understand while reading all of this that the tenerary, is not really a thing that is going away. people coming from a developer background wishes to have this, while powershell needs to be verbose in order to be \"newbie\" friendly. A \"get used to this\" approach is a bad idea and will just create a bigger hurdle for new users.\r\n\r\nHowever.. ive been thinking:\r\nHow about using it as a cmdlet, that can be pielined and hopefully with a alias (like Foreach or Where)?\r\nThis makes the property easy to use, follows already existing powershell framework and does not require new defintions for the core. Most importantly it can be used in the command prompt!\r\n``` Powershell\r\n$var = @{\r\n    prop = \"Yes!\"\r\n}\r\n$var|Ternary-object{$_.prop, \"no\"}\r\n#small t, as a |T looks ugly, but it could also be some symbol\r\n$var|t prop, \"no\"\r\n```",
      "created_at": "2019-07-18T23:47:32Z",
      "updated_at": "2019-07-18T23:50:08Z"
    },
    {
      "author": "rismoney",
      "author_association": "NONE",
      "body": "Not sure if this in the realm of ternary, but is there a semantic for $foo=$bar if ($foo).  Ruby has nice syntactical sugar along those lines.\r\n",
      "created_at": "2019-07-18T23:56:47Z",
      "updated_at": "2019-07-18T23:56:47Z"
    },
    {
      "author": "glennsarti",
      "author_association": "NONE",
      "body": "> Not sure if this in the realm of ternary, but is there a semantic for $foo=$bar if ($foo). Ruby has nice syntactical sugar along those lines.\r\n\r\n@rismoney That is way outside the scope of the original ternary discussion. As a ruby user myself, that requires a whole other discussion.",
      "created_at": "2019-07-19T00:18:02Z",
      "updated_at": "2019-07-19T00:18:02Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@WithHolm\r\n\r\n>How about using it as a cmdlet, that can be pielined and hopefully with a alias (like Foreach or Where)?\r\nThis makes the property easy to use, follows already existing powershell framework and does not require new defintions for the core. Most importantly it can be used in the command prompt!\r\n\r\nPipelines are not really compatible with expression syntax; an expression is only usable at the start of a pipeline. As this is intended to be used in expression syntax, that doesn't jive particularly well.\r\n\r\nHowever, you _could_ indeed make such a function relatively easily for the purposes you describe. There's nothing stopping you from doing so. Also, even with the expression syntax... you can still use it at the prompt, not sure what you mean there. All PowerShell is valid from the PowerShell prompt.\r\n\r\n@rismoney \r\n\r\n>Why not use unused operators && and || or something else?\r\n\r\nBecause those are used for other things in Bash by convention, and intended more for use with commands rather than expressions. That is also being implemented in a currently-being-worked-on PR from @rjmholt.\r\n\r\n@Jaykul \r\n\r\n> I'm not concerned you'll break that -- I'm asking how a user is supposed to know that's not what you're doing.\r\n>\r\n> If you put the \":\" on the following line, then suddenly the space or parenthesis after it is mandatory, right? Since otherwise :Whatever is a valid command name? I don't know. It's giving me a headache.\r\n>\r\n> Imagine how much worse it gets if you're mixing in some null-coalescing and null-conditional calls.\r\n>\r\n> I think the -then and -else options are more in line with PowerShell syntax, especially if we overloaded -else for null-coalescing: $x = 2 * ($Size -else $DefaultSize)\r\n\r\nI don't disagree with your stance here, but I do think making the operators look too much like existing operators is asking for a difficult time for people just learning it. Ternary is not a currently available syntax in PS, and I think we'd be lax to make it look too similar to currently available syntax. It is a different syntax, and it's going to behave differently to existing binary operators; thus, it should _look_ different to set the correct expectation.\r\n\r\nAnd, as with anything new we introduce -- there's always a bit of a barrier for new folks whenever something new is added. That's why we document features; I don't think \"people aren't immediately going to be familiar with it\" is a great place to start at -- PowerShell as a very _concept_ was initially so alien that it required a whole manifesto before there was sufficient buy-in for it to even get started.\r\n\r\nPowerShell strives to be as accessible as possible, but also as flexible as possible, given that it's a shell. Elastic syntax is great for this; I'd generally consider this more as a more brief way to write `if ($a) { $then } else { $otherwise }` that we can already work with. Yes, it's not perfectly equivalent as we want it to live in the realm of expressions rather than keywords or commands, but it is effectively the expression equivalent -- and the if/else syntax remains available.",
      "created_at": "2019-07-19T00:29:58Z",
      "updated_at": "2019-07-19T00:29:58Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "> On the newline complexity thing @Jaykul mentions, I'm again motivated by the brevity/pith thing. In Python `lambda`s can only be on a single line (because if it's longer than that you should write a function). Perhaps in PowerShell, if your ternary needs clever newline mangling, it's time to write an `if { } else { }`.\r\n\r\nPowerShell is very verbose, so you're really reducing the usefulness of a ternary operator if you're forcing it to be used only on a single line. Even in C#, which is much more pithy than PowerShell, I span ternary operators across multiple lines all the time because (a) it reads very well, and (b) it is much easier to see what will happen when the code runs. e.g.\r\n\r\n```csharp\r\nRunspace = _streamingHost != null\r\n    ? RunspaceFactory.CreateRunspace(_streamingHost, iss)\r\n    : RunspaceFactory.CreateRunspace(iss);\r\n```\r\n\r\nCarrying that same example into PowerShell as a single line would give us this:\r\n\r\n```powershell\r\n$Runspace = $streamingHost -ne $null ? [RunspaceFactory]::CreateRunspace($streamingHost, $iss) : [RunspaceFactory]::CreateRunspace($iss)\r\n```\r\n\r\nAnd that's with an example that's not even indented.\r\n\r\nCompare that with:\r\n\r\n```powershell\r\n$Runspace = $streamingHost -ne $null\r\n    ? [RunspaceFactory]::CreateRunspace($streamingHost, $iss)\r\n    : [RunspaceFactory]::CreateRunspace($iss)\r\n```\r\n\r\nIf implicit continuance is not supported, that would look like this:\r\n\r\n```powershell\r\n$Runspace = $streamingHost -ne $null ?\r\n    [RunspaceFactory]::CreateRunspace($streamingHost, $iss) :\r\n    [RunspaceFactory]::CreateRunspace($iss)\r\n```\r\n\r\nThat's a little awkward. Plus with these examples, they aren't even using actual PowerShell commands, which could result in the ternary operator symbols being far off to the right where it becomes quite difficult to see what is going on at a glance.\r\n\r\nGoing back to the `-then|-else` proposal, I like that syntax as an option, and could see myself using:\r\n\r\n```powershell\r\n$Runspace = $streamingHost -ne $null `\r\n    -then [RunspaceFactory]::CreateRunspace($streamingHost, $iss) `\r\n    -else [RunspaceFactory]::CreateRunspace($iss)\r\n```\r\n\r\nBut to get that syntax I'd need the backticks I used here or some sigil to indicate I want multi-line continuation for that command since `-then` and `-else` could be command names already in place in people's scripts.\r\n\r\nIf that was the only option for ternary, I'd just do this instead:\r\n\r\n```powershell\r\n$Runspace = if ($streamingHost -ne $null) {\r\n    [RunspaceFactory]::CreateRunspace($streamingHost, $iss)\r\n} else {\r\n    [RunspaceFactory]::CreateRunspace($iss)\r\n}\r\n```\r\n\r\n@jaykul For your earlier example of ternary use with comments and `Invoke-Command`, I think that highlights a few best practices that should come out with ternary support:\r\n\r\n1. Ternary operators should only be used for short commands. If you have to use anything more than a single command on a single line inside a ternary operator, you should probably use an if statement instead.\r\n1. Comments used inside ternary operators should be brief and on a single line. If you require longer comments, you should place those comments before the ternary operator.\r\n\r\nWe could consider not allowing comments inside of a ternary (that's just a boolean flag to switch in the code) if we feel they'll cause more confusion than they're worth.",
      "created_at": "2019-07-19T00:54:42Z",
      "updated_at": "2019-07-19T00:54:42Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I think the right approach is to be very conservative in extending the language. So what is the main question that we cannot do without this operator by existing means?\r\nToday I don\u2019t see why it\u2019s definitely better than `$var = if ( ... ) { ... } else { \u2026 }`",
      "created_at": "2019-07-19T04:14:40Z",
      "updated_at": "2019-07-19T04:14:40Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> I think the right approach is to be very conservative in extending the language\r\n\r\n@iSazonov personally I'm very much with your there. I think here basically there's been an ask on this one for a while and in a restricted sense it's not a huge feature. Under ordinary circumstances I think it's worth opting on the conservative side, but in this case I think it's a nice inclusion and unusually for PowerShell, it can be implemented in a way that doesn't really step on any toes.\r\n\r\n> I span ternary operators across multiple lines all the time because (a) it reads very well, and (b) it is much easier to see what will happen when the code runs\r\n\r\n@KirkMunro I totally agree with you there &mdash; I do the same in C#. However, my feeling there is:\r\n\r\n- PowerShell can assign from if-statements already, unlike C# where assigning across the branches of a statement is much less wieldy\r\n- Given that pre-existing facility in PowerShell, the ternary's main purpose is to be a convenient shorthand\r\n- Compared to the usual post-`?`-operator line continuation, the pre-`?`-operator continuation is both trickier to implement and collides with `?` as a command name (which I know is unusual, but still non-zero)\r\n- So having `?`/`:` with no pre-continuation, we have a ternary with a philosophy to encourage complex expressions to be more verbose and self-documenting, and don't have to deal with the command/operator conflict problem\r\n\r\nI personally imagine `?`/`:` to be an ergonomic improvement for interactive and on-the-fly PowerShell usage, and something that PSScriptAnalyzer will likely encourage you to replace with `if`/`else` in scripts deployed for long-term or shared usage. I think if you want a conditional expression and you're going to spend more characters on `if`/`else` than the body then that's what the ternary serves.\r\n\r\nI'll admit that I don't have a strong or dogmatic feeling on this particular feature (I also like `-then` and `-else` but I think they could be added separately as non-coercing truthy/falsey expression operators). But that leads me to think it's best to keep this feature smaller.",
      "created_at": "2019-07-19T05:24:59Z",
      "updated_at": "2019-07-19T05:31:49Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> ... and something that PSScriptAnalyzer will likely encourage you to replace with if/else in scripts deployed for long-term or shared usage.\r\n\r\n@rjmholt Personally, I don't think `PSScriptAnalyzer` should discourage the use of ternary operator in script. It's less nesting comparing to `if {} else {}`, and could be cleaner in many cases.",
      "created_at": "2019-07-19T06:41:35Z",
      "updated_at": "2019-07-19T06:41:35Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "> So having ?/: with no pre-continuation...\r\n\r\nIt's pre-continuation or bust for this operator as far as I'm concerned, because without that it simply cannot add enough value to be useful, as I attempted to demonstrate in the examples above.\r\n\r\nOn the conflict/potential confusion with the `?` alias for `Where-Object`, since aliases are not meant for use in scripts, I wonder if that helps reduce the potential for confusion with this operator, which would be for use in scripts. \ud83e\udd14",
      "created_at": "2019-07-19T12:54:35Z",
      "updated_at": "2019-07-19T12:54:35Z"
    },
    {
      "author": "rismoney",
      "author_association": "NONE",
      "body": "Aliases, especially ? can be used in scripts and have been present in the language since inception.  They are first class citizens.",
      "created_at": "2019-07-19T13:00:10Z",
      "updated_at": "2019-07-19T13:00:10Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "@daxian-dbw \r\n\r\n> @KirkMunro Good catch. The continuation of `?` will break `? -InputObject $c Count -gt 0` in that case, so it will be a potential breaking change.\r\n> Personally, I'm not too worried about it. That's a very obscure use of `Where-Object` and I presume the possibility of actually breaking any scripts is very low.\r\n> But we do need the committee review to approve this.\r\n\r\nWould it be feasible to fall back to command parsing if `:` is not included?\r\n\r\ne.g.\r\n\r\n```powershell\r\n# Parse as ternary:\r\n0 -eq 1\r\n    ? \"something\"\r\n    :  \"nothing\"\r\n\r\n# Parse as binary expression; command; string constant:\r\n0 -eq 1\r\n    ? \"something\"\r\n    \"nothing\"\r\n```\r\n\r\nI haven't looked at what parts of resync are expensive, but if it's the actual act of falling back and not the saving of state, the impact should be minimal yeah?",
      "created_at": "2019-07-19T13:10:29Z",
      "updated_at": "2019-07-19T13:10:29Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "@SeeminglyScience that example in particular is worrying to me; it's a naturally LR grammar construct that we must parse with an LL parser. We have to do arbitrary lookahead to cross the tokens of the first expression to know what kind of token and therefore what syntactic element we are looking at. That conflicts with the essential structure of the PowerShell parser.\r\n\r\n[Here](https://stackoverflow.com/a/56503144/9944203) is a fuller explanation of what I'm talking about.",
      "created_at": "2019-07-19T15:48:35Z",
      "updated_at": "2019-07-19T16:22:23Z"
    },
    {
      "author": "MSAdministrator",
      "author_association": "NONE",
      "body": "I think that that PowerShell should use the same/similar syntax as Python.\r\n\r\n$False if $x -eq 1 else $True",
      "created_at": "2019-07-20T03:13:27Z",
      "updated_at": "2019-07-20T03:13:27Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "The more we debate this, the more the `-then` and `-else` options look better to me.\r\n\r\nHowever, the more I think about that (and go and re-read @BrucePay's [arguments for not adding this](https://github.com/PowerShell/PowerShell/issues/3239#issuecomment-383776193)) the more I wonder why we are doing this at all. PowerShell doesn't really need to be terse.\r\n\r\nBut if people actually think the brackets make things unreadable, why not just ...\r\n\r\n### Make the parenthesis optional and allow the use of `then` instead\r\n\r\nOf course, we risk looking like VB instead C#, but if we can make the parser handle `?:` then certainly we can make it handle `if then else` without braces?\r\n\r\nIt would basically be the same as adding the ternary operator with `-then` and `-else` except you'd have to write the `if` keyword on the front.  Putting that on the front should make most of the opposition about readability go away, and _if_ we choose not to need the `-` on the front of `then` and `else` _then_ it works out to the same number of keystrokes \ud83d\ude44\r\n\r\n```PowerShell\r\n$Runspace = if $streamingHost -ne $null \r\n    then [RunspaceFactory]::CreateRunspace($streamingHost, $iss)\r\n    else [RunspaceFactory]::CreateRunspace($iss)\r\n```\r\n\r\nIs definitely somewhat more readable than:\r\n\r\n```PowerShell\r\n$Runspace = $streamingHost -ne $null\r\n    -then [RunspaceFactory]::CreateRunspace($streamingHost, $iss)\r\n    -else [RunspaceFactory]::CreateRunspace($iss)\r\n```\r\n\r\nAnd much more readable than:\r\n\r\n```PowerShell\r\n$Runspace = $streamingHost -ne $null\r\n    ? [RunspaceFactory]::CreateRunspace($streamingHost, $iss)\r\n    : [RunspaceFactory]::CreateRunspace($iss)\r\n```\r\n\r\nOf course, this does not actually solve any problems, and any change like this opens a can of worms with regards to additional syntax changes. In fact, this change as proposed, is clearly more complicated (in terms with colliding with existing syntax) and less useful (in terms of new functionality) than most syntax changes that could be proposed.",
      "created_at": "2019-07-20T17:45:13Z",
      "updated_at": "2019-07-20T21:12:08Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "While I could maybe see adding `-then|-else` operators, please **do not** add `then` as a new keyword.  PowerShell is not an `if/then` language ala Basic.  And at some point, unless you can achieve something close to the pithiness of `?:` then don't bother.  We already have an existing solution which I do use, I just really don't like its verbosity/ceremony for such a simple concept.  ",
      "created_at": "2019-07-20T23:29:06Z",
      "updated_at": "2019-07-20T23:29:06Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Exactly. If you want the verbosity, we _have_ if statements already, and there's nothing wrong with them.\r\n\r\nThe ternary is just an expressive shorthand. \ud83e\udd37\u200d\u2642 ",
      "created_at": "2019-07-21T01:16:20Z",
      "updated_at": "2019-07-21T01:16:20Z"
    },
    {
      "author": "TobiasPSP",
      "author_association": "COLLABORATOR",
      "body": "> The more we debate this, the more the `-then` and `-else` options look better to me.\r\n\r\nSome thoughts from someone busy teaching beginners and advanced users alike how to use PS to its fullest (and I may be terribly wrong with some observations yet am thrilled to see this lively public discussion prior to making changes to the language):\r\n\r\n- Let's be careful with adding arbitrary \"exceptions\" to the language \"rules\". We currently have two language elements that start with a hyphen: parameters and operators. -then/-else are neither one, and work very different. If we want these, we'd probably have to call them then/else rather than -then/-else.\r\n- isn't similarity to c# semantics a good thing? In the past, it has helped a lot to translate code between PS and c#, and I know many who started as non-programmers and through PS found their way to c#. When we add constructs that are specific to PS, we are making this harder.\r\n- Alias conflicts are not new, we have seen them from day 1 with foreach/foreach. PS simply caters all needs. You can be as declarative and backwards compatible as you want using if/elseif/else, as cryptic with aliases and positional arguments, and as dense and efficient with ?:. It takes no effort to write AST-based tools that automatically convert one way to another, and auto-expand ?: with old-style if blocks should you want that. So ?: may indeed look confusing to beginners, just like attributes and advanced functions. That's not a bad thing. Like Kennedy would put it: \"We choose to introduce ?: not because it is easy but because it is hard.\" :-)\r\n",
      "created_at": "2019-07-21T10:03:13Z",
      "updated_at": "2019-07-21T10:03:13Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "On the potential confusion because of the `?` alias for `Where-Object`, I was thinking this weekend that we just need to change the way we think about `?`. Instead of just looking at `?` as an alias, we need to teach/look at it as a context-sensitive conditional check. What it checks and what happens as a result depends on the context in which it is used. This shouldn't be much more difficult to learn then an operator that can be used as either an unary operator or a binary operator.",
      "created_at": "2019-07-21T12:19:05Z",
      "updated_at": "2019-07-21T12:19:05Z"
    },
    {
      "author": "TobiasPSP",
      "author_association": "COLLABORATOR",
      "body": "I thought exactly the same this morning \ud83d\ude00 ? complements the existing ?-alias very well.\n\nVon meinem iPhone gesendet\n\n> Am 21.07.2019 um 14:19 schrieb Kirk Munro <notifications@github.com>:\n> \n> On the potential confusion because of the ? alias for Where-Object, I was thinking this weekend that we just need to change the way we think about ?. Instead of just looking at ? as an alias, we need to teach/look at it as a context-sensitive conditional check. What it checks and what happens as a result depends on the context in which it is used. This shouldn't be much more difficult to learn then an operator that can be used as either an unary operator or a binary operator.\n> \n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n",
      "created_at": "2019-07-21T13:02:27Z",
      "updated_at": "2019-07-21T13:02:27Z"
    },
    {
      "author": "essentialexch",
      "author_association": "NONE",
      "body": "\"He's dead Jim\" - Dr. McCoy.\r\n\r\nThe so-called \"glide path to C#\" took a death dive off a cliff in v3 and hasn't been seen since.",
      "created_at": "2019-07-21T13:05:24Z",
      "updated_at": "2019-07-21T13:05:24Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "> \"glide path to C#\" took a death dive off a cliff in v3 and hasn't been seen since.\r\n\r\nReally?  How about the support added for classes and interfaces in v5?",
      "created_at": "2019-07-21T16:02:35Z",
      "updated_at": "2019-07-21T16:02:35Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> but if we can make the parser handle ?: then certainly we can make it handle if then else without braces\r\n\r\nIf you take the braces out and keep `else` optional ([which it isn't in Haskell](https://en.wikibooks.org/wiki/Haskell/Control_structures), and in F#, OCaml and Rust is a type error when `else` is not included and the `then` clause has a non unit/void expression type), you face [another fundamental grammatical ambiguity issue](https://en.wikipedia.org/wiki/Dangling_else) which I don't think anyone will enjoy explaining to people learning PowerShell for the first time.\r\n\r\nThe `-then`/`-else` operators, being operators, arguably don't require such an explanation since they'd probably just be left-associative (like `&&` and `||` are in JavaScript/TypeScript).",
      "created_at": "2019-07-22T03:06:46Z",
      "updated_at": "2019-07-22T03:15:35Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "@TobiasPSP said:\r\n\r\n> Let's be careful with adding arbitrary \"exceptions\" to the language \"rules\". We currently have two language elements that start with a hyphen: parameters and operators. -then/-else are neither one, and work very different. If we want these, we'd probably have to call them then/else rather than -then/-else.\r\n\r\nBut they **_are_** an operator, as it says up there in the topic, this thing we're talking about is the \"ternary operator\" (sometimes called the conditional operator), and `-then -else` would just be using different symbols for it, like we do for most of the other operators.\r\n\r\nI honestly don't love the idea of reverse-justifying the alias by pretending it's similar to the operator -- and then using _that_ as a justification for choose the more terse syntax. \ud83d\ude15\r\n\r\nI'll admit I think the ternary will reduce readability _for the target audience_ of PowerShell. Using the `?:` syntax, it's hard to look up online or in the help, unless you already know what it is. If you know what it is, then it's wonderful -- until someone nests it a few times and you have to untangle it. Anyway, I think it's a feature that's more for code-golf than for readability.\r\n\r\nI've had my say, so I'm going to let this lie. I don't feel strongly one way or another. I'm sure I'll use it in the console all the time if it's there -- at the same time I advise people _not_ to use it in shared scripts and production code \ud83e\udd23",
      "created_at": "2019-07-22T03:36:08Z",
      "updated_at": "2019-07-22T03:36:08Z"
    },
    {
      "author": "TobiasPSP",
      "author_association": "COLLABORATOR",
      "body": "> But they **_are_** an operator, as it says up there in the topic, this thing we're talking about is the \"ternary operator\" (sometimes called the conditional operator), and `-then -else` would just be using different symbols for it, like we do for most of the other operators.\r\n\r\nYes and no. the ternary operator is a rare operator that takes three operands. So while \"-then\" is an operator, \"-else\" is not.\r\n\r\nPowerShell has one of these operators already: -replace. It uses an array on the right side to provide more than one operand, similar to:\r\n\r\n$a -eq 1 -then $true, $false \r\n\r\nThis is coincidentally how the \"classic\" ternary operator works in many languages, it commonly just uses its own separator token (\":\") to distinguish the two operands:\r\n\r\n$a -eq 1 -then $true : $false\r\n$a -eq 1 ? $true : $false\r\n\r\nWhether you like \"?\" or \"-then\" better I wouldn't care too much. I'd just ask that we stick to the language rules and not use -else as a mere operand separator token while making it look like a concatenated binary operator:\r\n\r\n$a -eq 1 -then $true -else $false \r\n\r\nBy syntactical standards, -else would be defined as binary operator, but behavioral, it would be a keyword because it is not acting at all on its two operands on either side but it is rather part of -then and sharing one operand with -then. Admittedly, this sounds pretty picky, theoretical and bureaucratic, but it  harms the predictability of the language: how would the parser tokenize -else? Would it be tokenized as an operator? If not, and it gets a color different from -then, that's confusing. If it appears as an operator, and gets the same color as -then, that's confusing, too, when it suddenly is no operator anymore once you remove -then, and when it not acts on its operands but rather uses an operand from a \"different\" operator. \r\n\r\nThese lines would be inline with existing PowerShell language rules:\r\n\r\n$a -eq 1 -then $true, $false \r\n$a -eq 1 -then $true : $false  (requires a new keyword \":\")\r\n$a -eq 1 ? $true : $false  (requires a new keyword \":\"\r\n\r\nThis would be a violation since -else is no operator:\r\n\r\n$a -eq 1 -then $true -else $false\r\n\r\nWhen you look at these, they are all really not that much different. I'd go with one of the upper three.\r\n\r\n(technically, it would impose different challenges to use \",\" or \":\". \",\" probably would require some sort of \"command mode\" or take a command AST as array elements, but that's something easily resolvable in the back-end).\r\n",
      "created_at": "2019-07-22T07:20:40Z",
      "updated_at": "2019-07-22T07:20:40Z"
    },
    {
      "author": "Taoquitok",
      "author_association": "NONE",
      "body": "> PowerShell has one of these operators already: -replace. It uses an array on the right side to provide more than one operand, similar to:\r\n> \r\n> $a -eq 1 -then $true, $false\r\n> \r\n> This is coincidentally how the \"classic\" ternary operator works in many languages, it commonly just uses its own separator token (\":\") to distinguish the two operands:\r\n\r\nIt's good to see someone else come to this example, I thought I was going mad being the only person to suggest following the same structure used by -replace.  \r\n  \r\n[Vexx32 has already added some comments on why this would be difficult in the related suggestion issue](https://github.com/PowerShell/PowerShell/issues/3239#issuecomment-512234110), but if time is being spent on adding in new functionality anyways, presumably spending it on a format that's already familiar to the powershell language would be worth while?  \r\n  \r\nI believe the concept of `logical check -operator 'true result','false result'` fits in far more neatly with existing behaviour, while still meeting the needs of speed and ease to write compared to a full `if( ){ } else{ }` statement, and if we do follow the same structure as `-replace`, it would also work across multiple lines, allowing for consistent readability with existing functionality\r\n  \r\nTalking about readability, and ease of searching to find documentation, rather than `-then`, why not `-ternary` ? This would at least make it explicitly clear what's happening to those who know what a ternary is, while making it very easy for the wider powershell community to learn what the new functionality is, and what the common term is for this functionality.  \r\n\r\n[I mentioned this in my earlier comment, quoted the relevant parts below:](https://github.com/PowerShell/PowerShell/pull/10161#issuecomment-512193862)\r\n\r\n> \r\n> Much like with the current behaviour of `-replace / .replace()`, which can be spread across lines, using this existing operator format would be consistent with existing behaviours, so for example the below works with `replace`\r\n> \r\n> ```\r\n> # Same line\r\n> 'test' -Replace 'te','re'\r\n> # output: rest\r\n>\r\n> # multi-line\r\n> 'test' -Replace\r\n>     'te',\r\n>     're'\r\n> # output: rest\r\n> ```\r\n> \r\n> So why not follow the same pattern for ternary?\r\n> \r\n> ```\r\n> # Same line\r\n> $a -eq $b -ternary $a,$c\r\n> \r\n> # multi-line\r\n> $a -eq $b -ternary \r\n>     $a,\r\n>     $c\r\n> \r\n> ```\r\n\r\nI must say though that having followed these discussions, I'm now more open to the idea of `? :` from the technical and usage side, but I'm definitely still worried that it'll be exceptionally difficult for people who do not have experience with ternaries to find out what on earth this does.  \r\nSearching for `powershell ? :` in google, with any combination of \"\" and + comes up blank, while you would hope it would find either github issue, while searching for \"powershell ternary\" comes up with the related suggestion github issue.  \r\nSame with searching for \"? :\" in regards to C#.. it doesn't come up with much, and without knowing you need to search for \"?:\" you'll have issues trying to find information.\r\n",
      "created_at": "2019-07-22T15:47:59Z",
      "updated_at": "2019-07-22T17:14:55Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Though I'm reiterating a bit... I do dislike the idea of a `$condition -operator $trueAction, $falseAction` syntax -- it means we now have a **third** usage for a comma. Far more confusing in my opinion, and complicates both parsing and using the syntax when one option or another may potentially be an array value. And we can't just make it a regular array, either, if we want short-circuiting behaviour -- we'd end up with side effects being executed from both branches as the array is evaluated, which is not great. \ud83d\ude15 \r\n\r\nI definitely see the argument for discoverability though. Maybe we need a midway approach, with something like `$condition -choose $trueAction : $falseAction` so there's at least a keyword to google.\r\n\r\nBut again, this kinda muddies the waters with keywords and it having specialised syntax. PS can alleviate some discoverability by simply having a help document labelled `about_?:` or something, really. It mightn't be a valid _filename_ but it can still be a help topic name iirc.\r\n\r\nYes, a brand new syntax isn't the best for newbies to pick up, but having it look like something they might be familiar with when it simply... isn't... is (I think) a good deal worse, as instead of approaching it with a \"what even is this\" they'll approach it with a \"oh, this is like an operator!\" and then have all their previous assumptions about operators fall apart around them.",
      "created_at": "2019-07-22T17:11:43Z",
      "updated_at": "2019-07-22T17:14:18Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "Reiterating a brief conversation I had on this with @daxian-dbw and @rjmholt last week. \r\n\r\nI'm in support of the traditional `?`/`:` ternary operator, working out of two base assumptions (which I'm happy for everyone to jump in and invalidate):\r\n\r\n1. PowerShell typically has a recommended, \"PowerShell-y\" way to do things, and then a bunch of terse shortcuts and syntactical allowances. We have aliases, and we tell people not to use them in scripts. We also tell people not to omit the `Get-` from invocations like `ChildItem`. (Just check out [`Invoke-Obfuscation`](https://github.com/danielbohannon/Invoke-Obfuscation) for an extreme example of all the unreadable stuff we support.)\r\n1. When C# developers (*who like the ternary operator*, I recognize there's a set who don't) use PowerShell, they're upset when the ternary operator isn't in PowerShell. For me, this is the big one: I want it to be as easy as possible for C# developers (especially those working on SDKs for .NET/C# applications) to dabble in PowerShell. Even if they're writing cmdlets in C#, I'd like to lower the bar for them to write their build/test/CI/CD scripts in PowerShell (hence why we worked with .NET to add `pwsh` to the .NET SDK containers).\r\n\r\nThis latter reason is also why I think the `-then`/`-else` (with or without `-`) buys us nothing: the first time a C# dev searches up \"PowerShell ternary\" and sees that, they're going to be off put. And then who is it for? PowerShell scripters in this thread that are already arguing `if`/`else` or more parens/brackets are fine? \r\n\r\nIf we end up in a situation where C# and other developers are writing so much PowerShell that our community is littered with what traditional PowerShell scripters might call an unreadable ternary operator, I think that's a good problem to have. \r\n\r\nNot to mention we can warn or fail their modules on a PSSA run to `AvoidTernaryOperator` and give them a quick fix for traditional if/else. \r\n\r\nThe only arguments I've heard thus far against ternary altogether generally roll up to \"I don't like it\", \"it's ugly\", or \"people won't know what it means\". To the first two, I'd say \"just don't use it\", and for me the last one is addressed by PSSA and community self-enforcement (and if the community takes off with it, then folks will learn it). ",
      "created_at": "2019-07-22T18:14:24Z",
      "updated_at": "2019-07-22T18:14:24Z"
    },
    {
      "author": "TobiasPSP",
      "author_association": "COLLABORATOR",
      "body": "The \u201etarget audience\u201c for this operator is the group of people who asked for it, apparently people with c# background. So we probably shouldn\u2019t waste time by trying to make it attractive and digestible for anyone else and in the end come up with something that is so polished and artificial that it isn\u2018t working well for anyone anymore. Plus c# has always been Powershells alter ego so c# style helps with translating code from c# to PS, too. ",
      "created_at": "2019-07-22T18:40:34Z",
      "updated_at": "2019-07-22T18:40:34Z"
    },
    {
      "author": "WithHolm",
      "author_association": "NONE",
      "body": "I still don't like this idea. This really goes against how powershell has worked and should work. Hell. I dont even like -match and -replace, but that is for other reasons (-Match is messy and -replace is Regex, and not string replace). Im repeateing myself now: IF this was going into powershell i would much rather have it as a cmdlet than a operator. It represents \"The powershell way\" much better than a new operator. this would then include verb/operator'y alias that could represent this, and the invocation would happen in a scriptblock. This way you get the \"Golf-IF\" and powershell operates like normal. Also you get the benefit that c# devs learn the powershell syntax. Powershell is not C#, even tho they share common ground. There is a probable reason why the pipeline and the syntax is the way it is.\r\n\r\n`$this -eq $that|t{\"Yes\",\"No\"}`  \r\nor multiline:  \r\n``` Powershell\r\n$this -eq $that|t{\r\n   \"Yes\",\r\n   \"No\"\r\n}\r\n```",
      "created_at": "2019-07-22T22:59:15Z",
      "updated_at": "2019-07-22T23:03:36Z"
    },
    {
      "author": "essentialexch",
      "author_association": "NONE",
      "body": "@rkeithhill - as an admin scripter, not a dev, I've never seen a reason to use interfaces. So I have no opinion on that.\r\n\r\nHowever, the v5 class implementation is incomplete and the syntax is not C# compatible.  It's as close to VBScript as it is to C#.\r\n\r\nFor all of you C# folks, I encourage you to try to explain this to a C# programmer:\r\n\r\n`(dir).FullName\r\n`\r\n\r\nAs I wrote before - the C# glide path died with v3.\r\n\r\nNote: I don't disparage the class implementation or imply negative things about the PowerShell PG whatsoever. But those of you suggesting that PowerShell syntax should adhere to C# syntax and behavior - I find it ridiculous. That ended with the release of v3.",
      "created_at": "2019-07-22T23:30:52Z",
      "updated_at": "2019-07-22T23:30:52Z"
    },
    {
      "author": "rismoney",
      "author_association": "NONE",
      "body": "`We have aliases, and we tell people not to use them in scripts`\r\n\r\nThis nonsense rubric needs to end.  People use them, have always used them and aliases are a core tenet since v1, and it needs to stop being pushed in social circles. Aliases are, have been, and will continued to be used in scripts.  Assume that.\r\n",
      "created_at": "2019-07-23T00:17:56Z",
      "updated_at": "2019-07-23T00:17:56Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "I don't see how the PS class declaration syntax of:\r\n```\r\nclass foo { }\r\n``` \r\nis more similar to VBScript's syntax:\r\n```\r\nClass foo\r\nEnd Class\r\n```\r\nversus the C# syntax of:\r\n```\r\nclass foo { }\r\n```\r\n??\r\n\r\n> those of you suggesting that PowerShell syntax should adhere to C# syntax and behavior - I find it ridiculous\r\n\r\nThe above comparison is actually a good case-in-point. When classes were added to PowerShell, the team did not follow VB/VBScript syntax.  Instead, they followed the C# syntax for class declaration and even interface inheritance e.g. `class myArgCompleter : System.Management.Automation.IArgumentCompleter {}`.  That said, the syntax for classes internally is definitely more tuned for PowerShell's approach to specifying (field, parameter, return) types.\r\n\r\nI don't think anybody is saying that PowerShell needs to match C# syntax one-for-one.  It's just that **if** PowerShell were to add a language feature that has a direct analog in C#, then perhaps it should use that syntax - **if** it can **without** breaking other aspects of PS usage.\r\n\r\nRE the \"glide path to C#\", I think that still exists and has evolved to be a two-way glide path.  I suspect more than a few admin scripters have benefitted from various C# code samples on SO and other places.  I also know from personal experience that SW devs (particularly C/C#) I work with have had a much easier time writing scripts and modifying my scripts.  They do appreciate things like familiar control flow constructs (vs if/fi, case/esac).  \r\n\r\nI'd like to think that PowerShell \"scripters\" is a **big** tent that can accommodate many levels of proficiency.  Folks at the lower levels don't have to use more advanced features like classes, try/catch/finally or a ternary operator.  But I think it is short-sighted to deny some (and I can't believe I'm saying this about a ternary operator) \"advanced\" features to those that are further along. ",
      "created_at": "2019-07-23T00:18:47Z",
      "updated_at": "2019-07-23T00:19:32Z"
    },
    {
      "author": "essentialexch",
      "author_association": "NONE",
      "body": "You chose only the declaration. There is far more to a class than just the declaration.\r\n\r\nI recently spent 2 _days_ taking a C# function from C# to PowerShell. By request of a client. I certainly did not think it a good use of my time. (And I will blog on this topic.)\r\n\r\nBut this experience certainly re-enforces my perspective that the glide path is dead.",
      "created_at": "2019-07-23T00:31:55Z",
      "updated_at": "2019-07-23T00:31:55Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "> I certainly did not think it a good use of my time\r\n\r\nSorry to hear that.  I thought all billable time was a good use of time.  \ud83d\ude09 ",
      "created_at": "2019-07-23T00:41:34Z",
      "updated_at": "2019-07-23T00:41:34Z"
    },
    {
      "author": "TobiasPSP",
      "author_association": "COLLABORATOR",
      "body": "> I'd like to think that PowerShell \"scripters\" is a **big** tent that can accommodate many levels of proficiency. \r\n\r\nPowerShell is a big tent, couldn't agree more. So if apparently a large group loves to get that construct, why not happily help give it to them? \r\n\r\nThe very thing that matters to me is that new things must not damage existing things or make life harder for existing users. Adding -else that looks like an operator but is just an extension to -then would damage a rule because beginners could no longer trust that a stand-alone keyword beginning with a hyphen is an operator. \r\n\r\nWith ?: in comparison, it would be trivial to add a rule to the script analyzer to auto-convert ?: to an if statement for those uncomfortable with it. So I can't see this addition to have a hurting impact on existing users. \r\n\r\nAnd yes, we can build that operator on top of existing PS constructs like cmdlets or operators or arrays, and it's smart to evaluate these opportunities first before adding something new. After due inspection of the alternatives, I come to the conclusion that any effort to try and make the ternary operator more \"powershelly\" by implementing it via cmdlet or operator/array either kills the initial cause (loses its brevity, simplicity, familiarity), or has the potential of messing up the language rules by \"bending\" them too much. \r\n\r\nI'd love to see ?: plus a new script analyzer rule that auto-converts it to if-else on demand.",
      "created_at": "2019-07-23T09:35:47Z",
      "updated_at": "2019-07-23T09:35:47Z"
    },
    {
      "author": "LarryWeiss",
      "author_association": "NONE",
      "body": "> `We have aliases, and we tell people not to use them in scripts`\r\n> \r\n> This nonsense rubric needs to end. People use them, have always used them and aliases are a core tenet since v1, and it needs to stop being pushed in social circles. Aliases are, have been, and will continued to be used in scripts. Assume that.\r\n\r\nI am not a total absolutist on this, and I used to not appreciate the benefit for minimizing the use of aliases in scripts, but now I want consistency enough to get on the bandwagon and vote to normalize scripts by eliminating all aliases.  That way, when I'm searching a repository for something I can just use the one spelling and have a good chance on finding all occurrences of the thing.  Having said that, I love to use aliases when entering commands at the command prompt.  Aliases are a good thing to have on hand.",
      "created_at": "2019-07-23T13:22:44Z",
      "updated_at": "2019-07-23T13:22:44Z"
    },
    {
      "author": "rismoney",
      "author_association": "NONE",
      "body": "The hypocrisy of folks decrying aliases in scripts due to ambiguity are the same advocates of ? : syntax???  I'm in favor of ? : not because of current lang alignment, but because it is largely a conventional thing at this point.  The former because dir is the convention for directory listing, not get-childitem.  This talk with -then -else operators is just verbosity against the efforts intention.",
      "created_at": "2019-07-23T13:46:20Z",
      "updated_at": "2019-07-23T13:46:20Z"
    },
    {
      "author": "HumanEquivalentUnit",
      "author_association": "CONTRIBUTOR",
      "body": "> For me, this is the big one: I want it to be as easy as possible for C# developers (especially those working on SDKs for .NET/C# applications) to dabble in PowerShell. Even if they're writing cmdlets in C#, I'd like to lower the bar for them to write their build/test/CI/CD scripts in PowerShell\r\n\r\nPowerShell could be a build scripting system for C# devs, but it wasn't originally made for that - is there a push to move it towards that? Would pushing PS towards C# devs raise its profile inside Microsoft?\r\n\r\nAssume a future where this push is a great success and it's now \"as easy as possible\" for C# devs, what else could we admin-scripty people expect to see in this future? Has PowerShell turned completely into a superset of C#?\r\n\r\nPowerShell is already much much closer to C# than anything else the devs could be using, isn't it? Batch files, Bash, build systems made of XML, other scripting languages - except possibly [CAKE](https://cakebuild.net/) which is a C# DSL and PS will struggle to get closer than that. But they're still resisting dabbling in PowerShell because it's not enough like C# because of `?:` ?  I assume that's actual feedback instead of speculation? What other changes would lower this bar further?\r\n\r\n> When C# developers (who like the ternary operator, I recognize there's a set who don't) use PowerShell, they're upset when the ternary operator isn't in PowerShell. \r\n\r\nIt doesn't automatically follow that the fix should be \"put a ternary operator in PowerShell\". Different languages are different.\r\n\r\nBut if that is the fix .. I'm back to asking if there's a push to turn PowerShell completely into a superset of C#?",
      "created_at": "2019-07-26T23:06:32Z",
      "updated_at": "2019-07-26T23:06:32Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "@HumanEquivalentUnit \r\n\r\n> PowerShell could be a build scripting system for C# devs, but it wasn't originally made for that - is there a push to move it towards that?\r\n\r\nBuild scripts are just automation like everything else.  PowerShell wasn't built for creating chat bots either, doesn't mean it isn't great at it.\r\n\r\n>Would pushing PS towards C# devs raise its profile inside Microsoft?\r\n\r\nGetting more C# devs interested in PS is a net gain for everyone.  It means more contributions to the core product and more difficult to create third party projects popping up.\r\n\r\n> Assume a future where this push is a great success and it's now \"as easy as possible\" for C# devs, what else could we admin-scripty people expect to see in this future? Has PowerShell turned completely into a superset of C#?\r\n\r\nI'm not sure what you're implying.  Does borrowing a feature from C# make it harder to add unrelated features? If the concern is that resources were put into this, I think the scope of the change is being overestimated.  I don't want to speak for @daxian-dbw, but I would guess with pretty high confidence that this discussion has taken way more resources than actually writing the code.\r\n\r\n> PowerShell is already much much closer to C# than anything else the devs could be using, isn't it? Batch files, Bash, build systems made of XML, other scripting languages - except possibly [CAKE](https://cakebuild.net/) which is a C# DSL and PS will struggle to get closer than that. But they're still resisting dabbling in PowerShell because it's not enough like C# because of `?:` ? I assume that's actual feedback instead of speculation? What other changes would lower this bar further?\r\n\r\nThe way you describe it makes it sound like someone is getting into PS and then abandons everything when they see there's no ternary operator.  Instead the reality is that it would probably just make a decent chunk of folks a bit more comfortable.\r\n\r\nThe decision to give up looking into a language is often (in my experience) cumulative.  It's not often one thing that makes folks lose interest, but instead a sort of subconscious pros and cons list that adds up to a general feeling about the language.\r\n\r\n> > When C# developers (who like the ternary operator, I recognize there's a set who don't) use PowerShell, they're upset when the ternary operator isn't in PowerShell.\r\n>\r\n> It doesn't automatically follow that the fix should be \"put a ternary operator in PowerShell\". Different languages are different.\r\n\r\nIt does automatically follow that a discussion should be had about whether it has a place in PowerShell.  Languages are different, but they're also incredibly similar.\r\n\r\nRealistically there are plenty of things from other languages that you'll likely never see a PR for because it's objectively wrong for PowerShell.  For instance, I'm sure some devs hate that PowerShell is dynamically typed, but you'll never see the PS team advocating for static typing.\r\n\r\n> But if that is the fix .. I'm back to asking if there's a push to turn PowerShell completely into a superset of C#?\r\n\r\nI doubt it, but there's also not a push to keep features from C# out of PowerShell.   It's not a *particularly* difficult feature to implement and it (in my opinion) fits well in the language.  Just seems like an easy win to me.",
      "created_at": "2019-07-31T16:19:20Z",
      "updated_at": "2019-07-31T16:19:20Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I think we should stop the long cycle discussion (conslusion is clear) and go forward with the PR.",
      "created_at": "2019-08-01T04:42:03Z",
      "updated_at": "2019-08-01T04:42:03Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@daxian-dbw Maybe make sense to open new PR because here we have over 100 comment which is not related to _implementation details_.",
      "created_at": "2019-08-01T04:45:04Z",
      "updated_at": "2019-08-01T04:45:04Z"
    },
    {
      "author": "ThomasNieto",
      "author_association": "CONTRIBUTOR",
      "body": "Is there a reason why this new language feature was not introduced as a RFC?",
      "created_at": "2019-08-01T04:50:59Z",
      "updated_at": "2019-08-01T04:50:59Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "Now that the conclusion has been drawn, I will continue with the prototype and submit an RFC based on the prototype.",
      "created_at": "2019-08-01T18:06:56Z",
      "updated_at": "2019-08-01T18:06:56Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "Closing this draft PR. I will submit a ready-for-review PR shortly.",
      "created_at": "2019-08-15T18:18:29Z",
      "updated_at": "2019-08-15T18:18:29Z"
    }
  ],
  "created_at": "2019-07-15T17:03:40Z",
  "number": 10161,
  "state": "closed",
  "title": "Add support to ternary operator",
  "updated_at": "2019-08-15T18:18:29Z"
}