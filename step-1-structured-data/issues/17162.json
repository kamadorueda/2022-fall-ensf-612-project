{
  "_url": "https://github.com/PowerShell/PowerShell/issues/17162",
  "author": "thecliguy",
  "body": "### Summary of the new feature / enhancement\r\n\r\nUsing `Get-ChildItem`, can anyone advise whether it's possible to non-recursively list files where the directory is specified as a LiteralPath and the filename(s) returned must match a given string containing wildcards?\r\n\r\nThis is the closest I've managed to get:\r\n\r\n```powershell\r\nGet-ChildItem -LiteralPath \"C:\\Bitbucket\\Test\\foo[1-5]bar\" -Filter \"*.doc\" -File\r\n```\r\n\r\nThe `-Filter` parameter uses the FileSystem provider rather than PowerShell wildcards _(`Get-Help about_Wildcard`)_. PowerShell wildcards are well understood and it's unlikely that the syntax will ever change dramatically (or at least not in a breaking change way). Whereas, when relying on the FileSystem provider for filtering, although there are many similarities to PowerShell wildcards, PowerShell has no influence over its behaviour, you are completely at the mercy of .Net Core and this makes me feel it's a potentially risky proposition to use.\r\n\r\n_(The behaviour of `-Filter` has changed dramatically between Windows PowerShell and Powershell Core. To illustrate this, in Windows PowerShell if `C:\\Bitbucket\\Test\\foo[1-5]bar` contained both `.doc` and `.docx` files then `Get-ChildItem -LiteralPath \"C:\\Bitbucket\\Test\\foo[1-5]bar\" -Filter \"*.doc\" -File` would return files with both extensions, whereas this is not the case in PowerShell Core)_ \r\n\r\nHere are a couple of workarounds I've come up with... I'm not entirely sure if I'd trust the second option just in case there are any quirks or edge cases that I've failed to consider.\r\n\r\n```powershell\r\n################################################################################\r\n# WORKAROUND 1\r\n# Delegate responsibility for filtering to the Where method.\r\n(Get-ChildItem -LiteralPath \"C:\\Bitbucket\\Test\\foo[1-5]bar\" -File).Where({$_.name -like \"*.doc\"})\r\n################################################################################\r\n# WORKAROUND 2\r\n# Use Get-ChildItem with a non-literal path to take advantage of PowerShell's\r\n# wildcard filtering but before doing so, check that the directory path \r\n# \"literally\" exists, the filename is a value that can only be interpreted as a \r\n# file (not a directory) by ensuring that it does NOT contain any path \r\n# separators (\"\\\" or \"/\") and then escape the directory path.\r\n$DirectoryPath = \"C:\\Bitbucket\\Test\\foo[1-5]bar\"\r\n$Filename = \"*.doc\"\r\n\r\nIf (Test-Path -LiteralPath $DirectoryPath -Type Container) {\r\n    If (!($Filename.ToCharArray().Where({ ('\\', '/').contains([string]$_.ToString()) }))) {\r\n        $DirectoryPathEscaped = [Management.Automation.WildcardPattern]::Escape($DirectoryPath)\r\n        Get-ChildItem -Path \"$DirectoryPathEscaped\\$Filename\" -File\r\n    }\r\n}\r\n################################################################################\r\n```\r\n\r\n### Proposed technical implementation details (optional)\r\n\r\nI'd be delighted if someone could tell me of a way to achieve the result I want using nothing but `Get-ChildItem`, however if that's simply not possible at present then I'd like to ask the PowerShell team and the community to consider whether it would be feasible and desirable to add new functionality that (somehow) enables a user to modify the behaviour of `-Filter` so that it can \r\noperate using PowerShell wildcard filtering?\r\n\r\nCan anyone comment on whether the implementation of such a feature would theoretically offer performance benefits over using the `Where` method _(as shown in 'workaround 1')_ to perform filtering?",
  "closed_at": null,
  "comments": [
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> ### Summary of the new feature / enhancement\r\n> Using `Get-ChildItem`, can anyone advise whether it's possible to non-recursively list files where the directory is specified as a LiteralPath and the filename(s) returned must match a given string containing wildcards?\r\n\r\nI'm not sure if literalpath is a factor, but unless you expecting the path to contain characters which would be interpreted as Wildcards or escapes of some kind, I'd side step that and just use `Get-ChildItem \"C:\\DirA\\DirB\\*.doc\" -File` with path and wildcarded file name in one.  \r\n\r\n \r\n> if `C:\\DirA\\DirB` contained both `.doc` and `.docx` files then `Get-ChildItem -LiteralPath \"C:\\DirA\\DirB\" -Filter \"*.doc\" -File` would return both.\r\n\r\nThere is a difference between Windows PowerShell 5 (legacy, in-box and not updated via this repo) and PowerShell 7 (current, separate download, suggest changes here). \r\n\r\ncmd.exe matches on the short names (the internal 8.3 names needed by 16 bit programs which we can't run on 64 bit OSes),  try dir /x   and then do something like dir *~1.*  If you have any long names it will find them though normally you don't have ~1 in the name :-)  the extension is truncated at 3 characters so dir *.DOC in cmd matches on .docx. Someone will tell me I'm sure but I can't see how to get those names in PowerShell.  \r\n\r\nI tried to repro what you said, I have one DOC and many DOCX file in the root of my documents folder and \r\n`Get-Childitem -LiteralPath C:\\users\\me\\Documents\\ -Filter *.doc -File`  only returns the doc file but that was on PowerShell 7. When I fired up Windows PowerShell 5.1 - I get the same as you, i.e.  the filter reproduces cmd behaviour in 5 but not in 7 - probably because being cross platform there was no sense bring those things to linux, which was an excuse to call time on some of them for windows. \r\n\r\nOne of those links says file system provider sees \".*\" as \"any file extension including none\" and the wildcard wanting the name_with_any_extension to include a .  - this behaviour does seem to have stayed in 7.  Since directories traditionally didn't have extensions dir *. got just the directories, in pwsh 7 dir *. returns files ending in with \".\" and dir -filter *. gets the old directory listing. \r\n\r\n\r\n  \r\n\r\n\r\n",
      "created_at": "2022-04-19T14:58:09Z",
      "updated_at": "2022-04-19T14:58:09Z"
    },
    {
      "author": "thecliguy",
      "author_association": "NONE",
      "body": "@jhoneill Thanks for taking the time to respond. I probably should have devised a better example but in my use case the path to the directory is specified by the consumer and I want it to be interpreted as literal. I don't want PowerShell to attempt any wildcard expansion in the path to the directory, it should \"literally\" exist, else the command should fail.\r\n\r\n> I tried to repro what you said, I have one DOC and many DOCX file in the root of my documents folder and `Get-Childitem -LiteralPath C:\\users\\me\\Documents\\ -Filter *.doc -File` only returns the doc file but that was on PowerShell 7. When I fired up Windows PowerShell 5.1 - I get the same as you, i.e. the filter reproduces cmd behaviour in 5 but not in 7 - probably because being cross platform there was no sense bring those things to linux, which was an excuse to call time on some of them for windows.\r\n\r\nYou are quite right, this particular behaviour does only appear to be exhibited in PowerShell 5 but not in 7. That's a silly mistake on my part, I thought I had tested both versions but obviously not...\r\n\r\nIt's interesting and perhaps a little scary to see that the behaviour of `-Filter` has changed quite a bit between PowerShell 5 and 7... I'd be curious to know whether that's due to design changes within PowerShell _(unlikely because nothing mentioned in the docs)_ or whether the behaviour is entirely influenced by changes made in .Net Core...\r\n\r\nI suppose my original question still stands, would the PowerShell team and the community to consider it feasible and desirable to add new functionality that (somehow) enables a user to modify the behaviour of `-Filter` so that it can operate using PowerShell wildcard filtering? ",
      "created_at": "2022-04-19T17:44:06Z",
      "updated_at": "2022-04-19T17:44:06Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> It's interesting and perhaps a little scary to see that the behaviour of -Filter has changed quite a bit between PowerShell 5 and 7... I'd be curious to know whether that's due to design changes within PowerShell (unlikely because nothing mentioned in the docs) or whether the behaviour is entirely influenced by changes made in .Net Core...\r\n\r\nThe `-Filter` directly pass the search pattern to .NET APIs like `Directory.GetFiles(string path, string searchPattern)`, and it seems the behavior of that API has changed in .NET Core:\r\n```\r\nPS> dir C:\\arena\\tmp\\repro\\repro\\\r\n\r\n    Directory: C:\\arena\\tmp\\repro\\repro\r\n\r\nMode                 LastWriteTime         Length Name\r\n----                 -------------         ------ ----\r\n-a---           4/21/2022  2:59 PM              0 a.doc\r\n-a---           4/21/2022  3:00 PM              0 b.docx\r\n```\r\nFrom PowerShell 7.2 (.NET 6):\r\n```\r\nPS> [System.IO.Directory]::GetFiles(\"C:\\arena\\tmp\\repro\\repro\", \"*.doc\")\r\nC:\\arena\\tmp\\repro\\repro\\a.doc\r\nPS>\r\n```\r\nFrom Windows PowerShell 5.1:\r\n```\r\nPS> [System.IO.Directory]::GetFiles(\"C:\\arena\\tmp\\repro\\repro\", \"*.doc\")\r\nC:\\arena\\tmp\\repro\\repro\\a.doc\r\nC:\\arena\\tmp\\repro\\repro\\b.docx\r\nPS>\r\n```\r\n\r\n> I suppose my original question still stands, would the PowerShell team and the community to consider it feasible and desirable to add new functionality that (somehow) enables a user to modify the behaviour of -Filter so that it can operate using PowerShell wildcard filtering?\r\n\r\nThe purpose of having `-Filter` is for performance. Certain providers may have the filtering capability supported in its underlying component, and thus have better performance than the PowerShell wildcard globing. For the built-in providers, currently only the FileSystemProvider supports `-Filter` because .NET API can do this to some extent. Below is copied from the help content of `-Filter` parameter:\r\n> The filter string is passed to the .NET API to enumerate files. The API only supports * and ? wildcards.\r\n\r\nHere is an example for you to get a sense of the perf difference:\r\n\r\n```\r\n## Using PowerShell globing\r\nPS:49> Measure-Command { dir C:\\windows\\System32\\* }\r\n\r\nDays              : 0\r\nHours             : 0\r\nMinutes           : 0\r\nSeconds           : 0\r\nMilliseconds      : 798\r\nTicks             : 7984646\r\nTotalDays         : 9.24148842592593E-06\r\nTotalHours        : 0.000221795722222222\r\nTotalMinutes      : 0.0133077433333333\r\nTotalSeconds      : 0.7984646\r\nTotalMilliseconds : 798.4646\r\n\r\n## Using -Filter\r\nPS:50> Measure-Command { dir C:\\windows\\System32\\ -Filter * }\r\n\r\nDays              : 0\r\nHours             : 0\r\nMinutes           : 0\r\nSeconds           : 0\r\nMilliseconds      : 61\r\nTicks             : 619072\r\nTotalDays         : 7.16518518518519E-07\r\nTotalHours        : 1.71964444444444E-05\r\nTotalMinutes      : 0.00103178666666667\r\nTotalSeconds      : 0.0619072\r\nTotalMilliseconds : 61.9072\r\n```\r\n\r\nGiven that, making it do PowerShell wildcard globing will defeat its original purpose.\r\n",
      "created_at": "2022-04-21T22:17:17Z",
      "updated_at": "2022-04-21T22:17:17Z"
    },
    {
      "author": "thecliguy",
      "author_association": "NONE",
      "body": "@daxian-dbw Thank you for your response. \r\n\r\nJust to clarify, I'm not suggesting any changes be made to the default behaviour of `-Filter`. I was asking whether it would be possible to introduce some means whereby the user can enable `-Filter` to operate using PowerShell wildcards.\r\n\r\nIn order to non-recursively list files where the specified directory path should be treated as literal but the filename value should allow for wildcard expansion, do you think `Get-ChildItem` should make some provision for this? Or do you think it is better to just use one of the following workarounds? \r\n\r\n> ```powershell\r\n> ################################################################################\r\n> # WORKAROUND 1\r\n> # Delegate responsibility for filtering to the Where method.\r\n> (Get-ChildItem -LiteralPath \"C:\\Bitbucket\\Test\\foo[1-5]bar\" -File).Where({$_.name -like \"*.doc\"})\r\n> ################################################################################\r\n> # WORKAROUND 2\r\n> # Use Get-ChildItem with a non-literal path to take advantage of PowerShell's\r\n> # wildcard filtering but before doing so, check that the directory path \r\n> # \"literally\" exists, the filename is a value that can only be interpreted as a \r\n> # file (not a directory) by ensuring that it does NOT contain any path \r\n> # separators (\"\\\" or \"/\") and then escape the directory path.\r\n> $DirectoryPath = \"C:\\Bitbucket\\Test\\foo[1-5]bar\"\r\n> $Filename = \"*.doc\"\r\n> \r\n> If (Test-Path -LiteralPath $DirectoryPath -Type Container) {\r\n>     If (!($Filename.ToCharArray().Where({ ('\\', '/').contains([string]$_.ToString()) }))) {\r\n>         $DirectoryPathEscaped = [Management.Automation.WildcardPattern]::Escape($DirectoryPath)\r\n>         Get-ChildItem -Path \"$DirectoryPathEscaped\\$Filename\" -File\r\n>     }\r\n> }\r\n> ################################################################################\r\n> ```\r\n",
      "created_at": "2022-04-22T21:40:39Z",
      "updated_at": "2022-04-22T21:40:39Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> In order to non-recursively list files where the specified directory path should be treated as literal but the filename value should allow for wildcard expansion, do you think Get-ChildItem should make some provision for this? Or do you think it is better to just use one of the following workarounds?\r\n\r\nI agree it would be nice for `Get-ChildItem` to allow doing that with the PowerShell wildcards by itself, but it would likely be a non-trivial work with relatively high risk of regression given the complexity of the FileSystem provider. So, given that simple workarounds like `.Where(..)` and `... | Where-Object` exist, I don't think the value would justify the cost.",
      "created_at": "2022-04-23T00:04:33Z",
      "updated_at": "2022-04-23T00:04:33Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> I was asking whether it would be possible to introduce some means whereby the user can enable `-Filter` to operate using PowerShell wildcards.\r\n\r\nBy design, `-Filter` is transparently delegated to Provider and, in the case we discuss, FileSystem Provider delegates this to .Net.\r\n\r\nAnd by design, we already have wildcard (Regex) processing in PowerShell Provider Engine itself with `-Include` and `-Exclude`. But really they don't work in the scenario and we already have some registered issues for such scenarios.",
      "created_at": "2022-04-23T08:00:42Z",
      "updated_at": "2022-04-23T08:00:42Z"
    },
    {
      "author": "Hrxn",
      "author_association": "NONE",
      "body": "What am I missing here?\r\n\r\nThis example you give here:\r\n\r\n`Get-ChildItem -LiteralPath \"C:\\Bitbucket\\Test\\foo[1-5]bar\" -Filter \"*.doc\" -File`\r\n\r\nis working as intended...\r\n\r\nTo recapitulate, what you are trying to do, is matching both `.doc` and `.docx` files in that specific directory you picked with -LP?\r\n\r\nAs already pointed out `-Filter` uses the underlying .NET searchstring pattern for matching, and that has been changed some time ago from old legacy Windows matching, to the new, sane matching with correct globbing patterns.\r\n\r\nThis seems to work for me:\r\n`[System.IO.Directory]::GetFiles('D:\\Temp\\Test', '*.doc?')`\r\n\r\nTherefore `-Filter '*.doc?'` would work as well.",
      "created_at": "2022-05-01T16:52:53Z",
      "updated_at": "2022-05-01T16:54:35Z"
    }
  ],
  "created_at": "2022-04-19T12:50:35Z",
  "labels": [
    "Issue-Enhancement",
    "WG-Engine-Providers",
    "Needs-Triage",
    "Area-FileSystem-Provider"
  ],
  "number": 17162,
  "state": "open",
  "title": "Non-Recursive Listing of Files Where the Directory is Specified as a LiteralPath and the Filename Contains Wildcards ",
  "updated_at": "2022-05-01T16:54:35Z"
}