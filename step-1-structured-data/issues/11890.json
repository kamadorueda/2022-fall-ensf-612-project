{
  "_url": "https://github.com/PowerShell/PowerShell/issues/11890",
  "author": "theJasonHelmick",
  "body": "# Summary of the new feature/enhancement\r\n\r\nText Effects (font customization) allow you to place emphasis on text to lower or raise awareness to\r\nthe user and improve data comprehension. They include, but not limited to, foreground and background\r\ncolors, bold, highlighting, strikethrough, and blinking.\r\n\r\nPowerShell should support Text effects in views and interactive sessions for data\r\ncomprehension and Accessibility. PowerShell should support, as most modern terminals, 24-bit True\r\nColor.  Below are two scenario's for this need:\r\n\r\nAs a PowerShell user, I want to interactively use Text Effects for reporting and color emphasis. For\r\nexample, when a value exceeds defined limits to enhance data comprehension.\r\n\r\nAs a PowerShell Module builder, I want to take advantage of Text Effects for colorization, and\r\ncreate views for cmdlets to aid in data comprehension and overall Accessibility.\r\n\r\n# Proposed technical implementation details (optional)\r\n\r\nFor PowerShell users, Text Effects can be set in interactive sessions with calculated properties for\r\nthe purpose of accenting data with specific defined results. A new attribute `texteffect`, that is\r\nabbreviated `t`, follows the previous pattern for `alignment` (al) and avoids contention.\r\n\r\n```powershell\r\nGet-Service -Name bits | Select-Object -Property Name, @{n='State';e={$_.status};t={...}}\r\n```\r\n\r\nFor advanced module builders, Text Effects may be added to the formatting system PowerShell\r\ncurrently has in place. A new xml tag **TextEffect** will contain a script block.\r\n\r\n```powershell\r\n<TableControl>\r\n  <TableHeaders>\r\n    <TableColumnHeader>\r\n      <Label>AvailableSpace</Label>\r\n      <Width>7</Width>\r\n      <Alignment>right</Alignment>\r\n    </TableColumnHeader>\r\n  </TableHeaders>\r\n\r\n  <TableRowEntries>\r\n    <TableRowEntry>\r\n      <TableColumnItems>\r\n        <TableColumnItem>\r\n          <ScriptBlock>[String]($_.Freespace / 1024)</ScriptBlock>\r\n          <TextEffect>if ( $_.Freespace/1024 -lt 100mb ) { \"red\" }</TextEffect>\r\n         </TableColumnItem>\r\n      </TableColumnItems>\r\n    </TableRowEntry>\r\n  </TableRowEntries>\r\n</TableControl>\r\n```\r\n\r\n",
  "closed_at": "2020-12-14T20:21:48Z",
  "comments": [
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I like this idea quite a bit.\r\n\r\nI do, however, question the priority... format files requiring XML is quite cumbersome. The C# APIs, in comparison, are quite easy to work with internally. \r\n\r\nCan we perhaps also look at exposing those APIs to powershell users in some fashion so that we can define formats in _script_ rather than just in XML?",
      "created_at": "2020-02-19T22:36:15Z",
      "updated_at": "2020-02-19T22:36:15Z"
    },
    {
      "author": "ThomasNieto",
      "author_association": "CONTRIBUTOR",
      "body": "I like this idea of adding color to output based on a condition. The only consideration I can think of is changing the color based on color blindness and where the color chosen will not work well with non-default console background color. It falls into a wider concern of color themes for PowerShell. \n\nThis https://github.com/PowerShell/PowerShell-RFC/pull/241 RFC proposes a DSL for creating formatting definitions without using XML.",
      "created_at": "2020-02-20T00:51:54Z",
      "updated_at": "2020-02-20T00:51:54Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> I do, however, question the priority... format files requiring XML is quite cumbersome. The C# APIs, in comparison, are quite easy to work with internally.\r\n\r\nWriting the XML is also quite easy to work with *assuming* you go through the sort of tedious steps of setting up schema support from #7749.  I wonder if shipping those settings as an extension would be a workable middle group for the time being.\r\n\r\nSomething to consider anyway, I'm *definitely not* saying those API's shouldn't be exposed or that a DSL shouldn't be created. ",
      "created_at": "2020-02-21T14:20:45Z",
      "updated_at": "2020-02-21T14:20:45Z"
    },
    {
      "author": "JamesWTruher",
      "author_association": "MEMBER",
      "body": "I've got this prototyped not in xml, but via `format-table -property $properties`\r\n```\r\n$props = @{ L = \"UnixMode\"     ;E={$_.unixmode}      ;TEXTEFFECT={if ( $_.unixmode -match \"^d\" ) { \"44\" } }; W = 10},\r\n@{ L = \"User\"         ;E={$_.user}          ;T={if ( $_.user -match \"jimtru\" ) { \"7\" }}; W = 16},\r\n@{ L = \"Group\"        ;E={$_.Group}         ;T={if ( $_.user -match \"root\" ) { \"41;1;33\" }}; W = 18},\r\n@{ L = \"LastWriteTime\";E={$_.lastwritetime} ;T={if ( $_.lastwritetime -lt \"1/1/2020\" ) { \"4;1;36\" } }; W = 20 ; F = \"{0:MM}/{0:dd}/{0:yyyy} {0:hh}:{0:mm}\" },\r\n@{ L = \"Size\"         ;E={$_.size}          ;T={if ( $_.size -gt 100kb ) { \"1;41;33\" } elseif ( $_.size -gt 10kb ) { \"1;31\" } }; W = 10 },\r\n@{ L = \"Name\"         ;E={$_.name}          ;T={if ( $_.Name -match \"^a\" ) { \"31\" } elseif ( $_.Name -match \"^b\" ) { \"1;35\" } elseif ( $_.Name -match \"readme\" ) { \"5\" } else { \"1;34\"} }}\r\n```\r\nwhich renders to this (note that one of the filenames is blinking :) :\r\n![Screen Shot 2020-02-26 at 12 20 49 PM](https://user-images.githubusercontent.com/10214008/75384229-98306780-5892-11ea-8ac9-3bc2b61744f9.png)\r\n\r\nI see a DSL for formatting as something orthogonal, I can't see supporting colors without using our current configuration mechanisms",
      "created_at": "2020-02-26T20:23:22Z",
      "updated_at": "2020-02-26T20:24:48Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "I think the proposal to do color via formatting and the format commands makes a lot of sense, but ...\r\n\r\n## First: Let's get this out of the way: please don't support blink. \r\n\r\nThankfully, many terminals won't support it anyway. But there's a reason that was deprecated from HTML. \r\n\r\nWhen I worked on this, I actually left off the text effects (underline, bold, strikethrough, _and_ blinking). I think _underline is the only one that's supported in most terminals_ anyway (terminals treat \"bold\" as a \"bright\" modifier for the _color_ --which only affects the base 8 colors-- not as a font modifier, since they're designed to be used with bitmap fonts). So I just decided it was not worth the effort for my prototype to support underlining.\r\n\r\n\r\n## Second, there's a usability need\r\n\r\n@theJasonHelmick's example is too simple (is that foreground or background red? And remember that over on Linux (or in Windows Terminal) they don't call it \"Red\" and \"DarkRed\" it's \"BrightRed\" and \"Red\" ...\r\n```powershell\r\nif ( $_.Freespace/1024 -lt 100mb ) { \"red\" }\r\n```\r\n\r\n@JamesWTruher's example is too obscure. I think if we're going to write escape sequences, you're not helping enough, and we might as well just keep writing them the way we are now (e.g. [devblackops/Terminal-Icons](https://github.com/devblackops/Terminal-Icons)).\r\n```powershell\r\nif ( $_.size -gt 100kb ) { \"1;41\" }\r\n```\r\n\r\nMy proposal (obviously) is that we should bring in the code I wrote to prototype this stuff for #2381 (wow, 8000 issues ago?). Basically, we should expose:\r\n1. An `RgbColor` class for full color support\r\n2. A variable/provider syntax for foreground vs background colors, so instead of writing `\"red\"` or `\"1;31\"` or `\"1;41\"` you can write `$fg:red` or `$bg:red` or `$bg:ee0518` or even `$fg:firebrick` (remember the color pallette names?)\r\n3. A similar provider syntax for additional formatting (e.g. underline, inverse?) \r\n\r\nThat way you have discoverability!  E.g. you can get a list of them (In the 256 color model, there about 76 reds plus 44 magentas):\r\n![image](https://user-images.githubusercontent.com/192942/75577167-6d2f4a80-5a2f-11ea-8979-0ba8132edfd7.png)\r\n\r\nWe could alter that a bit, and make the _provider_ a \"text effect\" and the drive \"text\" and make \"background\" (and \"bg\") and \"foreground\" (and \"fg\") as folders, so you could `Write-Host \"${text:fg\\red}${text:bg\\white}${text:underline}Hello World\"` or use _that_ in the format files and cmdlets ... or we could make it castable: `[TextEffect]@{ fg = \"red\"; bg = \"white\"; underline = $true}` or ... whatever. **My point** is that I think PowerShell deserves a more user-friendly model than just VT sequences (which we can already use, and which don't help with accessibility).\r\n\r\n## Thirdly:  There's an accessability need\r\n\r\nThe _whole point_ of supporting this as a _separate_ entity in the formatting **should be** that a user can set a preference variable (e.g. `$PSColorSupport`) which allows something like: `Full` or `None` or `HighContrast` -- where the formatting engine would ensure that dark foreground colors were shifted to light colors (perhaps to the nearest 8 \"bright\" console colors, so the user can at least specify a theme), and the background was always black... \r\n\r\nThe code I wrote doesn't support _that_ preference variable yet, but I did write the color model to support forcing colors to the nearest match in a specified color palette.\r\n\r\nDid I mention not supporting blink?\r\n\r\n## Fourthly: About backward compatibility\r\n\r\nI assume that any module that uses this in it's formatting file will have to ship PS5-specific format files.\r\n\r\nIf there's any way that we can make the formatting engine _warn on import_, but ignore elements it doesn't recognize, instead of blowing up, that would be really nice, and future you will thank past me for thinking of it \ud83d\ude09\ud83d\ude01",
      "created_at": "2020-02-28T18:39:58Z",
      "updated_at": "2020-02-28T18:39:58Z"
    },
    {
      "author": "theJasonHelmick",
      "author_association": "CONTRIBUTOR",
      "body": "@Jaykul I really appreciate the detail of your thoughts and appreciate your time.  Let me start by saying that we are very early days in investigating colorization and text effects.  Just so I can clarify for everyone, this means that nothing is \u2018on\u2019 or \u2018off\u2019 the table at this time in our thinking process- we are open to all discussions and ideas.\r\n\r\nJakul, let me briefly respond to your 4 main points directly here. \r\n\r\nFirst:  In regards to blink and other specific effects. Just in general, we intend to follow the Accessibility guidance that we are given.  I will start that process a little further down the road and report back here - but your point about blink was noted ;)\r\n\r\nSecond:  Yes, the examples in this early stage or simplified, and do not show any tooling or additional support. To your point about the syntax and coloring, we are looking at ways to simplify this, maybe  a `color-picker`?  - but nothing defined yet.  That doesn\u2019t mean I disagree with your suggestion in anyway, just not there yet. Your point that PowerShell deserves a more friendly model than just VT seq is understood and noted.\r\n\r\nThird: Accessibility is a major part to this focus.  I agree with your view but we haven\u2019t moved to those discussions yet. \r\n\r\nFourth: Regarding backward compat - I see your point.  As we get further into implementation we will be able to address those concerns more clearly.\r\n\r\nThanks Jakul for taking the time to respond. \r\n",
      "created_at": "2020-03-25T20:27:15Z",
      "updated_at": "2020-03-25T20:27:15Z"
    },
    {
      "author": "theJasonHelmick",
      "author_association": "CONTRIBUTOR",
      "body": "For anyone that wishes to explore some of these ideas, I'm including some instructions here.  \r\nTo test, you will need Jim Truher's Github repo and branch:\r\n\r\n- Fork: https://github.com/JamesWTruher/PowerShell-1\r\n- Checkout Branch: **FormatWithAttributes**\r\n- Build (Will get PS 6.0 Alpha)\r\n  - `Import-Module .\\build.psm1`\r\n  - `Start-PSBootstrap`\r\n  - `Start-PSBuild`\r\n  - `&(get-psoutput)`\r\n\r\nI then created a simple function, you can make your own, but here is mine:\r\n`\r\nfunction Get-Dir {\r\n\r\n    dir | ft UnixMode,User,Group,\r\n        @{N=\"LastWriteTime\";E={$_.LastWriteTime};T = {\r\n            if ($_.lastwritetime -lt \"1/1/2020\"){\"36;4\"} }},Size,\r\n        @{N =\"Name\"; T = { if ($_.extension -eq \".md\") {\"31;1\"}}; E={$_.Name}}\r\n}\r\n`\n\n<blockquote><img src=\"https://avatars2.githubusercontent.com/u/10214008?s=400&v=4\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicon.ico\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/JamesWTruher/PowerShell-1\">JamesWTruher/PowerShell-1</a></strong></div><div>PowerShell for every system. Contribute to JamesWTruher/PowerShell-1 development by creating an account on GitHub.</div></blockquote>",
      "created_at": "2020-03-25T20:30:08Z",
      "updated_at": "2020-03-25T20:30:11Z"
    },
    {
      "author": "StartAutomating",
      "author_association": "NONE",
      "body": "I think the heart of the proposal is in the right place, and the suggested implementation _is not_ the right approach.\r\n\r\n# Recognizing the Breadth of the Need\r\n\r\nAs suggested, this fix addresses a very slim subsection of the need.  It allows you to color a particular column.  Surely this isn't _all we want_.\r\n\r\nIf we look at the formatters more broadly, we can format any object any way we'd like.  What we're hoping to do is to allow for more advanced colorization and interactivity.  To that end, having a rule that just returns a color in the XML ignores a lot of scenarios.   What if I wanted to make it Bold or Underlined?  What if it were a link and I'd like to render as such in a webpage or notebook?  What if I wanted to be able to make my tables markdown tables?  What if I wanted to display text in a grid?  What if I wanted to justify it?\r\n\r\nYou hopefully are getting the point.  This idea is nifty and all, but it's hardly all we want to do, even if we are limiting it to \"text effects\".  Given that the formatter can also produce things that are not text (e.g. you can have a formatter that writes XAML, or feeds data to a UI), even having the issue title as simple as \"Attributing Text Effects\" is inherently limiting.\r\n\r\nI'd suggest a more appropriate title would be \"Enhancing Formatting\".\r\n\r\n# Leveraging the formatting engine as it exists\r\n\r\nSince we cannot make changes to the format schema without breaking formatting for down-level versions, it makes the most sense to leverage the formatting subsystem within PowerShell now.\r\n\r\nA few major capabilities are worth highlighting:\r\n* You can override the display of any property with a ScriptBlock.  This can be used to support colorization directly within a table, including the above HeatMap example.\r\n* Custom formatters can do almost anything, and already have the concept of a \"Control\" \r\n* Controls can also be used to display a group header on a given set of formatters\r\n\r\nTo give a couple of practical examples, here are some screenshots of formatting built with [EZOut](https://github.com/StartAutomating/EZOut):\r\n\r\nHere's a Process HeatMap:\r\n![Process Heatmap](https://github.com/StartAutomating/EZOut/raw/master/Assets/Process.Heatmap.gif)\r\n\r\nHere's colorized XML:\r\n![Colorized XML](https://github.com/StartAutomating/EZOut/raw/master/Assets/ColorizedXml1.gif)\r\n\r\nHere's a file tree formatter:\r\n![File Trees](https://github.com/StartAutomating/EZOut/raw/master/Assets/FileTreeFormatter.gif)\r\n\r\nAnother module I wrote for RegEx ([Irrregular](https://github.com/StartAutomating/Irregular) uses EZOut to build syntax highlighting for RegEx:\r\n\r\n![Regex Syntax Highlighter](https://github.com/StartAutomating/Irregular/raw/master/Assets/RegexSyntaxHighlighting.gif)\r\n\r\nTo give a much crazier example of what you can do with formatters, I point you to [PowerArcade](https://github.com/StartAutomating/PowerArcade) (which is built using EZOut):\r\n\r\n![Nibbles2020](https://github.com/StartAutomating/PowerArcade/raw/master/Assets/Nibbles2020.2.gif)\r\n\r\nThis formatting will work in any PowerShell where $host.SupportsVirtualTerminal.\r\n\r\nThus I believe that we can accomplish this scenario in a way that works for every PowerShell user, not just for Core.  Furthermore, we have the opportunity to solve this scenario in ways that are more forward-looking than simply tweaking a table.\r\n\r\n# How EZOut does it\r\n\r\nIt's only been fairly recently that I've dusted off EZOut and began adding advanced formatting scenarios.\r\n\r\nTo get colorized properties in Tables and Lists, I create a -VirtualProperty in a formatter that prepends the text with colorization and appends text that clears the colorization.\r\n\r\nOriginally, I did this inline, which made the formatter files get larger than I would like.\r\n\r\nI've since switched to using a \\Parts subdirectory, which contains little script files they can use to directly style.  The used \\Parts are then placed in the .format.ps1xml, and loaded as a side-module when the formatter first needs them.\r\n\r\nWith this in hand, I can write formatters that change colors dynamically within the same control, by using code in my formatter like . $SetOutputStyle -ForegroundColor '#ff0000' -Bold -Underline ; 'My Red output'; . $clearOutputStyle\r\n\r\nWhile this has expanded _a lot_ in terms of capability (e.g. bolding, underline, and dual-mode formatting (ANSI/HTML)), it's not yet as elegant and discoverable as I tend to like PowerShell to be.\r\n\r\n# A More Elegant Suggestion and an underused verb\r\n\r\nAfter much reflection, I think the _right_ move here is to create a set of advanced formatting commands, for instance:\r\n\r\n~~~\r\n# Formats text in RED\r\nFormat-RichText -ForegroundColor '#ff0000' -Content \"My Red Output\"\r\n~~~\r\n\r\nOr:\r\n\r\n~~~\r\n# Formats a value into a heatmap.  Hot and Cool are the color when -ge maximum or -le minimum, respectively.  Values in between will have a color between these two points.\r\nFormat-HeatMap -Value 5 -Min 3 -Max 7 -Hot '#ff0000' -Cool '#00ff00'\r\n~~~\r\nThis would be more discoverable than the example above, and, gives us a forward-looking way to present things.  If there's any way we'd like to write fancy output for a given object, we can use Format-X to do so.\r\n\r\nWe could either produce an additional module of fancy formatting that can ship to all versions of PowerShell, or more and more of this functionality can be added to EZOut, with more and more demos on how to use it interactively.\r\n\r\nEither way, if we decide to meet this need by providing a module full of Format- commands, we get the following benefits:\r\n\r\n* Backwards compatibility\r\n* Extending the formatting engine without moving heaven and hearth\r\n* Potentially Multi-platform output\r\n* Ease of discoverability\r\n* Ease of interactive use\r\n",
      "created_at": "2020-05-01T18:15:46Z",
      "updated_at": "2020-05-01T18:15:46Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "Fixed via https://github.com/PowerShell/PowerShell/pull/13758",
      "created_at": "2020-12-14T20:21:47Z",
      "updated_at": "2020-12-14T20:21:47Z"
    }
  ],
  "created_at": "2020-02-19T20:22:51Z",
  "number": 11890,
  "state": "closed",
  "title": "Attributing Text Effects",
  "updated_at": "2020-12-14T20:21:48Z"
}