{
  "_url": "https://github.com/PowerShell/PowerShell/issues/15856",
  "author": "jantari",
  "body": "### Prerequisites\n\n- [X] Write a descriptive title.\n- [X] Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\n- [X] Search the existing issues.\n- [X] Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\n- [X] Refer to [Differences between Windows PowerShell 5.1 and PowerShell](https://docs.microsoft.com/powershell/scripting/whats-new/differences-from-windows-powershell).\n\n### Steps to reproduce\n\n# LOCAL - works:\r\n\r\n    $alldirectories = [System.Collections.Generic.List[string]]::new()\r\n    $AllDirectories = [System.IO.Directory]::GetDirectories(\"C:\\AnEmptyDir\", \"*\", 1)\r\n    \r\n    $AllDirectories.Count\r\n    0\r\n    \r\n    $AllDirectories.GetType()\r\n    \r\n    IsPublic IsSerial Name                                     BaseType\r\n    -------- -------- ----                                     --------\r\n    True     True     List`1                                   System.Object\r\n\r\n\r\n# REMOTE - doesn't work:\r\n\r\n    $AllDirectories = [System.Collections.Generic.List[string]]::new()\r\n    $AllDirectories = Invoke-Command computer01 -Credential $cred -ScriptBlock { [System.IO.Directory]::GetDirectories(\"C:\\AnEmptyDir\", \"*\", 1) }\r\n    \r\n    $AllDirectories.count\r\n    0\r\n    \r\n    $AllDirectories.GetType()\r\n    InvalidOperation: You cannot call a method on a null-valued expression.\r\n\r\n\n\n### Expected behavior\n\n```console\n$AllDirectories.Insert(0, 'MyFunnyString')\r\n# no output - string is added to collection at index 0\n```\n\n\n### Actual behavior\n\n```console\n$AllDirectories.Insert(0, 'MyFunnyString')\r\nInvalidOperation: You cannot call a method on a null-valued expression.\n```\n\n\n### Error details\n\n```console\nException             :\r\n    Type        : System.Management.Automation.RuntimeException\r\n    ErrorRecord :\r\n        Exception             :\r\n            Type    : System.Management.Automation.ParentContainsErrorRecordException\r\n            Message : You cannot call a method on a null-valued expression.\r\n            HResult : -2146233087\r\n        CategoryInfo          : InvalidOperation: (:) [], ParentContainsErrorRecordException\r\n        FullyQualifiedErrorId : InvokeMethodOnNull\r\n        InvocationInfo        :\r\n            ScriptLineNumber : 1\r\n            OffsetInLine     : 1\r\n            HistoryId        : -1\r\n            Line             : $AllDirectories.Insert(0, 'MyFunnyString')\r\n            PositionMessage  : At line:1 char:1\r\n                               + $AllDirectories.Insert(0, 'MyFunnyString')\r\n                               + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n            CommandOrigin    : Internal\r\n        ScriptStackTrace      : at <ScriptBlock>, <No file>: line 1\r\n    TargetSite  : System.Object CallSite.Target(System.Runtime.CompilerServices.Closure, System.Runtime.CompilerServices.CallSite, System.Object, Int32, System.String)\r\n    Message     : You cannot call a method on a null-valued expression.\r\n    Data        : System.Collections.ListDictionaryInternal\r\n    Source      : Anonymously Hosted DynamicMethods Assembly\r\n    HResult     : -2146233087\r\n    StackTrace  :\r\n   at CallSite.Target(Closure , CallSite , Object , Int32 , String )\r\n   at System.Dynamic.UpdateDelegates.UpdateAndExecute3[T0,T1,T2,TRet](CallSite site, T0 arg0, T1 arg1, T2 arg2) in System.Linq.Expressions.dll:token 0x6001066+0x128\r\n   at System.Management.Automation.Interpreter.DynamicInstruction`4.Run(InterpretedFrame frame) in System.Management.Automation.dll:token 0x6004d51+0x0\r\n   at System.Management.Automation.Interpreter.EnterTryCatchFinallyInstruction.Run(InterpretedFrame frame) in System.Management.Automation.dll:token 0x6004d01+0x0\r\nCategoryInfo          : InvalidOperation: (:) [], RuntimeException\r\nFullyQualifiedErrorId : InvokeMethodOnNull\r\nInvocationInfo        :\r\n    ScriptLineNumber : 1\r\n    OffsetInLine     : 1\r\n    HistoryId        : -1\r\n    Line             : $AllDirectories.Insert(0, 'MyFunnyString')\r\n    PositionMessage  : At line:1 char:1\r\n                       + $AllDirectories.Insert(0, 'MyFunnyString')\r\n                       + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n    CommandOrigin    : Internal\r\nScriptStackTrace      : at <ScriptBlock>, <No file>: line 1\n```\n\n\n### Environment data\n\n```powershell\nName                           Value\r\n----                           -----\r\nPSVersion                      7.2.0-preview.8\r\nPSEdition                      Core\r\nGitCommitId                    7.2.0-preview.8\r\nOS                             Microsoft Windows 10.0.19043\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\n```\n\n\n### Visuals\n\n_No response_",
  "closed_at": "2021-08-03T15:18:27Z",
  "comments": [
    {
      "author": "jantari",
      "author_association": "NONE",
      "body": "My problem is, I have the following snippet in a production script and it throws a `InvalidOperation: You cannot call a method on a null-valued expression.` error on the `$AllDirectories.Insert(0, $LocalSharePath)` line when the directory referred to by `$LocalSharePath` does not have any subdirectories. I have thought about it for a while but I'm not sure what I'm supposed to do to handle this in a somewhat elegant manner.\r\n\r\n```powershell\r\n$LocalSharePath = 'E:\\whatever\\some\\directory'\r\n[System.Collections.Generic.List[string]]$AllDirectories = @()\r\n\r\ntry {\r\n    [System.Collections.Generic.List[string]]$AllDirectories = Invoke-Command -Session $FileServerSession {\r\n        # https://docs.microsoft.com/en-us/dotnet/api/system.io.directory.getdirectories?view=netframework-4.7.2\r\n        # public static string[] GetDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);\r\n        [System.IO.Directory]::GetDirectories(\"$using:LocalSharePath\", \"*\", 1)\r\n    } -ErrorAction Stop\r\n}\r\ncatch {\r\n    Write-Error $_\r\n    Write-Error \"Falling back to slower directory enumeration ...\"\r\n    [System.Collections.Generic.List[string]]$AllDirectories = Invoke-Command -Session $FileServerSession {\r\n        Get-ChildItem -LiteralPath $using:LocalSharePath -Recurse | Where-Object { $_.PSIsContainer } | Select-Object -ExpandProperty FullName\r\n    }\r\n}\r\n\r\n# Add the root directory itself to the list of directories to go through\r\n$AllDirectories.Insert(0, $LocalSharePath)\r\n```\r\n\r\nEDIT: As you can see I am even explicitly casting/coercing/type-ensuring `[System.Collections.Generic.List[string]]` for `$AllDirectories` again in both the `Invoke-Command` lines - so I have no idea how I am getting `$null` back to be honest.",
      "created_at": "2021-08-02T13:56:21Z",
      "updated_at": "2021-08-02T14:00:49Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "This is less to do with `Invoke-Command` specifically and more about how objects are enumerated to the pipeline from a command.\r\n\r\nFor instance you'll see the same behavior with just wrapping `GetDirectories()` in a scriptblock:\r\n\r\n```powershell\r\n[System.Collections.Generic.List[string]] $AllDirectories = @()\r\n\r\n# Direct method invocation does not enumerate and `GetDirectories` returns an empty\r\n# array, so this is similar to `$AllDirectories = @()`\r\n$AllDirectories = [System.IO.Directory]::GetDirectories(\"emptydir\", \"*\", 1)\r\n$null -eq $AllDirectories\r\n# False\r\n\r\n# Wrapping in `& { }` causes output to go through a pipeline.  Empty arrays have\r\n# no items to emit, so this is similar to `$AllDirectories = $null`\r\n$AllDirectories = & { [System.IO.Directory]::GetDirectories(\"emptydir\", \"*\", 1) }\r\n$null -eq $AllDirectories\r\n# True\r\n```\r\n\r\nIn the latest PowerShell you can handle this pretty easily with the following syntax:\r\n\r\n```powershell\r\n$AllDirectories = & { [System.IO.Directory]::GetDirectories(\"emptydir\", \"*\", 1) }\r\n\r\n# If null, then assign `@()`\r\n$AllDirectories ??= @()\r\n```\r\n\r\nOr wrap in `@()`\r\n\r\n```powershell\r\n$AllDirectories = @(& { [System.IO.Directory]::GetDirectories(\"emptydir\", \"*\", 1) })\r\n```",
      "created_at": "2021-08-02T16:34:21Z",
      "updated_at": "2021-08-02T16:34:21Z"
    },
    {
      "author": "jantari",
      "author_association": "NONE",
      "body": "Okay, so that helps me understand what's happening better.\r\n\r\nThe workaround syntax of wrapping it in `@()` is problematic for readability of course as `Invoke-Command` calls usually span multiple lines (assuming an inline scriptblock like in my example above) amd I'm not a fan of the extra paranthesis/indentation required.\r\n\r\nThinking of it as C# I understand that any nullable type is going to be nulled by an expression that essentially evaluates like `[System.Collections.Generic.List[string]]$list = $null`, no matter what I try to cast/coerce to on the left side of the assignmnent, I guess it was just unexpected in PowerShell to me.\r\n\r\nEDIT: In case someone else finds this and is looking for a way to fail early on null-assignment, I suggest this:\r\n\r\n    [ValidateNotNull()][System.Collections.Generic.List[string]]$list = & { [System.IO.Directory]::GetDirectories(\"C:\\emptydir\", \"*\", 1) }",
      "created_at": "2021-08-03T15:18:27Z",
      "updated_at": "2021-08-03T15:20:53Z"
    }
  ],
  "created_at": "2021-08-02T13:52:15Z",
  "labels": [
    "Resolution-By Design",
    "Resolution-Answered"
  ],
  "number": 15856,
  "state": "closed",
  "title": "`Invoke-Command` overwrites collection variable with `$null` value if it returns nothing",
  "updated_at": "2021-08-03T15:20:53Z"
}