{
  "_url": "https://github.com/PowerShell/PowerShell/issues/9244",
  "author": "mklement0",
  "body": "Note: \r\n* This issue is meant to supersede #8158 and #6833 and #10682 .\r\n\r\n---\r\n\r\nFrom the committee decision at https://github.com/PowerShell/PowerShell/pull/8587#issuecomment-477375667:\r\n\r\n> Filesystem accepting both `/` and `\\` on all systems is an explicit cross platform experience decision for PowerShell.\r\n\r\nGiven that it's currently impossible on Unix-like platforms - where `\\` is a legal filename character - to access or wildcard-match filenames with embedded `\\` chars., the following fixes are needed:\r\n\r\n* Wildcard matching must able to match `\\` chars., namely via `?` or `*` or `[\\]`.\r\n  * Note that inside `[...]`, `\\` shouldn't require escaping, analogous to `[.]` matching a _literal_ `.` in a regex. \r\n\r\n* `-Path` and `-LiteralPath` arguments must support `` ` ``-escaping of `\\` chars. to request their literal treatment.\r\n\r\n* The `.PS*` provider property values (`.PSPath`, `.PSParentPath`, `.PSChildName`) must reflect the _escaped_ path.\r\n\r\n* To-native-path conversions such as with `Convert-Path` must remove the escaping.\r\n\r\n* Native globbing must not break if a wildcard pattern happens to match a filename that contains `\\`.\r\n\r\nNote: \r\n\r\n* Even the above doesn't address the awkwardness of the - unescaped - `.FullName` value of `System.IO.FileSystemInfo` _not_ being directly usable with the filesystem provider; e.g., with the provider bug fixed, something like `(Get-ChildItem \"$HOME/a\\b\").FullName` would return something like `/Users/jdoe/a\\b` - unescaped.\r\n\r\n* Similarly, native paths from outside sources with embedded `\\` - e.g., read from a file - will break in PowerShell commands, unless explicit escaping with ``-replace '`', '\\`'`` is performed.\r\n\r\n* `` ` `` as the escape char. means that it requires _doubling_ inside `\"...\"`  and therefore also in _unquoted_ arguments in order to be passed through; i.e., the following calls would be equivalent and match a file literally named `a\\b`:\r\n\r\n```powershell\r\nGet-Item 'a`\\b'\r\nGet-Item \"a``\\b\" # !! \r\nGet-Item a``\\b # !! implicitly treated like a \"...\" string\r\n```\r\n\r\n* Handling `` ` `` instances that precede a char. _other_ than `\\` gets quite tricky:\r\n\r\n  * Literal paths: So as not to break the existing ability to match `` ` `` literally in paths, `` ` `` must be special only before `\\` and before `` ` `` itself. This follows the model of `\\` use in double-quoted strings in Bash, but introduces the awkwardness of needing to interpret `` 'a`b' `` and `` 'a``b' `` the same (similar to how `\"a\\b\"` and `\"a\\\\b\"` are equal in Bash).\r\n\r\n  * Wildcard paths: Wildcard matching itself _always_ requires doubling of `` ` `` for literal use; e.g., \r\n``'a`b' -like  'a`b'`` is `$false`, and only ```'a`b' -like  'a``b'``` is `$true` (edge case: `` 'a`' -like  'a`' `` is also `$true` - the trailing syntactically incomplete use of `` ` `` is interpreted as a literal).\r\n     * However, use of wildcards _with the filesystem provider_:\r\n         * currently makes `` Get-Item -Path 'a`b' `` match a file literally named `` a`b ``, even though it shouldn't.\r\n        * currently doesn't find a match with `` Get-Item -Path 'a``b' `` and neither with `` Get-Item -Path 'a``?' ``, even though it should.\r\n     * In other words: wildcard handling by the filesystem provider is currently _broken_ - this may be related to #7999.\r\n     * While _falling back_ to literal interpretation is perhaps useful, especially given that `-Path` is the default parameter, this should be fixed, separately.\r\n\r\n# Steps to reproduce\r\n\r\nOn macOS or Linux, run the following Pester tests:\r\n\r\n```powershell\r\n# Note: -Skip isn't yet supported at the level of Describe and Context blocks.\r\n#        See https://github.com/pester/Pester/issues/442\r\nif ($env:OS -eq 'Windows_NT') {\r\n  Write-Warning \"Tests apply to Unix-like platforms only\" }\r\nelse {\r\n  Describe \"Support for backslashes in Unix filenames\" {\r\n    BeforeAll  {\r\n      Push-Location TestDrive:\\\r\n      # File with literal backslash in its name.\r\n      touch 'a\\b'\r\n      $nativePath = ($PWD.ProviderPath -replace '/$') + '/' + 'a\\b'\r\n      $escapedName = 'a`\\b'\r\n      $escapedPath = ((Get-Item .).PSPath -replace '/$') + '/' + $escapedName\r\n      # File with literal backtick in its name.\r\n      touch 'a`b'\r\n    }\r\n    It \"Backslashes can be matched with wildcards\" {\r\n      (Get-Item -Path 'a?b').Name   | Should -BeExactly 'a\\b'\r\n      (Get-Item -Path 'a*b').Name   | Should -BeExactly 'a\\b'\r\n      (Get-Item -Path 'a[\\]b').Name | Should -BeExactly 'a\\b'\r\n    }\r\n    It \"Backtick-escaped backslashes match literal ones in filenames\" {\r\n      (Get-Item -Path 'a`\\b').Name | Should -BeExactly 'a\\b'\r\n      (Get-Item -LiteralPath 'a`\\b').Name | Should -BeExactly 'a\\b'\r\n    }\r\n    It \"Backticks not preceding a backslash or backtick are literals in literal paths\" {\r\n      (Get-Item -LiteralPath 'a`b').Name | Should -BeExactly 'a`b'\r\n    }\r\n    It \"Doubled backticks are also literals in literal paths\" {\r\n      (Get-Item -LiteralPath 'a``b').Name | Should -BeExactly 'a`b'\r\n    }\r\n    It \"Backtick-escaped backticks must be recognized as a literal backtick in wildcard paths\" {\r\n      (Get-Item -Path 'a``?').Name | Should -BeExactly 'a`b'\r\n    }\r\n    It \"Provider properties contain escaped paths\" {\r\n      (Get-Item -LiteralPath 'a`\\b').PSChildName | Should -BeExactly $escapedName\r\n      (Get-Item -LiteralPath 'a`\\b').PSPath | Should -BeExactly $escapedPath\r\n    }\r\n    It \"Convert-Path removes the PS-specific escaping\" {\r\n      Get-Item -LiteralPath 'a`\\b' | Convert-Path | Should -BeExactly $nativePath\r\n    }\r\n    It \"Native globbing doesn't break when a filename with a backslash is among the matches\" {\r\n      /bin/echo a* | Should -Not -Match '\\*'\r\n    }\r\n    AfterAll {\r\n      Pop-Location\r\n    }\r\n  }\r\n\r\n}\r\n```\r\n\r\n# Expected behavior\r\n\r\nAll tests should pass.\r\n\r\n# Actual behavior\r\n\r\nAll tests except \"Backticks not preceding a backslash or backtick are literals in literal paths\" fail.\r\n\r\n# Environment data\r\n\r\n```none\r\nPowerShell Core 6.2.0-rc.1\r\n```\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "If we ever get around to https://github.com/PowerShell/PowerShell/issues/5785, we can decide what the default behavior should be with regards to slashes.  ",
      "created_at": "2019-03-29T01:17:01Z",
      "updated_at": "2019-03-29T01:17:01Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT, can you please clarify?\r\n\r\n> with regards to slashes\r\n\r\nDid you mean backslashes?\r\n\r\n> If we ever get around to #5785\r\n\r\nDoes this mean that, for the time being, _explicit cross platform experience_ translates to:\r\n *  \"You can use `\\` and `/` interchangeably on all platforms, as long as you don't expect filenames with embedded `\\` chars. to work on Unix-like platforms\"?\r\n\r\nDo you feel that there are aspects of #8158 and #6833 not covered here? \r\n * If so which? \r\n * If not, can you please close them?\r\n",
      "created_at": "2019-03-29T02:19:47Z",
      "updated_at": "2019-03-29T02:19:47Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "I'm using 'slashes' as a generic term for both forward and backslashes.\r\n\r\nYes, current expectation is that you can use `\\` and `/` interchangeably on all platforms, except where filename/directoryname contains `\\`.\r\n\r\nhttps://github.com/PowerShell/PowerShell/issues/6833#issuecomment-389690161 summarizes the PS-Committee stance.\r\n\r\nUnlike the square brackets, it's unclear to me how often people use the backtick `` ` ``  or the backslash `\\` within file/directory names.\r\n\r\nI'm ok closing the older issues as dupes of this one (although it's a bit backwards...) as I believe this does summarize the issues.",
      "created_at": "2019-03-29T03:16:32Z",
      "updated_at": "2019-03-29T03:16:32Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @SteveL-MSFT.\r\n\r\nGood point that use of  `` ` `` and `\\` in filenames may be rare, but it's still problematic to make native capabilities inaccessible (currently) and providing a workaround is both a nontrivial implementation effort and a pitfall for and burden on those who do wish to use `\\`.\r\n\r\n> I'm ok closing the older issues as dupes of this one (although it's a bit backwards...\r\n\r\nI don't think that's problematic, as long as the later issue properly references and summarizes the earlier one(s), and the benefit is that future readers are spared the need to cull information from lengthy exchanges and potential confusion over what the way forward is.",
      "created_at": "2019-03-29T07:33:24Z",
      "updated_at": "2019-03-29T07:33:24Z"
    }
  ],
  "created_at": "2019-03-28T17:10:19Z",
  "number": 9244,
  "state": "open",
  "title": "Bug fixes needed to support interchangeable use of \"/\" (forward slash) and \"\\\" (backslash) in file paths on Unix-like platforms",
  "updated_at": "2021-12-01T11:35:11Z"
}