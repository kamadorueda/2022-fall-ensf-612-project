{
  "_url": "https://github.com/PowerShell/PowerShell/issues/12106",
  "author": "essentialexch",
  "body": "# Summary of the new feature/enhancement\r\n\r\nOver the last year or two, shutdown.exe has gained several new and worthwhile options (/g, /sg, /fw, etc.) which aren\u2019t present in restart-computer. I would like to see these implemented in Restart-Computer (especially the three I mentioned).\r\n\r\nThe /g option (reboot with auto-restart) makes reboots easier. The /sg option (shutdown with auto-restart) makes shutdowns followed by restarts easier.  The /fw option (reboot to firmware) solves the age-old problem of \"which special key do I hit to get to BIOS/UEFI???\"\r\n\r\n# Proposed technical implementation details (optional)\r\n\r\nI don't know how the new options are implemented. I presume some Win32 call.\r\n\r\nBut for PowerShell, some new parameters such as [-Reboot] [-AutoRestart] [-Shutdown] [-Firmware] in appropriate parametersets would be desirable.\r\n\r\nOops.... TIL about Stop-Computer. I didn't even realize Stop-Computer existed until I was reading about #4857 (which leads to the question, what happened to #8112)?\r\n\r\nSo I guess I'm actually asking for [-AutoRestart] and [-Firmware] to be implemented in both Restart-Computer and Stop-Computer.\r\n",
  "closed_at": "2021-10-27T12:23:09Z",
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I found only the public docs https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32shutdown-method-in-class-win32-operatingsystem\r\nand https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32shutdowntracker-method-in-class-win32-operatingsystem\r\n\r\nCan they fulfill your request?\r\n\r\n",
      "created_at": "2020-03-12T06:26:13Z",
      "updated_at": "2020-03-12T06:40:34Z"
    },
    {
      "author": "essentialexch",
      "author_association": "NONE",
      "body": "Far be it from me to claim to be a programmer (I'm not, I'm just an admin scripter).\r\n\r\nBut according to Win32ShutdownTracker, it's implemented using ExitWindowsEx():\r\n\r\n```\r\nPS C:\\scripts> get-cimclass -class win32_operatingsystem | \r\n    select -expand cimclassmethods |? { $_.Name -eq 'Win32ShutdownTracker' } |\r\n    select -expand qualifiers |? { $_.Name -eq 'mappingstrings' } | \r\n    select Value\r\n\r\nValue\r\n-----\r\n{Win32API|System Shutdown Functions|ExitWindowsEx}\r\n```\r\nAutoRestart (and Reboot and Shutdown) is fully defined within ExitWindowsEx(). I would guess the Win32ShutdownTracker doc was not updated with EWX_RESTARTAPPS.\r\n\r\nInsofar as how reboot to BIOS/UEFI is done - I'm not sure. I would expect it to be another parameter to ExitWindowsEx() (there are 3 others defined in WinUser.h: EWX_QUICKRESOLVE, EWX_HYBRID_SHUTDOWN, and EWX_BOOTOPTIONS but these are not explicitly documented). EWX_BOOTOPTIONS seems likely.\r\n\r\nSince both shutdown.exe and the Windows 10 UI know how to do a \"reboot to BIOS/UEFI\", it can't be too much of a secret (UI: Start --> Settings --> Update & Security --> Recovery --> Advanced Startup).\r\n\r\nI can experiment with those 3 options.",
      "created_at": "2020-03-12T15:10:10Z",
      "updated_at": "2020-03-12T15:10:10Z"
    },
    {
      "author": "TravisEz13",
      "author_association": "MEMBER",
      "body": "It's also entirely possible that the option, is not a public API.",
      "created_at": "2020-03-12T16:00:52Z",
      "updated_at": "2020-03-12T16:00:52Z"
    },
    {
      "author": "essentialexch",
      "author_association": "NONE",
      "body": "ExitWindowsEx() works just fine and exposes all of the expected restart options shown by MSDN.\r\n\r\nWith a P/Invoke/Add-Type I was able to do everything:\r\n\r\n```\r\n$Win32 = Add-Type -Name 'Win32' `\r\n    -Namespace 'Win32' `\r\n    -MemberDefinition @\" \r\n        [DllImport( \"user32.dll\" )] \r\n        public static extern int ExitWindowsEx( int uFlags, int dwReason ); \r\n\"@ -PassThru \r\n\r\n```\r\nIt appears that WindowsShutdown() and WindowsShutdownTracker() mask and suppress several of the ExitWindowsEx() options. I don't know why - but I bet there are comments in the Win32 sources. \r\n\r\nBut not that anything is a non-public API using ExitWindowsEx instead of ShutdownWindows*.",
      "created_at": "2020-03-16T01:31:39Z",
      "updated_at": "2020-03-16T01:31:39Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": ">  I was able to do everything\r\n\r\nI don't see an option for `-Firmware`. Please update the issue description for latest status.",
      "created_at": "2020-03-16T04:34:18Z",
      "updated_at": "2020-03-16T04:34:18Z"
    },
    {
      "author": "TobiasPSP",
      "author_association": "COLLABORATOR",
      "body": "This seems like a duplicate to https://github.com/PowerShell/PowerShell/issues/14222 so I am reiterating our conclusion and close this issue for now:\r\n\r\nAfter thorough debate, the cmdlet WG concluded:\r\nA platform-specific feature for which a native command exists generally is easily accessible from within PowerShell as-is. For example, it is trivial on a Windows system to use shutdown.exe in a PowerShell script.\r\nUsing native commands may not be easily discoverable, though: the PowerShell help system wouldn't suggest this native command or provide help. This part could indeed be solved by adding the functionality to a core cmdlet.\r\nOn the down side, this would decrease consistency and user experience on non-targeted systems though.\r\nSo for platform specific features, the cmdlet WG recommends to continue to directly use appropriate native commands provided by the particular platform on the platforms where it is available. If additional PowerShell-specific functionality like risk mitigation (-whatif) etc is needed - native commands can easily be wrapped inside a PowerShell function.\r\nFor these reasons, the issue was closed, and we hope our reasoning resonates with the community.",
      "created_at": "2021-10-27T12:23:09Z",
      "updated_at": "2021-10-27T12:24:09Z"
    },
    {
      "author": "doctordns",
      "author_association": "COLLABORATOR",
      "body": "The Cmdlet working group has looked at this issue. We are marking this as won't fix for the same reasons we outlined in a similar issue, https://github.com/PowerShell/PowerShell/issues/12106. The Working Group recognizes the value and need for cmdlets, but that doesn't preclude someone from running the native shutdown.exe command. If someone wants the benefits of a cmdlet, that is where the Crescendo module becomes important.",
      "created_at": "2022-06-01T16:10:46Z",
      "updated_at": "2022-06-01T16:10:46Z"
    },
    {
      "author": "Jibun-no-Kage",
      "author_association": "NONE",
      "body": "So, what people ask for, is just not considered valid?  Using shutdown.exe is a scapegoat.  The original Restart-Computer and Stop-Computer should have had full functionality.  That is the real issue, someone cut a corner, and someone else should have called it out as wrong.  \r\n\r\nThere should be parity in design.  Anything else is just being lazy.  Sorry, guys, but this is why there are 100s of ways to do things, and no consistency in Windows.  In this respect you are closer to Linux than not.  Parity of design needs to be honored.  Frankly when I realized Restart- and Stop-Computer lacked parity, I was dumbfounded, of all the stupid things to not implement was my initial reaction, I could not then nor now see any rationale argument for non-parity.\r\n\r\nI realize some may not agree, but every IT professional I know that has to remember 20 commands to do the same thing in Windows because each command is slightly different, is just nuts.  Get off your butts and update the cmdlets... establish some real parity of design.",
      "created_at": "2022-06-23T18:19:56Z",
      "updated_at": "2022-06-23T18:19:56Z"
    },
    {
      "author": "TobiasPSP",
      "author_association": "COLLABORATOR",
      "body": "What has been asked is completely valid, no worries. It just cannot be implemented by the PowerShell team, and here is why:\r\n\r\nWhen Windows PowerShell was invented in 2006, it was a Windows-specific automation shell so back then the PowerShell team created the automation engine/language plus a number of basic cmdlets like *-Computer to manage Windows-systems. \r\n\r\nToday, 15 years later, PowerShell has evolved into a cross-platform automation engine, and the team has since invested in an ecosystem (PowerShellGet and powershellgallery.com) where anyone can add Modules. \r\n\r\nWe tried to explain that the team today needs to focus on the engine and work on a small generic OOB footprint for the base package to make it available in as many generic platforms as possible. \r\n\r\nThat\u2019s why the suggestion discussed here is perfectly valid yet it is not necessarily up to the PowerShell team to implement this, especially since the requested feature is OS-specific. \r\n\r\nI know this is not a perfect answer, and in a perfect world *someone* would just take care of the many valid and good ideas posted here. \r\n\r\nOur challenge is to identify the features only the team can implement (technically), and for all other scenarios, suggest alternate ways. One would be to create an OS-specific improved version and publish it to the gallery (which would indeed help consistency and discoverability for Windows users). Another would be to use the OS-specific tooling for OS-specific features, i.e. shutdown.exe, at the expense of less consistency. \r\n\r\nThe same applies to any raw .NET code portion, though. PowerShell has a consistent easy-to-use cmdlet interface for all tasks supported on that level, yet also a much less managed and lower level approach for anything else. \r\n\r\nAgain, I am completely on your page, and in a perfect world we would have consistent cmdlets for all thinkable tasks. ",
      "created_at": "2022-06-23T18:48:28Z",
      "updated_at": "2022-06-23T18:48:28Z"
    },
    {
      "author": "Jibun-no-Kage",
      "author_association": "NONE",
      "body": "Thanks for the response.\r\n\r\nSo, just following your logic, the creation of Restart-Computer and Stop-Computer should not have been established?  If I am understanding, correctly, I agree with this.  Because it would up-hold parity or consistency at least within the respective OS.  That being that shutdown.exe should be used, even if driven by PS, because it becomes the sole [cough] de-facto standard for doing such, restart, shutdown, etc.  I find it endlessly exhausting to keep track of multiple ways to do things in Windows, never mind Linux, and other OSes, where within the given OS, there is... how should I put it, technical ambiguity?\r\n\r\nMoreover, if Restart-Computer can be implemented consistently across the entire eco-system, that it should be.  I agree with this as well, this would also establish true parity within the eco-system.\r\n\r\nOf course, a counter argument for PS once could have been, there will be the PS way of doing things and no other... but that did not result, just as VBScript, .NET, etc. all where called in their time, the solution to retire others.  I even remember when retirement of BAT/CMD scripts was heralded to be soon reality!  But such is development life? No?",
      "created_at": "2022-06-23T19:08:25Z",
      "updated_at": "2022-06-23T19:08:25Z"
    },
    {
      "author": "essentialexch",
      "author_association": "NONE",
      "body": "Correct.\r\n\r\nIf they aren't going to absorb the functionality, then they shouldn't bother. Retire the cmdlets.\r\n\r\nThe reference to Crescendo is especially mind-boggling to me, as when I opened the issue, Crescendo didn't exist. And based on my review of it, it isn't something for someone who just writes scripts.\r\n\r\nThe WGs seem to be focused on responses that only appeal to programmers. Not admin scripters.\r\n\r\nAll the responses to my original issue (as a scripter who wanted to use PS to accomplish something) were programming oriented. It took me many hours to figure out my responses - because I'm not a programmer. And I shouldn't have to be one to open an issue and expect it to be properly reviewed.\r\n\r\nThis attitude from both the WGs and the PS team has led me in the past two years to move to using far more native binaries and direct .NET calls than I used in the past, even when cmdlets exist.\r\n\r\nThis isn't \"woe is me\", but a simple statement of fact, from my perspective: the team and the WGs prioritize programmers before scripters.",
      "created_at": "2022-06-23T19:51:24Z",
      "updated_at": "2022-06-23T19:51:24Z"
    },
    {
      "author": "Jibun-no-Kage",
      "author_association": "NONE",
      "body": "Wow... you hit a nerve with me... I as well, tend to look for native API methods whenever possible.  I am a scripter to be sure, but I also have done serious programming in C (real C), C#, C# .NET, VB.NET, VB (in 1995 no less) and more recently with python, although I figure I will get around to 'Rust' at some point.  Of course, on Linux, python, bash, C.  And even with my programming experience, I still remember saying to the local programming team, 'You are not user friendly, not coding for long term use, what the hell are you doing?'  Let's just say, as a QA/QC code reviewer, even as far back as University student for on campus development and beyond, I was NOT POPULAR.  LOL.  But I can say this, the solutions where I got my way... they had fewer bugs, worked better and longer, and once I got a few programmers to listen, they could see the value of taking into account the end-user over coding speed or ease.  I remember something I learned as kid... if it is worth doing, it is worth doing right... IT world, that reads, if the users hate it, it is a waste of time and resources, i.e. reduces profit, not generates profit.  Want to guess which Fortune 50, or even Fortune 10 firms I worked for, that did in-house development, and forget that idea?  Most of them.  Scripters ARE users.",
      "created_at": "2022-06-23T21:25:12Z",
      "updated_at": "2022-06-23T21:29:01Z"
    },
    {
      "author": "TobiasPSP",
      "author_association": "COLLABORATOR",
      "body": "Hm. When you look at other scripting environments, libraries are created and maintained by a vast number of actors including the vendors and the community. \r\n\r\nIn PowerShell, coming from the closed Windows world, there was the original expectation that everything is provided by Microsoft. \r\n\r\nThis has opened up considerably, and today modules from vendors and community outnumber the modules shipped by the PowerShell team big time. That appears to me as a good thing however I do see the need for i.e. curated community modules, i.e. to cover generic OS-specific extensions, in an effort to improve the one-stop idea where admins can easily find all they typically need rather than having to add millions of dependencies to multiple modules. \r\n\r\nI wouldn\u2018t do away with the idea of cmdlets in general though just because of this. They are and continue to be an excellent way of providing consistency, code reuse, and ease of use. To me it is more about transitioning to an ecosystem where more parties provide and maintain such cmdlets than just the team that maintains the engine.\r\n\r\nI too am personally believing that what differentiates good and easy scripts from clumsy and hard-to-maintain scripts is the *distance* you bridge between the commands you use and your automation need. So of course you can go the full distance and use .NET and native binaries to solve your need from scratch. However cmdlets/functions often shorten that distance immensely, and often you need just a few specialized cmdlets vs. pages and pages of low level generic calls. Just compare Get-ADUser with low-level ADSI scripting. Cmdlets reduce the *noise* in your code and enable everyone to look at the intended workflow in a much cleaner and focused way, plus once you added a new cmdlet for a particular need, it lets you easily reuse the effort and makes itself become discoverable.\r\n\r\nTo cut a long story short, to me cmdlets/functions are the way to go in administration. It\u2019s just an ongoing puzzle we need to solve who is providing and maintaining these, and how extensions to the cmdlet ecosystem are best organized. Just my 5ct. :-)",
      "created_at": "2022-06-24T08:01:22Z",
      "updated_at": "2022-06-24T08:02:50Z"
    },
    {
      "author": "essentialexch",
      "author_association": "NONE",
      "body": "I think that Get-ADUser is probably a bad example. The AD cmdlets are quite broken and have been since the day they were released. 95% of the time I replace Get-AD* with:\r\n\r\n```\r\nfunction __simpleSearch\r\n{\r\n\tParam\r\n\t(\r\n\t\t[String] $ldapQuery,\r\n\t\t[String] $searchBase,\r\n\t\t[String[]] $Properties = $null,\r\n\t\t[String] $searchScope = 'Subtree',\r\n\t\t[Switch] $findOne,\r\n\t\t[Int32] $PageSize  = 1000,\r\n\t\t[Int32] $SizeLimit = 1000000\r\n\t)\r\n\r\n\t$adSearcher = [adsisearcher] $ldapQuery\r\n\t$adSearcher.SearchRoot  = getObject $searchBase\r\n\t$adSearcher.PageSize    = $PageSize\r\n\t$adSearcher.SizeLimit   = $SizeLimit\r\n\t$adSearcher.SearchScope = $searchScope\r\n\r\n\tif( $Properties ) \r\n    {\r\n        foreach( $ADProperty in $Properties ) \r\n        {\r\n            $null = $adSearcher.PropertiesToLoad.Add( $ADProperty )\r\n        }\r\n    }\r\n\r\n\tif( $findOne )\r\n\t{\r\n\t\t$r = $adSearcher.FindOne()\r\n\t}\r\n\telse\r\n\t{\r\n\t\t$r = $adSearcher.FindAll()\r\n\t}\r\n\r\n\t$r\r\n}\r\n\r\n```\r\n\r\nwhich usually reduces to:\r\n\r\n```\r\nfunction getAllObjects\r\n{\r\n\tParam\r\n\t(\r\n\t\t[String] $ldapQuery,\r\n\t\t[String] $namingContext = $null,\r\n\t\t[String[]] $Properties  = $null\r\n\t)\r\n\r\n\t__simpleSearch -ldapquery $ldapQuery -searchBase ( getNC $namingContext ) -Properties $Properties\r\n}\r\n```",
      "created_at": "2022-06-24T12:18:48Z",
      "updated_at": "2022-06-24T12:18:48Z"
    },
    {
      "author": "Jibun-no-Kage",
      "author_association": "NONE",
      "body": "@TobiasPSP ,  the point, that I made, is that incomplete implementation creates confusion and non-parity.  For example, why Restart-Computer or Stop-Computer does NOT include a message parameter... is just STUPID.  PERIOD.  Every other option to restart/shutdown the computer (if memory serves) .NET, native EXE, etc., DOES include the message option.  The use of ExitWindows a direct API call is not applicable, because it as a task API call, no expectation for it to be interactive.  But shutdown.exe is designed to be interactive, if so needed or desired.  So does Restart-Computer/Stop-Computer given the options they DO support, the confirm option alone screams this point.\r\n\r\nAgain, my assertion is that if you write or develop a cmdlet that mirrors another method, do it right, and be complete.  Taking away flexibility is short sighted, and I see Restart-Computer and Stop-Computer explicit examples of cutting a corner that creates non-parity, confusion, etc.  A cmdlet is to ease use not create additional complexity, which must be done to add message feature to the standardized Restart-Computer/Stop-Computer.\r\n\r\nSo, the suggestion is, if you write a cmdlet, do it right, if such does mirror other methods available.  Again, shutdown.exe as compared to Restart-Computer and Stop-Computer so clearly illustrates chessy development.  The goal of .NET was not to replace the lower level API, but to make it safer and easier to use the lower level API.  Powershell should to the same thing.",
      "created_at": "2022-06-24T15:29:42Z",
      "updated_at": "2022-06-24T15:31:59Z"
    },
    {
      "author": "doctordns",
      "author_association": "COLLABORATOR",
      "body": "It is easy to say \"we should do xxx\" - but a lot harder to actually do it. Sure, in a perfect world, we'd have cmdlets for everything. But that is not what we have. Insulting the team, and calling them 'stupid', does not advance your case. \r\n\r\nAs you know, there is a workaround to this lack of functionality.  That is today, probably the best answer. \r\n\r\nWe can discuss this in the Cmdlet working group, but I do not see much hope of success. If you DO want to change the command, then bring on the evidence of need - demonstrate the need for this feature. Show that the community values this particular new feature above all others. Make the case on need, not on a perceived view of perfection. So far, I am not really seeing such pent-up demand. But I could be looking in the wrong place.  So if there is real community enthusiasm for this, please show me. \r\n\r\nA suggestion is for the OP to build a proxy `Restart-Computer` command that implements additional parameters. Then submit it to the PowerShell Gallery.  If that becomes wildly and widely popular, then that may be evidence of the need to bring this into the core of PowerShell. \r\n\r\n",
      "created_at": "2022-06-25T10:51:58Z",
      "updated_at": "2022-06-25T10:51:58Z"
    },
    {
      "author": "Jibun-no-Kage",
      "author_association": "NONE",
      "body": "I did not insult the team, I insulted the mind-set.  This is a mind-set that is across the industry of software development in total, frankly.  One example the gaming world, where before digital release, you had to get the code stable... and right.  Because deployment was expensive to recall, on physical media.  But the actual, second, so to speak, it was easy to publish updates, there was direct and explicit decline in the quality of the code development and greater push to release less than solid code... after all as one developer said, 'hey we can just deploy a fix easy now, right?'  That is so wrong, that if you can't see that point, you miss one of the key issues I am stressing.\r\n\r\nThe other issue is parity of design.  Not designing well, with strong parity and thought of how and why you make such decisions, you are not doing yourself or you end-user population any favors.  The Restart-Computer/Stop-Computer is just an easy example that illustrates, that yes, someone cut a corner, and someone did not call it out.  To your point, how it important is?  Look at all the examples on Google about work-arounds... if that does not tell you something was wrong with the cmdlets, what can I say to convince you of my point about parity of design?  Scripting exists to save time and effort, versus traditional coding methods such as C or Pascal, which saved time and effect in their own right, otherwise we would all still be coding in Macro Assembler.\r\n\r\nTo be fair, I am not expecting anything to change per se.  It maybe, likely that Restart-Computer/Stop-Computer just fade away and disappear over time.  There are better ways to do the same thing across each part of the total eco-system, and as others have suggested, time better spent after other goals for PowerShell.  But the lesson to be learned, IMHO, is if you tackle something in PowerShell that already exists elsewhere.... Do it right, met feature set parity, or improve it, but don't remove a key feature because it is hard to do, might take more time, or some other explanation that removes parity.   Your end-users hate these blind-corners, snafus.  I know this after years of serious development, being a QA/QC lead, as well as early virtualization adopter.  If you are going to do something to it right.  Anyone that looks at Restart-Computer/Stop-Computer, knows it just screams, as an example, of not being done right.",
      "created_at": "2022-06-25T13:35:57Z",
      "updated_at": "2022-06-25T13:35:57Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> I did not insult the team, I insulted the mind-set.\r\n\r\nIf you insult a way of thinking, the people who think that way are going to feel insulted. \r\n\r\n\r\n> The other issue is parity of design.\r\n\r\nNot really. When PowerShell 1 released and Windows Vista / Server 2008 was the current OS, there _was_ parity of design. There isn't a PM for `Stop-Computer` and `Restart-Computer` so as  functionality is added to `shutdown.exe` there is no automatic way for the cmdlet to grow. \r\n\r\nWith PowerShell 6 and 7  the PowerShell team are focused on the engine more than on the Windows-specific commands. But as an Open Source project people are free to put forward enhancements . \r\n\r\nThis in the first post \r\n>> So I guess I'm actually asking for [-AutoRestart] and [-Firmware] to be implemented in both Restart-Computer and Stop-Computer.\r\n\r\nIs a start. If there should be others @Jibun-no-Kage   you're welcome to propose them (though have a read of https://smile.amazon.co.uk/How-win-friends-Influence-People-ebook/dp/B09ST4JLBQ/ref=sr_1_1?keywords=how+to+win+friends+and+influence+people&qid=1656189952&sprefix=how+to+%2Caps%2C89&sr=8- first) \r\n\r\nI see no reason why that shouldn't be flagged as \"up for grabs\". It wouldn't be harmful, and has some benefit, and doesn't need to be written by the core team. It doesn't look like very difficult C# to write so if someone from the community wants to do it, great, if not it shows it's not good use of Microsoft people's time. \r\n\r\n\r\n\r\n\r\n",
      "created_at": "2022-06-25T20:49:46Z",
      "updated_at": "2022-06-25T20:49:46Z"
    },
    {
      "author": "Jibun-no-Kage",
      "author_association": "NONE",
      "body": "@jhoneill. really, recommending a book?  One I have read by the way, years ago.  But that is not relevant to the question posed.  Frankly, people need to stop worrying about their feelings, and focus on quality code, and good design.  When that is done, the result is benefit to everyone.  Call it a suggestion, to your suggestion that some one may pick up the task as you offered.",
      "created_at": "2022-06-25T21:49:39Z",
      "updated_at": "2022-06-25T21:51:35Z"
    },
    {
      "author": "essentialexch",
      "author_association": "NONE",
      "body": "> It doesn't look like very difficult C# to write so if someone from the community wants to do it, great, if not it shows it's not good use of Microsoft people's time.\r\n\r\nIt most certainly does not show that.\r\n\r\nThe people that would benefit are those who are admin scripters. They are not the people who can write C#. They are the people that want to use PS to get a job done.\r\n\r\n> A suggestion is for the OP to build a proxy Restart-Computer command that implements additional parameters.\r\n\r\nThere y'all go again - suggesting that a scripter become a developer.\r\n\r\nYou are forgetting a primary audience for PS, if not THE primary audience.",
      "created_at": "2022-06-25T21:57:58Z",
      "updated_at": "2022-06-25T21:57:58Z"
    },
    {
      "author": "Jibun-no-Kage",
      "author_association": "NONE",
      "body": "@essentialexch Yes, that is an excellent point, very well said.",
      "created_at": "2022-06-25T22:00:35Z",
      "updated_at": "2022-06-25T22:00:35Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> @jhoneill. really, recommending a book? One I have read by the way, years ago. But that is not relevant to the question posed. Frankly, people need to stop worrying about their feelings, and focus on quality code, and good design. When that is done, the result is benefit to everyone. Call it a suggestion, to your suggestion that some one may pick up the task as you offered.\r\n\r\nPerhaps my point was too subtle. There is a famous book called \"How to win friends and influence people\", you're doing the opposite, being insulting just means no one wants to listen to you. It doesn't matter if you're _right_ \r\n\r\nThere is a piece of bug free code (so there is no quality issue), and which was designed 15 years ago and there was nothing wrong with the design at that time. Throwing insults around because the team has not made it a priority to go back and look at V1 cmdlets and see if they need to be updated won't make them re-order their priorities in the way that you want. Other contributors who might implement features will put their time into something else.  \"People need to stop worrying about their feelings\" translates to people need to treat requests from those who insult them in the same way as people who are _nice_, and I wish you luck getting that to happen.\r\n\r\n \r\n\r\n> > It doesn't look like very difficult C# to write so if someone from the community wants to do it, great, if not it shows it's not good use of Microsoft people's time.\r\n> \r\n> It most certainly does not show that.\r\n> \r\n> The people that would benefit are those who are admin scripters. They are not the people who can write C#. They are the people that want to use PS to get a job done.\r\n\r\nThe people who write these sort of things aren't, usually, writing just for themselves. There are community contributors with the C# skills who will write things they see a need for.  If they could do it but think it would be bad use of _their_  time why would it be good use of the Microsoft team's time? \r\n\r\n\r\n> > A suggestion is for the OP to build a proxy Restart-Computer command that implements additional parameters.\r\n> \r\n> There y'all go again - suggesting that a scripter become a developer.\r\n\r\nSince you were the OP, looking at what you've posted you're more than capable of generating a proxy function and adding an extra switch and a line `IF ($switch) { shutdown.exe /xyz; return}`\r\n\r\nThere is no logoff command in PowerShell, and stop-computer does provide a choice between stop at the \"safe to Power off\" and \"power the machine off\" and so on.  I'm not convinced that a `Stop-UserSesssion` command is better than `logoff`, or that \"Restart-Computer -Firmware\" is better than `shutdown /fw`  Something like booting to the firmware menu is  an interactive thing we do rarely and there may be reasons for not open-sourcing \"re-start from the same place\"\r\nthere is nothing wrong with using shutdown.exe  , or ping, or clip  or format.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2022-06-26T10:06:53Z",
      "updated_at": "2022-06-26T10:06:53Z"
    },
    {
      "author": "Jibun-no-Kage",
      "author_association": "NONE",
      "body": "About the book.... clearly you don't understand, I don't care about being all goody goody nice.  I made my point, and it factual and accurate.  You would rather argue about something that is not relevant to the points made by me and others.  Stop thinking about being a developer, and consider the needs of your end-user population.",
      "created_at": "2022-06-26T22:44:08Z",
      "updated_at": "2022-06-26T22:44:08Z"
    },
    {
      "author": "doctordns",
      "author_association": "COLLABORATOR",
      "body": "It feels to me that while youn may have a purist point, it is not all that helpful here. Yes, I agree - having better parity between shudowhn.exe and shutdown-computer would be nice. But today, it doesn't.   So what do we do? \r\n\r\nPersonally, I've never seen significant community input saying this change is needed. Most of the folks posting (eg in the Spiceworks PowerShell forum) seem content with the current cmdlet or the WIn32 console application as a workaround. I have written 5 books on PowerShell (the 5th is due out this autumn) and have managed just fine without this fix. What this says to me is that, while not perfect, this is a good enough solution.  So where is this user population demanding this change?  I just do not see it but could be looking in the wrong places\r\n\r\nAnd finally, why not create a module with a proxy function to demonstrate just what you are doing. Stick this into the PS gallery (and promote it!) then come back when you have loads of downloads. This might be another way to demonstrate the value of this change by allowing reconsideration based on facts, not personal biases.\r\n\r\nI have put this item on the agenda for the next cmdlet working group meeting. That said, I see no great reason NOT to close this issue as something we will not implement.  But we can discuss. In the mean time, both suggestions above would help us to come to a conclusion. \r\n",
      "created_at": "2022-06-27T11:22:54Z",
      "updated_at": "2022-06-27T11:22:54Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "@Jibun-no-Kage   \r\nI'm not a developer. I've spent 34 years working with IT pros / as an IT pro. I was a consultant and then an evangelist working at Microsoft for 10 years, so I have some grasp of how Microsoft worked - although people will tell me that particular Leopard has changed its spots.  It has been by job to act as customer advocate and get the people who develop the product _as customers need it_ which is not always the work they want to do.  And I now sit on the cmdlet working group because I've written a ton of PowerShell (and a tiny amount of C#) over the last 15 years, and people seem to think I know what I'm talking about. \r\nI'm not always the politest person, and do tend to take a view that facts are facts, and if they only support one conclusion then that conclusion is right however it is presented. And the bitter fruit of 34 years experience is thinking that way has neither helped my career nor the customers I was acting as advocate for.  Choosing to - as you put it - \"care about being all goody goody nice\" gets results more of the time.  \r\n\r\nThe position is: \r\n\r\n- There is far more work that the PowerShell team in Microsoft _could_ do than Microsoft will assign developer/tester hours _to_ do. So work must be prioritized\r\n- Now that PowerShell is open-source the team effort is augmented by the community, assuming that community members see it as worth their time. Where the Microsoft team is a single queue to fight for a place in, each community developer is another chance to get some developer hours, but only if they can be persuaded it is worth their time. \r\n- If anybody _can_ do it but nobody comes forward _to_ do then it shows a Microsoft decision not to do it was probably the right one - the team is there to do the jobs others can't, not as resource for the ones they don't want to do.\r\n- Assigning resources to features and enhancements uses a very fuzzy cost-benefit analysis. How many hours of effort  does the work need, for how much benefit to how many people? What new scenarios are enabled ? What existing scenarios are improved, does anything work less well?  \r\n- This is not a request to enable new scenarios - everything is already done by an external command that can be called from a script.  Is a common scenario better with a PowerShell native command ? Being able to pipe a list of computers into restart or stop _is_ a benefit , but reboot to firmware  menu seems like a single computer task, done rarely, so if we do as you say \"consider the needs of your end-user population.\" do they _need_ this ? No, they don't. Some of them would _like_ it, and a few scripts would be slightly more elegant.  Do they have needs where effort would be better spent? Yes, many of them.  \r\n- So this may get marked as \"up for grabs\", but I can't see Microsoft resource being devoted to it. \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2022-06-27T12:11:37Z",
      "updated_at": "2022-06-27T12:12:09Z"
    },
    {
      "author": "TobiasPSP",
      "author_association": "COLLABORATOR",
      "body": "@jhoneill thank you for this comprehensive summary. This reflects exactly what I feel. @doctordns : technically this issue is closed already, we responded to post-close comments. @Jibun-no-Kage: I hear you, and consistency and discoverability *are* great assets however PowerShell is serving a much wider audience in 2022 than in 2006, and is no longer a scripting language primarily targeted towards the Windows Admin. Instead, there are plenty of communities which each use vendor- and community-owned modules to make themselves at home. In the WG we are already discussing how community-driven modules can be made more readily available. In a perfect world, the mentioned suggestion could then be proposed not just to MSFT but possibly also to specific community-maintained module(s).",
      "created_at": "2022-06-27T12:52:40Z",
      "updated_at": "2022-06-27T12:52:40Z"
    },
    {
      "author": "essentialexch",
      "author_association": "NONE",
      "body": "Modules and proxy functions are something that developers use. Not admin scripters.\r\n\r\nI've been writing PowerShell since it was called Monad and released in beta for E12. I've written two Exchange books of my own and tech edited more Exchange and AD books than I can remember. Plus exam authoring. Plus conferences. Yadda yadda yadda. My list of experience in IT matches or surpasses both of yours. Your attempted one-upmanship fails on me. And it really doesn't matter.\r\n\r\nIn my 15+ years of PS usage I've written fewer than a handful of modules and zero proxy functions. I'm not a developer. I'm an admin scripter.\r\n\r\nMy perspective as a user is just as valid as yours.\r\n\r\nOne further comment and then I'm out:\r\n\r\n> > The people that would benefit are those who are admin scripters. They are not the people who can write C#. They are the people that want to use PS to get a job done.\r\n> \r\n> The people who write these sort of things aren't, usually, writing just for themselves. There are community contributors with the C# skills who will write things they see a need for.\r\n\r\nI don't think so. They are writing things that they are interested in. Big difference. As a 13-year MVP I'm well aware of how community contributions work.\r\n",
      "created_at": "2022-06-27T12:59:08Z",
      "updated_at": "2022-06-27T12:59:08Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "@essentialexch  Sorry you feel that way.  I played the 34 years in IT card because I didn't want to address another poster in terms which might look rude. I've failed doing things his way, and succeeded when I've been more... emollient.  \r\n\r\nAnd yes @doctordns  @TobiasPSP  and can I talk about our years doing this, the books we've written (yes I have my name on a some covers too - and I was an item writer for the Windows 2000 exams before I joined Microsoft), and Conferences we've spoken at - Tobias and I are just returned from PSConfEU  And we'll all bang heads until we have the sense to stop.  But actually \"I know perfectly well who you are, and my perspective still is valid\" is a very good reminder.  Some issues that are opened are idiotic, this is not. It's something that would be done if we were starting today, and would be done today if we were not resource constrained.  But from the position that we're in the benefits of reworking the cmdlet are small and it just won't meet the threshold for getting PowerShell team hours. \r\n\r\nI'm not sure you get what a proxy function is - it is just a function with the same name as a cmdlet which gets called first by normal rules of precedence, does something the cmdlet doesn't and then calls the fully-qualified cmdlet to do the rest - a simple way to extend functions. On the one hand you posted something using PInvoke, which I class as being developer stuff  - with some big modules and proxy functions to my name I don't have anywhere in my own code so I took you to be more of a developer than I am - and on the other you talk your abilities down with \"I'm just an admin scripter\". I think you may be under-estimating yourself.  But if it's too far outside your comfort zone then someone else needs to be persuaded to take the work on - which is where I came in. \r\n",
      "created_at": "2022-06-27T14:09:31Z",
      "updated_at": "2022-06-27T14:09:31Z"
    },
    {
      "author": "Jibun-no-Kage",
      "author_association": "NONE",
      "body": "@doctordns, of course now, revisiting the cmdlets of note, is unrealistic, by core PS development team.  If you read my previous comments, I never asked for re-development, only that what development was done at the time, was not great, or not maintained well to maintain parity.  These cmdlets are illustrative, of an issue that it should not be ignored, that a corner was cut, which I think was a bad decision, and at the risk of more book suggestions, pretty short sighted if not dumb.  This is, if nothing else is a learning opportunity, of how not to cut a corner going forward.\r\n\r\n@jhoneill , So, you are the one that gave me nightmares?!  I refer to the Windows 2000 exams.  The exams were no joke back in the day, when I took them.  :)  The odd thing was, after I completed Novell CNE certification, moved to Microsoft certification, only after I moved to Microsoft, I moved deep into virtualization, beta testing the original VMware 'ESX' server for a Fortune 10 that was a very early adopter of each type of virtualization in 2001 no less.  Oh, note I said 'ESX' not the later 'ESXi' solution, that should date me.  LOL... only to circle back to Hyper-V and then get very deep into KVM, which led to precursor LXC containers, then Docker.  But I digress.\r\n\r\n@TobiasPSP, I agree with you, in reference to the future direction of PS, I think PS should only tackle the specific and narrow focus that eco-system requires, meaning that what is developed is done very well with due consideration of the end-users use cases and needs, save scripters time and effort, please repeat 1000s times.  PS only exists to save time and effort, of scripters, IMHO.  I will re-affirm one of my past points... if you decide to include something in PS of today, do it right, consider parity as a key goal across the eco-system.  If you can't achieve extensive parity across the eco-system, and comparable for applicable existing options in each given OS, don't create a blind corner for scripters.  The question then is, is the specific candidate really worth the effort?  In that qualified mind-set, I doubt Restart-Computer/Stop-Computer would have ever been added to PS of the past, as an example.",
      "created_at": "2022-06-27T18:52:01Z",
      "updated_at": "2022-06-27T19:19:36Z"
    }
  ],
  "created_at": "2020-03-11T21:23:27Z",
  "number": 12106,
  "state": "closed",
  "title": "Add some shutdown.exe functionality into Restart-Computer/Stop-Computer",
  "updated_at": "2022-06-27T19:19:36Z"
}