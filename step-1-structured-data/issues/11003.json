{
  "_url": "https://github.com/PowerShell/PowerShell/issues/11003",
  "author": "KirkMunro",
  "body": "# PR Summary\r\n\r\nLike PR's #10984 and #10073, this PR enhances the splatting capabilities in PowerShell.\r\n\r\nWith this PR in place, users are able to splat members (properties and methods) as well as indexed items into an invocation. It doesn't matter how many levels deep you go with your expression.\r\n\r\nExamples:\r\n\r\n```powershell\r\n# Splat a property\r\nGet-Date @data.Parameters\r\n\r\n# Splat the results of a method\r\nGet-Date @data.GetParams()\r\n\r\n# Splat a nested property\r\nGet-Process @PSCmdlet.MyInvocation.BoundParameters\r\n\r\n# Splat a property from the result of a method\r\nTest-Splat @result.GetParameterSets().Value\r\n\r\n# Splat an item from a collection\r\nTest-Splat @parameterSet[0]\r\n```\r\n\r\nThe only question I have is whether or not this functionality needs to be behind an experimental feature. If you review the code changes, you'll see that adding this support was very, very easy, and I believe the changes are low risk, so I don't know that it is worth the added complexity of wrapping these in an experimental feature.\r\n\r\n## PR Context\r\n\r\nThis functionality has already been identified as desirable for PowerShell as part of [RFC0002](https://github.com/PowerShell/PowerShell-RFC/blob/e09b14fe01b636ea38260da9e70ff024dc32936b/2-Draft-Accepted/RFC0002-Generalized-Splatting.md).\r\n\r\n## PR Checklist\r\n\r\n- [X] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [X] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [X] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [X] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` or `[ WIP ]` to the beginning of the title (the `WIP` bot will keep its status check at `Pending` while the prefix is present) and remove the prefix when the PR is ready.\r\n- **[Breaking changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)**\r\n    - [X] None\r\n    - **OR**\r\n    - [ ] [Experimental feature(s) needed](https://github.com/MicrosoftDocs/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/About/about_Experimental_Features.md)\r\n        - [ ] Experimental feature name(s): <!-- Experimental feature name(s) here -->\r\n- **User-facing changes**\r\n    - [ ] Not Applicable\r\n    - **OR**\r\n    - [X] [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n- **Testing - New and feature**\r\n    - [ ] N/A or can only be tested interactively\r\n    - **OR**\r\n    - [X] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n- **Tooling**\r\n    - [X] I have considered the user experience from a tooling perspective and don't believe tooling will be impacted.\r\n    - **OR**\r\n    - [ ] I have considered the user experience from a tooling perspective and enumerated concerns in the summary. This may include:\r\n        - Impact on [PowerShell Editor Services](https://github.com/PowerShell/PowerShellEditorServices) which is used in the [PowerShell extension](https://github.com/PowerShell/vscode-powershell) for VSCode (which runs in a different PS Host).\r\n        - Impact on Completions (both in the console and in editors) - one of PowerShell's most powerful features.\r\n        - Impact on [PSScriptAnalyzer](https://github.com/PowerShell/PSScriptAnalyzer) (which provides linting & formatting in the editor extensions).\r\n        - Impact on [EditorSyntax](https://github.com/PowerShell/EditorSyntax) (which provides syntax highlighting with in VSCode, GitHub, and many other editors).\r\n",
  "closed_at": "2021-04-24T13:15:45Z",
  "comments": [
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@PoshChan please restart windows",
      "created_at": "2019-11-07T04:33:46Z",
      "updated_at": "2019-11-07T04:34:24Z"
    },
    {
      "author": "PoshChan",
      "author_association": "COLLABORATOR",
      "body": "@KirkMunro, successfully started retry of `PowerShell-CI-Windows`",
      "created_at": "2019-11-07T04:34:15Z",
      "updated_at": "2019-11-07T04:34:15Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "> I think it makes sense to add more tests that splatting (old and new) works (like Get-Date @DaTa and Get-Date @data.Parameters )\r\n\r\nAgreed. I added some basic splatting tests since we didn't have specific tests in place already.",
      "created_at": "2019-11-07T13:58:37Z",
      "updated_at": "2019-11-07T13:58:37Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@KirkMunro Please fix CIs failures.",
      "created_at": "2019-11-23T10:40:02Z",
      "updated_at": "2019-11-23T10:40:02Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@PoshChan please retry all",
      "created_at": "2019-11-23T13:46:34Z",
      "updated_at": "2019-11-23T13:46:34Z"
    },
    {
      "author": "PoshChan",
      "author_association": "COLLABORATOR",
      "body": "@KirkMunro, successfully started retry of `PowerShell-CI-static-analysis, PowerShell-CI-Windows, PowerShell-CI-macOS, PowerShell-CI-Linux`",
      "created_at": "2019-11-23T13:47:14Z",
      "updated_at": "2019-11-23T13:47:14Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Should we update RFC0002 for the syntax?",
      "created_at": "2019-11-28T05:26:55Z",
      "updated_at": "2019-11-28T05:26:55Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov Someone can if they want to. [I shared the syntax 3+ years ago, before that RFC was approved](https://github.com/PowerShell/PowerShell-RFC/issues/6#issuecomment-189517556), but @lzybkr didn't add it to the RFC at the time.",
      "created_at": "2019-11-28T20:53:34Z",
      "updated_at": "2019-11-28T20:53:34Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "@PowerShell/powershell-committee reviewed this, and while we don't see a technical risk or breaking change, we're having trouble coming up with a compelling, real-world scenario to justify adding it to the language. \r\n\r\nEspecially considering `Test-Splat @PSBoundParameters` works for the 3rd case, are there some scripting conveniences that can actually be gained from the other 4 examples you gave? In all the cases we could think of, what you have seems less clear than if you were to simply assign the value to another variable.",
      "created_at": "2019-12-11T23:35:03Z",
      "updated_at": "2019-12-11T23:35:03Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "The 3rd case is exactly the scenario where this is needed, because it doesn't always work. For example:\r\n\r\n```powershell\r\nfunction Test-Splat {\r\n    [CmdletBinding()]\r\n    param(\r\n        [parameter(mandatory)]\r\n        [string]\r\n        $Name\r\n    )\r\n    $sb = {Get-Service @PSBoundParameters}\r\n    & $sb\r\n}\r\nTest-Splat -Name wuauserv\r\n```\r\n\r\nIf you run that command, you'll get all services. Why? Because `$PSBoundParameters` variable is current scope only. So if you're using nested scopes or script blocks to reuse code within a function, and you want to splat in bound parameters, you cannot. You instead need to create an intermediate variable to store `$PSCmdlet.MyInvocation.BoundParameters` and then splat that variable, which is ironic given that I believe `$PSBoundParameters` was added to make parameter processing (and splatting of parameters) easier. I've had to use a temporary variable to achieve this many, many times in scripts and I continue to have to do it today. This is the most common scenario that drove me to add this to the language.\r\n\r\nAs a best practice, I don't use `$PSBoundParameters` in scripts because it is only accurate in the current scope, and I don't like minor refactoring risks to introduce unexpected issues so I use `$PSCmdlet.MyInvocation.BoundParameters` everywhere because it gives me consistency no matter where I use it, so I can refactor with confidence.\r\n\r\nHere is an example demonstrating what I would have to do instead if I wanted to make what I shared above work today:\r\n\r\n```powershell\r\nfunction Test-Splat {\r\n    [CmdletBinding()]\r\n    param(\r\n        [parameter(mandatory)]\r\n        [string]\r\n        $Name\r\n    )\r\n    $sb = {\r\n        $cmdletParams = $PSCmdlet.MyInvocation.BoundParameters\r\n        Get-Service @cmdletParams\r\n    }\r\n    & $sb\r\n}\r\nTest-Splat -Name wuauserv\r\n```\r\n\r\nThe use of intermediate variables here feels unnecessary and it's just extra code to maintain. I want to be able to accomplish the same like this:\r\n\r\n```powershell\r\nfunction Test-Splat {\r\n    [CmdletBinding()]\r\n    param(\r\n        [parameter(mandatory)]\r\n        [string]\r\n        $Name\r\n    )\r\n    $sb = {\r\n        Get-Service @PSCmdlet.MyInvocation.BoundParameters\r\n    }\r\n    & $sb\r\n}\r\nTest-Splat -Name wuauserv\r\n```\r\n\r\nThe other scenarios are added because it makes much more sense to me syntactically to be able to use the new syntax, which is very clear in intent, than to add an overly complex splat-subexpression syntax such as `@$($PSCmdlet.MyInvocation.BoundParameters)` to the language, as was suggested in the RFC.\r\n\r\nFurther, and quite important (so make sure you read/get this), these changes open the door for something else that is needed with splatting. One thing missing from splatting is the ability to perform a partial hashtable splat. Splat in one or more parameters, and only if they are present as keys in the hashtable. Splat in all parameters in the hashtable except for one or more parameters. Those scenarios (manipulating hashtables to get a subset hashtable easily without having to write complicated code) have benefits that extend beyond splatting and are useful elsewhere in scripts. By extending the splatting syntax to support member invocation and indices, we're opening the door for hashtable manipulation to be added independently of splatting, as it should be, such that splatting can just support it once it is added (maybe for free, maybe with a minor addition, depending on the syntax used for hashtable manipulation). If this is not clear, let me know and I'll go into more detail.\r\n\r\nThis need, and the justification for the syntax shared here, is crystal clear to me, keeping splatting focused on exactly what it was designed to do (take an array or a hashtable and splat those values into an invocation), while leveraging other current functionality (accessing members, accessing an indexed item) and new functionality (hashtable manipulation) using the same syntax that you would use elsewhere.\r\n\r\nPowerShell is object-oriented, with properties and methods, as well as indexable collections. When working with variables, we can access properties and methods and indexed items in collections with ease. Why should we have to use a different syntax to do so when splatting, or inject intermediate variables, when we can simply change a `$` before a variable name to a `@` and as a result be able to splat whatever that would return, in a more natural syntax that we're already familiar with, without having to use subexpressions where subexpressions are normally not required?\r\n\r\nFor some reason, when it comes to splatting improvements such as inline splatting and subexpression splatting and the discussions surrounding it, there seems to be a strong bias for new, obtuse syntax over syntax that maintains consistency with how things have already been written and used in PowerShell since v1, and I just don't get why. At any rate, I'll keep pushing improvements into the language the way I see them being most consistent and a best fit for what's already there, and this PR is an example of just that.",
      "created_at": "2019-12-12T16:28:57Z",
      "updated_at": "2019-12-15T01:01:07Z"
    },
    {
      "author": "dragonwolf83",
      "author_association": "NONE",
      "body": "Funny enough, I ran into this just the other day.\r\n\r\nWith the WinSCP PSModule there are parameters for HostName, Port, SshPrivateKeyPath, etc. They all match perfectly for Splatting. However, when you have multiple servers, you have to namespace them.\r\n\r\nIdeally, I would do this:\r\n```PowerShell\r\n$config = @{\r\n  QA = @{\r\n    Host = @{\r\n      HostName = 'abc'\r\n      Port = 22\r\n    }\r\n  Prod = @{\r\n    Host = @{\r\n      HostName = 'abc'\r\n      Port = 22\r\n    }\r\n  }\r\n}\r\n\r\nNew-WinSCPOption @config.QA.Host\r\nNew-WinSCPOption @config.Prod.Host\r\n```\r\n\r\nToday, I would have to store both of those configurations into another variable first to use them:\r\n```PowerShell\r\n$qaConfig = $config.QA.Host\r\n$prodConfig = $config.Prod.Host\r\n\r\nNew-WinSCPOption @qaConfig\r\nNew-WinSCPOption @prodConfig\r\n```\r\n\r\nIt just adds more work when I could have just splat directly to them. ",
      "created_at": "2019-12-14T23:46:14Z",
      "updated_at": "2019-12-14T23:46:14Z"
    },
    {
      "author": "adityapatwardhan",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee  Please re-review as the author has responded.",
      "created_at": "2020-04-13T18:59:44Z",
      "updated_at": "2020-04-13T18:59:44Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "@dragonwolf83 we in the @PowerShell/powershell-committee don't really understand why, in the 1st example where you set a variable for the params, is unclear\r\n\r\nUnfortunately, we didn't have @BrucePay today in our @PowerShell/powershell-committee meeting, would love to get his take as well: as @JamesWTruher raised, this is all very tied to the parameter binder, and he may have an opinion there. \r\n\r\nSimilarly, @KirkMunro, I'm really not seeing why the 2nd example is fundamentally more clear or concise to justify the additional complexity. I won't pretend to understand exactly in what way this is enabling future hashtable manipulation features, but we should establish first that those features are useful before leading with an implementation that we're not sure is a pre-requisite. You may have posted about those somewhere we haven't yet gotten to, but the value that said features would enable should be the front of the pipeline. ",
      "created_at": "2020-04-15T23:07:04Z",
      "updated_at": "2020-04-15T23:07:04Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee reviewed this, we are ok with the intent.  We ask that the tests be increased to cover multiple values rather than splatting a single value.",
      "created_at": "2020-04-29T22:52:03Z",
      "updated_at": "2020-04-29T22:52:03Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as Review Needed because it has been there has not been any activity for **7 days**.\nMainainer, Please provide feedback and/or mark it as `Waiting on Author`",
      "created_at": "2020-05-27T02:02:41Z",
      "updated_at": "2020-05-27T02:02:41Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "Closing. See https://github.com/PowerShell/PowerShell/pull/10238#issuecomment-826091414.",
      "created_at": "2021-04-24T13:15:45Z",
      "updated_at": "2021-04-24T13:15:45Z"
    }
  ],
  "created_at": "2019-11-06T22:53:39Z",
  "number": 11003,
  "state": "closed",
  "title": "Add property, method, and indexed item splatting support",
  "updated_at": "2021-04-24T13:15:45Z"
}