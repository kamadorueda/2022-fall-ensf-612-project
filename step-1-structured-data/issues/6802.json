{
  "_url": "https://github.com/PowerShell/PowerShell/issues/6802",
  "author": "mklement0",
  "body": "Note:\r\n\r\n* The behavior described below is _by design_  and has been in place since [member enumeration](https://blogs.msdn.microsoft.com/powershell/2012/06/13/new-v3-language-features/) was introduced in v3.\r\n\r\n  * While it's most likely too late to change this behavior, I'm offering my observations in the context of the \"PowerShell vZeroTechnicalDebt\" discussion - see #6745.\r\n\r\n* A request to officially document the _current_ behavior can be found [here](https://github.com/PowerShell/PowerShell-Docs/issues/2198), which arose out of the since-closed #6454.\r\n\r\n  * This is a follow-up to the latter to further clarify why the existing behavior is problematic.\r\n\r\n---\r\n\r\nCurrently, `<objOrCollection>.<member>` is equivalent to  \r\n`<objOrCollection> | ForEachObject { $_.<member> }`.\r\nThat is, _pipeline_ logic is applied when collecting the member values from a collection's _elements_:\r\n\r\n```powershell\r\n# A member collected from a single-element collection is unwrapped.\r\n# The following returns *scalar* 1:\r\nPS> (, @{ a = 1 }).a.GetType().Name\r\nInt32    # suggested alternative: (, 1) (single-element array)\r\n\r\n# Collecting array-valued members *concatenates* the arrays.\r\n# The following returns *flat* array 1, 2, 3, 4:\r\nPS> (@{ a = 1, 2 }, @{ a = 3, 4 }).a.Count\r\n4 # suggested alternative: (1, 2), (3, 4); a 2-element array containing the member arrays as-is\r\n```\r\n\r\nThe current behavior is problematic for the following reasons:\r\n\r\n* It is generally surprising that _pipeline_ logic is invisibly applied, given that member enumeration applies to _expression mode_ only.\r\n\r\n* Intuitively, one would expect member values to be _collected as-is_, not to be _concatenated_ if they happen to be array-valued.\r\n\r\n* The unwrapping of a single member value is especially counterintuitive in combination with `@(...)`:\r\n\r\n```powershell\r\n$objOrColl =  @{ Name = 'foo' }\r\n\r\n# Ensure that $objOrColl is *array*-valued with @(...) so that -like acts as an array *filter*.\r\n# Currently the use of .Name negates the effect of @(...):\r\n@($objOrColl).Name -like 'f*'\r\nTrue # !! LHS evaluated to a *scalar* and returns a Boolean rather than the intended 'foo'\r\n```\r\n\r\nEnclosing the _entire expression_ in `@(...)` solves the problem, but that's not obvious and shouldn't be necessary: `@($objOrColl.Name) -like 'f*'`\r\n\r\n---\r\n\r\nAdditionally, in the _no-input-object_ case, member enumeration returns `$null` rather than `[System.Management.Automation.Internal.AutomationNull]::Value`, which can also lead to surprising behavior:\r\n\r\n```powershell\r\n$pids = @((Get-Process *NoSuchProcess*).Id)\r\n```\r\n\r\nThe intuitive expectation is for `$pids` to contain an _empty array_, but, because `$null` was output by the member enumeration, the actual result is `@($null)`, i.e. a single-element array containing `$null`.\r\n\r\n\r\nEnvironment data\r\n----------------\r\n\r\nWritten as of:\r\n\r\n```powershell\r\nPowerShell Core v6.0.2\r\n```\r\n",
  "closed_at": null,
  "comments": [],
  "created_at": "2018-05-02T13:10:19Z",
  "labels": [
    "WG-Engine",
    "Issue-Discussion"
  ],
  "number": 6802,
  "state": "open",
  "title": "Member-access enumeration should not apply pipeline enumeration logic",
  "updated_at": "2022-10-05T15:05:06Z"
}