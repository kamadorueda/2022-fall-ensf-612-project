{
  "_url": "https://github.com/PowerShell/PowerShell/issues/12377",
  "author": "iRon7",
  "body": "There are several PowerShell scripts and cmdlets that support expressions (`ScriptBlocks`) as a parameter. A lot of these scripts are based native cmdlets (or 3rd party cmdlets that are based on native cmdlet) presuming passing expressions (or rebuilding expressions) is a general safe thing to do (but I question that).  \r\n\r\nThe [`Invoke-Expression is considered harmful`](https://devblogs.microsoft.com/powershell/invoke-expression-considered-harmful/) but that is [primarily about preventing *unintended* execution of code (code injection)](https://stackoverflow.com/a/56988348/1701026) but what about preventing against any deliberate malicious code injections?\r\n\r\nCmdlets that directly invoke commands/expressions (like `Start-Job`, `Invoke-Command`  and the Call Operator `&`) are quiet obvious  commands to exploit for an an attacker and a developer will probably focus on that but passing (or *partly* passing) a script to a calculated expression as e.g. the `Sort-Object` cmdlet could also be possibly exploit by a hacker (if not specially handled).\r\n\r\n**Example:**\r\nIn this example I build a `ScriptBlock` from a variable to give the user the possibly to select for a column to be sorted (a little cumbersome for this but the requirements are usually a lot more complex).\r\nCounter measurements are taken:\r\n* Against anybody tempering the PowerShell code by signing it and setting the related policies\r\n* Using `Import-PowerShellDataFile` to load the data\r\n\r\n```PowerShell\r\n$Data = ConvertFrom-Csv @'\r\nName,Value\r\nOne,1\r\nTwo,2\r\nThree,3\r\n'@\r\n\r\n$Sort = 'Name' # Retrieved via Import-PowerShellDataFile\r\nData | Sort ([ScriptBlock]::Create(\"`$_.$Sort\"))\r\n```\r\n\r\nAt the first look this code might look safe from malicious attacks but is ***not***.\r\nThru this code, a hacker might make changes to locations along with the file system, registry, etc. by injecting code via PowerShellDataFile which will change the `$Sort` variable to something like:\r\n\r\n```PowerShell\r\n $Sort = \"Name; 'Test' | Add-Content '.\\Test.txt';\"\r\n```\r\n\r\n* Is there any *common* way to **safely** pass expressions (or parts) to other cmdlets?\r\n* Is it possible to equip any of the existing commands that invoke expressions (like `Start-ThreadJob`) with a parameter that [Run Partially Trusted Code in a Sandbox](https://docs.microsoft.com/en-us/dotnet/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox), meaning that the only connection for that script with the outside world would be the input (parameters) and the output of the script?\r\n* Shouldn't cmdlets (like `Sort-Object`) have any standard mechanism that prevents tempering with the system? meaning that these (calculated) expressions are only allowed to supply an output to the concerned cmdlet and noting else...\r\n",
  "closed_at": "2020-04-20T14:07:25Z",
  "comments": [
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@iRon7 the general consensus in the community is to never use `[scriptblock]::Create()` or `Invoke-Expression` on any input that originates from somewhere the author does not have control over.\r\n\r\nGiven you have control over the string once it is loaded into a variable, I'd generally advise you verify the content of the string before you execute it as code.",
      "created_at": "2020-04-18T17:22:54Z",
      "updated_at": "2020-04-18T17:22:54Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> * Is there any _common_ way to **safely** pass expressions (or parts) to other cmdlets?\r\n\r\nIf you mean as text, you can use `Parser.ParseInput` to get an abstract syntax tree and analyze that (though if you're not already familar with the AST, it's very easy to miss something).  If you mean as a scriptblock, well as a command writer you can't really stop the caller from explicitly getting around best practices. As a sysadmin you can use applocker to enforce constrained language mode (to disable `[scriptblock]::Create()`) and restrict allowed commands.\r\n\r\n> * Is it possible to equip any of the existing commands that invoke expressions (like `Start-ThreadJob`) with a parameter that [Run Partially Trusted Code in a Sandbox](https://docs.microsoft.com/en-us/dotnet/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox), meaning that the only connection for that script with the outside world would be the input (parameters) and the output of the script?\r\n\r\nCAS isn't supported in core, but I also don't think that's a sandbox in the way you're thinking.\r\n\r\n> * Shouldn't cmdlets (like `Sort-Object`) have any standard mechanism that prevents tempering with the system? meaning that these (calculated) expressions are only allowed to supply an output to the concerned cmdlet and noting else...\r\n\r\nI'm not really sure what the benefit would be.  If the code has already made it into a scriptblock, one of these are true:\r\n\r\n1. The code is trusted\r\n1. The environment isn't locked down\r\n1. Trusted code is creating scriptblocks from arbitrary user input",
      "created_at": "2020-04-19T03:58:41Z",
      "updated_at": "2020-04-19T03:58:41Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "@vexx32, @SeeminglyScience, thank you for your responses.\r\n\r\n> the general consensus in the community is to never use `[scriptblock]::Create()` or `Invoke-Expression` on any input that originates from somewhere the author does not have control over.\r\n\r\n* The \"*community*\" should include developers writing (signed) scripts for enterprise companies and I am not so sure if they do recognize where their script might introduce a potential security hole for their company.\r\n* \"*... using `[scriptblock]::Create()`*\", <strike>the [`Invoke-Expression is considered harmful`](https://devblogs.microsoft.com/powershell/invoke-expression-considered-harmful/) but that is [primarily about preventing *unintended* execution of code (code injection)](https://stackoverflow.com/a/56988348/1701026). If it should take in account preventing against any deliberate malicious code injections, were does it differ from any other cmdlet/statement that invokes a command/script?</strike>.\r\nIt took me a while, but apparently the PowerShell security measurements against code injection emphasis on (not) fabricating a `[ScriptBlock]` rather than (securely) invoking them (that is where `Invoke-Expression` differs from other invitation methods and where the similarity with `[scriptblock]::Create()` is, where they both create script from a string.\r\n* \"*...any input that originates from somewhere the author does not have control over*\" if this is taken very strict, I guess this implies that you should only use hardcoded expressions. Meaning that if I want to make the example safe, I should change it to something like:\r\n\r\n```PowerShell\r\n$Sort = 'Name' # from Import-PowerShellDataFile .\\Configuration1.psd1\r\n$SortExpr = Switch ($Sort) {\r\n\t'Name' {{ $_.Name }}\r\n\t'Value' {{ $_.Value }}\r\n}\r\n$Data | Sort $SortExpr # (knowing that I can just do $Data | Sort $Sort, but that is not the point)\r\n```\r\n\r\nI am about to open a PSScriptAnalyzer `PSAvoidUsingScriptBlockCreate` \"*[ScriptBlock]::Create is used. Please remove [ScriptBlock]::Create from script and find other options instead*\" rule request for this as I like to conclude that for the same reason as **`PSAvoidUsingInvokeExpression`**,  `[ScriptBlock]::Create` should not be used as it fabricates a `[ScriptBlock]` based on input that ***either*** originates from somewhere the script author does not have control over **or could be a hardcoded as an expression `{ ... }` otherwise**.\r\nOr is this conclusion too short sighted?\r\n\r\nFor your background, I have a devops background and currently creating/maintaining some *reusable* PowerShell scripts and answering PowerShell question at StackOverflow for a hobby.  \r\nSome of these scripts have a `[ScriptBlock]` as a parameter, take [this stackoverflow example](https://stackoverflow.com/a/32890418/1701026):\r\n\r\n```PowerShell\r\nFunction Merge-Hashtables([ScriptBlock]$Operator) {\r\n    $Output = @{}\r\n    ForEach ($Hashtable in $Input) {\r\n        If ($Hashtable -is [Hashtable]) {\r\n            ForEach ($Key in $Hashtable.Keys) {$Output.$Key = If ($Output.ContainsKey($Key)) {@($Output.$Key) + $Hashtable.$Key} Else  {$Hashtable.$Key}}\r\n        }\r\n    }\r\n    If ($Operator) {ForEach ($Key in @($Output.Keys)) {$_ = @($Output.$Key); $Output.$Key = Invoke-Command $Operator}}\r\n    $Output\r\n}\r\n```\r\n\r\nSomehow I feel responsible of either:\r\n* Prevent the provided script coloring way outside the lines, meaning writing to the file system or registry where it is just supposed do nothing more than merging properties (in this case).\r\nOr:\r\n* Telling the user/developer/sysadmin that should never *use `[scriptblock]::Create()` or `Invoke-Expression` on any input that originates from somewhere the author does not have control over*, or better, refer to more formal drawer statement that also should apply to native cmdlets that have a `[ScriptBlock]`(or calculated expression) as a parameter.\r\n\r\nThe whole question actually arias from this [`ConvertTo-Expression` project](https://github.com/iRon7/ConvertTo-Expression) also related to this [How can I write a nested arbitrary associative Array value set to a .psd1 file in powershell?](https://stackoverflow.com/a/61301255/1701026) which does use `[scriptblock]::Create()` but I think it is actually safe by itself as it creates a `[ScriptBlock]` from an **object** and therefore the is output `[scriptblock]` is bound to just recreating the **object** (but I am not completely sure).\r\n\r\nAnyways, I have closed the request as it is clear (also after viewing the video at [PowerShell Security Best Practices](https://devblogs.microsoft.com/powershell/powershell-security-best-practices/) with the video recorded and available here: https://channel9.msdn.com/Events/Blue-Hat-Security-Briefings/BlueHat-Security-Briefings-Fall-2013-Sessions/PowerShell-Best-Practices) that there is no **way of** running partly trusted PowerShell code in a restricted security environment.\r\n\r\n\r\n<blockquote><img src=\"https://sec.ch9.ms/ch9/6293/6b23246a-31d5-4168-811c-1281ad1c6293/PowerShellBestPractices_960.jpg\" width=\"48\" align=\"right\"><div>Channel 9</div><div><strong><a href=\"https://channel9.msdn.com/Events/Blue-Hat-Security-Briefings/BlueHat-Security-Briefings-Fall-2013-Sessions/PowerShell-Best-Practices\">PowerShell Best Practices</a></strong></div><div>Microsoft's Lee Holmes talks about PowerShell operational security and PowerShell encrypting security in this BlueHat 2013 talk. Slides here:  https://blogs.msdn.microsoft.com/powershell/2013/12/16/po</div></blockquote>",
      "created_at": "2020-04-20T14:07:25Z",
      "updated_at": "2020-04-20T14:10:15Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> that there is no way of running partly trusted PowerShell code in a restricted security environment.\r\n\r\nYou might be interested in reading about [constrained language mode](https://devblogs.microsoft.com/powershell/powershell-constrained-language-mode/).",
      "created_at": "2020-04-20T15:06:32Z",
      "updated_at": "2020-04-20T15:06:32Z"
    },
    {
      "author": "PaulHigin",
      "author_association": "COLLABORATOR",
      "body": "@iRon7 \r\n\r\nPowerShell does provide a mechanism to distinguish between trusted and untrusted code.  But it pointless for PowerShell to protect against dangerous scripts if the rest of the system is wide open to an attacker.  That is why PowerShell ConstrainedLanguage mode was designed to work with system wide application control polices such as AppLocker and WDAC (https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/windows-defender-application-control).\r\n\r\nWhen a system is locked down by policy, PowerShell will run in ConstrainedLanguage mode which greatly restricts it.  Only script files approved by the policy will run in FullLanguage.\n\n<blockquote><img src=\"https://docs.microsoft.com/en-us/media/logos/logo-ms-social.png\" width=\"48\" align=\"right\"><div><strong><a href=\"https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/windows-defender-application-control\">Application Control for Windows - Windows security</a></strong></div><div>Application Control restricts which applications users are allowed to run and the code that runs in the system core.</div></blockquote>",
      "created_at": "2020-04-20T15:30:54Z",
      "updated_at": "2020-04-20T15:30:57Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> I am about to open a PSScriptAnalyzer `PSAvoidUsingScriptBlockCreate` \"_[ScriptBlock]::Create is used. Please remove [ScriptBlock]::Create from script and find other options instead_\" rule request for this as I like to conclude that for the same reason as **`PSAvoidUsingInvokeExpression`**, `[ScriptBlock]::Create` should not be used as it fabricates a `[ScriptBlock]` based on input that _**either**_ originates from somewhere the script author does not have control over **or could be a hardcoded as an expression `{ ... }` otherwise**.\r\n> Or is this conclusion too short sighted?\r\n\r\nIt should work similar to the `Invoke-Expression` rule yeah.  Using `[scriptblock]::Create` instead of `Invoke-Expression` to get around the rule is a bit like using `$Host.UI.Write` instead of `Write-Host`.  Same thing in a different suit.\r\n\r\n> Somehow I feel responsible of either:\r\n> \r\n> * Prevent the provided script coloring way outside the lines, meaning writing to the file system or registry where it is just supposed do nothing more than merging properties (in this case).\r\n\r\nWhy would you need to though?  If they want to write to the registry while they're sorting why stop them?  If the caller creates a scriptblock, it's created in their security context/language mode/etc. If they load untrusted arbitrary code explicitly into that context just to sort then that sucks but it's not your responsibility.\r\n\r\n> * Telling the user/developer/sysadmin that should never _use `[scriptblock]::Create()` or `Invoke-Expression` on any input that originates from somewhere the author does not have control over_, or better, refer to more formal drawer statement that also should apply to native cmdlets that have a `[ScriptBlock]`(or calculated expression) as a parameter.\r\n\r\nIt's up to you how much you want to go out of your way to educate the consumer of your module, but the same applies to any built in command that takes a scriptblock.  Really it applies to most things, don't load code you don't trust, period.  You don't really need to tell the user this just like you don't need to tell them not to hard code a password when you accept a `SecureString`.\r\n\r\n> The whole question actually arias from this [`ConvertTo-Expression` project](https://github.com/iRon7/ConvertTo-Expression) also related to this [How can I write a nested arbitrary associative Array value set to a .psd1 file in powershell?](https://stackoverflow.com/a/61301255/1701026) which does use `[scriptblock]::Create()` but I think it is actually safe by itself as it creates a `[ScriptBlock]` from an **object** and therefore the is output `[scriptblock]` is bound to just recreating the **object** (but I am not completely sure).\r\n\r\n\r\nI didn't fully analyze it but it can be safe as long as you account for things breaking out of the string.  e.g.\r\n\r\n```powershell\r\nclass MyNastyObject {\r\n    [string] ToString() { return @'\r\n'; Invoke-Something; '\r\n'@\r\n}\r\n```\r\n\r\nOne way would be to parse the script string you generate before creating the `scriptblock` and use an `AstVisitor` to ensure that there's nothing other than `ConstantExpressionAst` and `StringConstantExpressionAst` (with a `StringConstantKind` of `SingleQuote`) present.\r\n\r\nAlso I'm not 100% sure why you'd want to do this.  I could understand returning a `string` that someone could copy and paste into a script, but I'm not 100% sure why it needs to be a scriptblock",
      "created_at": "2020-04-20T15:32:52Z",
      "updated_at": "2020-04-20T15:35:45Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "I'm not sure if there's a public way to do this, but module manifests today are executed in Restricted Language Mode to read them in. That forbids anything non constant. There's also the `SafeGetValue()` API. Also there are the value building visitors designed precisely to take PowerShell ASTs and safely convert them to values:\r\n\r\nhttps://github.com/PowerShell/PowerShell/blob/c41c39be2a172440f8efd57baa0c9a596df76326/src/System.Management.Automation/engine/parser/ConstantValues.cs#L324-L570\r\n\r\nhttps://github.com/PowerShell/PowerShell/blob/c41c39be2a172440f8efd57baa0c9a596df76326/src/System.Management.Automation/engine/parser/SafeValues.cs#L353-L801\r\n\r\n[There's also an alternative implementation in PSScriptAnalyzer](https://github.com/PowerShell/PSScriptAnalyzer/blob/9098e76a32e31f3ef73f1d513a706dbb9fbe57a1/Engine/Helper.cs#L1856-L2035)",
      "created_at": "2020-04-20T19:42:44Z",
      "updated_at": "2020-04-20T19:42:44Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "Also https://github.com/PowerShell/PowerShell/issues/11300 is related to your original use case",
      "created_at": "2020-04-20T23:45:35Z",
      "updated_at": "2020-04-20T23:45:35Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "@SeeminglyScience \r\n\r\n> Also I'm not 100% sure why you'd want to do this. I could understand returning a string that someone could copy and paste into a script, but I'm not 100% sure why it needs to be a scriptblock\r\n\r\nThanks for the hint, I have updated my [ConvertTo-Expression](https://www.powershellgallery.com/packages?q=convertto-expression) script so that it returns a expression in the form of a `[String]`. All potential statements that can be exploit for code injections are removed and checked for with [https://devblogs.microsoft.com/powershell/powershell-injection-hunter-security-auditing-for-powershell-scripts/](https://devblogs.microsoft.com/powershell/powershell-injection-hunter-security-auditing-for-powershell-scripts/)\n\n<blockquote><img src=\"https://devblogs.microsoft.com/powershell/wp-content/uploads/sites/30/2018/08/defcon_header.png\" width=\"48\" align=\"right\"><div><img src=\"https://devblogs.microsoft.com/powershell/wp-content/uploads/sites/30/2019/02/Powershell_2561.png\" height=\"14\"> PowerShell</div><div><strong><a href=\"https://devblogs.microsoft.com/powershell/powershell-injection-hunter-security-auditing-for-powershell-scripts/\">PowerShell Injection Hunter: Security Auditing for PowerShell Scripts | PowerShell</a></strong></div><div>At the DEFCON security conference last year, we presented the session: \u201cGet $pwnd: Attacking Battle Hardened Windows Server\u201c. \nIn this talk, we went through some of the incredibly powerful ways that administrators can secure their high-value systems (for example, Just Enough Administration) and also dove into some of the mistakes that administrators sometimes make when exposing their PowerShell code to an attacker.</div></blockquote>",
      "created_at": "2020-05-11T11:10:07Z",
      "updated_at": "2020-05-11T11:10:15Z"
    }
  ],
  "created_at": "2020-04-18T15:32:28Z",
  "labels": [
    "Issue-Enhancement"
  ],
  "number": 12377,
  "state": "closed",
  "title": "Running partly trusted PowerShell code in a restricted security environment.",
  "updated_at": "2020-05-11T11:10:15Z"
}