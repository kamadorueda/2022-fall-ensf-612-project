{
  "_url": "https://github.com/PowerShell/PowerShell/issues/17058",
  "author": "MatejKafka",
  "body": "### Summary of the new feature / enhancement\r\n\r\nTL;DR: I want to prompt user for input from a runspace, which I'm using to isolate a running script.\r\n\r\n**Context:**\r\nAs part of a larger project, I'm executing PowerShell scripts, which may be distributed between machines with different PowerShell configurations. To make the environment more consistent, I'm running the scripts using `Start-Job ... | Receive-Job -Wait`, and inside the job, I set `$PSModuleAutoLoadingPreference` to `\"None\"` and explicitly import a few built-in modules. That way, the scripts behave the same even if user overrides a cmdlet with a different implementation, registers a conflicting alias or forgets about a hidden dependency on an installed module.\r\n\r\nHowever, for this usecase, PowerShell jobs has a needlessly large overhead of creating a full new PowerShell instance, which takes a few hundred milliseconds on my machine. This is why I started looking into using runspaces instead, which have better startup and can share live objects with the main runspace.\r\n\r\n---\r\n\r\n**Issue:**\r\nHowever, some of the scripts require interactive input from the user using `Read-Host` and `$Host.UI.PromptForChoice(...)`. When a job is used and received with `Receive-Job -Wait`, these interactive cmdlets work correctly and user can respond. However, when running under a runspace, the Host is not interactive and the following error is thrown:\r\n```\r\nA command that prompts the user failed because the host program or the command type does not support user interaction. Try a host program that supports user interaction, such as the PowerShell Console, and remove prompt-related commands from command types that do not support user interaction.\r\n```\r\n\r\nFrom my understanding, it should be easier to implement interactivity for runspaces than it was for jobs, given that runspaces run in the same process. At the same time, this would bring `ForEach-Object -Parallel`, which uses runspaces internally, a bit closer to ordinary script blocks in terms of features.\r\n\r\n### Proposed technical implementation details (optional)\r\n\r\nCurrently, I figured out this terrible workaround, which works, but it's brittle and hacky:\r\n\r\n```powershell\r\n# % -Parallel is used because it internally handles many ugly details of working with runspaces,\r\n#  no actual parallelism is done :)\r\n% -Parallel {\r\n    sleep 1 # some work\r\n    # send a prompt request \u2013 a tuple containing our runspace, and a prompt message\r\n    ,@([runspace]::DefaultRunspace, \"Tell me something\")\r\n    # we now need to block and wait until the user enters something; a wait on a custom event seems the easiest for this demo\r\n    $response = (Wait-Event -SourceIdentifier \"HostInput\").MessageData\r\n    # we got a response, print it out\r\n    echo \"Response: $response\"\r\n    sleep 1 # more work\r\n} | % {\r\n    if (@($_).Count -ne 2 -or $_[0] -isnot [runspace]) {\r\n        return $_ # not a prompt request, forward the data to the output\r\n    }\r\n    $rs, $prompt = $_\r\n    $response = Read-Host -Prompt $prompt\r\n    # trigger an event, which wakes up the runspace, and send the response\r\n    $null = $rs.Events.GenerateEvent(\"HostInput\", $null, $null, $response)\r\n}\r\n```\r\n\r\nIf you do not wish to implement full interactivity for runspaces, I'm open to less hacky solutions in a similar spirit. :)",
  "closed_at": null,
  "comments": [
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "Just as an FYI Runspace is a bit of a misleading term to use here. Actual Runspaces can definitely have an interactive host associated that can be used as you would interactively. For example I have a runspace pool that will run my scripts and each of those can access `$host` and it's various methods.\r\n\r\n```powershell\r\n$rp = [RunspaceFactory]::CreateRunspacePool(1, 4, $host)\r\n$rp.Open()\r\n1..4 | ForEach-Object -Parallel {\r\n    $ps = [PowerShell]::Create()\r\n    $ps.RunspacePool = $using:rp\r\n    $ps.AddScript('$host.UI.WriteLine(\"$($args[0])\" * 10)').AddArgument($_) | Out-Null\r\n    $ps.Invoke()\r\n}\r\n$rp.Dispose()\r\n```\r\n\r\nThe problem you are facing here is that `ForEach-Object -Parallel` (what I'm assuming what you mean by Runspaces) is that PowerShell does not associate a PSHost with each pipeline run. It's a simple enough hack to get it working though\r\n\r\n```powershell\r\n1..4 | ForEach-Object -Parallel {\r\n    $psHost = $using:host\r\n    $psHost.UI.WriteLine(\"$_\" * 10)\r\n}\r\n````\r\n\r\nIt won't enable cmdlets like `Read-Host` to work as is but you can still do the raw calls through the passed in `$host` instance from the parent. Asking for input in parallel is going to be dicey though as the input will most likely clobber each other causing problems. If you do want to do this you will need some sort of lock around the calls to ensure they are only running 1 at a time. You hack essentially does the same thing as the caller is running synchronously and is responding to each input request as they come in. An example of what I mean by using a lock.\r\n\r\n```powershell\r\n$lock = [System.Threading.SemaphoreSlim]::new(1)\r\n1..4 | ForEach-Object -Parallel {\r\n    $psHost = $using:host\r\n    $lock = $using:lock\r\n\r\n    $lock.Wait()\r\n    try {\r\n        $psHost.UI.WriteLine(\"Tell me something for $_\")\r\n        \"{0} - {1}\" -f $_, $psHost.UI.ReadLine()\r\n    }\r\n    finally {\r\n        $lock.Release() | Out-Null\r\n    }\r\n}\r\n```\r\n\r\nAt a guess this concurrency is part of the reason why the host isn't associated with a parallel pipeline.",
      "created_at": "2022-03-24T05:58:11Z",
      "updated_at": "2022-03-24T06:02:45Z"
    },
    {
      "author": "MatejKafka",
      "author_association": "NONE",
      "body": "Thanks, that makes sense. The reason why I mostly focused on `% -Parallel` is that getting a script running inside a runspace to behave \"normally\" (mainly, having live, interleaved output streams and correctly propagated exceptions) seems quite non-trivial (happy to be proven wrong), while these issues are already solved for `% -Parallel`.\r\n\r\nFor some reason, it didn't occur to me that I can use `$using:Host` inside the runspace. I'm only running a single script at a time, so this approach should be OK, and I can write a good-enough polyfill for `Read-Host`, which should be enough.\r\n\r\nBtw, I didn't ask in the original message, but is there a more \"officially supported\" / intended way to run a script in a fresh environment (e.g. no loaded modules, no global variables from calling session,...), while preserving most features of direct execution (interactivity, non-serialized types, low overhead,...)? All proposed solutions work, but they still seem like a bit of a misuse of both jobs and runspaces, so I'm curious if there's a better way. :)",
      "created_at": "2022-03-24T15:42:57Z",
      "updated_at": "2022-03-24T15:45:02Z"
    }
  ],
  "created_at": "2022-03-24T00:15:13Z",
  "number": 17058,
  "state": "open",
  "title": "Implement interactive cmdlets like `Read-Host` for runspaces",
  "updated_at": "2022-03-24T15:45:02Z"
}