{
  "_url": "https://github.com/PowerShell/PowerShell/issues/14348",
  "author": "escservices",
  "body": "After upgrading my script to from Powershell 7.0.3 to 7.1 whenever I use invoke-webrequest and do a clear-host it still leaves the following data in the console.\r\n\r\nWeb request status \r\nWeb request completed. (Number of bytes processed: 9738485) \r\n\r\nThis is a part of a larger script that is proprietary, I removed some info from the script for privacy but the example I provided should provide enough insight into the issue.  Anywhere an invoke-webrequest is used, this issue occurs, I just used Ethr as an example.\r\n\r\n<!--\r\n\r\nFor Windows PowerShell 5.1 issues, suggestions, or feature requests please use the following link instead:\r\nWindows PowerShell [UserVoice](https://windowsserver.uservoice.com/forums/301869-powershell)\r\n\r\nThis repository is **ONLY** for PowerShell Core 6 and PowerShell 7+ issues.\r\n\r\n- Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\r\n- Search the existing issues.\r\n- Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\r\n- Refer to the [known issues](https://docs.microsoft.com/powershell/scripting/whats-new/known-issues-ps6).\r\n\r\n-->\r\n\r\n## Steps to reproduce\r\n\r\n```powershell\r\n\r\nFunction Build-Menu (){\r\n    \r\n    Param(\r\n        [Parameter(Mandatory=$True)][String]$MenuTitle,\r\n        [Parameter(Mandatory=$True)][array]$MenuOptions\r\n    )\r\n\r\n    $MaxValue = $MenuOptions.count-1\r\n    $Selection = 0\r\n    $EnterPressed = $False\r\n    \r\n    Clear-Host\r\n\r\n    While($EnterPressed -eq $False){\r\n        $MenuTitleLength = ($MenuTitle | Measure-Object -Character).Characters\r\n        if ($MenuTitleLength -eq 16) {\r\n            $Space = 7\r\n        }\r\n        if ($MenuTitleLength -gt 16) {\r\n        $Difference = ($MenuTitleLength - 16)\r\n        $Space = (7 - $Difference)\r\n\r\n        } else {\r\n            $Difference = (16 - $MenuTitleLength)\r\n            $Space = (7 + $Difference)\r\n        }\r\n        $MenuTitleValue = \"::       $MenuTitle\" + \" \" * $Space + \"::\"\r\n        Clear-Host\r\n        Write-Host \"::::::::::::::::::::::::::::::::::\"\r\n        Write-Host -ForegroundColor Green \"::       Demo System       ::\"\r\n        Write-Host -ForegroundColor White \"$MenuTitleValue\"\r\n        Write-Host \"::::::::::::::::::::::::::::::::::\"\r\n        Write-Host \"\"\r\n\r\n        For ($i=0; $i -le $MaxValue; $i++){\r\n            \r\n            If ($i -eq $Selection){\r\n                Write-Host -BackgroundColor Cyan -ForegroundColor Black \"[ $($MenuOptions[$i]) ]\"\r\n            } Else {\r\n                Write-Host \"  $($MenuOptions[$i])  \"\r\n            }\r\n\r\n        }\r\n\r\n        $KeyInput = $host.ui.rawui.readkey(\"NoEcho,IncludeKeyDown\").virtualkeycode\r\n\r\n        Switch($KeyInput){\r\n            13{\r\n                $EnterPressed = $True\r\n                Return $Selection\r\n                Clear-Host\r\n                break\r\n            }\r\n\r\n            38{\r\n                If ($Selection -eq 0){\r\n                    $Selection = $MaxValue\r\n                } Else {\r\n                    $Selection -= 1\r\n                }\r\n                Clear-Host\r\n                break\r\n            }\r\n\r\n            40{\r\n                If ($Selection -eq $MaxValue){\r\n                    $Selection = 0\r\n                } Else {\r\n                    $Selection +=1\r\n                }\r\n                Clear-Host\r\n                break\r\n            }\r\n            Default{\r\n                Clear-Host\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\nfunction Get-File($filename,$url,$outpath,$alturl) {\r\n    Clear-Host\r\n    Write-Host \"Downloading\" $filename\"...\"\r\n    try {\r\n        if ($alturl) {\r\n            try {\r\n                Invoke-WebRequest -Uri $url -OutFile $outpath\r\n            } catch {\r\n                Invoke-WebRequest -Uri $alturl -OutFile $outpath\r\n            }\r\n        }\r\n        else {\r\n            Invoke-WebRequest -Uri $url -OutFile $outpath\r\n        }\r\n        Write-Host $filename \"has downloaded!\"\r\n    } catch {\r\n        Write-Host -ForegroundColor Red $filename \"download failed!\"\r\n    }\r\n}\r\n\r\ndo {\r\n                    $MenuArray = @(\r\n                        \"Run SpeedTest\",\r\n                        \"Show Network Share Info\", \r\n                        \"Get Users Mapped Shares\",\r\n                        \"Run Lan SpeedTest (iperf)\",\r\n                        \"Run Advanced IP Scanner\",\r\n                        \"Run WOL (Wake On LAN) Utility\",\r\n                        \"Use Ethr\",\r\n                        \"Exit\"\r\n                    )\r\n                    Clear-Host\r\n                    $MenuChoice = Build-Menu -MenuTitle \"Network Tools\" -MenuOptions $MenuArray\r\n                    #Header -MenuTitle \"Network Tools\" -Menu $MenuArray -Confirm $True\r\n\r\n                    if ($MenuChoice -eq '0') {\r\n                        Clear-Host\r\n                        Get-File -filename \"SpeedTest\" -url \"#\" -outpath \"C:\\Flexible-Toolkit\\SpeedTest.exe\" -alturl \"#\"\r\n                        if (Test-Path -Path \"C:\\Flexible-Toolkit\\SpeedTest\") {\r\n                            Remove-Item -Path \"C:\\Flexible-Toolkit\\SpeedTest\\\" -Recurse -Force\r\n                            Clear-Host\r\n                        }\r\n                        Unblock-File \"C:\\Flexible-Toolkit\\speedtest.exe\" -ErrorAction SilentlyContinue\r\n                        C:\\Flexible-Toolkit\\speedtest.exe --accept-license\r\n                        Write-Host -ForegroundColor Green \"Press Enter to continue.\"\r\n                        Read-Host | Out-Null\r\n                        Remove-Item -Path \"C:\\Flexible-Toolkit\\SpeedTest.exe\" -Force\r\n                    }\r\n\r\n                    if ($MenuChoice -eq '1') {\r\n                        if($Legacy -eq \"false\") {\r\n                            Clear-Host\r\n                            Write-Host -ForegroundColor White \"Shares on this device\"\r\n                            Write-Host \"-------------------------------------------\"\r\n                            Write-Host \"\"\r\n                            Get-SmbShare | Select-Object Name, Path, Description | Format-Table\r\n                            Write-Host \"-------------------------------------------\"\r\n                            Write-Host -ForegroundColor White \"Active sessions on device (Outbound)\"\r\n                            Write-Host \"\"\r\n                            Get-SmbConnection | Select-Object ServerName, ShareName, UserName, Credential, NumOpens | Format-Table\r\n                            Write-Host -ForegroundColor White \"Users connected to this device (Inbound)\"\r\n                            Get-SmbSession | Format-Table\r\n                            Write-Host \"-------------------------------------------\"\r\n                            Write-Host -ForegroundColor White \"Open Files (Inbound)\"\r\n                            Write-Host \"\"\r\n                            Get-SmbOpenFile | Format-Table\r\n                            Write-Host \"\"\r\n                        } else {\r\n                            Clear-Host\r\n                            Write-Host -ForegroundColor Red \"Not supported on this OS.\"\r\n                        }\r\n                        Write-Host \"-------------------------------------------\"\r\n                        Write-Host -ForegroundColor Green \"Press Enter to continue.\"\r\n                        Read-Host | Out-Null\r\n                        \r\n                    }\r\n\r\n                    if ($MenuChoice -eq '2') {\r\n                        do {\r\n                            Clear-Host\r\n                            $Username = Read-Host \"Enter Username \"\r\n                            $isDomain = Read-Host \"Is this a domain account?\" \"[Y / N]\"\r\n                            if ($isDomain -eq 'y') {\r\n                                $domain = Read-Host \"What is the domain? (DO NOT incude .local,.com etc...)\"\r\n                            }\r\n                            $areSure = Read-Host \"Username = $Username. Are you sure?\" \"[Y / N]\"\r\n                        } while ($areSure -ne 'y')\r\n                        if ($isDomain -eq 'y') {\r\n                            #$domain = (Get-WmiObject Win32_NTDomain).DomainName\r\n                            $domain = $domain\r\n                        }\r\n                        else {\r\n                            $domain = $env:computername\r\n                        }\r\n                        $TargetKey = ([wmi] \"win32_userAccount.Domain='$domain',Name='$Username'\").sid\r\n                        Write-Host \"Users Profile Key = $TargetKey\"\r\n                        Clear-Host\r\n                        if (Test-Path -Path \"REGISTRY::HKEY_USERS\\$TargetKey\\Network\\\") {\r\n                            Write-Host -ForegroundColor Green \"Below are the drives the user has mapped manually.\"\r\n                            Get-ChildItem \"REGISTRY::HKEY_USERS\\$TargetKey\\Network\\\" -Recurse | Format-Table\r\n                            if ($Legacy -eq \"false\") {\r\n                                Write-Host -ForegroundColor Green \"Below are the drives that were automatically mapped for the user/system.\"\r\n                                $systemMapped = (Get-CimInstance Win32_MappedLogicalDisk | Select-Object name, providername) | out-string\r\n                                Write-Host $systemMapped\r\n                            }\r\n                            Write-Host -ForegroundColor Green \"Please see $Username's mapped drives above.\"\r\n                            Write-Host -ForegroundColor Green \"If there's nothing above the user may not have mapped drives.\"\r\n                        } \r\n                        else {\r\n                            Write-Host -ForegroundColor Red \"Profile not found.\"\r\n                            if($Legacy -eq \"false\") {\r\n                                Write-Host -ForegroundColor Red \"However we listed any mapped drives that might have been added automatically for the user/system below.\"\r\n                                $systemMapped = (Get-CimInstance Win32_MappedLogicalDisk | Select-Object name, providername) | out-string\r\n                                Write-Host $systemMapped\r\n                            }\r\n                        }\r\n                        Write-Host -ForegroundColor Green \"Press Enter to continue.\"\r\n                        Read-Host | Out-Null\r\n                    }\r\n\r\n                    if ($MenuChoice -eq '3') {\r\n                        Clear-Host\r\n                        Get-File -filename \"iperf3\" -url \"https://iperf.fr/download/windows/iperf-3.1.3-win64.zip\" -outpath \"C:\\Flexible-Toolkit\\iperf-3.1.3-win64.zip\"\r\n                        Expand-Archive -Path \"C:\\Flexible-Toolkit\\iperf-3.1.3-win64.zip\" -DestinationPath \"C:\\Flexible-Toolkit\\\" -Force\r\n                        Write-Host \"iperf3 Downloaded\"\r\n                        Clear-Host\r\n                        do{\r\n                            $MenuArray = @(\r\n                                \"Setup Target (Destination)\",\r\n                                \"Initiate Test to Target (Source)\", \r\n                                \"Exit\"\r\n                            )\r\n                            Clear-Host\r\n                            $MenuChoice = Build-Menu -MenuTitle \"LAN SpeedTest Tools\" -MenuOptions $MenuArray\r\n                            #Header -MenuTitle \"LAN SpeedTest Tools\" -Menu $MenuArray -Confirm $True\r\n\r\n                            if ($MenuChoice -eq '0') {\r\n                                Clear-Host\r\n                                Start-Process \"C:\\Flexible-Toolkit\\iperf-3.1.3-win64\\iperf3.exe\" -ArgumentList \"-s\"\r\n                                Write-Host -ForegroundColor Green \"A new window should have launched with the tool running.\"\r\n                                Write-Host -ForegroundColor Green \"This device is now ready to take connections from the Source Device.\"\r\n                                Write-Host -ForegroundColor Green \"You now need to run this script on the Source device and initiate the test.\"\r\n                                Write-Host -ForegroundColor Red \"Do NOT press continue until you are done with the test as it will delete required files.\"\r\n                                Write-Host -ForegroundColor Green \"Press Enter to continue.\"\r\n                                Read-Host | Out-Null\r\n                                Stop-Process -Name \"iperf3\" -Force\r\n                            }\r\n\r\n                            if ($MenuChoice -eq '1') {\r\n                                Clear-Host\r\n                                $localIP = Read-Host (\"Enter IP address of target/destination device \")\r\n                                C:\\Flexible-Toolkit\\iperf-3.1.3-win64\\iperf3.exe -c $localIP\r\n                                Write-Host -ForegroundColor Red \"Do Not press continue until you are done with the test as it will delete required files.\"\r\n                                Write-Host -ForegroundColor Green \"Press Enter to continue.\"\r\n                                Read-Host | Out-Null\r\n                            }\r\n\r\n                        } while ($MenuChoice -ne (($MenuArray.Length -1).ToString()))\r\n                        $MenuChoice = $null\r\n                    }\r\n\r\n                    if ($MenuChoice -eq '4') {\r\n                        Clear-Host\r\n                        Get-File -filename \"Advanced IP Scanner\" -url \"https://www.advanced-ip-scanner.com/download/Advanced_IP_Scanner_2.5.3850.exe\" -outpath \"C:\\Flexible-Toolkit\\AdvancedIPScanner.exe\"\r\n                        Start-Process -FilePath \"C:\\Flexible-Toolkit\\AdvancedIPScanner.exe\"\r\n                        Write-Host -ForegroundColor Green \"Advanced IP Scanner should be running.\"\r\n                        Write-Host -ForegroundColor Green \"Press Enter to continue.\"\r\n                        Read-Host | Out-Null\r\n                    }\r\n\r\n                    if ($MenuChoice -eq '5') {\r\n                        Clear-Host\r\n                        Get-File -filename \"WOL.exe Utility\" -url \"#\" -outpath \"C:\\Flexible-Toolkit\\WOL.exe\"\r\n                        Clear-Host\r\n                        $WOLMacAddress = Read-Host \"Enter the MAC Address of the offline machine\"\r\n                        C:\\Flexible-Toolkit\\WOL.exe $WOLMacAddress\r\n                        Write-Host -ForegroundColor Green \"Press Enter to continue.\"\r\n                        Read-Host | Out-Null\r\n                    }\r\n\r\n                    if ($MenuChoice -eq '6') {\r\n                        Clear-Host\r\n                        Get-File -filename \"Ethr\" -url \"https://github.com/microsoft/ethr/releases/latest/download/ethr_windows.zip\" -outpath \"C:\\Flexible-Toolkit\\ethr.zip\"\r\n                        Expand-Archive -Path \"C:\\Flexible-Toolkit\\ethr.zip\" -DestinationPath \"C:\\Flexible-Toolkit\\\" -Force\r\n                        Write-Host \"Ethr Downloaded\"\r\n                        Clear-Host\r\n                        do{\r\n                            $MenuArray = @(\r\n                                \"Setup Server (Destination)\",\r\n                                \"Setup Client (Source)\",\r\n                                \"Measure TCP Connection Setup Latency to Website\",\r\n                                \"Measure ICMP ping latency to Website\",\r\n                                \"Exit\"\r\n                            )\r\n                            Clear-Host\r\n                            $MenuChoice = Build-Menu -MenuTitle \"Ethr Menu\" -MenuOptions $MenuArray\r\n                            #Header -MenuTitle \"LAN SpeedTest Tools\" -Menu $MenuArray -Confirm $True\r\n\r\n                            if ($MenuChoice -eq '0') {\r\n                                Clear-Host\r\n                                Start-Process -FilePath \"powershell.exe\" -ArgumentList 'C:\\Flexible-Toolkit\\ethr.exe -s -ui'\r\n                                Write-Host -ForegroundColor Green \"A new window should have launched with the tool running.\"\r\n                                Write-Host -ForegroundColor Green \"This device is now ready to take connections from the client device.\"\r\n                                Write-Host -ForegroundColor Green \"You now need to run this script on the client device and initiate the test.\"\r\n                                Write-Host -ForegroundColor Red \"Do NOT press continue until you are done with the test as it will delete required files.\"\r\n                                Write-Host -ForegroundColor Green \"Press Enter to continue.\"\r\n                                Read-Host | Out-Null\r\n                                Stop-Process -Name \"ethr\" -Force\r\n                            }\r\n\r\n                            if ($MenuChoice -eq '1') {\r\n                                Clear-Host\r\n                                $localIP = Read-Host (\"Enter IP address of the device running Ethr server\")\r\n                                Start-Process -FilePath \"powershell.exe\" -ArgumentList 'C:\\Flexible-Toolkit\\ethr.exe -s -ui' $localIP\r\n                                Write-Host -ForegroundColor Red \"Do Not press continue until you are done with the test as it will delete required files.\"\r\n                                Write-Host -ForegroundColor Green \"Press Enter to continue.\"\r\n                                Read-Host | Out-Null\r\n                            }\r\n\r\n                        } while ($MenuChoice -ne (($MenuArray.Length -1).ToString()))\r\n                        $MenuChoice = $null\r\n                    }\r\n\r\n\r\n                } while ($MenuChoice -ne (($MenuArray.Length -1).ToString()))\r\n                $MenuChoice = $null\r\n\r\n\r\n```\r\n\r\n## Expected behavior\r\n\r\n```none\r\nLaunch script, select \"Use Ethr\" downloads file, clears screen, and builds a new menu. (This is from PWSH v7.0.3)\r\n```\r\n![image](https://user-images.githubusercontent.com/1287511/101519660-73087380-3951-11eb-9503-d79816f82f9a.png)\r\n![image](https://user-images.githubusercontent.com/1287511/101519674-769bfa80-3951-11eb-882a-2f68af77cabe.png)\r\n\r\n\r\n## Actual behavior\r\n\r\n```none\r\nLaunch script, select \"Use Ethr\" downloads file, screen doesn't fully clear and menu gets messed up.  If you press any keys it expands the window (seen in screenshot 3).\r\n```\r\n![image](https://user-images.githubusercontent.com/1287511/101519812-9e8b5e00-3951-11eb-9642-242ed00aa74b.png)\r\n![image](https://user-images.githubusercontent.com/1287511/101519821-a0edb800-3951-11eb-91c8-a1bfea015900.png)\r\n![image](https://user-images.githubusercontent.com/1287511/101519870-b236c480-3951-11eb-8c3f-38b5ce4170a7.png)\r\n\r\n## Environment data\r\n\r\n<!-- provide the output of $PSVersionTable -->\r\n\r\n```none\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.1.0\r\nPSEdition                      Core\r\nGitCommitId                    7.1.0\r\nOS                             Microsoft Windows 10.0.19042\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n\r\n\r\nThe last tested version of PowerShell that works.\r\n\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.0.3\r\nPSEdition                      Core\r\nGitCommitId                    7.0.3\r\nOS                             Microsoft Windows 10.0.19042\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Please use our issue template to share all info about environment and repro steps.",
      "created_at": "2020-12-08T12:56:40Z",
      "updated_at": "2020-12-08T12:56:40Z"
    },
    {
      "author": "escservices",
      "author_association": "NONE",
      "body": "@iSazonov Updated",
      "created_at": "2020-12-08T17:48:28Z",
      "updated_at": "2020-12-08T17:48:28Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "A progress bar is cleaned at end of pipeline. You could try formally to put the web cmdlet in a pipeline.",
      "created_at": "2020-12-09T03:22:36Z",
      "updated_at": "2020-12-09T03:22:36Z"
    },
    {
      "author": "escservices",
      "author_association": "NONE",
      "body": "Sorry, I'm not sure what you mean @iSazonov.  Are you saying I should setup my function to accept parameters by piping them in instead?  Something like this (https://sid-500.com/2020/03/24/powershell-creating-functions-that-accept-pipeline-input-byvalue/)? \r\n\r\nI found a workaround that seems to resolve the issue but hides the cmdlet's progress info.  \r\nBy adding `$progressPreference = 'silentlyContinue'` before the Invoke-WebRequest and adding `$progressPreference = 'Continue'` at the end of the function, it seems to work.\n\n<blockquote><img src=\"https://patrick6649.files.wordpress.com/2019/10/unbenannt-9.png\" width=\"48\" align=\"right\"><div><img src=\"https://patrick6649.files.wordpress.com/2020/03/cropped-1_patrick_gruenauer_rund.png?w=192\" height=\"14\"> SID-500.COM</div><div><strong><a href=\"https://sid-500.com/2020/03/24/powershell-creating-functions-that-accept-pipeline-input-byvalue/\">PowerShell: Creating Functions that accept Pipeline Input (ByValue)</a></strong></div><div>You probably have already created your first function in PowerShell and now you want that your function is capable of pipeline input. Right? Ok, you\u2019ve come to the right place. In this blog p\u2026</div></blockquote>",
      "created_at": "2021-01-05T16:02:22Z",
      "updated_at": "2021-01-05T16:02:24Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I mean you could try to put the cmdlet in a pipeline like `1 | Get-WebRequest`.",
      "created_at": "2021-01-06T16:10:46Z",
      "updated_at": "2021-01-06T16:10:46Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> I mean you could try to put the cmdlet in a pipeline like `1 | Get-WebRequest`.\r\n\r\nIsn't that something `ConsoleHost` does between *interactive* pipelines?\r\n\r\nAlso either way, the command should write a `Completed` record to clear it.  If it's not doing that that's probably a bug.",
      "created_at": "2021-01-06T18:16:45Z",
      "updated_at": "2021-01-06T18:16:45Z"
    },
    {
      "author": "vcheckzen",
      "author_association": "NONE",
      "body": "> I mean you could try to put the cmdlet in a pipeline like `1 | Get-WebRequest`.\r\n\r\nnot working still",
      "created_at": "2022-10-20T19:02:09Z",
      "updated_at": "2022-10-20T19:02:09Z"
    }
  ],
  "created_at": "2020-12-07T20:58:33Z",
  "number": 14348,
  "state": "open",
  "title": "Powershell  v7.1 - Invoke-WebRequest not clearing in script when using Clear-Host",
  "updated_at": "2022-10-20T19:02:09Z"
}