{
  "_url": "https://github.com/PowerShell/PowerShell/issues/4624",
  "author": "mklement0",
  "body": "<sup>Follow-up to #4576 and #4591</sup>\r\n\r\n### Context:\r\n\r\nNote: By _bareword_ I mean a run of non-whitespace characters not single- or double-quoted as a whole (e.g., `foo`), used in argument mode, and normally interpreted as an expandable string (e.g., `$HOME/boy`).\r\n\r\nWhile `-`-prefixed barewords _look_ like _parameter names_ (e.g.,`-foo`), they _sometimes_ act as _arguments_ (_values_ to bind to parameters), and the ability to use them as such is important in two contexts:\r\n\r\n* In the context of the external CLI, when passing the name of a script file that happens to start with `-`; e.g., `powershell -File -foo.ps1`\r\n\r\n* When passing arguments _through_ that themselves happen to be command line or command-line fragments, which is enabled by cmdlets/advanced functions that declare a `ValueFromRemainingArguments` parameter; e.g., \r\n`Get-Command -Syntax Get-ChildItem -Path cert:` passes `-Path cert:` through (the `-Path` bareword is _not_ interpreted as `Get-Command`'s parameter) in order to discover the certificate provider's dynamic parameters.\r\n\r\nNote that, except when using the external CLI, you can always use _quoting_ to explicitly mark a bareword as an _argument_.\r\n\r\nGenerally, though, if there's no ambiguity, not having to quote tokens that don't strictly need it is a matter of convenience.\r\n\r\n### The problem:\r\n\r\nThere are two major problems with how `-`-prefixed barewords are currently parsed and interpreted:\r\n\r\n* Pragmatically speaking, **their syntactic role (parameter name vs. argument) is virtually unpredictable by the end user**. \r\n\r\n   * E.g., the `-a` in `Get-Item -LiteralPath -a` is an _argument_, whereas the `-c` in `Get-Item -LiteralPath -c` is _parameter name_`-Credential`.\r\n\r\n* They are **not parsed and expanded in the same way as barewords that do _not_ start with `-`**.\r\n\r\n   * E.g., bareword `a$HOME` expands `$HOME`, while `-a$HOME` does not.\r\n\r\nMore examples below.\r\n\r\n### Solution options:\r\n\r\n* Leave things as they are and _document_ the current behavior, recommending that _quoting_ be used for predictability.\r\n\r\n* Change the parameter binding as proposed in #4576: Once a parameter has been (unambiguously) identified, its specific definition  - switch vs. parameter-with-argument- _alone_ determines whether the next token is its argument or a different parameter:\r\n\r\n  * E.g., in `Get-Item -LiteralPath -p`, `-p` would _unambiguously_ be an _argument_, because `-LiteralPath` _syntactically requires_ an argument.\r\n\r\n    * An argument can be made that in cases where the _user intent_ was likely different - e.g., `Get-Item -LiteralPath -Path` - that _unconditional_ interpretation of `-`-prefixed barewords as _parameter names_ is preferable in terms of the user experience (`Missing an argument for parameter 'LiteralPath'` as opposed to `Cannot find path '-Path' because it does not exist`); a point that [@markekraus has made](https://github.com/PowerShell/PowerShell/issues/4576#issuecomment-322574632).\r\n\r\n     * That said, I think the conceptual simplicity and clarity of the let-the-identified-parameter-determine-the-next-token's-syntactic-role approach is more beneficial in the grand scheme of things.\r\n\r\n  * Note: [@lzybkr has already discounted this option](https://github.com/PowerShell/PowerShell/issues/4576#issuecomment-322572999) based on implementation cost, but I'm resubmitting it for consideration now that we have a fuller picture of all the issues involved: \r\n>  I can't see adding more complexity to the parameter binder to change this behavior.\r\n\r\n\r\n* Disallow `-`-prefixed barewords altogether, as proposed in #4591: In order for a `-`-prefixed tokens to be recognized as an _argument_, it would have to be _single- or double-quoted_ .\r\n\r\n   * E.g., `Get-Item -LiteralPath -a` would then _break_, because `Get-Item` has no `-a*` parameter, and `Get-Item -LiteralPath '-a'` would have to used consistently. (But, in contrast, PowerShell's _outside_ CLI would still need to accept something like `-File -a`.)\r\n\r\n   * The convenience of being able to specify `-`-prefixed tokens _as arguments_ is lost, but at least the behavior is _predictable_.\r\n\r\n     * That said, the waters would still be muddy with respect to commands that have a `ValueFromRemainingArguments` parameter, where, based on the current behavior, a `-`-prefixed barewords _if it happens not to match a regular parameter_ would still be interpreted as an _argument_.\r\n\r\n### Examples:\r\n\r\n```powershell\r\n### Virtually unpredictable syntactic role\r\n\r\n# BREAKS\r\n# -c, because it happens to match parameter name -Credential, is interpreted as a *parameter name*.\r\n# Note that, purely based on -LiteralPath being a parameter that *requires an argument*, there is\r\n# no good reason to parse -c as a parameter name. The syntax of Get-Item unambigously implies that\r\n# the token following -LiteralPath must be an *argument*.\r\nGet-Item -LiteralPath -c\r\n\r\n# SUCCEEDS\r\n# -a, because it happens not to match any of Get-Item's parameters, is interpreted as an *argument*\r\nGet-Item -LiteralPath -a\r\n\r\n\r\n# Even though a \"-\"-prefixed token as the 1st argument is normally *invariably* interpreted as \r\n# a *parameter name*, that is not the case for cmdlets with a ValueFromRemainingArguments parameter,\r\n# such as Write-Output:\r\n\r\n# BREAKS\r\n# -n happens to match parameter (switch) -NoEnumeration, and the call is therefore missing\r\n# arguments to output (-InputObject)\r\nWrite-Output -n\r\n# Solution: Use -- to signal the start of all positional arguments.\r\nWrite-Output -- -n\r\n\r\n# SUCCEEDS, because -z happens not to match a parameter name and is therefore bound to -InputObject.\r\nWrite-Output -z\r\n\r\n### Parsing / expansion inconsistencies\r\n\r\n# As part of an array, a \"-\"-prefixed bareword doesn't work as the 1st element.\r\nWrite-Output -a, b\t# BREAKS\r\nWrite-Output a, -b  # SUCCEEDS\r\n\r\n\r\n# \"-\"-prefixed barewords are non-expanding\r\nWrite-Output a$HOME   # expands $HOME\r\nWrite-Output -a$HOME  # doesn't expand $HOME\r\n\r\n\r\n# A \"-\"-prefixed bareword containing a \".\"-prefixed suffix is parsed as *2* arguments\r\nGet-Item -LiteralPath a.ps1  # SUCCEEDS\r\nGet-Item -LiteralPath -a.ps1 # BREAKS: Get-Item receives *2* arguments: '-a' and '.ps1'\r\n```\r\n\r\nEnvironment data\r\n----------------\r\n\r\n```powershell\r\nPowerShell Core v6.0.0-beta.5 on macOS 10.12.6\r\nPowerShell Core v6.0.0-beta.5 on Ubuntu 16.04.3 LTS\r\nPowerShell Core v6.0.0-beta.5 on Microsoft Windows 10 Pro (64-bit; v10.0.15063)\r\nWindows PowerShell v5.1.15063.483 on Microsoft Windows 10 Pro (64-bit; v10.0.15063)\r\n```\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@mklement0\r\n\r\n> But, in contrast, PowerShell's outside CLI would still need to accept something like `-File -a`.\r\n\r\nAs a point of clarity, this is not something under PowerShell's control as the calling shell (bash, another PowerShell, CMD, ksh, etc) has final say in the matter. What you are specifically requesting here is to maintain the current argument parsing for arguments passed from the calling shell to the PowerShell binary upon initialization. Correct?",
      "created_at": "2017-08-20T17:21:37Z",
      "updated_at": "2017-08-20T17:23:14Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@markekraus:\r\n\r\n> What you are specifically requesting here is to maintain the current argument parsing for arguments passed from the calling shell to the PowerShell binary upon initialization. Correct?\r\n\r\nCorrect: `powershell -File -foo.ps1` currently works already, and should continue to work.  \r\n(And as _one_ aspect of conceptual simplicity and consistency, the same should work _predictably_ PowerShell-_internally_ as well (when calling functions/cmdlets)).\r\n\r\nCalling from a POSIX-like shell (Unix; e.g., `bash`),  `powershell -File -foo.ps1` is indistinguishable from variants `powershell -File '-foo.ps1'` and `powershell -File \"-foo.ps1\"`, because the POSIX-like shell performs _quote removal_ before passing the array of arguments as literals to the target command: `powershell` sees just literals `-File` and `-foo.ps1` in all cases.\r\n\r\nConceivably, PowerShell _could_ - but shouldn't, in my view - then place _additional_ requirements on the arguments passed, based on _its_ syntax requirement, such as for the received `-foo.ps1` argument to still be represented as `'-foo.ps1'`, for instance, _if_ \r\nthe decision were made (I hope not) that `-`-prefixed tokens are only recognized as _arguments_ when _quoted_.\r\n\r\nIf such a requirement existed, you'd have to call `powershell -File \"'-foo.ps1'\"` (or `powershell -File '\"-foo.ps1\"'`) - and such two-unrelated-quoting-layers awkwardness is best avoided.\r\n\r\nUnfortunately, we already have that awkwardness with respect to how `-Command` parsing works: because it assembles all arguments into a single string that it then interprets based on PowerShell rules, you do need two-layer quoting; e.g.:\r\n\r\n```powershell\r\n# Oops! \"The string is missing the terminator: '.\"\r\n# PowerShell ended up interpreting `Write-Output don't` as the script.\r\npowershell -noprofile -command Write-Output \"don't\"\r\n\r\n# OK, but clearly cumbersome:\r\n# With shell-variable-based arguments, it gets even trickier.\r\npowershell -noprofile -command Write-Output \"\\\"don't\\\"\"\r\n```\r\n\r\nSee https://github.com/PowerShell/PowerShell/issues/4024#issuecomment-312267611 for more.\r\n\r\n",
      "created_at": "2017-08-20T18:57:56Z",
      "updated_at": "2017-08-20T19:05:10Z"
    }
  ],
  "created_at": "2017-08-20T16:40:15Z",
  "labels": [
    "WG-Language",
    "Issue-Discussion"
  ],
  "number": 4624,
  "state": "open",
  "title": "Inconsistent, unpredictable behavior of \"-\"-prefixed barewords in argument mode",
  "updated_at": "2020-08-19T13:30:50Z"
}