{
  "_url": "https://github.com/PowerShell/PowerShell/issues/2505",
  "author": "powercode",
  "body": "<!--\n\nIf it is a bug report:\n- make sure you are able to repro it on the latest released version. \nYou can install the latest version from https://github.com/PowerShell/PowerShell/releases\n- Search the existing issues.\n- Refer to the [FAQ](../docs/FAQ.md).\n- Refer to the [known issues](../docs/KNOWNISSUES.md).\n- Fill out the following repro template\n\nIf it's not a bug, please remove the template and elaborate the issue in your own words.\n-->\n## Steps to reproduce\n\n``` powershell\n#Sub.psm1:\n  class Sub {\n    [int] $Value\n  }\n\n#modrepo.psm1:\n  using module .\\Sub.psm1\n\n  function Get-Sub { \n     [Sub]@{\n         Value = 42\n     }\n  }\n\nImport-Module modrepo\nGet-Sub\n```\n\n`Value : 1`\n\nChange the definition of Sub:\n\n``` powershell\n#Sub.psm1:\n  class Sub {  \n    [string] $Name # added field\n    [int] $Value\n  }\n\n#modrepo.psm1:\n  using module .\\Sub.psm1\n\n  function Get-Sub{ \n     [Sub]@{\n         Name = \u2018Staffan\u2019 # added field\n         Value = 42\n     }\n  }\n\n#Then\n\nRemove-Module -force modrepo\nImport-Module -force modrepo\nGet-Sub \n```\n## Expected behavior\n\noutput of object of class Sub with \n\n```\nName : 'Staffan'\nValue : 42\n```\n## Actual behavior\n\n```\nCannot create object of type \"Sub\". The Name property was not found for the Sub object. The available property is: [Value <System.Int32>]\nAt C:\\Users\\<user>\\Documents\\WindowsPowerShell\\Modules\\modrepo\\modrepo.psm1:9 char:3\n+   [Sub] @{\n+   ~~~~~~~~\n    + CategoryInfo          : InvalidArgument: (:) [], RuntimeException\n    + FullyQualifiedErrorId : ObjectCreationError\n```\n## Environment data\n\n``` powershell\n\nName                           Value                                                                                                                                                       \n----                           -----                                                                                                                                                       \nPSVersion                      5.1.14393.206                                                                                                                                               \nPSEdition                      Desktop                                                                                                                                                     \nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}                                                                                                                                     \nBuildVersion                   10.0.14393.206                                                                                                                                              \nCLRVersion                     4.0.30319.42000                                                                                                                                             \nWSManStackVersion              3.0                                                                                                                                                         \nPSRemotingProtocolVersion      2.3                                                                                                                                                         \nSerializationVersion           1.1.0.1                                                                                                                                                     \n\n\n\n```\n",
  "closed_at": null,
  "comments": [
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "Hi @powercode, I'm unable to reproduce this issue in both powershell 5.1 and latest powershell core:\n\n### powershell 5.1\n\n```\nPS:3> dir\n\n    Directory: C:\\arena\\tmp\n\nMode                LastWriteTime         Length Name\n----                -------------         ------ ----\n-a----       10/19/2016   9:16 PM            127 modrepo.psm1\n-a----       10/19/2016   9:16 PM             74 Sub.psm1\n\nPS:4> v .\\Sub.psm1\nPS:5> v .\\modrepo.psm1\nPS:6> Import-Module .\\modrepo.psm1\nPS:7> Get-Sub\n\nValue\n-----\n   42\n\nPS:8> v .\\Sub.psm1\nPS:9> v .\\modrepo.psm1\nPS:10> Remove-Module modrepo -Force\nPS:11> Import-Module .\\modrepo.psm1 -Force\nPS:12>\nPS:12> Get-Sub\n\nName    Value\n----    -----\nStaffan    42\n\nPS:13> $PSVersionTable\n\nName                           Value\n----                           -----\nPSVersion                      5.1.14393.206\nPSEdition                      Desktop\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}\nBuildVersion                   10.0.14393.206\nCLRVersion                     4.0.30319.42000\nWSManStackVersion              3.0\nPSRemotingProtocolVersion      2.3\nSerializationVersion           1.1.0.1\n```\n\n### powershell core\n\n```\nPS C:\\arena\\tmp> dir\n\n    Directory: C:\\arena\\tmp\n\nMode                LastWriteTime         Length Name\n----                -------------         ------ ----\n-a----       10/19/2016   9:15 PM            128 modrepo.psm1\n-a----       10/19/2016   9:15 PM             75 Sub.psm1\n\nPS C:\\arena\\tmp> Import-Module .\\modrepo.psm1\nPS C:\\arena\\tmp>\nPS C:\\arena\\tmp> Get-Sub\n\nValue\n-----\n   42\n\nPS C:\\arena\\tmp>\nPS C:\\arena\\tmp> Remove-Module modrepo -Force\nPS C:\\arena\\tmp> Import-Module .\\modrepo.psm1 -Force\nPS C:\\arena\\tmp>\nPS C:\\arena\\tmp> Get-Sub\n\nName    Value\n----    -----\nStaffan    42\n```\n\nAm I missing anything? Are you able to reproduce the issue in the latest alpha.11 release of powershell core?\n",
      "created_at": "2016-10-20T04:33:52Z",
      "updated_at": "2016-10-20T04:33:52Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "I was actually a bit surprised when I created this repro that it failed the first time. I usually get this issue intermittently but it consistently is a pain when using classes in modules. I often end up restarting powershell.exe or the ise to get back to working modules. \nI'll try installing the alpha and see if I can repro it there too.\n",
      "created_at": "2016-10-20T06:50:16Z",
      "updated_at": "2016-10-20T06:50:16Z"
    },
    {
      "author": "LaurentDardenne",
      "author_association": "NONE",
      "body": "I can reproduce this issue on Windows Seven x64 & x86 with PS v5.0.\n\n``` Powershell\nremove-item c:\\temp\\Sub.psm1 -ea Silently\nremove-item c:\\temp\\modrepo.psm1 -ea Silently \n@'\n  class Sub {\n    [int] $Value\n  }\n'@ >c:\\temp\\Sub.psm1\n\n@'\n  using module c:\\temp\\Sub.psm1\n\n  [sub]::new()|gm > c:\\temp\\c1.txt\n\n  function Get-Sub { \n     [Sub]@{\n         Value = 42\n     }\n  }\n'@ > C:\\temp\\modrepo.psm1\n\nSet-location c:\\temp\nImport-Module c:\\temp\\modrepo.psm1\nGet-Sub\n\n@'\n  class Sub {  \n    [string] $Name # added field\n    [int] $Value\n  }\n'@ >c:\\temp\\Sub.psm1\n\n@'\n  using module c:\\temp\\Sub.psm1\n\n  [sub]::new()|gm > c:\\temp\\c2.txt\n\n  function Get-Sub{ \n     [Sub]@{\n         Name = \u2018Staffan\u2019 # added field\n         Value = 42\n     }\n  }\n'@ > C:\\temp\\modrepo.psm1\n\nSet-location c:\\temp\nRemove-Module -force modrepo\nImport-Module -force c:\\temp\\modrepo.psm1\nGet-Sub \n#-> Exception\n\nfc.exe c:\\temp\\c2.txt c:\\temp\\c1.txt\n# Equal\n# Comparaison des fichiers C:\\TEMP\\c2.txt et C:\\TEMP\\C1.TXT\n# FC\u00a0: aucune diff\u00e9rence trouv\u00e9e\n```\n\n$PSVersionTable\n\n```\nName                           Value\n----                           -----\nPSVersion                      5.0.10586.117\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0, 5.0.10586.117}\nBuildVersion                   10.0.10586.117\nCLRVersion                     4.0.30319.42000\nWSManStackVersion              3.0\nPSRemotingProtocolVersion      2.3\nSerializationVersion           1.1.0.1\n```\n\n$StackTrace\n\n```\n   \u00e0 System.Management.Automation.LanguagePrimitives.CreateMemberNotFoundError(PSObject pso, DictionaryEntry property, T\nype resultType)\n   \u00e0 System.Management.Automation.LanguagePrimitives.SetObjectProperties(Object o, IDictionary properties, Type resultTy\npe, MemberNotFoundError memberNotFoundErrorAction, MemberSetValueError memberSetValueErrorAction, Boolean enableMethodCa\nll, IFormatProvider formatProvider, Boolean recursion, Boolean ignoreUnknownMembers)\n   \u00e0 System.Management.Automation.LanguagePrimitives.ConvertViaNoArgumentConstructor.Convert(Object valueToConvert, Type\n resultType, Boolean recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable,\nBoolean ignoreUnknownMembers)\n```\n",
      "created_at": "2016-10-20T08:12:19Z",
      "updated_at": "2016-10-20T08:12:19Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "I did the following with trace-command to see module logging (still on the desktop):\nAnything else you can do to trace the caching of modules?\n\n``` powershell\n[datetime]::Now\n$modPath = '~/documents/windowspowershell/modules/modrepo/'\n$null = mkdir $modPath -ea:0\n\n\nSet-Content $modPath/modrepo.psm1 -Value @'\nusing module .\\Sub.psm1\nfunction Get-Sub{  \n  $s = [Sub]::new(); \n  $s | get-Member | Format-Table \n  $s.ToString();\n  $s.GetType().Assembly.Modules.ModuleVersionId \n}\n'@\n\n$sub1 = @'\nclass Sub {\n  [int] $Value \n  #[string] $Name\n  Sub(){\n    $this.Value = 42\n    #$this.Name='Answer'\n  }     \n  [string] ToString() {return 'I am the first version'}\n}   \n'@\n\n$sub2 = @'\nclass Sub {\n  [int] $Value \n  [string] $Name\n  Sub(){\n    $this.Value = 42\n    $this.Name='Answer'\n  }     \n  [string] ToString() { return 'I am new and improved' }\n}   \n'@\n\n\nSet-Content $modPath/sub.psm1 -Value $sub1\nTrace-Command -Expression {Import-Module -Force modrepo} -PSHost Modules\nGet-Sub\n\n# now change the definition of sub.psm1\nSet-Content $modPath/sub.psm1 -Value $sub2\nTrace-Command -Expression {Import-Module -Force modrepo} -PSHost Modules\nGet-Sub\n```\n\nThe output is as follows. Note that the definitions of Sub has not been been updated and the same dynamic assembly is used.\n\n`````` powershell\n\nden 20 oktober 2016 11:55:25\nDEBUG: Modules Information: 0 :  WriteLine   C:\\Users\\powercode\\Documents\\WindowsPowerShell\\Modules\\modrepo\\Sub.psm1: cache entry out of date, cached on 2016-10-20 11:29:20, last updated on 2016-10-20 11:55:25\nDEBUG: Modules Information: 0 :  WriteLine   Returning NULL for exported commands.\nDEBUG: Modules Information: 0 :  WriteLine   Analyzing path: C:\\Users\\powercode\\Documents\\WindowsPowerShell\\Modules\\modrepo\\Sub.psm1\nDEBUG: Modules Information: 0 :  WriteLine   Requested caching for Sub\nDEBUG: Modules Information: 0 :  WriteLine   Caching command: Sub\nDEBUG: Modules Information: 0 :  WriteLine   Requested caching for Sub\nDEBUG: Modules Information: 0 :  WriteLine   Existing cached info up-to-date. Skipping.\nDEBUG: Modules Information: 0 :  WriteLine   Requested caching for modrepo\nDEBUG: Modules Information: 0 :  WriteLine   Caching command: Get-Sub\nDEBUG: Modules Information: 0 :  WriteLine   Caching command: Sub\n\n\n\n\n   TypeName: Sub\n\nName        MemberType Definition\n----        ---------- ----------\nEquals      Method     bool Equals(System.Object obj)\nGetHashCode Method     int GetHashCode()\nGetType     Method     type GetType()\nToString    Method     string ToString()\nValue       Property   int Value {get;set;}\n\n\nI am the first version\n\nDEBUG: Modules Information: 0 :  WriteLine   Requested caching for Sub\nDEBUG: Modules Information: 0 :  WriteLine   C:\\Users\\powercode\\Documents\\WindowsPowerShell\\Modules\\modrepo\\Sub.psm1: cache entry out of date, cached on 2016-10-20 11:55:25, last updated on 2016-10-20 11:55:31\nDEBUG: Modules Information: 0 :  WriteLine   Caching command: Sub\nDEBUG: Modules Information: 0 :  WriteLine   Requested caching for modrepo\nDEBUG: Modules Information: 0 :  WriteLine   Existing cached info up-to-date. Skipping.\nGuid\n----\nfa9abef1-c3b5-4c5f-88f2-aa11f6a8d427\n\n\n\n\n   TypeName: Sub\n\nName        MemberType Definition\n----        ---------- ----------\nEquals      Method     bool Equals(System.Object obj)\nGetHashCode Method     int GetHashCode()\nGetType     Method     type GetType()\nToString    Method     string ToString()\nValue       Property   int Value {get;set;}\n\n\nI am the first version\n\nGuid\n----\nfa9abef1-c3b5-4c5f-88f2-aa11f6a8d427```\n\n``````\n",
      "created_at": "2016-10-20T10:03:06Z",
      "updated_at": "2016-10-20T10:03:06Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I confirm @LaurentDardenne's test on:\n\n```\n$PSVersionTable\n\nName                           Value\n----                           -----\nWSManStackVersion              3.0\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}\nBuildVersion                   3.0.0.0\nPSEdition                      Core\nSerializationVersion           1.1.0.1\nPSVersion                      6.0.0-alpha\nGitCommitId                    v6.0.0-alpha.11-39-g0104d205a46846b9df0ef4940eedb226d21324dc\nPSRemotingProtocolVersion      2.3\nCLRVersion\n```\n",
      "created_at": "2016-10-21T06:11:43Z",
      "updated_at": "2016-10-21T06:11:43Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "[Modrepo.ps1.txt](https://github.com/PowerShell/PowerShell/files/544270/Modrepo.ps1.txt)\n\nI can reproduce the problems on WSL \n\n```\nName                           Value\n----                           -----\nPSVersion                      6.0.0-alpha\nPSEdition                      Core\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}\nBuildVersion                   3.0.0.0\nGitCommitId                    v6.0.0-alpha.11\nCLRVersion\nWSManStackVersion              3.0\nPSRemotingProtocolVersion      2.3\nSerializationVersion           1.1.0.1\n```\n",
      "created_at": "2016-10-21T12:12:02Z",
      "updated_at": "2016-10-21T12:12:02Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@daxian-dbw \n\n> Am I missing anything? \n\nDo you modify submodule before second test?\n",
      "created_at": "2016-10-21T12:56:59Z",
      "updated_at": "2016-10-21T12:56:59Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "@iSazonov\nYes, he got \n\n```\nValue\n-----\n   42\n```\n\nthe first run and \n\n```\nName    Value\n----    -----\nStaffan    42\n```\n\nthe second.\n\nSo there are some other factors involved here too. \n",
      "created_at": "2016-10-21T13:07:37Z",
      "updated_at": "2016-10-21T13:07:37Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "[Modrepo.Tests.ps1.txt](https://github.com/PowerShell/PowerShell/files/544410/Modrepo.Tests.ps1.txt)\n\nAttaching a pester test. It is failing on \n\n```\nPSVersion     BuildVersion   PSEdition GitCommitId            \n---------     ------------   --------- -----------            \n6.0.0-alpha   3.0.0.0        Core      v6.0.0-alpha.11 wsl (Ubuntu 14)  \n6.0.0-alpha   3.0.0.0        Core      v6.0.0-alpha.11 windows\n5.1.14393.206 10.0.14393.206 Desktop                          \n```\n",
      "created_at": "2016-10-21T13:50:56Z",
      "updated_at": "2016-10-21T14:13:53Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "@vors: Do you know if this is a known problem or not? I vaguely remember a conversation about classes getting cached in perpetuity for a given runspace? \n",
      "created_at": "2016-10-25T21:32:37Z",
      "updated_at": "2016-10-25T21:32:37Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "Are you saying that you can't repro this?\nI have no machine where it works. \n",
      "created_at": "2016-10-31T14:12:49Z",
      "updated_at": "2016-10-31T14:12:49Z"
    },
    {
      "author": "pcgeek86",
      "author_association": "NONE",
      "body": "Does this have to do with the inability to unload an assembly from an AppDomain, perhaps? What does the output of `[System.AppDomain]::CurrentDomain.GetAssemblies()` look like, after each execution? If I recall correctly PowerShell generates dynamic, in-memory assemblies that only last for the lifetime of the process (or maybe runspace, as Joey mentioned).\n",
      "created_at": "2016-10-31T14:40:49Z",
      "updated_at": "2016-10-31T14:40:49Z"
    },
    {
      "author": "pcgeek86",
      "author_association": "NONE",
      "body": "Further reading on .NET: http://stackoverflow.com/questions/123391/how-to-unload-an-assembly-from-the-primary-appdomain\n",
      "created_at": "2016-10-31T14:41:31Z",
      "updated_at": "2016-10-31T14:41:31Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "Thank you @powercode! I'm able to reproduce the issue with your script [Modrepo.Tests.ps1.txt](https://github.com/PowerShell/PowerShell/files/544410/Modrepo.Tests.ps1.txt). I will investigate further to find the root cause.\n",
      "created_at": "2016-10-31T18:58:51Z",
      "updated_at": "2016-10-31T22:54:56Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "@pcgeek86 Not really. New assemblies are generated for each edited version of a module. So lots of assemblies with the same name but with a unique guid. And PowerShell needs to map the name of a class to the correct version of the generated assembly. \n",
      "created_at": "2016-11-01T08:10:46Z",
      "updated_at": "2016-11-01T08:10:46Z"
    },
    {
      "author": "pcgeek86",
      "author_association": "NONE",
      "body": "@powercode Good info! Appreciate the clarification.\n",
      "created_at": "2016-11-01T16:39:15Z",
      "updated_at": "2016-11-01T16:39:15Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "There is a special kind of dynamic assembly that can be unloaded and garbage collected - PowerShell uses that kind of assembly for our implementation of classes.\n\nAnd yes, @powercode is correct, we do maintain a mapping of name to assembly for PowerShell classes - that mapping is checked for all typenames before using reflection to resolve a typename.\n",
      "created_at": "2016-11-01T19:52:24Z",
      "updated_at": "2016-11-01T19:52:24Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "@lzybkr Thinking about that: is there a side-by-side story in PowerShell? If multiple versions of an assembly is loaded, can we indicate which one to use? I.E. the fullname of the type?\n",
      "created_at": "2016-11-01T20:06:56Z",
      "updated_at": "2016-11-01T20:06:56Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "An ugly solution is to use the `AssemblyQualifiedName`, e.g.\n\n``` powershell\n[System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]\n```\n",
      "created_at": "2016-11-01T20:14:15Z",
      "updated_at": "2016-11-01T20:14:15Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Is it impossible 'Import-Module -Force' first unload the old version of the assembly?\n",
      "created_at": "2016-11-02T08:37:48Z",
      "updated_at": "2016-11-02T08:37:48Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "@daxian-dbw Found anything?",
      "created_at": "2016-11-21T17:58:46Z",
      "updated_at": "2016-11-21T17:58:46Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@powercode Sorry that I was distracted by other things and didn't get back to this issue. I will post my update by end of this week.",
      "created_at": "2016-11-21T20:29:35Z",
      "updated_at": "2016-11-21T20:29:35Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@powercode There are 2 problems in the module loading:\r\n\r\n1. `Import-Module modrepo -Force` doesn't reload the nested module of `modrepo` (`Sub.psm1` in this case) when `modrepo` was already loaded. So when running `Import-Module modrepo -Force`, it would actually reuse the same `Sub` module loaded previous, even though that module file had been changed.\r\n2. The module analysis result is stored in a [cache](https://github.com/PowerShell/PowerShell/blob/277b81141ab68d5b72f4be0850c7c05b0800b50b/src/System.Management.Automation/engine/Modules/ModuleCmdletBase.cs#L6533) with the module file path as the key and the `PSModuleInfo` object as the value. The cache entries are not properly invalidated based on the `LastWriteTime` of the module file, and thus same cached value got reused.\r\n\r\n**More details for `#1`:**\r\nWhen running `Import-Module modrepo -Force`, if `modrepo` was already loaded, powershell would [remove the module first](https://github.com/PowerShell/PowerShell/blob/80951777cfde34e9d527dedd833f90cc715ad684/src/System.Management.Automation/engine/Modules/ImportModuleCommand.cs#L623). However, it doesn't handle the nested modules in this case and thus the nested module stays in the module table. Then when reloading `modrepo`, the old nested module would be reused.\r\n*Concrete repro:*\r\n```powershell\r\nPS C:\\temp>   $sub1 = @'\r\n>> class Sub {\r\n>>   [int] $Value\r\n>>   #[string] $Name\r\n>>   Sub(){\r\n>>     $this.Value = 42\r\n>>     #$this.Name='Answer'\r\n>>   }\r\n>>   [string] ToString() {return 'I am the first version'}\r\n>> }\r\n>> '@\r\nPS C:\\temp>\r\nPS C:\\temp>   $sub2 = @'\r\n>> class Sub {\r\n>>   [int] $Value\r\n>>   [string] $Name\r\n>>   Sub(){\r\n>>     $this.Value = 4711\r\n>>     $this.Name='Answer'\r\n>>   }\r\n>>   [string] ToString() { return 'I am new and improved' }\r\n>> }\r\n>> '@\r\nPS C:\\temp> Set-Content .\\modrepo\\Sub.psm1 -Value $sub1\r\nPS C:\\temp> $s = Import-Module .\\modrepo -PassThru\r\nPS C:\\temp> Set-Content .\\modrepo\\Sub.psm1 -Value $sub2\r\nPS C:\\temp> $v = Import-Module -Force .\\modrepo -PassThru\r\nPS C:\\temp> $v.NestedModules[0].Name\r\nSub\r\nPS C:\\temp> $s.NestedModules[0].Equals($v.NestedModules[0])\r\nTrue\r\n```\r\n\r\n**More details for `#2`:**\r\nWhen you have `using module .\\Sub.psm1`, `Get-Module <path-to-Sub.psm1> -ListAvailable` would be used to analyze the module. However, since the analysis result is cached and not properly invalidated, the second call to `Get-Module` after changing `Sub.psm1` would return the same result as before the change (clones of the cached value). Therefore, the class definition being used is stale.\r\n*Concrete repro:*\r\n```powershell\r\nPS C:\\temp> Set-Content .\\modrepo\\Sub.psm1 -Value $sub1\r\nPS C:\\temp> $first = Get-Module C:\\temp\\modrepo\\Sub.psm1 -ListAvailable\r\nPS C:\\temp> Set-Content .\\modrepo\\Sub.psm1 -Value $sub2\r\nPS C:\\temp> $second = Get-Module C:\\temp\\modrepo\\Sub.psm1 -ListAvailable\r\nPS C:\\temp> $first.Name\r\nSub\r\nPS C:\\temp>\r\nPS C:\\temp> $first.GetExportedTypeDefinitions()\r\n\r\nKey Value\r\n--- -----\r\nSub class Sub {...\r\n\r\nPS C:\\temp> $firstType = $first.GetExportedTypeDefinitions()\r\nPS C:\\temp> $secondType = $second.GetExportedTypeDefinitions()\r\nPS C:\\temp> $firstType.Sub.Equals($secondType.Sub)\r\nTrue\r\n```\r\n\r\nI had troubles reproducing the issues interactively in powershell console, and it turned out that was because the analysis cache from `#2` would be cleared by tab completion when completing module name for cmdlets like `Import-Module mod<tab>`. That's probably by design, but it did make it harder to get to the root causes.",
      "created_at": "2016-11-27T06:57:55Z",
      "updated_at": "2018-04-18T01:00:18Z"
    },
    {
      "author": "alx9r",
      "author_association": "NONE",
      "body": "Thank you for sharing your analysis @daxian-dbw.  I've been trying to understand this behavior myself, and your last post helps.\r\n\r\nCan you confirm that the correct behavior for `Import-Module -Force` is to reload the module and its nested modules *regardless* of whether any module file has changed?  This wasn't clear from your last post.  Modules can keep all manner of internal state.  Intuitively I'd expect `Import-Module -Force` to result in the same state as `Import-Module` would for that module in a fresh session.  That behavior would also be consistent with the help which reads as follows:\r\n\r\n>-Force\r\n>Indicates that this cmdlet re-imports a module and its members, even if the module or its members have an access mode of read-only.\r\n\r\nAs best I can tell neither PowerShell 5.0, 5.1, nor 6.0.0-alpha.13 behave in this manner consistently.  Rather, those versions all seem to skip reloading modules in some circumstances despite using `-Force`.\r\n\r\nThere's a fairly significant test matrix to consider.  [Here's a test I have written](https://gist.github.com/alx9r/7d3c220163bf55daca6fcc544c07ee27) that reloads modules after changing their module arguments, module files, and submodule files then tests the results.  Here is the summary of the test for PowerShell 5.0, 5.1, and 6.0.0-alpha.13:\r\n\r\n* submodules *never* seem to get reloaded\r\n* unless the module file is changed, a module containing a class never gets reloaded whether it is a submodule or the module named in the `Import-Module -Force` command\r\n\r\nThese are pretty painful results because it means that you have to start a new PowerShell session to have any certainty over the internal state of any module.  During development I am launching a new PowerShell process to run each test.  `powershell.exe` takes about 15 seconds to load itself, Pester, and the module-under-test, so a lot of developer time is spent just waiting to clear state to get a meaningful test result on each iteration.  And if you want to do any meaningful interactive debugging you have to open a fresh instance of ISE for each test which also takes time.\r\n\r\nI'm really hoping that module reloading can be cleaned up.  \r\n\r\nThanks for your help with this,\r\n\r\nAlex\r\n\r\n",
      "created_at": "2016-11-27T23:55:04Z",
      "updated_at": "2016-11-27T23:55:04Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Can you confirm that the correct behavior for  Import-Module -Force  is to reload the module and its nested modules regardless of whether any module file has changed?\r\n\r\nIt would be good to have two possibilities:\r\n1. Reload only changed module(s) and submodules based on `LastWriteTime`\r\n2. Force reload module(s) and submodules regardless of the `LastWriteTime`",
      "created_at": "2016-11-28T07:33:51Z",
      "updated_at": "2016-11-28T07:33:51Z"
    },
    {
      "author": "alx9r",
      "author_association": "NONE",
      "body": "@iSazonov \r\n\r\n> 1. Reload only changed module(s) and submodules based on LastWriteTime\r\n\r\nCan you share an example use case this behavior would be useful for?",
      "created_at": "2016-11-28T16:29:16Z",
      "updated_at": "2016-11-28T16:29:16Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@alx9r Thanks for the thorough pester tests!\r\n> Can you confirm that the correct behavior for Import-Module -Force is to reload the module and its nested modules regardless of whether any module file has changed?\r\n\r\nI believe `Import-Module -Force Foo` should work the same as `Remove-Module Foo -Force; Import-Module Foo`, and that means it should remove the `Foo` module and its nested modules, and then import it again.\r\n\r\n> unless the module file is changed, a module containing a class never gets reloaded whether it is a submodule or the module named in the Import-Module -Force command\r\n\r\nI played with your pester tests and found that the root module with a class definition does get reloaded with `Import-Module -Force`, however, the class definition from it doesn't get updated unless the module file has been changed since the last loading.\r\n\r\n**Steps to reproduce:**\r\n```powershell\r\nPS F:\\tmp> $content = @'\r\n>> $passedArgs = $Args\r\n>> class Root { $passedArgs = $passedArgs }\r\n>> function Get-PassedArgsRoot { [Root]::new().passedArgs }\r\n>> function Get-PassedArgsNoRoot { $passedArgs }\r\n>> '@\r\nPS F:\\tmp>\r\nPS F:\\tmp> Set-Content .\\testmodule\\testmodule.psm1 -Value $content\r\nPS F:\\tmp> Import-Module .\\testmodule -ArgumentList 'value1'\r\nPS F:\\tmp> Get-PassedArgsNoRoot\r\nvalue1\r\nPS F:\\tmp> Get-PassedArgsRoot\r\nvalue1\r\nPS F:\\tmp>\r\nPS F:\\tmp> Import-Module .\\testmodule -ArgumentList 'value2' -Force\r\nPS F:\\tmp> Get-PassedArgsNoRoot  ## indicate the module did get reloaded\r\nvalue2\r\nPS F:\\tmp> Get-PassedArgsRoot\r\nvalue1\r\nPS F:\\tmp>\r\nPS F:\\tmp> Add-Content .\\testmodule\\testmodule.psm1 -Value \"`n\" ## add a newline char to the file\r\nPS F:\\tmp> Import-Module .\\testmodule -ArgumentList 'value3' -Force\r\nPS F:\\tmp> Get-PassedArgsNoRoot\r\nvalue3\r\nPS F:\\tmp> Get-PassedArgsRoot\r\nvalue3\r\n```\r\n\r\nActually, the class definition doesn't get updated even you run `Remove-Module` and then `Import-Module`:\r\n```powershell\r\nPS F:\\tmp> Remove-Module testmodule\r\nPS F:\\tmp> Import-Module .\\testmodule -ArgumentList 'value4' -Force\r\nPS F:\\tmp> Get-PassedArgsNoRoot\r\nvalue4\r\nPS F:\\tmp> Get-PassedArgsRoot\r\nvalue3\r\n```\r\n\r\nIt looks like there is some caching for powershell class definition, which I need to investigate further to find out.",
      "created_at": "2016-11-28T19:31:36Z",
      "updated_at": "2016-11-28T20:29:53Z"
    },
    {
      "author": "alx9r",
      "author_association": "NONE",
      "body": "@daxian-dbw \r\n\r\n> Thanks for the thorough pester tests!\r\n\r\nYou're welcome. :)\r\n\r\n> I believe `Import-Module -Force Foo` should works the same as `Remove-Module Foo -Force; Import-Module Foo`, and that means it should remove the `Foo` module and its nested modules, and then import it again.\r\n\r\nThat sounds like good behavior to me.\r\n\r\n> I played with your pester tests and found that the root module with a class definition does get reloaded with `Import-Module -Force`, however, the class definition from it doesn't get updated unless the module file has been changed since the last loading.\r\n\r\n>Actually, the class definition doesn't get updated even you run `Remove-Module` and then `Import-Module`:\r\n\r\nInteresting.  I've [expanded the test matrix to cover the different reloading methods](https://gist.github.com/alx9r/7d3c220163bf55daca6fcc544c07ee27).  `Import-Module -Force` definitely behaves different from `Remove-Module -Force; Import-Module`.  \r\n\r\n> It looks like there is some caching for powershell class definition, which I need to investigate further to find out.\r\n\r\nThat explains a good chunk of the problems I've seen related to module reloading.  The results of the automated test `DifferentArgs_Classes_ForceRemoveThenImport` is consistent with caching of the class definition.\r\n\r\nI'll try to summarize the findings:\r\n\r\n1. With current versions of PowerShell use `Remove-Module; Import-Module` instead of `Import-Module -Force`.  `Remove-Module; Import-Module` reloads nested modules (but not class definitions contained in them) whereas `Import-Module -Force` does not.\r\n2. With current versions of PowerShell, the only known way to reload a class definition is to modify its module file.\r\n\r\nThere is another scenario that isn't part of the automated test: Dot-sourcing files in the `.psm1`.  Dot-sourcing files in `.psm1` files is commonplace in bigger modules.  [Pester is one example](https://github.com/pester/Pester/blob/dc550d2b9254bf09b225dafbf34be69f12901527/Pester.psm1#L113-L116).  [ZeroDSC is another](https://github.com/alx9r/ZeroDSC/blob/af6058ef062beae72f8f07038163694ac760dbbf/ZeroDSC.psm1#L5-L21).  I wonder whether the cache validation (for both modules and class definitions) is handled correctly when `.ps1` files are dot-sourced in `.psm1` files.",
      "created_at": "2016-11-28T23:01:47Z",
      "updated_at": "2016-11-28T23:05:46Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Above I meant that perhaps we need some optimization of module reload that can be significantly for _large_ modules. For example, to reload only those modules or/and submodules that actually changed. This can significantly reduce the time needed to reload.\r\nMaybe @daxian-dbw comment this.",
      "created_at": "2016-11-29T04:40:28Z",
      "updated_at": "2016-11-29T04:40:28Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@iSazonov I prefer to keep the logic simple so that it's easy to reason and maintain. Here are my arguments:\r\n\r\n1. There are other cases where we want to reload a module even if the module file is not changed since the last loading, for example, `Import-Module -Force -ArgumentList` uses different arguments which might affect the module behavior.\r\n2. IMHO, the performance of `Import-Module -Force` is not a problem unless there is data to prove I'm wrong. Besides, `Import-Module -Force` is more of a developer scenario, where I think the easy-to-reason advantage would outweigh the slight performance gain.",
      "created_at": "2016-11-29T21:14:29Z",
      "updated_at": "2016-11-29T21:14:29Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "The right way to think about performance here is - make `Import-Module` fast, then `Import-Module -Force` will be fast too.",
      "created_at": "2016-11-29T21:50:56Z",
      "updated_at": "2016-11-29T21:50:56Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@daxian-dbw @lzybkr Thanks for comments! \"make  Import-Module  fast\" is great. My concern about the performance of a module reload comes from the fact that some modules are heavy enough and if the custom module depends on such module, the user may be dissatisfied with the fact that reload of his little module leads to the heavy module is reloaded too. But I agree that  is more of a developer scenario and a full reload is acceptable.",
      "created_at": "2016-11-30T05:14:17Z",
      "updated_at": "2016-11-30T05:14:17Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "This is an update to my [post](https://github.com/PowerShell/PowerShell/issues/2505#issuecomment-263369811) about class definition reloading with module reloading.\r\n\r\nThe root cause is that powershell doesn't correctly refresh the `SessionState` associated with the class definition when a module gets reloaded. So the PS class is still referencing to the `SessionState` from the old module instance, and thus doesn't get the module state changes that happen during the reloading.\r\nThe PR #2837 was submitted to fix this particular issue.\r\n\r\nThere are still 2 more issues, and the detailed information can be found at [this comment](https://github.com/PowerShell/PowerShell/issues/2505#issuecomment-263105859).",
      "created_at": "2016-12-02T21:37:52Z",
      "updated_at": "2016-12-02T23:54:11Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "@alx9r \r\n> During development I am launching a new PowerShell process to run each test. powershell.exe takes about 15 seconds to load itself, Pester, and the module-under-test, so a lot of developer time is spent just waiting to clear state to get a meaningful test result on each iteration\r\n\r\nWhen the loading times are that bad, it may be caused by your organization having ExecutionPolicy set by a group policy, triggering a very unfortunate code path in PowerShell.\r\n\r\nI personally have a scheduled task to remove the group policy key just to get PowerShell usable. I had load times of 30+ seconds just loading my profile.\r\n\r\nThis is what I run (vbscript to not get a window popping up when the scheduled task is executed).\r\n```vb\r\non error resume next\r\nSet objShell = Wscript.CreateObject(\"Wscript.Shell\")\r\nobjShell.RegDelete \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\PowerShell\\\"\r\n```\r\nSee #2578. Some fixes has been made that are expected in the January release if I understand correctly.",
      "created_at": "2016-12-15T10:55:02Z",
      "updated_at": "2016-12-15T10:55:02Z"
    },
    {
      "author": "AlFeersum",
      "author_association": "NONE",
      "body": "WRT Import-/Remove-Module caching subs in 5.0/5.1 (ref: https://github.com/PowerShell/PowerShell/issues/2505#issuecomment-263369811) - this also happens with 'using module xxx.psm1'\r\n\r\nxxx.psm1 contains a class definition, which gets loaded into the core script. If a method or property in xxx.psm1 changes, the module isn't reloaded as part of an execution, despite the module being listed with Get-Module, and successfully being removed with Remove-Module.\r\n\r\nIf addressing this for Import-/Remove-Module, consideration needs to be made for 'using module ...' - presumably the same underlying code is used, but just in case...",
      "created_at": "2017-05-05T16:09:50Z",
      "updated_at": "2017-05-05T16:09:50Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "This is super-annoying, obviously, but given our desire to postpone classes work until 6.0.0 is stable, I'm moving this out to 6.1.0. ",
      "created_at": "2017-05-22T18:39:46Z",
      "updated_at": "2017-05-22T18:39:46Z"
    },
    {
      "author": "garfbradaz",
      "author_association": "NONE",
      "body": "Is this fixed yet? Happens to me as well when using \"using\"\r\n\r\n`using module 'C:\\Program Files\\WindowsPowerShell\\Modules\\GitHubClient\\GitHubClient.psm1'`\r\n\r\nIf i make changes to my classes within 'GitHubClient.psm1' i have to close and re-open PowerShell ISE. \r\n",
      "created_at": "2017-06-02T14:49:11Z",
      "updated_at": "2017-06-02T14:49:11Z"
    },
    {
      "author": "mallochine",
      "author_association": "NONE",
      "body": "yeah........I hit this while on pwsh in Linux.\r\n\r\n```\r\n$ pwsh --version\r\nPowerShell v6.0.1\r\n```",
      "created_at": "2018-03-12T23:58:59Z",
      "updated_at": "2018-03-12T23:58:59Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "Some historical design notes i.e. what we were thinking when we designed this:\r\n\r\n`Import-Module -Force` was explicitly the equivalent of `Remove-Module ...` then `Import-Module ...`. The core scenario was for module developers who needed to force a reload (reset) of their module.\r\n\r\nDoing an `Import-Module -Force` does not reload sub-modules by design. (Similarly `Remove-Module` does not remove dependent modules.)  The reason for this is that the dependent modules may have been imported by more than one parent module. If you forced the reload of the dependent modules you might break something else. The solution is to require the developer to explicitly do a reload (or remove) of each module. (FWIW I now think we got this wrong. Since the scenario is developers, having a possibly unstable session is just a fact of life and so `Import-Module -Force` should reload everything in `NestedModules` recursively.)\r\n\r\nGetting `Remove-Module` to work even tolerably well was ludicrously difficult. Removing modules is tricky, because there can be references to module elements in a variety of places. So even if the module is removed from the module table, it may still be in memory because of these references. Loading that module again will result in two copies of the module. (Note: we did consider reference counting for unloads but didn't ever get to it.) Ick.\r\n\r\nRemoving a module that exports types is particularly tricky since there may be references to the `Type` object in various places.\r\n\r\n`using module` doesn't have a `-Force` flag and shouldn't. Perhaps we need a developer mode in PowerShell  `Set-DeveloperMode -on` to turn on module auto-reloading...\r\n\r\n(I've probably forgotten some possibly significant stuff. If I remember anything, I will add it later.)\r\n\r\n@iSazonov \r\n> Above I meant that perhaps we need some optimization of module reload that can be significantly for large modules.\r\n\r\nGiven that this is a developer scenario not a production one (and assuming it isn't ridiculously slow) do we really need this? And even if a file hasn't changed, if one of it's dependent modules is updated, the depending module still has to be reloaded. As @lzybkr said, making `Import-Module` fast is probably where the work should go. When I wrote the module code in V2, performance was not one of my goals. As far as I know, we've never done any performance work since then.",
      "created_at": "2018-04-11T18:00:02Z",
      "updated_at": "2018-04-11T18:00:02Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "It is clear and simple design. Sometimes PowerShell do magic things. Perhaps here it could do it too. \r\nWe could inform the user that there are submodules which are not reloaded or to request their forced reload or do something more magic.",
      "created_at": "2018-04-13T04:04:26Z",
      "updated_at": "2018-04-13T04:04:26Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "I think, on the face of it, the intent seems simple. But after spending a fair amount of time reading and stepping through the `Import-Module` code, my feeling is that magic is what's gotten us into trouble here, rather than knowing what our promised functionality is and at what point the onus is back on the scripter.\r\n\r\nMy concern is that `Import-Module`'s behaviour is already so complicated as to make it hard to maintain, and it gets called a lot (e.g. several times per completion). So really I think we should make a clear decision on what its contract with the invoker is, and ensure that the code reflects that (both tasks being still quite tricky).",
      "created_at": "2018-04-13T14:09:00Z",
      "updated_at": "2018-04-13T14:14:09Z"
    },
    {
      "author": "SCLDGit",
      "author_association": "NONE",
      "body": "After skimming through this thread, are we to understand that currently there is no way to reliably auto-update modules with classes/methods? Having both Remove-Module ModuleName -Force and Import-Module .\\Module\\Location\\ModuleName.psm1 -Force fixes nothing here, and necessitating a Visual Studio/ISE restart every time a code change is made makes development a non-starter.",
      "created_at": "2018-04-19T22:19:02Z",
      "updated_at": "2018-04-19T22:19:02Z"
    },
    {
      "author": "alx9r",
      "author_association": "NONE",
      "body": "@SCLDGit You might be interested in [this summary of the issue, its implications, and workarounds](https://stackoverflow.com/a/42878789/1404637).",
      "created_at": "2018-04-20T01:50:30Z",
      "updated_at": "2018-04-20T01:50:40Z"
    },
    {
      "author": "SCLDGit",
      "author_association": "NONE",
      "body": "@alx9r That was useful for confirmation, but I can't believe that anyone would accept that kind of workaround for anything other than the simplest unit test and development cases. It's kind of mind-boggling that this issue was never addressed in the design phase.",
      "created_at": "2018-04-20T14:43:24Z",
      "updated_at": "2018-04-20T14:43:24Z"
    },
    {
      "author": "alx9r",
      "author_association": "NONE",
      "body": ">...I can't believe that anyone would accept that kind of workaround for anything other than the simplest unit test and development cases.\r\n\r\n@SCLDGit  FWIW, the workaround is somewhat less painful using VS Code compared with ISE.  VS Code (v 1.22.2, at least) allows you to reload the PowerShell environment without restarting the editor.  So your workspace survives changes to class definitions.",
      "created_at": "2018-04-22T16:58:07Z",
      "updated_at": "2018-04-22T16:58:07Z"
    },
    {
      "author": "SCLDGit",
      "author_association": "NONE",
      "body": "@alx9r That's good to know. I couldn't manage to pull it off with the Visual Studio extension, but if VS code can do it I may just use that for PS development. Thanks.",
      "created_at": "2018-04-22T17:33:14Z",
      "updated_at": "2018-04-22T17:33:14Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "Another possible workaround is to manually reset the offending cache:\r\n\r\n```powershell\r\nfunction Clear-ScriptAnalysisCache\r\n{\r\n    $fieldInfo = ([Microsoft.PowerShell.Commands.ModuleCmdletBase].GetField(\"s_scriptAnalysisCache\", [System.Reflection.BindingFlags]::NonPublic -bor [System.Reflection.BindingFlags]::Static))[0]\r\n    $scriptAnalysisCache = $fieldInfo.GetValue($null)\r\n    $scriptAnalysisCache.Clear()\r\n}\r\n```\r\n\r\nThe problem is that `s_scriptAnalysisCache` is not thread-safe and currently there's a lock object that protects access. So to do this properly (without corrupting the cache) you'd need to find `Microsoft.PowerShell.Commands.ModuleCmdletBase.s_lockObject` using the same reflection technique and do some [locking in PowerShell](https://davewyatt.wordpress.com/2014/04/06/thread-synchronization-in-powershell/) on that object.\r\n\r\nWhich is really not a great workaround (but unlike restarting things, is simpler to encapsulate in a function).\r\n\r\nI'm currently working on a fix for this.",
      "created_at": "2018-04-22T20:00:07Z",
      "updated_at": "2018-04-22T20:01:33Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "Going to tag this for review by the @PowerShell/powershell-committee , with the specific question of:\r\n> Should `Import-Module -Force` recursively reload nested modules, or should it only reload the top-level module.\r\n\r\n@daxian-dbw's [comment](https://github.com/PowerShell/PowerShell/issues/2505#issuecomment-263369811) and @BrucePay's [comment](https://github.com/PowerShell/PowerShell/issues/2505#issuecomment-380542348) seem to weigh the issue well.",
      "created_at": "2018-04-23T20:54:24Z",
      "updated_at": "2018-04-23T20:54:24Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Should we think about long sessions (login shell), runspaces and concurrency? What if I run a script in one runspace and then I start reload a module in other runspace? Should we use runspace/global cache and/or something like \"copy-on-write\"?",
      "created_at": "2018-04-24T05:35:40Z",
      "updated_at": "2018-04-24T05:35:40Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee reviewed this and rather than breaking `-Force`, we prefer to add `-Recurse` to `Import-Module` and also `Remove-Module` for this desired behavior used with `-Force` and would not be a breaking change.",
      "created_at": "2018-04-25T22:31:52Z",
      "updated_at": "2018-04-25T22:31:52Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "It looks like [`Remove-Module` removes nested modules recursively](https://github.com/PowerShell/PowerShell/blob/35d8de927b8e408461a5b4fc40ba20016c68433e/src/System.Management.Automation/engine/Modules/RemoveModuleCommand.cs#L99) even without the `-Force` flag.\r\n\r\nIs the @PowerShell/powershell-committee's new desired behaviour with the `-Recurse` flag on `Remove-Module` that we only recursively unload with `-Force` and `-Recurse` specified? Or just `-Recurse`? And does that constitute a breaking change we should be worried about?",
      "created_at": "2018-04-25T23:17:49Z",
      "updated_at": "2018-04-25T23:17:49Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@rjmholt the intent is that `-Recurse` is used with `-Force` (part of same parameterset).  Because this is a new switch, it avoids the breaking change.  Note that `-Recurse` isn't just about nested modules, but dependent modules as well.",
      "created_at": "2018-04-26T00:19:15Z",
      "updated_at": "2018-04-26T00:19:15Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "It looks like `-Force` isn't [part of any parameter set](https://github.com/PowerShell/PowerShell/blob/768cfc4adff19e9107597a81cdbc559b7563a80d/src/System.Management.Automation/engine/Modules/ImportModuleCommand.cs#L203). `Import-Module`'s parameter sets are [things like Name, ModuleInfo, Assembly, PSSession](https://github.com/PowerShell/PowerShell/blob/768cfc4adff19e9107597a81cdbc559b7563a80d/src/System.Management.Automation/engine/Modules/ImportModuleCommand.cs#L43) and you can use `-Force` with all of them -- do we have a mechanism available to say \"`-Recurse` is only allowed when `-Force` is present\"?\r\n\r\nBy dependent modules above, do you mean (\"nested modules\" \u222a \"required modules\") (to use the language on the [module manifest documentation page](https://msdn.microsoft.com/en-us/library/dd878337(v=vs.85).aspx))?\r\n\r\nI think the remaining (non-cache-related) complaint in the issue is described by this Pester test:\r\n```powershell\r\nDescribe \"Nested module refreshing in script modules\" {\r\n    BeforeAll {\r\n        $testRoot = Join-Path $TestDrive \"nestedModuleTest\"\r\n        $mod1Name = \"mod1\"\r\n        $subModName = \"sub\"\r\n        $mod1Path = Join-Path $testRoot $mod1Name\r\n        $subModPath = Join-Path $testRoot $subModName\r\n        $mod1PsmPath = Join-Path $mod1Path \"$mod1Name.psm1\"\r\n        $subModPsmPath = Join-Path $subModPath \"$subModName.psm1\"\r\n\r\n        foreach ($modPath in $mod1Path,$subModPath)\r\n        {\r\n            New-Item -Path $modPath -ItemType Directory\r\n        }\r\n    }\r\n\r\n    BeforeEach {\r\n        Get-Module $mod1Name,$subModName | Remove-Module -Force\r\n\r\n        New-Item -Path $mod1PsmPath -Force -Value @\"\r\nImport-Module $subModPath\r\n\r\nfunction Test-TopModuleFunction\r\n{\r\n    Test-SubModuleFunction\r\n}\r\n\"@\r\n\r\n\r\n        New-Item -Path $subModPsmPath -Force -Value @\"\r\nfunction Test-SubModuleFunction\r\n{\r\n    \"Hello\"\r\n}\r\n\"@\r\n    }\r\n\r\n    It \"Does not refresh the submodule definition when Import-Module -Force is used\" {\r\n        Import-Module $mod1Path\r\n\r\n        Test-TopModuleFunction | Should -BeExactly \"Hello\"\r\n\r\n        Set-Content -Path $subModPsmPath -Force -Value \"function Test-SubModuleFunction { 'Aloha' } \"\r\n\r\n        Test-TopModuleFunction | Should -BeExactly \"Hello\"\r\n\r\n        Import-Module -Force $mod1Path\r\n\r\n        # NOTE: We imported with force here, but the submodule function is not refreshed\r\n        Test-TopModuleFunction | Should -BeExactly \"Hello\"\r\n    }\r\n\r\n    It \"Refreshes the submodule defintion when Remove-Module is used without -Force\" {\r\n        Import-Module $mod1Path\r\n\r\n        Test-TopModuleFunction | Should -BeExactly \"Hello\"\r\n\r\n        Set-Content -Path $subModPsmPath -Force -Value \"function Test-SubModuleFunction { 'Howdy' }\"\r\n\r\n        Test-TopModuleFunction | Should -BeExactly \"Hello\"\r\n\r\n        Remove-Module $mod1Name\r\n\r\n        Import-Module $mod1Path\r\n\r\n        # NOTE: We never used -Force with Remove-Module, but the submodule is refreshed\r\n        Test-TopModuleFunction | Should -BeExactly \"Howdy\"\r\n    }\r\n}\r\n```\r\n\r\nLike @BrucePay has described, we don't refresh submodules with `-Force` by design (although the presence of this issue indicates that that's not what everyone expects).\r\n\r\nThe `-Recurse` flag seems like the right way to go, but my concerns for it are:\r\n- `Import-Module` probably needs a way to refresh nested modules without refreshing required modules. This seems like what `-Recurse` should do to me.\r\n- `Remove-Module` already recursively unloads nested modules, even without `-Force`. There's not much else we can do there, because those modules would be orphaned otherwise. (The difference with `Remove-Module -Force` is that it will [remove `ReadOnly` modules](https://github.com/PowerShell/PowerShell/blob/c5415d31a614a7c8e04c18214774c6c32e17ee40/src/System.Management.Automation/engine/Modules/RemoveModuleCommand.cs#L158) and [modules that other modules have as `RequiredModules`](https://github.com/PowerShell/PowerShell/blob/c5415d31a614a7c8e04c18214774c6c32e17ee40/src/System.Management.Automation/engine/Modules/RemoveModuleCommand.cs#L223)).\r\n- The module cmdlets currently do no manipulation of required modules anywhere. They only check for their existence and raise errors.\r\n\r\nSo my suggestion is:\r\n- `Import-Module` should have a `-Recurse` flag that can only be used with `-Force` (and errors otherwise -- probably has to be runtime error because I don't think we have a parameter binder mechanism for this), and `-Recurse` should recursively refresh nested modules only.\r\n- `Remove-Module` already does the nested module stuff, so no need for a `-Recurse` flag there.\r\n- If there's demand for a way to unload/refresh required modules, we can add that later (with a more dangerous looking flag like `-RemoveRequired` or something). But so far in this issue, there has been no mention of required modules.",
      "created_at": "2018-04-27T19:08:04Z",
      "updated_at": "2018-04-27T19:08:35Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "We could implement `-Recurse` as dynamic parameter.",
      "created_at": "2018-04-27T19:14:44Z",
      "updated_at": "2018-04-27T19:14:44Z"
    },
    {
      "author": "aaroncalderon",
      "author_association": "NONE",
      "body": "@rjmholt Your suggestion is grate. \r\n\r\nHowever, I want to point out one detail, consistency.\r\n\r\n## Consistency\r\n\r\nIs there really a need to add more flags rather than fix the behaviour of the current and documented flag?\r\n\r\nAS @alx9r [pointed out](https://github.com/PowerShell/PowerShell/issues/2505#issuecomment-263157383), the documentation explains that the flag `-Force` should reload modules and submodules. \r\n\r\n> -Force\r\n>Indicates that this cmdlet re-imports a module **and its members**, even if the module or its members have an access mode of read-only.\r\n\r\nWhen running `Import-Module -Force`, one would expect it to behave as documented. `-Force`  Must be used if the module change and one wants to reload the changes, but it will not reload submodules. This contradicts the documentation.\r\n\r\n## Conclusion\r\n\r\nIt seems to me that the behavior of the flag -Force should be fixed, rather than add another flag and complicate things further.",
      "created_at": "2018-07-23T14:21:20Z",
      "updated_at": "2018-07-23T14:25:55Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "@aaroncalderon I agree with your preference here. The problem is that the other behaviour is the current one (and has been deemed to be by design). So a recursive reload on `-Force` would be a breaking change. It can be changed, but needs to go through the [PowerShell RFC process](https://github.com/powershell/powershell-rfc) to do so.",
      "created_at": "2018-07-24T16:35:07Z",
      "updated_at": "2018-07-24T16:35:07Z"
    },
    {
      "author": "eedwards-sk",
      "author_association": "NONE",
      "body": "A recent project I started, I decided rather than dot sourcing all my library code, I would encapsulate them in basic nested modules and then import them. This would hopefully make the code more re-usable and easier to test.\r\n\r\nHowever, with this current issue, it sounds like it would be better to go back to dot sourcing the library files instead.\r\n\r\nSo, \ud83d\udc4d to `-Recurse` or anything that lets me leverage native powershell features for library loading rather than having to manage it myself with dot sourcing",
      "created_at": "2019-08-26T18:31:20Z",
      "updated_at": "2019-08-26T18:31:20Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> So, \ud83d\udc4d to -Recurse or anything that lets me leverage native powershell features for library loading rather than having to manage it myself with dot sourcing\r\n\r\nLibraries will load perfectly well; this issue is about the development scenario about **re**loading (changing the code and then wanting to load the new version to kick out the old version).\r\n\r\nIf you're talking about .NET DLL libraries, then even solving this issue wouldn't help you; .NET Core doesn't allow assembly unloading, so you just need to run things in a new process each time.\r\n\r\nIf it's nested PowerShell modules you're trying to reload, you can currently achieve that with `Remove-Module $TopLevelModule; Import-Module $TopLevelModule`.",
      "created_at": "2019-08-27T22:28:36Z",
      "updated_at": "2019-08-27T22:28:36Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "In fact, dot-sourcing would make the unloading of old versions much harder I'd imagine",
      "created_at": "2019-08-27T22:29:28Z",
      "updated_at": "2019-08-27T22:29:28Z"
    },
    {
      "author": "eedwards-sk",
      "author_association": "NONE",
      "body": ">Libraries will load perfectly well; this issue is about the development scenario about reloading (changing the code and then wanting to load the new version to kick out the old version).\r\n\r\nYeah I'm referring to development scenarios (quickly loading/unloading and reloading to test changes).",
      "created_at": "2019-08-28T21:09:29Z",
      "updated_at": "2019-08-28T21:09:29Z"
    },
    {
      "author": "alx9r",
      "author_association": "NONE",
      "body": "@rjmholt @eedwards-sk You might be interested in [this comment](https://github.com/PowerShell/PowerShell/issues/5942#issuecomment-365067309).  My interpretation is that (from the perpective of at least one language author at one time) the _only_ \"supported\" way of implementing multi-file modules was by way of dot-sourcing from `.psm1`.",
      "created_at": "2019-09-09T16:14:19Z",
      "updated_at": "2019-09-09T16:14:19Z"
    },
    {
      "author": "rifftual",
      "author_association": "NONE",
      "body": "Still occurs with PowerShell 7.0.3 and there's no `Recurse` parameter present.",
      "created_at": "2021-03-22T10:26:41Z",
      "updated_at": "2021-03-22T10:26:41Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "If Force reloads only main module and we need new option to reload submodules too we could use more informative name for the new switch like **ReloadSubmodules**. The switch could be implemented as dynamic parameter in addition to Force: `Import-Module name -Force -ReloadSubmodules`.\r\n\r\nAlternative proposal: **ReloadDependencies** if we want to reload classes too as requested in #7654.\r\n\r\nAsk PowerShell-Committee to revisit https://github.com/PowerShell/PowerShell/issues/2505#issuecomment-384454527.",
      "created_at": "2021-08-07T04:19:10Z",
      "updated_at": "2021-08-07T04:30:05Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "So we reviewed this on the @PowerShell/powershell-committee yesterday and our thinking is that implementing the original ask here doesn't address most of the actual issues people have in the comments:\r\n\r\n- Adding a new switch to `Import-Module` (or just changing the behaviour of `Import-Module -Force`) wouldn't change the situation with PowerShell classes, which use `using module`, or with DLLs, which can't be unloaded/reloaded currently\r\n- Adding a new switch to the module cmdlets is also quite complex given the complexity of their implementation and need for expanded testing, so the risk of regression is higher than we'd like given what it buys\r\n- This is not a scenario that's expected to be encountered for most users, since you have to be editing a psm1 file and reloading it to see an issue here (i.e. be a module developer)\r\n- You can achieve what's needed here today by composing two existing commands: `Remove-Module` and `Import-Module`\r\n\r\nGiven this, plus the historical notes and how long this issue has been open, the consensus was that we should close this issue as by design.\r\n\r\nWith that said, from me personally:\r\n\r\n- I've added this for Engine WG discussion, since I think that's now the best forum for this. We'll discuss that in our next meeting and delay closing until then.\r\n- If the module cache issue still exists, that is a bug and should be fixed\r\n- There was some discussion around a developer-mode style setting where (for example) modules are always reloaded. It might be worth continuing that discussion in a separate issue\r\n- The DLL reloading situation *could possibly* be improved with module ALC isolation, but it's complicated, comes with its own set of issues, and isn't likely to be in an initial implementation for those reasons",
      "created_at": "2021-08-19T23:46:06Z",
      "updated_at": "2021-08-19T23:46:06Z"
    }
  ],
  "created_at": "2016-10-19T08:50:13Z",
  "number": 2505,
  "state": "open",
  "title": "Reloading module does not reload submodules.",
  "updated_at": "2021-08-19T23:46:12Z"
}