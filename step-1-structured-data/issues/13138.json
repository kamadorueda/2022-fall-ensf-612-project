{
  "_url": "https://github.com/PowerShell/PowerShell/issues/13138",
  "author": "carlocardella",
  "body": "<!--\r\n\r\nFor Windows PowerShell 5.1 issues, suggestions, or feature requests please use the following link instead:\r\nWindows PowerShell [UserVoice](https://windowsserver.uservoice.com/forums/301869-powershell)\r\n\r\nThis repository is **ONLY** for PowerShell Core 6 and PowerShell 7+ issues.\r\n\r\n- Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\r\n- Search the existing issues.\r\n- Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\r\n- Refer to the [known issues](https://docs.microsoft.com/powershell/scripting/whats-new/known-issues-ps6).\r\n\r\n-->\r\n\r\n## Steps to reproduce\r\nUse Powershell 7.1 preview 4 or 5\r\n\r\n```powershell\r\nImport-Module Appx\r\n```\r\n\r\n## Expected behavior\r\n\r\n```none\r\nSuccessfully load the module\r\n```\r\n\r\n## Actual behavior\r\n\r\n```none\r\nipmo Appx\r\nImport-Module: Operation is not supported on this platform. (0x80131539)\r\n```\r\n\r\n## Environment data\r\n\r\n<!-- provide the output of $PSVersionTable -->\r\n\r\n```none\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.1.0-preview.5\r\nPSEdition                      Core\r\nGitCommitId                    7.1.0-preview.5\r\nOS                             Microsoft Windows 10.0.19041\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n\r\nThe module can be imported properly in Powershell 7.0.2 or, in Preview 4/5 using `-UseWindowsPowerShell`.\r\nI was able to load the module till 7.1 Preview 3\r\n\r\nIs this an expected breaking change? Asking in case I need to update my scripts to use `-UseWindowsPowerShell`",
  "closed_at": "2022-09-23T16:01:25Z",
  "comments": [
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@SteveL-MSFT @joeyaiello this sounds like it could be a consequence of the missing WinRT libraries (https://github.com/PowerShell/PowerShell/issues/13042). Will the Appx module maintainers will want to package the WinRT libs with their module? Even if they do, it will mean anyone using newer versions of PS on older Windows versions will be unable to use the AppX module, since that module is shipped with Windows.\r\n\r\n@carlocardella can you provide the output from `Get-Error` after the failed import as well? Thanks! \ud83d\ude0a ",
      "created_at": "2020-07-08T22:42:52Z",
      "updated_at": "2020-07-08T22:52:51Z"
    },
    {
      "author": "carlocardella",
      "author_association": "NONE",
      "body": "Here you go: \r\n\r\n```\r\n[92mException             : [0m\r\n    [92mType       : [0mSystem.PlatformNotSupportedException\r\n    [92mTargetSite : [0m\r\n        [92mName          : [0mGetExportedTypes\r\n        [92mDeclaringType : [0mSystem.Reflection.RuntimeAssembly, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e\r\n        [92mMemberType    : [0mMethod\r\n        [92mModule        : [0mSystem.Private.CoreLib.dll\r\n    [92mStackTrace : [0m\r\n   at System.Reflection.RuntimeAssembly.GetExportedTypes()\r\n   at System.Reflection.Assembly.get_ExportedTypes()\r\n   at System.Management.Automation.Runspaces.PSSnapInHelpers.GetAssemblyTypes(Assembly assembly, String name)\r\n   at System.Management.Automation.Runspaces.PSSnapInHelpers.AnalyzeModuleAssemblyWithReflection(Assembly assembly, String name, PSSnapInInfo psSnapInInfo, PSModuleInfo moduleInfo, String helpFile, Dictionary`2& cmdlets, Dictionary`2& aliases, Dictionary`2& providers)\r\n   at System.Management.Automation.Runspaces.PSSnapInHelpers.AnalyzePSSnapInAssembly(Assembly assembly, String name, PSSnapInInfo psSnapInInfo, PSModuleInfo moduleInfo, Dictionary`2& cmdlets, Dictionary`2& aliases, Dictionary`2& providers, String& helpFile)\r\n   at System.Management.Automation.Runspaces.InitialSessionState.ImportCmdletsFromAssembly(Assembly assembly, PSModuleInfo module)\r\n   at Microsoft.PowerShell.Commands.ModuleCmdletBase.LoadBinaryModule(PSModuleInfo parentModule, Boolean trySnapInName, String moduleName, String fileName, Assembly assemblyToLoad, String moduleBase, SessionState ss, ImportModuleOptions options, ManifestProcessingFlags manifestProcessingFlags, String prefix, Boolean loadTypes, Boolean loadFormats, Boolean& found, String shortModuleName, Boolean disableFormatUpdates)\r\n   at Microsoft.PowerShell.Commands.ModuleCmdletBase.LoadModuleNamedInManifest(PSModuleInfo parentModule, ModuleSpecification moduleSpecification, String moduleBase, Boolean searchModulePath, String prefix, SessionState ss, ImportModuleOptions options, ManifestProcessingFlags manifestProcessingFlags, Boolean loadTypesFiles, Boolean loadFormatFiles, Object privateData, Boolean& found, String shortModuleName, Nullable`1 manifestLanguageMode)\r\n   at Microsoft.PowerShell.Commands.ModuleCmdletBase.LoadModuleManifest(String moduleManifestPath, ExternalScriptInfo manifestScriptInfo, Hashtable data, Hashtable localizedData, ManifestProcessingFlags manifestProcessingFlags, Version minimumVersion, Version maximumVersion, Version requiredVersion, Nullable`1 requiredModuleGuid, ImportModuleOptions& options, Boolean& containedErrors)\r\n   at Microsoft.PowerShell.Commands.ModuleCmdletBase.LoadModule(PSModuleInfo parentModule, String fileName, String moduleBase, String prefix, SessionState ss, Object privateData, ImportModuleOptions& options, ManifestProcessingFlags manifestProcessingFlags, Boolean& found, Boolean& moduleFileFound)\r\n   at Microsoft.PowerShell.Commands.ModuleCmdletBase.LoadUsingExtensions(PSModuleInfo parentModule, String moduleName, String fileBaseName, String extension, String moduleBase, String prefix, SessionState ss, ImportModuleOptions options, ManifestProcessingFlags manifestProcessingFlags, Boolean& found, Boolean& moduleFileFound)\r\n   at Microsoft.PowerShell.Commands.ModuleCmdletBase.LoadUsingModulePath(PSModuleInfo parentModule, Boolean found, IEnumerable`1 modulePath, String name, SessionState ss, ImportModuleOptions options, ManifestProcessingFlags manifestProcessingFlags, PSModuleInfo& module)\r\n   at Microsoft.PowerShell.Commands.ImportModuleCommand.ImportModule_LocallyViaName(ImportModuleOptions importModuleOptions, String name)\r\n   at Microsoft.PowerShell.Commands.ImportModuleCommand.ImportModule_LocallyViaName_WithTelemetry(ImportModuleOptions importModuleOptions, String name)\r\n   at Microsoft.PowerShell.Commands.ImportModuleCommand.ProcessRecord()\r\n   at System.Management.Automation.CommandProcessor.ProcessRecord()\r\n    [92mMessage    : [0mOperation is not supported on this platform. (0x80131539)\r\n    [92mSource     : [0mSystem.Private.CoreLib\r\n    [92mHResult    : [0m-2146233031\r\n[92mCategoryInfo          : [0mNotSpecified: (:) [Import-Module], PlatformNotSupportedException\r\n[92mFullyQualifiedErrorId : [0mSystem.PlatformNotSupportedException,Microsoft.PowerShell.Commands.ImportModuleCommand\r\n[92mInvocationInfo        : [0m\r\n    [92mMyCommand        : [0mImport-Module\r\n    [92mScriptLineNumber : [0m1\r\n    [92mOffsetInLine     : [0m1\r\n    [92mHistoryId        : [0m33\r\n    [92mLine             : [0mipmo Appx\r\n    [92mPositionMessage  : [0mAt line:1 char:1\r\n                       + ipmo Appx\r\n                       + ~~~~~~~~~\r\n    [92mInvocationName   : [0mipmo\r\n    [92mCommandOrigin    : [0mInternal\r\n[92mScriptStackTrace      : [0mat <ScriptBlock>, <No file>: line 1\r\n```",
      "created_at": "2020-07-08T22:47:49Z",
      "updated_at": "2020-07-08T22:47:49Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "Hmmmm, this I don't understand, as the compatible libraries should be available on the box. But it's WinRT, not NetFx, so we're probably not looking in the right place for them with our GAC logic. Or maybe the included WinRT libraries in 3.1 were forwarders all along? \n\n@adityapatwardhan can you and I talk about this one offline this week? ",
      "created_at": "2020-07-08T22:52:29Z",
      "updated_at": "2020-07-08T22:52:29Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@joeyaiello PowerShell is likely still loading everything as it does in 7.0, but the CoreCLR cannot consume Windows Metadata files (WinMDs) anymore.\r\n\r\nQuote from https://github.com/dotnet/docs/issues/18875\r\n> #### Old behavior\r\n> Consumption of WinMDs by CoreCLR was possible. This permitted activation and consumption of WinRT types.\r\n>\r\n> #### New behavior\r\n> Direct consumption of WinMDs is no longer possible by CoreCLR.\r\n>\r\n> Examples of failures that may now occur:\r\n> ...\r\n> Activation of a WinRT class will result in the following:\r\n>```\r\n>Unhandled exception. System.PlatformNotSupportedException: Operation is not supported on this platform. (0x80131539)\r\n>```",
      "created_at": "2020-07-09T00:00:57Z",
      "updated_at": "2020-07-09T00:03:12Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "@joeyaiello It's throwing in [`Assembly::FindModuleByTypeRef`](https://github.com/dotnet/runtime/blob/cb1a7feaa43cdbd03b317db24fa30d86eae2a27c/src/coreclr/src/vm/assembly.cpp#L1039) when resolving an assembly reference with `WindowsRuntime` in it's assembly flags.  Loading the WinRT package won't change that unfortunately.  All binary modules that previously utilized WinRT will need to be recompiled to target the new package explicitly.  Don't think there's anything PowerShell can do about it.\r\n\r\n**Edit:** Oops GitHub didn't update, @daxian-dbw beat me to it \ud83d\ude42 ",
      "created_at": "2020-07-09T00:47:54Z",
      "updated_at": "2020-07-09T00:48:42Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "But as @SteveL-MSFT noted [here](https://github.com/PowerShell/PowerShell/issues/13042#issuecomment-653357546) (and @iSazonov below that), if the module author can put em back, than so can PS.\n\nMy question is whether we need both of those DLLs to get this WinMD support, or if we could ship something lighter that picks up the remaining right stuff off the Windows install. \n\nAlso, I'd like to spend a little time understanding .NET's decision a little better. We may be reinventing the wheel here, or they may be a larger reason they pulled support in .NET 5 that we're missing. \n\nI'll try to do a little digging this week \n\n",
      "created_at": "2020-07-09T01:42:30Z",
      "updated_at": "2020-07-09T01:42:30Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> But as @SteveL-MSFT noted [here](https://github.com/PowerShell/PowerShell/issues/13042#issuecomment-653357546) (and @iSazonov below that), if the module author can put em back, than so can PS.\r\n\r\nThat works because he's referencing the newly defined types from the package.  The AppX module directly references WinRT types.  This exception is at type load because of how the `AssemblyRef` is encoded.\r\n\r\n> My question is whether we need both of those DLLs to get this WinMD support, or if we could ship something lighter that picks up the remaining right stuff off the Windows install.\r\n\r\nI'd love to be wrong but I'm pretty sure there's nothing PowerShell can ship to make this work, other than a new version of the AppX module.",
      "created_at": "2020-07-09T02:01:42Z",
      "updated_at": "2020-07-09T02:01:42Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "The exception is too early in the code path for anything to be injected atm.  I don't know if this would work, but it might be worth talking to the dotnet team to see if the exception can be moved to after custom assembly resolve handlers are raised. *Maybe* if that was done the handler could point the resolution request to the new managed lib.  At a glance it looks like the signatures should match.\r\n\r\nI'm guessing that would be flimsy at absolute best but maybe that sparks an idea for them.",
      "created_at": "2020-07-09T12:28:49Z",
      "updated_at": "2020-07-09T13:00:29Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "Nah that's a bust.  To test I manually removed the assembly ref flag for `WindowsRuntime` on the assembly in the GAC (ty dnSpy) and added an assembly resolve handler to point the ref to the new managed lib.  It actually works for the most part, but eventually I get a JIT exception because the new managed lib prefixes it's set accessor methods with `set_` instead of `put_`.\r\n\r\n```raw\r\nException             :\r\n    Type       : System.MissingMethodException\r\n    Message    : Method not found: 'Void Windows.Foundation.IAsyncOperationWithProgress`2.put_Completed(Windows.Foundation.AsyncOperationWithProgressCompletedHandler`2<!0,!1>)'.\r\n    TargetSite :\r\n        Name          : RunAppxOperation\r\n        DeclaringType : Microsoft.Windows.Appx.PackageManager.Commands.AppxPackageManager\r\n        MemberType    : Method\r\n        Module        : Microsoft.Windows.Appx.PackageManager.Commands.dll\r\n    StackTrace :\r\n   at Microsoft.Windows.Appx.PackageManager.Commands.AppxPackageManager.RunAppxOperation()\r\n   at Microsoft.Windows.Appx.PackageManager.Commands.AppxPackageManager.SetVolumeState(AppxVolume volume, Boolean setOnline)\r\n   at Microsoft.Windows.Appx.PackageManager.Commands.MountAppxVolumeCommand.ProcessRecord()\r\n   at System.Management.Automation.CommandProcessor.ProcessRecord()\r\n    Source     : Microsoft.Windows.Appx.PackageManager.Commands\r\n    HResult    : -2146233069\r\nCategoryInfo          : NotSpecified: (:) [Mount-AppxVolume], MissingMethodException\r\nFullyQualifiedErrorId : System.MissingMethodException,Microsoft.Windows.Appx.PackageManager.Commands.MountAppxVolumeCommand\r\nInvocationInfo        :\r\n    MyCommand        : Mount-AppxVolume\r\n    ScriptLineNumber : 1\r\n    OffsetInLine     : 22\r\n    HistoryId        : 34\r\n    Line             : Get-AppPackageVolume|Mount-AppxVolume\r\n    PositionMessage  : At line:1 char:22\r\n                       + Get-AppPackageVolume|Mount-AppxVolume\r\n                       +                      ~~~~~~~~~~~~~~~~\r\n    InvocationName   : Mount-AppxVolume\r\n    CommandOrigin    : Internal\r\nScriptStackTrace      : at <ScriptBlock>, <No file>: line 1\r\n```",
      "created_at": "2020-07-09T13:57:26Z",
      "updated_at": "2020-07-09T13:57:26Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "I manually changed the method ref to `set_` in the strings heap and now everything appears to be working fine.  Maybe the team working on the managed lib could add fake `put_` accessors that point to the `set_` accessors for compat (hidden with `EditorBrowsableState.Never`).",
      "created_at": "2020-07-09T14:15:31Z",
      "updated_at": "2020-07-09T14:18:06Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "It seems .Net team explicitly said that WinRT application should be recompiled in the case. So we need new version of the module.",
      "created_at": "2020-07-09T15:14:04Z",
      "updated_at": "2020-07-09T15:14:04Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "@iSazonov Yeah that's definitely their current stance.  It was pretty easy to coerce it into working though. I think it would be moderately easy for the dotnet team to enable an application to re-add support for these assemblies.  They would be able to keep actual support for winrt completely out of dotnet/runtime, but an application like PowerShell could hook it back up potentially seamlessly.\r\n\r\nAnyway that's mainly just to give @joeyaiello some ideas if he was still intending to discuss it with them.  If not then yeah just ship a new version I suppose.",
      "created_at": "2020-07-10T16:57:59Z",
      "updated_at": "2020-07-10T16:58:32Z"
    },
    {
      "author": "xmha97",
      "author_association": "NONE",
      "body": "I have exactly the same problem. \ud83d\ude2d",
      "created_at": "2020-07-17T14:52:31Z",
      "updated_at": "2020-07-17T14:52:31Z"
    },
    {
      "author": "salyounis",
      "author_association": "NONE",
      "body": "> I manually changed the method ref to `set_` in the strings heap and now everything appears to be working fine. Maybe the team working on the managed lib could add fake `put_` accessors that point to the `set_` accessors for compat (hidden with `EditorBrowsableState.Never`).\r\n\r\ncan you place a download link of your package so can verify it too?",
      "created_at": "2020-07-19T16:43:06Z",
      "updated_at": "2020-07-19T16:43:06Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "@salyounis It was just for testing purposes, I would heavily advise against using an assembly whose metadata has been modified manually.",
      "created_at": "2020-07-19T17:03:39Z",
      "updated_at": "2020-07-19T17:03:39Z"
    },
    {
      "author": "TravisEz13",
      "author_association": "MEMBER",
      "body": "We are still investigating this, but we are open to servicing this if this isn't fixed by 7.1 release.",
      "created_at": "2020-08-20T19:09:10Z",
      "updated_at": "2020-08-20T19:09:10Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "Per .NET team, if we retarget the Windows release to `net50-windows`, that would pull in the WinRT assemblies and should work.  However, that new [TFM](https://github.com/dotnet/designs/blob/master/accepted/2020/net5/net5.md) isn't available until .NET 5 Preview 8.",
      "created_at": "2020-08-20T21:25:36Z",
      "updated_at": "2020-08-20T21:26:00Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "@SteveL-MSFT are we 100% sure they mean it'll work without recompiling?  It fails at the runtime level, unless they plan on lighting up the assembly resolution logic again, this module will still need to be recompiled.",
      "created_at": "2020-08-20T23:24:32Z",
      "updated_at": "2020-08-20T23:24:32Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@SeeminglyScience won't know until we try, the implication is that retargeting to the new TFM will pull in the necessary assemblies to make it work.  My suspicion is that a recompilation of Appx module is required, but that will then break running in Windows PowerShell.  The other option is to not mark it as Core compatible to have it go through the Windows PowerShell path.\r\n\r\nEven now, you can just `import-module appx -usewindowspowershell` to get it working.",
      "created_at": "2020-08-21T00:29:57Z",
      "updated_at": "2020-08-21T00:29:57Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> @SeeminglyScience won't know until we try, the implication is that retargeting to the new TFM will pull in the necessary assemblies to make it work.\r\n\r\nThis may already be understood so I apologize if I'm just reiterating facts y'all already know, but the point where this exception is thrown won't be affected by any additional assemblies.  It's hard coded to throw at type ref resolution well before any other code runs.  It's more or less the first stop in the code path.\r\n\r\nReally I'm just trying to make sure y'all aren't banking on that working, if that's already understood then \ud83d\udc4d \r\n\r\n> My suspicion is that a recompilation of Appx module is required, but that will then break running in Windows PowerShell. The other option is to not mark it as Core compatible to have it go through the Windows PowerShell path.\r\n\r\nI did outline another potential path that would allow host processes like PowerShell to map these older assembly references to the new library.\r\n\r\n1. Defer the exception in  [`Assembly::FindModuleByTypeRef`](https://github.com/dotnet/runtime/blob/cb1a7feaa43cdbd03b317db24fa30d86eae2a27c/src/coreclr/src/vm/assembly.cpp#L1039) until *after* assembly resolve events are raised.  If a registered handler finds the assembly then don't throw, if it does then throw the same exception\r\n1. In the new WinRT package add `put_` methods that map to the new `set_` accessor methods for properties\r\n\r\nIf those are done then compat can be kept for these modules without compromising their goal of getting the code out of `dotnet/runtime`.\r\n\r\nI just want to make sure all the options are being considered.  If y'all don't want to pursue that then \ud83d\udc4d \r\n",
      "created_at": "2020-08-21T00:49:51Z",
      "updated_at": "2020-08-21T00:49:51Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@SeeminglyScience spoke with .NET team and based on your idea, they agreed that to maintain compatibility, they would expose both set_ and put_ accessors for WinRT https://github.com/microsoft/CsWinRT/pull/402.  Thanks!",
      "created_at": "2020-09-04T00:46:37Z",
      "updated_at": "2020-09-04T00:46:37Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "@SteveL-MSFT That's awesome! Thanks for talking to them.\r\n\r\nHas there been any discussion with the runtime team regarding moving the assembly resolution exception? This is sort of an all or nothing scenario where if that part doesn't happen there won't be a need for the `put_` methods.\r\n\r\nJust to spell it all out in case any of this isn't clear, let say we have a TypeRef encoded like this:\r\n\r\n```il\r\n.assembly extern windowsruntime Windows\r\n{\r\n    .ver 255:255:255:255\r\n}\r\n\r\n[Windows]Windows.Foundation.AsyncStatus\r\n```\r\n\r\nThat sets the content type for the assembly as `WindowsRuntime`.\r\n\r\nAssembly resolution at a high level looks like this:\r\n\r\n1. Check if the content type is `WindowsRuntime` and throw `NotSupportedException`\r\n1. Run any `AssemblyResolve` event handlers\r\n1. Default resolve/load behavior\r\n\r\nSo ideally the PowerShell engine would be able to register an `AssemblyResolve` handler that looks something like this (psuedo code):\r\n\r\n```csharp\r\nAssembly Resolve(object sender, ResolveEventArgs args)\r\n{\r\n    if (args.Name.StartsWith(\"Windows\") && args.Name.Contains(\"WindowsRuntime\"))\r\n    {\r\n        return CsWinRTAssembly;\r\n    }\r\n\r\n    return null;\r\n}\r\n```\r\n\r\nBut because assembly resolution never makes it past the first step, that handler will never fire.  If the `NotSupportedException` could be moved until *after* assembly resolution doesn't find anything then compatibility could be kept.\r\n\r\nWithout that, these modules will still need to be recompiled and at that point they'll just use the `set_` accessors anyway.",
      "created_at": "2020-09-04T12:44:30Z",
      "updated_at": "2020-09-10T01:23:29Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "Ok, after extensive discussions with .NET team and a change in their Windows.SDK assembly that handles WinRT calls to support both `put_` and `set_` for compatibility, the fix still requires Appx module to be retargeted for netstandard20.  Working with the Appx team to do this.  Since there is no change in PowerShell that can be done, closing this.",
      "created_at": "2020-10-02T20:01:13Z",
      "updated_at": "2020-10-02T20:01:13Z"
    },
    {
      "author": "doctordns",
      "author_association": "COLLABORATOR",
      "body": "\r\n> I'd love to be wrong but I'm pretty sure there's nothing PowerShell can ship to make this work, other than a new version of the AppX module.\r\n\r\nIn the short term, can we get the compatibility deny list updated? SInce this module can not work natively with PowerShell 7.1, let's just not load it (by default).",
      "created_at": "2020-11-12T19:45:52Z",
      "updated_at": "2020-11-12T19:45:52Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> In the short term, can we get the compatibility deny list updated? SInce this module can not work natively with PowerShell 7.1, let's just not load it (by default).\r\n\r\n/cc @anmenaga ",
      "created_at": "2020-11-13T03:30:47Z",
      "updated_at": "2020-11-13T03:30:47Z"
    },
    {
      "author": "juvtib",
      "author_association": "NONE",
      "body": "What is the impact of \r\n\r\n```\r\nWARNING: Module Appx is loaded in Windows PowerShell using WinPSCompatSession remoting session; \r\nplease note that all input and output of commands from this module will be deserialized objects. \r\n```\r\n\r\nwhile working on a live system? ",
      "created_at": "2020-11-15T19:22:05Z",
      "updated_at": "2020-11-15T19:22:05Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "If a module is not supported in PowerShell the PowerShell creates a remote session to Windows PowerShell and run the module there. Limitation - you will receive reserialized objects in local session.",
      "created_at": "2020-11-16T03:11:40Z",
      "updated_at": "2020-11-16T03:11:40Z"
    },
    {
      "author": "juvtib",
      "author_association": "NONE",
      "body": "So `Get-AppxPackage` will give accurate results and `Add-AppxPackage` will affect the live system? \r\nIf this is true, what is the difference between working with de/serialized objects and live data? ",
      "created_at": "2020-11-16T13:45:22Z",
      "updated_at": "2020-11-16T13:45:22Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "@juvtib When an object is serialized it loses methods, some properties may be typed differently or contain slightly different values, some may lose nested objects, and they may no longer work as arguments to strongly typed parameters.\r\n\r\nWhether it effects your specific workflows is something you'll need to test to find out.",
      "created_at": "2020-11-16T14:26:34Z",
      "updated_at": "2020-11-16T14:26:34Z"
    },
    {
      "author": "doctordns",
      "author_association": "COLLABORATOR",
      "body": "Another side effect of the compatibility solution is that, at present, Display XML created by modules is not imported into the Parent PowerShell 7 session. So the output from commands such as Get-WindowsFeature produces sub-optimal output. You can, of course, always manually import the XML to get around this issue.",
      "created_at": "2020-11-16T20:30:34Z",
      "updated_at": "2020-11-16T20:30:34Z"
    },
    {
      "author": "fgimian",
      "author_association": "NONE",
      "body": "I was too a bit surprised that a minor update (7.1) broke my scripts.  It's a shame because everything worked well in 7.0.3.\r\n\r\nBased on the discussion above, are we likely to see the return of native Appx support in a future version of PowerShell or will we need to use the `-UseWindowsPowerShell` for all future PowerShell versions > 7.1?\r\n\r\nThanks heaps\r\nFotis",
      "created_at": "2020-12-10T04:55:00Z",
      "updated_at": "2020-12-10T04:55:00Z"
    },
    {
      "author": "doctordns",
      "author_association": "COLLABORATOR",
      "body": "given that Appx does NOT natively load in PowerShell 7, should that module be added to the deny list?",
      "created_at": "2020-12-10T10:41:36Z",
      "updated_at": "2020-12-10T10:41:36Z"
    },
    {
      "author": "Kein",
      "author_association": "NONE",
      "body": "Same issue. Any ETA on this?",
      "created_at": "2021-01-04T16:58:11Z",
      "updated_at": "2021-01-04T16:58:11Z"
    },
    {
      "author": "asklar",
      "author_association": "NONE",
      "body": "@SteveL-MSFT any updates on this? Still happening on 7.1.0",
      "created_at": "2021-01-07T11:24:26Z",
      "updated_at": "2021-01-07T11:24:26Z"
    },
    {
      "author": "ntpmhlk",
      "author_association": "NONE",
      "body": "My workaround: \r\nTry default Windows Powershell(version 5). It works fine with `Get-appxpackage` command.",
      "created_at": "2021-01-19T02:49:53Z",
      "updated_at": "2021-01-19T02:49:53Z"
    },
    {
      "author": "JohannesWiesner",
      "author_association": "NONE",
      "body": "> @SeeminglyScience won't know until we try, the implication is that retargeting to the new TFM will pull in the necessary assemblies to make it work. My suspicion is that a recompilation of Appx module is required, but that will then break running in Windows PowerShell. The other option is to not mark it as Core compatible to have it go through the Windows PowerShell path.\r\n> \r\n> Even now, you can just `import-module appx -usewindowspowershell` to get it working.\r\n\r\nI had the same issue, this comment solved it for me.",
      "created_at": "2021-01-24T14:59:28Z",
      "updated_at": "2021-01-24T14:59:28Z"
    },
    {
      "author": "jmroyb",
      "author_association": "NONE",
      "body": "> > @SeeminglyScience won't know until we try, the implication is that retargeting to the new TFM will pull in the necessary assemblies to make it work. My suspicion is that a recompilation of Appx module is required, but that will then break running in Windows PowerShell. The other option is to not mark it as Core compatible to have it go through the Windows PowerShell path.\r\n> > Even now, you can just `import-module appx -usewindowspowershell` to get it working.\r\n> \r\n> I had the same issue, this comment solved it for me.\r\n\r\nMe too! this comment solved it for me.",
      "created_at": "2021-01-29T15:56:04Z",
      "updated_at": "2021-01-29T15:56:04Z"
    },
    {
      "author": "juvtib",
      "author_association": "NONE",
      "body": "``` powershell\r\nSwitch ($PSVersionTable.PSVersion.ToString())\r\n{\r\n  \"7.1.0\" {Import-Module -Name Appx -UseWindowsPowerShell; Break}\r\n  \"7.1.1\" {Import-Module -Name Appx -UseWindowsPowerShell; Break}\r\n}\r\n```",
      "created_at": "2021-02-02T11:43:55Z",
      "updated_at": "2021-02-02T11:43:55Z"
    },
    {
      "author": "fgimian",
      "author_association": "NONE",
      "body": "Is the `UseWindowsPowerShell` the correct solution moving forward?  I may be missing something but this was seemingly natively supported in PowerShell 7.0.x before.  Doesn't relying on Windows PowerShell go against the point that PowerShell 7+ is the future and supposed to replace Windows PowerShell?\r\n\r\nPerforming the import above adds an extra second or two to any script that uses Appx, when this wasn't the case or needed in 7.0.x.\r\n\r\nJust trying to understand what the way forward here is \ud83d\ude04 \r\n\r\nThanks\r\nFotis",
      "created_at": "2021-02-21T12:08:01Z",
      "updated_at": "2021-02-21T12:08:01Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> Just trying to understand what the way forward here is \ud83d\ude04\r\n\r\nThe module needs to be recompiled to reference the new CsWinRT library instead of referencing WinRT directly. The change itself **should** be pretty simple, but the module ships in Windows and probably isn't owned by PowerShell team so I wouldn't hold out for that.",
      "created_at": "2021-02-21T15:37:56Z",
      "updated_at": "2021-02-21T15:39:40Z"
    },
    {
      "author": "Starstrike",
      "author_association": "NONE",
      "body": "This is still an issue in Powershell 7.1.3. I cannot run Get-AppxPackage and get told to run Import-Module Appx which also gives me an error.\r\n\r\n![image](https://user-images.githubusercontent.com/1996734/111788558-9a4ad700-8896-11eb-8211-ce3878d75a07.png)\r\n\r\n",
      "created_at": "2021-03-19T13:36:46Z",
      "updated_at": "2021-03-19T13:36:46Z"
    },
    {
      "author": "assist726",
      "author_association": "NONE",
      "body": "> This is still an issue in Powershell 7.1.3. I cannot run Get-AppxPackage and get told to run Import-Module Appx which also gives me an error.\r\n> \r\n> ![image](https://user-images.githubusercontent.com/1996734/111788558-9a4ad700-8896-11eb-8211-ce3878d75a07.png)\r\n\r\nLikewise same problem here ",
      "created_at": "2021-03-20T03:25:02Z",
      "updated_at": "2021-03-20T03:25:02Z"
    },
    {
      "author": "keithnicholson",
      "author_association": "NONE",
      "body": "I know this is closed, but I am having the same issue and now we cannot sideload app we have created in our company. Can there be a reference to another issue in process with another team if necessary.",
      "created_at": "2021-03-25T11:59:55Z",
      "updated_at": "2021-03-25T11:59:55Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "@joeyaiello @SteveL-MSFT Someone might want to reach out to the team that owns this module directly. This issue is getting some unusually high engagement for this repo.",
      "created_at": "2021-03-25T13:17:15Z",
      "updated_at": "2021-03-25T13:17:15Z"
    },
    {
      "author": "ds-steventondeur",
      "author_association": "NONE",
      "body": "I got the same issue trying to install Ubutnu 20.04 without having to sign in into the windows store.\r\nUsing `Import-Module Appx -usewindowspowershell` worked for me but I had to search quite a bit before I ended up here and found the solution.",
      "created_at": "2021-04-06T07:07:09Z",
      "updated_at": "2021-04-06T07:07:09Z"
    },
    {
      "author": "koumaza",
      "author_association": "NONE",
      "body": "We can use this.\r\nNo happen warning. But slow the same continually.\r\n\r\n```pwsh\r\n$Before_WarningPreference = $WarningPreference\r\n$WarningPreference = 'SilentlyContinue'\r\nImport-Module -Name Appx -UseWindowsPowerShell\r\n$WarningPreference = $Before_WarningPreference\r\n```",
      "created_at": "2021-04-06T07:46:25Z",
      "updated_at": "2021-04-06T07:46:25Z"
    },
    {
      "author": "SekiBetu",
      "author_association": "NONE",
      "body": "`-usewindowspowershell` is not a solution, it only means we are using the old version of powershell, we need to stick to the problem and fix it.",
      "created_at": "2021-04-11T17:55:30Z",
      "updated_at": "2021-04-11T17:55:30Z"
    },
    {
      "author": "kyanha",
      "author_association": "CONTRIBUTOR",
      "body": "Can this issue be reopened until whatever's going on (and whatever happens with the AppX module in Windows 10) is fixed?  This breaks the Windows Store troubleshooting workflow.",
      "created_at": "2021-04-21T20:07:40Z",
      "updated_at": "2021-04-21T20:07:40Z"
    },
    {
      "author": "FuccDucc",
      "author_association": "NONE",
      "body": "> Ok, after extensive discussions with .NET team and a change in their Windows.SDK assembly that handles WinRT calls to support both `put_` and `set_` for compatibility, the fix still requires Appx module to be retargeted for netstandard20. Working with the Appx team to do this. Since there is no change in PowerShell that can be done, closing this.\r\n\r\nYou wrote this in 2020\r\n\r\nBut now it is almost June 2021 and the issue persists..\r\n\r\nentered `Get-AppxPackage appname | Remove-AppxPackage`\r\n\r\nError:\r\n```\r\nGet-AppxPackage: The 'Get-AppxPackage' command was found in the module 'Appx', but the module could not be loaded. For more information, run 'Import-Module Appx'.\r\n```\r\n\r\nWent on to enter `Import-Module Appx` as it asks\r\n\r\nError:\r\n```\r\nImport-Module: Operation is not supported on this platform. (0x80131539)\r\n```\r\n\r\n\r\nIt's only working on Powershell.exe from `C:\\Windows\\System32\\WindowsPowerShell\\v1.0` (Built into Windows 10), so for now until github powershell projects takes enough interest to end up getting it fixed, for users like me the github powershell is no proper replacement candidate for the windows built-in version of powershell.\r\n\r\nDo you not strive for feature parity? You should take this as a serious issue.",
      "created_at": "2021-05-27T05:05:02Z",
      "updated_at": "2021-05-27T05:05:59Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "I'll see if I can get more concrete plans from Appx team, but for now you can use:\r\n\r\n```powershell\r\nimport-module appx -usewindowspowershell\r\n```\r\n",
      "created_at": "2021-05-27T21:51:51Z",
      "updated_at": "2021-05-27T21:51:51Z"
    },
    {
      "author": "fgimian",
      "author_association": "NONE",
      "body": "> ```powershell\r\n> Import-Module -Name Appx -UseWindowsPowerShell\r\n> ```\r\n\r\nYou can do this in one line actually:\r\n\r\n```powershell\r\nImport-Module -Name Appx -UseWindowsPowerShell -WarningAction SilentlyContinue\r\n```\r\n\r\nLike everyone else, I'm not really satsified with the current state of this broken functionality so I continue to use PowerShell 7.0.6.  Adding extra imports for this and Language for #14102 adds another 1+ second to the running of my scripts and/or profile.  All of this functionality worked perfectly before 7.1+ and I think that's the key here.\r\n\r\nBoth these issues have been closed here which just limits their visibility.  Depsite the issue being upstream, the functionality is broken in PowerShell itself.",
      "created_at": "2021-05-31T06:21:19Z",
      "updated_at": "2021-05-31T06:21:19Z"
    },
    {
      "author": "doctordns",
      "author_association": "COLLABORATOR",
      "body": "> My workaround :\r\n> Try default Windows Powershell(version 5). It works fine with `Get-appxpackage` command.\r\n\r\nIs this really the best advice we can get? Somehow abandoning PowerShell 7 for Windows PowerShell is rather sub-optimal to say the last. \r\n\r\nI understand that some product teams may be too busy, or lazy, to get their cmdlets fully working with PowerShell 7.  But this issue is nearly a year old and is still present in PowerShell 7.1.3, and the latest 7.2 preview and daily build versions.  \r\n\r\nit does appear that you can force `Import-Module` to load the APPX module via compatibility. So can you extend the logic of the JSON file ban list to have a set of modules that Import-Module always loads using compatibility? So parhapx a powershell.config.json like this:\r\n\r\n```powershell \r\n \r\nPS C:\\Program Files\\PowerShell\\7> cat .\\powershell.config.json\r\n{\r\n    \"WindowsPowerShellCompatibilityModuleDenyList\":  [\r\n                                                         \"PSScheduledJob\",\r\n                                                         \"BestPractices\",\r\n                                                         \"UpdateServices\"\r\n                                                     ],\r\n    \"Microsoft.PowerShell:ExecutionPolicy\":  \"RemoteSigned\",\r\n    \"WindowsPowerShellForceWindowsCompatibility\":  [\r\n                                                         \"Appx\"\r\n                                                     ]\r\n}\r\n```",
      "created_at": "2021-05-31T09:43:43Z",
      "updated_at": "2021-05-31T09:43:43Z"
    },
    {
      "author": "fgimian",
      "author_association": "NONE",
      "body": "This is still broken on the very latest preview release;\r\n\r\n```powershell\r\nPowerShell 7.2.0-preview.8\r\nCopyright (c) Microsoft Corporation.\r\n\r\nhttps://aka.ms/powershell\r\nType 'help' to get help.\r\n\r\nPS C:\\Program Files\\PowerShell\\7-preview> Import-Module Appx\r\nImport-Module: Operation is not supported on this platform. (0x80131539)\r\n```\r\n\r\n@SteveL-MSFT Would you kindly consider reopening this issue until it's fully resolved?  Is there any sort of ETA on this?\r\n\r\nI will admit that I'm surprised how long such a critical issue has managed to remain outstanding given how much work has been done on .NET and PowerShell in the last year.  It would really be awesome to see this finally fixed. \ud83d\ude04 \r\n\r\nHuge thanks\r\nFotis",
      "created_at": "2021-07-30T23:49:30Z",
      "updated_at": "2021-07-30T23:53:58Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@fgimian The best thing you can do - report the issue by Windows Feedback tool to vote for fastest fixing the issue.",
      "created_at": "2021-07-31T13:18:46Z",
      "updated_at": "2021-07-31T13:18:46Z"
    },
    {
      "author": "aminya",
      "author_association": "NONE",
      "body": "I also have the same issue\r\nhttps://github.com/microsoft/winget-cli/issues/995#issuecomment-896572382\r\n\r\nMake sure to upvote the feedback issue, if you are having the same problem.\r\nhttps://aka.ms/AAddp04",
      "created_at": "2021-08-11T07:34:30Z",
      "updated_at": "2021-08-11T07:37:34Z"
    },
    {
      "author": "roboticsMSM",
      "author_association": "NONE",
      "body": "Same issue here.\r\nWhen I type:\r\n`Get-AppxPackage Microsoft.YourPhone -AllUsers | Remove-AppxPackage`\r\nI expect Your Phone to be removed.\r\nBut I get this:\r\n`Get-AppxPackage: The 'Get-AppxPackage' command was found in the module 'Appx', but the module could not be loaded. For more information, run 'Import-Module Appx'.`",
      "created_at": "2021-08-17T06:08:33Z",
      "updated_at": "2021-08-17T06:08:33Z"
    },
    {
      "author": "fawdlstty",
      "author_association": "NONE",
      "body": "same issue, it's dont work on win10 20h2 (19042.1165)\r\n```\r\nPowerShell 7.2.0-preview.8\r\nCopyright (c) Microsoft Corporation.\r\n\r\nhttps://aka.ms/powershell\r\nType 'help' to get help.\r\n\r\nPS F:\\fawdlstty\\Downloads\\pwsh> get-appxpackage *store* | remove-Appxpackage\r\nremove-Appxpackage: The 'remove-Appxpackage' command was found in the module 'Appx', but the module could not be loaded. For more information, run 'Import-Module Appx'.\r\nPS F:\\fawdlstty\\Downloads\\pwsh> Import-Module Appx\r\nImport-Module: Operation is not supported on this platform. (0x80131539)\r\nPS F:\\fawdlstty\\Downloads\\pwsh>\r\n```\r\n\r\n```\r\nPowerShell 7.1.4\r\nCopyright (c) Microsoft Corporation.\r\n\r\nhttps://aka.ms/powershell\r\nType 'help' to get help.\r\n\r\nPS F:\\fawdlstty\\Downloads\\pwsh> get-appxpackage *store* | remove-Appxpackage\r\nremove-Appxpackage: The 'remove-Appxpackage' command was found in the module 'Appx', but the module could not be loaded. For more information, run 'Import-Module Appx'.\r\nPS F:\\fawdlstty\\Downloads\\pwsh> Import-Module Appx\r\nImport-Module: Operation is not supported on this platform. (0x80131539)\r\nPS F:\\fawdlstty\\Downloads\\pwsh>\r\n```",
      "created_at": "2021-08-17T17:14:39Z",
      "updated_at": "2021-08-17T17:15:44Z"
    },
    {
      "author": "oising",
      "author_association": "CONTRIBUTOR",
      "body": "Hah, and now I have finally arrived at this thread. I was trying to fix some broken crap in the latest win11 beta (windows defender ui missing) by using AppX to force resinstall the winsecui appx. I'm on 7.2p9. And I finally found my way here... \r\n\r\nin case other win11 users find themselves here trying to fix windows defender, then:\r\n\r\n1) run *windows* powershell as admin, then run \"Get-AppxPackage Microsoft.SecHealthUI -AllUsers | Reset-AppxPackage\" ;)",
      "created_at": "2021-09-01T23:13:15Z",
      "updated_at": "2021-09-01T23:15:05Z"
    },
    {
      "author": "asklar",
      "author_association": "NONE",
      "body": "> @SteveL-MSFT This is really a deal breaker. can't use pwsh beyond `7.0.X`\r\n> \r\n> this is clearly a WinRT((aka COM version 2)) and .NET interop issue. the right way to mitigate this on onwards .NET 5, powershell team will have to make `ComWrappers` for these modules to work.\r\n> \r\n> should this be filed in [CsWinRT ](https://github.com/microsoft/CsWinRT)repo ?\r\n> i mean if appropriate, Can you please transfer the issue there so that they look at it?\r\n> or _It's the powershell team that will have to make these modules `ComWrappers` compatible ?_\r\n\r\ncswinrt knows nothing of powershell or the appx PS module. CsWinrt can be used to produce a new version of the powershell appx module that can be used with .net 5+ though, so this should be on the appx team's plate, or powershell's.",
      "created_at": "2021-09-02T01:43:31Z",
      "updated_at": "2021-09-02T01:43:31Z"
    },
    {
      "author": "SpriggsySpriggs",
      "author_association": "NONE",
      "body": "Still an issue in PowerShell v7.1.4",
      "created_at": "2021-09-13T20:54:54Z",
      "updated_at": "2021-09-13T20:54:54Z"
    },
    {
      "author": "riverar",
      "author_association": "NONE",
      "body": "Agree, doesn't appear to be working on Windows 11 dev per release notes. https://blogs.windows.com/windows-insider/2021/09/15/announcing-windows-11-insider-preview-build-22458/#:~:text=appx%20commandlets\r\n\r\n```\r\nPS C:\\> get-appxpackage\r\nget-appxpackage: The 'get-appxpackage' command was found in the module 'Appx', but the module could not be loaded. For more information, run 'Import-Module Appx'.\r\nPS C:\\> Import-Module Appx\r\nImport-Module: Unable to find the specified file.\r\nPS C:\\> $PSVersionTable                                                                                                 \r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.1.4\r\nPSEdition                      Core\r\nGitCommitId                    7.1.4\r\nOS                             Microsoft Windows 10.0.22458\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```",
      "created_at": "2021-09-17T22:27:54Z",
      "updated_at": "2021-09-17T22:28:18Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Powershell can't fix this issue. The issue is in the module itself, which is maintained by one of the Windows product teams.\r\n\r\nIf you want to have them prioritize it more urgently, you need to communicate that to the relevant team via the Windows Feedback tool.",
      "created_at": "2021-09-18T06:28:50Z",
      "updated_at": "2021-09-18T06:28:50Z"
    },
    {
      "author": "doctordns",
      "author_association": "COLLABORATOR",
      "body": "I get that the underlying issue is with the module and the module's owners.\r\n\r\nAt the same time if you use the ``-UseWindowsPowerShell`` property to import the module - the module works. I can't help thinking that If the error message had read \"Please use Import-Module  Appx -UseWindowsPowerShell\" this would largely be a non-issue.\r\n\r\nIt would make sense to get PowerShell to do the work if the module owners won't or can't. I suggested extending the PowerShell JSON configuration file to implement a \"WindowsPowerShellForceWindowsCompatibility\" section to the JSON which tells PowerShell 7 to always load the modules named in that section using compatibility. \r\n\r\nI believe there are things that PowerShell can do to protect me from these compatibility issues in a more intelligent way. By just force loading the appx module using compatibility would make this issue with appx go away.",
      "created_at": "2021-09-18T10:21:17Z",
      "updated_at": "2021-09-19T15:59:57Z"
    },
    {
      "author": "pb5050",
      "author_association": "NONE",
      "body": "\r\n> It would make sense to get PowerShell to do the work if the module owners won't or can't. **`I suggested extending the PowerShell JSON configuration file to implement a \"WindowsPowerShellForceWindowsCompatibility\" section to the JSON which tells PowerShell 7 to always load the modules named in that section using compatibility.`**\r\n\r\n\r\n\r\nomg yes this would be so nice. \r\n",
      "created_at": "2021-09-27T08:01:34Z",
      "updated_at": "2021-09-27T08:01:34Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Not sold on the naming there but yeah it would be nice to be able to configure that.",
      "created_at": "2021-09-27T12:31:05Z",
      "updated_at": "2021-09-27T12:31:05Z"
    },
    {
      "author": "doctordns",
      "author_association": "COLLABORATOR",
      "body": "> Not sold on the naming there but yeah it would be nice to be able to configure that.\r\n\r\nI am defiantly not precious over naming and defer those who can do a better job! :-)\r\n\r\nIt would be, I feel, both fairly straightforward to implement and would give a much better user experience. ",
      "created_at": "2021-09-27T19:04:20Z",
      "updated_at": "2021-09-27T19:04:20Z"
    },
    {
      "author": "Fs00",
      "author_association": "CONTRIBUTOR",
      "body": "Hello guys,\r\nI did a test on Windows 11 Insider build 22471 and I saw that the issue with AppX cmdlets has been fixed.\r\n\r\nThey have changed the `Appx.psd1` file from `CompatiblePSEditions = @(\"Desktop\", \"Core\")` to `CompatiblePSEditions = @(\"Desktop\")`, so that now the module gets always imported using WinCompat.\r\n\r\nWonder why releasing this simple workaround took so much \ud83d\ude03 \r\n\r\n**UPDATE:** the fix is available for everyone starting from Windows 11 build 22000.348.",
      "created_at": "2021-10-08T07:20:15Z",
      "updated_at": "2021-12-11T19:39:39Z"
    },
    {
      "author": "dzigner",
      "author_association": "NONE",
      "body": "> I got the same issue trying to install Ubutnu 20.04 without having to sign in into the windows store. Using `Import-Module Appx -usewindowspowershell` worked for me but I had to search quite a bit before I ended up here and found the solution.\r\n\r\nthank you for this, I was trying to install the appx module, and powershell gave me this error. This solved it.",
      "created_at": "2021-10-21T00:14:10Z",
      "updated_at": "2021-10-21T00:14:10Z"
    },
    {
      "author": "Hashimlokasher",
      "author_association": "NONE",
      "body": "Running following command fixed the issue for me.\r\n`Import-Module Appx -usewindowspowershell`",
      "created_at": "2021-11-06T21:23:53Z",
      "updated_at": "2021-11-06T21:23:53Z"
    },
    {
      "author": "samus-a",
      "author_association": "NONE",
      "body": "> Hello guys, I did a test on Windows 11 Insider build 22471 and I saw that the issue with AppX cmdlets has been fixed.\r\n> \r\n> They have changed the `Appx.psd1` file from `CompatiblePSEditions = @(\"Desktop\", \"Core\")` to `CompatiblePSEditions = @(\"Desktop\")`, so that now the module gets always imported using WinCompat.\r\n> \r\n> Wonder why releasing this simple workaround took so much \ud83d\ude03\r\n\r\nThe issue seems to have to do more with PowerShell 7 (7.2 in my case) than the version of Windows, since this only started to occured after upgrading to 7.2 (from 5) on both of my Windows 10 and 11 (official release) machinies.",
      "created_at": "2021-11-22T11:15:00Z",
      "updated_at": "2021-11-22T11:15:00Z"
    },
    {
      "author": "doctordns",
      "author_association": "COLLABORATOR",
      "body": "Here at least - I see that `Import-Module Appx` 'fails' in Windows 11 21H2. In my insiders build (22504). This now works. \r\n\r\nI am running PowerShell 7.2.0 on all hosts. ",
      "created_at": "2021-11-22T17:32:05Z",
      "updated_at": "2021-11-22T17:32:05Z"
    },
    {
      "author": "LuanVSO",
      "author_association": "NONE",
      "body": "hey i'm on windows 10.0.19044.1348 and ps 7.2\r\nbut when i try to import any module with `-usewindowspowershell` i get an error, here's the shell history:\r\n[PowerShell use windowsps.txt](https://github.com/PowerShell/PowerShell/files/7585211/PowerShell.use.windowsps.txt)\r\n\r\nps: if i run powershell elevated it works",
      "created_at": "2021-11-23T00:34:42Z",
      "updated_at": "2021-11-23T00:51:03Z"
    },
    {
      "author": "alex19831362",
      "author_association": "NONE",
      "body": "no reaction my power shell after import-module appx",
      "created_at": "2021-11-30T06:31:51Z",
      "updated_at": "2021-11-30T06:31:51Z"
    },
    {
      "author": "bogdan-patraucean",
      "author_association": "NONE",
      "body": "> I get that the underlying issue is with the module and the module's owners.\r\n> \r\n> At the same time if you use the `-UseWindowsPowerShell` property to import the module - the module works. I can't help thinking that If the error message had read \"Please use Import-Module Appx -UseWindowsPowerShell\" this would largely be a non-issue.\r\n> \r\n> It would make sense to get PowerShell to do the work if the module owners won't or can't. I suggested extending the PowerShell JSON configuration file to implement a \"WindowsPowerShellForceWindowsCompatibility\" section to the JSON which tells PowerShell 7 to always load the modules named in that section using compatibility.\r\n> \r\n> I believe there are things that PowerShell can do to protect me from these compatibility issues in a more intelligent way. By just force loading the appx module using compatibility would make this issue with appx go away.\r\n\r\nUsing `UseWindowsPowerShell` no longer works in Windows 11. ",
      "created_at": "2022-01-21T18:10:06Z",
      "updated_at": "2022-01-21T18:10:06Z"
    },
    {
      "author": "MatiasAT",
      "author_association": "NONE",
      "body": "Se puede solucionar ejecutando powershell_ise con permisos de administrador y en la base de la consola ejecutar los comandos.\r\n![image](https://user-images.githubusercontent.com/51810798/160970389-ba665730-b78e-4396-9f1d-b7138838ae3c.png)\r\n",
      "created_at": "2022-03-31T03:27:04Z",
      "updated_at": "2022-03-31T03:27:04Z"
    },
    {
      "author": "asklar",
      "author_association": "NONE",
      "body": "> Se puede solucionar ejecutando powershell_ise con permisos de administrador y en la base de la consola ejecutar los comandos. ![image](https://user-images.githubusercontent.com/51810798/160970389-ba665730-b78e-4396-9f1d-b7138838ae3c.png)\r\n\r\nEl ISE usa \"Windows PowerShell\", que es diferente (una version anterior) de PowerShell core (que es lo que de lo que habla este bug).",
      "created_at": "2022-03-31T03:37:32Z",
      "updated_at": "2022-03-31T03:37:32Z"
    },
    {
      "author": "bogdan-patraucean",
      "author_association": "NONE",
      "body": "@carlocardella , this should be reopened as there are a lot of people complaining the error still occurs.",
      "created_at": "2022-06-13T14:32:17Z",
      "updated_at": "2022-06-13T14:32:17Z"
    },
    {
      "author": "soroshsabz",
      "author_association": "NONE",
      "body": "Please reopen this issue\r\n\r\nthanks",
      "created_at": "2022-07-10T17:00:41Z",
      "updated_at": "2022-07-10T17:00:41Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "Long story short, I've been working with the AppX team on this issue.  They have been working on a fix which is not a small change.  The changes will not be backported to shipped versions of Windows and will show up in a future release of Windows.",
      "created_at": "2022-07-11T16:21:39Z",
      "updated_at": "2022-07-11T16:21:39Z"
    },
    {
      "author": "bogdan-patraucean",
      "author_association": "NONE",
      "body": "> Long story short, I've been working with the AppX team on this issue. They have been working on a fix which is not a small change. The changes will not be backported to shipped versions of Windows and will show up in a future release of Windows.\r\n\r\nOMG, so this means that if we want to use AppX module we should target only Windows 11 future versions?",
      "created_at": "2022-07-11T16:32:07Z",
      "updated_at": "2022-07-11T16:32:30Z"
    },
    {
      "author": "kyanha",
      "author_association": "CONTRIBUTOR",
      "body": "Then revert the change in pwsh that broke it. You broke it, you fix it. I have machines that bluescreen when I try to update them to Windows 11, and Microsoft's policies prevent me from activating fresh installs of 11 with the 10 Pro Retail keys that I bought for them. I am literally stuck because of MSFT and its employees. FIX THIS SO I CAN GET THE STORE WORKING AGAIN.",
      "created_at": "2022-07-12T06:17:37Z",
      "updated_at": "2022-07-12T06:17:37Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> Then revert the change in pwsh that broke it. You broke it, you fix it. \r\n\r\nJust to clarify it again, it was caused by an intentional breaking change in .NET Core, not PowerShell. See https://github.com/dotnet/docs/issues/18875 for details.",
      "created_at": "2022-07-12T16:05:10Z",
      "updated_at": "2022-07-12T16:05:10Z"
    },
    {
      "author": "ToxicSmurf",
      "author_association": "NONE",
      "body": "> > Then revert the change in pwsh that broke it. You broke it, you fix it.\r\n> \r\n> Just to clarify it again, it was caused by an intentional breaking change in .NET Core, not PowerShell. See [dotnet/docs#18875](https://github.com/dotnet/docs/issues/18875) for details.\r\n\r\nJust to clarify it again, why is this issue closed?",
      "created_at": "2022-07-22T02:03:03Z",
      "updated_at": "2022-07-22T02:03:15Z"
    },
    {
      "author": "Terafugia",
      "author_association": "NONE",
      "body": "Well this is clear as mud. Closing an issue - that if you are unfortunately using Windows 10, can only be solved by upgrading to Windows 11 or becoming an insider?",
      "created_at": "2022-08-02T11:16:26Z",
      "updated_at": "2022-08-02T11:16:26Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "The issue is closed because the module is not part of this project. The feedback hub is the best way to reach the folks who own the AppX module.",
      "created_at": "2022-08-02T15:40:21Z",
      "updated_at": "2022-08-02T15:40:21Z"
    },
    {
      "author": "mikehearn",
      "author_association": "NONE",
      "body": "Is there a piece of script that is:\r\n\r\na. Like the one by @juvtib above that detects the PowerShell version in use and then auto-fixes things?\r\nb. Robust enough that it will NOT break in future releases of Windows or PowerShell?\r\n\r\nTo be clear, I - like everyone else here - do not care *at all* about whose fault inside Microsoft this problem is, or who is \"supposed\" to fix it. The amount of finger-pointing on this thread, the time taken to ship a fix and the fact that Win10 won't get it, is frankly absurd. Is it AppX, .NET team, WinRT, PowerShell team - who cares? Scripts that used to work now don't if someone upgrades to PS7. ",
      "created_at": "2022-08-06T21:58:10Z",
      "updated_at": "2022-08-06T21:58:10Z"
    },
    {
      "author": "juvtib",
      "author_association": "NONE",
      "body": "\r\n> a. Like the one by @juvtib above that detects the PowerShell version in use and then auto-fixes things?\r\n> b. Robust enough that it will NOT break in future releases of Windows or PowerShell?\r\n\r\n``` PowerShell\r\n# some_file_name.ps1\r\n\r\n$firstAffectedVersion = [System.Management.Automation.SemanticVersion](\"7.1.0\")\r\n\r\n$lastAffectedVersion  = [System.Management.Automation.SemanticVersion](\"999.0.0\")\r\n\r\nif (\r\n  ($PSVersionTable.PSVersion -ge $firstAffectedVersion) -and \r\n  ($PSVersionTable.PSVersion -le $lastAffectedVersion )\r\n)\r\n{  Import-Module -Name Appx -UseWindowsPowerShell  }\r\n\r\n```\r\n\r\n* Use the [`[SemanticVersion]` :link:](https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.semanticversion) class to make version comparisons. \r\n* Fill in `$lastAffectedVersion` when it is known. \r\n* [Dot source :link:](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_scripts?view=powershell-7.2#script-scope-and-dot-sourcing) this code into affected scripts and sessions. \r\n\r\nThe issue has not been fixed, so we don't know the true value for `$lastAffectedVersion` at this time. \r\n\r\nWith dot sourcing, you can maintain your code in one place and use it in many scripts. \r\n\r\n``` PowerShell\r\n# Dot Source Appx work-around.\r\n. /path/to/some_file_name.ps1\r\n```\r\n\r\nI don't have Windows available to test. Please, test this code to make sure it is working. \r\n\r\n---\r\n\r\nOr use Windows PowerShell 5.1: that is [`powershell.exe` :link:](https://docs.microsoft.com/en-us/powershell/scripting/whats-new/differences-from-windows-powershell#renamed-powershellexe-to-pwshexe)\r\n\r\n## References \r\n\r\n* [Explanation of `-ge` and `-le`](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_comparison_operators). \r\n\r\n* [Modules and Scope](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_scopes#modules)\r\n\r\n* [Automatically add code to every PowerShell session](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_profiles?view=powershell-7.2). \r\n\r\n\r\nRegards,\r\n\r\n",
      "created_at": "2022-08-07T01:15:15Z",
      "updated_at": "2022-08-07T01:15:15Z"
    },
    {
      "author": "asklar",
      "author_association": "NONE",
      "body": "CC @joshusto @cwruss",
      "created_at": "2022-08-07T04:32:49Z",
      "updated_at": "2022-08-07T04:33:46Z"
    },
    {
      "author": "mikehearn",
      "author_association": "NONE",
      "body": "Thank you @juvtib ! That is very helpful.",
      "created_at": "2022-08-07T10:34:04Z",
      "updated_at": "2022-08-07T10:34:04Z"
    },
    {
      "author": "rklec",
      "author_association": "NONE",
      "body": "That script only seems to work in new PS versions (i.e. not Windows PowerShell), but PowerShell Core. In Windows PS I get the error that it cannot find `[System.Management.Automation.SemanticVersion]`.\r\n\r\nAnd even in PowerShell Core I get some warning and it's horribly slow (so doing this at every initialisation is likely not really good):\r\n```\r\nPowerShell 7.2.5\r\nCopyright (c) Microsoft Corporation.\r\n\r\nhttps://aka.ms/powershell\r\nType 'help' to get help.\r\n\r\nWARNING: Module Appx is loaded in Windows PowerShell using WinPSCompatSession remoting session; please note that all input and output of commands from this module will be deserialized objects. If you want to load this module into PowerShell please use 'Import-Module -SkipEditionCheck' syntax.\r\nLoading personal and system profiles took 6237ms.\r\n```",
      "created_at": "2022-08-08T10:11:54Z",
      "updated_at": "2022-08-08T10:11:54Z"
    },
    {
      "author": "juvtib",
      "author_association": "NONE",
      "body": "\r\n@rklec\r\n\r\nHere is how I would solve the problem. \r\n\r\nIf I am running `powershell.exe` (Windows PowerShell 5.1) then AppX works there and I don't need to make any checks or use the work-around. \r\n\r\nIf I am running `pwsh.exe` (PowerShell 7) then I can use the work-around when needed. When you use it is up to you. You can put it in your profile, certain scripts, or run it manually. \r\n\r\nYou can also modify my example to make additional checks. For example, you might use [WMI](https://docs.microsoft.com/powershell/scripting/samples/getting-wmi-objects--get-ciminstance-) to check what computer the script is running on or what operating system it has. Then, my example won't run on computers that don't use PowerShell 7. \r\n\r\nIn PowerShell 7, your other options are to use the [PackageManager class](https://docs.microsoft.com/uwp/api/Windows.Management.Deployment.PackageManager) or [DISM](https://docs.microsoft.com/windows-hardware/manufacture/desktop/dism-app-package--appx-or-appxbundle--servicing-command-line-options). \r\n\r\nTo answer your question, it looks like the SemanticVersion class is not available in PowerShell 5.1: \r\n\r\n![Semantic Version Class Not In SDK 5.1](https://user-images.githubusercontent.com/51273929/183414115-96a62c19-c7de-44ce-9859-fae500274f24.png)\r\n\r\nAlso, the format of `$PSVersionTable` changed between PowerShell 5.1 and PowerShell 7. Both of these issues would have to be addressed before my example would work across all PowerShell versions. Hopefully, some of these other options are helpful. \r\n\r\nRegards, \r\n\r\n",
      "created_at": "2022-08-08T12:19:59Z",
      "updated_at": "2022-08-08T12:19:59Z"
    },
    {
      "author": "mikehearn",
      "author_association": "NONE",
      "body": "Thanks. In my case I'm distributing a script, so it has to \"just work\" for users regardless of what they've installed. So I'll need to figure out some script snippet that can work on both and figure out if it's PS7 or earlier.",
      "created_at": "2022-08-08T12:43:03Z",
      "updated_at": "2022-08-08T12:43:03Z"
    },
    {
      "author": "juvtib",
      "author_association": "NONE",
      "body": "\r\n@mikehearn\r\n\r\nTry running the version check in PowerShell 5.1 to see the exact error relating to the SemanticVersion class. \r\n\r\nThen wrap the version check in a [try and catch block](https://docs.microsoft.com/powershell/module/microsoft.powershell.core/about/about_try_catch_finally?view=powershell-5.1). Catch the exception from the last step. And leave the catch block empty. We don't need to do anything on PowerShell 5.1 if the version check fails to run. \r\n\r\nIn this way, if the SemanticVersion class is present then the work-around runs. \r\n\r\nAnd if the class is absent then you can assume you are using PowerShell 5.1 and no work-around is needed. \r\n\r\nIf you want to share your work then you can try using a [gist](https://docs.github.com/get-started/writing-on-github/editing-and-sharing-content-with-gists/creating-gists). Feel free to copy my example there. \r\n\r\n",
      "created_at": "2022-08-08T20:00:43Z",
      "updated_at": "2022-08-08T20:00:43Z"
    },
    {
      "author": "mikehearn",
      "author_association": "NONE",
      "body": "Thanks. Once we reach this task I'll share the code we come up with.",
      "created_at": "2022-08-09T07:47:07Z",
      "updated_at": "2022-08-09T07:47:07Z"
    },
    {
      "author": "sccook-intel",
      "author_association": "NONE",
      "body": "> Using `UseWindowsPowerShell` no longer works in Windows 11.\r\n\r\nI just successfully ran \"import-module appx -usewindowspowershell\" on Windows Server 2022 21H2 20348.1006, in case that helps anyone.",
      "created_at": "2022-09-22T00:06:36Z",
      "updated_at": "2022-09-22T00:06:36Z"
    },
    {
      "author": "igorskyflyer",
      "author_association": "NONE",
      "body": "> > Using `UseWindowsPowerShell` no longer works in Windows 11.\r\n> \r\n> I just successfully ran \"import-module appx -usewindowspowershell\" on Windows Server 2022 21H2 20348.1006, in case that helps anyone.\r\n\r\n@sccook-intel, I started getting this error a few days ago but your workaround fixes it, thank you very much! \ud83d\ude01",
      "created_at": "2022-09-22T01:32:05Z",
      "updated_at": "2022-09-22T01:32:05Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This issue has been marked as external and has not had any activity for **1 day**. It has been be closed for housekeeping purposes.",
      "created_at": "2022-09-23T16:01:24Z",
      "updated_at": "2022-09-23T16:01:24Z"
    },
    {
      "author": "bogdan-patraucean",
      "author_association": "NONE",
      "body": "@sccook-intel can you test this on Windows 11 22H2? I'm on the latest Insider Preview but still does not work.",
      "created_at": "2022-10-25T21:50:42Z",
      "updated_at": "2022-10-25T21:50:42Z"
    },
    {
      "author": "sccook-intel",
      "author_association": "NONE",
      "body": "> @sccook-intel can you test this on Windows 11 22H2? I'm on the latest Insider Preview but still does not work.\r\n\r\nSorry; I'm on Windows 11 21H2, and don't have a newer version available to me. :-/",
      "created_at": "2022-10-26T00:12:54Z",
      "updated_at": "2022-10-26T00:12:54Z"
    }
  ],
  "created_at": "2020-07-08T22:39:47Z",
  "labels": [
    "Issue-Bug",
    "WG-Engine",
    "Resolution-External"
  ],
  "number": 13138,
  "state": "closed",
  "title": "Appx - Import-Module: Operation is not supported on this platform. (0x80131539)",
  "updated_at": "2022-10-26T00:12:55Z"
}