{
  "_url": "https://github.com/PowerShell/PowerShell/issues/17184",
  "author": "LutAle",
  "body": "### Prerequisites\r\n\r\n- [X] Write a descriptive title.\r\n- [X] Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\r\n- [X] Search the existing issues.\r\n- [X] Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\r\n- [X] Refer to [Differences between Windows PowerShell 5.1 and PowerShell](https://docs.microsoft.com/powershell/scripting/whats-new/differences-from-windows-powershell).\r\n\r\n### Steps to reproduce\r\n\r\nIn $profile.AllUsersAllHosts  , function: \r\n \r\nfunction Test-IsAdmin {\r\n    try {\r\n            ([System.Security.Principal.WindowsPrincipal][System.Security.Principal.WindowsIdentity]::GetCurrent()\r\n            ).IsInRole([System.Security.Principal.WindowsBuiltInRole]::Administrator)    \r\n\r\n    } catch {\r\n        throw \"Failed to determine if the current user has elevated privileges. The error was: '{0}'.\" -f $_\r\n    }\r\n    <#\r\n        .SYNOPSIS\r\n            Checks if the current Powershell instance is running with elevated privileges or not.\r\n        .EXAMPLE\r\n            PS C:\\> Test-IsAdmin\r\n        .OUTPUTS\r\n            System.Boolean\r\n                True if the current Powershell is elevated, false if not.\r\n    #>\r\n}\r\n\r\nPut in  $PROFILE.CurrentUserAllHosts :\r\n  & $profile.AllUsersAllHost\r\n\r\n\r\n### Expected behavior\r\n\r\n```console\r\nPS> Test-IsAdmin -eq Test-IsAdmin\r\nTrue\r\n```\r\n\r\n\r\n### Actual behavior\r\n\r\n```console\r\nPS> Test-IsAdmin -eq Test-IsAdmin\r\nFalse\r\nPS> Test-IsAdmin -eq ($(Test-IsAdmin))\r\nFalse\r\nPS>Test-IsAdmin -eq $(Test-IsAdmin)\r\nFalse\r\n\r\nBut:\r\n\r\nPS> $(Test-IsAdmin) -eq $(Test-IsAdmin)\r\nTrue\r\n```\r\n\r\n\r\n### Error details\r\n\r\n_No response_\r\n\r\n### Environment data\r\n\r\n```powershell\r\nPS> $PSVersionTable\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.3.0-preview.3\r\nPSEdition                      Core\r\nGitCommitId                    7.3.0-preview.3\r\nOS                             Microsoft Windows 10.0.19044\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n\r\n\r\n### Visuals\r\n\r\n### \r\n\r\n![\u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435_2022-04-23_175453025](https://user-images.githubusercontent.com/25406539/164911290-fa1572d0-6807-4950-a5ed-e411785177d4.png)\r\n",
  "closed_at": "2022-04-27T14:24:05Z",
  "comments": [
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I can see how that's a bit confusing here, aye.\r\n\r\nWhat you're running into here is that PowerShell has multiple separate [parsing modes](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_parsing?view=powershell-7.2) that it will use to parse various kinds of expressions. Once you've entered a command name (in this case `Test-IsAdmin`) for the remainder of the statement the parser switches into [argument parsing mode](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_parsing?view=powershell-7.2#argument-mode). In this mode, the `-eq` operator will be instead treated as a command parameter instead of an operator.\r\n\r\nBecause command parameters also use a `-ParamName` syntax, similar to `-operator` for many operators, it's only the parsing mode that determines whether something is inferred as an operator or a command parameter. To work around this, as you've noted, you generally need to surround command calls in parentheses to indicate to PS where the boundary of the command expression is. This lets it swap back to expression parsing mode. \r\n\r\nTo avoid this scenario where you accidentally provide a parameter instead of using an operator, you can define the function with `[CmdletBinding()]` instead. This will avoid some of the unclear behaviour by having PowerShell instead emit an error when you accidentally provide a parameter that the command doesn't actually implement:\r\n\r\n```ps1\r\nfunction Test-IsAdmin {\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    try {\r\n        ([System.Security.Principal.WindowsPrincipal][System.Security.Principal.WindowsIdentity]::GetCurrent()).\r\n            IsInRole([System.Security.Principal.WindowsBuiltInRole]::Administrator)\r\n    } \r\n    catch {\r\n        throw \"Failed to determine if the current user has elevated privileges. The error was: '{0}'.\" -f $_\r\n    }\r\n    <#\r\n    .SYNOPSIS\r\n        Checks if the current Powershell instance is running with elevated privileges or not.\r\n    .EXAMPLE\r\n        PS C:\\> Test-IsAdmin\r\n    .OUTPUTS\r\n        System.Boolean\r\n            True if the current Powershell is elevated, false if not. \r\n    #>\r\n}\r\n```\r\n\r\nThis then shows you exactly what's going wrong if you stumble into this again:\r\n```ps1\r\nPS> Test-IsAdmin -eq Test-IsAdmin\r\nTest-IsAdmin: A parameter cannot be found that matches parameter name 'eq'.\r\n```",
      "created_at": "2022-04-23T16:38:29Z",
      "updated_at": "2022-04-23T16:40:30Z"
    },
    {
      "author": "LutAle",
      "author_association": "NONE",
      "body": "I tru undestand that in first scenario Test-IsAdmin -eq Test-IsAdmin , -eq operator break as waste and not will been assume it test, for remain expresseon as  legitime syntaxical meaning. Remain Test-IsAdmin ... -parametrN ...   interprenation only.\r\nMay be need -operator precedence over -parameter sintaxy meaning, [ -if parameter missing in param. function or over all case?],  in string parsing, not as equal kind expression. \r\nI undestanded it momment.\r\n",
      "created_at": "2022-04-24T11:10:01Z",
      "updated_at": "2022-04-24T11:10:01Z"
    },
    {
      "author": "LutAle",
      "author_association": "NONE",
      "body": "This may simplify, clearing and improve langlage expresivity",
      "created_at": "2022-04-24T11:20:06Z",
      "updated_at": "2022-04-24T11:20:06Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "It may simplify some cases, but I think doing what you suggest would introduce inconsistency. For example, if the command definition is updated to include a similarly-named parameter, the script would suddenly behave differently, without warning. I think that's potentially much worse than the current behaviour where it simply never treats it as an operator; that behaviour is at least consistent.\r\n\r\nSomething that also needs to be considered is that PowerShell parameters support implicit aliases; if you have a parameter named `-Equalise` (or anything else starting with `-Eq`) and you provide a parameter named like `-Eq`, PowerShell will match the partially named parameter and assume you meant to provide `-Equalise`. That complicates the suggested implementation here and makes it less likely that using an operator like this will work.\r\n\r\nI agree there are cases where this would be somewhat helpful, but in my opinion I think it's more likely to result in confusing behaviour than the current implementation.\r\n\r\nI'll defer to the Language Working Group on this, though, not my area. \ud83d\ude04 \r\n@LutAle can I ask you to incorporate some of your previous comments into the issue description so it's more clear what you're requesting to folks browsing the issue? \ud83d\ude42 ",
      "created_at": "2022-04-24T13:37:12Z",
      "updated_at": "2022-04-24T14:09:19Z"
    },
    {
      "author": "LutAle",
      "author_association": "NONE",
      "body": ".. I build syntax > ( if ( A -eq B ) {... ....} )  - > this issue assume solution as  if ((A) -eq (B))   ...  too many parenthes, not common  programming langlage sintaxis. If write code in simple form:  condition = expression [operator expression]+  not as:             ((expression) [operator (expression)]+) Without deep expirience with powershell it's sintax less prefer for newable users\r\n\r\nA , B - > function.\r\n\r\nSyntax parsing now:\r\n1 -eq 1      // True, parsing -OK , result trutly\r\n(1) -eq 1    // True, parsing -OK , result trutly\r\nfunction  Test-IsAdmin return true or false , Test-IsAdmin  some funtion like function  A, B, etc..\r\n(Test-IsAdmin ) -eq (Test-IsAdmin)    // True , Test-IsAdmin = False, result trutly\r\n(Test-IsAdmin)  -eq Test-IsAdmin       // ParserError:  You must provide a value expression following the '-eq' operator. Exception\r\nTest-IsAdmin -eq Test-IsAdmin          // Parsing - Ok. Silent wrong result : False!!   -  meaningless\r\nTest-IsAdmin -eq $True                     //  Result False \r\nTest-IsAdmin -eq $False                     //  Result False, the same value, not undestand work operator or not it\r\n In general case if set conditon, like : A -operator B -operator C -operator D   may cauth unexepected result, and difficul to undestand where  sintaxis without  parenthes problem  or operand with wrong value out problem result // Or in expaned case where A, B, C, ... may be subconditions.\r\n\r\nI think that sintax parsing with -operator precedence over -parameter precedence  not cauth problem whit normal  behave , if parametr name same as operator name, in function paraments list,  that parametrs parsing may be contine too next.\r\nBut ,in case, -sintaxyValue prefered in sense meaning the as operator meaning, than meaning the as parameter. That be need rename parameters. \r\nBut I think powershell code base not widewithese use parametr like operator naming. It not over few  ones problem case.\r\n One may produce [preferred] -  attribute (programmtag), like [deprecated] attribute, added by the author now,  but in contrast with deprecate attribute meaning.  And this [prerefer] attribute tag be evaluted powershell sintax engine, for function atribute list. It's tag descript prefered code modification, or the  even reveal hot bug fix interface,  or old sintax fix interface,\r\n  For autoapply, next lang version sintaxys,  for codebase evolution mechanic.\r\n",
      "created_at": "2022-04-25T09:32:22Z",
      "updated_at": "2022-04-25T09:32:22Z"
    },
    {
      "author": "LutAle",
      "author_association": "NONE",
      "body": "BRIEF, condition :          for ( A -operator B  -operator C )\r\nvisual look more cute, clearing to than the expression:  for ( (A) -operator ((B) -operator (C)) ) or,\r\n                                                                                         for ((A) -operator ((B) -operator (C))) ",
      "created_at": "2022-04-25T10:31:31Z",
      "updated_at": "2022-04-25T10:32:31Z"
    }
  ],
  "created_at": "2022-04-23T15:38:41Z",
  "number": 17184,
  "state": "closed",
  "title": "- eq operator not work?",
  "updated_at": "2022-04-27T14:24:05Z"
}