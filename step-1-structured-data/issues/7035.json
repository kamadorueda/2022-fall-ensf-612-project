{
  "_url": "https://github.com/PowerShell/PowerShell/issues/7035",
  "author": "alx9r",
  "body": "I'm experimenting with running PowerShell unit tests in parallel. It seems like one open runspace per thread is needed to achieve speedup.  I'm seeing good speedup after the runspaces are open (see [#6965(comment)](https://github.com/PowerShell/PowerShell/issues/6965#issuecomment-395928585).  I haven't, however, found a reliable way to parallelize module importing that occurs when opening the runspaces.  (Runspaces.OpenAsync() looks promising, but it seems to suffer from #7034.)\r\n\r\nCalling PowerShell.BeginInvoke() on a several of PowerShell instances sharing a runspace pool seems to block while module loading completes.  The result is that despite that there might be many processors available and one runspace for each, only one processor is utilized to perform module importing for all of the runspaces.\r\n\r\nSteps to reproduce\r\n------------------\r\n\r\n```powershell\r\n$processorCount = [System.Environment]::ProcessorCount\r\n\r\nWrite-Host \"Processor Count: $processorCount\"\r\n\r\n$moduleContent = {\r\n    function fibonacci {\r\n        param([int]$n)\r\n        [bigint]$a=0\r\n        [bigint]$b=1\r\n        foreach ($x in 0..$n)\r\n        {\r\n            $a,$b = $b,($a+$b)\r\n        }\r\n        $b\r\n    }\r\n    0..0 | % { fibonacci 100000 }\r\n}\r\n\r\n$modulePath = \"$([System.IO.Path]::GetTempPath())slowLoading.psm1\"\r\n$moduleContent | Set-Content $modulePath\r\n\r\n$t_import = Measure-Command {\r\n    Import-Module $modulePath -Force\r\n}\r\n\r\n$initialSessionState = [initialsessionstate]::CreateDefault()\r\n$initialSessionState.ImportPSModule($modulePath)\r\n\r\n$rsp = [runspacefactory]::CreateRunspacePool($initialSessionState)\r\n$rsp.SetMaxRunspaces($processorCount) | Out-Null\r\n$rsp.Open()\r\n\r\n$ps = 1..$processorCount | % { [powershell]::Create().AddScript({'done'}) }\r\n$ps | % { $_.RunspacePool = $rsp }\r\n\r\n$t_begin = Measure-Command {\r\n    $invocation = $ps.BeginInvoke()\r\n}\r\n\r\n$t_wait = Measure-Command {\r\n    while ( $invocation.IsCompleted -contains $false )\r\n    {\r\n        sleep 0.1\r\n    }\r\n}\r\n\r\n[pscustomobject]@{\r\n    'name'     = 'Import-Module slowLoading.psm1'\r\n    'time(ms)' = [int]$t_import.TotalMilliseconds\r\n}\r\n\r\n[pscustomobject]@{\r\n    'name'     = 'BeginInvoke()'\r\n    'time(ms)' = [int]$t_begin.TotalMilliseconds\r\n}\r\n\r\n[pscustomobject]@{\r\n    'name'     = 'Wait'\r\n    'time(ms)' = [int]$t_wait.TotalMilliseconds\r\n}\r\n\r\n```\r\n\r\nExpected behavior\r\n-----------------\r\n\r\n```none\r\nProcessor Count: 16\r\n\r\nname                           time(ms)\r\n----                           --------\r\nImport-Module slowLoading.psm1     5122\r\nBeginInvoke()                       100  (approximately)\r\nWait                               6000  (approximately)\r\n```\r\n\r\nActual behavior\r\n---------------\r\n\r\n```none\r\nProcessor Count: 16\r\n\r\nname                           time(ms)\r\n----                           --------\r\nImport-Module slowLoading.psm1     5122\r\nBeginInvoke()                     19452\r\nWait                                 13\r\n```\r\n\r\nHere is the CPU utilization graph for the above test run:\r\n\r\n![image](https://user-images.githubusercontent.com/11237922/41194290-08289110-6bce-11e8-8c02-97d094417f08.png)\r\n\r\n\r\nEnvironment data\r\n----------------\r\n\r\n<!-- provide the output of $PSVersionTable -->\r\n\r\n```powershell\r\n> $PSVersionTable\r\n\r\nName                           Value\r\n----                           -----\r\nPSVersion                      6.1.0-preview.691\r\nPSEdition                      Core\r\nGitCommitId                    v6.1.0-preview.691\r\nOS                             Microsoft Windows 6.3.9600 \r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "alx9r",
      "author_association": "NONE",
      "body": "It looks like the following might be relevant to answering this question:\r\n\r\n* The time spent on script module compilation affects parallelization differently from the time spent executing a script module's scriptblock.  (I think importing Pester is mostly spent compiling, while importing `slowLoading.psm1` is mostly spent executing the scriptblock.)\r\n* Importing a module in one runspace slows the execution of code in another runspace that uses that module.\r\n\r\nBelow are the results of some tests related to these aspects.\r\n\r\n### .OpenAsync() with slowLoading.psm1\r\n\r\nIt looks like `.OpenAsync()` parallelizes importing of `slowLoading.psm1` nicely.  [parallelLoadModule.ps1](https://gist.github.com/alx9r/c24bf08fd22af7e88f3a17e720215f63) is a demonstration.  Here is the output of two test runs on a 16-core processor:\r\n\r\n\r\n```none\r\nBaseline w/ $p overridden to 1\r\n\r\nProcessorCount: 1\r\n54ms : OpenAsync()\r\n68ms : WaitAll()\r\n4018ms : done\r\n```\r\n\r\n```none\r\nProcessorCount: 16\r\n44ms : OpenAsync()\r\n219ms : WaitAll()\r\n7060ms : done\r\n```\r\n\r\nOpening 16x runspaces took 1.75x as long.  The CPU utilization reflects that all processors are used in parallel:\r\n\r\n![image](https://user-images.githubusercontent.com/11237922/41488271-9ed8b3de-70a0-11e8-87a8-346b0ad28390.png)\r\n\r\n\r\nThis seems like good news for parallelized importing of script modules.  However, `slowLoading.psm1` isn't a very good stand-in for real-world modules.\r\n\r\n### .OpenAsync() w/ Pester\r\n\r\nPester is a real-world script module that takes some time to import.\r\n\r\nChanging the call in parallelModuleLoad.ps1 to `Import-Module $modulePath` and `.ImportPSModule($modulePath)` to `Import-Module Pester` and `.ImportPSModule('Pester')`, respectively, causes Pester to be imported into each of the runspaces when `.OpenAsync()` is called.   Here are the corresponding tests runs:\r\n\r\n```none\r\nBaseline w/ $p overridden to 1\r\n\r\nProcessorCount: 1\r\n46ms : OpenAsync()\r\n59ms : WaitAll()\r\n991ms : done\r\n```\r\n\r\n```none\r\nProcessorCount: 16\r\n59ms : OpenAsync()\r\n234ms : WaitAll()\r\n7627ms : done\r\n```\r\n\r\nOpening 16x runspaces that have Pester imported took 7.69x as long.  The CPU utilization reflects some parallelization occuring:\r\n\r\n![image](https://user-images.githubusercontent.com/11237922/41488479-4b5e2116-70a1-11e8-813a-fd01a104069d.png)\r\n\r\n\r\n\r\n### .OpenAsync() w/ Pester while Running Pester\r\n\r\nIt's likely that code in a script module will be executed while another runspace is importing that module.\r\n\r\n[This test](https://gist.github.com/alx9r/de92c472060a574dbb6633e000dde3e7) profiles importing Pester into a number of runspaces while the first runspace performs CPU-bound execution using Pester.  The results from a typical test run are as follows:\r\n\r\n```none\r\nProcessorCount: 16\r\n59ms : OpenAsync()\r\n7229ms : importing done\r\nthroughput while importing: 143 iterations/s\r\nthroughput while solo: 246 iterations/s\r\n```\r\n\r\nThe time taken to import Pester into the 16 runspaces took about the same time as when Pester code was not simultaneously being executed (7229ms vs. 7627ms).  On the other hand, the single-threaded throughput of Pester code while other runspaces were importing Pester was 0.58x the throughput of that code when executed solo.\r\n\r\nThis seems to point to the following:\r\n\r\n1. There is some sort of performance interaction between runspaces using the same module.\r\n2. Executing code using a module in one runspace *does not* slow loading of that module in another runspace.\r\n3. Importing a module into one runspace *does* slow code executing using that module in another runspace.\r\n",
      "created_at": "2018-06-15T21:02:22Z",
      "updated_at": "2018-06-15T21:02:22Z"
    },
    {
      "author": "alx9r",
      "author_association": "NONE",
      "body": "Per #7153, sharing an `AuthorizationManager` object amongst `Runspace`s being opened causes contention.  I wonder if `RunspacePool` uses a single `AuthorizationManager` when opening runspaces.",
      "created_at": "2018-06-23T14:35:50Z",
      "updated_at": "2018-06-23T14:35:50Z"
    }
  ],
  "created_at": "2018-06-09T17:18:25Z",
  "number": 7035,
  "state": "open",
  "title": "Is there a way to use RunspacePools such that module loading uses more than one processor?",
  "updated_at": "2019-09-28T19:20:47Z"
}