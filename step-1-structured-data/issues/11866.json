{
  "_url": "https://github.com/PowerShell/PowerShell/issues/11866",
  "author": "iRon7",
  "body": "## Property table\r\nSince I am using calculated properties I am questioning the current its syntax: *Why do I need to assign the name of the concerned property to a new name/label while the property(/column) name is literally *key* by itself? Why can't I just instantly assign the (calculated) values to the property (name) in a hash table similar to what is done in the related constructor of that object?*\r\n\r\n<sub>To put this in perspective with the recent requests #11607 and #11617, you might as well consider to update the classic [`New-Object`]([https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/new-object?view=powershell-7](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/new-object?view=powershell-7)) cmdlet property parameter to be compliant with calculated properties: <strike> `New-Object -COMObject InternetExplorer.Application -Property @{Name = 'Navigate2'; Value = \"www.microsoft.com\"}, @{Name = 'Visible'; Value = $True}`</strike></sub>\r\n\r\n## Multiple property attributes\r\nFor `Select-Object`, which has in fact a single calculated property attribute (if you do not count `Name`/`Label`),  a calculated property syntax like `<name>={<expression>}`is easy to imaging, but there other cmdlets, like `Sort-Object` and `Format-Table`, that support calculated properties. And the property parameter of those cmdlets support more attributes than just the expression, as e.g. `Ascending`, `Descending`, `FormatString`, `Width` and `Alignment`.   \r\nAs the value of these property attributes are currently represented as common (`string` and `integer`) datatypes, it hard to recognize them by type but that is not the case if those values are predefined by object classes (and enumerations). Meaning that it would than be possible to explicitly define each property attribute by its type prefix and as the common types (and enumeration values) used by the constructors of those classes are known, it is also possible to implicitly refer to common property attributes.\r\n\r\n## Wrappers\r\nUnfortunately I am not experienced enough with C# but to test and show the idea, I have created 3 simple PowerShell wrappers (not caring about the parameter constrains and correctly processing the pipeline):\r\n\r\n 1. `Select2` wraps around the `Select-Object` cmdlet \r\n 2. `FT2` wraps around the `Format-Table` cmdlet\r\n 3. `Sort2` wraps around the `Sort-Object` cmdlet\r\n  \r\nEach of the wrappers is able to process properties as usual and recognize the purposed syntax. Any property in the purposed format is translated to the current format and passed to the related cmdlet.\r\n\r\n```PowerShell\r\nclass Expression {\r\n    [ValidateNotNullOrEmpty()][ScriptBlock]$Value\r\n    Expression ([scriptblock]$Value) {$this.Value = $Value}\r\n    Expression ([string]$Value) {$this.Value = [ScriptBlock]::Create(\"`$_.'$Value'\")}\r\n}\r\nclass FormatString {\r\n    [ValidateNotNullOrEmpty()][string]$Value\r\n    FormatString ([string]$Value) {$this.Value = $Value}\r\n}\r\nclass Width {\r\n    [ValidateNotNullOrEmpty()][int]$Value\r\n    Width ([int]$Value) {$this.Value = $Value}\r\n}\r\nenum Alignment {Left; Center; Right}\r\nenum Ascending {Ascending}\r\nenum Descending {Descending}\r\n\r\nFunction ConvertProperty([HashTable]$Parameters, [Type[]]$ExplicitTypes = @(), [Switch]$Immutable) {\r\n    $EnumItems = @{}; $ImplicitTypes = @{}\r\n    ForEach ($Type in (@([Expression]) + $ExplicitTypes)) { # The later $ExplicitTypes will overrule.\r\n        If ($Type.BaseType.Name -eq 'Enum') {\r\n            ForEach ($EnumName in $Type.GetEnumNames()) {\r\n                $EnumItems[$EnumName] = $Type\r\n            }\r\n        } Else {\r\n            ForEach ($Constructor in ($Type.GetConstructors())) {\r\n                $ImplicitTypes[$Constructor.GetParameters()[0].ParameterType.Name] = $Type\r\n            }\r\n        }\r\n    }\r\n    $ExplicitTypes = @([Expression]) + $ExplicitTypes\r\n    $LegacyKeys = ('Name', 'Label', 'Expression') + $ExplicitTypes.Name\r\n    $LegacyKeys = ForEach ($Key in $LegacyKeys) {\r\n        For ($i = 1; $i -le $Key.Length; $i++) { $Key.SubString(0, $i) }\r\n    }\r\n    If ($Parameters.Property) {\r\n        $Parameters['Property'] = ForEach ($Property in $Parameters.Property) {\r\n            If ($Property -is [System.Collections.IDictionary]) {\r\n                ForEach ($Key in $Property.Get_Keys()) {\r\n                    $Exclusive = $Key -IsNot [String] -or !($LegacyKeys -Contains $Key)\r\n                    If ($Exclusive) { Break }\r\n                }\r\n                If ($Exclusive) {\r\n                    ForEach ($Key in $Property.Get_Keys()) {\r\n                        $HashTable = @{}\r\n                        ForEach ($Value in $Property.$Key) {\r\n                            If ($Null -ne $Value) {\r\n                                $Type = $Value.GetType()\r\n                                If ($ExplicitTypes.Contains($Type)) {\r\n                                    $HashTable[$Type.Name] = If ($Type.BaseType -eq [Enum]) { \"$Value\" } Else { $Value.Value }\r\n                                } ElseIf ($EnumItems.ContainsKey($Value) -and !$HashTable.ContainsKey($Type.Name)) {\r\n                                    $HashTable[$EnumItems[$Value].Name] = If ($EnumItems[$Value].Name -eq $Value) { $True } Else { $Value }\r\n                                } ElseIf ($ImplicitTypes.ContainsKey($Type.Name) -and !$HashTable.ContainsKey($Type.Name)) {\r\n                                    $HashTable[$ImplicitTypes[$Type.Name].Name] = $Value\r\n                                } Else { Write-Error \"Cannot resolve property Value: $Value\" }\r\n                            } Else { Write-Error 'Property Value cannot be null' }\r\n                        }\r\n                        If ($Key -is [Expression]) {$HashTable['Expression'] = $Key.Value}\r\n                            ElseIf ($Key -is [ScriptBlock]) {$HashTable['Expression'] = $Key}\r\n                            ElseIf ($HashTable.ContainsKey('Expression')) {$HashTable['Name'] = \"$Key\"}\r\n                            Else {$HashTable['Expression'] = \"$Key\"}\r\n                        $HashTable\r\n                    }\r\n                } Else { $Property }\r\n            } Else { $Property }\r\n        }\r\n    }\r\n#   Write-Host ($Parameters | ConvertTo-Expression -Expand 1)    # https://www.powershellgallery.com/packages/ConvertTo-Expression\r\n    Write-Output $Parameters\r\n}\r\n\r\nFunction Select2 {\r\n    [CmdletBinding()]\r\n    param(\r\n        [object[]]$Property,\r\n        [Parameter(ValueFromPipeline=$true, Mandatory=$true)]$InputObject,\r\n        [String]$ExcludeProperty, [String]$ExpandProperty,\r\n        [Switch]$Unique, [Int]$Last, [Int]$First, [Int]$Skip, [Switch]$Wait\r\n\r\n    )\r\n    $Null = $PSBoundParameters.Remove('InputObject')\r\n    $Parameters = ConvertProperty $PSBoundParameters\r\n    $Input | Select-Object @Parameters\r\n}\r\n\r\nFunction FT2 {\r\n    [CmdletBinding()]\r\n    param(\r\n        [object[]]$Property,\r\n        [switch]$AutoSize, [switch]$RepeatHeader, [switch]$HideTableHeaders, [switch]$Wrap,\r\n        [object]$GroupBy, [string]$View, [switch]$ShowError, [switch]$Force, \r\n        [ValidateSet('CoreOnly','EnumOnly','Both')]$Expand,\r\n        [Parameter(ValueFromPipeline=$true, Mandatory=$true)]$InputObject\r\n    )\r\n    $Null = $PSBoundParameters.Remove('InputObject')\r\n    $Parameters = ConvertProperty $PSBoundParameters ([FormatString], [Width], [Alignment])\r\n    $Input | Format-Table @Parameters\r\n}\r\n\r\nFunction Sort2 {\r\n    [CmdletBinding()]\r\n    param(\r\n        [object[]]$Property,\r\n        [switch]$Stable, [switch]$Descending, [switch]$Unique,\r\n        [Parameter(ValueFromPipeline=$true, Mandatory=$true)]$InputObject,\r\n        [string]$Culture, [switch]$CaseSensitive\r\n    )\r\n    $Null = $PSBoundParameters.Remove('InputObject')\r\n    $Parameters = ConvertProperty $PSBoundParameters -Immutable ([Ascending], [Descending])\r\n    $Input | Sort-Object @Parameters\r\n}\r\n```\r\n## Change\r\nTo prevent a breaking change, the wrappers test for any known property attribute name (`Name`, `Label`, `Expression,`...) or abbreviation (`n`, `l`, `e,`...) and if found, it will assume the current property syntax layout and exclude it from the conversion. This could be a little stricter by excluding anything that would produce an error like:\r\n \r\n > `The <keyname> key is not valid.`\r\n> `A mandatory entry for expression is missing.`\r\n> `The <keyname> key has a type, System.Object[], that is not valid; expected type is System.String.`\r\n\r\n<sub>In the unlikely case of an overlap (where e.g. the property names have similar names and value types as the property attributes), the current syntax implementation will simply take priority.</sub>\r\n\r\n## Typecasting\r\nOnce the a dictionary item is considered to be an new syntax, it will parse the (array of) property attributes in the following order:\r\n 1. **Explicit**, the attribute is a predefined property attribute type (e.g. `[Expression]'<expresson>'`.\r\n 2. **Implicit enumeration value**, the (`[Srting]`) attribute is listed by any predefined attribute (`[enum]`) enumerations.  (e.g. `Left`, `Center` or `Right` for `[Alignment]`).\r\n 3. **Implicit type**,  the common type of the attribute is used by one of the constructors of the predefined attribute classes (e.g. `[Int]` for `[Width]`, `[String]` for `[FormatString]`,  and `[ScriptBlock]` for `[Expression]`). <br>\r\n<sub>In the event the variety of calculated properties crow that much, and an unlikely conflict arise, <strike>the order of the attribute might also be taken in consideration</strike>(requires `[orderer]` attribute table, see #8107). Besides specific attribute can always been forced using explicit property attributes. </sub>\r\n\r\n## Disadvantage\r\nThe disadvantage of the purposed solution is that all possible property attributes need to be predefined. This could be through some more advanced sub classes contained by a larger \"decoration\" class and possibly some type accelerators. (Unfortunately, I am not aware of any technique that can be done in the scope of the cmdlet but prior loading the parameters and doubt that exists.) At the other hand predefined property attributes could also be useful to decorate an object and set the default attribute of a property along with the object itself rather than defining the attributes with the `-Property` parameter of the specific cmdlet.\r\n\r\n## Examples\r\n\r\n**`Select-Object`**\r\n\r\n```PowerShell\r\n# Current syntax:\r\nGet-ChildItem | Select2 Name,\r\n    @{label='Size';expression={ $_.length/1KB }},\r\n    @{l='Days';e={ ((Get-Date) - $_.LastAccessTime).Days }}\r\n\r\n# Purposed implicit syntax:\r\nGet-ChildItem | Select2 Name,\r\n    @{Size = { $_.length/1KB }},\r\n    @{Days = { ((Get-Date) - $_.LastAccessTime).Days }}\r\n```\r\n\r\nYou could also put all properties in one hash table:\r\n\r\n```PowerShell\r\nGet-ChildItem | Select2 Name, @{\r\n    Size = { $_.length/1KB }\r\n    Days = { ((Get-Date) - $_.LastAccessTime).Days }\r\n}\r\n```\r\n\r\nBut in this case the order will be lost (I am not sure when this can be be resolve take in account that the order will not be lost in a new/ordered object constructor syntax). Anyways, it is also possible to provide an `[Ordered]` dictionary:\r\n\r\n```PowerShell\r\nGet-ChildItem | Select2 Name, ([Ordered]@{\r\n    Size = { $_.length/1KB }\r\n    Days = { ((Get-Date) - $_.LastAccessTime).Days }\r\n})\r\n\r\n# Purposed explicit syntax:\r\nGet-ChildItem | Select2 Name, @{\r\n    Size = [Expression]{ $_.length/1KB }\r\n    Days = [Expression]{ ((Get-Date) - $_.LastAccessTime).Days }\r\n}\r\n```\r\n\r\n**`Format-Table` example 1**\r\n\r\n```PowerShell\r\n# Current syntax:\r\nget-date | ft2 'Date',\r\n    @{Name = 'Time'; Expression = { $_ }; FormatString = 'T'},\r\n    @{Name = 'Min'; Expression = { (60 - $_.Minute)/60 }; FormatString = 'P'; Alignment = 'Left'} -AutoSize\r\n\r\n# Purposed implicit syntax:\r\nget-date | ft2 'Date',@{Time = { $_ }, 'T'; Min = { (60-$_.Minute)/60}, 'P', 'Left' } -AutoSize\r\n\r\n# Purposed explicit syntax:\r\nget-date | ft2 'Date',@{\r\n    Time = [Expression]{ $_ },'T'\r\n    Min = [Expression]{ (60-$_.Minute)/60 }, [FormatString]'P', [Alignment]'Left'\r\n} -AutoSize\r\n```\r\n\r\n**`Format-Table` example 2**\r\n\r\n```PowerShell\r\n$Table = ConvertFrom-Csv @'\r\nAAA,BBB,CCC\r\n1,2,3\r\n4,5,6\r\n'@\r\n\r\n# Current syntax:\r\n$Table | FT2 @{'Alignment' = 'Left'; 'Expression' = 'AAA'; 'Width' = 10},\r\n    @{'Alignment' = 'Center'; 'Expression' = 'BBB'; 'Width' = 10},\r\n    @{'Alignment' = 'Right'; 'Expression' = 'CCC'; 'Width' = 10}\r\n\r\n# Purposed (implicit) syntax:\r\n$Table | FT2 @([Ordered]@{AAA = 'Left', 10; BBB = 'Center', 10; CCC = 'Right', 10})\r\n```\r\n\r\n**`Sort-Object` Example 1**\r\nNote that the properties of the objects passed thru the `Sort-Object` do not change and therefore expressions are not added to the properties as with `Select-Object` and `Format-Table`\r\n\r\n```PowerShell\r\n# Current syntax:\r\nGet-ChildItem | Sort2 @{Expression = 'Length'; Descending = $True}\r\n\r\n# Purposed syntax:\r\nGet-ChildItem | Sort2 @{Length = 'Descending'}\r\n```\r\n\r\n**`Sort-Object` Example 2**\r\n\r\n```PowerShell\r\n# Current syntax:\r\nGet-ChildItem | Sort2 @{Expression = { $_.CreationTime - $_.LastWriteTime }; Descending = $True}\r\n\r\n# Purposed syntax:\r\nGet-ChildItem | Sort2 @{{ $_.CreationTime - $_.LastWriteTime } = 'Descending'}\r\n```\r\n",
  "closed_at": "2020-02-20T16:21:52Z",
  "comments": [
    {
      "author": "HumanEquivalentUnit",
      "author_association": "CONTRIBUTOR",
      "body": "Looks like it's related to request #8107 ",
      "created_at": "2020-02-20T00:03:46Z",
      "updated_at": "2020-02-20T00:03:46Z"
    }
  ],
  "created_at": "2020-02-17T12:19:31Z",
  "number": 11866,
  "state": "closed",
  "title": "Simplified calculated property syntax",
  "updated_at": "2020-02-21T02:58:40Z"
}