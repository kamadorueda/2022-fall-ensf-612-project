{
  "_url": "https://github.com/PowerShell/PowerShell/issues/4616",
  "author": "alx9r",
  "body": "Steps to reproduce\r\n------------------\r\n\r\n```powershell\r\nfunction f {\r\n    param (\r\n        [AllowNull()]\r\n        [string]\r\n        $x\r\n    )\r\n    return $x\r\n}\r\n\r\n$r = f -x $null\r\n$null -eq $r\r\n```\r\n\r\nExpected behavior\r\n-----------------\r\n\r\nI expected the output to be `True` because I expected `$null` to pass through `f` unaltered. \r\n\r\nActual behavior\r\n---------------\r\nThe output is `False` because `$null` is converted to `[string]::Empty` when it is assigned to `$x`.\r\n\r\nEnvironment data\r\n----------------\r\n\r\n<!-- provide the output of $PSVersionTable -->\r\n\r\n```powershell\r\n> $PSVersionTable\r\n\r\nName                           Value                                           \r\n----                           -----                                           \r\nPSVersion                      6.0.0-beta                                      \r\nPSEdition                      Core                                            \r\nGitCommitId                    v6.0.0-beta.5                                   \r\nOS                             Microsoft Windows 6.3.9600                      \r\nPlatform                       Win32NT                                         \r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}                         \r\nPSRemotingProtocolVersion      2.3                                             \r\nSerializationVersion           1.1.0.1                                         \r\nWSManStackVersion              3.0                                             \r\n\r\n```\r\n\r\nWhy do I expect it to be possible for `$null` to remain `$null` when passed to a string parameter?\r\n----------------\r\n\r\nFor every other parameter type I have tested it is possible to pass `$null` without conversion.  I have tested the following:\r\n\r\n```PowerShell\r\nfunction f { param([System.Nullable[int]]$x) $x }\r\nfunction f { param([System.Nullable[System.DayOfWeek]]$x) $x }\r\nfunction f { param([hashtable]$x) $x }\r\nfunction f { param([array]$x) $x }\r\nfunction f { param([System.Collections.Generic.Dictionary[string,int]]$x) $x }\r\nfunction f { param([System.Collections.ArrayList]$x) $x }\r\nfunction f { param([System.Collections.BitArray]$x) $x }\r\nfunction f { param([System.Collections.SortedList]$x) $x }\r\nfunction f { param([System.Collections.Queue]$x) $x }\r\nfunction f { param([System.Collections.Stack]$x) $x }\r\n```\r\n\r\nPassing `$null` to any of these functions outputs `$null`. The only parameter type I haven't found a way to which to pass `$null` without conversion is `[string]`; PowerShell always converts `$null` to `[string]::Empty`.\r\n\r\nPowerShell's behavior in this regard is also inconsistent with C#. The corresponding function in C# is as follows:\r\n\r\n```C#\r\npublic string f(string x)\r\n{\r\n    return x;\r\n}\r\n```\r\nCalling `f(null)` returns `null`.\r\n\r\nWhy does it matter that `$null` is unconditionally converted to `[string]::Empty`?\r\n----------------\r\n\r\nAll other collection-type parameters of a function can take three different empty-ish values:\r\n\r\n* a collection object containing no items (eg. `@()`, `@{}`, `[System.CollectionsArraylist]`, etc)\r\n* `$null`\r\n* not bound (ie. the parameter name is not in `$MyInvocation.BoundParameters.Keys`)\r\n\r\nEach of these represents different arguments at the call site.  Each can be distinguished from the other inside the function unless the parameter type is `[string]`. For `[string]` parameters `$null` always gets converted to `[string]::empty`.  This causes information to be lost between the call site and the function body: It is not possible to distinguish between the `$null` and `[string]:empty` arguments as they both appear as `[string]::empty` inside the function.\r\n\r\nThis has significant implications for a function whose parameter has different meaning for `$null` versus `[string]::empty`.  In DSC resources, for example, it is natural to pass groups of parameters from the Set and Test functions down through a call stack which eventually makes a system call to manipulate some configuration.  In such scenarios preserving the distinction between `$null` and `[string]::empty` often has a critical distinction in meaning.  Omitting a string parameter altogether customarily means \"don't make a change to the configuration thing that this parameter would affect.\"  Passing `[string]::empty` to a string parameter customarily means \"clear the configuration  thing that this parameter affects.\"  But as soon as a string argument whose value is null encounters a function parameter that is statically typed as `[string]`, PowerShell unexpectedly converts it to `[string]::empty`.  That has the effect of implicitly converting all string parameters not mentioned in the configuration from `$null` \"don't make a change\" to `[string]::empty` \"clear the thing\".\r\n\r\nIt might be possible in certain cases to rely on the \"not bound\" state of function parameters, however, for class-based DSC resources the \"parameters\" are properties of the class and there's no analog to \"not bound\" for such properties.  Incidentally, assignment of `$null` to class properties of different types seems to behave exactly the same as parameter binding of each type: They all allow assignment to `$null` except `[string]`.\r\n\r\nWhat am I hoping for?\r\n----------------\r\n\r\nI'm hoping for some kind of workaround that retains the static-typing of the parameter.  I'm hoping there's some way I don't know about to tell PowerShell that a parameter can be either `$null` or a `[string]`.\r\n\r\nLong-term I'm hoping that PowerShell has comprehensive support for nullable strings as C# does and PowerShell already does for other collections.\r\n\r\nSee also\r\n----------------\r\n\r\nhttps://stackoverflow.com/q/45720150/1404637\r\n",
  "closed_at": "2017-08-19T15:38:47Z",
  "comments": [
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "I can understand your pain and I have been caught out by this behaviour before as well.\r\n\r\nIf you simply remove the `[string]` type then it will work as expected:\r\n```\r\nfunction f2 {\r\n    param (\r\n        $x\r\n    )\r\n    return $x\r\n}\r\n$null -eq (f2 -x $null)\r\n```\r\nThere is no value in declaring a parameter as type string because all classes in .Net have to derive from the [Object ](https://docs.microsoft.com/en-us/dotnet/api/system.object?view=netframework-4.7#remarks) class. Therefore every class implements `ToString()` and thus PowerShell would convert you every object to a string anyway.\r\n\r\nHowever, there are more complex scenarios such as e.g. passing `$null` into a method that got compiled in C# by PowerShell using `Add-Type`. In this scenario (see [here](https://stackoverflow.com/questions/38958377/powershell-null-is-not-null-any-more-when-calling-into-c-sharp-code) for my SO question last year)\r\nThe workaround for this is to use the [NullString](https://msdn.microsoft.com/en-us/library/system.management.automation.language.nullstring.value(v=vs.85).aspx) class that got introduced in PowerShell v3 and pass in `[NullString]::Value`\r\n\r\nAlthough I would also upvote if it is possible to improve it going forward, this will be up to the MSFT guys since this could be quite a big breaking change and given the fact that the NullString class got introduced in v3 suggests to me that they were aware of this but did not want to make the breaking change back then. But maybe now is the time where this breaking change would not hurt as much as it would've been in previous versions?",
      "created_at": "2017-08-19T11:54:09Z",
      "updated_at": "2017-08-19T15:55:06Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "This is by design and as @bergmeister points out - changing the behavior would be a massive breaking change.\r\n\r\nThe thinking behind the design was that in most ways, `$null` and the empty string both represent the same error condition and that in the rare case where a distinction was important, `PSBoundParameters` would be sufficient to distinguish between knowing a value was provided or not.\r\n\r\nLet's consider the alternatives:\r\n\r\n```powershell\r\nif ($str -eq '') { ... }  # preferred\r\nif ($str -eq $null) { ... }  # handles empty string in a similar manner\r\nif ($str -eq $null -or $str -eq '') { ... } # pointless in PowerShell today, but necessary if we changed it\r\nif ([string]::IsNullOrEmpty($str)) { ... }  # an alternative to 2 tests\r\n```\r\n\r\nThe first is the shortest, and in most cases, needs to be checked anyway.\r\nThe second works in a similar manner, but does invoke a conversion from `$null` to the empty string.\r\nThe third and fourth options would typically be necessary if PowerShell did not do this conversion.\r\n\r\nWe do occasionally hear requests to not do this conversion, and the reason is usually to be more like C#, e.g. to test a C# api and verify that it validates the arguments.\r\n\r\nTo support this scenario, we added an api, you can use it like this:\r\n\r\n```powershell\r\nPS> [string]$s = [NullString]::Value\r\nPS> $null -eq $s\r\nTrue\r\n```",
      "created_at": "2017-08-19T15:38:46Z",
      "updated_at": "2017-08-19T15:38:46Z"
    },
    {
      "author": "alx9r",
      "author_association": "NONE",
      "body": "@lzybkr \r\n\r\n> ...changing the behavior would be a massive breaking change.\r\n\r\nI appreciate and accept this.\r\n\r\n>We do occasionally hear requests to not do this conversion, and the reason is usually to be more like C#, e.g. to test a C# api and verify that it validates the arguments.\r\n>To support this scenario, we added an api, you can use it like this:\r\n>PS> [string]$s = [NullString]::Value\r\n>PS> $null -eq $s\r\n>True\r\n\r\nAre you implying that `[NullString]::Value` is meant to support passing `$null` to a `[string]` parameter?  That would afford some options that might alleviate some of the pain.  But it doesn't seem to do that. \r\n `[NullString]::Value` also gets converted to `[string]::empty` when passed to a function:\r\n\r\n```PowerShell\r\nfunction f {\r\n    param (\r\n        [AllowNull()]\r\n        [string]\r\n        $x\r\n    )\r\n    return $x\r\n}\r\n\r\n$r = f -x ([NullString]::Value)\r\n$r.GetType().Name\r\n```\r\n\r\nExecuting that snippet outputs `String`.  `$r` is `[string]::Empty` despite that `[NullString]::Value` was passed to `$x`.\r\n\r\nIs this how `[NullString]::Value` is supposed to work when passed to a function?",
      "created_at": "2017-08-20T15:34:14Z",
      "updated_at": "2017-08-20T15:34:14Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "I can't explain this behavior.\r\n\r\nParameters to C# methods was the target scenario for `[NullString]::Value`, and I will say that might be the only reasonable scenario. Typical usage would end up coercing `null` to the empty string sooner than later.\r\n\r\nIn this case though, it does seem sooner is too soon, but if this was changed, I do think it would be hard to take advantage of it in a useful way.",
      "created_at": "2017-08-20T16:47:55Z",
      "updated_at": "2017-08-20T16:47:55Z"
    },
    {
      "author": "alx9r",
      "author_association": "NONE",
      "body": ">...I do think it would be hard to take advantage of it in a useful way.\r\n\r\nI disagree.  Allowing `[NullString]::Value` to propagate without conversion to `[string]::empty` is useful when optional string parameters are handled in bulk using either `ValueFromPipelineByPropertyName` or via hashtable splatting.  Here is an example using the former demonstrating parameter passing that arises naturally when working with class-based DscResources:\r\n\r\n```PowerShell\r\nclass SomeDscResource\r\n{\r\n    #[DscResource()]\r\n    [string]$a = [NullString]::Value\r\n    [string]$b = [NullString]::Value\r\n    [string]$c = [NullString]::Value\r\n    # ...\r\n\r\n    [void] Set () {\r\n        $this | Set-SomeConfiguration\r\n    }\r\n    # ...\r\n}\r\n\r\nfunction Set-SomeConfiguration\r\n{\r\n    param\r\n    (\r\n        [Parameter(ValueFromPipelineByPropertyName = $true)]\r\n        [string]\r\n        $a,\r\n\r\n        [Parameter(ValueFromPipelineByPropertyName = $true)]\r\n        [string]\r\n        $b,\r\n\r\n        [Parameter(ValueFromPipelineByPropertyName = $true)]\r\n        [string]\r\n        $c\r\n\r\n        #...\r\n    )\r\n    process\r\n    {\r\n        foreach ( $paramName in $PSCmdlet.MyInvocation.BoundParameters.Keys )\r\n        {\r\n            Write-Host \"Parameter $paramName : \" -NoNewline\r\n            switch ( Get-Variable $paramName -ValueOnly )\r\n            {\r\n                ($null)               { Write-Host \"do nothing\"; break }\r\n                ([NullString]::Value) { Write-Host \"do nothing\"; break }\r\n                ([string]::Empty)     { Write-Host \"clear\" } \r\n                Default               { Write-Host \"set to $paramName\"}\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nWhen the resource needs to be set, `.a`, `.b`, and `.c` are optionally assigned and `.Set()` is called:\r\n\r\n```PowerShell\r\n$rsrcObj = [SomeDscResource]::new()\r\n$rsrcObj.a = 'desired value'\r\n$rsrcObj.b = [string]::Empty\r\n$rsrcObj.Set()\r\n```\r\n\r\nCurrently that outputs\r\n\r\n```\r\nParameter a : set to a\r\nParameter b : clear\r\nParameter c : clear\r\n```\r\n\r\nwhich is incorrect for `c` as it was not assigned and should be left untouched.  Rather, the result should be as follows:\r\n\r\n```\r\nParameter a : set to a\r\nParameter b : clear\r\nParameter c : do nothing\r\n```\r\n\r\nThis can be achieved today by omitting the `[string]` static type in all functions that might have bulk properties passed in one of such ways.  That, however, requires that all future maintainers and creators of all functions that accept such `[string]` parameters be aware that a statically-typed `[string]` parameter behaves fundamentally different from all other types with respect to `$null`.  In real DSC resources with reasonably-factored code, it is usual that parameters pass through several functions before use.  It seems unrealistic to expect that static-typing as `[string]` is omitted (but static-typing for any other type is permitted) at each of those sites.  \r\n\r\nIt seems more realistic, however, to write a comment about the merits of `[NullString]::value` over `$null` at the few sites where the default values for the parameters object or hashtable are set.  \r\n\r\nIn other words, if `[NullString]::Value` could be passed to `[string]` parameters unaltered, the pain of `$null` conversion to `[string]::empty` could be managed once where the parameter is created (or at the module boundary) rather than at every possible site where such a parameter might be passed to a parameter statically-typed as `[string]`.\r\n",
      "created_at": "2017-08-20T20:34:54Z",
      "updated_at": "2017-08-20T20:36:38Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "`[NullString]::Value` turns into `$null` immediately when you write:\r\n\r\n```\r\n    [string]$a = [NullString]::Value\r\n```\r\n\r\n`string` is sealed, `NullString` is a completely unrelated type, so PowerShell must convert the instance to string (which it does via a call to `ToString` that returns null) before the assignment.\r\n\r\nIt is this eager conversion that makes it difficult to effectively use `[NullString]::Value` in PowerShell.\r\n\r\nWe could introduce a new special empty string to represent the notion of an unspecified value, something like:\r\n\r\n```PowerShell\r\nclass SentinalEmptyString\r\n{\r\n    static [string] Value = [string]::new()\r\n}\r\n```\r\n\r\nDoing so would be error prone though - you would need to use `[object]::ReferenceEquals([SentinalEmptyString]::Value, $other)` consistently to avoid accidentally testing against random empty strings. Alternatively, you could initialize this string with unlikely value.\r\n\r\nAt any rate, I think user defined properties might be the cleaner path to solving your problem with classes - that way you can detect when the property is set versus not.",
      "created_at": "2017-08-21T03:19:50Z",
      "updated_at": "2017-08-21T03:19:50Z"
    },
    {
      "author": "alx9r",
      "author_association": "NONE",
      "body": ">[NullString]::Value turns into $null immediately when you write:\r\n>    [string]$a = [NullString]::Value\r\n\r\nGood point.\r\n\r\n> We could introduce a new special empty string to represent the notion of an unspecified value...Doing so would be error prone though...\r\n\r\nI tried that approach, but didn't find a net improvement.\r\n\r\nIt seems like having a type that has APIs just like `System.String` except is _not_ special-cased by PowerShell would alleviate this problem.  Then it would just be a matter of using that string type where the typical behavior involving `null` is needed.  I have been experimenting with introducing such a type.  The preliminary results are promising.  \r\n\r\nIf you're interested, an example is in [this gist](https://gist.github.com/alx9r/fec92c03387d694ad2b9dee48cd7d4be).  I've implemented `IEquatable` and `IComparable` and it seems to work well in contexts that rely on those interfaces, and it doesn't have the painful properties related to `$null`.  I'm interested in what you think.",
      "created_at": "2017-08-21T14:13:21Z",
      "updated_at": "2017-08-21T14:13:21Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "That's an interesting approach. I would anticipate some confusing issues that typically come up when introducing a proxy like this, but nothing specific comes immediately to mind.\r\n\r\nI do think user defined properties are the ideal solution for this problem.",
      "created_at": "2017-08-21T19:43:36Z",
      "updated_at": "2017-08-21T19:43:36Z"
    },
    {
      "author": "alx9r",
      "author_association": "NONE",
      "body": "(It's not my intention to re-open this conversation.  Rather, I'm leaving this information here for completeness.)\r\n\r\n[PowerShell cmdlet \"Strongly Encouraged Design Guideline\" SD03](https://msdn.microsoft.com/en-us/library/dd878270(v=vs.85).aspx#SD03) \"strongly encourages\" the use of null to indicate \"unspecified\" similarly as [was argued above](https://github.com/PowerShell/PowerShell/issues/4616#issuecomment-323610228):\r\n\r\n>If your parameter needs to differentiate between 3 values: $true, $false and \u201cunspecified\u201d, then define a parameter of type Nullable<bool>. The need for a 3rd, \"unspecified\" value typically occurs when the cmdlet can modify a Boolean property of an object. In this case \"unspecified\" means to not change the current value of the property.",
      "created_at": "2017-09-09T16:35:57Z",
      "updated_at": "2017-09-09T16:35:57Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@lzybkr:\r\n\r\n> I can't explain this behavior. \r\n\r\n(A `[string]` parameter with default value `[NullString]::Value` turning to `''`)\r\n\r\n@PetSerAl thinks this behavior is related to the optimization bug reported in #4312.\r\n\r\nAnd the workaround proposed there indeed fixes the problem:\r\n\r\n```powershell\r\nPS> function foo { param([string] $bar = [nullstring]::value) $null -eq $bar }; foo\r\nFalse # !! broken: $bar should be $null, but is ''\r\n\r\n# Workaround\r\nPS> function foo { param([string] $bar = [nullstring]::value) if ($false) { Remove-Variable }; $null -eq $bar }; foo\r\nTrue # OK - the mere presence of Remove-Variable in the function body fixed the problem.\r\n```\r\n\r\nThus, unless there are considerations I'm missing, fixing #4312:\r\n\r\n* would allow `[string]` _parameters_ to _default to_ `$null` (via default value `[NullString]::Value]`), as above.\r\n\r\n* would allow passing `[string]` _variables_ that contain `$null` (by having been assigned `[NullString]::Value]`- directly or via a parameter default value) on as arguments to `[string]`-typed parameters.\r\n\r\n\r\n",
      "created_at": "2018-07-15T19:47:26Z",
      "updated_at": "2018-07-16T02:43:14Z"
    }
  ],
  "created_at": "2017-08-19T03:10:57Z",
  "number": 4616,
  "state": "closed",
  "title": "Passing $null to a [string] parameter unconditionally causes conversion to [string]::Empty",
  "updated_at": "2018-07-16T02:43:14Z"
}