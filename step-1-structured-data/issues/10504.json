{
  "_url": "https://github.com/PowerShell/PowerShell/issues/10504",
  "author": "iRon7",
  "body": "Suppress the error on the `-is` operator when the type is supplied as a string:\r\n\r\n`$a -is 'UndefinedType'`\r\n\r\n```\r\nCannot convert the \"UndefinedType\" value of type \"System.String\" to type \"System.Type\".\r\nAt line:1 char:1\r\n+ $a -is 'UndefinedType'\r\n+ ~~~~~~~~~~~~~~~~~~~~~~\r\n+ CategoryInfo          : NotSpecified: (:) [], RuntimeException\r\n+ FullyQualifiedErrorId : RuntimeException\r\n```\r\n\r\nIf \"strict\" programming is required, the system.type (square brackets) should be used instead:\r\n\r\n`$a -is [UndefinedType]`\r\n\r\n```\r\nUnable to find type [UndefinedType].\r\nAt line:1 char:8\r\n+ $a -is [UndefinedType]\r\n+        ~~~~~~~~~~~~~~~\r\n+ CategoryInfo          : InvalidOperation: (UndefinedType:TypeName) [], RuntimeException\r\n+ FullyQualifiedErrorId : TypeNotFound\r\n```\r\n\r\n<sub>(Were the error is actually generated by the type casting and not the `-is`operator.)/sub>\r\n\r\nThis would allow for easier type checking on types that might not exist in certain environments (like `[semver]` that doesn't exist in Windows PowerShell, see also: Stackoverflow: [How to test a (possible) unknown type?](https://stackoverflow.com/q/57805460/1701026)\r\n\r\nBesides, I think this is more in line with the general PowerShell behavor set by the PowerShell team: [\"Type Conversion in PowerShell is, without question, one of the most useful ingredients in its \"Magic Sauce\" of administrator effectiveness.\"](https://devblogs.microsoft.com/powershell/understanding-powershells-type-conversion-magic/) and looking to other comparison operators, there aren't many operators that can produce an error.\r\n\r\nIn other words, from my perspective:\r\n`$a -is 'UndefinedType'` should just return `$False` without error and `$a -isnot 'UndefinedType'` should just return `$True` without error. ",
  "closed_at": "2019-09-12T12:00:34Z",
  "comments": [
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Yeah, I think I can get behind this. Asking whether an object is of a nonexistent type should probably just return `$false`; it certainly still answers the query the operator is designed to address.\r\n\r\nFWIW, you can workaround this for the time being with a pattern like this:\r\n\r\n```powershell\r\n$Type = 'UnknownType' -as [type]\r\n$Result = $Type -and $object -is $Type\r\n```\r\n\r\nWhich isn't _ideal_ but it does avoid the issue in the meantime. \ud83d\ude42 ",
      "created_at": "2019-09-09T17:42:42Z",
      "updated_at": "2019-09-09T17:44:22Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "@iRon7 What scenario do you have that ignoring this error would facillitate? In general, hiding errors is bad practice. If you mistype a  type name or don't have an assembly loaded you *should* get an error. If you just want to see if a string names a type then do that i.e.:\r\n```powershell\r\nPS[1] (83) > \"adsasdas\" -is [type]\r\nFalse\r\n```\r\n\r\n ",
      "created_at": "2019-09-09T22:16:46Z",
      "updated_at": "2019-09-09T22:16:46Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I don't think that works the way you claim, @BrucePay? It would be very odd to have two variant behaviours for `$string -is [type]`",
      "created_at": "2019-09-09T22:40:30Z",
      "updated_at": "2019-09-09T22:40:30Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "@vexx32 Oops - you're right. My bad. I've been using `LanguagePrimitives.ConvertTo` in C# a lot lately which does do the conversion\r\n```powershell\r\n[System.Management.Automation.LanguagePrimitives]::ConvertTo(\"int32\", [type]) != $null\r\n```\r\nStill, this is pretty straight forward:\r\n```powershell\r\nPS1> \"int32\" -as [type] -ne $null\r\nTrue\r\nPS1> \"notatype\" -as [type] -ne $null\r\nFalse\r\n```\r\nEither way, it doesn't change the fact that silently ignoring errors is bad practice.\r\n\r\n",
      "created_at": "2019-09-09T23:09:42Z",
      "updated_at": "2019-09-09T23:09:42Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Mmm. Depends what you're trying to determine, really.\r\n\r\nI'd think the point of `-is` is simply to determine whether the item in question is an instance of the type given -- not necessarily to also determine whether the given type is actually present in the current session. One task at a time, as it were. :slightly_smiling_face: ",
      "created_at": "2019-09-10T01:58:07Z",
      "updated_at": "2019-09-10T01:58:07Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "I think this would mostly end up just making typos harder to find.  Granted that's generally speaking pretty on brand for PowerShell, but the use cases here are not as compelling as with other instances.\r\n\r\nMost of the time when you're not using a default type, you're going to be explicitly loading the assembly.  In most of the cases you aren't doing that, you probably still *need* it loaded .  In the few cases were you truly want this failure to be ignored, you're better off being slightly more explicit with something like this:\r\n\r\n```powershell\r\nif ('SomeType' -as [type] -and $var -is [SomeType]) {\r\n    return $true\r\n}\r\n```",
      "created_at": "2019-09-10T02:25:40Z",
      "updated_at": "2019-09-10T02:25:40Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "@BrucePay, there are pro's and con's with regards a strict programming language but as far I can tell, PowerShell **not** a strict language (_by default_).\r\nIn other words, I do not get an error with the following statements either:\r\n```\r\n$UndefinedVariable -eq 0\r\n$TypoInVaraible -eq 0\r\n```\r\nKnowing that there is no technical difference between the above statements, from a developer standpoint it will be preferred to get an error for the later \"`$TypoInVaraible`\" example but for the first example, it might be desired in a syntax like:\r\n\r\n`If ($a -eq 'Varaible') {$a = 'Variable'}`\r\n\r\n(Knowing that I will not get an error when `$a` is undefined or `$Null`)\r\nThe same behavior I would expect for the `-is` operator:\r\n\r\n`If ($v -is 'semver') {'Patch version: ' + $v.Patch} Else {'No patch version available'}`\r\n\r\nBut this generates an error in Windows PowerShell  (I understand that this request will not fix this for this specific -past- example but future versions and environments might cause similar situations)\r\n\r\nBtw, the [`Set-StrictMode`](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/set-strictmode?view=powershell-6) should play a roll in this. In strict mode, I actually do expect an error if the type doesn't exist in the current environment or a simple enforcement of the use of a `[Type]` type (the use of square brackets).\r\n\r\n(Once again, a strict syntax can also still be enforced by using square brackets: `$v -is [semver]`)\r\n\r\n\r\n",
      "created_at": "2019-09-10T12:53:15Z",
      "updated_at": "2019-09-10T17:02:03Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I would be inclined to also agree that unless Strict Mode is enabled, the proposed behaviour makes sense.",
      "created_at": "2019-09-10T12:55:34Z",
      "updated_at": "2019-09-10T12:55:34Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "@iRon7 Even in non-strict mode, PowerShell tries to error on impossible behaviour. For example\r\n```powershell\r\n[int] \"abc\"\r\n```\r\nis an error (unlike say Javascript).  Likewise `123 + \"abc\"` is an error. `$x.nosuchmethod()` is an error.  `123/0` is an error.  `[type] 'nosuchtype'` is an error. As much as possible, we try to treat things that make no sense as errors. In particular, we wanted implicit (or explicit) type conversions to be rational so `[int] \"123\"` works but `[int] \"abc\"`.\r\n\r\n@SeeminglyScience \r\n> I think this would mostly end up just making typos harder to find.\r\n\r\nAgree 100%. Type names tend to be long so it's easy to make a mistake.",
      "created_at": "2019-09-10T17:27:05Z",
      "updated_at": "2019-09-10T17:27:05Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This issue has been marked as answered and has not had any activity for **1 day**. It has been closed for housekeeping purposes.",
      "created_at": "2019-09-12T12:00:34Z",
      "updated_at": "2019-09-12T12:00:34Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "@iSazonov, what exactly does this automatic close mean? That the request is rejected? Do I need to spam you daily to keep it open until it is accepted or not? (I don't think that is good for housekeeping either.)",
      "created_at": "2019-09-12T13:31:47Z",
      "updated_at": "2019-09-12T13:31:47Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> That the request is rejected?\r\n\r\n@iRon7 The issue is not _locked_ - anybody can comment and share new thoughts.\r\n\r\nMain concern here that the enhancement will hide typos. PowerShell is not only programming language where the change would be good but interactive shell where hiding typos is very bad. The discussion shows that interactive scenario is more important and in scripts we can use strong syntax and/or simple workarounds if needed.\r\nWe could request Script Analyzer to recommend strong syntax. It is another argument that current compromise is good.\r\n",
      "created_at": "2019-09-13T04:12:02Z",
      "updated_at": "2019-09-13T04:12:02Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "@iSazonov , thanks for the explanation, I can only summarize my arguments:\r\n* PowerShell is a not a strict language (by default)\r\n* Other operators like `-eq` act the same, meaning by default (`Set-StrictMode Off`) they do not resolve typos\r\n* Casting typos are not related (an explicit syntax like `$v -is [semver]` will still produce an error when `[semver]` is misspelled)\r\n* `Set-StrictMode` in this request should enforce strict typing for `$v -is 'semver'` (e.g. to use: `$v -is [semver]`) similar to other operators.\r\n\r\nUnless something new comes up, I will leave it as it is.",
      "created_at": "2019-09-13T07:04:50Z",
      "updated_at": "2019-09-13T07:17:44Z"
    }
  ],
  "created_at": "2019-09-09T17:28:36Z",
  "labels": [
    "Issue-Enhancement",
    "Resolution-Answered"
  ],
  "number": 10504,
  "state": "closed",
  "title": "Feature Request: -Is operator: suppress \"Cannot convert\"error",
  "updated_at": "2019-09-13T07:17:44Z"
}