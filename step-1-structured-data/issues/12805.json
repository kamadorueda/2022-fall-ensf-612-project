{
  "_url": "https://github.com/PowerShell/PowerShell/issues/12805",
  "author": "Herr-Sepp",
  "body": "<!--\r\n\r\nFor Windows PowerShell 5.1 issues, suggestions, or feature requests please use the following link instead:\r\nWindows PowerShell [UserVoice](https://windowsserver.uservoice.com/forums/301869-powershell)\r\n\r\nThis repository is **ONLY** for PowerShell Core 6 and PowerShell 7+ issues.\r\n\r\n- Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\r\n- Search the existing issues.\r\n- Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\r\n- Refer to the [known issues](https://docs.microsoft.com/powershell/scripting/whats-new/known-issues-ps6).\r\n\r\n-->\r\n\r\nIf i want to copy content from a directory without subdirectorys to a NEW folder the [Documentations ](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/copy-item?view=powershell-7#examples\r\n)says unter **Example 3**: \r\n\r\n> If the Path includes \\*, all the directory's file contents, without the subdirectory trees, are copied to the new destination directory. For example:\r\n> \r\n> Copy-Item -Path \"C:\\Logfiles\\*\" -Destination \"C:\\Drawings\\Logs\" -Recurse\r\n> \r\n\r\nBut this only works if under Path (\"C:\\Logfiles\") are subdirectorys.\r\n\r\n# Steps to reproduce\r\n\r\n```powershell\r\nC:\\Logfiles exists and contains only files\r\nC:\\Drawings exists\r\n\r\nCopy-Item -Path \"C:\\Logfiles\\*\" -Destination \"C:\\Drawings\\Logs\" -Recurse\r\n```\r\n\r\n# Expected behavior\r\n\r\n```\r\nDirectory \"Logs\" is created under \"C:\\Drawings\" with all Files from \"C:\\Logfiles\"\r\n```\r\n\r\n# Actual behavior\r\n\r\n```\r\nPowershell copy one File from Path (\"C:\\Logfiles\") to \"C:\\Drawings\" and name it \"Logs\" \r\nAll other Files are ignored\r\n\r\n```\r\n\r\nIf you create inside C:\\logfiles a directory everything works as it should.\r\n# Environment data\r\n\r\n<!-- provide the output of $PSVersionTable -->\r\n\r\n```none\r\nPowershell 7.0.1\r\n```\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I agree that the behavior is counter-intuitive.\r\n\r\nWhat happens is that if the `-Destination` argument is a path that _doesn't yet exist_, it is interpreted as a _file_, and it is the _last_ of the input files that ends up in that file.\r\n\r\nThe workaround is to make sure that the target path exists _as a directory_  beforehand.\r\n\r\nYou can mitigate the problem somewhat if you append a `\\` or `/` to the `-Destination` path so as to signal that the target path is meant to be a _directory_, in which case you'll at least get an error if no such directory exists yet.\r\n\r\nAlthough it would technically be a breaking change, it would make sense to default to assuming a container (directory) as the target path in case multiple paths / a wildcard-based path is specified as input, possibly complemented with a new switch such as `-CreateOnDemand` so as to create the container (directory) on demand.",
      "created_at": "2020-05-31T21:55:10Z",
      "updated_at": "2020-05-31T21:55:10Z"
    },
    {
      "author": "Herr-Sepp",
      "author_association": "NONE",
      "body": "Thanks for declaration.\r\nBut why does it work if Path has subdirectorys?\r\n\r\nI don't think a new switch is necessary.\r\nIt is documented that a new folder is created if the destination is not available ([Copy-Item Doc](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/copy-item?view=powershell-7#example-3--copy-directory-contents-to-a-new-directory))\r\n\r\nIf _Copy-Item -Path \"C:\\Logfiles\\*\" -Destination \"C:\\Drawings\\Logs\"_ worked as expeced, it would match the current documentation.\r\n\r\n\r\nAlso you don`t need the flag \"-Recurse\" for \"Copy all files to a new folder\" as described in the note of example 3.\r\nShould I make a new documentation issue for that or wait for further feedback here?\r\n\r\n",
      "created_at": "2020-07-13T12:31:55Z",
      "updated_at": "2020-07-13T12:31:55Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> Also you don't need the flag \"-Recurse\" for \"Copy all files to a new folder\" as described in the note of example 3\r\n\r\nYes, please open a documentation issue for that. \r\nThe short of it is: \r\n\r\n* `C:\\Logfiles\\*` _with_ `-Recurse` copies all files  and all subdirectories _and their subtrees_.\r\n\r\n* `C:\\Logfiles\\*` _without_ `-Recurse`, copies all files and all subdirectories _as empty directories_.\r\n\r\nIf you want to copy _files only_, you need to use something like `Get-ChildItem C:\\Logfiles -File | Copy-Item ...`",
      "created_at": "2020-07-13T13:15:51Z",
      "updated_at": "2020-07-13T13:15:51Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> It is documented that a new folder is created if the destination is not available\r\n\r\nThis applies if the source path is a _directory_ or at least _has directories among the items that a wildcard expression resolves to_. \r\nIf you explicitly pass _multiple_ `-Path` / `-LiteralPath` arguments, it is the type of the _first_ item that determines whether a non-existent destination path is considered a file or a directory.\r\n\r\nFor a _single_ directory and file, respectively, it makes sense to create a directory / a file (after all, `Copy-Item file.txt file1.txt` should _not_ create a directory named `file1.txt` and copy `file.txt` into it).\r\n\r\nThe current behavior gets messy with _multiple_ source paths, however:\r\n\r\n* _All-files_ source paths make `Copy-Item` consider a non-existing destination a _ single file_. \r\n\r\n   * This means that whatever file happens to be the last among the sources becomes the - only destination file.\r\n\r\n* _All-directories_ source paths make `Copy-Item` consider a non-existing destination a _ single directory_. \r\n   * The _first_ directory among the source path is copied (without `-Recurse`, this means little more than creating the destination directory, without contents)\r\n   * All _subsequent_ directories cause errors(!) and their contents are _ignored_: `Copy-Item: Container cannot be copied onto existing leaf item.`\r\n\r\n* _Mixed-type_ sources  resulting from wildcard expressions make `Copy-Item` also consider a non-existing destination a _single directory_.\r\n   * This means that all _files_ among the source are copied to the new destination directory, and, if `-Recurse` is specified,  the _contents_ of the _first_ among the source _directories_ is copied; again, any subsequent directories cause an error.\r\n\r\n  * Note: Wildcard resolution results in any directories among the matches being listed _first_, which causes the interpretation of the destination as a _directory_; by contrast, if you explicitly pass multiple paths as an _array_ to `-Path` / `-LiteralPath`, the _first_ array element's type determines how the destination is interpreted (as stated above); therefore, if you do something like `Copy-Item someFile.txt, someSubdir -Destination foo`, `foo` is created as a _file_ (as a copy of `someFile.txt`) and the subsequent attempt to copy _directory_ `someSubDir` to _file_ `foo` then _fails_.\r\n\r\n---\r\n\r\n> I don't think a new switch is necessary.\r\n\r\nThe proposed `-Create[DestinationAsContainer]OnDemand` switch  (name negotiable - I'm struggling to come up with one that is both succinct and descriptive) wasn't meant to address the issues above: it was meant as a convenience switch that allows you to unequivocally specify that the destination path should be a _directory_, to be created on demand,  that the source items should be _copied into_. For instance, `Copy-Item file.txt foo -CreateDestinationContainerOnDemand` would allow you to create directory `foo` on demand rather than creating a _file_ named `foo` in the absence of a preexisting `foo` _directory_. The same would apply to `Copy-Item somedir foo -Recurse -CreateDestinationContainerOnDemand`, which would copy `somedir` _as a whole_ into `foo/` rather than copying _its contents_ to a not-yet-existing `foo` directory.\r\n\r\nWhat _was_ meant to address the above issues was the following suggestion:\r\n\r\n> it would make sense to default to assuming a container (directory) as the target path in case multiple paths / a wildcard-based path is specified as input\r\n\r\nTo flesh this out a bit:\r\n\r\n* If _literally_ multiple `-Path` / `-LiteralPath` source paths are given, _always_ assume that the destination is a _directory_.\r\n\r\n* If a single `-Path` argument is given, and that argument is a _wildcard expression_ (e.g., `*.txt`) rather than a _literal_ (e.g., `file.txt`), _always_ assume that the destination is a _directory_.\r\n\r\n* Otherwise, as currently (single file or single directory), assume that the destination is a file or directory, respectively.\r\n\r\nGiven how the current behavior with multiple source items is both useless and obscure, it's hard to imagine that existing code relies on it, which would make this proposal an acceptable [Bucket 3: Unlikely Grey Area](https://github.com/PowerShell/PowerShell/blob/master/docs/dev-process/breaking-change-contract.md#bucket-3-unlikely-grey-area) change.\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-07-13T14:15:01Z",
      "updated_at": "2020-07-13T14:34:23Z"
    }
  ],
  "created_at": "2020-05-27T01:05:54Z",
  "number": 12805,
  "state": "open",
  "title": "Copy-Item with \"\\*\" fails if no subdirectory is present",
  "updated_at": "2021-11-29T17:19:35Z"
}