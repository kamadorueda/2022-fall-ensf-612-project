{
  "_url": "https://github.com/PowerShell/PowerShell/issues/5503",
  "author": "nightroman",
  "body": "I am not sure what but something is wrong:\r\n\r\n- If the documentation is correct then `Import-Module` imports to the wrong scope by default, global.\r\n    - Then this is a bug in `Import-Module`, probably tough to fix (breaking).\r\n- If the documentation is wrong and the default is global then:\r\n    - The documentation should be corrected.\r\n    - The switch `Global` is rather confusing in this case.\r\n\r\nSteps to reproduce\r\n------------------\r\n\r\n*MyModule.psm1*\r\n\r\n```powershell\r\nfunction MyFunc {\r\n    'MyFunc'\r\n}\r\nExport-ModuleMember -Function MyFunc\r\n```\r\n\r\n*test1.ps1*\r\n\r\n```powershell\r\nImport-Module \"$PSScriptRoot\\MyModule.psm1\" #-Scope Local\r\nMyFunc\r\n```\r\n\r\n*test2.ps1*\r\n\r\n```powershell\r\n& \"$PSScriptRoot\\test1.ps1\"\r\nMyFunc\r\n```\r\n\r\nExpected behavior\r\n-----------------\r\n\r\nIf the documentation is correct then I expect *test2.ps1* to fail with \"MyFunc\r\nis not found\" because *test1.ps1* imports the module to the default local\r\nscope.\r\n\r\nActual behavior\r\n---------------\r\n\r\n*test2.ps1* works and calls `MyFunc` successfully.\r\n\r\nGuess about actual behavior\r\n---------------------------\r\n\r\nIf we uncomment `-Scope Local` in *test1.ps1* then *test2.ps1* fails \"MyFunc\r\nis not found\". That means that the default scope is not local, as the help says.\r\n\r\nQuotes from help\r\n----------------\r\n\r\n    -Scope <String>\r\n        Specifies a scope into which this cmdlet imports the module.\r\n\r\n        The acceptable values for this parameter are:\r\n\r\n        - Global . Available to all commands in the session. Equivalent to the\r\n          Global parameter.\r\n        \r\n        - Local . Available only in the current scope.\r\n\r\n        By default, the module is imported into the current scope, which could be a\r\n        script or module.\r\n\r\n    -Global [<SwitchParameter>]\r\n        Indicates that this cmdlet imports modules into the global session state so\r\n        they are available to all commands in the session. By default, the commands\r\n        in a module, including commands from nested modules, are imported into the\r\n        caller's session state. To restrict the commands that a module exports, use\r\n        an Export-ModuleMember command in the script module.\r\n\r\n        The Global parameter is equivalent to the Scope parameter with a value of Global.\r\n\r\nEnvironment data\r\n----------------\r\n\r\nI observe this in v5 and v6-rc\r\n\r\n    Name                           Value\r\n    ----                           -----\r\n    PSVersion                      5.1.15063.674\r\n    PSEdition                      Desktop\r\n    PSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}\r\n    BuildVersion                   10.0.15063.674\r\n    CLRVersion                     4.0.30319.42000\r\n    WSManStackVersion              3.0\r\n    PSRemotingProtocolVersion      2.3\r\n    SerializationVersion           1.1.0.1\r\n\r\n    Name                           Value\r\n    ----                           -----\r\n    PSVersion                      6.0.0-rc\r\n    PSEdition                      Core\r\n    GitCommitId                    v6.0.0-rc\r\n    OS                             Microsoft Windows 10.0.15063\r\n    Platform                       Win32NT\r\n    PSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}\r\n    PSRemotingProtocolVersion      2.3\r\n    SerializationVersion           1.1.0.1\r\n    WSManStackVersion              3.0\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "nightroman",
      "author_association": "NONE",
      "body": "The issue was labeled `Issue-Question`. I have taken a look at other items in this category. I do not think this issue is a question. It does not ask anything. It describes the bug, either in the cmdlet or the documentation.\r\n",
      "created_at": "2017-11-20T10:17:30Z",
      "updated_at": "2017-11-20T10:17:30Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@nightroman we use that label until it has been confirmed as a bug by a knowledge area expert. ",
      "created_at": "2017-11-20T10:24:38Z",
      "updated_at": "2017-11-20T10:24:38Z"
    },
    {
      "author": "nightroman",
      "author_association": "NONE",
      "body": "Oh, I am sorry then, I did not know. Other issues in that category looked like true questions, that's why I worried.",
      "created_at": "2017-11-20T10:28:13Z",
      "updated_at": "2017-11-20T10:28:13Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Good analysis, @nightroman - I took the liberty of creating a docs issue (that links) here: https://github.com/PowerShell/PowerShell-Docs/issues/2691, as it is safe to assume that the global-by-default behavior won't change and that it is therefore the docs that should be corrected.\r\n\r\nAside from fixing the docs, the implications for the code base are:\r\n\r\n* Since `-Global` serves no useful purpose, as you state, do we have a way of _deprecating_ parameters, e.g. by hiding them from tab completion?\r\n\r\n* Is it worth introducing a `-Local` switch instead? It may be overkill, given that current-scope-only imports are probably not that common (just a guess).\r\n\r\n\r\n\r\n",
      "created_at": "2018-07-15T19:16:59Z",
      "updated_at": "2018-07-15T19:16:59Z"
    },
    {
      "author": "sethvs",
      "author_association": "CONTRIBUTOR",
      "body": "@nightroman @mklement0 \r\nI can't repro the condition, when you use -Scope Local from the script.\r\nWhat I see, is that when you use `Import-Module` cmdlet from script or scriptblock, it always imports into the **global** scope.\r\n\r\n**TheModule.psm1**\r\n```\r\nfunction TheFunction\r\n{\r\n    Write-Output -InputObject 'I am TheFunction.'\r\n}\r\n```\r\n```\r\nRemove-Module TheModule -Force\r\n& {Import-Module .\\TheModule.psm1}\r\nGet-Module TheModule\r\n\r\nModuleType Version Name      ExportedCommands\r\n---------- ------- ----      ----------------\r\nScript     0.0     TheModule TheFunction\r\n```\r\n```\r\nRemove-Module TheModule -Force\r\n& {Import-Module .\\TheModule.psm1 -Scope Global}\r\nGet-Module TheModule\r\n\r\nModuleType Version Name      ExportedCommands\r\n---------- ------- ----      ----------------\r\nScript     0.0     TheModule TheFunction\r\n```\r\n```\r\nRemove-Module TheModule -Force\r\n& {Import-Module .\\TheModule.psm1 -Scope Local}\r\nGet-Module TheModule\r\n\r\nModuleType Version Name      ExportedCommands\r\n---------- ------- ----      ----------------\r\nScript     0.0     TheModule TheFunction\r\n```\r\n\r\nThe same is for script files:\r\n**import_default.ps1**\r\n```\r\nImport-Module $PSScriptRoot\\TheModule.psm1\r\n```\r\n\r\n**import_global.ps1**\r\n```\r\nImport-Module $PSScriptRoot\\TheModule.psm1 -Scope Global\r\n```\r\n\r\n**import_local.ps1**\r\n```\r\nImport-Module $PSScriptRoot\\TheModule.psm1 -Scope Local\r\n```\r\n\r\n```\r\nRemove-Module TheModule -Force\r\n.\\import_default.ps1\r\nGet-Module TheModule\r\n\r\nModuleType Version Name      ExportedCommands\r\n---------- ------- ----      ----------------\r\nScript     0.0     TheModule TheFunction\r\n```\r\n\r\n```\r\nRemove-Module TheModule -Force\r\n.\\import_global.ps1\r\nGet-Module TheModule\r\n\r\nModuleType Version Name      ExportedCommands\r\n---------- ------- ----      ----------------\r\nScript     0.0     TheModule TheFunction\r\n```\r\n\r\n```\r\nRemove-Module TheModule -Force\r\n.\\import_local.ps1\r\nGet-Module TheModule\r\n\r\nModuleType Version Name      ExportedCommands\r\n---------- ------- ----      ----------------\r\nScript     0.0     TheModule TheFunction\r\n```\r\n\r\nBut when you use the `Import-Module` cmdlet from **another module**, then by default it imports into the **module scope**.\r\n\r\n**import_default_Module.psm1**\r\n```\r\nImport-Module $PSScriptRoot\\TheModule.psm1\r\n\r\nfunction Get-TheModule\r\n{\r\n    Get-Module TheModule\r\n}\r\n\r\nExport-ModuleMember -Function Get-TheModule\r\n```\r\n**Import_global_Module.psm1**\r\n```\r\nImport-Module $PSScriptRoot\\TheModule -Scope Global\r\n\r\nfunction Get-TheModule\r\n{\r\n    Get-Module TheModule\r\n}\r\n\r\nExport-ModuleMember -Function Get-TheModule\r\n```\r\n\r\n**Import_local_Module.psm1**\r\n```\r\nImport-Module $PSScriptRoot\\TheModule -Scope Local\r\n\r\nfunction Get-TheModule\r\n{\r\n    Get-Module TheModule\r\n}\r\n\r\nExport-ModuleMember -Function Get-TheModule\r\n```\r\n```\r\nRemove-Module TheModule -Force\r\nImport-Module .\\import_default_Module.psm1\r\nGet-TheModule\r\n\r\nModuleType Version Name      ExportedCommands\r\n---------- ------- ----      ----------------\r\nScript     0.0     TheModule TheFunction\r\n\r\nGet-Module TheModule\r\n# nothing returned\r\n\r\nRemove-Module import_default_Module -Force\r\n```\r\n\r\n```\r\nImport-Module .\\Import_global_Module.psm1\r\nGet-TheModule\r\n\r\nModuleType Version Name      ExportedCommands\r\n---------- ------- ----      ----------------\r\nScript     0.0     TheModule TheFunction\r\n\r\nGet-Module TheModule\r\n\r\nModuleType Version Name      ExportedCommands\r\n---------- ------- ----      ----------------\r\nScript     0.0     TheModule TheFunction\r\n\r\nRemove-Module Import_global_Module -Force\r\nRemove-Module TheModule -Force\r\n```\r\n\r\n```\r\nImport-Module .\\Import_local_Module.psm1\r\nGet-TheModule\r\n\r\nModuleType Version Name      ExportedCommands\r\n---------- ------- ----      ----------------\r\nScript     0.0     TheModule TheFunction\r\n\r\nGet-Module TheModule\r\n# nothing returned\r\n\r\nRemove-Module Import_local_Module\r\n```\r\n\r\nSo, I believe, the `-Scope` and `-Global` parameters has meaning only when you use `Import-Module` cmdlet from another module.\r\n\r\nVersion:\r\n```\r\nName                           Value\r\n----                           -----\r\nPSVersion                      6.1.0-preview.748\r\nPSEdition                      Core\r\nGitCommitId                    6.1.0-preview.748\r\nOS                             Microsoft Windows 10.0.17134\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```",
      "created_at": "2018-07-20T09:53:32Z",
      "updated_at": "2018-07-20T09:53:32Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@sethvs: Thanks for digging deeper:\r\n\r\n**Re script behavior:**\r\n\r\nYou must distinguish between _a module's visibility to `Get-Module`_ and the _availability (importing) of its exported members_.\r\n\r\nA `-Scope Local`-imported module in a child scope still shows up in an ancestral scope's `Get-Module` output, but its exported members aren't _callable_ there, because they weren't _imported_.\r\n\r\nWhile it may seem curious that the module shows up in `Get-Module`'s output, the import still is _local_ in the sense that no ancestral scopes can _use_ the module, because it doesn't get _imported_.\r\n\r\nThus, the real test for the locality of an import is to try to _invoke an exported member_ from another scope.\r\n\r\nA quick example:\r\n\r\n```powershell\r\nPS> & { 'function f1{\"[f1]\"}'>t1.psm1; ipmo -Scope Local ./t1.psm1; f1 }; f1; gmo t1\r\n[f1] # ok: callable from the local scope\r\nf1 : The term 'f1' is not recognized as the name of a cmdlet, function, script file, or operable program.\r\n...\r\n\r\nModuleType Version    Name                                ExportedCommands\r\n---------- -------    ----                                ----------------\r\nScript     0.0        t1                                  f1\r\n\r\n```\r\n\r\nAs you can see, the calling scope doesn't see the exported `f1` _function_ (because it was imported with `-Scope Local` into the _child_ scope only), but `Get-Module` does see the `t1` _module_.\r\n\r\n**Re nested-modules behavior:**\r\n\r\nGood catch: When a module imports another module, `Import-Module` effectively defaults to `-Scope Local`, and the same applies to modules loaded implicitly via the `NestedModuleKeys` in a module's manifest (`*.psd1`).\r\n\r\nNote that it's generally better to import nested modules via a _manifest_, and that you then _invariably_ get the local behavior.\r\n\r\nSeparately, though, you're free to _export_ the nested module's locally imported exported members _as part of the parent module_ - simply by referencing them in `Export-ModuleMember` calls or, preferably, via the `FunctionsToExport`, `AliasesToExport`, and `VariablesToExport` keys in a module manifest.\r\n(A minor pitfall is that if your parent module relies on the default export behavior - where _all_ functions and aliases are exported - the functions and aliases among the _nested_ module's exported members are automatically _included_ - however, a module generally shouldn't rely on implicit export behavior.)\r\n\r\n---\r\n\r\nThat leaves just one case in which `-Global` / `-Scope Global` actually makes a _difference_, though its usefulness is questionable:\r\n\r\nIf a _module_ uses an explicit `Import-Module -Global`call to import another module, that other module indeed becomes globally available.  \r\nHowever, unless I'm missing something, a module should never import another module globally behind the user's back.\r\n\r\n---\r\n\r\nSo, in summary:\r\n\r\n* From a _non-module_ scope, `Import-Module`:\r\n    * is global by default\r\n    * can be made local with `-Scope Local`\r\n\r\n* From a _module_ scope, `Import-Module`:\r\n   * is local by default (it's up to the parent module what, if anything, to _export_)\r\n   * can, but _shouldn't_ be made global with `-Global` / `Scope -Global`\r\n   * Generally, it's worth _discouraging explicit use of `Import-Module` in modules_ in favor of declaring nested modules via a _manifest_.\r\n\r\n---\r\n\r\nGiven that we've arrived at these findings by trial and error, perhaps a subject-matter could review the findings. @SteveL-MSFT, would you mind looking at this, assigning someone?\r\n\r\nI haven't looked at the PR that was just submitted, but I strongly suspect it needs revising now;\r\ncc @sdwheeler \r\n",
      "created_at": "2018-07-20T17:48:20Z",
      "updated_at": "2018-07-20T17:52:26Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@BrucePay can you confirm @mklement0's explanation matches design intent?",
      "created_at": "2018-07-21T14:53:36Z",
      "updated_at": "2018-07-21T14:53:36Z"
    },
    {
      "author": "sethvs",
      "author_association": "CONTRIBUTOR",
      "body": "@mklement0 \r\n**about script behavior.**\r\nInteresting finding.\r\nWhat is `Import-Module` cmdlet is doing: is **importing** some module and **exporting** it's content (functions, aliases, etc.) into the scope.\r\n\r\nConcerning calling `Import-Module -Scope Local` from inside the script, is imports a module into **global** scope, and it's content - in the **script** scope. It looks more like a bug, then the lack of documentation.\r\n\r\nJoining the request to @BrucePay :)",
      "created_at": "2018-07-23T07:38:55Z",
      "updated_at": "2018-07-23T07:45:56Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@sethvs \r\n\r\n> What `Import-Module` cmdlet is doing: is importing some module and exporting it's content (functions, aliases, etc.) into the scope.\r\n\r\nI would phrase that differently:\r\n\r\n* `Import-Module` is _loading_ a module (on demand),\r\n* and then _importing_ the module's _exported members_ (there's never any exporting _to_ - its always an act of _importing_ on the part of the code that wants to use module's exported members)\r\n\r\nIt is only the _importing_ that can be scoped, and arguably that is all that matters.\r\n\r\nNote that the current documentation and terminology conflate the aspects of _loading_ and _importing_ - notably in the term _auto-loading_ - which it arguably shouldn't:\r\n\r\nWhile you can't _only_ load  a module, you can prevent its getting _imported_ into _other scopes_ by using `-Scope Local`.\r\n\r\n`Get-Module` sees that the module is _loaded_ globally - which happens irrespective of the specifics of the `Import-Module` call - but that is not a problem in practice (and irrelevant from the perspective of scope-limiting _importing_ it).\r\n\r\nIt may be awkward that a given scope may see the fact that a module is _loaded_ while not having access to its exports (not having imported them), if the `Import-Module` call was performed in a different scope with `-Scope Local`, but I don't see a _bug_ there.\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2018-07-23T14:38:24Z",
      "updated_at": "2018-07-23T14:38:24Z"
    },
    {
      "author": "sethvs",
      "author_association": "CONTRIBUTOR",
      "body": "@mklement0 \r\nIt's not just awkward - it is inconsistent when some part of the functionality takes place in the global scope, and some - in local.\r\n\r\nI'm OK with different defaults, when using cmdlet from script or scriptblock  and from inside the module - *Global* and *Local*, respectively.\r\nBut when you use `Import-Module -Scope Local` it should not mean `please load the module globally, and import it's content locally`, I believe.",
      "created_at": "2018-07-23T14:56:26Z",
      "updated_at": "2018-07-23T14:56:26Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@sethvs:\r\n\r\n~~You're right~~: it's an inconsistency if you expect `Get-Module` to list _imported_ modules (by default) - and that's ~~certainly what its help topic claims~~ [update: it's only an inconsistency if you assume imported into the _current scope_, which the topic does _not_ claim - see below].\r\n\r\nCurrently, it is reporting _loaded_ modules whose exports may or may not be available in the _current_ scope.\r\n\r\n> it should `not mean please load the module globally, and import it's content locally`\r\n\r\nTo be clear: what I'm suggesting is that this is more likely a `Get-Module` issue, not an `Import-Module` issue.\r\n\r\nIn a way it's pointless to call a module \"globally loaded\", because that state of being _loaded_ has no direct relationship with _scopes_.\r\n\r\nClearly, `Get-Module` knows about all _loaded_ modules (with a module getting implicitly loaded either via auto-loading or via an `Import-Module` call in _any_ scope) and has access to them independently of scopes.\r\n\r\nSimilarly, `Remove-Module` has access to all _loaded_ modules, and therefore allows removal (\"unimporting\" _and_ unloading) even of modules that were locally imported into a different scope.\r\n(There may be additional inconsistencies / bugs lurking: calling `Remove-Module` on a module that was imported with `-Scope Local` from the same scope truly seems to only \"unimport\" from that scope, while the same module loaded into the global scope continues to work - yet `Get-Module` doesn't show it any longer.)\r\n\r\nClearly, this fuzziness around loaded vs. imported is problematic:\r\n\r\n* If we modified `Get-Module` and `Remove-Module` to only show / allow removal of modules that are either _imported into the current scope_  or _globally imported_, we'd have a breaking change on our hands.\r\n\r\n* Conversely, with the status quo, there's no way to relate `Get-Module` and `Remove-Module` to the current scope. That is, `Get-Module`'s output doesn't let you determine whether a given module's exports are _available_ in the current scope, - only whether the module is _loaded_.  \r\nThis could be problematic if, say, you use `Get-Module Foo` in your code to indirectly test the availability of `Foo`'s _commands_ in the current scope: if the module is loaded, but only because it was imported _locally_ into a _different_ scope, the test will not work as expected (testing for a specific _command_ with `Get-Command` would work, however).\r\n\r\nArguably, _both_ perspectives are valuable: knowing which modules are _loaded_ vs. which ones are _available in the current scope_ (imported locally into the current scope or globally imported).\r\n\r\nLet's hear what Bruce has to say.\r\n\r\n",
      "created_at": "2018-07-23T19:02:27Z",
      "updated_at": "2018-07-24T18:43:33Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "Technically, there are two things that you need to keep in mind when trying to figure out modules: scope and session state. By default, modules are loaded into the top-level of the current **_session state_** not the current _scope_. If you are in the global scope (i.e. not in a module) then they get loaded into the global session state and any exports are placed into the global tables. If you load a module from _within_ a module, things are loaded into the _module's_ session state, not the global session state and any exports are placed at the top of the module's session state. If you use `-Scope local`, then the exports are placed into the current scope object rather than at the top level. If you are _in a module_ and use `-Scope global` (or `-Global`) to load another module, that module and it's exports will be loaded into the global session state object instead of the module's local session state. This feature was designed for writing module that manipulate modules (and is used by the WindowsCompatibility module to import proxy modules into the global scope.) Looking at the documentation snippet out of context\r\n\r\n>    By default, the module is imported into the current scope, which could be a\r\n    script or module.\r\n\r\nit does appear to be incorrect and should probably say \"By default. the module is imported into the current session state, which could be a module session state or the global session state.\"",
      "created_at": "2018-07-23T21:09:21Z",
      "updated_at": "2018-07-23T21:09:21Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @BrucePay - good to learn about the role of session states in this context.\r\n\r\nHowever, given that _session state_ is not a well-known concept (and given that the only session-related conceptual topics, `about_PSSession` and`about_PSSession_Details` are of little help and focus on sessions in the context of _remoting_; as an aside: they deserve a fundamental overhaul), I fear that:\r\n\r\n> By default. the module is imported into the current session state, which could be a module session state or the global session state\r\n\r\nwill not be helpful to the average user, not least because the parameters that modify the behavior relate to _scopes_.\r\n\r\nI think what may make sense to the average user is the following:\r\n\r\n* _Outside_ of a module: `Import-Module` imports modules _globally_ by default:\r\n\r\n    * That is, the top-level scope and all its descendant scopes (and even loaded modules) have access to the module's exported elements - even if `Import-Module` was called from a _descendant_ scope.\r\n\r\n    *  In a descendant scope, `-Scope Local` can be used to limit importing to that scope and all its descendant scopes. (Therefore, using `-Scope Local` in the top-level scope would make no difference). That is, parent scopes then do _not_ see the imported members.\r\n\r\n   * Since session-global import is the default behavior, use of `-Global` / `-Scope Global` is pointless outside of a module.\r\n\r\n   * If importing a module should include its `class` and `enum` definitions as well, use `using module`  instead of `Import-Module`, and place it at the very beginning of your script \r\n\r\n* _Inside_ of a module: `Import-Module` imports another module _into that module only_ by default - non-module code and other modules don't see it (again, using `-Scope Local` in the top-level scope of the module would make no difference).\r\n  \r\n  *  A better alternative to calling `Import-Module` from a module is to declare the target module as a _nested_ module via the module's own _manifest_ - this helps with discovering dependencies. \r\n\r\n      * However, there may still be cases where explicit `Import-Module` calls are appropriate, such as when a dependent module cannot be assumed to always be there.\r\n \r\n  * Either way, you may in turn export (public) members of the  imported module by including them in the parent module's own exports.\r\n\r\n  * Use `-Global` / `-Scope Global`, which makes the module available session-globally (to non-module code and to other modules), only in exceptional cases, given that modules should generally avoid session-global modifications on import.\r\n\r\n     * However, a legitimate use case is to write modules expressly designed  to manipulate modules loaded session-globally, such as the [`WindowsCompatibility` module](https://www.powershellgallery.com/packages/WindowsCompatibility/).\r\n\r\n---\r\n\r\nThe above covers `Import-Module` only. Does that make sense and is it accurate enough?\r\n\r\n",
      "created_at": "2018-07-24T00:15:38Z",
      "updated_at": "2018-08-01T17:21:38Z"
    },
    {
      "author": "sethvs",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for explanation, @BrucePay. Suspected something like this after looking through the code.",
      "created_at": "2018-07-24T07:14:10Z",
      "updated_at": "2018-07-24T07:14:10Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "After thinking further about @BrucePay's explanation, I've revised the overview in my previous comment to (hopefully) present a pragmatic summary:\r\n\r\n* with a view to _practical implications_ of the behaviors.\r\n* with some _guidance_ as to when to use which features / parameters.\r\n\r\nWhile as such it doesn't fit into the `Import-Module` help topic, I hope it provides a useful _basis_ for revising it.\r\n\r\n---\r\n\r\nI'll address the `Get-Module` / `-Scope Local` discrepancy separately, below.",
      "created_at": "2018-07-24T17:27:03Z",
      "updated_at": "2018-07-24T17:27:03Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Re the `Get-Module` / `-Scope Local` discrepancy (`Get-Module` potentially seeing a module even if it wasn't imported into the current scope):\r\n\r\nIn short: Unlike what I thought earlier, the help topics do _not_ support the expectation that `Get-Module` see only modules imported into the _current scope_, so a small amendment to the existing `Get-Module` help topic is probably sufficient (see below).  \r\nIn other words, @sethvs: I don't think there was a problem to begin with, it was just a matter of framing things correctly, after all, though the amendment proposed below may help.\r\n\r\n**Some background on loading vs. importing** (do tell me if I didn't get this right):\r\n\r\n_Loading_ a module - into the enclosing session state - happens _implicitly_ the first time a module is imported (whether implicitly or explicitly), and subsequent imports of the same module reuse the already loaded module.\r\n\r\nWith the default  behavior, loading the module entails making its exported members available to _all_ scopes of the session state (via inheritance from the top scope),  so that all scopes both see the module with `Get-Module` _and_ see the imported members (though you can _restrict_ what members to import with the `-Function`, `-Alias`, and `-Variable` parameters).\r\n\r\nThe discrepancy can only arise with `-Scope Local`: ancestral scopes in the same session state then do _not_ see the _imported members_; however, they do see _the module itself_ in the `Get-Module` output, because **`Get-Module` (by default) lists modules solely based on whether they're _loaded_ or, to put it differently, were imported into _any_ scope** in the current session state, not whether or not their exported members happen to be imported into the current _scope_.\r\n\r\nSimilarly, `Remove-Module` cmdlet also targets _loaded_ modules and therefore too sees modules even in scopes in the same session state that happen not to have _imported the module's exports_. \r\n(Perhaps needless to say, `Remove-Module` unloads the module _and_ removes its import.)\r\n\r\n---\r\n\r\n**As for possible tweaks to the `Get-Module` topic:**\r\n\r\nBoth the `Get-Module` and the `Remove-Module` help topics already mention the _current session_ as the entity whose imported modules are shown / whose imported modules are removed.\r\n(The term _session_, unfortunately, is a bit nebulous - I'll address that separately).\r\n\r\nThus, arguably no promise is made that such a module must have been imported into the _current scope_ in order to be targeted, and no change is needed.\r\n\r\nHowever, it may be worth adding a note to the `NOTES` section that explains that even though a given _scope_ may not have imported a given module's exports, a call to `Get-Module` will still show that module, as long as it was imported into _any_ scope in the same session.\r\n",
      "created_at": "2018-07-24T18:52:20Z",
      "updated_at": "2018-07-24T18:54:46Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "~~As for what appears to be an actual _bug_ with `-Scope Local` that I've alluded to earlier: see #7349~~",
      "created_at": "2018-07-24T19:45:40Z",
      "updated_at": "2019-05-12T18:32:02Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I've created a new issue, #9582, which obsoletes #7349 and more generally, discusses the problems with invariably global module caching / removal vs. local importing.\r\n\r\nRe the need to document the concepts of internal session states and to give them more descriptive official names, I've opened https://github.com/MicrosoftDocs/PowerShell-Docs/issues/4288",
      "created_at": "2019-05-12T18:35:03Z",
      "updated_at": "2019-05-12T18:35:03Z"
    }
  ],
  "created_at": "2017-11-19T12:22:48Z",
  "labels": [
    "Issue-Question"
  ],
  "number": 5503,
  "state": "open",
  "title": "Import-Module: incorrect scope, confusing parameters, wrong documentation?",
  "updated_at": "2019-05-12T18:35:03Z"
}