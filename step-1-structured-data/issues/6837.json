{
  "_url": "https://github.com/PowerShell/PowerShell/issues/6837",
  "author": "mklement0",
  "body": "Being able to pass script blocks ad hoc in order to calculate per-input-object parameter values is a [great general-purpose feature](https://github.com/PowerShell/PowerShell-Docs/issues/2338).\r\n\r\nHowever, it is currently _limited to parameters that are explicitly defined as pipeline-binding_.\r\n\r\nA widely used application of this technique is with `Rename-Item`'s `-NewName` parameter, where a script block is passed to calculate the new name; e.g.:\r\n\r\n```powershell\r\n# Rename all *.rtf files to *.txt files\r\nGet-Item *.rtf | Rename-Item -NewName {  $_.BaseName + '.txt' } -WhatIf\r\n```\r\n\r\nHowever, the above _only_ works because `-NewName` too is defined as pipeline-binding (`ValueFromPipelineByPropertyName`, in this case).\r\n\r\nThe ability to pass a script block to _any_ parameter (other than those typed `[object]` or `[scriptblock]`) of a command that accepts pipeline input in principle - whether or not that parameter is itself pipeline-binding - would make this technique useful in a much wider array of situations.\r\n\r\nIs there a conceptual barrier to removing this restriction (overall, the cmdlet/advanced function would still have to have at least _one_ pipeline-binding parameter)?\r\n\r\nTechnically, this would be a breaking change, albeit hopefully one that falls into [Bucket 3: Unlikely Grey Area](https://github.com/PowerShell/PowerShell/blob/master/docs/dev-process/breaking-change-contract.md#bucket-3-unlikely-grey-area):\r\n\r\nWhat happens currently if you try to pass a script block to a differently typed non-pipeline-binding parameters is that an attempt is made to convert the script block to the parameter's type (unless the parameter is `[object]` or `[scriptblock]`, which would continue to be exempt). \r\nThis fails with most types, but in the case of a `[string]` parameter you currently do get the script block's _contents_ as a string value.  \r\nArguably, though, users who expect script blocks type their parameters a such.\r\n\r\n\r\n\r\n------------------\r\n\r\nHere's an example with an advanced function:\r\n\r\n```powershell\r\nfunction Rename-Foo {\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory, ValueFromPipeline)]\r\n        [System.IO.FileSystemInfo] $InputObject\r\n        ,\r\n        # WISHFUL THINKING: The `ValueFromPipelineByPropertyName` shouldn't be necessary.\r\n        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]\r\n        [string] $NewName\r\n    )\r\n\r\n    process {\r\n        \"Will rename $($InputObject.Name) to $NewName.\"\r\n    }\r\n\r\n}\r\n\r\nPS> Get-Item foo.txt, bar.txt | Rename-Foo -NewName { $_.Name + '!!' }\r\nWill rename foo.txt to foo.txt!!\r\nWill rename bar.txt to bar.txt!!\r\n```\r\n\r\n\r\nEnvironment data\r\n----------------\r\n\r\nWritten as of:\r\n\r\n```powershell\r\nPowerShell Core v6.0.2\r\n```\r\n",
  "closed_at": "2018-05-14T19:21:31Z",
  "comments": [
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 I'm not sure I understand what the benefit of this is other than being able skip the attribute.",
      "created_at": "2018-05-08T17:27:57Z",
      "updated_at": "2018-05-08T17:27:57Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@BrucePay:\r\n\r\nThe benefit is that you could pass a script block to _any_ parameter of a pipeline-supporting-in-principle command _without that parameter having to be designed to be pipeline-binding itself_.\r\n\r\nIn other words:\r\n\r\n* _Existing_ commands would benefit by users now being able to pass script blocks to parameters that previously didn't support them (due to not being declared as pipeline-binding).\r\n\r\n* Authors of _future_ commands would be relieved of the need to remember to make specific parameters pipeline-binding just so they support script-block arguments.  \r\nUnless I'm missing something, the current requirement to do so seems conceptually unnecessary.\r\n\r\n",
      "created_at": "2018-05-08T17:45:52Z",
      "updated_at": "2018-05-08T17:45:52Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "> without that parameter having to be designed to be pipeline-binding itself.\r\n\r\nIf the command designer didn't design the command in such a way that it makes sense for the parameter to come from the pipeline, why do you think that making it pipelineable anyway will work? \r\n\r\n>  relieved of the need to remember to make specific parameters pipeline-binding  just so they support script-block arguments.\r\n\r\nThey still have to indicate which parameters can be bound from the pipeline.\r\n",
      "created_at": "2018-05-08T21:51:52Z",
      "updated_at": "2018-05-08T21:51:52Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@BrucePay:\r\n\r\nLet's ask the opposite question:\r\n\r\nIn the `Rename-Item` example above - arguably the most widely used application of the pattern - what need is there for  the `-NewName` parameter _specifically_ to be pipeline-binding - \r\nas opposed to the `-LiteralPath` parameter binding to `Get-Item` / `Get-ChildItem` input?\r\n\r\nHow common is it for objects with a `.NewName` property to be piped to `Rename-Item` in order to bind to the `-NewName` parameter from the pipeline?\r\nAnd isn't this unrelated to the usefulness of binding `-NewName` as demonstrated?\r\n\r\nThe only thing that the `Get-Item *.rtf | Rename-Item -NewName {  $_.BaseName + '.txt' }` idiom relies on is input objects binding to `-LiteralPath` - and, as stated, a command being pipeline-binding _in principle_ (with at least _one_ parameter) must sensibly remain a prerequisite for the feature at hand.\r\n\r\nIn summary:\r\n\r\n> If the command designer didn't design the command in such a way\r\n\r\nProviding an ad hoc, flexible mechanism of general usefulness that command designers  _do not have to anticipate_ is the very purpose of this feature.",
      "created_at": "2018-05-08T22:08:04Z",
      "updated_at": "2018-05-08T22:08:04Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "@mklement0 - I'd like to see other examples where it makes sense.\r\n\r\nToday, we can reason about commands and how they are composed based on the attributes, e.g. we could detect a pipeline that doesn't make sense because a downstream command has no parameters that accept pipeline input.\r\n\r\nWith your proposed change, **every** command could be valid as a downstream command in the pipeline even though the command author did not anticipate that usage, likely implementing the command in the end block.",
      "created_at": "2018-05-09T00:28:24Z",
      "updated_at": "2018-05-09T00:28:24Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@lzybkr:\r\n\r\n> With your proposed change, every command could be valid as a downstream command in the pipeline \r\n\r\nHere's what I've said before (emphasis added):\r\n\r\n> The ability to pass a script block to any parameter (other than those typed [object] or [scriptblock]) **of a command that accepts pipeline input in principle**\r\n\r\n>  as stated, **a command being pipeline-binding in principle (with at least one parameter) must sensibly remain a prerequisite** for the feature at hand.\r\n\r\nPerhaps let me add:\r\n\r\nMost cmdlets have only _one_ parameter that is the obvious candidate for pipeline binding. Even though _technically_ others may be pipeline-binding too, in most cases there's an obvious choice and that's what's used in the vast majority of cases.\r\n\r\nIn the `Rename-Item` example, `-LiteralPath` is that obvious candidate - even though _technically_ `-Credential`, `-Path` and `-NewName` _also_  accept pipeline input, though likely unbeknownst to many.\r\n\r\nIn the case of `-NewName` - even though I've never seen anyone bind that parameter _directly_ with pipeline input - that's a blessing, because it is _currently_ the prerequisite for being able to pass a script block to it, which enables the widely used idiom - but it is that very prerequisite I would like to get rid of.\r\n\r\nThe script-block parameter technique  _complements_ the obvious pipeline-binding parameter by allowing _other_ parameters to _derive their value from the input object at hand_, in an ad hoc fashion that doesn't and shouldn't require anticipation by the command author.\r\n\r\n",
      "created_at": "2018-05-09T02:09:42Z",
      "updated_at": "2018-05-09T02:09:42Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "@mklement0 - if a command does not operate on pipeline input correctly, why would the engine pretend to support it?\r\n\r\nWith an attribute, the command tells PowerShell that, in theory, it has properly implemented pipeline semantics.\r\n\r\nWithout the attribute, all bets are off. I can think of multiple ways that a user would be surprised that PowerShell allowed the syntax, but the command didn't produce reasonable results.\r\n\r\nAt any rate, I was asking for *concrete* examples, not design principles. I see enough downsides and no upsides without additional concrete examples.",
      "created_at": "2018-05-09T04:26:40Z",
      "updated_at": "2018-05-09T04:27:00Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@lzybkr: \r\n\r\nThe reason I was talking about design principles is that I feel my intent is still not understood.\r\n\r\nCase in point:\r\n\r\n> if a command does not operate on pipeline input correctly, why would the engine pretend to support it?\r\n\r\nGiven that the purpose of my previous comment was to clarify that I always wanted the feature to be restricted to commands that _do_ properly implement pipeline support (with at least _one_ parameter, with the _other_ parameters that are _themselves_ not pipeline-binding potentially benefitting from the feature), what do you mean by _does not operate on pipeline input correctly_?\r\n\r\n---\r\n\r\nOn a meta note:\r\n\r\nI'm getting a sense of [d\u00e9j\u00e0 vu](https://github.com/PowerShell/PowerShell/issues/2226#issuecomment-386275201) here: Significant effort is spent on debating points that were neither intended nor made, so let me ask again:\r\n\r\nWere there specific ways in which I presented my arguments that obscured their intent?\r\n\r\nThis is not a rhetorical, woe-is-me question. If there's a way I can generally get my points across more clearly, please tell me.\r\n\r\n---\r\n\r\nProceeding on the assumption that we now _are_ talking about the same thing, I will try to come up with examples in a separate comment.\r\n\r\n\r\n> I can think of multiple ways that a user would be surprised that PowerShell allowed the syntax, but the command didn't produce reasonable results.\r\n\r\nPerhaps you can come up with examples too.\r\n",
      "created_at": "2018-05-09T13:48:30Z",
      "updated_at": "2018-05-09T13:48:30Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "An example with historical context:\r\n\r\nLet me quote @jpsnover  from [a 2006 blog post](https://blogs.msdn.microsoft.com/powershell/2006/06/23/flexible-pipelining-with-scriptblock-parameters/); emphasis added:\r\n\r\n> The cmdlet developer decides which parameters can be pipelined and whether they can be pipelined by value or by propertyname.  They do this based upon their view of the common scenarios and the benefit/risks of this binding.  Imagine the incomprehensibility and potential disasters that would arise if all parameters accepted pipeline input!  The point is that as a Cmdlet developer, caution is your friend.\r\n\r\n> **But here is the point: Cmdlet developers don\u2019t know everything and even if they did, there is not always a clear consensus of what should be pipelinable**.  Case in point: take a look at the parameters for Get-WMIObject \u2013 none of its parameters can take input from the pipeline.\r\n\r\n> PSMDTAG:**PHILOSOPHY: Cmdlets should only allow pipelining of parameters that are safe to pipeline, the engine can allow the user to override that via ScriptBlock parameters.**\r\n\r\n> ScriptBlock parameters provide you as simple, **powerful mechanism to get pipelining of parameters where the cmdlet author has not already provided this for you**.\r\n\r\nThe post then discusses wanting to pass the computer-name and WMI-class values from a 2-column CSV elegantly to `Get-WmiObject`, a cmdlet that - somewhat ironically - has _no_ pipeline-binding parameters.\r\n\r\n(I'm puzzled by the blog post being written as if the feature already worked; it certainly doesn't now (with non-pipeline-binding parameters). Has it ever?)\r\n\r\nBut for the sake of example let's assume that, say, `-ComputerName` _is_  pipeline-binding, whereas `-Class` is not.\r\n\r\nSo, instead of a `ForEach-Object`-based approach:\r\n\r\n```powershell\r\nImport-Csv computers.csv | ForeEach-Object { \r\n    Get-WmiObject -computerName $_.ComputerName -Class $_.Class  \r\n  }\r\n```\r\n\r\nyou could write:\r\n\r\n```powershell\r\nImport-Csv computers.csv | Get-WmiObject -computerName { $_.ComputerName } -Class { $_.Class }\r\n```\r\n\r\nSo, even though `-Class` is not pipeline-binding itself (and is of type `[string]`), it was able to take its value from the current pipeline object in each iteration via a _script block_.\r\nNot only is this more concise and elegant, it also avoids multiple invocations of `Get-WmiObject`.\r\n\r\n---\r\n\r\nI'll think about more examples, but the point is that the feature at hand is precisely helpful in _unusual_ scenarios, and that it enables flexible _ad hoc_ use that the cmdlet author didn't have to anticipate (except for the cmdlet being pipeline-binding _in principle_).",
      "created_at": "2018-05-09T15:45:55Z",
      "updated_at": "2018-05-09T15:49:28Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "Requiring at least one pipeline parameter alleviates one of my concerns, but not all.\r\n\r\nA cmdlet may do something once for a parameter when it doesn't expect the value to change during pipeline processing. Requiring an attribute is one way of at least declaring that the cmdlet does not do so for that parameter.\r\n\r\nTo handle that situation correctly, I suppose the engine could rewrite the command invocation to do the equivalent of using `ForEach-Object`, but I don't think it's worth it - performance wouldn't be as good and it seems to be difficult to find examples where folks have forgotten the attribute.",
      "created_at": "2018-05-09T17:28:48Z",
      "updated_at": "2018-05-09T17:28:48Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "@mklement0  Actually, the `Get-WmiObject` command is the perfect case for why this not a good idea. Your example wouldn't work because the cmdlet does everything in `BeginProcessing`. Binding parameters from the pipeline would be useless, confusing and a waste of time. As @lzybkr says, simply binding parameters from the pipeline is not sufficient to make the command pipelineable. In other cases like `Sort-Object -Descending` it makes absolutely no sense to bind the parameter from the pipeline. Likewise with `Measure-Object -Sum` or `-Average`, etc.",
      "created_at": "2018-05-09T17:36:09Z",
      "updated_at": "2018-05-09T17:36:09Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@BrucePay:\r\n\r\n> Actually, the Get-WmiObject command is the perfect case for why this not a good idea. \r\n\r\nYes, the `Get-WmiObject` example was hypothetical, given that it doesn't support the pipeline _at all_ (as mentioned).\r\n\r\nAmong the pipeline-supporting cmdlets, however, even being an _aggregating_ cmdlet does _not_ preclude per-input-object processing:\r\n\r\nWhile `Sort-Object` is _aggregating_, it still performs per-input-object processing, and passing a per-input-object script-block argument to `-Property` is one of its salient features; e.g.:\r\n\r\n```powershell\r\n# Sort by only the numerical part of the input, via a script-block parameter argument.\r\nPS> 'z1', 'a0', 'b10' | Sort-Object -Property { [int] $_.Substring(1) }\r\na0\r\nz1\r\nb10\r\n```\r\n\r\n<sup>By _aggregating_ I mean cmdlets that either output only aggregate values (e.g., `Measure-Object`) or ones that must collect all input objects first before being able to operate on them (e.g., `Sort-Object`)</sup>\r\n\r\n\r\nAdditionally, it's worth mentioning that `Sort-Object`'s use is a _custom_ implementation of the pattern, via conditional interpretation of the specific type passed to the `[object[]]`-typed `-Porperty` parameter and does _not_ rely on a `ValueFromPipeline*` attribute.\r\n\r\nDitto for `Select-Object`'s `-Property` parameter and the use of calculated properties (though you typically wrap the script blocks in a _hashtable_ there, you don't have to; e.g., `1 | select { $_ + 1 }`).\r\n\r\n~~Similarly, using the technique with `Measure-Object`'s  `-Property` parameter _would_ make sense (it currently isn't supported, because the type is `[string[]]` and the parameter is not declared as pipeline-binding) and it is an example of how generalizing the feature could benefit existing commands:~~\r\n\r\n```powershell\r\n# Count the  odd numbers in the input.\r\n1, 2, 3 | Measure-Object -Sum -Property { $_ % 2 }  # wishful thinking\r\n```\r\n\r\n<sup>Update: This example is flawed, because `Measure-Object` only expects _property names_, and wouldn't know how to handle being given a _value_ directly.</sup>\r\n\r\n\r\n\r\nYes, there may be cmdlets where applying the feature makes no sense, but:\r\n\r\n* users who use the - advanced - ad-hoc script-block feature need to understand what the cmdlet does anyway (and thus whether the technique is applicable)\r\n\r\n* it is unlikely that someone who doesn't will stumble on its use or expect it to do something else.\r\n\r\n",
      "created_at": "2018-05-10T16:13:05Z",
      "updated_at": "2018-05-10T17:40:43Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@lzybkr \r\n\r\n> To handle that situation correctly, I suppose the engine could rewrite the command invocation to do the equivalent of using ForEach-Object\r\n\r\nBut something to that effect must _already_ be happening for explicitly pipeline-binding parameters, correct?\r\n\r\n> , but I don't think it's worth it - performance wouldn't be as good\r\n\r\nPerformance wouldn't be as good as direct use of `ForEach-Object`?\r\nWhat if you factor in the need to call the target cmdlet _for each input object_ in the context of `ForEach-Object`? \r\nIn either scenario a script block must be executed _for each input object_, and it seems to me that the additional overhead from calling _another cmdlet_ from each such script-block invocation not only makes for a more verbose command overall, it would also perform worse.\r\n(Or did you mean something else?)\r\n\r\n>  and it seems to be difficult to find examples where folks have forgotten the attribute.\r\n\r\nAmong the standard cmdlets I've stumbled upon `Measure-Object` (see previous comment), but do note that it's also about _third-party_ and _user-defined_ cmdlets / advanced functions - more on that below.\r\n\r\n> A cmdlet may do something once for a parameter when it doesn't expect the value to change during pipeline processing. Requiring an attribute is one way of at least declaring that the cmdlet does not do so for that parameter.\r\n\r\nThat a `ValueFromPipeline*` attribute is needed in order to support ad-hoc script-block arguments is _conceptually obscure_ (not least because the ad-hoc script-block feature isn't _documented_):\r\n\r\nIf we take the [`ValueFromPipelineByPropertyValue` attribute](https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.parameterattribute.valuefrompipelinebypropertyname?view=powershellsdk-1.1.0) at face value:\r\n\r\n> Gets and sets a flag that specifies that this parameter can take values from a property in the incoming pipeline object with the same name as the parameter. \r\n\r\nThere's no reference to the script-block technique, and the suggestion is that the purpose is to do something like the following, using the `Rename-Item` cmdlet's `-NewName` parameter:\r\n\r\n```powershell\r\n[pscustomobject] @{ NewName = 'bar.txt' } | Rename-Item foo.txt -Whatif\r\n```\r\n\r\nNot an intuitive use, and not something I've seen in the wild.\r\n\r\nAnd even if the connection with the script-block technique _were_ mentioned:\r\n\r\n* the coupling with the property-from-pipeline-object feature is awkward\r\n\r\n* especially in cases where the _sole_ reason for specifying the attribute is to enable the script-block technique.\r\n\r\n----\r\n\r\nIn short:\r\n\r\nFor command authors:\r\n\r\n  * it's not obvious in the first place that a `ValueFromPipeline*` is needed to enable the script-block technique.\r\n\r\n  * even once an author knows, it's cumbersome to anticipate all uses that make sense, and cumbersome to manually decorate all parameters for which it _potentially_ makes sense.\r\n\r\nFor users:\r\n\r\n* Users should have the option to apply the script-block technique to _any_ parameter, _if_ it makes sense for a given _pipeline-supporting_ cmdlet - and determining whether it makes sense in a given situation is the user's responsibility.\r\n\r\n   * As stated, it is an _advanced_ feature, and its syntax makes it unlikely that _inexperienced_ users will stumble upon it with different intent.\r\n\r\nMaking the feature _part of the plumbing_ solves these problems.\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2018-05-10T16:56:01Z",
      "updated_at": "2018-05-10T16:57:31Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "Your `Measure-Object` example is a bit silly - the value produced gets would be converted to string, so you would rely on round trip conversions to get a proper sum. If that scenario made sense, it would be more useful to have `Measure-Object` evaluate the script block instead of the parameter binder.\r\n\r\nIf you really want to make your case, you should write a tool to analyze a large body of scripts looking for uses of `ForEach-Object` that could be simplified with this feature.",
      "created_at": "2018-05-10T17:16:37Z",
      "updated_at": "2018-05-10T17:16:37Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@lzybkr:\r\n\r\n> Your Measure-Object example is a bit silly\r\n\r\nYou're right: `Measure-Object` would have to follow the model of `Sort-Object` and `Select-Object` (`[object[]]` parameter with command-internal custom logic) for this technique to be useful, so it's a flawed example.\r\n\r\n(But as an aside: enhancing `Measure-Object` to work like `Sort-Object` / `Select-Object`  in this respect is worth considering in its own right).\r\n\r\n> If you really want to make your case, you should write a tool to analyze a large body of scripts looking for uses of ForEach-Object that could be simplified with this feature.\r\n\r\nIf the \"In short:\" paragraph from my previous comment doesn't make a compelling case in your mind, I won't pursue this any further.\r\n\r\nI'm not closing it yet, however, in case others want to contribute thoughts (or perhaps someone else feels inspired to analyze existing scripts).\r\n\r\n\r\n",
      "created_at": "2018-05-10T17:35:29Z",
      "updated_at": "2018-05-10T17:36:26Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 In fact your `measure-object` example _wouldn't work at_ all because the cmdlet is expecting the _name_ of a property to retrieve not a value to sum. With `1, 2, 3 | Measure-Object -Sum -Property { $_ % 2 }`  it would be looking for properties on the input object named '1', '0' and '1'. That's why there are custom implementations of the logic in sum, select, etc. They are polymorphic operations: retrieve the property name if it's a string, compute a value if it's a scriptblock, add a custom property if it's a hashtable. Once again, simply binding the parameter from the pipeline is not sufficient. The cmdlet has to have been written in such a way that it makes sense.\r\n\r\n> Users should have the option to apply the script-block technique to any parameter, *if it makes sense for a given pipeline-supporting cmdlet*\r\n\r\nIn the absence of the `[ValueFromPipeline]` attribute, _how could the user possibly know this_? So far, we haven't presented a single example so far where it _would_ work.\r\n\r\nBUT - I do see how a sort of variation on this idea could work to simplify `foreach` scenarios. It's very much along the line of `xargs` (so I'll call it xargs). Taking the `Get-WmiObject` example, \r\n```\r\nImport-Csv computers.csv | Get-WmiObject -computerName { $_.ComputerName } -Class { $_.Class }\r\n```\r\nit would become\r\n```\r\nImport-Csv computers.csv | xargs Get-WmiObject -computerName { $_.ComputerName } -Class { $_.Class }\r\n```\r\nThe `xargs` command would use dynamic parameters to expose the parameters of the wrapped command, but annotated with `[ValueFromPipelineByPropertyName]`. On each pipeline object, it would invoke the wrapped command with `$PSBoundParameters`.  (I haven't thought it through completely yet so I'm not totally sure it would work.)",
      "created_at": "2018-05-10T23:26:16Z",
      "updated_at": "2018-05-10T23:26:16Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@BrucePay:\r\n\r\n>  In fact your measure-object example wouldn't work at all \r\n\r\nYes, I had already updated my original comment with that realization. (More later)\r\n\r\n",
      "created_at": "2018-05-10T23:30:37Z",
      "updated_at": "2018-05-10T23:30:37Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 Do you have an example where it would work?",
      "created_at": "2018-05-11T01:27:24Z",
      "updated_at": "2018-05-11T01:27:24Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@BrucePay \r\n\r\n> Do you have an example where it would work?\r\n\r\nThe standard cmdlets - commendably - have most scenarios covered by having the relevant parameters declared with `ValueFromPipelineByPropertyName`, so there are only a few examples I can think of that don't already work (see below).\r\n\r\nHowever, the point is that:\r\n\r\n* Third-party cmdlets, by contrast, may not be implemented with this feature in mind, even where it makes sense for easily anticipated uses cases - not least because the feature and its connection with `ValueFromPipelineByPropertyName` is not documented.\r\n  * This is just a _hunch_; certainly, personally I wasn't aware of it until fairly recently, when I conducted my own experiments and wrote up the findings in [this docs issue](https://github.com/PowerShell/PowerShell-Docs/issues/2338).\r\n  * However, given the point made below (and previously), I don't think it's necessary to analyzing existing code.\r\n\r\n* More importantly, however, this required decoration with `ValueFromPipelineByPropertyName` strikes me as both logically unnecessary and cumbersome / easy to forget.\r\n   * Even if you do try to anticipate all use cases, the point, as also made in Jeffrey's blog post, is that having the feature work generically, as part of the language infrastructure (within the constraints stated), gives users great flexibility and does not restrict them to what parameters the command author chose to designate - assuming they even knew of that requirement.\r\n    * From what I can tell, the _only_ thing that cmdlets currently need to do to in order to support ad-hoc script-block arguments is to designate a parameter as pipeline-binding: the process of evaluating the script block and updating the associated property / PS variable with the result for each input object in the `ProcessRecord()` method / `process` block implementation already is transparent to the cmdlet, so opening up that feature shouldn't require too much effort.\r\n\r\n---\r\n\r\n> They are polymorphic operations: retrieve the property name if it's a string, compute a value if it's a scriptblock, add a custom property if it's a hashtable.\r\n\r\nYes, and of necessity these special cases are therefore based on `[object[]]`-typed parameters, which do _not_ clash with the feature being discussed (which fundamentally only applies to parameter types _other than_ `[object]` / `[psscriptblock]` (and their array variants).\r\n\r\n(And because these are custom implementations, they are not required to - and aren't - marked as `ValueFromPipelineByPropertyName` (or, more descriptively, as a hypothetical `ValueFromPipelineByScriptBlock`).\r\n\r\n> In the absence of the [ValueFromPipeline] attribute, how could the user possibly know this?\r\n\r\nThey don't have to know this technical detail - and _most likely even currently don't_, given the lack of documentation. There are tons of `Rename-Item -NewName { ... }` examples out there, but I'm fairly certain that most users are completely unaware of the underlying mechanism and its prerequisites.\r\n\r\nAs an aside: Which parameters have pipeline support is currently hard to discover altogether: see #4135\r\n\r\nAll that is - and should be - needed is to understand the following about a cmdlet in order to infer whether the script-block technique makes sense:\r\n\r\n* The cmdlet supports pipeline input - and, as stated, with most cmdlets, there's an obvious candidate for what kinds of objects are supplied via the pipeline\r\n\r\n* As each object being processed, it is useful to derive the value of _additional_ parameters (other than one through which pipeline input is bound) from the object at hand.\r\n   * This usefulness depends on the scenario, and there are obvious _general_ cases (`Rename-Item -NewName`) as well as _unusual, one-off_ ones (see below). The point is that by opening up the feature you give users a general-purpose feature that gives them the flexibility to cover even unusual situations.\r\n\r\n---\r\n\r\n### Examples based on standard cmdlets with parameters not already supported by ad-hoc script-block input.\r\n\r\n_These examples are somewhat contrived_, because, as stated, the _standard_ cmdlets do a good job of anticipating common scenarios and marking the relevant parameters as `ValueFromPipelineByPropertyName`, thereby ensuring ad-hoc script-block argument support.\r\n\r\nBut, again, the point is that many 3rd-party cmdlets may not (see speculation above) and that it (a) isn't a logical necessity and (b) not requiring it gives users flexibility that doesn't rely on the cmdlet authors' anticipation of specific uses.\r\n\r\nWith `Import-Csv`, derive the input encoding from the input file path (a component of which is assumed to reflect the encoding) by passing a script block to `-Encoding`:\r\n\r\n```powershell\r\nGet-ChildItem *.csv -Recurse | Import-Csv -Encoding { ['utf8', 'ascii']($_.FullName -match '/ascii/') }\r\n```\r\n\r\nWith `Select-String`, determine which files contain their own filename by passing a script block to `-Pattern`:\r\n\r\n```powershell\r\nGet-ChildItem *.cs -Recurse | Select-String -Pattern { $_.Name }\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n ",
      "created_at": "2018-05-11T13:38:53Z",
      "updated_at": "2018-05-12T03:41:41Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@BrucePay: Regarding the `xargs` idea:\r\n\r\nThe appeal of the ad-hoc script-block technique is that it doesn't require _once-per-input-object_ invocations of cmdlets, which is what a `ForEach-Object` solution does.\r\n\r\nTo go back to the `Rename-Item` example:\r\n\r\n```powershell\r\nGet-Item *.txt | Rename-Item -NewName {  $_.BaseName + '.md' }\r\n```\r\n\r\nis not only more concise and elegant, but _also more efficient_ than the following (do tell me if it is not), because it only requires a _single_ invocation of `Rename-Item`:\r\n\r\n```powershell\r\nGet-Item *.txt | % { Rename-Item -LiteralPath $_.FullName -NewName ($_.BaseName + '.md') }\r\n```\r\n\r\nBy contrast, if the cmdlet doesn't support the [PowerShell] pipeline at all, such as in the case of `Get-WmiCommand` or, more generally, with _external_ programs, _once-per-input-object_ invocations are _unavoidable_ if you want to pass arguments derived from each input object.\r\n\r\nAnd for that I think the existing `ForEach-Object` syntax is fine, and there is no need for an `xargs`-like  construct.\r\n\r\nUsing the example at hand, I don't think that:\r\n\r\n```powershell\r\nImport-Csv computers.csv | xargs Get-WmiObject -computerName { $_.ComputerName } -Class { $_.Class }\r\n```\r\n\r\nis an improvement on good old:\r\n\r\n```powershell\r\nImport-Csv computers.csv | % { Get-WmiObject -computerName $_.ComputerName -Class $_.Class }\r\n```\r\n",
      "created_at": "2018-05-11T15:43:25Z",
      "updated_at": "2018-05-11T15:43:25Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "> The appeal of the ad-hoc script-block technique is that it doesn't require once-per-input-object invocations of cmdlets\r\n\r\nBut it does require one-per-input-object scriptblock invocations which aren't cheap. Consider\r\n```\r\nPS[1] (93) >  measure-command { $null = $nums | sort-object num } | foreach totalseconds\r\n1.6597981\r\nPS[1] (94) >  measure-command { $null = $nums | sort-object {$_.num} } | foreach totalseconds\r\n3.0010975\r\n```\r\nand `xargs` would be able to cache the `CommandInfo` object thereby mitigating some of the performance overhead:\r\n```\r\nPS[1] (95) >  measure-command { foreach ($n in $nums) { Out-Null -InputObject 1 } } | foreach totalseconds\r\n1.7755921\r\nPS[1] (96) >  measure-command { foreach ($n in $nums) { & $onc -InputObject 1 } } | foreach totalseconds\r\n0.8879042\r\n```\r\nOf course it depends on what the command does, but caching the `CommandInfo` can certainly help.\r\n\r\n> Using the example at hand, I don't think that (`xargs` example) is is an improvement on good old (`foreach` example using `%` alias)\r\n\r\nAliases certainly help with brevity. For example, `^` could be an alias for `xargs`.\r\n```\r\nImport-Csv computers.csv |^ Get-WmiObject -computerName { $_.ComputerName } -Class { $_.Class }\r\n```\r\nbut even so, if you don't think it's better than `foreach`, then why do think (removing the ^)\r\n```\r\nImport-Csv computers.csv | Get-WmiObject -computerName { $_.ComputerName } -Class { $_.Class }\r\n```\r\nis more elegant? Or is it just the perceived efficiency that you care about (which actually requires the cmdlet to be redesigned to accept pipeline input). \r\n\r\n",
      "created_at": "2018-05-11T21:19:38Z",
      "updated_at": "2018-05-11T21:19:38Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "@mklement0  With respect to your newest examples, the `Select-String` case worn't work because `Pattern` is compiled into regular expressions in `BeginProcessing` while `Import-Csv` might actually work but is **extremely** contrived.  In the absence of a _single compelling_ example, with plenty of examples where it just wouldn't work or make sense,  and at the cost of significant impact on the parameter binder, why should we consider doing this? ",
      "created_at": "2018-05-11T21:53:21Z",
      "updated_at": "2018-05-11T21:53:21Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@BrucePay:\r\n\r\n>  the Select-String case worn't work because Pattern is compiled into regular expressions\r\n\r\nThat's the first legitimate counter-example (see below).\r\n\r\n> Import-Csv might actually work but is **extremely** contrived\r\n\r\nI've explained why it is contrived of necessity. \r\nBut it's a moot point, because It is not cmdlets that _ship with PowerShell_ that would benefit, it's third-party cmdlets and self-authored ones.\r\n\r\nThis _assumes_ that third-party cmdlet authors aren't aware (yet) of the need to mark parameters that should support ad-hoc script blocks explicitly as pipeline-binding and that third-party cmdlets therefore miss out on legitimate uses of the technique.\r\n\r\nThe assumption is based on the lack of documentation (and my personal unawareness until recently) - but I haven't done any analysis of existing code.\r\n\r\n> with plenty of examples where it just wouldn't work or make sense\r\n\r\n* `Get-WmiObject` was never even in the running as a counter-example, because, as stated, it _doesn't support pipeline input_.\r\n\r\n* `Measure-Object` is not a counter-example, because, as `Sort-Object` and `Select-Object` and already do, it should support script blocks via  _custom_ logic - see #6855\r\n\r\n---\r\n\r\nTo generalize the cases where it _wouldn't_ make sense (in addition to cmdlets that don't support the pipeline at all, support of which was never my intent),  such as in the `Select-String -Pattern` case (a  manifestation of what @lzybkr had already briefly mentioned):\r\n\r\n  * The technique wouldn't work for parameters whose values are _cached_ (in transformed form) _before_ per-input-object processing begins.\r\n\r\n  * While such caching is impossible to know about  in the absence of `ValueFromPipeline*` or documentation of implementation details (short of looking at the source code), it's the prize to pay for generalizing the ad-hoc script-block feature - user discretion / experimentation advised.\r\n\r\n> and at the cost of significant impact on the parameter binder\r\n\r\nI haven't looked at the source code, but let's look at what happens currently when you pass a script block to a parameter that doesn't support it:\r\n\r\n```powershell\r\nPS> 1 | & { param([parameter(ValueFromPipeline)] $InputObject, [int] $NoScriptBlockPlease) } -NoScriptBlockPlease { $_ + 1  }\r\nCannot process argument transformation on parameter 'NoScriptBlockPlease'. Cannot convert the \" $_ + 1 \" value of type \"System.Management.Automation.ScriptBlock\" to type \"System.Int32\".\r\n```\r\n\r\nAs such, ad-hoc script-block binding could be implemented as a  _fall-back_ solution that wouldn't hamper performance during normal parameter binding.\r\n\r\nHowever, there _is_ a snag that I hadn't considered: `[string]`-typed parameters.\r\nGiven that _anything_ can bind to a `[string]` parameter, passing a script block currently binds its literal contents as a string, so changing the interpretation of a script-block argument in this scenario is technically a breaking change.\r\n\r\nSo, the breaking change is problematic, but is the impact on the parameter binder really significant?\r\n",
      "created_at": "2018-05-12T03:15:56Z",
      "updated_at": "2018-05-12T03:44:40Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@BrucePay:\r\n\r\n> But it does require one-per-input-object scriptblock invocations which aren't cheap.\r\n\r\nYes, but (a) that's unavoidable in the given scenario and (b) it's cheaper than a `ForEach-Object` loop with per-object invocations of the cmdlet (with the `Rename-Item` example, the ad-hoc script-block example is about twice as fast as the `ForEach-Object` variant on my machine after warming up the cache).\r\n\r\n> then why do think (removing the ^) `Import-Csv computers.csv | Get-WmiObject -computerName { $_.ComputerName } -Class { $_.Class }`\r\nis more elegant? Or is it just the perceived efficiency that you care about (which actually requires the cmdlet to be redesigned to accept pipeline input).\r\n\r\nTo be clear: I was never looking for a _new syntax_; instead, I was looking to make existing syntax _for pipeline-supporting cmdlets_ part of the plumbing without requiring cmdlets to explicitly signal support for it.\r\n\r\nTherefore, the right examples to compare are the `Rename-Item` ones, where the elegance comes in part from the input objects coming _from the pipeline_.\r\n\r\nI was also not looking for performance improvements per se, but the fact that the ad-hoc script-block technique is also faster is a nice bonus.\r\n\r\n",
      "created_at": "2018-05-12T03:36:35Z",
      "updated_at": "2018-05-12T03:36:35Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@BrucePay:\r\n\r\nBefore we move on to the grand finale, let me summarize my thoughts re the severity of the impact on the parameter binder:\r\n\r\nI can't speak to the _implementation_ side of things, but _conceptually_, the impact strikes me as small:\r\n\r\nIt requires moving from:\r\n\r\n* Is the parameter _at hand_ pipeline-binding (and not `[object]`- or `[scriptblock]`-typed)?\r\n\r\nto:\r\n\r\n* Is the _cmdlet as a whole_ pipeline-binding, via _any_ of its parameters (and is the parameter _at hand_ not `[object]`- or `[scriptblock]`-typed)?\r\n\r\n\r\n\r\n",
      "created_at": "2018-05-13T14:30:59Z",
      "updated_at": "2018-05-13T14:30:59Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "My Spidey senses tell me that what this issue asks for ain't gonna happen, so let me bring some closure to it:\r\n\r\n---\r\n\r\nFrom the Department of Coulda-Shoulda-Woulda:\r\n\r\nIf the feature were opened up (if it didn't require per-parameter opt-in), cmdlets would have to _go out of their way_ to defeat it.\r\n\r\nHence, it is _defeating it_  - in legitimate cases such as precompiling the `-Pattern` regex for `Select-String` for performance reasons - that should require _opting out_, via an attribute such as `ValueFromPipelineByScriptBlock=$False`.\r\nIn the simple case of advanced PowerShell functions without a `process {}` block, non-support could be _inferred_.\r\n\r\n---\r\n\r\nFrom the Department of Let's-Make-Lemonade:\r\n\r\nThe existing feature is powerful, but in order for it to see wider adoption, two things must happen:\r\n\r\nIt must be given a _name_ and be _documented_:\r\n\r\n  * for end users: see https://github.com/PowerShell/PowerShell-Docs/issues/2338\r\n\r\n  * for cmdlet authors: https://github.com/PowerShell/PowerShell-Docs/issues/2427\r\n\r\nThis enables:\r\n\r\n* _end users_ to understand the feature _conceptually_ (instead of just seeing _situational_ applications such as with `Rename-Item`) and how to examine a given cmdlet's parameters for support (though that is currently a little cumbersome).\r\n\r\n* _cmdlet authors_ to design their cmdlets with the feature in mind, which I suspect may not have happened so far due to lack of documentation.\r\n\r\nThe current coupling of the feature with attribute `ValueFromPipelineByPropertyName` is conceptually confusing, and the latter's primary purpose - binding by input objects' _properties_  - is often _not_ needed in binding-by-script-block scenarios - see #6861.\r\n\r\n",
      "created_at": "2018-05-13T14:33:08Z",
      "updated_at": "2018-05-13T14:33:08Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "@mklement0 - your proposal is just asking for trouble - opting out means the command author must be aware of the feature **and** realize their code does not support the feature. In my experience, you're expecting too much.\r\n\r\nI'll pick on the `-ComputerName` parameter. I count 25 cmdlets that do not accept `ComputerName` with either ValueFromPipeline... attribute, and most (verified by assumption only) *do* take some value from the pipeline.\r\n\r\nIt's reasonable to assume every one of these commands creates the connection once, not for every object in the pipeline.\r\n\r\nI'll also assert that this pattern is probably common.\r\n\r\nSo with this proposal, people would learn the hard way that they can't trust script block binding because it won't work for some common patterns.",
      "created_at": "2018-05-14T17:45:32Z",
      "updated_at": "2018-05-14T17:45:32Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> means the command author must be aware of the feature\r\n\r\nRaising awareness of the feature is sorely needed in general, both for end users and command authors - see my previous comment.\r\n\r\n> and realize their code does not support the feature.\r\n\r\nOnce they understand the feature, that shouldn't be a problem.\r\n\r\nThere are other implicit features you need to opt out of that users may not be aware of, such as positional-by-default binding.\r\n\r\nIn both cases, not opting out is _typically_ benign, however.\r\n\r\nThat said, I can see that users want to determine positively whether a given parameter supports the feature, so I briefly considered the following contract:\r\n\r\n* If a given parameter is marked `ValueFromPipeline[ByPropertyName/ByScriptBlock]`, you can _rely_ on support for ad-hoc script-block arguments.\r\n\r\n* In the _absence_ of a such an attribute for a _pipeline-binding-in-principle_ command's parameter, it _may_ work - but there's no guarantee.\r\n\r\nAt the end of the day, however, that is too brittle:\r\n\r\nA later _implementation change_ of a cmdlet / advanced function (such as a performance optimization) could then unwittingly break existing code that relied on the happened-to-work feature.\r\n\r\nIn short: I now agree that _opt-in_ is better, so I'm closing this.\r\nSorry it took a while to get there, and thanks for the discussion.\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2018-05-14T19:21:31Z",
      "updated_at": "2018-05-14T19:21:31Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": ">Sorry it took a while to get there, ...\r\n\r\nIt is very usefull because binding is very complex. Thanks!",
      "created_at": "2018-05-15T03:29:32Z",
      "updated_at": "2018-05-15T03:29:32Z"
    }
  ],
  "created_at": "2018-05-08T13:19:23Z",
  "labels": [
    "Issue-Question"
  ],
  "number": 6837,
  "state": "closed",
  "title": "Can we allow script-block parameter values for non-pipeline-binding parameters too?",
  "updated_at": "2018-05-15T03:29:32Z"
}