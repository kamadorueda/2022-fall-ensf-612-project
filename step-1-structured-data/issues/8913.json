{
  "_url": "https://github.com/PowerShell/PowerShell/issues/8913",
  "author": "pougetat",
  "body": "<!-- Anything that looks like this is a comment and can't be seen after the Pull Request is created. -->  \r\n\r\n## PR Summary\r\n\r\nThis PR fixes #8912 which is due to a tokenization issue in the help command.\r\n\r\n## PR Context  \r\n\r\n\r\n## PR Checklist\r\n\r\n- [x] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [x] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] [Change is not breaking](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)\r\n- [x] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` or `[ WIP ]` to the beginning of the title (the `WIP` bot will keep its status check at `Pending` while the prefix is present) and remove the prefix when the PR is ready.  \r\n- **User-facing changes**\r\n    - [x] Not Applicable\r\n    - **OR**  \r\n    - [ ] [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n- **Testing - New and feature**\r\n    - [ ] N/A or can only be tested interactively\r\n    - **OR**\r\n    - [x] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n        - [ ] [Add `[feature]` to your commit messages if the change is significant or affects feature tests](https://github.com/PowerShell/PowerShell/blob/master/docs/testing-guidelines/testing-guidelines.md#requesting-additional-tests-for-a-pr)\r\n",
  "closed_at": "2019-03-10T14:52:57Z",
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@rkeithhill Please review the PR.",
      "created_at": "2019-02-22T14:04:16Z",
      "updated_at": "2019-02-22T14:04:16Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "My fear is that this function becomes ponderous.",
      "created_at": "2019-02-22T14:06:20Z",
      "updated_at": "2019-02-22T14:06:33Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "I'll look at it this weekend. I still have some concerns.  I'd like to avoid any sort of script injection e.g. `less \"format string $(remove-item $home\\* -r -for)\"`.  Which I \"think\" we could avoid with: `& $pagerCmd --% $pagerArgs`.  \r\n\r\nAlso the tokenizer approach doesn't account for single value, path to pager with spaces.  That is, it parses this `C:\\Program Files\\Pscx\\bin\\less.exe` as `command = C:\\Program` followed by an arg/param of `Files\\Pscx\\bin\\less.exe`.  So *before* trying the tokenize approach we should check if the entire pager value corresponds to an application path.  If so, there are no args and no need to tokenize.  If not, then we can tokenize cmd/args.",
      "created_at": "2019-02-22T15:57:51Z",
      "updated_at": "2019-02-22T16:03:48Z"
    },
    {
      "author": "pougetat",
      "author_association": "NONE",
      "body": "The tokenizer approach can still work if you put quotes around the pager path. Without quotes and extra arguments it indeed becomes harder to parse the page path with a space in it. Without an extra argument I agree we shouldn't need quotes and checking if the entire command-line is a valid path is a good idea and this is exactly how to code works currently.",
      "created_at": "2019-02-22T17:28:24Z",
      "updated_at": "2019-02-22T17:59:55Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Should we follow only env:PAGER? Could we put in env:PAGER only application name and params in env:PAGERPARAMS?",
      "created_at": "2019-02-22T19:06:13Z",
      "updated_at": "2019-02-22T19:06:13Z"
    },
    {
      "author": "pougetat",
      "author_association": "NONE",
      "body": "> Should we follow only env:PAGER? Could we put in env:PAGER only application name and params in env:PAGERPARAMS?\r\n\r\n@rjmholt :)",
      "created_at": "2019-02-23T07:00:07Z",
      "updated_at": "2019-02-23T07:00:07Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "OK, here is my take on how to do this without incurring script injection - at least unintental script injection.  Note there is probably a better way but this does seem to work.  Here it is in pseudo-code - ish form:\r\n```\r\n$customPagerCommand = $customPagerArgs = $null\r\n\r\n# Disallow a pure whitespace value as that would cause the tokenizer to return 0 tokens.\r\nif (![string]::IsNullOrWhitespace($env:PAGER)) {\r\n    # Check if the PAGER value corresponds to a command.\r\n    # This allows the user to specify a path to an exe with spaces without having to quote the path.\r\n    # However, if the user wants to also specify args then they will have to quote the exe path.\r\n    if (Microsoft.PowerShell.Core\\Get-Command $env:PAGER -ErrorAction Ignore) {\r\n        $customPagerCommand = $env:PAGER\r\n    }\r\n    else {\r\n        # Custom pager has been specified with arguments OR single arg is not a command.\r\n        # Tokenize the specified $env:PAGER command / command line.  Ignore tokenizing\r\n        # errors because what is an error for PowerShell may be allowed for the paging\r\n        # utility to be invoked.\r\n        $errs = $null\r\n        $tokens = [System.Management.Automation.PSParser]::Tokenize($env:PAGER, [ref]$errs)\r\n\r\n        $customPagerCommand = $tokens[0].Content\r\n        if (!(Microsoft.PowerShell.Core\\Get-Command $customPagerCommand -ErrorAction Ignore)) {\r\n            # Custom pager command is invalid, issue a warning.\r\n            Write-Warning \"\"Ignoring invalid custom-paging utility command line specified in `$env:PAGER: $env:PAGER\"\"\r\n            $customPagerCommand = $null\r\n        }\r\n        elseif ($tokens.Count -gt 1) {\r\n            # This approach will preserve all the pagers args.\r\n            $customPagerArgs = $env:PAGER.Substring($tokens[1].Start)\r\n        }\r\n    }\r\n}\r\n...\r\nif ($customPagerCommand) {\r\n    if ([string]::IsNullOrWhitespace($customPagerArgs)) {\r\n        $help | & $customPagerCommand\r\n    }\r\n    else {\r\n        # Using the stop parsing operator prevents PowerShell from executing/interpolating \r\n        # anything in the PAGER args and choking on what it thinks is a parse error.\r\n        $env:__PAGER_ARGS = $customPagerArgs\r\n        $help | & $customPagerCommand --% %__PAGER_ARGS%\r\n        Remove-Item Env:\\__PAGER_ARGS -ErrorAction Ignore # Or maybe keep for debugging?\r\n    }\r\n}\r\n...\r\n```",
      "created_at": "2019-02-23T21:16:08Z",
      "updated_at": "2019-03-03T03:35:44Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "BTW while we have \"the hood up\", why is it that on Windows - when I use less, I have to first pipe to `Out-String -Width 120` before sending on to less?  Otherwise, help topics wrap and do not look right:\r\n```\r\nman Get-Content\r\n...\r\nDESCRIPTION\r\n    The `Get-Content` cmdlet gets the content of the item at the location specified by the path, such as the text in a f\r\nile or the content of a function. For files, the content is read one line at a time and returns a collection of objects\r\neach of which represents a line of content.\r\n\r\n    Beginning in Windows PowerShell 3.0, `Get-Content` can also get a specified number of lines from the beginning or ed\r\n of an item.\r\n```\r\nversus:\r\n```\r\nGet-Help Get-Content | Out-String -Width 120 | less\r\n...\r\nDESCRIPTION\r\n    The `Get-Content` cmdlet gets the content of the item at the location specified by the path, such as the text in a\r\n    file or the content of a function. For files, the content is read one line at a time and returns a collection of\r\n    objects, each of which represents a line of content.\r\n\r\n    Beginning in Windows PowerShell 3.0, `Get-Content` can also get a specified number of lines from the beginning or\r\n    end of an item.\r\n```\r\nNote that on Linux, piping directly to less works just fine.  BTW I've tried setting $COLUMNS/$LINES on Windows and that doesn't help.",
      "created_at": "2019-02-23T21:22:04Z",
      "updated_at": "2019-02-23T21:22:59Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@rkeithhill Please open new Issue for your question.\r\n\r\n~~I am not sure that Tokenizer is right tool to resolve paths.~~",
      "created_at": "2019-02-24T18:48:53Z",
      "updated_at": "2019-02-25T04:28:26Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "@iSazonov see #7175",
      "created_at": "2019-02-25T04:16:56Z",
      "updated_at": "2019-02-25T04:16:56Z"
    }
  ],
  "created_at": "2019-02-19T08:48:08Z",
  "number": 8913,
  "state": "closed",
  "title": "Fix env:PAGER not tokenized properly by help command",
  "updated_at": "2019-03-10T14:53:12Z"
}