{
  "_url": "https://github.com/PowerShell/PowerShell/issues/18343",
  "author": "sumit-kakadiya",
  "body": "### Prerequisites\n\n- [X] Write a descriptive title.\n- [X] Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\n- [X] Search the existing issues.\n- [X] Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\n- [X] Refer to [Differences between Windows PowerShell 5.1 and PowerShell](https://docs.microsoft.com/powershell/scripting/whats-new/differences-from-windows-powershell).\n\n### Steps to reproduce\n\nfacing issue in version: Powershell version powershell-7.2 and on powershell-7.1.3\r\nOS: centos 7\r\nmodule used : ExchangeOnlineManagement\r\nIssue: I connected o365 via powershell using application. I connected succesfully. I tried to fetch any connector exists or not. \r\nThat gets failed. But \"$?\" was not set to False. It always remains True. Earlier it was set to False in such a case.\r\nSame issue I faced when I create any connector. IF connector creations fails, \"$?\" remains True instead of False.\r\n\r\nIn below code sample: \r\n1. connector1 does not exist in my o365 exchange. \r\n2. \"myrule\" as not created as account has reached limit to no. of rules already.\r\n\r\ncode sample:\r\n$EncPassword = ConvertTo-SecureString -String 'passowd' -AsPlainText -Force \r\nConnect-ExchangeOnline -AppId 'appid of mine' -CertificateFilePath '/home/cert.pfx' -CertificatePassword $EncPassword -Organization 'myorgdomain.onmicrosoft.com'\r\n write-host \"connected\"\r\n Get-InboundConnector 'connector1' \r\nif ($? -eq $True) \r\n{ \r\n    write-host \"inbound connector exist\"\r\n  }\r\n  else\r\n{\r\n   write-host \"inbound connector does not exist\"\r\n}\r\n     try \r\n    {\r\n      New-TransportRule -Name 'myrule' -FromScope NotInOrganization -SentToScope InOrganization  -Enabled $true  -Priority 0 -SetSCL -1\r\n       if ($? -eq $True)\r\n        {\r\n         write-host \"inbound rule created\"\r\n         } \r\n        else\r\n         {\r\n              write-host \"inbound rule creation failed\"\r\n         }\r\n       } \r\n       catch \r\n       { write-error \"This is exception\" }\n\n### Expected behavior\n\n```console\n$? should be set to $False as both commands were actually failed. It was working before few days but suddenly behaviour looks changed.\r\n\r\nExpected output:\r\nconnected\r\ninbound connector does not exist\r\ninbound rule creation failed\n```\n\n\n### Actual behavior\n\n```console\n$? always set to $True even both commands were actually failed. It was working before few days but suddenly behaviour looks changed.\r\n\r\nactual output:\r\nconnected\r\ninbound connector exist\r\ninbound rule created\n```\n\n\n### Error details\n\n_No response_\n\n### Environment data\n\n```powershell\nactual output:\r\nconnected\r\ninbound connector exist\r\ninbound rule created\n```\n\n\n### Visuals\n\n_No response_",
  "closed_at": null,
  "comments": [
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "The value of erroractionPreference and what happens inside the command being called will impact $?\r\n\r\n\r\n```\r\nfunction one {\r\n[CmdletBinding()]\r\nparam()\r\n1/0\r\n\"This line runs\"\r\n}\r\n\r\nPS>  one\r\nRuntimeException:\r\nLine |\r\n   4 |  1/0\r\n     |  ~~~\r\n     | Attempted to divide by zero.\r\nThis line runs\r\n\r\nPS>  $?\r\nTrue\r\n```\r\n There was an error but the command still ran to completion - this is the test for \"succeeded\"  - setting error action prevents it running to completion.\r\n\r\n```\r\nPS>  one -ErrorAction stop\r\none: Attempted to divide by zero.\r\n\r\nPS>  $?\r\nFalse\r\n```\r\n\r\n\"Did what I wanted\", \"Ran without raising any error\", and \"Succeeded\" are not not the same, and the difference is a surprise sometimes.  \r\n",
      "created_at": "2022-10-21T10:25:25Z",
      "updated_at": "2022-10-21T10:26:01Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "If I understand correctly, what sets `$?` to false is _any_ error record being written to the caller's error stream - which can be a non-terminating error (`Get-Item NoSuch`) or a statement-terminating error (`Get-Item -NoSuch`).\r\n(As such `$?` only ever tells you that _some_ error occurred, not whether the command failed entirely or should still be considered successful overall.)\r\n\r\nHowever, for commands written _in PowerShell_, statement-terminating errors or `Write-Error` calls _inside_ them do _not_ cause `$?` to be set to `$false`. The only way to currently achieve that is by making your script or function an _advanced_ one and to use `$PSCmdlet.WriteError()` (non-terminating error) or `$PSCmdlet.ThrowTerminatingError()` (statement-terminating error, from the caller's perspective).\r\n\r\nThat `Write-Error` currently doesn't set `$?` is unfortunate, and a known problem:\r\n * https://github.com/PowerShell/PowerShell/issues/3629\r\n\r\nAdditionally, the ability for scripts and function to set `$?` _explicitly_ has been green-lighted a while back, but isn't yet implemented (a new public API to be surfaced via a new cmdlet):  \r\n * https://github.com/PowerShell/PowerShell/issues/10917#issuecomment-550550490\r\n\r\nTherefore, `$?` in your code should only be `$false` if BOTH of the following conditions are met:\r\n\r\n* The preceding command emitted (at least one) error.\r\n* The command is implemented as a _binary cmdlet_ OR it is implemented as an advanced function and uses `$PSCmdlet.WriteError()` and `$PSCmdlet.ThrowTerminatingError()` to emit its error.\r\n\r\n",
      "created_at": "2022-10-21T17:32:21Z",
      "updated_at": "2022-10-21T17:32:21Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> for commands written _in PowerShell_, statement-terminating errors or `Write-Error` calls _inside_ them do _not_ cause `$?` to be set to `$false`. The only way to currently achieve that is by making your script or function an _advanced_ one and to use `$PSCmdlet.WriteError()` (non-terminating error) or `$PSCmdlet.ThrowTerminatingError()` (statement-terminating error, from the caller's perspective).\r\n\r\n\r\n@mklement0    `throw` works, and if error action preference is set to `stop` other errors act _like_ throw. \r\n\r\n```\r\nPS>  function two {\"a\"; throw; b;}\r\n\r\nPS>  two\r\na\r\nException: ScriptHalted\r\n\r\nPS>  $?\r\nFalse\r\n\r\nPS>\r\n```\r\n \r\n \r\nUsing my other example\r\n```\r\nfunction one {\r\n[CmdletBinding()]\r\nparam()\r\n1/0\r\n#  $? will now be false\r\n\"This line runs\"\r\n#  $? will now be true because the string was output\r\n}\r\n\r\nPS>  one\r\nRuntimeException:\r\nLine |\r\n   4 |  1/0\r\n     |  ~~~\r\n     | Attempted to divide by zero.\r\nThis line runs\r\n\r\nPS>  $?\r\nTrue      # even if the error is the last line the function, it is still true  \r\n```\r\n\r\ndivide by zero is a terminating error, but when ErrorActionPreference is \"continue\" it is considered to have been handled after printing it. So the function exits normally and $? says \"true\"\r\n\r\n",
      "created_at": "2022-10-22T10:55:28Z",
      "updated_at": "2022-10-22T10:55:28Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@jhoneill \r\n\r\nQuick terminology note: There are _two types_ of terminating errors:\r\n\r\n* A _statement_-terminating error (pipeline-terminating) occurs in an expression such as `1 / 0`, an exception thrown by a .NET method, an reported by a compiled cmdlet with `.ThrowTerminatingError()` (which, as noted, you can also do in PowerShell code with `$PSCmdlt.ThrowTerminatingError()`, but it is cumbersome and rarely done in practice).\r\n  * As the name implies, the scope of what is terminated by default is the current _statement_ , meaning that execution continues with the next statement.\r\n\r\n* A _script_-terminating error (runspace-terminating, fatal) `throw` by default produces ; you can promote non-terminating errors to script-terminating ones with `-ErrorAction Stop`. \r\n\r\n  * As the name (imperfectly) implies, the scope of what is terminated by default is the current _script_ - at least - but actually the entire _runspace_ the script and its callers). (In an earlier discussion, it was decided that \"script\" was good enough, and easier to understand than \"runspace\").\r\n  \r\n  * You can also promote _non_-terminating errors to script-terminating ones with `-ErrorAction Stop`. You can _additionally_ promote statement-terminating ones to script-terminating ones with `$ErrorActionPreference = 'Stop`.\r\n\r\nThis terminology isn't official but it's useful for making sense of what PowerShell does, and I've used it here and on Stack Overflow. (The names could be revisited, should they became part of the official docs; speaking of:\r\nA while back I've attempted a comprehensive overview of PowerShell's error handling: [Our Error Handing, Ourselves](https://github.com/PowerShell/PowerShell-Docs/issues/1583))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2022-10-22T13:30:01Z",
      "updated_at": "2022-10-22T13:30:01Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@jhoneill, as for your examples:\r\n\r\nYour `throw` example:\r\n\r\nInside a script or function there's no point in combining `throw` with `$?`,\r\nbecause `throw` either terminates the runspace, so no further code gets to execute, or you must use `try` / `catch`, in which case the fact that the `catch` block is triggered _by definition_ means that an error occured.\r\n\r\n(_Interactively_, `throw` fortunately does _not_ terminate the entire session, which is what your example relies on)\r\n\r\n---\r\n\r\nYour `1 / 0` example:\r\n\r\nWhat `$?` is _inside_ a script or function is irrelevant _to the caller_.\r\n\r\nThat is, whether or not you follow `1 / 0` with another statement that _function-internally_ resets `$?` before returning makes no difference:\r\n\r\n```powershell\r\nfunction foo { 1 / 0 }; foo; $? # -> $true\r\n```\r\n\r\n\r\n\r\n",
      "created_at": "2022-10-22T13:36:05Z",
      "updated_at": "2022-10-22T13:36:05Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@sumit-kakadiya so for your original issue, does setting `$ErrorActionPreference = 'Stop'` address your issue?  It seems that the generated proxy functions do not generate a terminating error such that `$?` gets set.",
      "created_at": "2022-10-24T18:14:04Z",
      "updated_at": "2022-10-24T18:14:04Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT:\r\n\r\nSwitching to `-ErrorAction Stop` isn't a _general_ solution, as with multiple inputs you may want to _continue_ processing of the remaining inputs, even if an earlier one resulted in a non-terminating error, and check `$?` afterwards.\r\n\r\nAlso, `-ErrorAction Stop` could only be handled with a `try` / `catch` - a directly following `if ($? -eq $true)` would not get to execute.\r\n\r\nUnless there is truly a bug here, the fact hat `if ($? -eq $true)` _did_ get to execute and was `$true` implies one of two things:\r\n* _No_ error was emitted.\r\n* A _non_-terminating error was emitted, but it didn't cause `$?` to be set to `$false`. (_Statement_-terminating errors _always_ set `$?` to `$false`; _functions_ can only emit such errors via `$PSCmdlet.ThrowTerminatingError()`).\r\n  * As discussed, this can be the case for _functions_ that use `Write-Error` (rather than `$PSCmdlet.WriteError()`) to emit non-terminating errors.\r\n\r\nYou mention _proxy_  functions: do they use `Write-Error`? Normally, proxy function, i.e. ones that use a steppable pipeline, _do_ set `$?` to `$false` for relayed non-terminating errors, at least if the command being proxied is a _binary_ cmdlet.\r\n\r\nIs there an aspect we're not considering, such as CDXML / implicit remoting?\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2022-10-24T21:07:09Z",
      "updated_at": "2022-10-24T21:07:09Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@mklement0 since this is ExchangeOnline, it's using implicit remoting so proxy functions are generated locally, hence was looking for a workaround in the interim.",
      "created_at": "2022-10-25T01:25:50Z",
      "updated_at": "2022-10-25T01:25:50Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @SteveL-MSFT, so just to clarify:\r\n\r\nAuto-generated functions created in the context of implicit remoting have the same problem that local functions that use `Write-Error` do, i.e. they do not properly set `$?` to `$false` for the caller, if (at least one) non-terminating error is emitted?\r\n\r\nIf (distant) memory serves, the only  way to get implicit remoting functions to generate a terminating error is to set `$ErrorActionPreference` in the _global_ scope, otherwise the module in which the functions run doesn't see it: `$global:ErrorActionPreference = 'Stop'`; saving and restoring the previous global setting is advisable. \r\n\r\nHowever, this makes errors _script_-terminating ones, which can therefore only be handled with `try` / `catch`, not via `$?`\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2022-10-25T02:00:37Z",
      "updated_at": "2022-10-25T02:06:03Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "TBH  I think as a way of testing whether ANY command had an error `$?` is flawed. It indicates \"ran to completion\" rather than \"success\", and   `try {foo}  catch {bar}`  is _more_ reliable , though it sometimes needs `-erroraction`  Style wise  we can see \"I'm going to run some code and do something if there is an error\" as soon as we see `try`   but \r\n```\r\nfoo\r\nif (-not $?) {bar}\r\n```\r\nRequires us to think back to foo when our brains fill in the $? means \"previous-ran-to-completion\"  The behaviour of $? making us write clearer, code which isn't actually any more typing isn't a bad thing.\r\n\r\n",
      "created_at": "2022-10-26T09:31:42Z",
      "updated_at": "2022-10-26T09:31:42Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@jhoneill, yeah, `$?` is only a very abstract way to test if _some_ error occurred.\r\nIn fact, it does _not_ necessarily indicate \"ran to completion\", given that a _statement_-terminating error also sets it to `$false`:\r\n\r\n```powershell\r\nGet-Item -NoSuchParameter  # a statement-terminating error reported by the parameter binder.\r\n$? # -> $false\r\n```\r\n\r\n`$?` can be handy as a shortcut for `$LASTEXITCODE -eq 0` when calling _external programs_ (but a bug relating to `2>` redirections in _Windows PowerShell_ makes that unreliable).\r\n\r\n`$?` is now _indirectly_ useful, as its value in effect is the basis of the pipeline-chain operators, `&&` and `||`:\r\n\r\n```powershell\r\nGet-Item NoSuchFile || 'dang!'   # with non-terminating error -> 'dang!' prints (too)\r\nGet-Item -NoSuchParameter || 'dang!'  # with statement-terminating error -> 'dang!' prints (too)\r\n# Unfortunately, does NOT work with functions that use Write-Error, as discussed\r\nfunction foo { Write-Error 'non-terminating error' }; foo || 'dang!'  # !! 'dang!' does NOT print\r\n```\r\n\r\nTo distinguish between non-terminating and terminating errors (whether statement- or script-terminating), you need `try` / `catch`:\r\n\r\n```powershell\r\n# With non-terminating error -> error prints, try / catch is IGNORED\r\ntry { Get-Item NoSuchFile } catch { 'I AM NEVER CALLED' }   \r\n# With terminating errors -> no error output, catch block is called.\r\ntry { Get-Item -NoSuchParameter } catch { 'CAUGHT!' }  # statement-terminating error - 'CAUGHT!' prints\r\ntry { throw 'A fit' } catch { 'CAUGHT!' }  # script-terminating error - 'CAUGHT!' prints\r\n```\r\n\r\n---\r\n\r\nAs an aside:\r\n\r\n* In the context of `$PSNativeCommandUseErrorActionPreference = $true`, the error that is emitted in response to a child process (external program) reporting a nonzero exit code, should be a statement-terminating one, so it can be also be caught with `try` / `catch`, which is currently not the case:\r\n  * #18368\r\n",
      "created_at": "2022-10-26T15:38:59Z",
      "updated_at": "2022-10-26T15:38:59Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> distinguish between non-terminating and terminating errors (whether statement- or script-terminating), you need `try` / `catch`:\r\n> \r\n> ```powershell\r\n> # With non-terminating error -> error prints, try / catch is IGNORED\r\n> try { Get-Item NoSuchFile } catch { 'I AM NEVER CALLED' }   \r\n> # With terminating errors -> no error output, catch block is called.\r\n> try { Get-Item -NoSuchParameter } catch { 'CAUGHT!' }  # statement-terminating error - 'CAUGHT!' prints\r\n> try { throw 'A fit' } catch { 'CAUGHT!' }  # script-terminating error - 'CAUGHT!' prints\r\n> ```\r\n\r\n\r\nIt gets complicated because we have \r\n-  non-terminating which just write a message to the error channel but don't terminate and can't be caught.   Since the next step runs the $? will end up as true. \r\n- \"Statement terminating\" which will normally be handled according to the value of `$errorActionPreference` in force (which may be locally set by `-errorAction`). The terminating error is treated as \"caught\"  simply by printing if the value is continue or not even printing it if it is silently continue. \r\n- \"script terminating\" one of the terminating commands - which won't be treated as caught simply by printing the message. \r\n- The powershell `throw` statement. Can be script-terminating, but if error-action is set to silently continue is considered to be handled. \r\n![image](https://user-images.githubusercontent.com/16209593/198239417-96f7ef0c-245d-448f-a69b-25f169dc66d8.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2022-10-27T09:06:31Z",
      "updated_at": "2022-10-27T09:06:31Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "My examples assume the _default_ value for `$ErrorActionPreference`, `'Continue'`\r\n\r\n> Since the next step runs the $? will end up as true.\r\n\r\nImmediately after a cmdlet call that produced at least one non-terminating error (error records written to the error stream), `$?` is _`$false`_; the `try` / `catch` enclosure doesn't change that:\r\n\r\n```powershell\r\ntry { Get-Item NoSuchFile } catch { 'I AM NEVER CALLED' }\r\n$? # -> $false\r\n```\r\n\r\n>  will normally be handled according to the value of $errorActionPreference in force (which may be locally set by -errorAction)\r\n\r\n`$ErrorActionPreference` and `-ErrorAction` are NOT equivalent, which is highly unfortunate: the former acts on _all_ error types (as you demonstrate with `throw`), the latter only on _non-terminating_ ones.\r\n\r\nResolving this asymmetry is being considered, but it would be a substantial breaking change:\r\n\r\n* #14819\r\n\r\n> \"script terminating\" one of the terminating commands - which won't be treated as caught simply by printing the message.\r\n\r\nI don't understand.\r\n\r\n\r\n\r\n",
      "created_at": "2022-10-27T12:18:39Z",
      "updated_at": "2022-10-27T12:22:08Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> `$ErrorActionPreference` and `-ErrorAction` are NOT equivalent, which is highly unfortunate: the former acts on _all_ error types (as you demonstrate with `throw`), the latter only on _non-terminating_ ones.\r\n\r\nNo,  -ErrorAction definitely changes the behaviour for terminating errors. \r\n```\r\nFunction Get-Tangent {\r\n     [cmdletbinding()]\r\n     param ($a)\r\n     $t = [math]::Tan($a)\r\n     $t\r\n     Write-Verbose \"tan of $a  is $t\"\r\n}\r\n\r\nPS>  try {Get-Tangent \"hello\" -verbose }  catch {\"Problem finding tangent\"}  #   terminating error catch works\r\nProblem finding tangent   \r\n\r\nPS>  Get-Tangent \"hello\" -verbose    # Error action continue verbose line runs \r\nMethodException:\r\nLine |\r\n   4 |      $t = [math]::Tan($a)\r\n     |      ~~~~~~~~~~~~~~~~~~~~\r\n     | Cannot convert argument \"a\", with value: \"hello\", for \"Tan\" to type \"System.Double\": \"Cannot convert value \"hello\" ...\r\nVERBOSE: tan of hello  is                     \r\n\r\nPS>  Get-Tangent \"hello\" -verbose  -ea Stop   # terminating error is no longer handled by print and continue\r\nGet-Tangent: Cannot convert argument \"a\", with value: \"hello\", for \"Tan\" to type \"System.Double\": \"Cannot convert value \"hello\" \r\n...\r\n```\r\n\r\nAnd for throw \r\n```\r\n function throwSomething {\r\n [cmdletbinding()]\r\n param()\r\n throw \"something\"\r\n \"This should not run\"\r\n}\r\n\r\nPS>  throwSomething\r\nException:\r\nLine |\r\n   4 |  throw \"something\"\r\n     |  ~~~~~~~~~~~~~~~~~\r\n     | something\r\n\r\nPS>  throwSomething -ErrorAction SilentlyContinue\r\nThis should not run\r\n\r\n```\r\n\r\nWhich is why I advise people to follow throw with return. \r\n\r\n\r\n\r\n> * [](https://github.com/PowerShell/PowerShell/issues/14819)\r\n> \r\n> > \"script terminating\" one of the terminating commands - which won't be treated as caught simply by printing the message.\r\n> \r\n> I don't understand.\r\n\r\nOK. You have an old fashioned batch file. In it you have ping with invalid parameters. But the next line of the batch file runs. Even though ping terminated unless the next line is \"check what happened and abort if ping failed\" the rest of the script runs. So here there is no such thing as a script terminating error. An error might terminate a command, but it can't stop the batch file that called it.   \r\n\r\nIn a C# program you might have the equivalent of `[int]::Parse($s)` if s contains \"one\" this will cause a terminating error, the C# program can catch the error, but if it does not the program exits with a run time failure. So all terminating errors are the same - if they are not caught errors exit the program there and then. \r\n\r\nPowerShell has something different again. \r\n`[int]::Parse($s)`  is still a terminating error. We can still catch it, it's not just information going to the error channel. \r\n `$errorActionPreference` (whether it is a global variable or set via the common parameter) decides whether and how that error will be trapped. Continue is \"Print-message resume-next\".  And its value in different scopes can change behaviour. \r\n\r\n```\r\n Function Get-Tangent {\r\n    [cmdletbinding()]\r\n    param ($a)\r\n     $ErrorActionPreference = \"stop\"\r\n    $t = [math]::Tan($a)\r\n     $t\r\n    Write-Verbose \"tan of $a  is $t\"\r\n}\r\n  \r\n>  $ErrorActionPreference = \"continue\"\r\n\r\nPS>  get-Tangent \"hello\" -verbose  ; \"boo\"\r\nGet-Tangent: Cannot convert argument \"a\", with value: \"hello\", for \"Tan\" to type \"System.Double\": \"Cannot convert value \"hello\" to type \"System.Double\". Error: \"The input string 'hello' was not in a correct format.\"\"\r\nboo\r\n\r\n```\r\nHaving action preference set to stop causes the function to exit without writing the verbose message, but when the message bubbles up to the command line where action is continue, it is printed and the next command runs. \r\n\r\nThis is what I mean by printing the message is a treated as catching it \r\n\r\nBut `write-error` with `-ea stop` or erroractionpreference set  the next command doesn't run\r\n```\r\nPS>  function one {\r\n>> write-error \"Stop\" -ea stop\r\n>> \"this won't run\"\r\n>> }\r\n\r\n\r\nPS>  one  ; \"two\"\r\none: Stop\r\n```\r\nThis makes write error return a pipeline terminating error, we can only catch it... \r\n \r\n",
      "created_at": "2022-10-27T14:50:49Z",
      "updated_at": "2022-10-27T14:50:49Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "`-ErrorAction Stop` has no effect on your example:\r\n\r\n```powershell\r\n# Prints the error message and continues. [UPDATE: No quite] Omitting -ErrorAction Stop behaves the same.\r\nGet-Tangent \"hello\" -verbose -ErrorAction Stop; 'after'\r\n\r\n# As opposed to (prints \"caught!\" only, 'after' doesn't get to execute):\r\ntry { Get-Tangent \"hello\" -verbose -ErrorAction Stop; 'after' } catch { 'caught!' }\r\n\r\n# Via $ErrorActionPreference  = 'Stop' - but UNLIKE with -ErrorAction Stop - the statement-terminating\r\n# error becomes a script-terminating one, so 'after' doesn't get to execute.\r\n& {\r\n  $ErrorActionPreference = 'Stop'\r\n  Get-Tangent \"hello\" -verbose; 'after'\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2022-10-27T15:07:53Z",
      "updated_at": "2022-10-27T17:11:15Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "As for the rest of your previous comment: no argument there, but it also drives home the need for _specific terms_ for  the _two kinds_ of _terminating errors_ that can occur in PowerShell, based on the _what the unit of execution is_ that they terminate.\r\n\r\n> [int]::Parse($s) is still a terminating error. \r\n\r\nI'm calling this a _statement_-terminating error, because (by default) it terminates _just that statement_, and continues execution.\r\n\r\nBy contrast, `throw` creates a _script_-terminating error (not a precise term, as discussed; perhaps _fatal_ would be more descriptive, without having to get too technical about what the unit of executions).\r\n\r\nIt's interesting to note that binary cmdlets cannot themselves create such errors; `.ThrowTerminatingError()` is (by default) a _statement_-terminating error.\r\n",
      "created_at": "2022-10-27T16:05:34Z",
      "updated_at": "2022-10-27T16:05:51Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "Lets out big sigh\r\n\r\n> ```powershell\r\n> # Prints the error message and continues. Omitting -ErrorAction Stop behaves the same.\r\n> Get-Tangent \"hello\" -verbose -ErrorAction Stop; 'after'\r\n> ```\r\n\r\nNo it doesn't \r\n<img width=\"565\" alt=\"image\" src=\"https://user-images.githubusercontent.com/16209593/198336840-25fa6db8-1d2b-4261-9554-9f41fed2cd9d.png\">\r\n\r\nAs far as I can tell `-ErrorAction  x` / `warningAction x`, `-verbose` , and `-confirm` does is to set the value of the preference variable in the scope of that command.  \r\n\r\n`-ErrorAction stop` in the function's scope causes the function to exit as soon as it hits an error, but outside the function where the value of `ErrorActionPreference` is different (continue), the error is printed and execution continues. \r\n\r\nAnd it doesn't matter whether $errorActionPreference is set by specifying -ErrrorAction as above  or as  variable as below\r\n<img width=\"535\" alt=\"image\" src=\"https://user-images.githubusercontent.com/16209593/198340222-c4d1458a-1803-4abc-a5d8-066c7e23b1fe.png\">\r\n\r\nWhat I can't figure out is why this varies \r\n\r\n<img width=\"655\" alt=\"image\" src=\"https://user-images.githubusercontent.com/16209593/198345771-0d672563-c825-474e-a3b8-ed6aab71504d.png\">\r\n\r\nAnd if you know I'd love to hear. \r\n\r\nThe rest as you say we agree on.   `Throw` is law unto itself. It will create a script / pipeline terminating error UNLESS the local scope has error action = Silently continue. In which case it continues silently.  This is multiple kinds of wrong, but probably too embedded to change.  I'm  not sure that anyone would say ALL of these are consistent \r\n<img width=\"424\" alt=\"image\" src=\"https://user-images.githubusercontent.com/16209593/198348016-bef27c0c-ceb4-4bc1-b513-17a53d9ccff4.png\">\r\n\r\n\r\n\r\n",
      "created_at": "2022-10-27T16:34:59Z",
      "updated_at": "2022-10-27T16:34:59Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Yes, good point, I missed one aspect:\r\n\r\nAn _uncaught_ statement-terminating error (exception) _inside_ a command _that happens to be implemented as a PowerShell script or function_, is susceptible to `-ErrorAction Stop` - indeed because `-ErrorAction Stop` is translated into a function-local `$ErrorActionPreference = 'Stop'` variable that then promotes _any_ error caused inside the function to what would _normally_ become a _script_-terminating one, but _in the context of an ADVANCED function_ turns into a _statement_-terminating one:\r\n\r\n```powershell\r\n# !! 'after' still prints\r\n& { [CmdletBinding()]param() $ErrorActionPreference = 'Stop'; 1 / 0 }; 'after'\r\n\r\n# !! Ditto - ErrorAction Stop was NOT effective at the *command level*\r\n& { [CmdletBinding()]param() 1 / 0 } -ErrorAction Stop; 'after'\r\n\r\n# !! A SIMPLE function, by contrast, does create a *script*-terminating error: 'after' does NOT print.\r\n& { param() $ErrorActionPreference = 'Stop'; 1 / 0 }; 'after'\r\n```\r\n\r\nBut that is an _implementation detail_ of the command, and, strictly speaking, a statement-terminating error that happens to occur inside a function is not the same as a deliberately emitted statement-terminating error, which requires `.ThrowTerminatingError()`.\r\n\r\nIt fits into the larger theme of cmdlet-like commands _implemented in PowerShell_ not behaving the same as _binary_ cmdlets, as is the case with `Write-Error`'s non-impact on `$?`\r\n\r\nHowever:\r\n\r\n* **Your example isn't susceptible to `-ErrorAction Stop` in the way that that parameter is _intended_** and is therefore _not effective_:\r\n  * It only aborts the _internal_ execution of the PowerShell-implemented command (due to an implementation detail), but _does not abort execution overall_ (i.e. no _script_-terminating / fatal error occurs).\r\n\r\n* By contrast, the subtlety wouldn't even arise with a _genuine_ statement-terminating error, as emitted via `.ThrowTerminatingError()`, given that it aborts the internal processing of the command right there and then by design.\r\n\r\nIn short: \r\n\r\n* **`-ErrorAction Stop` is _ineffective_ with respect to _statement_-terminating errors _at the command level_**,\r\n* but it can affect when a  command _implemented in PowerShell_ aborts processing _internally_, which is unfortunate.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2022-10-27T17:01:54Z",
      "updated_at": "2022-10-27T17:18:31Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "As for `throw`: Yes, it is the only way to _explicitly_ create a _script_-terminating (fatal) error (and therefore not available to _binary_ cmdlets), but you also get one:\r\n\r\n* with `$ErrorActionPreference = 'Stop'`, with _any_ error (with the exception of internal use in advanced functions).\r\n* with `-ErrorAction Stop`, with _non-terminating_ errors.\r\n\r\n(And, yes, you can silence / ignore even script-terminating errors with `$ErrorActionPreference = 'SilentlyContinue'` or `$ErrorActionPreference = 'Ignore'`).\r\n",
      "created_at": "2022-10-27T17:17:38Z",
      "updated_at": "2022-10-27T17:17:38Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "The bottom line with respect to authoring _advanced functions or scripts_ is:\r\nIf you want them to be well-behaved in terms of error handling (on par with _binary_ cmdlets):\r\n\r\n* Only ever use `$PSCmdlet.WriteError()` and  `$PSCmdlet.ThrowTerminatingError()` to report errors (non-terminating and statement-terminating ones, respectively).\r\n  * This ensures that `$?` is set correctly (in the _caller's_ scope).\r\n\r\n* _Silence or catch_ any errors that may result from calls to others commands in the implementation, and translate them into one of the above calls, as appropriate. \r\n  * Failure to do so can make your function / script subject to premature termination when invoked with `-ErrorAction Stop`.\r\n\r\nNote that while you're still free to use `throw` in such a function in order to emit a _script_-terminating (fatal) error, this would amount to behavior that diverges from that of a _binary_ cmdlet (which cannot emit such errors).\r\n\r\n---\r\n\r\nHere's a sample function that demonstrates the necessary techniques:\r\n\r\n```powershell\r\nFunction Get-Foo {\r\n\r\n  [CmdletBinding()]\r\n  param(\r\n    [string] $Path = '/',\r\n    [string] $NumString = '0'\r\n  )\r\n\r\n  # Relay any non-terminating errors from PowerShell-native commands via\r\n  # $PSCmdlet.WriteError(), and any terminating error (including exceptions\r\n  # from expressions / .NET method calls) via $PSCmdlet.ThrowTerminatingError()\r\n\r\n  try {\r\n\r\n    # Stderr output need not necessarily be silenced - it isn't \r\n    # affected by -ErrorAction Stop / $ErrorActionPreference = 'Stop'\r\n    & ($IsWindows ? 'cmd' : 'sh') ($IsWindows ? '/c' : '-c') 'echo stderr output >&2'\r\n\r\n    # Handle *non-terminating* errors, as happens when $Path doesn't exist.\r\n    # NOTE: \r\n    #  * If you don't care about any errors, use just -ErrorAction Ignore\r\n    #  * 2>$null does NOT work, as it would abort processing right away\r\n    #    when invoked with -ErrorAction Stop\r\n    # Any cmdlet call that results in *statement-terminating* error would be \r\n    # handled in the `catch` block.\r\n    (Get-Item $Path -ErrorVariable errs -ErrorAction SilentlyContinue).FullName\r\n    # If errors were captured, relay them via $PSCmdlet.WriteError()\r\n    if ($errs) {\r\n      foreach ($err in $errs) { $PSCmdlet.WriteError($err) }\r\n    }\r\n\r\n    # Handle a potential terminating error.\r\n    # If $NumString can't be parsed as an integer, the\r\n    # resulting exception amounts to a statement-terminating error,\r\n    # which is handled in the `catch` block.\r\n    [int]::Parse($NumString)\r\n    \r\n  }\r\n  catch {\r\n    # Relay as a statement-terminating error.\r\n    $PSCmdlet.ThrowTerminatingError($_)\r\n    # Note: To emit a *script*-terminating error instead, use:\r\n    #  throw $_\r\n  }\r\n\r\n  'Done.'\r\n\r\n}\r\n```\r\n\r\nSome sample calls:\r\n\r\n```none\r\n# No errors.\r\nPS> Get-Foo; $?\r\nstderr output\r\n/\r\n0\r\nDone.\r\nTrue\r\n```\r\n\r\n```none\r\n# Non-terminating error - note that $? is $False, function runs to completion.\r\nPS> Get-Foo NoSuchFile; $?\r\nstderr output\r\n/\r\n0\r\nDone.\r\nFalse\r\n```\r\n\r\n```none\r\n# Statement-terminating error - note that $? is $False and 'Done' doesn't get to print.\r\nPS> Get-Foo / NotANumber; $?\r\nstderr output\r\n/\r\nGet-Foo: Exception calling \"Parse\" with \"1\" argument(s): \"The input string 'NotANumber' was not in a correct format.\"\r\nFalse\r\n```\r\n\r\n```none\r\n# Both types of errors - note that $? is $False and 'Done' doesn't get to print.\r\nPS> Get-Foo NoSuchFile NotANumber; $?\r\nstderr output\r\nGet-Foo: Cannot find path '/Users/mklement/Desktop/pg/NoSuchFile' because it does not exist.\r\nGet-Foo: Exception calling \"Parse\" with \"1\" argument(s): \"The input string 'NotANumber' was not in a correct format.\"\r\nFalse\r\n```\r\n\r\n```\r\n# Effect of -ErrorAction Stop on a *non-terminating* error:\r\n#  Becomes *script*-terminating (fatal):\r\n#  * Instantly aborts the function-internal processing.\r\n#  * $? result does not get to print, because execution was aborted overall.\r\nPS> Get-Foo NoSuchFile -ErrorAction Stop; $?\r\nstderr output\r\nGet-Foo: Cannot find path '/Users/mklement/Desktop/pg/NoSuchFile' because it does not exist.\r\n```\r\n\r\n```\r\n# Effect of -ErrorAction Stop on a *statement-terminating* error:\r\n#  NO effect - $? still gets to print - execution continues.\r\nPS> Get-Foo / NotANumber -ErrorAction Stop; $?\r\nstderr output\r\n/\r\nGet-Foo: Exception calling \"Parse\" with \"1\" argument(s): \"The input string 'NotANumber' was not in a correct format.\"\r\nFalse\r\n```\r\n\r\n",
      "created_at": "2022-10-27T19:16:47Z",
      "updated_at": "2022-10-27T19:16:47Z"
    }
  ],
  "created_at": "2022-10-21T08:59:04Z",
  "labels": [
    "WG-Engine",
    "Needs-Triage"
  ],
  "number": 18343,
  "state": "open",
  "title": "$? is not set to $False even command fails",
  "updated_at": "2022-10-28T17:51:13Z"
}