{
  "_url": "https://github.com/PowerShell/PowerShell/issues/4695",
  "author": "powercode",
  "body": "In some cases where a module is loaded with\r\n`using module <path>`\r\nand there is an error loading the module, we can end up with a case where PowerShell `HadErrors` is true, but there are no errors in the `powershell.Streams.Errors`.\r\n\r\nThis causes an index out of range when we try to throw.\r\n\r\n```CSharp\r\n            var commandInfo = new CmdletInfo(\"Import-Module\", typeof(ImportModuleCommand));\r\n            var ps = PowerShell.Create(RunspaceMode.CurrentRunspace)\r\n                .AddCommand(commandInfo)\r\n                .AddParameter(\"Name\", modulePath)\r\n                .AddParameter(\"PassThru\");\r\n            var moduleInfo = ps.Invoke<PSModuleInfo>();\r\n            if (ps.HadErrors)\r\n            {\r\n                var errorRecord = ps.Streams.Error[0];\r\n                throw InterpreterError.NewInterpreterException(modulePath, typeof(RuntimeException), null,\r\n                    errorRecord.FullyQualifiedErrorId, errorRecord.ToString());\r\n            }\r\n```\r\n\r\nI haven't figured out yet what is causing the error, and it is harder to diagnose since this error masks the underlying condition.\r\n\r\nSteps to reproduce\r\n------------------\r\n\r\n```powershell\r\n# mod.psm1\r\n$c = Get-Command -CommandType Application -Name Foobar.nonexisting -ErrorAction SilentlyContinue\r\n\r\n######\r\n\r\nPS> using module .\\mod.psm1\r\n\r\n```\r\n\r\n\r\nExpected behavior\r\n-----------------\r\n\r\n```none\r\nget-command : The term 'Foobar.nonexisting' is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again.\r\nAt mod.psm1 line:1 char:1\r\n+ get-command nonexisting -CommandType Application\r\n+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n    + CategoryInfo          : ObjectNotFound: (nonexisting:String) [Get-Command], CommandNotFoundException\r\n    + FullyQualifiedErrorId : CommandNotFoundException,Microsoft.PowerShell.Commands.GetCommandCommand\r\n```\r\n\r\nOr some \r\n\r\nActual behavior\r\n---------------\r\n```\r\nAn error occurred while creating the pipeline.\r\nAt line:0 char:0\r\n```\r\n\r\nThis is a really unhelpful error message :)\r\n\r\n```none\r\n$error[0] | fl -showerror -force *\r\nMessage        : Index was out of range. Must be non-negative and less than the size of the collection.\r\n                 Parameter name: index\r\nActualValue    :\r\nParamName      : index\r\nData           : {}\r\nInnerException :\r\nTargetSite     : Void ThrowArgumentOutOfRangeException(System.ExceptionArgument, System.ExceptionResource)\r\nStackTrace     :    at System.ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource)\r\n                    at System.Collections.Generic.List`1.get_Item(Int32 index)\r\n                    at System.Management.Automation.PSDataCollection`1.get_Item(Int32 index)\r\n                    at System.Management.Automation.Language.Compiler.LoadModule(PSModuleInfo originalModuleInfo)\r\n                    at System.Management.Automation.Language.Compiler.LoadUsingsImpl(IEnumerable`1 usingAsts, Assembly[]& assemblies)\r\n                    at System.Management.Automation.Language.Compiler.GenerateLoadUsings(IEnumerable`1 usingStatements, Boolean allUsingsAreNamespaces, List`1 exprs)\r\n                    at System.Management.Automation.Language.Compiler.GenerateTypesAndUsings(ScriptBlockAst rootForDefiningTypesAndUsings, List`1 exprs)\r\n                    at System.Management.Automation.Language.Compiler.CompileSingleLambda(ReadOnlyCollection`1 statements, ReadOnlyCollection`1 traps, String funcName, IScriptExtent entryExtent, IScr\r\n                 iptExtent exitExtent, ScriptBlockAst rootForDefiningTypesAndUsings)\r\n                    at System.Management.Automation.Language.Compiler.CompileNamedBlock(NamedBlockAst namedBlockAst, String funcName, ScriptBlockAst rootForDefiningTypes)\r\n                    at System.Management.Automation.Language.Compiler.VisitScriptBlock(ScriptBlockAst scriptBlockAst)\r\n                    at System.Management.Automation.Language.Compiler.Compile(CompiledScriptBlockData scriptBlock, Boolean optimize)\r\n                    at System.Management.Automation.CompiledScriptBlockData.ReallyCompile(Boolean optimize)\r\n                    at System.Management.Automation.CompiledScriptBlockData.CompileUnoptimized()\r\n                    at System.Management.Automation.CompiledScriptBlockData.Compile(Boolean optimized)\r\n                    at System.Management.Automation.DlrScriptCommandProcessor.Init()\r\n                    at System.Management.Automation.CommandDiscovery.CreateCommandProcessorForScript(ExternalScriptInfo scriptInfo, ExecutionContext context, Boolean useNewScope, SessionStateInternal\r\n                  sessionState)\r\n                    at System.Management.Automation.CommandDiscovery.CreateScriptProcessorForSingleShell(ExternalScriptInfo scriptInfo, ExecutionContext context, Boolean useLocalScope, SessionStateIn\r\n                 ternal sessionState)\r\n                    at System.Management.Automation.CommandDiscovery.LookupCommandProcessor(CommandInfo commandInfo, CommandOrigin commandOrigin, Nullable`1 useLocalScope, SessionStateInternal sessio\r\n                 nState)\r\n                    at System.Management.Automation.CommandDiscovery.LookupCommandProcessor(String commandName, CommandOrigin commandOrigin, Nullable`1 useLocalScope)\r\n                    at System.Management.Automation.Runspaces.Command.CreateCommandProcessor(ExecutionContext executionContext, CommandFactory commandFactory, Boolean addToHistory, CommandOrigin orig\r\n                 in)\r\n                    at System.Management.Automation.Runspaces.LocalPipeline.CreatePipelineProcessor()\r\nHelpLink       :\r\nSource         : mscorlib\r\nHResult        : -2146233086\r\n```\r\n\r\nEnvironment data\r\n----------------\r\n\r\nAll versions\r\n",
  "closed_at": "2017-09-01T15:54:09Z",
  "comments": [
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "`Compiler.LoadModule` assumes that when `ps.HadErrors == true` the error stream is not empty. However, when `SilentlyContinue` is specified as the error action, the non-terminating error is not kept in `ErrorOutputPipe` of the cmdlet and thus does not appear in `ps.Streams.Error`. So when `ps.HadErrors == true` while `ps.Streams.Error` is empty, it suggests it's OK to ignore the errors because they are explicitly suppressed with `SilentlyContinue` error action.\r\n\r\nSo in my opinion, the expected behavior of `\"using module .\\mod.psm1\"` in this case should be successful, as if `ps.HaddErrors` is false.",
      "created_at": "2017-08-29T19:18:35Z",
      "updated_at": "2017-08-29T19:36:08Z"
    }
  ],
  "created_at": "2017-08-29T09:36:05Z",
  "labels": [
    "WG-Engine",
    "Issue-Discussion",
    "Resolution-Fixed"
  ],
  "number": 4695,
  "state": "closed",
  "title": "ArgumentOutOfRangeException in Compiler.LoadModule ",
  "updated_at": "2017-09-04T05:23:21Z"
}