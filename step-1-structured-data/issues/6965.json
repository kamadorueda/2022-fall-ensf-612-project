{
  "_url": "https://github.com/PowerShell/PowerShell/issues/6965",
  "author": "alx9r",
  "body": "I'm experimenting with running PowerShell unit tests in parallel.  The execution of most tests in my corpus is CPU-bound.\r\n\r\nSteps to reproduce\r\n------------------\r\n\r\nRun the following on a computer with 8 or more cores that are otherwise idle.\r\n\r\n```powershell\r\n$processorCount = [System.Environment]::ProcessorCount\r\n\r\nWrite-Host \"Processor Count: $processorCount\"\r\n\r\n$sb = {\r\n    function fibonacci {\r\n        param([int]$n)\r\n        [bigint]$a=0\r\n        [bigint]$b=1\r\n        foreach ($x in 0..$n)\r\n        {\r\n            $a,$b = $b,($a+$b)\r\n        }\r\n        $b\r\n    }\r\n    fibonacci 100000\r\n}\r\n\r\n\r\n$t_sync = Measure-Command $sb\r\n\r\n$rsp = [runspacefactory]::CreateRunspacePool(1,$processorCount)\r\n$rsp.Open()\r\n\r\nforeach ( $n in 1..$processorCount )\r\n{\r\n    $ps = 1..$n | % { [powershell]::Create().AddScript($sb) }\r\n    $ps | % { $_.RunspacePool = $rsp }\r\n\r\n    $t_begin = Measure-Command {\r\n        $invocation = $ps.BeginInvoke()\r\n    }\r\n\r\n    $t_wait = Measure-Command {\r\n        while ( $invocation.IsCompleted -contains $false )\r\n        {\r\n            sleep 0.1\r\n        }\r\n    }\r\n\r\n    [pscustomobject]@{\r\n        'n '                 = $n\r\n        'BeginInvoke() (ms)' = [int]$t_begin.TotalMilliseconds\r\n        'Wait (ms)'          = [int]$t_wait.TotalMilliseconds\r\n        'speedup'            = (($t_sync.TotalMilliseconds*$n)/$t_wait.TotalMilliseconds) | % { [math]::Round($_,3) }\r\n    }\r\n}\r\n```\r\n\r\nExpected behavior\r\n-----------------\r\n\r\nI expected the speedup and processor utilization to be somewhat proportional to the number of runspaces as long as the number of runspaces is fewer than the number of cores. \r\n\r\nActual behavior\r\n---------------\r\n\r\nThe actual speedup seems limited to ~3x even on a computer with 16 cores.  As the number of runspaces nears the number of cores, the actual processor utilization seems to peak only momentarily and settles to approximately 50%.\r\n\r\nHere are the results of a typical run:\r\n\r\n```none\r\nProcessor Count: 16\r\n\r\nn  BeginInvoke() (ms) Wait (ms) speedup\r\n-- ------------------ --------- -------\r\n 1                  1      2910   1.162\r\n 2                 15      2990   2.263\r\n 3                 15      3655   2.776\r\n 4                 38      6884   1.965\r\n 5                 38      8144   2.077\r\n 6                 38      8450   2.402\r\n 7                 44      9712   2.438\r\n 8                 53     11435   2.366\r\n 9                 53     14680   2.074\r\n10                 47     12754   2.652\r\n11                 61     19348   1.923\r\n12                 78     21901   1.853\r\n13                 92     23640    1.86\r\n14                 76     22776   2.079\r\n15                 85     27332   1.856\r\n16                136     29318   1.846\r\n```\r\n\r\nHere is the CPU utilization graph from the end of the above test run.  The peak occurred as the `n=16` run began.  The peak and plateau shape seems to be characteristic for all `n`.\r\n\r\n![image](https://user-images.githubusercontent.com/11237922/40787722-2c261ace-64a3-11e8-9ac1-1a7e57b8df48.png)\r\n\r\n\r\nEnvironment data\r\n----------------\r\n\r\n<!-- provide the output of $PSVersionTable -->\r\n\r\n```powershell\r\n> $PSVersionTable\r\nName                           Value\r\n----                           -----\r\nPSVersion                      6.1.0-preview.691\r\nPSEdition                      Core\r\nGitCommitId                    v6.1.0-preview.691\r\nOS                             Microsoft Windows 6.3.9600\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n",
  "closed_at": "2018-06-09T01:10:44Z",
  "comments": [
    {
      "author": "alx9r",
      "author_association": "NONE",
      "body": "The poor speedup seems to be caused by GCSettings.IsServerGC=false.  Changing pwsh.runtimeconfig.json to\r\n\r\n```json\r\n{\r\n  \"runtimeOptions\": {\r\n\t\"configProperties\" : {\r\n\t\t\"System.GC.Server\": true\r\n\t}\r\n  }\r\n}\r\n```\r\n\r\nsets  GCSettings.IsServerGC=true.  Running the same test as my OP with this garbage collector setting produces the following result:\r\n\r\n```\r\nProcessor Count: 16\r\n\r\nn  BeginInvoke() (ms) Wait (ms) speedup\r\n-- ------------------ --------- -------\r\n 1                  6      3706   1.652\r\n 2                 37      3779   3.239\r\n 3                 12      3558    5.16\r\n 4                  7      4178    5.86\r\n 5                  8      3746   8.169\r\n 6                  8      4141   8.869\r\n 7                  8      4167  10.283\r\n 8                 14      4763   10.28\r\n 9                 17      4841   11.38\r\n10                 23      5510  11.108\r\n11                 30      5831  11.547\r\n12                 45      5376  13.663\r\n13                 36      5736  13.873\r\n14                 63      6124  13.992\r\n15                 92      6405  14.335\r\n16                103      6849    14.3\r\n```\r\n\r\nHere is the CPU utilization graph from that run:\r\n\r\n![image](https://user-images.githubusercontent.com/11237922/41186171-bd19cd6a-6b46-11e8-945c-4875caf03654.png)\r\n\r\nThis seems consistent with the following statement from [Fundamentals of Garbage Collection](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals#background_server_garbage_collection):\r\n\r\n> Background workstation garbage collection uses one dedicated background garbage collection thread, whereas background server garbage collection uses multiple threads, typically a dedicated thread for each logical processor.\r\n\r\nI guess one garbage collector thread cannot keep up with the garbage produced by the up-to 16 worker threads in the test.",
      "created_at": "2018-06-09T01:10:44Z",
      "updated_at": "2018-06-09T01:10:44Z"
    }
  ],
  "created_at": "2018-05-31T14:36:00Z",
  "labels": [
    "WG-Engine",
    "WG-Engine-Performance",
    "Issue-Discussion"
  ],
  "number": 6965,
  "state": "closed",
  "title": "Why is the speedup of this parallelization of CPU-bound runspaces limited to ~3x?",
  "updated_at": "2018-06-09T01:10:44Z"
}