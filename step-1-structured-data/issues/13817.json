{
  "_url": "https://github.com/PowerShell/PowerShell/issues/13817",
  "author": "iRon7",
  "body": "### Runtime Construct and Populate\r\nAt design-time the syntax of an array and a dictionary (hash table) may look quiet consistent:\r\n```PowerShell\r\n$Array = @(1, 4, 9) # or just $a = 1, 4, 9\r\n$Hashtable = @{1 = 1; 2 = 3; 3 = 9}\r\n```\r\nBut at **runtime** there is quiet a difference; it is possible to *construct and populate* a array in ones:\r\n```PowerShell\r\n$Array = @(1..3 | %{ $_ * $_ })\r\n```\r\nbut it is not possible to *construct and populate* a dictionary in ones. AFAIK, I always need to construct it first and then populate it:\r\n```PowerShell\r\n$Hashtable = @{}\r\n1..3 | %{ $Hashtable[$_] = $_ * $_ }\r\n```\r\nBasically, it is not possible to put a function in a hash table syntax, like: `@{ MyFunction }`, as there is no way to get out of argument mode, in comparison with an array syntax, where it is easy to jump to expression mode `@( MyFunction )`. For the same reason it is not possible to initiate and populate the hash table from within `@{...}` during runtime.\r\n\r\nThe same limitation counts for using a .Net constructor. I can populate an array within an array constructor:\r\n```PowerShell\r\n$Array = [array](1..3 | %{ $_ * $_ })\r\n```\r\nBut it is not possible to something similar from within a hash table constructor:\r\n```PowerShell\r\n$Hashtable = [hashtable](1..3 | %{ @{ $_ = $_ * $_ } })\r\n```\r\nOr to invoke a function like:\r\n```PowerShell\r\n$Hashtable = [hashtable]MyKeyValuePairs\r\n```\r\n> InvalidArgument: Cannot convert the \"System.Object[]\" value of type \"System.Object[]\" to type \"System.Collections.Hashtable\".\r\n\r\n**Purpose**\r\nIt would be nice if the hash table constructor accepts a list KeyValuePair (hash table) objects (`Object[]]`) to better support the [Single-responsibility principle](https://en.wikipedia.org/wiki/Single-responsibility_principle).\r\n\r\n**Caveats**  \r\n* A single item (anything but a key value pair, e.g.:`@{ 1 = 'One' }, 2, @{ 3 = 'Three' }`) probably needs to be considered as a key with a `$Null` value.\r\n* Duplicate keys need to be handled, e.g.: overwrite by default and throw an error when `Set-StrictMode` is set or put the related values of the duplicated keys in an array: `[hashtable]@{ 1 = 'One' }, @{2 = 'Two' }, @{ 1 = 'Also One' }` \ud83e\udc46 `[hashtable]@{ 1 = 'One', 'Also One'; 2 = 'Two' }` \r\n\r\nThe same goes for a `[PSCustomObject]`, it isn't possible to construct and populate a new PSCustomObject in once at runtime. Meaning,  to construct a `[PSCustomObject]` and populate it with custom properties at runtime, it is required to construct the `[PSCustomObject]` first, and than populate it, using `Add-Member`. See e.g. StackOverflow question [Is it possible to do an for \u201cfor\u201d in an PSObject?](https://stackoverflow.com/a/64385996/1701026).   \r\n```PowerShell\r\n$Object = [PSCustomObject](1..3 | %{ @{ \"Name$_\" = $_ * $_ } })\r\n```\r\nThere is no error, but instead, I get a list of hash table objects (`[hashtable[]]`) rather than a single PSCustomObject  with 3 properties:\r\n```PowerShell\r\nPS C:\\> $Object.Count\r\n3\r\nPS C:\\> $Object[0].GetType()\r\nIsPublic IsSerial Name                                     BaseType\r\n-------- -------- ----                                     --------\r\nTrue     True     Hashtable                                System.Object\r\n```\r\nThere is probably a good explanation for this but I would expect a single `[PSCustomObject]` with three properties, like:\r\n```PowerShell\r\nName1 Name2 Name3\r\n----- ----- -----\r\n    1     4     9\r\n```\r\nPresuming that for a `[PSCustomObject]` it would mean a breaking change, a `[Hashtable]` constructor as purposed would still allow to do something like this:\r\n```PowerShell\r\n$Object = [PSCustomObject][Hashtable]MyPropertyFunction\r\n```\r\nOr directly:\r\n```PowerShell\r\n$Object = [PSCustomObject][Hashtable](1..3 | %{ @{ \"Name$_\" = $_ * $_ } })\r\n```\r\n\r\nThis purpose is related to #5643.  \r\nIn addition to the shortcut purpose from @iSazonov, for the object `@[]` shortcut accelerator,  `@{}` could also be an shortcut for the hash table accelerator (wishful thinking?):\r\n```PowerShell\r\n$Hashtable = @{}MyPropertyFunction\r\n$Object = @[]$Hashtable\r\n```\r\n\r\n### Design-time Construct and Populate\r\n\r\nI am not sure whether this part makes sense in a way it is a more a less intuitive/consistent with the current syntax, but I like to mention it anyways as it has at least some consistency with the runtime purpose above: \r\n\r\nTo assign an array, it is possible to just supply a list of items separated with a comma:\r\n```PowerShell\r\n$Array = 1, 2, 3\r\n```\r\nIt would be nice to also be able to do that for creating a list of key-value pairs, e.g.:\r\n```PowerShell\r\n$KeyValues = 1 = 'One', 2 = 'Two', 3 = 'Three' \r\n```\r\nKnowing that this currently this has no meaning and returns an error:\r\n```\r\nLine |\r\n   1 |  $KeyValues = 1 = 'One', 2 = 'Two', 3 = 'Three'\r\n     |               ~\r\n     | The assignment expression is not valid. The input to an assignment operator must be an object that is able to accept assignments, such as a variable or a property.\r\n```\r\nBut is could return a list of  `[hashtable]` items, similar to:\r\n```PowerShell\r\n$KeyValues = @{ 1 = 'One' }, @{ 2 = 'Two' }, @{ 3 = 'Three' }\r\n```\r\nWhich on its own could be used for simple enumerations (even there is no binary index and requires to enumerate twice):\r\n```PowerShell\r\n$KeyValues.GetEnumerator().GetEnumerator() | Foreach-Object { Write-Host ('{0} = {1}' -f $_.Key, $_.Value) }\r\n```\r\nWhich than could than be casted to a single hash table as suggested in the above **Runtime** section, like:\r\n```PowerShell\r\n$Hashtable = [hashtable](1 = 'One', 2 = 'Two', 3 = 'Three')\r\n```\r\n**Caveats**\r\n* String keys always required to be quoted: `$Hashtable = [hashtable]('One' = 1, 'Two' = 2, 'Three' = 3)`\r\n* Variable keys need to be double quoted: `$Hashtable = [hashtable](1..3 | %{ \"$_\" = $_ * $_ })`, which is probably unsafe.\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> but it is not possible to _construct and populate_ a dictionary in ones. AFAIK, I always need to construct it first and then populate it:\r\n> \r\n> ```powershell\r\n> $Hashtable = @{}\r\n> 1..3 | %{ $Hashtable[$_] = $_ * $_ }\r\n> ```\r\n\r\nIn PSv7 you can do this:\r\n\r\n```powershell\r\n1..3 | % { ($h ??= @{})[$_] = $_ * $_ }\r\n```\r\n\r\nand prior you can do\r\n\r\n```powershell\r\n1..3 | % -b { $h = @{} } -pr { $h[$_] = $_ * $_ }\r\n```\r\n\r\nPersonally if something were to be added I'd rather it be a command like:\r\n\r\n```powershell\r\n0..10 | ConvertTo-Hashtable { $_ } { $_ * $_ }\r\n```\r\n\r\nI think there's an issue or RFC for something like that but I'm not sure.",
      "created_at": "2020-10-20T14:12:42Z",
      "updated_at": "2020-10-20T14:13:02Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> at runtime there is quiet a difference; it is possible to construct and populate a array in ones:\r\n> \r\n> `$Array = @(1..3 | %{ $_ * $_ })`\r\n> but it is not possible to construct and populate a dictionary in ones. AFAIK, I always need to construct it first and then populate it:\r\n\r\n> $Hashtable = @{}\r\n> 1..3 | %{ $Hashtable[$_] = $_ * $_ }\r\n\r\nYes this is normal.  You don't need the @()  array-subexpression operator in the first one. `$Array = 1..3 | %{ $_ * $_ }` gives the same result.  FF . Multiple things naturally become [object[]] in PowerShell if you want a string array or a int array or you have to define it up front. So that's a special behaviour.  \r\n\r\nYou can concatenate hash tables.     \r\n`$h=@{} ; 1..3 | %{ $h+= @{$_ = $_* $_}}`\r\nAlso works, although it is no better. \r\n\r\n` @{ \"Name$_\" = $_ * $_ } `  Says make a one item hash table. so  `1..3 | %{ @{ \"Name$_\" = $_ * $_ } }` Says make 3 one item hash tables,  which is why it's not so great with `[PsCustomObject]. `\r\n\r\n> `$Array = [array](1..3 | %{ $_ * $_ })`\r\n\r\nSays take 1,4,9  (already an array) and cast it to array. Simple \r\n\r\n> `$H = [hashtable](1..3 | %{ @{ $_ = $_ * $_ } })`\r\n\r\nSays take an array of 3 hash tables and cast them to a hash table.  Which is unwieldy. As as a way of saying \"initialize a hash table and put this in it\" is longer than where you started. \r\n` $H = @{}; 1..3 | %{ $H[$_] = $_ * $_ }`\r\n\r\n> To assign an array, it is possible to just supply a list of items separated with a comma:\r\n> $Array = 1, 2, 3\r\n\r\nWell yes but if you were consistent with what you first wrote you'd use   `$Array = @(1, 2, 3)`\r\n\r\n> It would be nice to also be able to do that for creating a list of key-value pairs, e.g.:\r\n> `$KeyValues = 1 = 'One', 2 = 'Two', 3 = 'Three' `\r\n\r\nWell if we were being consistent  that would be `$KeyValues = @{1 = 'One', 2 = 'Two', 3 = 'Three'}`\r\n\r\nDon't forget you can write   `$KeyValues = @{$won = 'One',}`  but this     \r\n$KeyValues = $won = 'One'    \r\nalready has a meaning, so I don't think it would be nice at all.  \r\n\r\nIncidentally  \r\n> `$KeyValues = 1 = 'One', 2 = 'Two', 3 = 'Three' `\r\nAre value pairs until we take take them somewhere where one becomes a key. We might have \r\n```\r\n$KeyValues = @{One = 1    \r\n               Two = 2}\r\n```\r\nWithout needing the quotes\r\n\r\n>`$Hashtable = [hashtable](1 = 'One', 2 = 'Two', 3 = 'Three')`\r\nSo what you've done is you've replaced @ with [hashtable]   {} with () and \";\" or linebreak with \",\" and made a requirement for string literal keys to be quoted. \r\n\r\nI'm not seeing an improvement here.  @SeeminglyScience `s last suggestion is a good one and could support lots of ways of passing in the keys and values. \r\n\r\n\r\n\r\n",
      "created_at": "2020-10-21T15:09:33Z",
      "updated_at": "2020-10-21T15:09:33Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I also like @SeeminglyScience's idea, but the command should probably be named differently (and probably needs an option to create an _ordered_ hashtable or, better yet, do so by default):\r\n\r\n```powershell\r\n0..10 | New-Hashtable { $_ } { $_ * $_ }\r\n```\r\n\r\nYou could then do `[pscustomobject] (New-Hashtable ...)` if you wanted a custom object.\r\n\r\nI suppose another option would be to add a new parameter set to `New-Object` (with the two script blocks) to construct as [pscustomobject] instance by default and give it an `-AsHashtable` switch.\r\n\r\n(A `ConvertTo-Hashtable` might be nice for converting `[pscustomobject]`s to hash tables, though you could argue that syntactic sugar `[hashtable] $customObject` is called for, to complement `[pscustomobject] $hashTable`; as usual, fitting the `[ordered]` in there would be awkward; it is too late, but I really wish that PowerShell would simply _always_ use ordered hashtables; sigh).\r\n\r\n---\r\n\r\n@iRon7:\r\n\r\n> I get a list of hash table objects ([hashtable[]]) \r\n> There is probably a good explanation for this\r\n\r\nThe explanation is that PowerShell only implements the `[pscustomobject]` _syntactic sugar_ for a single operand _of type  (ordered) `[hashtable]`_ (but sadly not for a generic ``Dictionary`2``, though #13727 may change that).\r\n\r\nThe unfortunate part is that for non-supported operands the cast is the same as casting to `[psobject]`, which is a virtual no-op: it simply wraps the operand in a - largely invisible, except when not (#5579) - `[psobject]` instance.\r\n\r\nSee #13836 and #13838\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-10-22T20:24:17Z",
      "updated_at": "2020-10-22T20:24:17Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "@mklement0, Thanks for the comments and the interesting linked issues.\r\nThe idea from @SeeminglyScience's:\r\n```PowerShell\r\n0..10 | New-Hashtable { $_ } { $_ * $_ }\r\n```\r\nIs indeed nice, although it is a little confusing with input process blocks as with the `Foreach-Object` cmdlet (unless you use (but  named parameters):\r\n```PowerShell\r\n0..10 | Foreach-Object { $_ } { $_ * $_ }\r\n```\r\nBecause the first script block has a different meaning.\r\nYou could also consider:\r\n```PowerShell\r\n0..10 | New-Hashtable { @{ $_ = $_ * $_ } }\r\n```\r\nBut that causes embedded curly brackets (which is not so nice but quiet common in PowerShell, think of calculated properties)\r\n\r\n> it is too late, but I really wish that PowerShell would simply always use ordered hashtables; sigh\r\n\r\nI completely agree, I was thinking: _what would a change for this actually break?, Enumerations will be similar and you can't index on an unordered hashtable anyways (it will be very fragile as it will likely immediately break anyways when you add something). But the the problem is all the explicit (parameter) definitions which are currently in the field._\r\nOne step to this direction can be taken anyways without breaking anything yet by simply **encouraging using the IDictionary interface for parameters** #13852\r\n\r\n\r\n\r\n",
      "created_at": "2020-10-23T13:54:42Z",
      "updated_at": "2020-10-23T16:01:54Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> unless you use (but named parameters)\r\n\r\nI think the separate script blocks are preferable, and using named arguments would bring the necessary clarity, along the lines of:\r\n\r\n```powershell\r\n0..10 | New-Hashtable -KeyScriptBlock { $_ } -ValueScriptBlock { $_ * $_ }\r\n```\r\n\r\n> what would a change for this actually break?\r\n\r\nProbably not too much overall, but, in addition to `[hashtable]`-typed parameters you mention, think of cases where someone uses a \"polymorphic\" (untyped, implicitly `[object]`) parameter and then reflects on its type: `$param -is [hashtable]`.\r\n(By the way, there's a typo in your comment: you meant `IDictionary`, not `IDirectory`.)\r\n\r\nIt is similar to the idea of making PowerShell use ``System.Collections.Generic.List`1`` instead of arrays by default (see  see https://github.com/PowerShell/PowerShell/issues/5643#issuecomment-349811857): again, most scripts wouldn't notice, but some could break.\r\n\r\nBoth ideas - switching to default use of ordered hashtables and lists rather than arrays - are  prime candidates for #6745.\r\n\r\n(As an aside: ``System.Collections.Generic.Dictionary`2`` is _not_ ordered, and from what I can tell there is currently no generic counterpart to `System.Collections.Specialized.OrderedDictionary` - see https://stackoverflow.com/q/2629027/45375)\r\n\r\n---\r\n\r\nAs an aside: \r\n\r\n> you can't index on an unordered hashtable anyways (it will be very fragile\r\n\r\nYou _fundamentally_ cannot _numerically_ index into a `[hashtable]`, that only works with `[ordered]`.\r\nWith `[ordered]`, there is a risk of ambiguity with numeric keys:\r\n\r\n```powershell\r\n([ordered] @{ 1 = 'one'; 2 = 'two' })[1]\r\ntwo # !! `1` was interpreted as *positional* index, not as a key.\r\n# Workarounds: `.1` or `[[object] key]`\r\n```\r\n\r\n<blockquote><img src=\"https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded\" width=\"48\" align=\"right\"><div>Stack Overflow</div><div><strong><a href=\"https://stackoverflow.com/questions/2629027/no-generic-implementation-of-ordereddictionary\">No generic implementation of OrderedDictionary?</a></strong></div><div>There doesn't appear to be a generic implementation of OrderedDictionary (which is in the System.Collections.Specialized namespace) in .NET 3.5. Is there one that I'm missing? \r\n\r\nI've found </div></blockquote>",
      "created_at": "2020-10-23T15:47:50Z",
      "updated_at": "2020-10-23T16:07:56Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> > what would a change for this actually break?\r\n> \r\n> Probably not too much overall, but, in addition to `[hashtable]`-typed parameters you mention, think of cases where someone uses a \"polymorphic\" (untyped, implicitly `[object]`) parameter and then reflects on its type: `$param -is [hashtable]`.\r\n\r\nYeah that's a good example.  Another is a map of ints:\r\n\r\n```powershell\r\n$h = @{\r\n    1 = 2\r\n}\r\n\r\n# Check if the key `0` exists.\r\nif (-not $h[0]) { do something }\r\n```\r\n\r\nAlso worth noting that it would probably double (or at least add one third) of the allocation size since it's basically a hashtable *and also* an `ArrayList`. I've seen hashtables get pretty big in PS scripts too, *might* push some OOM (but probably unlikely).",
      "created_at": "2020-10-23T16:03:21Z",
      "updated_at": "2020-10-23T16:03:21Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "> `0..10 | New-Hashtable -KeyScriptBlock { $_ } -ValueScriptBlock { $_ * $_ }`\r\n\r\nIn relation to **Encourage using IDictionary interface for parameters #13852**, it might be preferable to create an _ordered_ dictionary by default:\r\n\r\n```PowerShell\r\n0..10 | New-Dictionary -KeyScriptBlock { $_ } -ValueScriptBlock { $_ * $_ }\r\n```\r\nand have mutual switches like `-AsHashTable` (default ordered) and `-Sorted` along with a `-CaseSensitive` switch.\r\n<sub>(Would it make sense to introduce a new PowerShell specific type, something like: `[PSDictionary]`/`[PSCustomDictionary]` with PowerShell specific features and defaults. Or is this _way out of line_?)</sub>\r\n\r\nBy the way, a **common use case** for runtime construction and populating, is (binary) indexing a collection of PSCustomObjects for a fast join with another PSCustomObjects collection, where I would like to use a syntax like this:\r\n\r\n```PowerShell\r\n$IndexByName = $PSObjectCollection | New-Dictionary -KeyScriptBlock { $_.Name } -ValueScriptBlock { $_ }\r\n```",
      "created_at": "2020-10-25T09:20:23Z",
      "updated_at": "2020-10-25T09:21:13Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I definitely like the idea of naming the cmdlet `New-Dictionary`, defaulting to an ordered hashtable (`System.Collections.Specialized.OrderedDictionary`), and the `-CaseSensitive` switch.\r\n\r\nWhen you say `-Sorted`, did you mean `-Ordered` or were you thinking of  _sorted_ dictionaries (sorted by _keys_, as opposed to _ordered_, which maintain _definition order_): ``SortedList`2`` and ``SortedDictionary`2`` (they fundamentally behave the same, but are optimized for different things).\r\n\r\nInstead of having multiple switches, I suggest a single `-As` or perhaps better `-Kind` parameter that accepts an enumeration value; e.g.:\r\n\r\n```powershell\r\nNew-Dictionary -Kind { Unordered | Ordered | Sorted | SortedList }\r\n```\r\n\r\nI don't see the need for a custom, PS-specific dictionary type, but perhaps you can elaborate on why you think it would be a good idea.\r\n",
      "created_at": "2020-10-25T17:07:33Z",
      "updated_at": "2020-10-25T17:07:33Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "@mklement0,\r\n> did you mean -Ordered or were you thinking of sorted dictionaries\r\n\r\nI really meant `Sorted`, needless to say, I am not known with most dictionary types (except for `Hashtable`, `Ordered` and `Sorted` dictionaries) and do not quiet understand the hierarchy and which type/interface is derived from which type/interface.\r\n\r\n> Instead of having multiple switches, I suggest a single `-As`\r\n\r\nA single `-As` parameter is indeed better than multiple (mutually excluded) switches, except for the `Unordered` value, as `Unordered` would also imply that the dictionary is \"Unsorted\" (which is confusing), so far I can tell, the common type name for this (anything that is not `Ordered | Sorted | SortedList`) is in fact the well known `[Hashtable]`:\r\n\r\n```PowerShell\r\nNew-Dictionary -As{ Hashtable | Ordered | Sorted | SortedList }\r\n```\r\n\r\n> a custom, PS-specific dictionary type, but perhaps you can elaborate\r\n\r\n* This is partly related to the **Encourage using IDictionary interface for parameters #13852** and your new **Support hashtable initializers for all IDictionary types #13873** issues. I can't oversee this, but using the `IDictionary` and a paramater type might be a too large filter for dictionaries that might fail when iterated further down into a script. A specific PowerShell dictionary type (with can also be used for a parameter type) might give more control over directory types that supposed to iterate well in a PowerShell script.\r\n* Get a consistent set of members, as e.g. a `[Hashtable]` has a `ContainsKey` and a `ContainsValue` method and an `[Ordered]` type not.\r\n<sub>(btw, I don't understand [why the .Net `get_key()` method is hided as using the `Keys` property could potentially conflict with keys based on a custom list during runtime](https://stackoverflow.com/questions/60810458/is-it-correct-to-use-the-get-keys-method-for-collections))</sub>\r\n* To also allow for a `[PSDictionary]@{ 1 = 'a'; 2 = 'b'; 3 = 'c' }` syntax with (runtime) features like `[PSDictionary]{ $PSObjectCollection | % { $_.Name = $_ } }` as initially purposed\r\n* A new _common_ PS-specific dictionary type might be easier to understand for a novice programmer (than dealing with all the directory types/interfaces) and with that, could be an easier way to move away from the _unordered_ hash table\r\n\r\n",
      "created_at": "2020-10-26T10:36:39Z",
      "updated_at": "2020-10-26T15:09:37Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Re `Hashtable` as the enum value: yes, that'll be more familiar to users.\r\n\r\nRe custom PS dictionary type:\r\n\r\nWhat you're describing is the purpose that the `IDictionary` interface already fulfills.\r\n\r\nYour `ContainsKey` / `ContainsValue` example is a manifestation of the challenges of working with interfaces I've tried to [summarize](https://github.com/PowerShell/PowerShell/issues/13852#issuecomment-716055320) in the linked issue: by only working with types as themselves as opposed to through interfaces, interfaces are all but invisible in PowerShell, though implementing  #13865 should help a bit.\r\n\r\nVSCode already helps you with IntelliSense, but absent that you must simply know what members the interface itself supports - as opposed to a given type implementing it, which has additional members, which differs across implementing types.\r\n\r\nRather than trying to solve with this a custom type that in effect would emulate an interface, the better solution would be for PowerShell to support interface-typed variables, so that only the interface members are accessible through them, as in C#.\r\n\r\nCome to think of it, this may be exactly what @SeeminglyScience may have been advocating in [his comment](https://github.com/PowerShell/PowerShell/issues/13852#issuecomment-715435354) (I didn't see it at the time) - though it sounds like a nontrivial undertaking, \r\n\r\nCorrect, @SeeminglyScience? Do you see the potential for breaking changes if that were to be introduced? Also, casting back to an implementing type would for symmetry also have to be supported (though `-as` may do in a pinch).\r\n\r\n",
      "created_at": "2020-10-26T17:20:11Z",
      "updated_at": "2020-10-26T17:20:11Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "Using a hashtable (dictionary) for indexing properties is often suggested [as a lookup table](https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-hashtable?view=powershell-7.1#as-a-lookup-table) to speed up object searches therefore a `New-Dictionary` cmdlet with a \"`ValueFromPipeLine`\" `-InputObject` parameter and a `-Index` (or  `-Property`, or `-Key`) string parameter might used for an easy idiomatic way to create a lookup table as suggested by [@IISResetMe](https://stackoverflow.com/users/712649/mathias-r-jessen) in the stackoverflow answer [Initialize hashtable from array of objects?](https://stackoverflow.com/a/66067700/1701026):\r\n\r\n```PowerShell\r\n<psobject> |New-Dictionary [-KeyScriptBlock <ScriptBlock>] [-ValueScriptBlock <ScriptBlock>] ...\r\n<psobject> |New-Dictionary [-Index <string>] ...\r\n```\r\n**Example**\r\n```PowerShell\r\n$ADUser = Get-ADUser |New-Dictionary -Index SAMAccountName\r\n$ADUser['JohnDoe'].SID\r\n```",
      "created_at": "2021-02-07T11:50:24Z",
      "updated_at": "2021-02-07T18:09:03Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I like the idea, @iRon7, though I would call the parameter `-Key[Property]` rather than `-Index` for clarity.",
      "created_at": "2021-02-07T14:15:51Z",
      "updated_at": "2021-02-07T14:15:51Z"
    }
  ],
  "created_at": "2020-10-20T13:48:39Z",
  "number": 13817,
  "state": "open",
  "title": "Enhance hash table syntax",
  "updated_at": "2022-05-29T13:42:17Z"
}