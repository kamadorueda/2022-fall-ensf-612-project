{
  "_url": "https://github.com/PowerShell/PowerShell/issues/15206",
  "author": "iRon7",
  "body": "Aside from the requests for a `$PSIndex`, index-variable in foreach pairing:\r\n- [Enhance foreach loops to allow iterating over multiple, parallel collections in tandem (pairs) `#14732`](https://github.com/PowerShell/PowerShell/issues/14732)\r\n- [new GPO operator .map `#15153`](https://github.com/PowerShell/PowerShell/issues/15153)\r\n- [implement indexer in loop `#14724`](https://github.com/PowerShell/PowerShell/issues/14724)\r\n- [Automatic variable for the pipeline index `#13772`](https://github.com/PowerShell/PowerShell/issues/13772)\r\n\r\nIt would also be nice if we could have parallel input **_streams_**\r\n\r\nThis:\r\n```PowerShell\r\n$Count = (1..3 |)\r\n```\r\nCauses currently an error:\r\n> An empty pipe element is not allowed.\r\n\r\nInstead it could possibly create a kind of a \"**deferred pipeline object**\" and each time the object is used/invoked it processes and returns the next item in the deferred pipeline (until it is empty where it returns an `AutomationNull`)\r\n\r\nWishful thinking:\r\n```PowerShell\r\n$Count = (1..3 |) # Initialize the deferred pipeline object\r\n$Count\r\n1\r\n$Count\r\n2\r\n$Count\r\n3\r\n$Count # Nothing (`AutomationNull`) returns\r\n```\r\n\r\nMore specific:\r\n```PowerShell\r\n$a = (Get-Connect .\\MyHughFile.txt |) # or any other long stream\r\n$b = (1..1e9 |) # In the idea, the range shouldn't affect the memory used for $b \r\n$c = (Import-Csv .\\Large.csv |)\r\n$a | ForEach-Object {\r\n    Write-Host '$a item:' $_ \r\n    Write-Host '$b item:' $b # Every time the $b is used, it processes the next item in the deferred $b pipeline\r\n    Write-Host '$c item:' $c # Ditto for $c\r\n}\r\n```",
  "closed_at": "2021-06-11T20:51:17Z",
  "comments": [
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "As @mklement0 [mentions in his thought](https://github.com/PowerShell/PowerShell/issues/14732#issuecomment-817366599) and my own feature request for \"[Calculated Objects](https://github.com/iRon7/Join-Object/issues/20)\" related to the propose [Add a Join-Object cmdlet to the standard PowerShell equipment `#14994`](https://github.com/PowerShell/PowerShell/issues/14994), the suggested \"**deferred pipeline *object***\" doesn't differ much from an `[ScriptBlock]`. The difference is in how it is invoked. Meaning that rather than returning all the output items in once, I would like to retrieve just *a single **next*** item and literally ***stall***\u00b9 the (deferred) pipeline. Also knowing that it might be confusing if a variable changes just on the fly when it has been access, it would probably make more sense to implement a distinct syntax (e.g. by using a `%` rather than a `$` for the concerned expression variable) at the invocation side.\r\n\r\n<sub>**1.** as apposed to \"**choke**\", where the items are continued to be enumerated in memory</sub>\r\n\r\nThis:\r\n```PowerShell\r\n%Count\r\n```\r\nCauses currently an error:\r\n> %Count: The term '%Count' is not recognized as a name of a cmdlet, function, script file, or executable program.\r\n> Check the spelling of the name, or if a path was included, verify that the path is correct and try again.\r\n\r\nWishful thinking:\r\n```PowerShell\r\n$Count = { 1..3 } # Initialize the deferred pipeline object\r\n%Count\r\n1\r\n%Count\r\n2\r\n%Count\r\n3\r\n%Count # Nothing (`AutomationNull`) returns\r\n```\r\n\r\nMore specific:\r\n```PowerShell\r\n$a = { Get-Connect .\\MyHughFile.txt } # or any other long stream\r\n$b = { 1..1e9 } # In the idea, the range shouldn't affect the memory used for $b \r\n$c = { Import-Csv .\\Large.csv }\r\n%a | ForEach-Object { # Not sure about this but could simply be: `Get-Connect .\\MyHughFile.txt |ForEach-Object ...`\r\n    Write-Host '$a item:' $_ \r\n    Write-Host '$b item:' %b # Every time the %b is used, it processes the next item in the deferred $b expression\r\n    Write-Host '$c item:' %c # Ditto for $c\r\n}\r\n```\r\n",
      "created_at": "2021-04-12T10:38:04Z",
      "updated_at": "2021-04-12T12:15:58Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I like the idea, although I'm not sure this is that useful, to be honest. It reminds me a lot of `-PipelineVariable`, and I don't see a lot of folks really using that, either. It's a fairly complex thing to reason through and understand, iterating multiple pipelines at once.\r\n\r\nEssentially what this would end up doing is conceptually and functionally similar to this (though, if it could be done as you describe, we'd want there to be less overhead involved).\r\n\r\n```powershell\r\nfunction next($enumerator) {\r\n    if ($enumerator.MoveNext()) {\r\n        $enumerator.Current\r\n    }\r\n}\r\n\r\n$a = (1..1e9).GetEnumerator()\r\n\r\n1..100 | ForEach-Object {\r\n    Write-Host \"Pipeline: $_\"\r\n    Write-Host \"`$a item: $(next $a)\"\r\n}\r\n```\r\n\r\nI'm also not really sure that deferring the processing is going to be that valuable. For example, in your last example with $b, it's not possible to really defer the creation of the whole array without completely re-architecting how the `..` operator itself works. As soon as that script gets processed for the first time, the array has to be created in full, and then the enumerator captured so the later parts of the script can enumerate it.\r\n\r\nOverall it's an interesting idea, but I'm concerned that it would be overly complex both to actually make use of as well as just to implement it. I think PowerShell's array creation and general pipeline semantics would need a bit of a rethink to make this a worthwhile thing to implement.",
      "created_at": "2021-04-12T13:30:47Z",
      "updated_at": "2021-04-12T13:31:17Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "@vexx32\r\n>  It reminds me a lot of `-PipelineVariable`\r\n\r\nI don't think it is the same as the `-PipelineVariable`. As the  `-PipelineVariable` assigns \"*current*\" items  (`$PSItem`) to different variables in the ***same*** pipeline and the proposal concerns ***separated*** pipelines (and assignments). Although, I do agree that the propose probably adds quite some complexity.\r\n\r\n> it's not possible to really defer the creation of the whole array without completely re-architecting how the `..` operator  itself works.\r\n\r\nI agree: it probably doesn't give any advantage for this specific statement (other than a possible syntactical advantage). Nevertheless, I wonder whether it could improve memory usage and performance\u00b9 when I would load items from e.g. a file (`1..1e9 | Set-Content .\\List.txt`). Unfortunately, I can't that this with your code example as the parentheses required for this '(Set-Content .\\List.txt`).GetEnumerator()` would already load everything in memory...\r\n\r\n<sub>**1.** in case not all lines are eventually loaded, given the example where the `ForEach` will only loop a `100` times</sub>",
      "created_at": "2021-04-12T14:39:42Z",
      "updated_at": "2021-04-12T15:06:36Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I like the idea too, but as suggested in https://github.com/PowerShell/PowerShell/issues/14732#issuecomment-817366599, perhaps it is sufficient to offer this object-at-a-time-in-lockstep processing via `ForEach-Object` rather than devising new syntax:\r\n\r\n```powershell\r\n# WISHFUL THINKING\r\n{ 0..2 }, { 'a'..'c' } | ForEach-Object -InvokeScriptBlocks -Process { '{0}: {1}' -f $_[0], $_[1] }\r\n0: a\r\n1: b\r\n2: c\r\n```\r\n\r\nThat is, switch `-InvokeScriptBlocks` would interpret _script blocks_ passed as input as the input-data _generators_ to execute step by step, in tandem, via [`SteppablePipeline`](https://docs.microsoft.com/en-US/dotnet/api/System.Management.Automation.SteppablePipeline)s (as also used for [proxy functions](https://stackoverflow.com/a/62861781/45375)), with the collected results from each step passed to the `-Process` script block.\r\n\r\n_Update_: See [@SeeminglyScience's explanation below](https://github.com/PowerShell/PowerShell/issues/15206#issuecomment-818920122) for why steppable pipelines aren't a good solution.\r\n\r\n<details>\r\n<summary>Obsolete solution attempt.</summary>\r\n\r\nI tried to put together a quick proof-of-concept, but got stuck:\r\n\r\n* I couldn't figure how to _capture_ the output from `.Process()` calls on steppable pipelines\r\n* or how to detect when they're done producing output.\r\n\r\nSee my attempt below. @SeeminglyScience, any thoughts?\r\n\r\n```powershell\r\nfunction ForEach-SteppableObject {\r\n  [CmdletBinding(PositionalBinding=$false)]\r\n  param(\r\n    [Parameter(Mandatory, Position=0)]\r\n    [scriptblock] $Process\r\n    ,\r\n    [Parameter(Mandatory, ValueFromPipeline)]\r\n    [scriptblock] $InputScriptBlock\r\n  )\r\n\r\n  begin {\r\n    $allInputScriptBlocks = [System.Collections.Generic.List[scriptblock]]::new()\r\n  }\r\n\r\n  process {\r\n    $allInputScriptBlocks.Add($InputScriptBlock)\r\n  }\r\n\r\n  end {\r\n\r\n    [PowerShell[]] $psInstances = foreach ($sb in $allInputScriptBlocks) { [powershell]::Create().AddScript($sb) }\r\n    \r\n    [System.Management.Automation.SteppablePipeline[]] $steppablePipelines = $psInstances.GetSteppablePipeline()\r\n  \r\n    $steppablePipelines.Begin($false)\r\n\r\n    do {\r\n      # !! THIS IS THE PART THAT DOESN'T WORK.\r\n      # !! The script blocks' output objects aren't being returned as part of the .Process()\r\n      # !! call, and it's unclear to me how to get it to do that.\r\n      [array] $outputs = $steppablePipelines.Process()\r\n\r\n      # Pass the outputs from this step to the -Process script block.\r\n      ForEach-Object -InputObject $outputs -Process $Process\r\n\r\n    } while (($outputs -eq $null).Count -ne $outputs.Count) \r\n    # !! This currently results in an infinite loop, because each .Process()\r\n    # !! call returns an empty array.\r\n    # !! Without input being fed to the input script blocks, it's also not\r\n    # !! clear to me how to reliably detect when a script block has stopped\r\n    # !! producing.\r\n  \r\n    $steppablePipelines.End()\r\n\r\n    $psInstances.Dispose()\r\n  }\r\n\r\n}\r\n\r\n# Sample call:\r\n# CAVEAT: Currently results in an infinite loop.\r\n{ Write-Output (1..3) }, { Write-Output ('a'..'c') } | ForEach-SteppableObject { '{0}: {1}' -f $_[0], $_[1] } \r\n```\r\n</details>",
      "created_at": "2021-04-12T21:57:23Z",
      "updated_at": "2021-04-14T21:24:43Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "Just a thought: there might be a performance advantage (for larger pipelines) if the deferred input pipeline runs really in parallel.\r\n",
      "created_at": "2021-04-13T09:16:27Z",
      "updated_at": "2021-04-13T09:16:27Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "Something like this is possible, and is probably the closest we can feasibly get:\r\n\r\n<details>\r\n\r\n<summary>PipelineEnumerable.cs</summary>\r\n\r\n```csharp\r\nusing System;\r\nusing System.Collections;\r\nusing System.Management.Automation;\r\n\r\nnamespace Example\r\n{\r\n    public class PipelineEnumerable : IEnumerable\r\n    {\r\n        private readonly ScriptBlock _scriptBlock;\r\n\r\n        private readonly IEnumerable _input;\r\n\r\n        public PipelineEnumerable(ScriptBlock scriptBlock)\r\n        {\r\n            _scriptBlock = scriptBlock;\r\n        }\r\n\r\n        public PipelineEnumerable(ScriptBlock scriptBlock, IEnumerable input) {\r\n            _scriptBlock = scriptBlock;\r\n            _input = input;\r\n        }\r\n\r\n        public IEnumerator GetEnumerator()\r\n        {\r\n            return new PipelineEnumerator(\r\n                _scriptBlock.GetSteppablePipeline(CommandOrigin.Runspace),\r\n                _input?.GetEnumerator());\r\n        }\r\n    }\r\n\r\n    public class PipelineEnumerator : IEnumerator, IDisposable\r\n    {\r\n        private readonly SteppablePipeline _pipe;\r\n\r\n        private readonly IEnumerator _input;\r\n\r\n        private IEnumerator _output;\r\n\r\n        private bool _beginWasInvoked;\r\n\r\n        private bool _processWasInvoked;\r\n\r\n        private bool _endWasInvoked;\r\n\r\n        private bool _isDisposed;\r\n\r\n        public PipelineEnumerator(SteppablePipeline pipe, IEnumerator input)\r\n        {\r\n            _pipe = pipe;\r\n            _input = input;\r\n        }\r\n\r\n        public object Current => _output.Current;\r\n\r\n        public bool MoveNext()\r\n        {\r\n            if (!_beginWasInvoked)\r\n            {\r\n                bool expectingInput = _input is not null;\r\n                _pipe.Begin(expectingInput);\r\n                _beginWasInvoked = true;\r\n                // Always forget `SteppablePipeline.Begin` has a void return for some reason.\r\n                // if (($this.out = ($res)?.GetEnumerator())?.MoveNext()) {\r\n                //     return $true\r\n                // }\r\n            }\r\n\r\n            if (_output?.MoveNext() is true)\r\n            {\r\n                return true;\r\n            }\r\n\r\n            while (_input?.MoveNext() is true)\r\n            {\r\n                Array res = _pipe.Process(_input.Current);\r\n                _processWasInvoked = true;\r\n                if ((_output = res?.GetEnumerator())?.MoveNext() is true)\r\n                {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            if (!_processWasInvoked)\r\n            {\r\n                Array res = _pipe.Process();\r\n                _processWasInvoked = true;\r\n                if ((_output = res?.GetEnumerator())?.MoveNext() is true)\r\n                {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            if (!_endWasInvoked)\r\n            {\r\n                Array res = _pipe.End();\r\n                _endWasInvoked = true;\r\n                if ((_output = res?.GetEnumerator())?.MoveNext() is true)\r\n                {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        public void Reset() => throw new NotSupportedException();\r\n\r\n        protected virtual void Dispose(bool disposing)\r\n        {\r\n            if (_isDisposed)\r\n            {\r\n                return;\r\n            }\r\n\r\n            if (disposing)\r\n            {\r\n                _pipe.Dispose();\r\n            }\r\n\r\n            _isDisposed = true;\r\n        }\r\n\r\n        public void Dispose()\r\n        {\r\n            Dispose(disposing: true);\r\n            GC.SuppressFinalize(this);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n</details>\r\n\r\n(side note, try implementing the above in a PowerShell class and you get some *real* weird errors)\r\n\r\nThis sort of highlights the problem with the idea though.  There isn't a way to defer execution after a single pipeline object has been emitted.\r\n\r\nFor example, if you were to do this:\r\n\r\n```powershell\r\n$b = [Example.PipelineEnumerable]::new{\r\n\tForEach-Object {\r\n\t\tforeach ($a in 0..3) {\r\n\t\t\t$a\r\n\t\t\t$host.UI.WriteErrorLine('ehhh')\r\n\t\t}\r\n\t}\r\n}\r\n\r\n$e = $b.GetEnumerator()\r\n$e.MoveNext()\r\n$e.Current\r\n```\r\n\r\nYou get\r\n\r\n```raw\r\nehhh\r\nehhh\r\nehhh\r\nehhh\r\nTrue\r\n0\r\n```\r\n\r\nDuring a pipeline this works because when one item is emitted to the pipeline, execution moves immediately to the next pipeline element's process block.  Without an immediate next method to call, you **must** finish the block. There is no way to suspend and resume execution of a method in dotnet.  Even when C# *seems* to do this (e.g. with async/await and `yield return`), the compiler is really completely changing the method to enable this.",
      "created_at": "2021-04-13T17:38:22Z",
      "updated_at": "2021-04-13T18:20:49Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Great stuff, @SeeminglyScience; thanks for clarifying the limitations of steppable pipelines outside of actual pipelines.\r\n\r\nI played around with parallel thread jobs as a - suboptimal - alternative: the `ForEach-CorrespondingObject` function defined below uses _queues_ to buffer output objects in order to ensure that only corresponding output objects are processed; with large output sets and widely differing output timing among the input script blocks, however, you may still run out of memory.\r\n\r\nOf course, this approach isn't efficient, because buffering happens both in the thread jobs and in the function, and output is periodically collected with a short sleep interval between tries.\r\n\r\nHere's a sample call and its output, with verbose output enabled:\r\n\r\n* Two infinite producer script blocks are supplied, which simply output as sequence of numbers, and a the processing script block simple echoes the corresponding number pairs.\r\n  * One of the blocks periodically cleans the screen, to avoid memory issues from overly long console scrollback buffers.\r\n  \r\n* Note that the producers do not run in a _tight_ loop - they sleep briefly between outputting numbers - as there is currently no batching mechanism for `Receive-Object` calls, which could cause a given call to receive objects indefinitely; see:\r\n   * #15234 - the inability to retrieve a given number of objects from a job in a consuming manner.\r\n   * #5433. - proposal to call `Receive-Object` with a timeout.\r\n\r\n```powershell\r\n{ \r\n  $i=0; $sleepMs = 10\r\n  while ($true) { \r\n    (++$i); Start-Sleep -ms $sleepMs\r\n  } \r\n}, \r\n{ \r\n  $i=0; $sleepMs = 10\r\n  while ($true) { \r\n    (++$i); Start-Sleep -ms $sleepMs\r\n    # To avoid memory problems with an overly long scrollback buffer, we clear it\r\n    # periodically.\r\n  if ($i -gt 1000 -and $i % 1000 -eq 1) { (-not $IsWindows -or [bool] $env:WT_SESSION) ? [Console]::Write(\"`e[2J`e[3J`e[H\") : [Console]::Clear(); [Console]::WriteLine('(Screen cleared.)') } \r\n  } \r\n} | ForEach-CorrespondingObject { '{0} - {1}' -f $_[0], $_[1] } -Verbose\r\n```\r\n\r\nSample output:\r\n\r\n![image](https://user-images.githubusercontent.com/588825/114780602-a0bd5900-9d45-11eb-94e8-b2344d6bd22c.png)\r\n\r\n\r\n<details>\r\n<summary><pre>ForEach-CorrespondingObject</pre> source code.</summary>\r\n\r\n```powershell\r\n# Sample call.\r\nfunction ForEach-CorrespondingObject {\r\n  [CmdletBinding(PositionalBinding = $false)]\r\n  param(\r\n    [Parameter(Mandatory, Position = 0)]\r\n    [scriptblock] $Process\r\n    ,\r\n    [Parameter(Mandatory, ValueFromPipeline)]\r\n    [scriptblock] $InputScriptBlock\r\n  )\r\n  begin {\r\n    $allInputScriptBlocks = [System.Collections.Generic.List[scriptblock]]::new()\r\n  }\r\n  process {\r\n    $allInputScriptBlocks.Add($InputScriptBlock)\r\n  }\r\n  end {\r\n    # Start a thread job for each script block.\r\n    Write-Verbose \"Launching $($allInputScriptBlocks.Count) jobs...\"\r\n    [array] $jobs = foreach ($sb in $allInputScriptBlocks) {\r\n      Start-ThreadJob -ThrottleLimit $allInputScriptBlocks.Count $sb\r\n    }\r\n    try {\r\n      # Initialize an array of output queues parallelling the jobs and\r\n      # temporarily storing their output objects.\r\n      $outputQueues = [Collections.Queue[]]::new($jobs.Count)\r\n      for ($i = 0; $i -lt $outputQueues.Count; ++$i) { $outputQueues[$i] = [Collections.Queue]::new() }\r\n      # Start collecting output.\r\n      do {\r\n        Write-Verbose \"(Re)entering output-collection loop...\"\r\n        # Sleep a little between attempts to collect output.\r\n        Start-Sleep -ms 50\r\n        # Collect currently available output.\r\n        for ($i = 0; $i -lt $jobs.Count; ++$i) {\r\n          $job = $jobs[$i]\r\n          if (-not $job) {\r\n            # Set a completed job's output queue to $null, if it is now empty.\r\n            if ($outputQueues[$i] -and $outputQueues[$i].Count -eq 0) { $outputQueues[$i] = $null }\r\n          }\r\n          else {\r\n            $done = $job.State -in 'Completed', 'Failed'\r\n            if ($job.HasMoreData) {\r\n              Write-Verbose \"Receiving from job #$i...\"\r\n              # Note: using Select-Object -First <n> is unfortunately NOT an option: see https://github.com/PowerShell/PowerShell/issues/15234\r\n              # With a tight loop as input, this can end up collecting a lot of data.\r\n              Receive-Job -Job $job | ForEach-Object {\r\n                $outputQueues[$i].Enqueue($_)\r\n              }\r\n            }\r\n            else {\r\n              Write-Verbose \"Job #$i has no data.\"\r\n            }\r\n            if (-not $job.HasMoreData -and $done) {\r\n              $jobs[$i] = $null; Remove-Job $job\r\n            }\r\n          }\r\n        }\r\n    \r\n        # Process all corresponding objects currently in the queues.\r\n        if ($activeQueues = $outputQueues -ne $null) {\r\n          $availableOutputSetsCount = [Linq.Enumerable]::Min([int[]] $activeQueues.ForEach('Count'))\r\n          Write-Verbose \"Processing $($availableOutputSetsCount) available output set(s)...\"\r\n          for ($i = 0; $i -lt $availableOutputSetsCount; ++$i) {\r\n            [array] $outputSet = foreach ($queue in $outputQueues) { $queue -and $queue.Count ? $queue.Dequeue() : $null }\r\n            # Pass each set of corresponding output objects to the -Process script block.\r\n            ForEach-Object -InputObject $outputSet -Process $Process\r\n          }\r\n        }\r\n      } while ($jobs -ne $null -or $activeQueues)\r\n    }\r\n    finally {\r\n      if ($activeJobs = $jobs -ne $null) {\r\n        Remove-Job -Job $activeJobs -Force\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</details>",
      "created_at": "2021-04-14T21:22:37Z",
      "updated_at": "2021-04-14T21:42:39Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "Thanks for the commends and prototypes.\r\n\r\n@SeeminglyScience,\r\nUnfortuanetely, I can't get you C example to run as I get an error:\r\n\r\n> ```\r\n> Line |\r\n>  132 |  Add-Type -TypeDefinition $Source\r\n>      |  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n>      | (59,49): error CS8652: The feature 'not pattern' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.                 bool expectingInput =\r\n>      | _input is not null;                                                 ^\r\n> ```\r\n\r\nThe error is quiet clear but I have you clue how to resolve this (and is I want this, maybe I should do some more playing around in a sandbox).\r\n\r\n@mklement0,\r\nI have had it some deeper thoughts and I agree that this shouldn't require a different syntax.\r\nBut I think that the `ForEach-Object` should have an additional parameter instead, something like `-SynchronouslyProcess <ScriptBlock[]>` knowing that the parallel pipelines supplied are actually not a part of the (main) pipeline but (initially) nothing more than static scriptblocks.\r\n\r\nWhat I have for testing:\r\n```PowerShell\r\n$Command = { GCI }                                              # a Synchronic Process\r\n$Sync = [hashtable]::Synchronized(@{\r\n    Command = $Command\r\n    WaitMain = [System.Threading.AutoResetEvent]::new($True)\r\n    WaitJob = [System.Threading.AutoResetEvent]::new($False)\r\n    Output = $Null\r\n})\r\n\r\n$Script = {\r\n    param($Sync)\r\n    Invoke-Command $Sync['Command'] |\r\n    ForEach-Object { \r\n        $Sync['Output'] = $_                                    # Should be a data collector?\r\n        $Null = $Sync['WaitJob'].Set()                          # For multiple parallel pipelines use a barrier?\r\n        $Null = $Sync['WaitMain'].WaitOne(10000)\r\n    }\r\n    $Sync['Output'] = &{}\r\n    $Null = $Sync['WaitJob'].Set()\r\n}\r\n\r\n$PowerShell = [PowerShell]::Create()\r\n$Null = $PowerShell.AddScript($Script).AddArgument($Sync)\r\n$Job = $PowerShell.BeginInvoke()\r\nSleep -Milliseconds 500                                         #7626 Prevent a \"Stack Empty\"\r\n1..9 |ForEach-Object {                                          # Start the main pipeline\r\n    $SyncItem = if ($Null -ne $PowerShell) {\r\n        $Null = $Sync['WaitMain'].Set()                         # For multiple parallel pipelines use a barrier?\r\n        $Null = $Sync['WaitJob'].WaitOne(5000)\r\n        $Output = $Sync['Output']                               # $powerShell.Invoke ?\r\n        If ($Null -ne $Output) {\r\n            $Output\r\n        }\r\n        else {\r\n            $PowerShell.Dispose()\r\n            $PowerShell = $Null\r\n        }\r\n    }\r\n    '{0} - {1}' -f $_, $SyncItem\r\n}\r\n```\r\n\r\nUnfortunately, the result is quite slow, besides I am lacking detailed knowledge of thread signaling, data collectors and I running into bugs (#7626) to make this stable.\r\nAnyways, for the highlevel design, I think the way to implement this, would be:\r\n- Initiate a thread for each scripblock (supplied by the proposed `-SynchronouslyProcess` parameter)\r\n- in the thread, `Invoke-Command` the scriptblock and pipe it to a `ForEach-Object`\r\n(as in the above example: `Invoke-Command $Sync['Command'] | ForEach-Object `)\r\n- For each item, (synchronized) share it with the main script (using a [`PSDataCollector`](https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.psdatacollection-1)?)\r\n- Block the pipeline in the thread (with a [`Barrier`](https://docs.microsoft.com/en-us/dotnet/api/system.threading.barrier?view=net-5.0)?) ***after*** each item\r\n- Take care of the fact that the parallel thread might run out of objects.\r\n\r\nIn the main thread:\r\n- Initiate a thread for each scripblock (see above)\r\n- Start the main pipeline (`ForEach-Object`)\r\n- ***Before*** processing each current item (`$_`), implement a barrier (shared with all the above launched threads)\r\nto wait for all the parallel thread to supply their next item.\r\n- Make the parallel items available (e.g. in a `$SyncItem[]`) and process the current\r\n\r\n<sub>(I hope it makes some sense)</sub>",
      "created_at": "2021-04-17T08:48:55Z",
      "updated_at": "2021-04-19T07:27:32Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> The error is quiet clear but I have you clue how to resolve this (and is I want this, maybe I should do some more playing around in a sandbox).\r\n\r\nYou can update PowerShell or alternatively just change any instances of that pattern (e.g. `is null` to `== null` and `is not null` to `!= null`)\r\n\r\n---\r\n\r\nre: the thread based version.  If every deferred pipeline spawns a new thread that could get out of hand pretty quickly if folks don't know how heavy it is.  On top of that you'll end up losing state since you'll also need to spawn a new runspace for each one, which I don't think the user will expect for this functionality.\r\n\r\nIt's a cool idea, but I'm not sure it solves enough problems to justify the overhead, usage complication or implementation challenge.",
      "created_at": "2021-04-19T18:29:29Z",
      "updated_at": "2021-04-19T18:29:29Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@SeeminglyScience:\r\n\r\nGood point about not being able to use the caller's state being a limitation that may surprise users, but the same applies at least in principle to `ForEach -Parallel`, where you need `$using:` to reference the caller's state. How would/can something like `$using` work with a thread-based approach?\r\n\r\nI'd expect the number of input blocks to be limited, so perhaps the thread count is even less of a concern than with `ForEach-Object -Parallel`.\r\n\r\n@iRon7:\r\n\r\n> I have had it some deeper thoughts and I agree that this shouldn't require a different syntax.\r\nBut I think that the ForEach-Object should have an additional parameter instead,\r\n\r\nYes, that was [my suggestion too](https://github.com/PowerShell/PowerShell/issues/15206#issuecomment-818269432) (I only used a different name for the proof-of-concept, because it wasn't a superset of `ForEach-Object`).\r\nI've been struggling to come up with a good switch name, however, given that it would ideally convey _two_ aspects: accepting _script blocks_ as input, and processing their output in a synchronized fashion.",
      "created_at": "2021-04-19T22:27:31Z",
      "updated_at": "2021-04-19T22:27:31Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> @SeeminglyScience:\r\n> \r\n> Good point about not being able to use the caller's state being a limitation that may surprise users, but the same applies at least in principle to `ForEach -Parallel`, where you need `$using:` to reference the caller's state. How would/can something like `$using` work with a thread-based approach?\r\n\r\nI imagine it could be used in much the same way.  This would most likely need to be implemented as a custom sort of `Out-Default`, not much different than `-Parallel` otherwise. The hard part is communicating to the user that they need it for this, and ensuring that it's worth the trouble.",
      "created_at": "2021-04-20T01:30:58Z",
      "updated_at": "2021-04-20T01:30:58Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "We discussed this in the Engine Working Group today and while this is a compelling idea, we think:\r\n\r\n- The proposed functionality doesn't mesh well with PowerShell's existing enumeration paradigm\r\n- Other alternatives exist for implementing lazy enumeration in PowerShell today\r\n- There's not a clear justification for needing to first-class a mechanism like this at a language/syntax level\r\n- The proposed pipeline syntax itself would have consequences for parsing pipelines, especially interactively\r\n- The number and extent of changes that would be required to implement this would be difficult to justify compared to the benefit of the feature\r\n- It's not clear that there's a lot of demand or potential utility for this proposal\r\n- Without an example implementation, a proposal of this size requires a clear demand or scenario to motivate it\r\n\r\nWith that in mind, we are declining the feature request.",
      "created_at": "2021-06-11T00:09:48Z",
      "updated_at": "2021-06-11T00:09:48Z"
    }
  ],
  "created_at": "2021-04-12T10:37:56Z",
  "number": 15206,
  "state": "closed",
  "title": "Deferred input pipelines",
  "updated_at": "2021-06-11T20:51:17Z"
}