{
  "_url": "https://github.com/PowerShell/PowerShell/issues/1995",
  "author": "be5invis",
  "body": "<!--\r\n\r\nIf it is a bug report:\r\n- make sure you are able to repro it on the latest released version. \r\nYou can install the latest version from https://github.com/PowerShell/PowerShell/releases\r\n- Search the existing issues.\r\n- Refer to the [FAQ](../docs/FAQ.md).\r\n- Refer to the [known issues](../docs/KNOWNISSUES.md).\r\n- Fill out the following repro template\r\n\r\nIf it's not a bug, please remove the template and elaborate the issue in your own words.\r\n-->\r\n## Steps to reproduce\r\n1. write a C program `native.exe` which acquires ARGV\r\n2. Run ``native.exe \"`\"a`\"\"``\r\n## Expected behavior\r\n\r\nARGV[1] == `\"a\"`\r\n## Actual behavior\r\n\r\nARGV[1] == `a`\r\n## Environment data\r\n\r\nWindows 10 x64\r\n\r\n```\r\nName                           Value\r\n----                           -----\r\nPSVersion                      5.1.14393.0\r\nPSEdition                      Desktop\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}\r\nBuildVersion                   10.0.14393.0\r\nCLRVersion                     4.0.30319.42000\r\nWSManStackVersion              3.0\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\n```\r\n",
  "closed_at": "2022-08-11T01:16:27Z",
  "comments": [
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "Why do you think that `\"\\\"a\\\"\"` the expected behavior? My understanding of PowerShell escapes says that the actual behavior is the correct and expected behavior. `\"`\"a`\"\"` is a pair of quotes surrounding an escaped pair of quotes surrounding an `a`, so PowerShell interprets the outer unescaped pair as \"this is a string argument\" and so drops them, then interprets the escaped pair as escaped quotes and so keeps them, leaving you with `\"a\"`. At no point was a `\\` added to the string.\n\nThe fact that Bash uses `\\` as an escape character is irrelevant. In PowerShell, the escape character is a backtick. See PowerShell [escape characters](http://ss64.com/ps/syntax-esc.html).\n\nIf you want to pass literally `\"\\\"a\\\"\"`, I believe you would use:\n\n``` powershell\n> echo `\"\\`\"a\\`\"`\"\n\"\\\"a\\\"\"\n```\n",
      "created_at": "2016-08-31T20:27:21Z",
      "updated_at": "2016-08-31T20:27:21Z"
    },
    {
      "author": "be5invis",
      "author_association": "NONE",
      "body": "@andschwa \nYes, escapes works fine for internal cmdlets, but things get weird when communicate with **native binaries**, especially on Windows.\nWhen running `native.exe \"`\"a`\"\"`, the ARGV[1] should be \n\n```\n\"a\"\n```\n\n(three characters)\n\ninstead of\n\n```\na\n```\n\n(one character).\n",
      "created_at": "2016-08-31T20:30:31Z",
      "updated_at": "2016-08-31T20:30:31Z"
    },
    {
      "author": "be5invis",
      "author_association": "NONE",
      "body": "Currently to make `native.exe` correctly receive an ARGV with two quotes and an `a` character, you have to use this weird call:\n\n``` powershell\nnative.exe \"\\`\"a\\`\"\"\n```\n",
      "created_at": "2016-08-31T20:33:34Z",
      "updated_at": "2016-08-31T20:33:42Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "Ah, I see. Re-opening.\n",
      "created_at": "2016-08-31T20:41:22Z",
      "updated_at": "2016-08-31T20:41:22Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "Out of a strong curiosity, what happens if you try a build using #1639?\n",
      "created_at": "2016-08-31T20:42:27Z",
      "updated_at": "2016-08-31T20:42:27Z"
    },
    {
      "author": "be5invis",
      "author_association": "NONE",
      "body": "@andschwa The same. You HAVE to double-esacpe to satisify both PowerShell and `CommandLineToArgvW`. This line:\n\n``` powershell\nnative.exe \"`\"a`\"\"\n```\n\nresults a StartProcess equalivent to cmd\n\n``` bat\nnative.exe \"\"a\"\"\n```\n",
      "created_at": "2016-08-31T20:47:10Z",
      "updated_at": "2016-08-31T20:47:10Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "@be5invis @douglaswth is this resolved via https://github.com/PowerShell/PowerShell/pull/2182?\n",
      "created_at": "2016-09-19T22:36:34Z",
      "updated_at": "2016-09-19T22:36:34Z"
    },
    {
      "author": "be5invis",
      "author_association": "NONE",
      "body": "No, We still need to add a backslash before a backtick-escaped double quote? This does not solve the double-escaping problem. (That is, we have to escape a double quote for both PowerShell and CommandLineToArgvW.)\n",
      "created_at": "2016-09-20T02:37:17Z",
      "updated_at": "2016-09-20T02:37:17Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "Since  `\"`\"a`\"\"` is equal to `'\"a\"'`, do you suggest that `native.exe '\"a\"'` should result in `\"\\\"a\\\"\"`?\n",
      "created_at": "2016-09-20T05:17:10Z",
      "updated_at": "2016-09-20T05:17:10Z"
    },
    {
      "author": "douglaswth",
      "author_association": "CONTRIBUTOR",
      "body": "This seems like a feature request that if implemented could break a large number of already existing PowerShell scripts that use the required double escaping, so extreme care would be required with any solution.\n",
      "created_at": "2016-09-20T07:01:01Z",
      "updated_at": "2016-09-20T07:01:01Z"
    },
    {
      "author": "be5invis",
      "author_association": "NONE",
      "body": "@vors Yes.\n@douglaswth The double-escaping is really silly: why do we need the \u201cinner\u201d escapes made in the DOS era?\n",
      "created_at": "2016-09-20T14:26:59Z",
      "updated_at": "2016-09-20T14:26:59Z"
    },
    {
      "author": "be5invis",
      "author_association": "NONE",
      "body": "@vors @douglaswth \nThis is a the C code used to show GetCommandLineW and CommandLineToArgvW results:\n\n``` c\n#include <stdio.h>\n#include <wchar.h>\n#include <Windows.h>\n\nint main() {\n  LPWSTR cmdline = GetCommandLineW();\n  wprintf(L\"Command Line : %s\\n\", cmdline);\n\n  int nArgs;\n  LPWSTR *szArglist = CommandLineToArgvW(cmdline, &nArgs);\n  if (NULL == szArglist) {\n    wprintf(L\"CommandLineToArgvW failed\\n\");\n    return 0;\n  } else {\n    for (int i = 0; i < nArgs; i++) {\n      wprintf(L\"argv[%d]: %s\\n\", i, szArglist[i]);\n    }\n  }\n  LocalFree(szArglist);\n}\n```\n",
      "created_at": "2016-09-20T14:41:56Z",
      "updated_at": "2016-09-20T14:42:31Z"
    },
    {
      "author": "be5invis",
      "author_association": "NONE",
      "body": "Here is the result\n\n```\n$ ./a \"a b\"\nCommand Line : \"Z:\\playground\\ps-cmdline\\a.exe\" \"a b\"\nargv[0]: Z:\\playground\\ps-cmdline\\a.exe\nargv[1]: a b\n\n$ ./a 'a b'\nCommand Line : \"Z:\\playground\\ps-cmdline\\a.exe\" \"a b\"\nargv[0]: Z:\\playground\\ps-cmdline\\a.exe\nargv[1]: a b\n\n$ ./a 'a\"b'\nCommand Line : \"Z:\\playground\\ps-cmdline\\a.exe\" a\"b\nargv[0]: Z:\\playground\\ps-cmdline\\a.exe\nargv[1]: ab\n\n$ ./a 'a\"b\"c'\nCommand Line : \"Z:\\playground\\ps-cmdline\\a.exe\" a\"b\"c\nargv[0]: Z:\\playground\\ps-cmdline\\a.exe\nargv[1]: abc\n\n$ ./a 'a\\\"b\\\"c'\nCommand Line : \"Z:\\playground\\ps-cmdline\\a.exe\" a\\\"b\\\"c\nargv[0]: Z:\\playground\\ps-cmdline\\a.exe\nargv[1]: a\"b\"c\n```\n",
      "created_at": "2016-09-20T14:43:41Z",
      "updated_at": "2016-09-20T14:43:41Z"
    },
    {
      "author": "douglaswth",
      "author_association": "CONTRIBUTOR",
      "body": "@be5invis I do not disagree with you about the double escaping being annoying, but I am merely saying that a change to this would need to be backward compatible with what existing PowerShell scripts use.\n",
      "created_at": "2016-09-20T17:58:48Z",
      "updated_at": "2016-09-20T17:58:48Z"
    },
    {
      "author": "be5invis",
      "author_association": "NONE",
      "body": "How many are them? I do not think there are script writers know about such double-quoting. It is a bug, not feature, and it is not documented.\n\n???? iPhone\n\n? 2016?9?21??01:58?Douglas Thrift <notifications@github.com<mailto:notifications@github.com>> ???\n\n@be5invishttps://github.com/be5invis I do not disagree with you about the double escaping being annoying, but I am merely saying that a change to this would need to be backward compatible with what existing PowerShell scripts use.\n\n## \n\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHubhttps://github.com/PowerShell/PowerShell/issues/1995#issuecomment-248381045, or mute the threadhttps://github.com/notifications/unsubscribe-auth/AAOp20f_W0mTl2YiJKi_flQBJUKaeAnLks5qsB7ZgaJpZM4JpVin.\n",
      "created_at": "2016-09-20T18:02:49Z",
      "updated_at": "2016-09-20T18:02:49Z"
    },
    {
      "author": "douglaswth",
      "author_association": "CONTRIBUTOR",
      "body": "PowerShell has been around for 9 years so there are very likely a good number of scripts out there. I found plenty of information about the need for double escaping from StackOverflow and other sources when I ran into the need for it so I don't know if I agree with your claims about nobody knowing about the need for it or that it is not documented.\n",
      "created_at": "2016-09-20T18:38:49Z",
      "updated_at": "2016-09-20T18:38:49Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "For the additional context, I'd like to talk a little bit about the implementation.\nPowerShell calls .NET API to spawn a new process, which calls a Win32 API (on windows).\n\nHere, PS creates StartProcessInfo that is uses\nhttps://github.com/PowerShell/PowerShell/blob/master/src/System.Management.Automation/engine/NativeCommandProcessor.cs#L1063\n\nThe provided API takes a single string for arguments and then it's re-parsed into an array of arguments to do the execution.\nThe rules of this re-parsing are not controlled by PowerShell. It's a Win32 API (and fortunately, it consistent in dotnet core and unix rules).\nParticularly, this contract describes the `\\` and `\"` behavior.\n\nAlthough, PowerShell may try to be smarter and provide a nicer experience, the current behavior is consistent with cmd and bash: you can copy native executable line from them and use it in powershell and it works the same.\n\n@be5invis If you know a way to enhance the expirience in non-breaking way, please line up the details. For the breaking changes, we would need to use RFC process, as described in https://github.com/PowerShell/PowerShell/blob/master/docs/dev-process/breaking-change-contract.md\n",
      "created_at": "2016-09-20T19:00:24Z",
      "updated_at": "2016-09-20T19:00:24Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "This applies to Windows, but when running commands on Linux or Unix, its strange that one needs to double escape quotes.\n\nOn Linux processes don't have a single commandline but instead an array of arguments.\nTherefore arguments in powershell should be the same as those, that are passed to the executable, instead of merging all arguments and then resplitting.\n\nEven on windows, the current behavior is inconsistent:\nIf an argument contains no spaces, it is passed unchanged.\nIf an argument contains spaces, if it will be surrounded by quotes, to keep it together through  `CommandLineToArgvW` call. => Argument is changed to meet `CommandLineToArgvW` requirement.\nBut if argument contains quotes, those are not escaped. => Argument is not changed, although `CommandLineToArgvW` requires this.\n\nI think arguments should either never be changed, or always be changed to meet `CommandLineToArgvW` requirements, but not in half of the cases.\n\nRegarding breaking-the-contract:\nAs I couldn't find any official documentation about double escaping, I'd consider this as category \"Bucket 2: Reasonable Grey Area\", so there are chances to change this, or am I wrong?\n",
      "created_at": "2016-10-03T14:13:08Z",
      "updated_at": "2016-10-03T14:24:07Z"
    },
    {
      "author": "be5invis",
      "author_association": "NONE",
      "body": "@vors This is extremely annoying if your argument is an variable or something else: you have to manually escape it before sending it into a native app.\nAn \"auto-escaping\" operator may help. like `^\"a`\"`\" -> \"a\\`\"\"`\n",
      "created_at": "2016-10-03T14:30:37Z",
      "updated_at": "2016-10-03T14:31:23Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "I think @TSlivede put it right with the inconsistency in the behavior.\n\n> I think arguments should either never be changed, or always be changed to meet CommandLineToArgvW requirements, but not in half of the cases.\n\nI'm not sure about the bucket, but even the \"clearly breaking change\" bucket could potentially be changed. We want to make PowerShell better, but backward compatibility is one of our highest priorities. That's why it's not so easy. \nWe have a great community and I'm confident that we can find consensus.\n\nWould anybody want to start an RFC process?\n",
      "created_at": "2016-10-03T16:27:36Z",
      "updated_at": "2016-10-03T16:27:36Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "It would be worth investigating the use of P/Invoke instead of .Net to start a process if that avoids the need for PowerShell to add quotes to arguments.\n",
      "created_at": "2016-10-03T17:56:38Z",
      "updated_at": "2016-10-03T17:56:38Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "@lzybkr as far as I can tell, PInvoke would not help.\nAnd this is where unix and windows APIs are different:\n\nhttps://msdn.microsoft.com/en-us/library/20y988d2.aspx (treats spaces as separators)\nhttps://linux.die.net/man/3/execvp (doesn't treat spaces as separators)\n",
      "created_at": "2016-10-03T17:58:58Z",
      "updated_at": "2016-10-03T17:58:58Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "I wasn't suggesting changing the Windows implementation.\n",
      "created_at": "2016-10-03T18:10:03Z",
      "updated_at": "2016-10-03T18:10:03Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "I'd try to avoid having platform-specific behavior here. It will hurt scripts portability.\nI think we can consider changing windows behavior in a non-breaking way. I.e. with preference variable. And then we can have different defaults or something like that.\n",
      "created_at": "2016-10-03T18:14:14Z",
      "updated_at": "2016-10-03T18:14:14Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "We're talking about calling external commands - somewhat platform dependent anyway.\n",
      "created_at": "2016-10-03T18:31:48Z",
      "updated_at": "2016-10-03T18:31:48Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "Well, i think  it can't be really platform independent, as Windows and Linux just have different ways to call executables. In Linux a process gets an argument array while on Windows a process just gets a single commandline (one string).\n(compare the more basic\n`CreateProcess` -> commandline (https://msdn.microsoft.com/library/windows/desktop/ms682425)\nand\n`execve` -> command array (https://linux.die.net/man/2/execve)\n)\n\nAs Powershell adds those quotes when arguments have spaces in them, it seems to me, that powershell tries*\\* to pass the arguments in a way, that `CommandLineToArgvW` splits the commandline to the arguments that were originally given in powershell. (This way a typical c-program gets the same arguments in its argv array as a powershell function gets as $args.)\nThis would perfectly match to just passing the arguments to the linux systemcall (as suggested via p/invoke).\n\n*\\* (and fails, as it doesn't escape quotes)\n\nPS: What is necessary to start an RFC process? \n",
      "created_at": "2016-10-03T18:36:18Z",
      "updated_at": "2016-10-03T18:50:46Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "Exactly - PowerShell tries to make sure `CommandLineToArgvW` produces the correct command and _after_ reparsing what PowerShell has already parsed.\n\nThis has been a longstanding pain point on Windows, I see on reason to bring that difficulty over to *nix.\n\nTo me, this feels like an implementation detail, not really needing an RFC. If we changed behavior in Windows PowerShell, it might warrant an RFC, but even then, the right change might be considered a (possibly risky) bug fix.\n",
      "created_at": "2016-10-03T18:51:21Z",
      "updated_at": "2016-10-03T18:51:21Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "Yes, I also think, that changing it on Linux to use a direct system call would make everyone feel more happy.\n\nI still think it should also be changed on windows,\n(Maybe by adding a preference variable for those who don't want to change their scripts)\nbecause it's just wrong now - it is a bug. If this was corrected, a direct syscall on linux wouldn't even be necessary, because any argument would reach the next process unchanged. \n\nBut as there are executables, that split the commandline in a way, incompatible to `CommandLineToArgvW`, I like @be5invis's idea of an operator for arguments - but I wouldn't create an auto-escape operator (should be default for all arguments), but instead add an operator to not escape an argument (add no quotes, don't escape anything).\n",
      "created_at": "2016-10-03T19:04:23Z",
      "updated_at": "2016-10-03T19:14:07Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "This issue just came up for us today when someone tried the following command in PowerShell and was dissing PowerShell when it didn't work but CMD did:\r\n```\r\nwmic useraccount where name='username' get sid\r\n```\r\nFrom PSCX echoargs, wmic.exe sees this:\r\n\r\n```\r\n94> echoargs wmic useraccount where name='tso_bldadm' get sid\r\nArg 0 is <wmic>\r\nArg 1 is <useraccount>\r\nArg 2 is <where>\r\nArg 3 is <name=tso_bldadm>\r\nArg 4 is <get>\r\nArg 5 is <sid>\r\n\r\nCommand line:\r\n\"C:\\Users\\hillr\\Documents\\WindowsPowerShell\\Modules\\Pscx\\3.2.2\\Apps\\EchoArgs.exe\" wmic useraccount where name=tso_bldadm get sid\r\n```\r\n\r\nSo what API does CMD.exe use to invoke the process / form the command line?  For that matter, what does --% do to make this command work?\r\n",
      "created_at": "2016-11-22T23:58:13Z",
      "updated_at": "2016-11-23T00:16:05Z"
    },
    {
      "author": "be5invis",
      "author_association": "NONE",
      "body": "@rkeithhill `CreateProcessW`. direct call. really.",
      "created_at": "2016-11-23T00:04:11Z",
      "updated_at": "2016-11-23T00:04:11Z"
    },
    {
      "author": "cspotcode",
      "author_association": "NONE",
      "body": "Why is Powershell behaving differently in these two situations?  Specifically, it is inconsistently wrapping args containing spaces in double-quotes.\r\n\r\n```powershell\r\n# Desired argv[1] is 4 characters: A, space, double-quote, B\r\n$ .\\echoargs.exe 'A \\\"B'\r\n<\"C:\\test\\echoargs.exe\" \"A \\\"B\">\r\n<A \"B>\r\n# Correct!\r\n\r\n# Desired argv value is 4 characters: A, double-quote, space, B\r\n$ .\\echoargs.exe 'A\\\" B'\r\n<\"C:\\test\\echoargs.exe\" A\\\" B>\r\n<A\"> <B>\r\n# Wrong...\r\n```\r\n\r\nThere seems to be no rhyme or reason.  In the first situation, it wraps my arg with double-quotes, but in the second situation it doesn't.  I need to know exactly when it *will* and *won't* wrap in double-quotes so that I can manually wrap (or not) in my script.\r\n\r\n.\\echoargs.exe is created by compiling the following with `cl echoargs.c`\r\n```\r\n// echoargs.c\r\n#include <windows.h>\r\n#include <stdio.h>\r\nint wmain(int argc, WCHAR** argv) {\r\n    wprintf(L\"<%ls>\\n\", GetCommandLineW());\r\n    for(int i = 1; i < argc; i++) {\r\n        wprintf(L\">%s< \", argv[i]);\r\n    }\r\n    wprintf(L\"\\n\");\r\n}\r\n```\r\n\r\nEDIT: Here's my $PSVersionTable:\r\n```\r\nName                           Value\r\n----                           -----\r\nPSVersion                      5.1.15063.296\r\nPSEdition                      Desktop\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}\r\nBuildVersion                   10.0.15063.296\r\nCLRVersion                     4.0.30319.42000\r\nWSManStackVersion              3.0\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\n```",
      "created_at": "2017-05-22T16:08:42Z",
      "updated_at": "2017-05-22T16:09:31Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "The behaviour regarding quotes changed multiple times, therefore I'd suggest to use something like this:\r\n\r\n<details><summary>Edit: Updated form below</summary>\r\nOld version:\r\n\r\n```\r\n# call helper\r\n\r\nfunction Run-Native($command) {\r\n    $env:commandlineargumentstring=($args | %{'\"'+ ($_ -replace '(\\\\*)\"','$1$1\\\"' -replace '(\\\\*)$','$1$1') + '\"'}) -join ' ';\r\n    & $command --% %commandlineargumentstring%\r\n}\r\n\r\n# some test cases\r\n\r\nRun-Native .\\echoargs.exe 'A \"B' 'A\" B'\r\nRun-Native .\\echoargs.exe 'A \"B'\r\nRun-Native .\\echoargs.exe 'A\" B'\r\nRun-Native .\\echoargs.exe 'A\\\" B\\\\\" \\'\r\n```\r\n\r\nOutput:\r\n```\r\n<\"C:\\test\\echoargs.exe\"  \"A \\\"B\" \"A\\\" B\">\r\n<A \"B> <A\" B>\r\n\r\n<\"C:\\test\\echoargs.exe\"  \"A \\\"B\">\r\n<A \"B>\r\n\r\n<\"C:\\test\\echoargs.exe\"  \"A\\\" B\">\r\n<A\" B>\r\n\r\n<\"C:\\test\\echoargs.exe\"  \"A\\\\\\\" B\\\\\\\\\\\" \\\\\">\r\n<A\\\" B\\\\\" \\>\r\n```\r\nThe first `-replace` doubles backslashes in front of quotes and adds one additional backslash, to escape the qoute.\r\nThe second `-replace` doubles backslashes at the end of the argument, such that the closing quote is not escaped.\r\n\r\n</details>\r\n\r\nThis uses `--%` (PS v3 and above), which is AFAIK the only reliable way to pass quotes to native executables.\r\n\r\n---\r\n\r\n### Edit:\r\n\r\nUpdated version of `Run-Native`, now called `Invoke-NativeCommand` (as [suggested](https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-333384152))\r\n\r\n```powershell\r\nfunction Invoke-NativeCommand() {\r\n    $command, [string[]] $argsForExe = $args\r\n    if($argsForExe.Length -eq 0){\r\n        & $command\r\n    } else {\r\n        $env:commandlineargumentstring=($argsForExe | %{\r\n            if($_ -match '^[\\w\\d\\-:/\\\\=]+$'){\r\n                $_ #don't quote nonempty arguments consisting of only letters, numbers, or one of -:/\\=\r\n            } else {\r\n                $_ <# double backslashes in front of quotes and escape quotes with backslash #> `\r\n                    -replace '(\\\\*)\"','$1$1\\\"' `\r\n                   <# opening quote after xxx= or after /xxx: or at beginning otherwise #> `\r\n                    -replace '^([\\w\\d]+=(?=.)|[/-][\\w\\d]+[:=](?=.)|^)','$1\"' `\r\n                   <# double backslashes in front of closing quote #> `\r\n                    -replace '(\\\\*)$','$1$1' `\r\n                   <# add closing quote #> `\r\n                    -replace '$','\"'\r\n            }\r\n        }) -join ' ';\r\n        & $command --% %commandlineargumentstring%\r\n    }\r\n}\r\n```\r\n\r\n(with some inspiration from [iep](https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-562334606))\r\n- doesn't quote simple switches\r\n- still works with empty args\r\n- works if no args present\r\n- should mostly work with msiexec, cmdkey, etc...\r\n- still always works for programs, that follow the [common rules](https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args?view=vs-2019#parsing-c-command-line-arguments)\r\n- does not use nonstandard `\"\"` as escaped `\"` - will therefore still not work for embedded quotes in `.bat` or msiexec arguments\r\n",
      "created_at": "2017-05-23T09:35:41Z",
      "updated_at": "2020-08-20T16:01:29Z"
    },
    {
      "author": "cspotcode",
      "author_association": "NONE",
      "body": "Thanks, I didn't know about `--%`.  is there any way to do that without leaking the environment variable to the native process? (and to any processes it might invoke)\r\n\r\nIs there a PowerShell module that implements a `Run-Native` Cmdlet for everyone to use?  This sounds like something that should be on the Powershell Gallery.  If it were good enough, it could be the basis for an RFC.",
      "created_at": "2017-05-23T14:36:03Z",
      "updated_at": "2017-05-23T14:36:03Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "\"leaking\" sounds like you are concerned about security. Notice however that the commandline is visible to child processes anyway. (For example: `gwmi win32_process |select name,handle,commandline|Format-Table` on Windows and `ps -f` on Linux)\r\n\r\nIf you still want to avoid an environment variable, you may be able to construct something using invoke-expression.\r\n\r\nRegarding the RFC:\r\nI don't think such a commandlet should be necessary, instead this should be the default behavior:\r\n\r\nhttps://github.com/PowerShell/PowerShell-RFC/issues/90",
      "created_at": "2017-05-23T15:11:20Z",
      "updated_at": "2017-05-23T15:49:28Z"
    },
    {
      "author": "cspotcode",
      "author_association": "NONE",
      "body": "I agree that PowerShell's default behavior should be fixed.  I had been pessimistically assuming that it would never change for backwards compatibility reasons, which is why I suggested writing a module.  However, I really like the way your RFC allows the old escaping behavior to be re-enabled via a preference variable.",
      "created_at": "2017-05-23T20:04:36Z",
      "updated_at": "2017-05-23T20:04:36Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Let me summarize the discussion, with just the right dose of opinion:\r\n\r\n* It's clear that we have a backward-compatibility issue, so the old behavior must continue to remain available.\r\n\r\n* @TSlivede's [RFC proposal](https://github.com/PowerShell/PowerShell-RFC/pull/90) accounts for that while commendably pointing _the way to the future_.  \r\nUnfortunately, his proposal languishes as a _PR_ as of this writing, and it hasn't even been accepted as a an RFC _draft_ yet.\r\n\r\n---\r\n\r\nBy _the future_, I mean:\r\n\r\n* PowerShell is a shell in its own right that will hopefully soon shed its `cmd.exe`-related baggage, so the only considerations that matter when it comes to calling external utilities (executables that are (typically) console/terminal applications) are:\r\n\r\n  * Arguments to pass should be specified by the rules of _PowerShell_'s argument-mode parsing _only_.\r\n\r\n  * Whatever _literals_ result from that process must be passed _as-is_ to the target executable, as _individual_ arguments.\r\n\r\n  * In other words: As a user, all you should ever need to focus on is what the result of _PowerShell_'s parsing will be, and to be able to rely on that result getting passed as-is, with PowerShell taking care of any behind-the-scenes encoding - if necessary.\r\n\r\n---\r\n\r\n_Implementing_ the future:\r\n\r\n* On _Windows_:\r\n\r\n  * For _historical_ reasons, Windows does _not_ permit passing arguments _as an array of literals_ to the target executable; instead, a _single_ string encoding _all_ arguments using _pseudo shell syntax_ is needed. What's worse, it is _ultimately up to the individual target executable to interpret that single string_ and split it into arguments.\r\n\r\n  * The best PowerShell can do is to form that single string - behind the scenes, after having performed its _own_ splitting of the command line into individual arguments - in a _predictable , standardized manner_.\r\n   \r\n   * @TSlivede's [RFC proposal](https://github.com/PowerShell/PowerShell-RFC/pull/90) proposes just that, by suggesting that PowerShell synthesize the pseudo shell command line in a manner that will [cause the Windows C/C++ runtime to recover the input arguments as-is when performing its parsing](https://docs.microsoft.com/en-us/cpp/cpp/parsing-cpp-command-line-arguments):\r\n\r\n     * Given that it's ultimately up to each target executable to interpret the command line, there is no _guarantee_ that this will work in all cases, but said rules are the most sensible choice, because _most_ existing utilities use these conventions.\r\n\r\n     * The only notable exceptions are _batch files_, which could receive special treatment, as the RFC proposal suggests.\r\n\r\n* On _Unix_ platforms:\r\n\r\n  * Strictly speaking, the issues that plague Windows argument parsing _need never arise_, because the platform-native calls for creating new processes _accept arguments as arrays of literals_ - whatever arguments PowerShell ends up with after performing its _own_ parsing should just be passed on _as-is_.  \r\nTo quote @lzybkr: \" I see no reason to bring that difficulty over to *nix.\"\r\n\r\n  * Sadly, due to the current limitations of .NET Core (CoreFX), these issues _do_ come into play, because the CoreFX API needlessly forces the anarchy of _Windows_ argument passing onto the Unix world too, by requiring use of a pseudo command line even on Unix.\r\n\r\n    * I've created [this CoreFX issue](https://github.com/dotnet/corefx/issues/23592) to ask for that problem to be remedied.\r\n\r\n   * In the meantime, given that CoreFX splits the pseudo command line back into arguments based on the C/C++ rules cited above, @TSlivede's proposal should work on Unix platforms too.\r\n",
      "created_at": "2017-08-27T23:18:28Z",
      "updated_at": "2017-08-28T03:26:38Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "As https://github.com/PowerShell/PowerShell/issues/4358 was closed as duplicate of this, here a short summary of that problem:\r\n\r\nIf an argument of an external executable with a trailing backslash contains a space, it is currently naively quoted (add quote before and after the argument). Any executable, that follows [the usual rules](https://docs.microsoft.com/en-us/cpp/cpp/parsing-cpp-command-line-arguments) interprets that like this:   \r\n<sub>From @mklement0's [comment](https://github.com/PowerShell/PowerShell/issues/4358#issuecomment-318528600):</sub>\r\n>The 2nd `\"` in `\".\\test 2\\\"`, due to being preceded by \\ is interpreted as an escaped \", causing the remainder of the string - despite a then-missing closing \" to be interpreted as part of the same argument.\r\n\r\nExample:   \r\n<sub>(from @akervinen's [comment](https://github.com/PowerShell/PowerShell/issues/4358#issuecomment-318931047))</sub>    \r\n>`PS X:\\scratch> .\\ps-args-test.exe '.\\test 2\\'`   \r\nReceived argument: `.\\test 2\"`\r\n\r\nThe Problem occurs very often, because PSReadLine adds a trailing backslash on auto-completion for directories.",
      "created_at": "2017-09-19T21:13:46Z",
      "updated_at": "2017-09-19T21:13:46Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "Since corefx seems open to producing the api we need, I'm deferring this to 6.1.0.  For 6.0.0, I'll see if we can fix #4358 ",
      "created_at": "2017-10-01T03:03:58Z",
      "updated_at": "2017-10-01T03:03:58Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@TSlivede I took your function, renamed it to `Invoke-NativeCommand` (as `Run` isn't a valid verb) and added an alias `^` and published it as a module on PowerShellGallery:\r\n\r\n```powershell\r\ninstall-module NativeCommand -scope currentuser\r\n^ ./echoargs 'A \"B' 'A\" B'\r\n```",
      "created_at": "2017-10-01T15:24:57Z",
      "updated_at": "2017-10-01T15:24:57Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT: \r\n\r\nIt's nice to have a stopgap, but a less cumbersome one would be - while we wait for a CoreFX solution - to implement the well-defined official quoting / argument-parsing rules [as detailed in @TSlivede's RFC proposal](https://github.com/TSlivede/PowerShell-RFC/blob/master/1-Draft/RFC%23%23%23%23-Improve-generation-of-argument-string-for-executables.md) ourselves preliminarily - which doesn't sound too hard to do.\r\n\r\nIf we [only fix the `\\\"` problem](https://github.com/PowerShell/PowerShell/pull/4965), argument passing is still fundamentally broken, even in simple scenarios such as the following:\r\n\r\n```sh\r\nPS> bash -c 'echo \"hi there\"'\r\nhi    # !! Bash sees the following tokens:  '-c', 'echo hi', 'there'\r\n```\r\n\r\nI think at this point there's sufficient agreement on what the behavior should be so we don't need a full RFC process, do we?\r\n\r\nThe only outstanding decision is how to deal with backward-compatibility issues in _Windows_.\r\n",
      "created_at": "2017-10-01T16:31:15Z",
      "updated_at": "2017-10-01T19:25:08Z"
    },
    {
      "author": "be5invis",
      "author_association": "NONE",
      "body": "@mklement0 @SteveL-MSFT \r\nAre we **already** broke compatibility?",
      "created_at": "2017-10-01T17:15:49Z",
      "updated_at": "2017-10-01T17:15:49Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "> The only outstanding decision is how to deal with backward-compatibility issues in Windows.\r\n\r\nYeah, but that's the hard part, right? \r\n\r\n@be5invis what do you mean by \"already broke compatibility\"? \r\n\r\nPlus, if CoreFX is on the verge of a fix in their layer, I'd rather not create a stopgap in our layer before they do.\r\n\r\nAnd as someone said above in the thread, this is annoying, but it's also pretty well-documented in the community. I'm not sure we should break it *twice* in the next two releases. ",
      "created_at": "2017-10-10T22:21:55Z",
      "updated_at": "2017-10-10T22:21:55Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@joeyaiello:\r\n\r\nIsn't the fix for #4358 already a breaking change for those who've worked around the issue by doubling the final `\\`; e.g., `\"c:\\tmp 1\\\\\"`? In other words: if you limit the changes to this fix, _two_ breaking changes are guaranteed: this one now, and another later after switching to the future CoreFx API; and while that _could_ also happen if a complete stopgap were to be implemented now, it is unlikely, given what we know about this coming change.\r\n\r\nConversely, it may hamper adoption on Unix if common quoting scenarios such as  \r\n`bash -c 'echo \"hi there\"'` don't work properly.\r\n\r\nI do realize that fixing this is a much larger breaking change, however.\r\n\r\n\r\n\r\n",
      "created_at": "2017-10-12T01:41:34Z",
      "updated_at": "2017-10-12T01:41:34Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee discussed this and agreed that minimally, using `--%` should have the same behavior as bash in that the quotes are escaped so that the native command receives them.  What is still open for debate is if this should be the default behavior w/o using `--%`",
      "created_at": "2017-11-16T00:50:01Z",
      "updated_at": "2017-11-16T00:50:01Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Note:\r\n\r\n* I'm assuming that a call to an actual shell executable is necessary when using `--%` on _Unix_, as opposed to trying to _emulate_ the shell behavior, which is what happens on _Windows_. Emulating is not hard on Windows, but would be much harder on Unix, given the many more features that would need emulating.\r\n\r\n* Using an actual shell then raises the question what shell to use: while `bash` is ubiquitous, its default behavior is not POSIX-compliant nor is it required by POSIX to be present, so for portability other scripting languages call out to `/bin/sh`, the shell executable decreed by POSIX (which _can_ be Bash running in compatibility mode (e.g., on macOS), but certainly does't have to (e.g., Dash on Ubuntu)).\r\n\r\nArguably, we should target `/bin/sh` as well - which, however, means that some Bash features - notably brace expansion, certain automatic variables, ... - won't be available\r\n\r\n---\r\n\r\n## Use of `--%`\r\n\r\nI'll use command `echoargs --% 'echo \"hi there\"'` as an example below.\r\n\r\n> the same behavior as bash in that the quotes are escaped so that the native command receives them.\r\n\r\nThe way to do _in the future, once the CoreFX API has been extended_ would be to perform no escaping at all, and instead do the following:\r\n\r\n* Create a process as follows:\r\n  * `/bin/sh` as the executable, (effectively) assigned to `ProcessStartInfo.FileName`.\r\n  * The following array of _literal_, _individual_ argument tokens as `ProcessStartInfo.ArgumentList`:\r\n    * `-c` as the 1st argument\r\n    * `echoargs 'echo \"hi there\"'` as the 2nd argument - i.e., the original command line used _literally_, exactly as specified, except that `--%` was removed.\r\n\r\nIn effect, the command line is passed through _as-is_ to the shell executable, which can then perform _its_ parsing.\r\n\r\nI understand that, in the current absence of an array-based way to pass literal arguments, we need to combine `-c` and  `echoargs 'echo \"hi there\"'` into a _single_ string _with escaping_, regrettably _solely for the benefit of the CoreFX API_, which, when it comes time to create the actual process, then _reverses_ this step and splits the single string back into literal tokens - and ensuring that this reversal always results in the original list of literal tokens is the challenging part.\r\n\r\nAgain: The only reason to involve escaping here at all is due to the current CoreFX limitation.\r\nTo work with this limitation, the following single, escaped string must therefore be assigned to  the `.Arguments` property of a `ProcessStartInfo` instance, with the escaping performed as specified by [Parsing C++ Command-Line Arguments](https://docs.microsoft.com/en-us/cpp/cpp/parsing-cpp-command-line-arguments):  \r\n  * `/bin/sh` as the executable, (effectively) assigned to `ProcessStartInfo.FileName`.\r\n  * The following single, escaped string as the value of `ProcessStartInfo.Arguments`:  \r\n`-c \"echoargs 'echo \\\"hi there\\\"'\"` \r\n\r\n ## Default behavior\r\n\r\n> What is still open for debate is if this should be the default behavior w/o using --%\r\n\r\nThe default behavior on Unix should be very different:\r\n\r\n* **No escaping considerations _other than PowerShell's own_ should ever come into play** (except on _Windows_, where that cannot be avoided, sadly; but there the MS C++ rules are the way to go, _to be applied behind the scenes_; failing that, `--%` provides an escape hatch).\r\n\r\n* **Whatever arguments _PowerShell_ ends up with, after its own parsing, must be passed as an _array of literals_**, via the upcoming `ProcessStartInfo.ArgumentList` property.\r\n\r\nApplied to the example without `--%`: `echoargs 'echo \"hi there\"'`:\r\n\r\n* PowerShell performs its usual parsing and ends up with the following 2 arguments:\r\n  * `echoargs`\r\n  * `echo \"hi there\"` (single quotes - which only had syntactical function to _PowerShell_, removed)\r\n\r\n* `ProcessStartInfo` is then populated as follows, with the upcoming CoreFX extension in place:\r\n\r\n   * `echoargs` as the (effective) `.FileName` property value\r\n  * _Literal_ `echo \"hi there\"` as the only element to add to the `Collection<string>` instance exposed by `.ArgumentList`.\r\n\r\nAgain, in the absence of `.ArgumentList` that is not an option _yet_, but _in the interim_ the same MS C++-compliant auxiliary escaping as described above could be employed.\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2017-11-16T14:54:15Z",
      "updated_at": "2017-11-16T14:54:15Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "@SteveL-MSFT \r\nAs I already mentioned at [Make the stop-parsing symbol (--%) work on Unix (#3733)](https://github.com/PowerShell/PowerShell/issues/3733) I'd strongly advise against changing the behavior of `--%`.\r\n\r\nIf some special functionality for `/bin/sh -c` is needed *please* use a different symbol and leave `--%` the way it is!",
      "created_at": "2017-11-16T15:29:59Z",
      "updated_at": "2017-11-16T15:34:38Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@TSlivede: \r\n\r\n_If_ something `--%`-_like_ is implemented on Unix - and with native globbing and a generally more command-line-savvy crowd on Unix I perceive less of a need for it - then choosing a _different symbol_ - such as `--$` - probably makes sense (sorry, I'd lost track of all aspects of this lengthy, multi-issue debate).\r\n\r\nDifferent symbols would also serve as visually conspicuous reminders that non-portable _platform-specific_ behavior is being invoked.\r\n\r\nThat leaves the question what PowerShell should do when it comes across `--%` on Unix and `--$` on Windows.\r\n\r\n\r\n",
      "created_at": "2017-11-16T22:13:33Z",
      "updated_at": "2017-11-16T22:13:33Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "I'm fine leaving `--%` as-is.  Introducing something like `--$` which calls out to /bin/sh and I guess cmd.exe on Windows may be a good way to solve this.",
      "created_at": "2017-11-16T22:54:11Z",
      "updated_at": "2017-11-16T22:54:11Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "No chance of creating a cmdlet for these behaviors?",
      "created_at": "2017-11-17T03:38:04Z",
      "updated_at": "2017-11-17T03:38:04Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@iSazonov are you suggesting something like `Invoke-Native`?  Not sure I'm a fan of that.",
      "created_at": "2017-11-17T03:51:00Z",
      "updated_at": "2017-11-17T03:51:00Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Yes, like `Start-Native`. \r\nAs a joke :-), do you not like cmdlets in PowerShell?\r\n\r\nIn Build.psm1 we have `Start-NativeExecution` with link to  https://mnaoumov.wordpress.com/2015/01/11/execution-of-external-commands-in-powershell-done-right/",
      "created_at": "2017-11-17T04:03:46Z",
      "updated_at": "2017-11-17T04:03:46Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT \r\n\r\n> I'm fine leaving --% as-is. \r\n\r\nI think we all agree that `--%` must continue to behave the way it does on _Windows_.\r\n\r\nOn _Unix_, by contrast, this behavior makes no sense, as I've tried to demonstrate [here](https://github.com/PowerShell/PowerShell/issues/3733#issue-227180792) - in short:\r\n  * single quotes aren't being handled correctly\r\n  * the only way to reference environment variable is as _cmd.exe-style_ (`%var%`)\r\n  * important native features such as  globbing and word-splitting don't work.\r\n\r\nThe primary motivation for introducing `--%` was, if I understand correctly, to enable the _reuse of existing `cmd.exe` command lines_ as-is.\r\n\r\n* As such, `--%` is useless on Unix with its current behavior.\r\n* _If_ we wanted an _analogous_ feature on Unix, it would have to be `/bin/sh -c`-based, as proposed above, probably using a different symbol.\r\n\r\nI don't think there is a need for a `cmd /c`-based feature on Windows, as `--%` has that _mostly_ covered, arguably in a manner that is _good enough_.\r\n@TSlivede has pointed out that not all shell features are being emulated, but in practice that appears not to be a concern (e.g., variable-value substitutions such as `%envVar:old=new%` aren't supported,  `^` isn't an escape char., and use of `--%` is limited to a _single_ command - no use of `cmd.exe`'s redirection and control operators; that said, I don't think `--%` was ever meant to emulate entire command _lines_).\r\n\r\nAs such, something like `--$` - if implemented - would be the Unix _counterpart_ to `--%`.\r\n\r\n**In any event, at the very least the [`about_Parsing` help topic](https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/About/about_Parsing.md) deserves a conspicuous warning that `--%` will be useless on Unix** in all but a few cases.\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2017-11-17T11:37:02Z",
      "updated_at": "2017-11-17T11:37:02Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@iSazonov It may make sense to have `Start-Native` to handle some specific scenarios, but we should try to improve PowerShell so that using native exes is more natural and predictable",
      "created_at": "2017-11-17T17:08:49Z",
      "updated_at": "2017-11-17T17:08:49Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee reviewed this and agree that `--%` should mean treat the arguments as they would on their relevant platforms which means they behavior differently on Windows and Linux, but consistent within Windows and consistent within Linux.  It would be more confusing to the user to introduce a new sigil.  We will leave implementation to the engineer on how to enable this.\r\n\r\nCross platform scripts would have to be aware of this difference in behavior, but it seems unlikely users would hit this.  If the user feedback is that there is a need due to more cross platform usage, then we can revisit introducing a new sigil.",
      "created_at": "2018-01-03T23:50:49Z",
      "updated_at": "2018-01-03T23:50:49Z"
    },
    {
      "author": "mpawelski",
      "author_association": "NONE",
      "body": "For the second time I've been bitten by these native vs cmdlets string argument parsing differences when used [ripgrep](https://github.com/BurntSushi/ripgrep).\r\n\r\nHere is result of powershell calls (echo.exe is from \"C:\\Program Files\\Git\\usr\\bin\\echo.exe\")\r\n\r\nNow I know I should watch out for this `\"` quirk:\r\n```\r\n> echo.exe '\"test'\r\ntest\r\n```\r\nBut this quirk is beyond me...\r\n```\r\necho.exe '^\\+.+;'\r\n^\\+.+;\r\necho.exe '^\\+.*;'\r\n^+.*;\r\n```\r\nIn second case I need to put double `\\` to pass `\\` to native command, in first case I don't need to do it \ud83d\ude11\r\n\r\nI understand this would be a breaking change to change this behavior so there won't be a difference between cmlets and native commands. However, I think quirks like this is something that puts people off from using powershell as default shell.",
      "created_at": "2019-03-18T12:21:05Z",
      "updated_at": "2019-03-18T14:39:15Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@mpawelski I just tried this on my Windows box with git 2.20.1.vfs.1.1.102.gdb3f8ae and it doesn't repro for me with 6.2-RC.1.  Ran it several times and it consistently echos `^\\+.+;`",
      "created_at": "2019-03-18T16:50:02Z",
      "updated_at": "2019-03-18T16:50:02Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT, I think that @mpawelski accidentally specified the same command twice. You'll see the problem if you pass `'^\\\"+.*;'` for instance - note the `\\\"` part - with the - reasonable - expectation that the content of the single-quoted string will be passed through as-is, so that the external target program sees `^\\\"+.*;` as the argument's value:\r\n\r\n```powershell\r\n# Note how the \"\\\" char. is eaten.\r\nPS> bash -c 'printf %s \"$1\"' - '^\\\"+.*;'\r\n^\"+.*; \r\n\r\n#\"# Running the very same command from Bash does NOT exhibit the problem:\r\n$ bash -c 'printf %s \"$1\"' - '^\\\"+.*;'\r\n^\\\"+.*; \r\n```\r\n",
      "created_at": "2019-03-18T17:13:47Z",
      "updated_at": "2019-03-18T17:20:55Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "> --% was, if I understand correctly, to enable the reuse of existing cmd.exe command lines as-is.\r\n\r\nThat's not quite it.  `--%` was introduced because many Windows command line utils take args that are interpreted by PowerShell which completely fubars the invocation of the utility.  This can sour folks quick if they can no longer easily use their favorite native utils.  If I had a quarter for every time I've answered questions on SO and elsewhere RE native exe commands that don't work right because of this issue, I could probably take the family out to dinner at Qoba.  :-)  For instance, `tf.exe` allows `;` as part of specifying a workspace.  Git allows `{}` and `@~1`, etc, etc, etc.  \r\n\r\n`--%` was added to tell PowerShell to NOT parse the rest of the command line - just send it \"as-is\" to the native exe.  With the one rub, allow variables using the cmd env var syntax.  It is a bit ugly but man, it really, really comes in handy still on Windows.\r\n\r\nRE making this a cmdlet, I'm not sure I see how that works. `--%` is a signal to the parser to dumb down the parsing until EOL..\r\n\r\nFrankly, as a long time user of PowerShell and this feature in particular, it makes sense to me to use the same operator on other platforms to simply mean - dumb down the parsing until EOL.  There is the issue of how to allow some form of variable substitution.  Even though it feels a bit ugly, on macOS/Linux you could take %envvar% and substitute the value of any corresponding env var.  Then it could be portable between platforms.\r\n\r\nThe thing is, if you don't do this then you wind up with conditional code - not exactly what I'd call portable:\r\n```\r\n$env:Index = 1\r\nif ($IsWindows) {\r\n    git show --% @~%Index%\r\n}\r\nelse {\r\n    git show --$ @~$Index\r\n}\r\n```\r\n\r\nI'd prefer this work on all platforms:\r\n```\r\n$env:Index = 1\r\ngit show --% @~%Index%\r\n```\r\n\r\nThe behavior on Windows has to remain as-is because compatibility.  ",
      "created_at": "2019-03-22T04:45:54Z",
      "updated_at": "2019-03-22T04:45:54Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@rkeithhill \r\n\r\n> That's not quite it.\r\n\r\nBy process of elimination, **command lines that predate PowerShell in the Windows world were written for `cmd.exe` - and that's precisely what `--%` intends to emulate**, as evidenced by the following:\r\n\r\n* `--%` expands `cmd.exe`-style `%...%` environment-variable references, such as `%USERNAME%` (if no shell and no special logic were involved, such tokens would be passed _verbatim_)\r\n\r\n* straight [from the PowerShell's mouth](http://blogs.msdn.com/b/powershell/archive/2012/06/14/new-v3-language-features.aspx) (if you will; emphasis added):\r\n\r\n> **The web is full of command lines written for Cmd.exe**.  These commands lines work often enough in PowerShell, but when they include certain characters, e.g. a semicolon (;) a dollar sign ($), or curly braces, you have to make some changes, probably adding some quotes.  This seemed to be the source of many minor headaches.\r\n\r\n> To help address this scenario, we added a new way to \u201cescape\u201d the parsing of command lines.  If you use a magic parameter --%, we stop our normal parsing of your command line and switch to something much simpler.  We don\u2019t match quotes.  We don\u2019t stop at semicolon.  We don\u2019t expand PowerShell variables.  **We do expand environment variables if you use Cmd.exe syntax (e.g. %TEMP%).**  Other than that, the arguments up to the end of the line (or pipe, if you are piping) are passed as is.  Here is an example:\r\n\r\nNote that **this approach is a poor fit for the _Unix_ world** (to recap from above):\r\n\r\n* Globbing of unquoted arguments such as `*.txt` won't work.\r\n\r\n* Traditional (POSIX-like) shells in the Unix world do _not_ use `%...%` to refer to environment variables; they expect `$...` syntax.\r\n\r\n* There is (fortunately) no _raw_ command line in the Unix world: any external executable must be passed an _array_ of _literals_, so it is still PowerShell or CoreFx that must parse the command line into arguments first.\r\n\r\n* Traditional (POSIX-like) shells in the Unix world accept `'...'` (single-quoted) strings, which `--%` doesn't recognize - see #10831.\r\n\r\nBut **even in the Windows world `--%` has severe, non-obvious limitations**:\r\n\r\n* Most obviously, you cannot directly reference PowerShell variables in your command line if you use `--%`; the only - cumbersome - workaround is to temporarily define _environment_ variables, which you must then reference with `%...%`.\r\n* You cannot enclose the command line in `(...)` - because the closing `)` is interpreted as a literal part of the command line.\r\n* You cannot follow the command line with `;` and another statement - because the `;` is interpreted as a literal part of the command line.\r\n* You cannot use `--%` inside a single-line script block - because the closing `}` is interpreted as a literal part of the command line.\r\n* You cannot use redirections - because they're treated as a literal part of the command line - however, you can use `cmd --% /c ... > file`, to let `cmd.exe` handle the redirection.\r\n* You cannot use line-continuation characters - neither PowerShell's (`` ` ``) nor cmd.exe's (`^`) - they will be treated as _literals_.\r\n    * `--%` only ever parses (at most) to the end of the line. \r\n\r\n---\r\n\r\n**Fortunately, we already _do_ have a cross-platform syntax: _PowerShell's own syntax_.**\r\n\r\nYes, using that requires you to know what _PowerShell_ considers metacharacters, which is a _superset_ of both what `cmd.exe` and POSIX-like shells such as Bash consider metacharacters, but that is the price to pay for a richer, platform-agnostic command-line experience.\r\n\r\nHow unfortunate it is, then, that PowerShell handles quoting of `\"` characters so poorly - which is the very subject of this issue, and which is summarized in [this docs issue](https://github.com/MicrosoftDocs/PowerShell-Docs/issues/2361).\r\n\r\n\r\n\r\n",
      "created_at": "2019-05-11T21:22:34Z",
      "updated_at": "2019-10-18T14:57:01Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@rkeithhill, I started a bit of a tangent; let me try to close it:\r\n\r\n* `--%` actually already _is_ implemented as of PowerShell Core 6.2.0; e.g., \r\n`/bin/echo --% %HOME%` prints the value of environment variable `HOME`; by contrast, \r\n`/bin/ls --% *.txt` will not work as expected, because the `*.txt` is passed as a literal.\r\n\r\n* Ultimately, when not using `--%`, we need to help users diagnose what the command line / arguments array that is constructed _behind the scenes ultimately_ looks like (which takes us back to the venerable #1761):\r\n  * Your helpful `echoArgs.exe` does just that, and in the linked issue you sensibly called for such functionality to be part of PowerShell itself.\r\n  * @SteveL-MSFT pondered including the resulting command line in the error record.\r\n\r\nFinally, to apply my previous argument - using PowerShell's own syntax as the inherently portable one - to your example:\r\n\r\n```powershell\r\n# Works cross-platform, uses PowerShell syntax \r\n# Note: No need for an aux. *environment* variable (which should be cleaned up afterward)\r\n$Index = 1\r\ngit show \"@~$Index\"\r\n\r\n# Alternative, quoting just the '@'\r\ngit show `@~$Index\r\n```\r\n\r\nYes, it requires you to know that a token-initial `@` is a metacharacter that you therefore have to quote, but as PowerShell becomes more widely used, the awareness of such requirements should become more widespread too.\r\n ",
      "created_at": "2019-05-12T13:47:46Z",
      "updated_at": "2019-05-12T13:50:57Z"
    },
    {
      "author": "Artoria2e5",
      "author_association": "NONE",
      "body": "FYI, this problem should be almost the same on Windows and Unix-likes. CoreFx implementation of Unix S.D.Process has a thing called [`ParseArgumentsIntoList`](https://github.com/dotnet/corefx/blob/d391103/src/System.Diagnostics.Process/src/System/Diagnostics/Process.Unix.cs#L846-L854), which implements `CommandLineToArgvW` near-exactly without `_setargv` switches (and with the undocumented `\"\"` in quotes &rarr; `\"` feature). Unix should not be an additional point of pain in this because in the current shape it is broken in the same way as Windows is.\r\n\r\n`_setargv` is not something every program uses after all, and it's probably not worth considering it because, well, it is kinda effed with [behavioral changes among CRT versions](https://bugs.openjdk.java.net/browse/JDK-7167744). The best we can and should do  is to surround everything with double quotes, add some nice backslahes, and that's all.",
      "created_at": "2019-09-18T08:48:23Z",
      "updated_at": "2019-09-18T08:49:33Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "Another example where args aren't being parsed correctly:\r\n\r\n```powershell\r\naz \"myargs&b\"\r\n```\r\n\r\nIn this case, az gets `myargs` and `b` is attempted to be executed as a new command.\r\n\r\nWorkaround is: az --% \"myargs&b\"\r\n",
      "created_at": "2019-10-09T04:26:23Z",
      "updated_at": "2019-10-09T04:26:23Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT, we can remove the `Waiting - DotNetCore` label, given that the requisite feature - the collection-based [`ProcessStartInfo.ArgumentList`](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.processstartinfo.argumentlist) property has been available since .NET Core 2.1\r\n\r\n@TSlivede is aware of the new method and plans to use it, but the associated RFC, https://github.com/PowerShell/PowerShell-RFC/pull/90, is languishing, unfortunately.\r\n\r\nI suggest we continue the _implementation_ discussion there.\r\n\r\nHowever, in the RFC discussion, @joeyaiello talks about making the changes an experimental feature, but it's becoming increasingly clear to me that you cannot fix the quoting behavior without massively breaking existing code:\r\n\r\nAnyone who's had to _work around_:\r\n\r\n* the inability to pass an empty-string argument (`foo.exe \"\"` currently passes _no_ arguments)\r\n* the unexpected effective removal of double quotes due to lack of automatic escaping of embedded double quotes (`foo.exe  '{ \"foo\": \"bar\" }'` being passed as improperly escaped `\"{ \"foo\": \"bar\" }\"`)\r\n* the quirks of certain CLIs such as `msiexec` that don't accept certain arguments double-quoted _as a whole_ (`foo.exe foo=\"bar none\"` being passed as `\"foo=bar none\"`).\r\nNote: It is `msiexec` that is to blame here, and with the proposed changes applied, passing the required `foo=\"bar none\"` form of quoting will then require `--%`.\r\n\r\nwill be in trouble, because the workarounds will _break_ with the proposed changes applied.\r\n\r\nTherefore, an additional question is: \r\n\r\n* How can we make correct behavior available at least as an _opt-in_ feature?\r\n  \r\n  * In the case of broken quoting with `Start-Process`, we at least have the option of [introducing a new parameter for the correct behavior](https://github.com/PowerShell/PowerShell/issues/5576#issuecomment-552124719), but with direct invocation that is clearly not an option (unless we introduce another \"magic symbol\" such as `--%`).\r\n\r\n* A fundamental problem with such mechanisms - typically, by preference variable, but increasingly also by `using` statements  -  is PowerShell's dynamic scoping; that is, the opted-in behavior will by default be applied to code called _from_ one's opted-in code as well, which is problematic.\r\n\r\n  * Perhaps it is time for generally introducing  _lexical_ scoping of features, a generalization of the lexically scoped `using strict` proposal in the - equally languishing - [lexical strict-mode RFC](https://github.com/PowerShell/PowerShell-RFC/blob/master/1-Draft/RFC0003-Lexical-Strict-Mode.md) authored by @lzybkr.\r\n\r\n  * Something like a lexically scoped `using preference ProperArgumentQuoting`? (Name obviously negotiable, but I'm struggling to come up with one).\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2019-11-10T19:06:36Z",
      "updated_at": "2019-11-10T19:06:36Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Given all those caveats, and that this is an issue with direct invocation as well, where we can't simply add a new parameter, I'm firmly in favour of breaking the old behaviour.\r\n\r\nYes, it'll probably break a lot. But really, only because it was so thoroughly broken to begin with. I don't think it's particularly feasible to prioritise maintaining what amounts to a huge pile of workarounds for broken behaviour over having a feature that _actually works_.\r\n\r\nAs a new major version I think v7 really is the only chance we'll get to rectify this situation properly for quite some time, and we should take the opportunity. Provided we make users aware, I don't think the transition will be poorly received overall.",
      "created_at": "2019-11-10T19:56:05Z",
      "updated_at": "2019-11-10T19:57:51Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "If we feel that breaking change is inevitable, then perhaps we should design the ideal solution, taking into account that it should be easy to print in an interactive session and it is possible to have a script version that better works on all platforms.\r\n",
      "created_at": "2019-11-11T04:17:03Z",
      "updated_at": "2020-07-15T04:47:43Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Agreed, @vexx32: Retaining the existing behavior, even if only by default, will remain a perennial pain point. Users do not expect the need for opt-in to being with, and, once they do, they are likely to either forget on occasion and/or resent the need to apply it every time. \r\n\r\nA shell that doesn't reliably pass arguments to external programs is failing one of its core mandates.\r\n\r\nYou certainly have _my_ vote for making the breaking change, but I fear that others will feel differently, not least because v7 is being touted as allowing longterm WinPS users to migrate to PSCore.\r\n\r\n---\r\n\r\n@iSazonov: https://github.com/PowerShell/PowerShell-RFC/pull/90 describes the correct solution.\r\n\r\nTo recapitulate its spirit:\r\n\r\nPowerShell, as a shell, needs to parse arguments according to _its_ rules and then pass the resulting, expanded argument values _verbatim_ to the target program - users should never have to think about how PowerShell makes that happen; all they should ever have to worry about is getting _PowerShell_ syntax right.\r\n\r\n* On Unix-like platforms,  `ProcessStartInfo.ArgumentList` now gives us a way to perfectly implement this, given that the _array_ of expanded argument values can be passed _as-is_ to the target program, because that's how argument passing - sensibly - works in this world.\r\n\r\n* On Windows, we have to deal with the unfortunate reality of [the anarchy that is Windows command-line parsing](https://stackoverflow.com/a/4094897/45375), but, as a shell, it behooves us to _just make it work behind the scenes, as much as possible_, which is what the RFC describes - though I've just [discovered a wrinkle](https://github.com/PowerShell/PowerShell-RFC/pull/90#issuecomment-552231174) that makes sole use of  `ProcessStartInfo.ArgumentList` not good enough, unfortunately (due to widespread of _batch files_ as CLI entry points, as demonstrated by @SteveL-MSFT's `az[.cmd]` example above). For those edge cases where doing the sensible thing isn't good enough, there's `--%`. \r\n\r\n\r\n\r\n",
      "created_at": "2019-11-11T13:23:35Z",
      "updated_at": "2019-11-11T13:26:41Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Perhaps PSSA can help to mitigate the breaking change by warning users that they use an argument format which will be changed.",
      "created_at": "2019-11-11T13:35:57Z",
      "updated_at": "2019-11-11T13:35:57Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "I think we need to consider adopting something like [Optional Features](https://github.com/PowerShell/PowerShell-RFC/pull/220) to move forward on this breaking change along with [some others](https://github.com/PowerShell/PowerShell/issues/6745).",
      "created_at": "2019-11-11T16:46:12Z",
      "updated_at": "2019-11-11T16:46:12Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Is there really any value in maintaining the existing behaviour? Other than backwards compatibility, I mean.\r\n\r\nI don't think it's worthwhile to maintain two code paths for this, simply to retain a broken implementation because some old code might need it once in a while. I don't think it's unreasonable to expect folx to update their code once in a while. \ud83d\ude05 \r\n\r\nDoubly so if we expect PS7 to be a stand-in replacement for WinPS; the only reason I can see to retain the behaviour for v7 is if we expect folks to be using the same script to run commands on both  5.1 and 7, which (hopefully) should be a pretty rare case if PS7 is good replacement for 5.1.\r\n\r\nAnd even then, it wouldn't be overly difficult for users to account for both. Provided we're not changing actual language syntax, it should be pretty easy to do something like this:\r\n\r\n```powershell\r\nif ($PSVersionTable.PSVersion.Major -lt 7) {\r\n    # use old form\r\n}\r\nelse {\r\n    # use new form\r\n}\r\n```\r\n\r\nProvided we make users aware of the difference, I think it would be a welcome relief from the pain that it has been to handle weird native executables in PS up to now. \ud83d\ude04 \r\n\r\nAs @TylerLeonhardt mentioned in the discussion of optional features -- implementing that means you now maintain _multiple_ distinct implementations which each need to be maintained and tested, **plus** also maintaining and testing the optional feature framework. Doesn't really seem worth it for this, tbh.",
      "created_at": "2019-11-11T17:03:01Z",
      "updated_at": "2019-11-11T17:06:30Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@vexx32 backwards compatibility is a big issue here.  This isn't the only issue for args to native executables.  I'd like to bucket them all and have them all be one \"optional feature\".  For example, https://github.com/PowerShell/PowerShell/issues/1761 and https://github.com/PowerShell/PowerShell/issues/10675.  \"Fixing\" interoperability with native commands is something I'd like to resolve for vNext.  So if anyone sees any existing or new issues in this category, cc me and I'll tag it appropriately (or if you have triage permission, tag it like the others).",
      "created_at": "2019-11-11T17:18:35Z",
      "updated_at": "2019-11-11T17:18:35Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Optional features is modules :-) Having optional features in Engine is big headache for support, specially for Windows support. We could modularize Engine by reducing internal dependencies and replacing internal APIs with public - after this we could implement optional features in Engine in easy way.",
      "created_at": "2019-11-11T17:21:25Z",
      "updated_at": "2019-11-11T17:21:25Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@iSazonov one of the things my team will look at in vNext is to make the engine more modular :)",
      "created_at": "2019-11-11T17:27:10Z",
      "updated_at": "2019-11-11T17:27:10Z"
    },
    {
      "author": "musm",
      "author_association": "NONE",
      "body": "What is the recommended solution here for end users?",
      "created_at": "2019-11-25T20:13:03Z",
      "updated_at": "2019-11-25T20:13:03Z"
    },
    {
      "author": "Artoria2e5",
      "author_association": "NONE",
      "body": "This is contrived, but it is the most straightforward way to get to the correct\\* ArgumentList handling from the .NET framework itself:\r\n\r\n```Powershell\r\nAdd-Type -AssemblyName \"System\"\r\nfunction startProcess([string] $FileName, [string[]] $ArgumentList) {\r\n    $proc = ([System.Diagnostics.Process]::new())\r\n    $proc.StartInfo.UseShellExecute = $false\r\n    $proc.StartInfo.FileName = $FileName\r\n    $proc.StartInfo.CreateNoWindow = $true\r\n    foreach ($a in $ArgumentList) { $proc.StartInfo.ArgumentList.Add($a) }\r\n    $proc.Start()\r\n    return $proc\r\n}\r\n\r\nstartProcess -FileName 'C:\\Program Files\\nodejs\\node.exe' -ArgumentList '-e','console.log(process.argv.join(''\\n''))','--','abc\" \\\" messyString'\r\n```\r\n\r\nOf course you can make it less contrived to use here by using positional parameters and some `get-command` trickery.\r\n\r\n\\* DISCLAIMER: There is no single correct way to parse a cmdline on Windows. By \"correct\" I mean the MSVCRT style of cmdline from/to argv conversion, implemented by .NET on all platforms for ArgumentList handling, `main (string[] args)` processing, and external spawn calls on Unix. This sample is provided AS IS with no guarantee for general interoperability. See also [the \"windows command line\" section of proposed NodeJS child_process documentation](https://github.com/nodejs/node/blob/34eb90ea6cc27070de30175f886183b8e293a559/doc/api/child_process.md#windows-command-line).",
      "created_at": "2019-11-26T09:29:11Z",
      "updated_at": "2019-11-27T03:41:31Z"
    },
    {
      "author": "choovick",
      "author_association": "NONE",
      "body": "@Artoria2e5 That exactly the conclusion I came to. System.Diagnostics.Process is the only reliable way to run external executable, but escaping arguments can get tricky due to stdlib Rules: \r\n```\r\n2N backslashes + \" ==> N backslashes and begin/end quote\r\n2N+1 backslashes + \" ==> N backslashes + literal \" \r\nN backslashes ==> N backslashes\r\n```\r\nAs the result I have come up with the following logic to escape arguments wrap them into double quotes `\"` for process executuion:\r\nhttps://github.com/choovick/ps-invoke-externalcommand/blob/master/ExternalCommand/ExternalCommand.psm1#L244\r\n\r\nAlso it can get tricky to obtain STDOUT and STDERR in realtime while external executable runs, so I have created this package \r\n\r\nhttps://github.com/choovick/ps-invoke-externalcommand\r\n\r\n that i'm using heavily on Windows, Linux and Mac and so far without issues and I can pass arguments with newline and other special characters in them. \n\n<blockquote><img src=\"https://avatars2.githubusercontent.com/u/3503712?s=400&v=4\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicon.ico\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/choovick/ps-invoke-externalcommand\">choovick/ps-invoke-externalcommand</a></strong></div><div>Contribute to choovick/ps-invoke-externalcommand development by creating an account on GitHub.</div></blockquote>\n<blockquote><img src=\"https://avatars2.githubusercontent.com/u/3503712?s=400&v=4\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicon.ico\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/choovick/ps-invoke-externalcommand\">choovick/ps-invoke-externalcommand</a></strong></div><div>Contribute to choovick/ps-invoke-externalcommand development by creating an account on GitHub.</div></blockquote>",
      "created_at": "2019-11-27T15:26:58Z",
      "updated_at": "2019-11-27T15:27:00Z"
    },
    {
      "author": "Artoria2e5",
      "author_association": "NONE",
      "body": "@choovick the whole stdio redirect thing is great!\r\n\r\nI disagree slightly on the escaping part though, since there is already a thing that does it for you called ArgumentList. I do understand that it is a relative recent (?) addition, and it does get disappointing since MS forgot to put a String,String[] initializer for S.D.ProcessStartInfo. (Is there a place for these\u2026 .NET Interface proposals?)\r\n<details>\r\n<summary>chitchat</summary>\r\n\r\nMy escape function from that NodeJS example is a bit different from yours: it uses the undocumented (but found in .NET core and MSVCRT) `\"\"` escape for quotation marks. Doing so sort of simplifies the backslash picking work. I did this mainly because it was used for the all mighty cmd, which does not understand that `\\\"` should not unquote the rest of the string. Instead of struggling with  `\\^\"` I figured that I will be better off with something that has been in secret use since the beginning of time.\r\n\r\n</details>",
      "created_at": "2019-11-27T17:10:24Z",
      "updated_at": "2019-11-27T17:10:24Z"
    },
    {
      "author": "choovick",
      "author_association": "NONE",
      "body": "@Artoria2e5 unfortunately ArgumentList is not available in PowerShell 5.1 on windows, using your example i'm getting:\r\n\r\n```You cannot call a method on a null-valued expression.\r\nAt C:\\Users\\yser\\dev\\test.ps1:7 char:37\r\n+ ... oreach ($a in $ArgumentList) { $proc.StartInfo.ArgumentList.Add($a) }\r\n+                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n    + CategoryInfo          : InvalidOperation: (:) [], RuntimeException\r\n    + FullyQualifiedErrorId : InvokeMethodOnNull\r\n```\r\n\r\nSince custom argument escape logic....\r\n<details><summary>chitchat</summary>\r\n<p>\r\nin regards to `\\^\"` in NodeJS, I think I had to do that several years back :) and I think got it working</p>\r\n</details>\r\n",
      "created_at": "2019-11-27T18:06:10Z",
      "updated_at": "2019-11-27T18:06:10Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> System.Diagnostics.Process is the only reliable way to run external executable\r\n\r\nThe problem is that you won't get integration with PowerShell's output streams and you won't get streaming behavior in the pipeline.\r\n\r\n**Here's the summary of the required workarounds if you still want to let PowerShell perform the invocation (which is definitely preferable)**:\r\n\r\n* If you need to pass arguments with _embedded_ `\"` chars., _double_ them on Windows, if possible, or `\\`-escape them:\r\n\r\n  * On Windows, when calling _batch files_ and if you know that the target program understands `\"\"` as an escaped `\"`, use `$arg -replace '\"', '\"\"'`\r\n      * Use of `\"\"` is preferable on Windows (it avoids the Windows PowerShell problem and works with CLIs that use batch files as _stubs_, such as Node.js and Azure), but not all executables support it (notably not Ruby and Perl).\r\n\r\n  * Otherwise (always on Unix), use `$arg -replace '\"', '\\\"'`\r\n\r\n    * Note: In _Windows PowerShell_, this still doesn't always work properly if the value also contains _spaces_, because the presence of literal `\\\"` in the value does situationally does _not_ trigger enclosing double-quoting, unlike in PowerShell Core; e.g., passing `'3\\\" of snow'` breaks.\r\n\r\n  * Additionally, before the above escaping, you must double `\\` instance immediately preceding `\"`, if they are to be treated as literals:\r\n\r\n       * `$arg = $arg -replace '(\\\\+)\"', '$1$1\"'`\r\n\r\n* If you need to pass an _empty_ argument, pass `'\"\"'`.\r\n\r\n  *  `'' -eq $arg ? '\"\"' : $arg` (WinPS alternative: `($arg, '\"\"')['' -eq $arg]`\r\n\r\n* Windows PowerShell only, don't do this in PS Core (where the problem has been fixed): \r\n    * If your argument _contains spaces_ and _ends in_  (one or more) `\\`, double the trailing`\\` instance(s).\r\n\r\n     * `if ($arg -match ' .*?(\\\\+)$') { $arg = $arg + $Matches[1] }`\r\n\r\n* If `cmd` / a batch file is being invoked with arguments that do _not_ have spaces (therefore _not_ triggering automatic double-quoting by PowerShell) but contain any of `&|<>^,;` (e.g., `a&b`), use _embedded enclosing double-quoting_ to ensure that PowerShell passes a double-quoted token and therefore doesn't break the `cmd` / batch-file call:\r\n\r\n   * `$arg = '\"' + $arg + '\"'`\r\n\r\n* If you need to deal with ill-behaved executables such as `msiexec.exe`, single-quote the argument:\r\n\r\n   * `'foo=\"bar none\"'`\r\n\r\nAs stated, **these workarounds will _break_, once the underlying problem gets fixed.**\r\n\r\n---\r\n\r\nBelow is **simple (non-advanced) function `iep`** (for \"invoke external program\"), which: \r\n\r\n* Performs all of the escaping described above, including automatic special-casing for `msiexec` and preferring `\"\"` escaping over `\\\"` depending on the target program.\r\n  * The idea is that you can pass any argument by focusing on _PowerShell_'s string syntax only, and rely on the function to perform the necessary escaping so that the verbatim value that PowerShell sees is also seen by the target program.\r\n  * In PowerShell _Core_, this should work pretty robustly; in Windows PowerShell you still have edge cases with embedded double quotes that break if `\\\"` escaping must be used (as discussed above).\r\n* Preserves shell-command invocation syntax.\r\n  * Simply prepend `iep\u00a0` to your command line.\r\n* As direct invocation would, it:\r\n   * integrates with PowerShell's streams\r\n   * sends output line by line through the pipeline\r\n   * sets `$LASTEXITCODE` based on the external program's exit code; however, `$?` can _not_ be relied upon.\r\n\r\nNote: The function is purposely minimalistic (no parameter declarations, no command-line help, short (irregular) name), because its meant to be as unobtrusive as possible: simply prepend `iep` to your command line, and things should work.\r\n\r\n**Example invocation** using `EchoArgs.exe` (installable via Chocolatey from an _elevated_ session with `choco install echoargs -y`):\r\n\r\n```\r\nPS> iep echoargs '' 'a&b' '3\" of snow' 'Nat \"King\" Cole' 'c:\\temp 1\\' 'a \\\" b'\r\nArg 0 is <>\r\nArg 1 is <a&b>\r\nArg 2 is <3\" of snow>\r\nArg 3 is <Nat \"King\" Cole>\r\nArg 4 is <c:\\temp 1\\>\r\nArg 5 is <a \\\" b>\r\n\r\nCommand line:\r\n\"C:\\ProgramData\\chocolatey\\lib\\echoargs\\tools\\EchoArgs.exe\" \"\" a&b \"3\\\" of snow\" \"Nat \\\"King\\\" Cole\" \"c:\\temp 1\\\\\" \"a \\\\\\\" b\"\r\n```\r\n\r\nThe above shows PowerShell Core output. Note how all arguments were correctly passed through as seen verbatim by PowerShell, including the empty argument.\r\n\r\nIn Windows PowerShell, the `3\" of snow` argument won't be passed correctly, because  `\\\"` escaping is used due to calling an unknown executable (as discussed above).\r\n\r\nTo verify that batch files pass arguments correctly through, you can create `echoargs.cmd` as a wrapper for `echoargs.exe`:\r\n\r\n```\r\n'@echoargs.exe %*' | Set-Content echoargs.cmd\r\n```\r\nInvoke as `iep .\\echoargs.cmd '' 'a&b' '3\" of snow' 'Nat \"King\" Cole' 'c:\\temp 1\\' 'a \\\" b'`\r\n\r\nSince a batch file is now called, `\"\"`-escaping is employed, which fixes the `3\" of snow` problem when calling from Windows PowerShell.\r\n\r\nThe function equally works on Unix-like platforms, which you can verify by creating a `sh` shell script named `echoargs`:\r\n```powershell\r\n@'\r\n#!/bin/sh\r\ni=0; for a; do printf '%s\\n' \"\\$$((i+=1))=[$a]\"; done\r\n'@ > echoargs; chmod a+x echoargs\r\n```\r\n\r\nInvoke as `iep ./echoargs '' 'a&b' '3\" of snow' 'Nat \"King\" Cole' 'c:\\temp 1\\' 'a \\\" b'`\r\n\r\n---\r\n\r\n**Important**: A **more complete version of this function** has since been published as **`ie` (*I*nvoke (external) *E*xecutable)** in I've just published a module **[`Native`](https://github.com/mklement0/Native)**, which I encourage you to use instead. Install the module with\r\n**`Install-Module Native -Scope CurrentUser`**.\r\nThe module also contains an `ins` (`Invoke-NativeShell`) command that addresses the use case discussed in #13068  - see https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-671572939 for details.\r\n\r\n### Function `iep`' s source code (use module `Native` instead - see above): \r\n\r\n```powershell\r\nfunction iep {\r\n\r\n  Set-StrictMode -Version 1\r\n  if (-not (Test-Path Variable:IsCoreClr)) { $IsCoreCLR = $false }\r\n  if (-not (Test-Path Variable:IsWindows)) { $IsWindows = $env:OS -eq 'Windows_NT' }\r\n\r\n  # Split into executable name/path and arguments.\r\n  $exe, [string[]] $argsForExe = $args\r\n\r\n  # Resolve to the underlying command (if it's an alias) and ensure that an external executable was specified.\r\n  $app = Get-Command -ErrorAction Stop $exe\r\n  if ($app.ResolvedCommand) { $app = $app.ResolvedCommand }\r\n  if ($app.CommandType -ne 'Application') { Throw \"Not an external program, non-PS script, or batch file: $exe\" }\r\n\r\n  if ($argsForExe.Count -eq 0) {\r\n    # Argument-less invocation\r\n    & $exe\r\n  }\r\n  else {\r\n    # Invocation with arguments: escape them properly to pass them through as literals.\r\n    # Decide whether to escape embedded double quotes as \\\" or as \"\", based on the target executable.\r\n    # * On Unix-like platforms, we always use \\\"\r\n    # * On Windows, we use \"\" where we know it's safe to do. cmd.exe / batch files require \"\", and Microsoft compiler-generated executables do too, often in addition to supporting \\\",\r\n    #   notably including Python and Node.js\r\n    #   However, notable interpreters that support \\\" ONLY are Ruby and Perl (as well as PowerShell's own CLI, but it's better to call that with a script block from within PowerShell).\r\n    #   Targeting a batch file triggers \"\" escaping, but in the case of stub batch files that simply relay to a different executable, that could still break\r\n    #   if the ultimate target executable only supports \\\" \r\n    $useDoubledDoubleQuotes = $IsWindows -and ($app.Source -match '[/\\\\]?(?<exe>cmd|msiexec)(?:\\.exe)?$' -or $app.Source -match '\\.(?<ext>cmd|bat|py|pyw)$')\r\n    $doubleQuoteEscapeSequence = ('\\\"', '\"\"')[$useDoubledDoubleQuotes]\r\n    $isMsiExec = $useDoubledDoubleQuotes -and $Matches['exe'] -eq 'msiexec'\r\n    $isCmd = $useDoubledDoubleQuotes -and ($Matches['exe'] -eq 'cmd' -or $Matches['ext'] -in 'cmd', 'bat')\r\n    $escapedArgs = foreach ($arg in $argsForExe) {\r\n      if ('' -eq $arg) { '\"\"'; continue } # Empty arguments must be passed as `'\"\"'`(!), otherwise they are omitted.\r\n      $hasDoubleQuotes = $arg.Contains('\"')\r\n      $hasSpaces = $arg.Contains(' ')\r\n      if ($hasDoubleQuotes) {\r\n        # First, always double any preexisting `\\` instances before embedded `\"` chars. \r\n        # so that `\\\"` isn't interpreted as an escaped `\"`.\r\n        $arg = $arg -replace '(\\\\+)\"', '$1$1\"'\r\n        # Then, escape the embedded `\"` chars. either as `\\\"` or as `\"\"`.\r\n        # If \\\" escaping is used:\r\n        # * In PS Core, use of `\\\"` is safe, because its use triggers enclosing double-quoting (if spaces are also present).\r\n        # * !! In WinPS, sadly, that isn't true, so something like `'foo=\"bar none\"'` results in `foo=\\\"bar none\\\"` -\r\n        #   !! which - due to the lack of enclosing \"...\" - is seen as *2* arguments by the target app, `foo=\"bar` and `none\"`.\r\n        #   !! Similarly, '3\" of snow' would result in `3\\\" of snow`, which the target app receives as *3* arguments, `3\"`, `of`, and `snow`.\r\n        #   !! Even manually enclosing the value in *embedded* \" doesn't help, because that then triggers *additional* double-quoting.\r\n        $arg = $arg -replace '\"', $doubleQuoteEscapeSequence\r\n    }\r\n      elseif ($isMsiExec -and $arg -match '^(\\w+)=(.* .*)$') { \r\n        # An msiexec argument originally passed in the form `PROP=\"value with spaces\"`, which PowerShell turned into `PROP=value with spaces`\r\n        # This would be passed as `\"PROP=value with spaces\"`, which msiexec, sady, doesn't recognize (`PROP=valueWithoutSpaces` works fine, however).\r\n        # We reconstruct the form `PROP=\"value with spaces\"`, which both WinPS And PS Core pass through as-is.\r\n        $arg = '{0}=\"{1}\"' -f $Matches[1], $Matches[2]\r\n      }\r\n      # As a courtesy, enclose tokens that PowerShell would pass unquoted in \"...\", \r\n      # if they contain cmd.exe metachars. that would break calls to cmd.exe / batch files.\r\n      $manuallyDoubleQuoteForCmd = $isCmd -and -not $hasSpaces -and $arg -match '[&|<>^,;]'\r\n      # In WinPS, double trailing `\\` instances in arguments that have spaces and will therefore be \"...\"-enclosed,\r\n      # so that `\\\"` isn't mistaken for an escaped `\"` - in PS Core, this escaping happens automatically.\r\n      if (-not $IsCoreCLR -and ($hasSpaces -or $manuallyDoubleQuoteForCmd) -and $arg -match '\\\\') {\r\n        $arg = $arg -replace '\\\\+$', '$&$&'\r\n      }\r\n      if ($manuallyDoubleQuoteForCmd) {\r\n        # Wrap in *embedded* enclosing double quotes, which both WinPS and PS Core pass through as-is.\r\n        $arg = '\"' + $arg + '\"'\r\n      }\r\n      $arg\r\n    }\r\n    # Invoke the executable with the properly escaped arguments.\r\n    & $exe $escapedArgs\r\n  }\r\n}\r\n```",
      "created_at": "2019-12-05T21:50:49Z",
      "updated_at": "2020-08-11T12:17:25Z"
    },
    {
      "author": "choovick",
      "author_association": "NONE",
      "body": "@mklement0  Impressive, but here are couple that does not work for me on windows:\r\n```\r\niep echoargs 'somekey=\"value with spaces\"' 'te\\\" st'\r\n\r\nArg 0 is <somekey=\"value>\r\nArg 1 is <with>\r\nArg 2 is <spaces\">\r\nArg 3 is <te\\\">\r\nArg 4 is <st>\r\n\r\nCommand line:\r\n\"C:\\ProgramData\\chocolatey\\lib\\echoargs\\tools\\EchoArgs.exe\" somekey=\\\"value with spaces\\\" te\\\\\\\" st\r\n```\r\n\r\n\r\nhere is my test array of arguments :)\r\n```\r\n$Arguments = @(\r\n    'trippe slash at the end \\\\\\',\r\n    '4 slash at the end \\\\\\\\',\r\n    '\\\\servername\\path\\',\r\n    'path=\\\\servername\\path\\',\r\n    'key=\"\\\\servername\\pa th\\\"',\r\n    '5 slash at the end \\\\\\\\\\',\r\n    '\\\\\" double slashed double quote',\r\n    'simple',\r\n    'white space',\r\n    'slash at the end \\',\r\n    'double slash at the end \\\\',\r\n    'trippe slash at the end \\\\\\',\r\n    'trippe slash at the end with space \\\\\\ ',\r\n    '\\\\\" double slashed double quote',\r\n    'double slashed double quote at the end \\\\\"',\r\n    '\\\\\\\" triple slashed double quote',\r\n    'triple slashed double quote at the end \\\\\\\"',\r\n    # slash\r\n    'single slashes \\a ^ \\: \\\"',\r\n    'path=\"C:\\Program Files (x86)\\test\\\"'\r\n    # quotes\r\n    'double quote \" and single quote ''',\r\n    # windows env var syntax\r\n    \"env var OS: %OS%\",\r\n    # utf16\r\n    ('\"utf16 ETHIOPIC WORDSPACE: \\u1361\"' | ConvertFrom-Json),\r\n    # special chars\r\n    \"newLine`newLine\"\r\n    \"tab`tab\"\r\n    \"backspace`bbackspace\"\r\n    \"carriage`rafter\",\r\n    \"formFeed`fformFeed\",\r\n    # JSON Strings\r\n    @\"\r\n[{\"_id\":\"5cdab57e4853ea7b5a707070\",\"index\":0,\"guid\":\"25319946-950e-4fe8-9586-ddd031cbb0fc\",\"isActive\":false,\"balance\":\"`$2,841.15\",\"picture\":\"http://placehold.it/32x32\",\"age\":39,\"eyeColor\":\"blue\",\"name\":{\"first\":\"Leach\",\"last\":\"Campbell\"},\"company\":\"EMOLTRA\",\"email\":\"leach.campbell@emoltra.biz\",\"phone\":\"+1 (864) 412-3166\",\"address\":\"127 Beadel Street, Vivian, Vermont, 1991\",\"about\":\"Ex labore non enim consectetur id ullamco nulla veniam Lorem velit cillum aliqua amet nostrud. Occaecat ipsum do est qui sint aliquip anim culpa laboris tempor amet. Aute sint anim est sint elit amet nisi veniam culpa commodo nostrud cupidatat in ex.\",\"registered\":\"Monday, August 25, 2014 4:04 AM\",\"latitude\":\"-12.814443\",\"longitude\":\"75.880149\",\"tags\":[\"pariatur\",\"voluptate\",\"sint\",\"Lorem\",\"eiusmod\"],\"range\":[0,1,2,3,4,5,6,7,8,9],\"friends\":[{\"id\":0,\"name\":\"Lester Bender\"},{\"id\":1,\"name\":\"Concepcion Jarvis\"},{\"id\":2,\"name\":\"Elsie Whitfield\"}],\"greeting\":\"Hello, Leach! You have 10 unread messages.\",\"favoriteFruit\":\"strawberry\"},{\"_id\":\"5cdab57e8cd0ac577ab534a4\",\"index\":1,\"guid\":\"0be10c87-6ce7-46c4-8dd6-23b1d9827538\",\"isActive\":false,\"balance\":\"`$1,049.56\",\"picture\":\"http://placehold.it/32x32\",\"age\":33,\"eyeColor\":\"green\",\"name\":{\"first\":\"Lacey\",\"last\":\"Terrell\"},\"company\":\"XSPORTS\",\"email\":\"lacey.terrell@xsports.tv\",\"phone\":\"+1 (858) 511-2896\",\"address\":\"850 Franklin Street, Gordon, Virginia, 4968\",\"about\":\"Eiusmod nostrud mollit occaecat Lorem consectetur enim pariatur qui eu. Proident aliqua sunt incididunt Lorem adipisicing ea esse do ullamco excepteur duis qui. Irure labore cillum aliqua officia commodo incididunt esse ad duis ea. Occaecat officia officia laboris veniam id dolor minim magna ut sit. Aute quis occaecat eu veniam. Quis exercitation mollit consectetur magna officia sit. Irure ullamco laborum cillum dolore mollit culpa deserunt veniam minim sunt.\",\"registered\":\"Monday, February 3, 2014 9:19 PM\",\"latitude\":\"-82.240949\",\"longitude\":\"2.361739\",\"tags\":[\"nostrud\",\"et\",\"non\",\"eiusmod\",\"qui\"],\"range\":[0,1,2,3,4,5,6,7,8,9],\"friends\":[{\"id\":0,\"name\":\"Meyers Dillard\"},{\"id\":1,\"name\":\"Jacobson Franco\"},{\"id\":2,\"name\":\"Hunt Hernandez\"}],\"greeting\":\"Hello, Lacey! You have 8 unread messages.\",\"favoriteFruit\":\"apple\"},{\"_id\":\"5cdab57eae2f9bc5184f1768\",\"index\":2,\"guid\":\"3c0de017-1c2a-470e-87dc-5a6257e8d9d9\",\"isActive\":true,\"balance\":\"`$3,349.49\",\"picture\":\"http://placehold.it/32x32\",\"age\":20,\"eyeColor\":\"green\",\"name\":{\"first\":\"Knowles\",\"last\":\"Farrell\"},\"company\":\"DAYCORE\",\"email\":\"knowles.farrell@daycore.io\",\"phone\":\"+1 (971) 586-2740\",\"address\":\"150 Bath Avenue, Marion, Oregon, 991\",\"about\":\"Eiusmod sint commodo eu id sunt. Labore esse id veniam ea et laborum. Dolor ad cupidatat Lorem amet. Labore ut commodo amet commodo. Ipsum reprehenderit voluptate non exercitation anim nostrud do. Aute incididunt ad aliquip aute mollit id eu ea. Voluptate ex consequat velit commodo anim proident ea anim magna amet nisi dolore.\",\"registered\":\"Friday, September 28, 2018 7:51 PM\",\"latitude\":\"-11.475201\",\"longitude\":\"-115.967191\",\"tags\":[\"laborum\",\"dolor\",\"dolor\",\"magna\",\"mollit\"],\"range\":[0,1,2,3,4,5,6,7,8,9],\"friends\":[{\"id\":0,\"name\":\"Roxanne Griffith\"},{\"id\":1,\"name\":\"Walls Moore\"},{\"id\":2,\"name\":\"Mattie Carney\"}],\"greeting\":\"Hello, Knowles! You have 8 unread messages.\",\"favoriteFruit\":\"strawberry\"},{\"_id\":\"5cdab57e80ff4c4085cd63ef\",\"index\":3,\"guid\":\"dca20009-f606-4b99-af94-ded6cfbbfa38\",\"isActive\":true,\"balance\":\"`$2,742.32\",\"picture\":\"http://placehold.it/32x32\",\"age\":26,\"eyeColor\":\"brown\",\"name\":{\"first\":\"Ila\",\"last\":\"Hardy\"},\"company\":\"OBLIQ\",\"email\":\"ila.hardy@obliq.ca\",\"phone\":\"+1 (996) 556-2855\",\"address\":\"605 Hillel Place, Herald, Delaware, 9670\",\"about\":\"Enim eiusmod laboris amet ex laborum do dolor qui occaecat ex do labore quis sunt. Veniam magna non nisi ipsum occaecat anim ipsum consectetur ex laboris aute ut consectetur. Do eiusmod tempor dolore eu in dolore qui anim non et. Minim amet exercitation in in velit proident sint aliqua Lorem reprehenderit labore exercitation.\",\"registered\":\"Friday, April 21, 2017 6:33 AM\",\"latitude\":\"64.864232\",\"longitude\":\"-163.200794\",\"tags\":[\"tempor\",\"eiusmod\",\"mollit\",\"aliquip\",\"aute\"],\"range\":[0,1,2,3,4,5,6,7,8,9],\"friends\":[{\"id\":0,\"name\":\"Duncan Guy\"},{\"id\":1,\"name\":\"Jami Maxwell\"},{\"id\":2,\"name\":\"Gale Hutchinson\"}],\"greeting\":\"Hello, Ila! You have 7 unread messages.\",\"favoriteFruit\":\"banana\"},{\"_id\":\"5cdab57ef1556326f77730f0\",\"index\":4,\"guid\":\"f2b3bf60-652f-414c-a5cf-094678eb319f\",\"isActive\":true,\"balance\":\"`$2,603.20\",\"picture\":\"http://placehold.it/32x32\",\"age\":27,\"eyeColor\":\"brown\",\"name\":{\"first\":\"Turner\",\"last\":\"King\"},\"company\":\"DADABASE\",\"email\":\"turner.king@dadabase.co.uk\",\"phone\":\"+1 (803) 506-2511\",\"address\":\"915 Quay Street, Hinsdale, Texas, 9573\",\"about\":\"Consequat sunt labore tempor anim duis pariatur ad tempor minim sint. Nulla non aliqua veniam elit officia. Ullamco et irure mollit nulla do eiusmod ullamco. Aute officia elit irure in adipisicing et cupidatat dolor in sint elit dolore labore. Id esse velit nisi culpa velit adipisicing tempor sunt. Eu sunt occaecat ex pariatur esse.\",\"registered\":\"Thursday, May 21, 2015 7:44 PM\",\"latitude\":\"88.502961\",\"longitude\":\"-119.654437\",\"tags\":[\"Lorem\",\"culpa\",\"labore\",\"et\",\"nisi\"],\"range\":[0,1,2,3,4,5,6,7,8,9],\"friends\":[{\"id\":0,\"name\":\"Leanne Lawson\"},{\"id\":1,\"name\":\"Jo Shepard\"},{\"id\":2,\"name\":\"Effie Barnes\"}],\"greeting\":\"Hello, Turner! You have 6 unread messages.\",\"favoriteFruit\":\"apple\"},{\"_id\":\"5cdab57e248f8196e1a60d05\",\"index\":5,\"guid\":\"875a12f0-d36a-4e7b-aaf1-73f67aba83f8\",\"isActive\":false,\"balance\":\"`$1,001.89\",\"picture\":\"http://placehold.it/32x32\",\"age\":38,\"eyeColor\":\"blue\",\"name\":{\"first\":\"Petty\",\"last\":\"Langley\"},\"company\":\"NETUR\",\"email\":\"petty.langley@netur.net\",\"phone\":\"+1 (875) 505-2277\",\"address\":\"677 Leonard Street, Ticonderoga, Utah, 1152\",\"about\":\"Nisi do quis sunt nisi cillum pariatur elit dolore commodo aliqua esse est aute esse. Laboris esse mollit mollit dolor excepteur consequat duis aute eu minim tempor occaecat. Deserunt amet amet quis adipisicing exercitation consequat deserunt sunt voluptate amet. Ad magna quis nostrud esse ullamco incididunt laboris consectetur.\",\"registered\":\"Thursday, July 31, 2014 5:16 PM\",\"latitude\":\"-57.612396\",\"longitude\":\"103.91364\",\"tags\":[\"id\",\"labore\",\"deserunt\",\"cillum\",\"culpa\"],\"range\":[0,1,2,3,4,5,6,7,8,9],\"friends\":[{\"id\":0,\"name\":\"Colette Mullen\"},{\"id\":1,\"name\":\"Lynnette Tanner\"},{\"id\":2,\"name\":\"Vickie Hardin\"}],\"greeting\":\"Hello, Petty! You have 9 unread messages.\",\"favoriteFruit\":\"banana\"},{\"_id\":\"5cdab57e4df76cbb0db9be43\",\"index\":6,\"guid\":\"ee3852fe-c597-4cb6-a336-1466e8978080\",\"isActive\":true,\"balance\":\"`$3,087.87\",\"picture\":\"http://placehold.it/32x32\",\"age\":33,\"eyeColor\":\"brown\",\"name\":{\"first\":\"Salas\",\"last\":\"Young\"},\"company\":\"PLAYCE\",\"email\":\"salas.young@playce.org\",\"phone\":\"+1 (976) 473-2919\",\"address\":\"927 Elm Place, Terlingua, North Carolina, 2150\",\"about\":\"Laborum laboris ullamco aliquip occaecat fugiat sit ex laboris veniam tempor tempor. Anim quis veniam ad commodo culpa irure est esse laboris. Fugiat nostrud elit mollit minim. Velit est laborum ut quis anim velit aute enim culpa amet ipsum.\",\"registered\":\"Thursday, October 1, 2015 10:59 AM\",\"latitude\":\"-57.861212\",\"longitude\":\"69.823065\",\"tags\":[\"eu\",\"est\",\"et\",\"proident\",\"nisi\"],\"range\":[0,1,2,3,4,5,6,7,8,9],\"friends\":[{\"id\":0,\"name\":\"Day Solomon\"},{\"id\":1,\"name\":\"Stevens Boyd\"},{\"id\":2,\"name\":\"Erika Mayer\"}],\"greeting\":\"Hello, Salas! You have 10 unread messages.\",\"favoriteFruit\":\"apple\"},{\"_id\":\"5cdab57ed3c91292d30e141d\",\"index\":7,\"guid\":\"ef7c0beb-8413-4f39-987f-022c4e8ec482\",\"isActive\":false,\"balance\":\"`$2,612.45\",\"picture\":\"http://placehold.it/32x32\",\"age\":36,\"eyeColor\":\"brown\",\"name\":{\"first\":\"Gloria\",\"last\":\"Black\"},\"company\":\"PULZE\",\"email\":\"gloria.black@pulze.me\",\"phone\":\"+1 (872) 513-2364\",\"address\":\"311 Guernsey Street, Hatteras, New Mexico, 2241\",\"about\":\"Laborum sunt exercitation ea labore ullamco dolor pariatur laborum deserunt adipisicing pariatur. Officia velit duis cupidatat eu officia magna magna deserunt do. Aliquip cupidatat commodo duis aliquip in aute dolore occaecat esse ad. Incididunt est magna in pariatur ut do ex sit minim cupidatat culpa. Voluptate eu veniam cupidatat exercitation.\",\"registered\":\"Friday, June 26, 2015 7:59 AM\",\"latitude\":\"38.644208\",\"longitude\":\"-45.481555\",\"tags\":[\"sint\",\"ea\",\"anim\",\"voluptate\",\"elit\"],\"range\":[0,1,2,3,4,5,6,7,8,9],\"friends\":[{\"id\":0,\"name\":\"Abby Walton\"},{\"id\":1,\"name\":\"Elsa Miranda\"},{\"id\":2,\"name\":\"Carr Abbott\"}],\"greeting\":\"Hello, Gloria! You have 5 unread messages.\",\"favoriteFruit\":\"strawberry\"},{\"_id\":\"5cdab57edc91491fb70b705d\",\"index\":8,\"guid\":\"631ff8a0-ce4c-4111-b1e4-1d112f4ecdc7\",\"isActive\":false,\"balance\":\"`$2,550.70\",\"picture\":\"http://placehold.it/32x32\",\"age\":25,\"eyeColor\":\"brown\",\"name\":{\"first\":\"Deirdre\",\"last\":\"Huber\"},\"company\":\"VERBUS\",\"email\":\"deirdre.huber@verbus.info\",\"phone\":\"+1 (871) 468-3420\",\"address\":\"814 Coles Street, Bartonsville, Tennessee, 7313\",\"about\":\"Ipsum ex est culpa veniam voluptate officia consectetur quis et irure proident pariatur non. In excepteur est aliqua duis duis. Veniam consectetur cupidatat reprehenderit qui qui aliqua.\",\"registered\":\"Monday, April 1, 2019 2:33 AM\",\"latitude\":\"-75.702323\",\"longitude\":\"45.165458\",\"tags\":[\"labore\",\"aute\",\"nisi\",\"laborum\",\"laborum\"],\"range\":[0,1,2,3,4,5,6,7,8,9],\"friends\":[{\"id\":0,\"name\":\"Genevieve Clarke\"},{\"id\":1,\"name\":\"Black Sykes\"},{\"id\":2,\"name\":\"Watson Hudson\"}],\"greeting\":\"Hello, Deirdre! You have 8 unread messages.\",\"favoriteFruit\":\"strawberry\"}]\r\n\"@\r\n)\r\n```\r\n\r\nSystem.Diagnostics.Process does have limitations in when used, that's why I had to write my own runner with abilities to capture STDOUT STDERR and combination of then into variables, which is sufficient for my use cases, but not perfect.\r\n\r\n**Edit:** like you said its goes seems have edge cases in Windows Poweshell 5. I tested on Powershell 6 and it works great! unfortunately i have to deal with  Poweshell 5 until 7 takes it over in Windows case...",
      "created_at": "2019-12-06T03:00:39Z",
      "updated_at": "2019-12-06T03:16:14Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> Impressive, but here are couple that does not work for me on windows:\r\n\r\nYes, these limitations apply to _Windows PowerShell_, with executables for which support for `\"\"` escaping of embedded `\"` cannot be assumed, as detailed in my previous comment.\r\nIf you're willing to assume support for `\"\"` escaping in all of your invocations (_most_, but not all executables on Windows do support it), you can easily tweak the function.\r\n\r\nAnd, to confirm what you said in your edit: In PowerShell _Core_:\r\n\r\n* `iep echoargs 'somekey=\"value with spaces\"' 'te\\\" st'` works fine.\r\n* Your test array of arguments seem to work fine too.\r\n\r\n",
      "created_at": "2019-12-06T03:26:27Z",
      "updated_at": "2019-12-06T03:27:24Z"
    },
    {
      "author": "choovick",
      "author_association": "NONE",
      "body": "> If you're willing to assume support for `\"\"` escaping in all of your invocations (_most_, but not all executables on Windows do support it), you can easily tweak the function.\r\n\r\nThanks I will give it a try in near future. I deal with sqlcmd on occasion and it does not support `\"\"` for sure. For that case - its easy to provide an option to skip escape logic for specific arguments.",
      "created_at": "2019-12-06T03:35:03Z",
      "updated_at": "2019-12-06T03:35:03Z"
    },
    {
      "author": "jiasli",
      "author_association": "NONE",
      "body": "The way how Windows parses command-line arguments can be found at [Parsing C++ command-Line arguments](https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args?view=vs-2019#parsing-c-command-line-arguments):\r\n\r\n> Microsoft C/C++ startup code uses the following rules when interpreting arguments given on the operating system command line:\r\n> \r\n> - Arguments are delimited by white space, which is either a space or a tab.\r\n> \r\n> - The caret character (^) is not recognized as an escape character or delimiter. The character is handled completely by the command-line parser in the operating system before being passed to the `argv` array in the program.\r\n> \r\n> - A string surrounded by double quotation marks (\"*string*\") is interpreted as a single argument, regardless of white space contained within. A quoted string can be embedded in an argument.\r\n> \r\n> - A double quotation mark preceded by a backslash (\\\\\") is interpreted as a literal double quotation mark character (\").\r\n> \r\n> - Backslashes are interpreted literally, unless they immediately precede a double quotation mark.\r\n> \r\n> - If an even number of backslashes is followed by a double quotation mark, one backslash is placed in the `argv` array for every pair of backslashes, and the double quotation mark is interpreted as a string delimiter.\r\n> \r\n> - If an odd number of backslashes is followed by a double quotation mark, one backslash is placed in the `argv` array for every pair of backslashes, and the double quotation mark is \"escaped\" by the remaining backslash, causing a literal double quotation mark (\") to be placed in `argv`.\r\n\r\nThis is also discussed at [_exec, _wexec Functions](https://docs.microsoft.com/en-us/cpp/c-runtime-library/exec-wexec-functions?view=vs-2019):\r\n\r\n> Spaces embedded in strings may cause unexpected behavior; for example, passing `_exec` the string `\"hi there\"` will result in the new process getting two arguments, `\"hi\"` and `\"there\"`. If the intent was to have the new process open a file named \"hi there\", the process would fail. You can avoid this by quoting the string: `\"\\\"hi there\\\"\"`.\r\n\r\n### How Python calls native executables\r\n\r\nPython's [`subprocess.Popen`](https://docs.python.org/3/library/subprocess.html#subprocess.Popen) can handle escaping correctly by converting `args` to a string in a manner described in [Converting an argument sequence to a string on Windows](https://docs.python.org/3/library/subprocess.html#converting-argument-sequence). The implementation is [`subprocess.list2cmdline`](https://github.com/python/cpython/blob/1def7754b7a41fe57efafaf5eff24cfa15353444/Lib/subprocess.py#L529).\r\n\r\nHope this can shed some light on how PowerShell can handle this in a more elegant manner, instead of using `--%` or double escaping (following both PowerShell and CMD syntax). The current workarounds really bug Azure CLI (which is based on python.exe) customers.\r\n\r\n",
      "created_at": "2020-06-03T03:54:30Z",
      "updated_at": "2020-06-03T03:54:30Z"
    },
    {
      "author": "musm",
      "author_association": "NONE",
      "body": "We still don't have a clear and concise method to understand how to handle this issue. Can anyone from the Powershell team shed light if this is simplified with v7?",
      "created_at": "2020-06-04T21:36:04Z",
      "updated_at": "2020-06-04T21:36:04Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "Well, the good news is that one of the focuses for PS 7.1 is to make it easier to invoke native commands.  From a [blog post on 7.1 investments](https://devblogs.microsoft.com/powershell/powershell-7-1-team-investments-and-preview-1-release/):\r\n\r\n> Most native commands work just fine from within PowerShell, however, there are some cases where the argument parsing is not ideal (like handling quotes properly). The intent is to enable users to cut sample command lines for any popular native tool, paste it into PowerShell, and it just works without needing PowerShell specific escaping.\r\n\r\nSo maybe (hopefully) this will get addressed in 7.1",
      "created_at": "2020-06-07T17:50:56Z",
      "updated_at": "2020-06-07T17:50:56Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @rkeithhill, but doesn't:\r\n\r\n> The intent is to enable users to cut sample command lines for any popular native tool, paste it into PowerShell, and it just works without needing PowerShell specific escaping.\r\n\r\nsound like another take on the inherently conceptually problematic `--%` (stop-parsing symbol)?\r\n\r\n@SteveL-MSFT, can you tell us more about this upcoming feature?\r\n\r\n---\r\n\r\nTo recap, the fix proposed here is that all you need to focus on is to satisfy _PowerShell_'s syntax requirements and that PowerShell takes care of all escaping _behind the scenes_ (on Windows; on Unix this is not even necessary anymore, now that .NET allows us to pass an array of verbatim tokens to the target program) - but there's no doubt that the fix would have to be opt-in, if backward compatibility must be maintained.\r\n\r\n**With this fix, _some_ fiddling with command lines for other shells will still be required, but it will be more straightforward** - and, compared to `--%`,  you retain the full power of PowerShell's syntax and variable expansions (expressions with `(...)`, redirections, ...):\r\n\r\n* You need to replace `\\\"` with `` `\" ``, but _only inside `\"...\"`_.\r\n\r\n* You need to be aware that _no (other) shell_ is involved, so that Bash-style environment-variable references such as `$USER` will _not_ work (they will be interpreted as _PowerShell_ variables), unless you replace them with the equivalent PowerShell syntax, `$env:USER`. \r\n  * As an aside: `--%` tries to compensate for that by - notably _invariably_ - expanding `cmd.exe`-style environment-variable references such as `%USERNAME%`, but note that it not only doesn't support Bash-style references (`$USER`) is passed _verbatim_ to the target program, but also unexpectedly expands `cmd.exe`-style references on Unix-like platforms, and doesn't recognize `'...'`-quoting.\r\n * See below for an alternative that _does_ involve the respective platform-native shell.\r\n\r\n* You need to be aware that PowerShell has _additional_ metacharacters that require quoting/escaping for verbatim use; these are (note that `@` is only problematic as an argument's _first_ char.):\r\n  * for POSIX-like shells (e.g., Bash): `` @  { } ` `` (and `$`, if you want to prevent up-front expansion by PowerShell)\r\n  * for `cmd.exe`: `` ( ) @ { } # ` ``\r\n  * Individually `` ` ``-escaping such chars. is sufficient (e.g., `` printf %s `@list.txt ``).\r\n\r\nA somewhat contrived example:\r\n\r\nTake the following Bash command line:\r\n\r\n```bash\r\n# Bash\r\n$ printf '\"%s\"\\n' \"3\\\" of snow\"\r\n\"3\" of snow\"        # output\r\n```\r\n\r\nWith the proposed fix in place , all that is needed is to replace the `\\\"` instances inside the `\"...\"`-enclosed argument with `` `\" ``:\r\n\r\n```powershell\r\n# PowerShell - WISHFUL THINKING\r\nPS> printf '\"%s\"\\n' \"3`\" of snow\"\r\n\"3\" of snow\"        # output\r\n```\r\n\r\nThat is, you wouldn't need to worry about embedded `\"` inside `'...'`, and inside `\"...\"` you only need to escape them to make _PowerShell_ happy (which you could also do with `\"\"` here).\r\n\r\nThe [above `iep` function](https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-562334606) implements this fix (as a stopgap), so that ``iep printf '\"%s\"\\n' \"3`\" of snow\" `` works as intended.\r\n\r\n---\r\n\r\nContrast this with the current, broken behavior, where you need to jump through the following hoops to get the command to work as in Bash (inexplicably need for an _additional_ round of escaping with `\\`):\r\n\r\n```powershell\r\n# PowerShell - messy workaround to compensate for the current, broken behavior.\r\nPS> printf '\\\"%s\\\"\\n' \"3\\`\" of snow\"\r\n\"3\" of snow\"        # output\r\n```\r\n\r\n---\r\n\r\nWith the fix in place, **those who want to use a given command line _as-is_ via the platform's _default shell_, will be able to use a verbatim _here-string_ to pass to `sh -c` (or `bash -c`) / `cmd /c`**; e.g.:\r\n\r\n```powershell\r\n# PowerShell - WISHFUL THINKING\r\nPS> sh -c @'\r\nprintf '\"%s\"\\n' \"3\\\" of snow\"\r\n'@\r\n\"3\" of snow\"  # output\r\n```\r\n\r\nNote that use of `--%` does _not_ work here (`printf --% '\"%s\"\\n' \"3\\\" of snow\"`), and the added advantage of the here-string-based approach is that the various `--%` limitations don't apply, notably the inability to use an output redirection (`>`).\r\n\r\nIf you switch to a _double_-quoted here-string (`@\"<newline>....<newline>\"@`), you can even embed _PowerShell variables and expressions_, unlike with `--%`; however, you then need to make sure that the expanded values don't break the syntax of the target shell.\r\n\r\n**We can think about a dedicated cmdlet with a succinct alias (e.g, `Invoke-NativeShell` / `ins`)** for such calls (so that `sh -c` / `cmd /c` needn't be specified), but in order to pass complex command lines as-is, I don't think a way around using here-strings:\r\n\r\n```powershell\r\n# PowerShell - WISHFUL THINKING\r\n# Passes the string to `sh -c` / `cmd /c` for execution, as appropriate.\r\n# Short alias: ins\r\nPS> Invoke-NativeShell @'\r\nprintf '\"%s\"\\n' \"3\\\" of snow\"\r\n'@\r\n\"3\" of snow\"  # output\r\n```\r\n\r\n**Of course, if you're relying on features of the platform-native shell, such calls will by definition be platform[-family]-specific** - they won't work on _both_ Windows and Unix-like platforms.\r\n\r\n**This is the reason why relying on PowerShell _alone_, with its _own syntax_ is preferable in the long run**: it provides a predictable cross-platform experience for calling external programs - even if that means that you cannot use command lines crafted for other shells as-is; as PowerShell gains in popularity, I expect the pain of discovering and knowing the required modifications to lessen, and I expect more and more documentation to show the PowerShell versions of command lines (too).\r\n\r\n\r\n\r\n",
      "created_at": "2020-06-08T15:45:03Z",
      "updated_at": "2020-06-24T20:31:07Z"
    },
    {
      "author": "aminya",
      "author_association": "NONE",
      "body": "> * You need to replace `\\\"` with `` `\" ``, but _only inside `\"...\"`_.\r\n\r\nThis does not work everywhere.\r\n\r\n```powershell\r\n# working everywhere but polluted with \\\r\n\u276f node -e 'console.log(\\\"hey\\\")'\r\nhey\r\n\r\n# working in Node:\r\n\u276f node -e 'console.log(`\"hey`\")'\r\nhey\r\n\r\n# not working in Julia:\r\n\u276f julia -e 'print(`\"hey`\")'\r\n`hey`\r\n\r\n# not working anywhere:\r\n\u276f node -e \"console.log(`\"hey`\")\"\r\n\u276f node -e \"console.log(\"hey\")\"\r\n\u276f node -e \"console.log(\"\"hey\"\")\"\r\n\u276f node -e 'console.log(\"\"hey\"\")'\r\n```\r\n\r\n# Bash syntax:\r\n```\r\n\u276f node -e 'console.log(\"hey\")'\r\nhey\r\n```\r\n\r\n# Powershell Suggestion:\r\n\r\nIf PowerShell team is just looking for a symbol, that does not break the previous syntax, why just not use something like a backticks ` for a Bash like behavior, which escapes literals automatically, and allows string interpolation. This is similar to JavaScript's syntax too.\r\n```\r\n\u276f node -e `console.log(\"hey\")`\r\nhey\r\n\r\n\u276f $a=hey \r\n\u276f node -e `console.log($hey)`\r\nhey\r\n```",
      "created_at": "2020-06-24T19:22:56Z",
      "updated_at": "2020-06-24T19:30:14Z"
    },
    {
      "author": "Artoria2e5",
      "author_association": "NONE",
      "body": "> why just not use something like a backticks ` for a Bash like behavior\r\n\r\nBackticks are already used for escaping stuff, the same purpose as backslahes in POSIX shell. The comment you are referring to already points that out. We have used up all the ASCII quote-like stuff. Adding a `$` prefix to normal string literals might work, but I don't think it makes enough sense.\r\n\r\n* * *\r\n\r\n> The way how Windows parses command-line arguments can be found at...\r\n\r\nThe problem is that Windows MSVCR doesn't just do that: it handles corner cases [in undocumented ways](http://daviddeley.com/autohotkey/parameters/parameters.htm#WINCRULESCHANGE). The `\"\"` stuff is so solidly set that they even put it into CoreFX when they ported .NET to Unix. But anyway, it's always good enough for escaping, at least until someone asks for globbing. \r\n\r\nThere's also the classic problem of everyone doing it differently, but we don't need to worry about that because we always have .NET for raw cmdline.",
      "created_at": "2020-06-24T20:14:03Z",
      "updated_at": "2020-06-24T20:30:38Z"
    },
    {
      "author": "aminya",
      "author_association": "NONE",
      "body": "> > why just not use something like a backticks ` for a Bash like behavior\r\n> \r\n> Backticks are already used for escaping stuff, the same purpose as backslahes in POSIX shell. We have used up all the ASCII quote-like stuff.\r\n\r\nThere is a possibility to use a combination of symbols if the parser is not able to detect that here \\` is introducing a string. Something like `''` might even work. ",
      "created_at": "2020-06-24T20:31:11Z",
      "updated_at": "2020-06-24T20:31:21Z"
    },
    {
      "author": "choovick",
      "author_association": "NONE",
      "body": "@aminya here is a solution is you are not using old windows Powershell 5.1 and on 6+:\r\nhttps://github.com/PowerShell/PowerShell/issues/1995#issuecomment-562334606\r\n\r\nAs I have to deal with PowerShell 5,1 on windows and 6+ on linux/mac, I have my own implementation that been working without issues for years that allows be to work with tools like kubectl, helm, terraform and others passing complex JSON objects within parameters:\r\nhttps://github.com/choovick/ps-invoke-externalcommand\n\n<blockquote><img src=\"https://avatars2.githubusercontent.com/u/3503712?s=400&v=4\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/choovick/ps-invoke-externalcommand\">choovick/ps-invoke-externalcommand</a></strong></div><div>Contribute to choovick/ps-invoke-externalcommand development by creating an account on GitHub.</div></blockquote>",
      "created_at": "2020-06-24T20:40:33Z",
      "updated_at": "2020-06-24T20:40:35Z"
    },
    {
      "author": "AndrewSav",
      "author_association": "NONE",
      "body": "@choovick somewhat shorter implementation was given [above in this thread](https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-303345059), I'm still to find a case where it would fail for me. This works in PS starting from v3.",
      "created_at": "2020-06-25T03:35:17Z",
      "updated_at": "2020-06-25T03:35:17Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@AndrewSav [@TSlivede's `Run-Native` function](https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-303345059) is very clever and concise, and commendably also works reliably in _Windows PowerShell_; a few things worth noting: of necessity, the child process sees the aux. `commandlineargumentstring` environment variable (probably rarely, if ever, a problem in practice), argument-less invocations are currently not handled correctly (easily fixed and not even a problem, if you make sure that you only ever use the function _with_ arguments, which is what it is for), _all_ arguments get double-quoted (e.g., something like `42` is passed as `\"42\"`), which on Windows can (unfortunately) have side effects for programs that interpret double-quoted (or partially double-quoted, as in the `msiexec` case) arguments differently.\r\n\r\n@aminya, the only reason that ``node -e 'console.log(`\"hey`\")'`` (sort of) works is because of the current, broken behavior (see below). I assume what you meant to pass was _verbatim_ `console.log(\"hey\")`, which, if PowerShell on Windows escaped things correctly as proposed here, you would pass as-is in single quotes: `node -e 'console.log(\"hey\")'`. This  should _automatically_ be translated to `node -e \"console.log(\\\"hey\\\")\"` (double-quoting, `\\`-escaped verbatim `\"`) _behind the scenes_. \r\n\r\nGiven how long this thread has become, let me try to recap: \r\nYou should only ever have to worry about _PowerShell_'s syntax requirements, and it is PowerShell's job _as a shell_ to ensure that the _verbatim argument values_ that result from PowerShell's own parsing are passed to the external program _as-is_. \r\n* On Unix-like platforms, now that we have .NET Core support for it, doing this is trivial, as the verbatim values can just be passed as-is as the elements of an _array_ of arguments, which is how programs natively receive arguments there. \r\n* On Windows, external programs receive arguments as a _single command-line string_ (a regrettable historical design decision) and must perform their own command-line parsing. Passing multiple arguments as part of a single string necessitates quoting and parsing rules in order to properly delineate arguments; while this is ultimately a free-for-all (programs are free to parse however they like), the most widely used syntax convention (as stated before and also proposed in the unfortunately [now abandoned RFC](https://github.com/PowerShell/PowerShell-RFC/pull/90#issuecomment-639742573)) is [what Microsoft's C/C++ compilers implement](https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args), so it makes sense to go with that.\r\n  * _Update_: Even on Windows we can take advantage of the collection-of-verbatim-tokens [`ArgumentList`](https://docs.microsoft.com/en-US/dotnet/api/System.Diagnostics.ProcessStartInfo.ArgumentList) property of `System.Diagnostics.ProcessStartInfo` in .NET Core: on Windows it is automatically translated to a properly quoted and escaped command-line string when the process is started; however, for _batch files_ we may still need special handling - see https://github.com/PowerShell/PowerShell-RFC/pull/90#issuecomment-552231174\r\n  \r\nImplementing the above is undoubtedly a massive breaking change, so it presumably requires an opt-in.\r\nI think that going ahead with this is a must, if we want to git rid of all the current quoting headaches, which keep coming up  and hamper PowerShell adoption, especially in the Unix world.\r\n\r\n---\r\n\r\nAs for  ``node -e 'console.log(`\"hey`\")'``: inside `'...'`, don't use `` ` `` - unless you want that character to be passed through as-is. Because PowerShell currently _doesn't_ escape the verbatim `\"` chars. in your argument as `\\\"` behind the scenes, what `node` sees on the command line is ``console.log(`\"hey`\")``, which is parsed as two directly adjacent string literals: unquoted `` console.log(` `` and double-quoted `` \"hey`\" ``. After stripping the `\"`, which have _syntactic_ function due to not being `\\`-escaped, the JavaScript code getting executed is ultimately ``console.log(`hey`)``, and that only happens to work because a `` `....` `` enclosed token is a form of string literal in JavaScript, namely a  _template literal_.\r\n",
      "created_at": "2020-06-25T14:00:06Z",
      "updated_at": "2020-06-25T21:25:18Z"
    },
    {
      "author": "choovick",
      "author_association": "NONE",
      "body": "@AndrewSav I have tested with my crazy test object and it did worked for me! Very elegant solution, tested on Windows 5.1 and PS 7 on linux. I'm ok with having everything double quoted, I don't deal with `msiexec` or `sqlcmd` also known to treat `\"` explicitly.\r\n\r\nMy personal implementation also has simple escape logic similar to one you mention: https://github.com/choovick/ps-invoke-externalcommand/blob/master/ExternalCommand/ExternalCommand.psm1#L278\r\n\r\nbut I have wrote bunch of code to display and capture STDOUT and STDERR threads in realtime within that module... It probably can be greatly simplified, but I had no need...\r\n\r\n@mklement0 this thread will never end (: We either need to provide published PowerShell module in the ps gallery that will suite most use cases and will be simple enough to use, or wait for upcoming shell improvements.\n\n<blockquote><img src=\"https://avatars2.githubusercontent.com/u/3503712?s=400&v=4\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/choovick/ps-invoke-externalcommand\">choovick/ps-invoke-externalcommand</a></strong></div><div>Contribute to choovick/ps-invoke-externalcommand development by creating an account on GitHub.</div></blockquote>",
      "created_at": "2020-06-25T20:10:21Z",
      "updated_at": "2020-06-25T20:10:23Z"
    },
    {
      "author": "aminya",
      "author_association": "NONE",
      "body": "> @mklement0 this thread will never end (: We either need to provide published PowerShell module in the ps gallery that will suite most use cases and will be simple enough to use, or wait for upcoming shell improvements.\r\n> \r\n\r\nIf the PowerShell team decides to not fix this in the program itself, I would then say that a shell that cannot run external programs natively and correctly will not be the shell of my choice! These are the basic stuff that are missing from PowerShell.",
      "created_at": "2020-06-25T20:20:15Z",
      "updated_at": "2020-06-25T20:20:15Z"
    },
    {
      "author": "choovick",
      "author_association": "NONE",
      "body": "@aminya yea, I found it that issue is very annoying myself when I had to move to it. But features like below made it worth it.\r\n\r\n- Flexible parameters framework, easy to build reliable CMDlets.\r\n- Modules and internal modules repositories to share common logic across organization, avoiding a lot of code duplication and centralization of core functionality that can be refactored in once place.\r\n- Cross platform. I have folks running my tools on Windows in PS 5.1, and on linux/mac in PS 6/7\r\n\r\nI really hope to PS team improves this in the future to make it less convoluted.",
      "created_at": "2020-06-26T12:45:02Z",
      "updated_at": "2020-06-26T12:45:02Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Implementing the above is undoubtedly a massive breaking change, so it presumably requires an opt-in.\r\n\r\nDo you mean implementing https://github.com/PowerShell/PowerShell-RFC/pull/90?",
      "created_at": "2020-06-26T13:48:52Z",
      "updated_at": "2020-06-26T13:48:52Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@aminya, I agree that calling external programs with arguments is a core mandate of a shell and must function properly.\r\n\r\nA module, as suggested by @choovick, still makes sense for _Windows PowerShell_, which is in security-critical-fixes-only maintenance mode.\r\nComplementarily, if/when the proposed conceptual help topic about calling external programs gets written - see  https://github.com/MicrosoftDocs/PowerShell-Docs/issues/5152 - a helper function that corrects the problems in earlier versions / Windows PowerShell's, such as @TSlivede's above, could be posted there directly.\r\n\r\n@iSazonov Yes, implementing https://github.com/PowerShell/PowerShell-RFC/pull/90 is what I meant.\r\n\r\nAs for the thread never ending and the breaking-change concerns:\r\n\r\nThe last official response to the linked RFC was [this comment by @joeyaiello  from 8 July 2019](https://github.com/PowerShell/PowerShell-RFC/pull/90#issuecomment-509346263) (emphasis added):\r\n\r\n> but we think that this [RFC] **makes a ton of sense irrespective of existing behavior and without regard for the breaking-ness** of it. Now that we have experimental features, we think it's perfectly reasonable to go and implement this today behind an experimental feature flag, and **we can figure out further down the line whether this is opt-in vs. opt-out behavior**, whether there's some transition path, and if a preference variable is the right mechanism for turning it on and off.\r\n\r\n_Personally_, I wouldn't mind fixing the behavior _by default_, even though that it is a breaking change; the RFC indeed proposes that and suggests an opt-in if you want the _old_ (broken) behavior.\r\n\r\nI suspect those with legacy code to maintain will object, however, as _all existing workarounds will cease to function_ - see [above](https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-562334606) - and maintaining backward compatibility still seems to be the overarching goal.\r\n\r\nIf the new, fixed behavior is made opt-in, you still have the awkwardness of having to do something just to get the right behavior, but at least existing code won't break.\r\n\r\nBut the existing opt-in mechanisms are themselves problematic:\r\nNow that @KirkMunro's [optional features RFC](https://github.com/PowerShell/PowerShell-RFC/pull/220) has been rejected, that pretty much leaves a _preference variable_, and the challenge there is PowerShell's dynamic scoping: third-party code called  from a scope that opted-in that was not designed to use the new implementation could then break (unless the preference variable is temporarily reset).\r\n\r\n_Lexical_ scoping of the opt-in is required here, which we currently don't have. The [RFC for _lexical_ scoping of strict mode](https://github.com/PowerShell/PowerShell-RFC/issues/7) proposes implementation of a lexically scoped feature (or a different purpose), via a `using` statement (which, notably, is generally _dynamically_ scoped). Following this pattern, a lexically scoped `using ProperExternalArgumentQuoting` statement (the name is a WIP :) - if technically feasible - is worth considering.\r\n\r\nWe need the PowerShell committee to weigh in (again) and to provide clear guidance as to the way forward, with _timely_ feedback on questions as they arise. @SteveL-MSFT?\r\n\r\n---\r\n\r\nNote that a `--%`-like solution hinted at by the 7.1 blog post (see [above](https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-640255068)) (which I personally think isn't worth pursuing - see [above](https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-640711192) and  [this comment](https://github.com/PowerShell/PowerShell/issues/12975#issuecomment-646276628)), would be a _separate_ feature - fixing PowerShell's native (non-emulation) behavior is still a must.\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-06-26T16:09:09Z",
      "updated_at": "2020-06-26T16:09:09Z"
    },
    {
      "author": "musm",
      "author_association": "NONE",
      "body": "> Personally, I wouldn't mind fixing the behavior by default, even though that it is a breaking change; the RFC indeed proposes that and suggests an opt-in if you want the old (broken) behavior.\r\n\r\n> If the new, fixed behavior is made opt-in, you still have the awkwardness of having to do something just to get the right behavior, but at least existing code won't break.\r\n\r\n\r\n\r\nAgreed, in fact I would argue it makes less sense to have a **broken** default, then a correctly implemented default. Given the fact that the current implementation is in fact a **bug**, the new behavior must be opt-in, not opt-out, since it really doesn't make sense to continue to encourage broken external shell calls that are prone to break in unexpected ways.  In any case,  PowerShell 7 should strive improve over the legacy Windows PowerShell.\r\n",
      "created_at": "2020-06-26T19:47:10Z",
      "updated_at": "2020-06-26T19:47:51Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT and I agreed we should close this one in favor of #13068. Anything we touch here is just too much of a breaking change, and we should address the problem with a new operator that serves as an opt-in mode. ",
      "created_at": "2020-07-02T18:42:49Z",
      "updated_at": "2020-07-02T18:42:49Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "I absolutely don't see how #13068 would resolve this: If that operator is introduced as intended we still have no way to properly call any native executable with a given array of arguments or with some explicit arguments whose content originates from variables.\r\n\r\nThe example, that @JustinGrote [gave in that thread](https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-652064173) currently doesn't work reliably (if embedded quotes are possible in the argument payload) and adding that operator will not give any alternative that improves anything.",
      "created_at": "2020-07-02T19:04:55Z",
      "updated_at": "2020-07-02T19:04:55Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "@joeyaiello Can you at least leave this issue open until that operator actually exists and somebody can show, how that operator would improve anything, that was mentioned in this thread?\r\n\r\nOh and also what about Linux? This issue is stupid and unexpected on Windows, but on Linux it makes even far less sense, especially as there is no loooong history of linux powershell scripts, that will break.",
      "created_at": "2020-07-02T19:07:58Z",
      "updated_at": "2020-07-02T19:07:58Z"
    },
    {
      "author": "Artoria2e5",
      "author_association": "NONE",
      "body": "Making a special operator for this doesn't make sense for a command-line shell at all, since its main job is to launch programs and pass them arguments. Introducing a new operator that does `system()` for this job is like Matlab introducing a way to call `calc.exe` because it has a bug in its arithmetics. What should instead be done is that:\r\n\r\n* The pwsh team prepares for a new major release that fixes the command-line stuff, moving the current behavior behind a built-in cmdlet.\r\n* As a stop-gap solution, the upcoming pwsh version gets a built-in cmdlet that uses the new, correct behavior for command-line passing.\r\n\r\nThe same applies to `Start-Process`. (Actually it's a pretty good candidate for the \"new\" cmdlet with some options like `-QuotingBehavior Legacy`...) See #13089.\r\n\r\n",
      "created_at": "2020-07-02T19:48:41Z",
      "updated_at": "2020-07-03T08:53:51Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> Why is Powershell behaving differently in these two situations? Specifically, it is inconsistently wrapping args containing spaces in double-quotes.\r\n\r\nI get consistent results in v.7.  Seems fixed.\r\n```powershell\r\nPING 'A \\\"B'\r\n```\r\n> Ping request could not find host A \"B.\r\n```powershell\r\nPING 'A\\\" B'\r\n```\r\n> Ping request could not find host A\" B.",
      "created_at": "2020-07-13T18:40:35Z",
      "updated_at": "2020-07-13T18:40:35Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "It' isn't fixed, because the verbatim hostnames that `ping` should see are `A \\\"B` and `A\\\" B` - _with_ the `\\` characters.\r\n\r\nPowerShell, as a shell, should parse the arguments according _its_ rules - only - and then transparently ensure that the target process sees the same verbatim values that were the result of PowerShell's own parsing. \r\n\r\nThat _other_ shells - and those poor programs running on Windows that must act like their own shell, in a manner of speaking, by having to parse a _command line_ just to extract the individual arguments passed - use `\\` as the escape character shouldn't enter the picture here - accommodating that (necessary on Windows only, on Unix you just pass the verbatim arguments directly as an array) is PowerShell's job as a shell, _behind the scenes_.\r\n\r\nAs an aside, just like PowerShell itself doesn't require escaping of `\"` _inside `'...'`_ (single-quoted strings), neither do POSIX-compatible shells such as `bash`: executed from `bash`, for instance, `/bin/echo 'A \\\"B'` (sensibly) prints `A \\\"B` (the `\\` are treated as literals in single-quoted strings) - that executing the very same command from PowerShell (unexpectedly) yields\r\n`A \"B` - the `\\` is missing - is a manifestation of the problems discussed here.\r\n\r\n ",
      "created_at": "2020-07-13T19:04:07Z",
      "updated_at": "2020-07-13T19:09:15Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I should clarify:\r\n\r\n* From the perspective of wanting to ultimately pass `A \"B` _verbatim_, you should be able to use `'A \"B'` from PowerShell.\r\n\r\n* The command line that PowerShell currently constructs behind the scenes contains `\"A \"B\"` - which the target process see as `A B` - that is, the blind enclosure in `\"...\"`, without escaping the _embedded_ `\"` resulted in the effective loss of the embedded `\"`. What PowerShell _should_ use in the behind-the-scenes command line in this case is `\"A \\\"B\"` - that is, the embedded `\"` needs `\\`-escaping.\r\n\r\n* Similarly, the same blind enclosure causes `'A \\\"B'` to be represented as `\"A \\\"B\"` on the behind-the-scenes command line, which just so happens to turn the _embedded_ `\\\"` into an _escaped_ `\"` character, which the target process therefore sees as `A \"B`; that is, the lack of _automatic_ escaping resulted in the effective loss of the embedded `\\`. What PowerShell _should_ use in the behind-the-scenes command line in this case is `\"A \\\\\\\"B\"` - that is, both the `\\` and the `\"` need escaping.",
      "created_at": "2020-07-13T19:39:00Z",
      "updated_at": "2020-07-13T19:48:06Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> It' isn't fixed, because the verbatim hostnames that `ping` should see are `A \\\"B` and `A\\\" B` - _with_ the `\\` characters.\r\n\r\n\"It\" refers here to the quoted complaint, which I fortunately cannot reproduce.",
      "created_at": "2020-07-13T19:56:27Z",
      "updated_at": "2020-07-13T19:56:27Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@yecril71pl, I see: my (incorrect) assumption was that the \"inconsistently wrapping args containing spaces in double-quotes\" refers to the _lack of automatic escaping of embedded `\"` and `\\` characters_, as explained in my previous comment - and that is the crux of this issue.\r\n\r\nThere have been minor fixes in PowerShell Core that Windows PowerShell doesn't have; I can only think of one right now:\r\n\r\n* Windows PowerShell uses blind double-quoting in case of a trailing `\\`: `'A B\\'` turns into (broken) `\"A B\\\"` - PS Core handles that correctly (`\"A B\\\\\"`).\r\n\r\nGiven that this repo is for PS Core only, it's sufficient to focus on what's still broken in PS Core (it can be helpful to mention differences _as an aside_, but it's best to make that aspect explicit).\r\n\r\n---\r\n\r\nAnd even the scenario you had in mind _is_ still broken in PS Core - but only _if you omit the `\\` from the argument_:\r\n\r\nPassing `'A\" B'` still results in _non_-double-quoted `A\" B` behind the scenes (whereas `'A\\\" B'` results in`\"A\\\" B\"` - which is also broken, as discussed - only differently).\r\n\r\n",
      "created_at": "2020-07-13T20:25:09Z",
      "updated_at": "2020-07-13T20:28:31Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> Given that this repo is for PS Core only, it's sufficient to focus on what's still broken in PS Core (it can be helpful to mention differences _as an aside_, but it's best to make that aspect explicit).\r\n\r\nMeta aside: I find it useful to know that wrong behaviour mentioned in another user\u2019s comment does not apply.  Of course, we could have dismissed the comment merely because the user did not bother to check the current version.  Well.  Unruly reporters being unruly, it is still better to be sure.  IMHO.\r\n",
      "created_at": "2020-07-13T20:46:52Z",
      "updated_at": "2020-07-13T20:46:52Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "No argument there, but  providing _proper framing and context_ to such _asides_ is important, especially in a looooong thread where the original comment - needed for context - was posted a long time ago and is, in fact, now _hidden_ by default (it never hurts to actually _link_ to the original comment being quoted).\r\n\r\n",
      "created_at": "2020-07-13T20:58:34Z",
      "updated_at": "2020-07-13T20:58:34Z"
    },
    {
      "author": "aminya",
      "author_association": "NONE",
      "body": "I wonder if these discussions make a difference. Clearly the committee's decisions are independent of what the community wants. Look at the tags: `Resolution- won't fix.` But since PowerShell is open source (MIT), the community can fix this in a separate fork, and call this PowerShellCommunity (`pwshc`) for short. \r\n\r\nThis removes the need for backward compatibility. Later in PowerShell 8, the committee might integrate the fork. \r\n\r\nAbout backward compatibility: PowerShell does not come preinstalled on any operating system, and to me, the hardship of installing `PowerShellCommunity` is the same as `PowerShell`. I prefer to install the community version and use it right away instead of waiting for some future 8 version (or making the code more complex with a new operator).",
      "created_at": "2020-07-13T21:00:30Z",
      "updated_at": "2020-07-13T21:13:59Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "Since the Committee has decided to keep things broken, it is better to know how badly broken they are.  I think the community can live with `Invoke-Native` that does the right thing.  It is not the community\u2019s job to save Microsoft\u2019s face against their will.",
      "created_at": "2020-07-13T21:38:22Z",
      "updated_at": "2020-07-13T21:38:22Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> it is better to know how badly broken they are\r\n\r\nI fully agree - even if the problem can't be helped in the moment, knowing how to do things right _in principle, if and when the time comes_ is important - even if that time _never_ comes in the context of a given language.\r\n\r\n> the community can live with `Invoke-Native` that does the right thing\r\n\r\nTo be clear: \r\n\r\n* Something like `Invoke-NativeShell` addresses a _different use case_ -  which is the subject of #13068 -  and for that use case such a cmdlet is _not_ a stopgap: it is the proper solution - see https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-656781439\r\n\r\n* _This_ issue is about fixing _PowerShell itself_ (it is not about platform-_native_ functionality), and the _stopgap_ solution to that is to provide a low-ceremony _opt-in_ - hence [the proposal to ship function `iep`](https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-656781439) as a built-in function, pending a _proper_ fix in a future version that is permitted to substantially break backward compatibility.\r\n\r\n> It is not the community\u2019s job to save Microsoft\u2019s face\r\n\r\nI don't think @aminya's concern is about saving anyone's face - it's about fixing fundamentally broken behavior in an area that is a shell's core mandate.\r\n\r\nThat said, I'm not sure that fragmenting the PowerShell ecosystem with a fork is the right way to go.\r\n\r\n\r\n\r\n",
      "created_at": "2020-07-13T22:01:49Z",
      "updated_at": "2020-07-13T22:02:50Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "I don't have time to respond to all this at just this moment, but I think this is reasonable, so I'm re-opening:\r\n\r\n> Can you at least leave this issue open until that operator actually exists and somebody can show, how that operator would improve anything, that was mentioned in this thread?",
      "created_at": "2020-07-13T22:11:34Z",
      "updated_at": "2020-07-13T22:11:34Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "As I said in related issue, native call operator adds **complexity** in UX and it is wrong direction.\r\nAt the same time, the whole discussion here is about **simplifying** interaction with native applications.\r\n\r\nThe only thing that stops us is that it is a breaking change. We have said many times that this is **too much** destruction, but let's weigh it.\r\n\r\nLet's look at an interactive session. An user will install new PowerShell version and discover new behavior when invoking native applications. What will he say? I will speculate that he will say - \"Thanks - finally I can just type and it works!\".\r\n\r\nLet's look at script execution/hosting scenario. Any new version of an application (even with one minor change!) can break a business process. We always expect this and check our processes after any updates. If we find a problem, then we have several ways:\r\n- rollback the update\r\n- prepare fast fix for script\r\n- turn off a feature which break our script until these things are fixed or they themselves die over time.\r\n\r\n_Since version updates always break something, the last option is the best that we could have and accept._\r\n\r\n(I want to point out that right now PowerShell Core is not a component of Windows and therefore cannot spoil hosting applications directly, only scripts are affected directly.)\r\n\r\nI want to remind you what Jason said above - this is a bug fix.\r\nLet us fix it and simplify everything for everyone. Let users works `powershell-y`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-07-15T07:11:01Z",
      "updated_at": "2020-07-15T10:11:40Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> As I said in related issue, native call operator adds **complicity** in UX and it is wrong direction.\r\n\r\ncomplexity \u2753",
      "created_at": "2020-07-15T07:57:00Z",
      "updated_at": "2020-07-15T10:12:02Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> Let's look at an interactive session. An user will install new PowerShell version and discover new behavior when invoking native applications. What will he say? I will speculate that he will say - \"Thanks - finally I can just type and it works!\".\r\n\r\nI have a different scenario: new users give PowerShell a try, realise that it mysteriously fails, move it to the Recycle Bin and never return.  That is what I would do.\r\n\r\n> prepare fast fix for script\r\n\r\nThat is something we should do to cover the obvious cases in user scripts.",
      "created_at": "2020-07-15T08:08:55Z",
      "updated_at": "2020-07-15T08:08:55Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> realise that it mysteriously fails\r\n\r\nThe whole discussion here is just about getting rid of this \"mysteriously fails\". And it\u2019s best to do this by simplifying but not adding new mysterious things.\r\n",
      "created_at": "2020-07-15T10:17:00Z",
      "updated_at": "2020-07-16T06:18:28Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> The whole discussion here is just about getting rid of this. And it\u2019s best to do this by simplifying but not adding new mysterious things.\r\n\r\nWe do not want to get rid of the ability to directly invoke executable programs.",
      "created_at": "2020-07-15T10:26:11Z",
      "updated_at": "2020-07-15T10:26:11Z"
    },
    {
      "author": "Artoria2e5",
      "author_association": "NONE",
      "body": "The old invocation is not direct to cmdline either with its guessing of whether something is already quoted. In addition, the said ability would still be retained with --%.",
      "created_at": "2020-07-15T12:49:46Z",
      "updated_at": "2020-07-15T12:50:19Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> In addition, the said ability would still be retained with --%.\r\n\r\n`--%` requires a predefined command line, so its utility is limited.\r\n",
      "created_at": "2020-07-15T13:11:13Z",
      "updated_at": "2020-07-15T13:11:13Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@yecril71pl \r\n\r\n> We do not want to get rid of the ability to directly invoke executable programs.\r\n\r\nI think @iSazonov means getting rid _of the buggy behavior_, i.e. fixing the bug properly (without opt-in via extra syntax), even though it means breaking existing workarounds. Correct, @iSazonov?\r\n\r\n@Artoria2e5:\r\n\r\n> The old invocation is not direct to cmdline either with its guessing of whether something is already quoted\r\n\r\n[_Update_: I misread the quoted line, but hopefully the information is still of interest.]\r\n\r\n* You don't have to _guess_, and the rule is simple: \r\n  * _Only if_ your command name or path is _quoted_  - `'/foo bar/someutil`' - and/or contains _variable references (or expressions) - `$HOME/someutil` - `&` is _required_.\r\n\r\n* While you may consider this need unfortunate, it is at the very heart of the PowerShell language, and necessitated by needing to able to syntactically distinguishing between the two fundamental parsing modes, argument mode and expression mode.\r\n  * Note that the issue is not specific to calling _external programs_; native PowerShell commands too require `&` for invocation if specified via a quoted string / variable reference.\r\n\r\n* If you don't want to memorize this simple rule, the simpler rule is: _always_ use `&`, and you'll be fine - it's somewhat less convenient than _not_ needing anything, but not exactly a hardship (and shorter than `--%`, which is absolutely the wrong solution - see below)\r\n\r\n> the said ability would still be retained with --%.\r\n\r\n[_Update_: I misread the quoted line, but hopefully the information is still of interest.]\r\n\r\nNo, despite the unfortunate conflation of  #13068 with _this_ issue, **`--%` - the ability to call the _native shell_, using _its_, invariably _platform-specific_  syntax - is in no way a workaround for the issue at hand and discussing it as such only adds to the confusion**.\r\n\r\n`--%` is a very different use case and, as currently proposed, has severe limitations; If there's something _not_ worth introducing an _operator_ for (or changing the behavior of an existing one), it's the ability to pass a verbatim command line to the native shell (which, of course, you can already do yourself, with `sh -c '...'` on Unix, and `cmd /c '...'`, _but only robustly if this issue gets fixed_; a binary `Invoke-NativeShell` / `ins` cmdlet implementation, while primarily abstracting away the details of the target shell CLI syntax, would avoid the issue at hand (by direct use of [`System.Diagnostics.ProcessStartInfo.ArgumentList`](https://docs.microsoft.com/en-US/dotnet/api/System.Diagnostics.ProcessStartInfo.ArgumentList)), and can therefore be implemented independently).\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-07-15T13:19:51Z",
      "updated_at": "2020-07-15T20:41:05Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "@yecril71pl \r\n>I have a different scenario: new users give PowerShell a try, realise that it mysteriously fails, move it to the Recycle Bin and never return. That is what I would do.\r\n\r\nCould you clarify: Do you fear, that the current behavior of powershell could lead to this unpleasant user experience, or do you fear that the proposed change leads to that userexperience.\r\n\r\nBecause in my opinion the current behavior of powershell is much more likely to generate such a experience. As said above: The current behavior of powershell should be considered a bug.",
      "created_at": "2020-07-15T13:22:37Z",
      "updated_at": "2020-07-15T13:23:03Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "Why would a new user, without any knowledge of PowerShell being broken, issue commands with contorted arguments?",
      "created_at": "2020-07-15T13:30:17Z",
      "updated_at": "2020-07-15T13:30:17Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "@yecril71pl Just to be absolutely sure: You consider the currently required form for arguments \"contorted\", not the suggested fix. ",
      "created_at": "2020-07-15T13:34:56Z",
      "updated_at": "2020-07-15T13:34:56Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "I consider your question as originating from your supposition that I am an incurable nerd.  That is correct\u2014but I have retained the ability to imagine what a normal random chap would consider contorted.",
      "created_at": "2020-07-15T13:41:36Z",
      "updated_at": "2020-07-15T13:41:36Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "@mklement0 \r\nI think, that @Artoria2e5 was talking about converting the array of arguments to the single [`lpCommandLine`](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw) string when saying\r\n>The old invocation is not direct to cmdline either with its guessing of whether something is already quoted\r\n\r\nBecause when calling\r\n```\r\nechoargs.exe 'some\"complicated_argument'\r\n```\r\nyou indeed have to more or less guess, whether powershell adds quotes around `some\"complicated_argument`.\r\n\r\nExample 1: In most powershell versions   \r\n`echoarg.exe 'a\\\" b'` and `echoarg.exe '\"a\\\" b\"'` will be translated to   \r\n`\"C:\\path\\to\\echoarg.exe\" \"a\\\" b\"` (tested versions 2.0; 4.0; 6.0.0-alpha.15; 7.0.1)   \r\nbut my default powershell on Win10 (version 5.1.18362.752) translates   \r\n`echoarg.exe 'a\\\" b'` to `\"C:\\path\\to\\echoarg.exe\" a\\\" b` and   \r\n`echoarg.exe '\"a\\\" b\"'` to `\"C:\\path\\to\\echoarg.exe\" \"\"a\\\" b\"\"`.\r\n\r\nExample 2: Older powershell versions translate   \r\n`echoarg.exe 'a\"b c\"'` to `\"C:\\path\\to\\echoarg.exe\"  \"a\"b c\"\"` (tested versions 2.0; 4.0;)   \r\nwhereas newer versions translate    \r\n`echoarg.exe 'a\"b c\"'` to `\"C:\\path\\to\\echoarg.exe\" a\"b c\"` (tested versions 5.1.18362.752; 6.0.0-alpha.15; 7.0.1).\r\n\r\n----\r\n\r\nAs the behavior was clearly already changed multiple times, I don't get why it can't be changed one more time to get the expected behavior.",
      "created_at": "2020-07-15T15:15:56Z",
      "updated_at": "2020-07-15T15:20:39Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I see, @TSlivede, thanks for clarifying, and sorry for the misinterpretation, @Artoria2e5.\r\n\r\nAs for the real problem: we're 100% in agreement - in fact, you should never even have to think about what `lpCommandLine` ends up being used behind the scenes on Windows; if PowerShell did the right thing, no one would have to (except for edge cases, but they are not PowerShell's fault, and that's when `--%` (as currently implemented) can help; with a proper fix, there will never be edge cases on Unix-like platforms).\r\n\r\nAs for simply fixing the problem properly: you certainly have my vote (but existing workarounds will break).\r\n\r\n",
      "created_at": "2020-07-15T15:32:07Z",
      "updated_at": "2020-07-15T15:32:07Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "TL;DR: The assumption that we can reliably pass any value as an argument to any program in the Microsoft Windows NT subsystem is *wrong*, so we should stop pretending that this is our goal.  However, there is still much to be rescued if we consider the *extent* of the argument.\r\n\r\nWhen invoking native Windows executables, we should preserve original quoting.  Example:\r\n```powershell\r\nCMD /CSTART=\"WINDOW TITLE\"\r\n```\r\n> The system cannot find the file WINDOW.\r\n```powershell\r\n { CMD /CSTART=\"WINDOW TITLE\" }. Ast. EndBlock. Statements. PipelineElements. CommandElements[1]\r\n```\r\n<BLOCKQUOTE ><DL ><DT >\r\nStringConstantType <DD >\r\n BareWord <DT >\r\nValue              <DD >\r\n /CSTART=WINDOW TITLE <DT >\r\nStaticType         <DD >\r\n System.String <DT >\r\nExtent             <DD >\r\n /CSTART=\"WINDOW TITLE\" <DT >\r\nParent             <DD >\r\n CMD /CSTART=\"WINDOW TITLE\"</DL ></BLOCKQUOTE >\r\n\r\nIf we took the *extent* as the template, we would not lose anything and we could call the native executable as expected.  The workaround of using a string argument works here but I do not think it is strictly technically necessary to do so, provided proper support gets implemented within PowerShell.  This approach would work for all cases.  \r\n\r\nQuotation marks within quotations present an insurmountable problem because there are tools that interpret backslash escape   (`TASKLIST \"\\\\\\\"PROGRAM FILES\"`) and tools that do not (`DIR \"\\\"\"PROGRAM FILES\" /B`) and tools that do not bother (`TITLE A \" B`).  However, if we were to escape, the standard escape with backslashes poisons all common file managing tools because they simply do not support quotation marks at all and double backslashes `\\\\` mean something entirely different to them (try `DIR \"\\\\\\\"PROGRAM FILES\" /B`), so sending an argument with a quotation mark inside should be a run-time error.  But we cannot throw an error because we do not know which one is which.  While using the normal escaping mechanism should not cause any harm to arguments that do not contain quotation marks, we cannot be sure that, when applied to arguments that do contain them and fed to a tool that does not support quotation marks as values, it would necessarily cause an aborting error rather than unexpected behaviour, and unexpected behaviour would be very bad indeed.  This is a serious burden we place upon the user.  In addition, we shall never be able to provide for \u2018don\u2019t care\u2019 tools (`CMD /CECHO='A  \"  B'`).\r\n\r\nNote that environment variables do not represent values in `CMD`, they represent code fragments that are reparsed as environment variables are expanded, and there is no provision for reliably treating them as arguments to other commands.   `CMD` just does not operate on objects on any kind, not even strings, which seems to be the root cause of the present conundrum.",
      "created_at": "2020-08-08T17:47:29Z",
      "updated_at": "2020-08-08T18:37:27Z"
    },
    {
      "author": "Dabombber",
      "author_association": "NONE",
      "body": "\r\n> TL;DR: The assumption that we can reliably pass any value as an argument to any program in the Microsoft Windows NT subsystem is _wrong_, so we should stop pretending that this is our goal.\r\n\r\nThat should be the goal though shouldn't it? It's not PowerShell's problem if a program can't interpret arguments it receives.\r\n\r\n> When invoking native Windows executables, we should preserve original quoting. Example:\r\n> \r\n> ```powershell\r\n> CMD /CSTART=\"WINDOW TITLE\"\r\n> ```\r\n\r\nAre you suggesting calling a program should dynamically change the language from PowerShell to whatever the invoked program uses? You wrote that example in PowerShell, which means it should be equivalent to any of the following\r\n\r\n```powershell\r\nCMD \"/CSTART=WINDOW TITLE\"\r\nCMD '/CSTART=WINDOW TITLE'\r\nCMD /CSTART=WINDOW` TITLE\r\n```",
      "created_at": "2020-08-09T09:46:33Z",
      "updated_at": "2020-08-09T09:46:33Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> > TL;DR: The assumption that we can reliably pass any value as an argument to any program in the Microsoft Windows NT subsystem is _wrong_, so we should stop pretending that this is our goal.\r\n> \r\n> That should be the goal though shouldn't it? It's not PowerShell's problem if a program can't interpret arguments it receives.\r\n\r\nThe program `CMD` *can* interpret the argument `/CECHO=A \" B` but PowerShell *cannot* pass it without distorting it.\r\n\r\n> \r\n> > When invoking native Windows executables, we should preserve original quoting. Example:\r\n> > ```powershell\r\n> > CMD /CSTART=\"WINDOW TITLE\"\r\n> > ```\r\n> \r\n> Are you suggesting calling a program should dynamically change the language from PowerShell to whatever the invoked program uses? You wrote that example in PowerShell, which means it should be equivalent to any of the following\r\n> \r\n> ```powershell\r\n> CMD \"/CSTART=WINDOW TITLE\"\r\n> CMD '/CSTART=WINDOW TITLE'\r\n> CMD /CSTART=WINDOW` TITLE\r\n> ```\r\n\r\nI tried to suggest that, when interfacing with external programs under Microsoft Windows NT subsystem, PowerShell has a myriad ways to encode the arguments that are all equivalent to PowerShell but not equivalent to the receiving program.  Being blunt and forcing the One True Way&trade; of encoding arguments, without paying attention to what quoting arrangement the user actually used, is not helpful, to say it mildly.",
      "created_at": "2020-08-09T10:49:55Z",
      "updated_at": "2020-08-09T10:49:55Z"
    },
    {
      "author": "imgx64",
      "author_association": "NONE",
      "body": "@yecril71pl I'm really confused by your comments. What exactly are you proposing here? Your use cases are all covered by `--%`. You dismissed it earlier by saying\r\n> `--%` requires a predefined command line, so its utility is limited.\r\n\r\nBut in fact you can use environment variables with `--%`. Try This:\r\n\r\n    PS > $env:mytitle='WINDOW TITLE'\r\n    PS > cmd --% /CSTART=\"%mytitle%\"\r\n\r\nSo what am I missing?",
      "created_at": "2020-08-09T11:44:40Z",
      "updated_at": "2020-08-09T11:44:40Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "We are missing the syntax `CMD /CSTART=\"$mytitle\"`, without leaking things to `ENV:`.",
      "created_at": "2020-08-09T11:55:45Z",
      "updated_at": "2020-08-09T11:55:45Z"
    },
    {
      "author": "Artoria2e5",
      "author_association": "NONE",
      "body": "As a terrible idea, we do have the option of replacing `Environment.ExpandEnvironmentVariables` with something else. There's no native implementation on Unix anyways, and I don't believe the stuff it processes would become performance-critical when rewritten in C#.\r\n\r\nSince equal signs are not allowed in env var names anyways, we can have `%=$a%` mean `$a`. This wouldn't break anything existing while allowing for some very flexible (and possibly bad) extensions like making it work like JS's template strings. Hell, we can define `%VARNAME=$var%` as some sort of fallback syntax too.\r\n\r\nAs for the documentation hell this would cause... I apologize.",
      "created_at": "2020-08-09T20:02:34Z",
      "updated_at": "2020-08-11T15:16:33Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "* **We do _not_ have a parsing problem.**\r\n\r\n* **What we do have is a problem with _how PowerShell passes the verbatim, stringified arguments that have resulted from _its_ parsing to external (native) executables_:**\r\n\r\n  * **On _Windows_, the problem is that the command line to invoke the external executable with that is constructed behind the scenes does _not_ adhere to the most widely used convention for quoting arguments**, as detailed in the the Microsoft C/C++ compiler documentation's [Parsing C++ command-Line arguments](https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args?view=vs-2019#parsing-c-command-line-arguments) section.\r\n\r\n    * What happens currently isn't even that a _different_ convention is used: presumably due to an oversight, the command lines that are constructed are situationally _syntactically fundamentally broken_, depending on the specifics of the arguments, relating to a combination of embedded double quotes and spaces as well as empty-string arguments.\r\n\r\n    * Ultimately, the problem is the fundamental architecture of process creation on Windows: You're forced to encode the arguments to pass to a process _as a command line_ - a single string representing _all_ arguments - rather than passing them as an _array_ of arguments (which is how Unix-like platforms do it). The need to pass a command line requires _quoting and escaping rules_ to be implemented, and it is ultimately _up to each program_ how to interpret the command line it is given. In effect, this amounts to needlessly forcing programs to be a mini-shell of sorts: they're forced to _re-perform_ the task that the shell has already performed, which is task that should be the purview of a _shell only_ (as is the case on Unix), namely parsing a command line into individual arguments. In a nutshell, this is the [anarchy that is argument passing on Windows](https://stackoverflow.com/a/4094897/45375).\r\n\r\n    * In practice, the anarchy is mitigated by _most_ programs adhering to the aforementioned convention, and new programs being developed are highly likely to adhere to that convention, primarily because widely used runtimes underpinning console applications implement these conventions (such as the Microsoft C/C++ / .NET runtimes). The sensible solution is therefore:\r\n      * Make PowerShell adhere to this convention when building the command line behind the scenes.\r\n      * For \"rogue\" programs that do _not_ adhere to this convention - which notably includes `cmd.exe`, batch files, and Microsoft utilities such as `msiexec.exe` and `msdeploy.exe` - provide a mechanism to explicitly control the command line passed to the target executable; this is what `--%`, the [stop-parsing symbol](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_Parsing) provides - albeit [quite awkwardly](https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-661984949).\r\n\r\n  * **On _Unix_, the problem is that _a command line is being constructed at all_ - instead, the array of verbatim arguments should be passed _as-is_**, which .NET Core now supports (since v2.1, via [`ProcessStartInfo.ArgumentList`](https://docs.microsoft.com/en-US/dotnet/api/System.Diagnostics.ProcessStartInfo.ArgumentList); it should _always_ have supported this, given that - sensibly - _there are no command lines_, only argument arrays, when a process is created on Unix-like platforms).\r\n\r\n    * Once we use `ProcessStartInfo.ArgumentList`, all problems on Unix go away.\r\n\r\nFixing these issues is what @TSlivede's https://github.com/PowerShell/PowerShell-RFC/pull/90 is all about.\r\n\r\nIn https://github.com/PowerShell/PowerShell-RFC/pull/90#issuecomment-650242411 I've proposed additionally automatically compensating for the \"roguishness\" of batch files, given their still very widespread use as CLI entry points for high-profile software such as Azure (CLI `az` is implemented as a batch file, `az.cmd`). \r\nSimilarly, we should consider doing the same for `msiexec.exe` and `msdeploy.exe` and perhaps other high-profile \"rogue\" Microsoft CLIs.\r\n\r\n---\r\n\r\nI've just published a module, **[`Native`](https://github.com/mklement0/Native)**, (`Install-Module Native -Scope CurrentUser`) that addresses all of the above via its **`ie` function** (short for *i*nvoke (external) *e*xecutable; it is a more complete implementation of the `iep` function introduced [above](https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-656781439)).\r\n\r\nIt also includes **`ins` (`Invoke-NativeShell`)**, which addresses #13068, and **`dbea` (`Debug-ExecutableArguments`)** for diagnosing argument passing - see https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-671572939 for details.\r\n\r\nIn other words: `ie` can serve as an unobtrusive stopgap while we wait for this issue to be fixed, simply by prefixing invocations with `ie` as the command:\r\n\r\nInstead of:\r\n\r\n```powershell\r\n# This command is currently broken, because the '{ \"name\": \"foo\" }' argument isn't properly passed.\r\ncurl.exe -u jdoe  'https://api.github.com/user/repos' -d '{ \"name\": \"foo\" }'\r\n```\r\n\r\nyou'd use the following:\r\n\r\n```powershell\r\n# OK, thanks to `ie`\r\nie curl.exe -u jdoe  'https://api.github.com/user/repos' -d '{ \"name\": \"foo\" }'\r\n```\r\n\r\n---\r\n\r\nAs for the `CMD /CSTART=\"WINDOW TITLE\"` example (whose more idiomatic form is `cmd /c start \"WINDOW TITLE\"`, which does already work):\r\n\r\nIt is in essence the same problem as with `prop=\"<value with spaces>\"` arguments for `msiexec` / `msdeploy`: PowerShell - justifiably - transforms `/CSTART=\"WINDOW TITLE\"` into `\"/CSTART=WINDOW TITLE\"`, which, however breaks the `cmd.exe` invocation.\r\n\r\nThere are two ways to resolve this:\r\n\r\n* Delegate to `ins` / `Invoke-NativeShell` (note that the use of `cmd.exe /c` is effectively implied):\r\n\r\n  * `ins 'START=\"WINDOW TITLE\"'`\r\n  * If you use an _expandable_ string, you can embed PowerShell values in the command string.\r\n     * ``$title = 'window title'; ins \"START=`\"$title`\"\" ``\r\n\r\n* Alternatively, use the current `--%` implementation, but beware [its limitations](https://github.com/MicrosoftDocs/PowerShell-Docs/issues/6149):\r\n\r\n  * `cmd --% /CSTART=\"WINDOW TITLE\"`\r\n  * As discussed, a problematic limitation of `--%` is that the only way to embed _PowerShell_ values is to use an _aux. environment variable_ and reference it with `%...%` syntax:\r\n     * ``$env:_title = 'window title'; cmd --% /CSTART=\"%_title%\" ``\r\n     * To avoid this limitation, `--%` should always have been implemented with a _single_ string argument - e.g.,\r\n`cmd --% '/CSTART=\"WINDOW TITLE\"'` or `` cmd --% \"/CSTART=`\"$title`\"\" `` - but this can't be changed without breaking backward compatibility, so a _new_ symbol would have to be introduced - personally, I don't see the need for one.\r\n\r\n",
      "created_at": "2020-08-11T13:47:46Z",
      "updated_at": "2020-08-12T14:47:39Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> * they're forced to _re-perform_ the task that the shell has already performed\r\n\r\nI do not think `CMD.EXE` splits command lines into arguments, the only thing that is needed is to find out which executable to call and the rest is just the command line as written by the user (after environment variable substitutions, which are done without any regard for argument boundaries).  Of course, internal shell commands are an exception here.\r\n\r\n> It is in essence the same problem as with `prop=\"<value with spaces>\"` arguments for `msiexec` / `msdeploy`\r\n\r\nI am not a confident user of either, so I preferred to bring up something I am more familiar with.",
      "created_at": "2020-08-11T14:33:40Z",
      "updated_at": "2020-08-11T14:34:51Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "To be clear: the following has no impact on the points made in my previous comment.\r\n\r\n> I do not think `CMD.EXE` splits command lines into arguments\r\n\r\n* It can get away without _explicit_ splitting when calling _external executables_ (commands run by another executable in a child process), but it does have to do it for _batch files_.\r\n\r\n* Even when calling external executables it needs to be _aware_ of argument boundaries, so as to determine whether a given metacharacter (e.g. `&`) has _syntactic_ function or whether it is part of a double-quoted argument and therefore to be treated as a literal:\r\n\r\n```cmd\r\n:: OK - the \"...\" around & tells cmd.exe to use it verbatim\r\nC:\\>echoArgs.exe one \"two & three\"\r\nArg 0 is <one>\r\nArg 1 is <two & three>\r\n\r\nCommand line:\r\n\"C:\\ProgramData\\chocolatey\\lib\\echoargs\\tools\\EchoArgs.exe\" one \"two & three\"\r\n```\r\n\r\nAlso, `cmd.exe` recognizes _embedded_ `\"` chars. in `\"...\"` strings are recognized if escaped as `\"\"`:\r\n\r\n```cmd\r\n:: OK - the \"\" is recognized as an escaped \"\r\nC:\\>echoArgs.exe \"3\"\" of rain & such.\"\r\nArg 0 is <3\" of rain & such.>\r\n\r\nCommand line:\r\n\"C:\\ProgramData\\chocolatey\\lib\\echoargs\\tools\\EchoArgs.exe\" \"3\"\" of rain & such.\"\r\n```\r\n\r\nUnfortunately, `cmd.exe` _only_ supports (the Windows-only) `\"\"` and not also the more widely used `\\\"` (which is what POSIX-like _shells_ on Unix _exclusively_ use - note: _shells_, not _programs_, because programs just see the array of verbatim arguments that result from the shell's parsing).\r\n\r\nWhile most CLIs on Windows support _both_ `\"\"` and `\\\"`, some _only_ understand `\\\"` (notably Perl and Ruby), and then you're in trouble:\r\n\r\n```cmd\r\n:: !! BROKEN: cmd.exe misinterprets the & as *unquoted*, thinks it's the statement-sequencing operator, \r\n:: !! and tries to execute `such`:\r\nC:\\>echoArgs.exe \"3\\\" of rain & such.\"\r\nArg 0 is <3\" of rain >\r\n\r\nCommand line:\r\n\"C:\\ProgramData\\chocolatey\\lib\\echoargs\\tools\\EchoArgs.exe\" \"3\\\" of rain\r\n\r\n'such.\"' is not recognized as an internal or external command,\r\noperable program or batch file.\r\n```\r\n\r\nTherefore: \r\n\r\n* Avoid calling `cmd.exe` directly, if possible.\r\n\r\n  * Call external executables directly (once this issue is fixed) or via `ie` (for now), using _PowerShell's_ syntax.\r\n\r\n* If you do have to call `cmd.exe`, use `ins` / `Invoke-NativeShell` for general simplicity and, specifically, for how easy it is to embed PowerShell variable and expression values into the command line.\r\n\r\n  * A legitimate reason to still call `cmd.exe` directly is to compensate for PowerShell's lack of support for raw byte data in the pipeline - see [this SO answer](https://stackoverflow.com/a/59118502/45375) for an example.\r\n\r\n\r\n",
      "created_at": "2020-08-11T15:40:31Z",
      "updated_at": "2020-08-11T16:09:30Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "I know I'm going to catch a lot of flak here, and I really appreciate the depth of the discussion happening, but...*ducks*...does anyone have an example of any of this actually mattering in a real-world scenario? \r\n\r\nIt's my take that we are not empowered in PowerShell to solve the \"anarchy\" that currently exists with Windows argument parsing. And for many of the same reasons that we can't solve the problem, there's a good reason that Windows and the VC++ compilers have chosen not to break this behavior. It's rampant, and we're only going to create a really long tail of *new* (and largely undecipherable) problems if we change things. \r\n\r\nFor those utilities which are already cross-platform and in heavy use between Windows and Linux (e.g. Docker, k8s, Git, etc.), I don't see this problem manifesting in the real world. \r\n\r\nAnd for those \"rogue\" applications that do a poor job: they're largely legacy, Windows-only utilities.\r\n\r\nI agree that what you've described @mklement0 is largely a \"correct\" solution. I just don't know how to get there without really screwing things up. \r\n\r\n\r\n",
      "created_at": "2020-08-12T22:03:00Z",
      "updated_at": "2020-08-12T22:03:00Z"
    },
    {
      "author": "cspotcode",
      "author_association": "NONE",
      "body": "Pretty basic usages break:\r\n```\r\n\u276f git commit --allow-empty -m 'this is what we call a \"commit message\" which contains arbitrary text, often with punctuation'\r\nerror: pathspec 'message which contains arbitrary text, often with punctuation' did not match any file(s) known to git\r\n\u276f $a = 'this is what we call a \"commit message\" which contains arbitrary text, often with punctuation'\r\n\u276f git commit --allow-empty -m \"$a\"\r\nerror: pathspec 'message which contains arbitrary text, often with punctuation' did not match any file(s) known to git\r\n```\r\n\r\n```\r\n\u276f $PSVersionTable\r\n\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.0.3\r\nPSEdition                      Core\r\nGitCommitId                    7.0.3\r\nOS                             Microsoft Windows 10.0.19042\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```",
      "created_at": "2020-08-12T22:10:52Z",
      "updated_at": "2020-08-12T22:10:52Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "`git.exe` is a well-behaved application, so the fix in PowerShell will be straightforward, albeit requiring all scripters out there to revert their smart work-arounds.  `cmd.exe` is harder to adapt to and requires a much more considerate approach that may solve a few problems but probably not all of them.  Which is actually appalling, considering that PowerShell started as a Windows NT tool.  I understand this question as _whether there is a real-life scenario when an ill-behaved legacy utility like `cmd.exe` will be called from PowerShell in a way that causes problems in the interface_.  PowerShell tried to approach this problem by duplicating most of the functionality in `cmd.exe`, so as to make `cmd.exe` redundant.  This is also possible for other tools, for example MSI can be operated via ActiveX, although doing so requires considerable knowledge.  So is there anything essential that is not covered?",
      "created_at": "2020-08-12T22:29:04Z",
      "updated_at": "2020-08-12T22:29:04Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee discussed this.  We appreciate the git example which clearly shows a real world compelling example.  We agreed that we should have an experimental feature early in 7.2 to validate the impact of taking such a breaking change.  An additional test example shows that even `--%` has a problem even though it should have been unparsed:\r\n\r\n```powershell\r\nPS> testexe --% -echoargs 'a b c \"d e f \" g h'\r\nArg 0 is <'a>\r\nArg 1 is <b>\r\nArg 2 is <c>\r\nArg 3 is <d e f >\r\nArg 4 is <g>\r\nArg 5 is <h'>\r\n```\r\n\r\nThis appears to be a problem in the native command parameter binder.",
      "created_at": "2020-08-12T22:46:01Z",
      "updated_at": "2020-08-12T22:48:33Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "Yeah, thank you @cspotcode. That example was definitely an aha moment for me (especially considering I've actually hit that one in the real world). \r\n\r\nI'm still concerned about the breaking change aspect, and it's my take that this is a could candidate for an experimental feature that may remain experimental over multiple versions of PowerShell, and that is absolutely not something we're sure will eventually make it. \r\n\r\nI also need to dig in more to understand the allow list / \"rouge app\" aspect of your RFC, @mklement0, as I'm not sure how much we want to sign up to maintain a list like that. ",
      "created_at": "2020-08-12T22:53:42Z",
      "updated_at": "2020-08-12T22:53:42Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@joeyaiello  and @SteveL-MSFT, let me make a meta observation first:\r\n\r\nWhile it's good to see that  @cspotcode's example gave you a _glimpse_ of the problem, your responses still betray a fundamental lack of understanding and appreciation of the (magnitude of the) underlying problem (I will argue this point in a later comment).\r\n\r\nThis is not a _personal_ judgment: I fully recognize how difficult it must be to be stretched very thin and to have to make decisions on a very wide range of subjects in a short amount of time.\r\n\r\nHowever, this points to a _structural_ problem: To me it seems that decisions are routinely made by the @PowerShell/powershell-committee on the basis of a superficial understanding of the problems being discussed, to the detriment of the community at large.\r\n\r\nTo me, the committee's response to the issue being discussed here is the most consequential example of this structural problem to date.\r\n\r\nTherefore, I ask you to consider this:\r\n\r\nHow about appointing subject-matter-specific _sub_-committees that the committee consults with that _do_ have the required understanding of the issues involved?\r\n\r\n\r\n\r\n",
      "created_at": "2020-08-13T01:29:31Z",
      "updated_at": "2020-08-13T01:42:35Z"
    },
    {
      "author": "musm",
      "author_association": "NONE",
      "body": "can you share the content of `testexe ` SteveL-MSFT, just want to make sure !",
      "created_at": "2020-08-13T03:01:20Z",
      "updated_at": "2020-08-13T03:01:20Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@TSlivede summarized the problem aptly in https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-665125375:\r\n\r\n> PowerShell on the other hand claims to be a shell (until\u00a0#1995\u00a0is solved, I won't say that it\u00a0_is_\u00a0a shell)\r\n\r\nAs stated many times before, a core mandate of a shell is to call external executables with arguments.\r\n\r\nPowerShell currently fails to fulfill this mandate, given that arguments with embedded double quotes and empty-string arguments aren't passed correctly.\r\n\r\nAs stated before, this may have been less of a problem in the Windows-only days, where the lack of capable external CLIs rarely surfaced this problem, but these days are gone, and if PowerShell wants to establish itself as a credible cross-platform shell, it must address this problem.\r\n\r\n@cspotcode's `git` example is a good one; any executable to which you want to pass a JSON string - e.g., `curl` - is another:\r\n\r\n```powershell\r\n# On Unix; on Windows, \r\n#   echoArgs.exe '{ \"foo\": \"bar\" }' \r\n# would show the same problem.\r\nPS> /bin/echo '{ \"foo\": \"bar\" }'\r\n{ foo: bar }  # !! Argument was incorrectly passed.\r\n```\r\n\r\nLeaving backward compatibility aside:\r\n\r\n* On Unix, the problem is trivially and _completely_ solved by using `ProcessStartInfo.ArgumentList` behind the scenes.\r\n\r\n* On Windows, the problem is trivially and _mostly_ solved by using `ProcessStartInfo.ArgumentList` behind the scenes.\r\n  * For edge cases (\"rogue\" CLIs), there's the ([poorly implemented](https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-661984949)) `--%`\r\n  * As a _courtesy_, we can compensate for certain well-known edge cases to lessen the need for `--%` - see below.\r\n\r\nTherefore, _as soon as possible_, one of the following choices must be made:\r\n\r\n* Realize the importance of making argument-passing work properly and _fix it at the expense of backward compatibility_.\r\n\r\n* If backward compatibility is really paramount, provide a new operator or a function such as the `ie` function from the[ `Native` module](https://github.com/mklement0/Native) that fixes the problem, and widely publicize it as the only reliable way to invoke external executables.\r\n\r\nProposing an _experimental_ feature to address a badly broken fundamental feature is wholly inadequate.\r\n\r\n---\r\n\r\n@SteveL-MSFT \r\n\r\nEven considering use of `--%` as the solution to this problem is fundamentally misguided:\r\n\r\nIt is a _Windows-only_ feature that knows only `\"...\"` quoting and `%...%`-style environment-variable references.\r\n\r\nOn Unix, the concept of \"stopping parsing\" fundamentally doesn't apply: _there is no command line_ to pass to child processes, only arrays of arguments.\r\n\r\nThus, _someone_ has to parse the command line into arguments _before_ invocation, which is implicitly delegated to the `ProcessStartInfo` class, via its `.Arguments` property, which on Unix uses the _Windows_ conventions for parsing a command line - and therefore recognizes `\"...\"` quoting (with escaping of embedded `\"` as `\"\"` or `\\\"`) only.\r\n\r\n**`--%` is a Windows-only feature whose only legitimate purpose is to call \"rogue\" CLIs.**\r\n\r\n----\r\n\r\n@joeyaiello \r\n\r\n> that Windows and the VC++ compilers have chosen not to break this behavior.\r\n\r\n**The VC++ compiler _imposes a sensible, widely observed convention_**, to bring order to the anarchy.\r\n\r\n**It is precisely adherence to this convention that is being advocated for here**, which use of `ProcessStartInfo.ArgumentList` would automatically give us.\r\n\r\n_This alone will cover the vast majority of calls. Covering ALL calls is impossible and indeed not PowerShell's responsibility._\r\n\r\nAs stated, for \"rogue\" CLIs that require non-conventional forms of quoting, `--%` must be used (or `ins` / `Invoke-NativeShell` from the `Native` module).\r\n\r\n_As a courtesy_, we can automatically compensate for well-known \"rogue\" scenarios, namely calling batch files and certain high-profile Microsoft CLIs:\r\n\r\n* The batch-file case is a generic one, and easily explained and conceptualized (e.g, pass `a&b` as `\"a&b\"`, even though it shouldn't require quoting) - it will avoid the need for use of `--%` with all CLIs that use batch files as their entry point (which is quite common), such as Azure's `az.cmd`\r\n\r\n* The alternative to hard-coding exceptions for specific CLIs - which admittedly can get confusing - is to detect the following _pattern_ in the arguments that result from PowerShell's parsing - `<word>=<value with spaces>` - and, instead of passing `\"<word>=<value with spaces>\"`, as currently happens, to pass `<word>=\"<value with spaces>\"`; the latter satisfies the \"rogue\" CLIs, while also being accepted by convention-adhering CLIs; e.g., `echoArgs \"foo=bar baz\"` ultimately sees the same first argument as `echoArgs --% foo=\"bar baz\"`\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-08-13T04:25:17Z",
      "updated_at": "2020-08-13T04:25:17Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@musm You can find the source code of `TestExe` at https://github.com/PowerShell/PowerShell/blob/master/test/tools/TestExe/TestExe.cs.\n\n<blockquote><img src=\"https://repository-images.githubusercontent.com/49609581/aad0ad80-cdec-11ea-8248-a37bc0571bfd\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/PowerShell/PowerShell\">PowerShell/PowerShell</a></strong></div><div>PowerShell for every system! Contribute to PowerShell/PowerShell development by creating an account on GitHub.</div></blockquote>",
      "created_at": "2020-08-13T05:59:43Z",
      "updated_at": "2020-08-13T05:59:45Z"
    },
    {
      "author": "Dabombber",
      "author_association": "NONE",
      "body": "I think that accommodating exceptions by default is just going to lead to a similar situation as the current one, where people need to revert PowerShell's \"helpfulness\". If there are exceptions, it should be obvious they're being applied.\r\n\r\nMaybe something like:\r\n```powershell\r\n# Arguments passed correctly, without regard for the program's ability to handle them\r\n& $program a \"\" 'c \"d e\" f'\r\n# Try to pass the arguments intelligently based on the program being called\r\n&[] $program a \"\" 'c \"d e\" f'\r\n# Escape the arguments for a batch file, eg) \" -> \"\"\r\n&[bat] $program a \"\" 'c \"d e\" f'\r\n```\r\nI'm really struggling to find syntax for this which isn't broken. At least this sort of makes sense if you think of it as casting the program, but casting the actual variable containing the program would require enclosing parenthesis.\r\n\r\nThat, in addition to allowing people to add exceptions for whatever broken behaviour they desire should hopefully eliminate the need for `--%`. The exception class they register would then have a method for determining if it's applicable to the program (for intelligent invocation), and an escaping method where you just throw the command abstract syntax tree at it and it returns the argument array/string.",
      "created_at": "2020-08-13T06:51:31Z",
      "updated_at": "2020-08-13T06:51:31Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> * instead of passing `\"<word>=<value with spaces>\"`, as currently happens, to pass `<word>=\"<value with spaces>\"`\r\n\r\nThe quotes used to construct the command line should follow the way the call is quoted in PowerShell.  Therefore:\r\n1. A call that does not contain double quotes in its text should put double quotes around the whole value.\r\n2. A call that contains double quotes should retain them as written in the script _if possible_.\r\n\r\nIn particular:\r\n| script argument | command line |\r\n| ----------------- | ---------------- |\r\n| `p=l of v` | \"p=l of v\" |\r\n| `` p=l` of` v`` | \"p=l of v\" |\r\n| `p=\"l of v\"` | p=\"l of v\" |\r\n| `p=\"l of v\"'a s m'` | p=\"l of v\"a\" s m\" |\r\n| `p=\"l of v\"' s m'` | p=\"l of v s m\" |\r\n\r\nThe last row shows an example where it will not be possible to retain the original double quotes.\r\n\r\n",
      "created_at": "2020-08-13T08:01:38Z",
      "updated_at": "2020-08-13T19:59:35Z"
    },
    {
      "author": "mpawelski",
      "author_association": "NONE",
      "body": "> I know I'm going to catch a lot of flak here, and I really appreciate the depth of the discussion happening, but..._ducks_...does anyone have an example of any of this actually mattering in a real-world scenario?\r\n\r\nI already mentioned it in this thread a year ago (it's hidden now...) that I used to get a lot of WFT moments when using [ripgrep](https://github.com/BurntSushi/ripgrep) in Powershell. I couldn't understand why I couldn't search quoted strings. It ignored my quotes:\r\n\r\n`rg '\"quoted\"'`\r\n\r\nand in git bash it didn't.\r\n\r\nNow I get less this WTF moments because sadly I found this long github issue and found that passing `\"` to Powershel is totally broken. Recent \"git.exe\" example is also great.\r\n\r\nTo be honest, now I don't even dare to use Powershell to call native command when I know I might be passing `\"` in string as parameter. I know I might get wrong result or error.\r\n\r\nReally, @mklement0 summed it up great (this should be engraved in stone somewhere)\r\n\r\n>As stated many times before, a **core mandate of a shell is to call external executables with arguments**.\r\n>PowerShell currently fails to fulfill this mandate, given that arguments with embedded double quotes and empty-string arguments aren't passed correctly.\r\n>As stated before, this may have been less of a problem in the Windows-only days, where the lack of capable external CLIs rarely surfaced this problem, but these days are gone, and **if PowerShell wants to establish itself as a credible cross-platform shell, it must address this problem**.\r\n\r\nAnd about breaking changes.\r\nRecently coworker wrote to me that my script didn't worked on his machine. I was running it only on Powershel Core and he was running it on Windows Powershell. Turns out `Out-File -Encoding utf8` encoded file with \"BOM\" on Windows Powershell and without BOM on Powershel Core. This is somehow unreleted example but show that there are already subtle [breaking changes](https://docs.microsoft.com/en-us/powershell/scripting/whats-new/breaking-changes-ps6?view=powershell-7) in Powershel and this is good because we are eliminating quirks and intuitive behavior from a language that is famous for it. It would be great if Powershel team was a bit more lenient when it comes to breaking changes now that we have cross platform Powershell that is shipping outside of Windows and that we know that Windows Powershell is in \"maintenence\" mode and will be usable forever if you really want it to run some old script that broke in newer version of Powershell.",
      "created_at": "2020-08-13T08:53:59Z",
      "updated_at": "2020-08-13T20:43:59Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "RE: that last point of breaking changes -- I fully agree. There are _many_ breaking changes we've tolerated for various reasons. However, more and more often it seems to be the case that some breaking changes are simply frowned upon for reasons of preference and not given proper gravity of consideration for their actual value.\r\n\r\nThere are some changes like this which would _massively_ improve the overall shell experience for anyone who needs to reach outside of PowerShell to get things done, which happens all the time. It's been agreed time and time again that the current behaviour is untenable and already largely broken for anything but the simplest usages. And yet, we're still facing this reticence to breaking changes even while there are scores of already accepted breaking changes, some of which have similarly large impact.\r\n\r\nFor those asking for examples -- take a minute to visit Stack Overflow for once. I'm sure @mklement0 has a litany of examples where community help is required to help explain a breaking change in newer versions. It happens _all the time_. We have **no excuse** to not make helpful breaking changes.",
      "created_at": "2020-08-13T11:26:10Z",
      "updated_at": "2020-08-13T11:26:10Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Whenever MSFT team repeats the same thing over and over again, we can be sure they know more than they can publicly say. We should respect their inner discipline and not pressure them. _Maybe we can find a compromise._ I hope I have time today to describe an alternative path with lazy migration.\r\n",
      "created_at": "2020-08-13T12:37:48Z",
      "updated_at": "2020-08-13T12:37:48Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I do recognise that, and it's why I rarely make a point of questioning it.\r\n\r\nHowever, this is an open source project; if there's no possible visibility into those decisions, folks _will_ inevitably end up frustrated. No blame to cast on either side of that coin, that's just the reality of the situation here, IMO. So yeah, having a migration path may ease that pain somewhat, but we need clear policies defined on how that has to work that will make things work for as many folks as possible. Compromise is difficult to reach when lacking information, though.\r\n\r\nI look forward to seeing what you have up your sleeve. \ud83d\ude09 ",
      "created_at": "2020-08-13T12:43:26Z",
      "updated_at": "2020-08-13T12:44:32Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "@mklement0 you're absolutely right, and so much so that I can only respond to your meta-point right now. Unfortunately, in the cases where we aren't able to reach the level of depth required to answer a question like this, the safer approach is often to defer or reject the breaking change until we have more time to \r\n\r\nI want to make another meta-point about breaking changes, though: [our telemetry](https://aka.ms/psgithubbi) implies that *most* PowerShell 7 users are not managing their own versions. They're running automated scripts in a managed environment that's comfortable e.g. upgrading their users from 6.2 to 7.0 (see the 2-day jump in 6.2 users becoming 7.0 users starting on 8/3; this isn't our only data point here, but it's a convenient one right now that makes the point). For these users, a breaking change that turns a perfectly working script into a non-working script is unacceptable. \r\n\r\nI also owe the community a blog on how I think about the impact of breaking changes: namely trading off the prevalence of existing usage and severity of the break against the ease of identifying and correcting the break. This one is extremely prevalent in existing scripts, confusing to identify and fix, and the breaking behavior is from total success to total failure, hence my extreme reticence to do anything here. \r\n\r\nI think it's fair to say we're not going to do anything here in 7.1, but I'm definitely open to making this an investigative priority for 7.2 (i.e. we spend more than just our Committee time discussing this.) \r\n\r\n> How about appointing subject-matter-specific sub-committees that the committee consults with that do have the required understanding of the issues involved?\r\n\r\nWe're working on this. I know I've said that before, but we're *extremely* close (as in, I'm crafting the blog and you're probably going to see some new labels show up soon that we'll be playing with). \r\n\r\nI appreciate everyone's patience and I recognize that it's annoying to get a pithy reply out of the Committee every couple weeks when folks are pouring an immense amount of thought and consideration into the discussion. I know it looks like that means we're not thinking deeply about things, but I think we're just not expressing the depth of our discussions in as much detail as folks do here. In my own backlog, I've got a whole set of blog topics like the breaking change one around how I think about making decisions from within the Committee, but I've just never gotten the chance to sit down and pump them out. But I can see here that maybe folks would find a lot of value in that. \r\n\r\nHope I didn't get the rails too far off in this discussion. I don't want this issue to totally become a meta-issue about the project's management, but I did want to address some of the understandable frustration I see here. I implore anyone that wants to talk about this in more detail with us to join the [Community Call](https://aka.ms/PSCommunityCall) next week (add your questions and thoughts [here](https://github.com/PowerShell/PowerShell-RFC/issues/258) and I'll be sure to address them in the call). ",
      "created_at": "2020-08-13T19:16:59Z",
      "updated_at": "2020-08-13T19:16:59Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Just a quick note on the meta-point: I appreciate the thoughtful response, @joeyaiello.\r\n\r\nAs for the severity of the breaking change: The following statements seem to be at odds:\r\n\r\n> does anyone have an example of any of this actually mattering in a real-world scenario\r\n\r\nvs.\r\n\r\n> This one is extremely prevalent in existing scripts, confusing to identify and fix\r\n\r\nIf it is already prevalent, the awkwardness and obscurity of the necessary workarounds are all the more reason to finally fix this, especially given that we should expect the number of cases to increase.\r\n\r\nI do realize that all existing workarounds will break.  \r\n\r\nIf avoiding that is paramount, this [previously suggested approach](https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-673247420) is the way to go:\r\n\r\n>  provide a _new operator or a function_ such as the `ie` function from the `Native` module that fixes the problem, and widely publicize it as the only reliable way to invoke external executables.\r\n\r\nA _function_ such as `ie` would allow people to opt-into the correct behavior with _minimal fuss_, _as a stopgap_, without burdening the _language_ with a new syntactical element (an operator), whose sole raison d'\u00eatre would be to work around a legacy bug deemed too breaking to fix:\r\n\r\n* The stopgap would provide _officially sanctioned_ access to the correct behavior (no reliance on _experimental_ features).\r\n* For as long as the stopgap is necessary, it would need to be widely publicized and properly documented.\r\n  \r\nIf/when the default behavior gets fixed:\r\n* the function can be modified to just defer to it, so as not to break code that uses it.\r\n* new code can be written without needing the function anymore.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-08-13T21:11:40Z",
      "updated_at": "2020-08-16T13:01:26Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> A function such as ie would allow people to opt-into the correct behavior with minimal fuss, as a stopgap\r\n\r\nWe can simplify adoption by mean of #13428. We can inject this with @mklement0's investigations in Engine transparently.\r\n",
      "created_at": "2020-08-14T14:36:48Z",
      "updated_at": "2020-08-14T14:36:48Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@Dabombber\r\n\r\n> I think that accommodating exceptions by default is just going to lead to a similar situation as the current one, where people need to revert PowerShell's \"helpfulness\". If there are exceptions, it should be obvious they're being applied.\r\n\r\n**The accommodations I'm proposing make the vast majority of calls \"just work\" - they are useful abstractions from the Windows command line anarchy that we should do our best to shield users from.** \r\n\r\nThe justifiable assumption is that this shielding is a one-time effort for _legacy_ executables, and that newly created ones will adhere to the Microsoft C/C++ conventions.\r\n\r\nIt's impossible to do that in _all_ cases, however; for those that can't be accommodated automatically, there's `--%` .\r\n\r\nPersonally, I don't want to have to think about wether a given utility `foo` happens to be implemented as `foo.bat` or `foo.cmd`, or whether it requires `foo=\"bar none\"` arguments specifically, without also accepting `\"foo=bar none\"`, which for convention-compliant executables are equivalent.\r\n\r\nAnd I certainly don't want a separate syntax form for various exceptions, such as `&[bat]`\r\nInstead, `--%` is the (Windows-only) catch-all tool for formulating the command line exactly as you want it passed - whatever the target program's specific, unconventional requirements are.\r\n\r\n**Specifically, the proposed accommodations are the following:** \r\n\r\nNote:\r\n\r\n* As stated, they are required _on Windows_ only; on Unix, delegating to `ProcessStartInfo.ArgumentList` is sufficient to solve all problems. \r\n\r\n* At least at a high level, these accommodations are easy to conceptualize and document.\r\n\r\n* Note that they will be applied _after_ PowerShell's usual parsing, in the (Windows-only) translation-to-the-process-command-line step. That is, PowerShell's own parameter parsing won't be involved - and [_shouldn't_ be](https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-673326940), @yecril71pl.\r\n\r\n* Any then truly exotic cases not covered by these accommodations would have to be handled by users themselves, with\r\n`--%`  - or, with the `Native` module installed, with `ins` / `Invoke-NativeShell`, which makes it easier to embed PowerShell variable and expression values in the call.\r\n\r\n  * The  `dbea` (`Debug-ExecutableArguments`) command from the `Native` module can help with diagnosing and understanding what process command line is ultimately used - see the example section below.\r\n\r\n**List of accommodations:**\r\n\r\n* For  **batch files** (as noted, the importance of accommodating this case automatically is the prevalence of high-profile CLIs that use batch files _as their entry point_, such as `az.cmd` for Azure).\r\n\r\n  * Embedded double quotes, if any, are escaped as `\"\"`  (rather than `\\\"`) in all arguments.\r\n   * Any argument that contains *no spaces* but contains either double quotes or `cmd.exe` metacharacters such as `&` is enclosed in double quotes (whereas PowerShell by default only encloses arguments *with spaces* in double quotes); e.g., a verbatim argument seen by PowerShell as `a&b` is placed as `\"a&b\"` on the command line passed to a batch file.\r\n         \r\n* For **high-profile CLIs such as `msiexec.exe` / `msdeploy.exe` and `cmdkey.exe`** (without hard-coding exceptions for them):\r\n        \r\n  * Any invocation that contains at least one argument of the following forms triggers the behavior described below; `<word>` can be composed of letters, digits, and underscores:\r\n          * `<word>=<value with spaces>`\r\n          * `/<word>:<value with spaces>`\r\n          * `-<word>:<value with spaces>`\r\n       \r\n   * If such an argument is present:    \r\n     * ~~Embedded double quotes, if any, are escaped as `\"\"` (rather than `\\\"`) in all arguments.~~ - see https://github.com/PowerShell/PowerShell/pull/13482#issuecomment-677813167 for why we should _not_ do this; this means that in the rare event that `<value with spaces>` has _embedded_ `\"` chars., `--%` must be used; e.g., \r\n`msiexec ... --% PROP=\"Nat \"\"King\"\" Cole\"`\r\n      * Only the `<value with spaces>` part is enclosed in double quotes, *not* the argument *as a whole* (the latter being what PowerShell - justifiably - does by default); e.g., a verbatim argument seen by PowerShell as `foo=bar none` is placed as `foo=\"bar none\"` on the process' command line (rather than as `\"foo=bar none\"`).\r\n   * Note:    \r\n      * If the target executable happens _not_ to be an `msiexec`-style CLI, no harm is done, because convention-adhering CLIs sensibly consider  `<word>=\"<value with spaces>\"` and  `\"<word>=<value with spaces>\"` _equivalent_, both representing verbatim `<word>=<value with spaces>`.\r\n      * ~~Similarly, the vast majority of executables accept `\"\"` interchangeably with `\\\"` for escaping embedded `\"` chars., with the notably exception of PowerShell's own CLI, Ruby, and Perl (_not_ performing the accommodation is worthwhile at least if the PowerShell CLI is being called, but I think hard-coding Ruby and Perl would also make sense).~~ https://github.com/PowerShell/PowerShell/pull/13482#issuecomment-677813167 shows that all applications that use the `CommandLineToArgvW` WinAPI function do _not_ support `\"\"`-escaping.\r\n\r\nAll other cases on Windows can also be handled with `ProcessStartInfo.ArgumentList`, which implicitly applies the [Microsoft C/C++ convention](https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args?view=vs-2019#parsing-c-command-line-arguments) (which notably means `\\\"` for `\"`-escaping).\r\n\r\n---\r\n\r\n**The `ie` function from the current version (`1.0.7`) of the [`Native` module](https://www.powershellgallery.com/packages/Native) implements these accommodations (in addition to fixing the broken argument parsing)**, for **PowerShell versions 3 and up** (`Install-Module Native`).\r\n\r\n**I invite you and everyone here to put it through its paces to test the claim that it \"just works\" for the vast majority of external-executable calls**\r\n\r\nCurrently unavoidable limitations:\r\n\r\n* Note: These technical limitations come from `ie` being implemented as a _function_ (a proper fix in the engine itself would _not_ have these problems):\r\n\r\n  * While `$LASTEXITCODE` is properly set to the process' exit code, `$?` ends up always `$true` - user code currently cannot set `$?` explicitly, though adding this ability has been green-lit - see https://github.com/PowerShell/PowerShell/issues/10917#issuecomment-550550490. Unfortunately, this means that you cannot currently use `ie` meaningfully with `&&` and `||`, the `&&`, the [pipeline-chain operators](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_Pipeline_Chain_Operators).  \r\nHowever, if _aborting_ a script on detecting a nonzero exit code is desired, the `iee` wrapper function can be used.\r\n\r\n  * `--` as an argument is invariably \"eaten\" by the PowerShell parameter binder; simply pass it _twice_ in order to pass `--` through to the target executable (`foo -- --` instead of `foo --`).\r\n\r\n  * An unquoted token with `,` must be quoted lest it be interpreted as an array and passed as multiple arguments; e.g., pass `'a,b'` rather than `a,b`; similarly, pass `-foo:bar` (something that looks like a named PowerShell argument) as `'-foo:bar'` (this shouldn't be necessary, but is owed to a bug: #6360); similarly '-foo.bar` must be passed as `'-foo.bar'` (another bug, which affects direct calls to external executables too: #6291)\r\n\r\n* I expect the function to work robustly in PowerShell _Core_. Due to changes in _Windows PowerShell_ over time, there may be edge cases that aren't handled properly, though I'm only aware of two:\r\n\r\n  * The partial-quoting accommodation for `msiexec`-style CLIs cannot be applied in version 3 and 4, because these versions wrap the entire argument in an additional set of double quotes; it does work in v5.1, however.\r\n\r\n  * `\"\"`-escaping is used by default, to work around problems, but in cases where `\\\"` is necessary (PowerShell CLI, Perl, Ruby), a token such as `3\" of snow` is mistakenly passed as _3_ arguments, because all Windows PowerShell versions neglect to enclose such an argument in double quotes; this seems to happen for arguments with non-initial `\"` characters that aren't preceded by a space character.\r\n\r\n---\r\n\r\n### Examples, with output from PowerShell Core 7.1.0-preview.5 on Windows 10:\r\n\r\nNote: The `dbea` (`Debug-ExecutableArguments`) function is used to illustrate how the arguments would be received by external executables / batch files.\r\n\r\n#### Current, broken argument passing:\r\n\r\n* Calling a convention-compliant application (a .NET console application used by `dbea` behind the scenes by default):\r\n\r\n```powershell\r\n# Note the missing 2nd argument and the effective loss of embedded double quotes,\r\n# due to the embedded \" chars. not having been escaped.\r\nPS> dbea -- 'a&b' '' '{ \"foo\": \"bar\" }'\r\n\r\n2 argument(s) received (enclosed in <...> for delineation):\r\n\r\n  <a&b>\r\n  <{ foo: bar }>\r\n\r\nCommand line (helper executable omitted):\r\n\r\n  a&b  \"{ \"foo\": \"bar\" }\"\r\n```\r\n\r\n* Calling a batch file:\r\n\r\nNote the use of `-UseBatchFile` to make `dbea` pass the arguments to a helper _batch file_ instead.\r\n\r\n```powershell\r\n# Note that only *part of the first argument* is passed and that the `&` is interpreted as cmd.exe's\r\n# statement separator, causing `b` to be run as a command (which fails).\r\nPS> dbea -UseBatchFile -- 'a&b' '' '{ \"foo\": \"bar\" }'\r\n\r\n1 argument(s) received (enclosed in <...> for delineation):\r\n\r\n  <a>\r\n\r\n'b' is not recognized as an internal or external command,\r\noperable program or batch file.\r\n```\r\n\r\n* Calling a `msiexec`-style CLI, `cmdkey.exe`:\r\n\r\n```powershell\r\n# The call fails, because `cmdkey.exe` requires the password argument to \r\n# to be quoted exactly as `/password:\"bar none\"` (double-quoting of the option value only), \r\n# whereas PowerShell - justifiably - passes `\"/password:bar none\"` (double-quoting of the whole argument).\r\nPS> cmdkey.exe /generic:foo /user:foo /password:'bar none'\r\n\r\nThe command line parameters are incorrect.\r\n```\r\n\r\n#### Fixing the problem with `ie`:\r\n\r\nNote the use of `-ie` in the `dbea` calls, which causes the use of `ie` for the invocations.\r\n\r\n* Calling a convention-compliant application (a .NET console application used by `dbea` behind the scenes by default):\r\n\r\n```powershell\r\n# OK\r\n# Note that the empty 2nd argument is correctly passed, and that \\\" is used for embedded \"-escaping.\r\nPS> dbea -ie -- 'a&b' '' '{ \"foo\": \"bar\" }'\r\n\r\n3 argument(s) received (enclosed in <...> for delineation):\r\n\r\n  <a&b>\r\n  <>\r\n  <{ \"foo\": \"bar\" }>\r\n\r\nCommand line (helper executable omitted):\r\n\r\n  a&b \"\" \"{ \\\"foo\\\": \\\"bar\\\" }\"\r\n```\r\n\r\n* Calling a batch file:\r\n\r\n```powershell\r\n# OK\r\n# - `a&b` was enclosed in \"...\", due to the presence of metacharacter `&`\r\n# - \"\" is used for escaping of embedded \" chars.\r\n# Note that `echo %1`, for instance, prints the argument exactly as passed on the command line, including quoting.\r\n# `echo %~1` strips the surrounding double quotes, but embedded escaped ones still print as \"\".\r\n# However, if you pass these arguments (`%*`) through to convention-compliant CLIs, they are parsed correctly.\r\nPS> dbea -ie -UseBatchFile -- 'a&b' '' '{ \"foo\": \"bar\" }'\r\n\r\n3 argument(s) received (enclosed in <...> for delineation):\r\n\r\n  <\"a&b\">\r\n  <\"\">\r\n  <\"{ \"\"foo\"\": \"\"bar\"\" }\">\r\n```\r\n\r\n* Calling a `msiexec`-style CLI, `cmdkey.exe`:\r\n\r\n```powershell\r\n# The call now succeeds, because `ie` ensure the value-only double-quoting that cmdkey.exe requires.\r\n# (Use `cmdkey /del:foo` to remove the credentials again.)\r\nPS> ie cmdkey.exe /generic:foo /user:foo /password:'bar none'\r\n\r\nCMDKEY: Credential added successfully.\r\n```\r\n\r\nTo show that the value-only double-quoting was applied in the actual command line, via `dbea`:\r\n\r\n```powershell\r\nPS> dbea -ie -- cmdkey.exe /generic:foo /user:foo /password:'bar none'\r\n\r\n  <cmdkey.exe>\r\n  </generic:foo>\r\n  </user:foo>\r\n  </password:bar none>\r\n\r\nCommand line (helper executable omitted):\r\n\r\n  cmdkey.exe /generic:foo /user:foo /password:\"bar none\"\r\n```\r\n\r\n\r\n\r\n",
      "created_at": "2020-08-15T20:51:02Z",
      "updated_at": "2020-08-20T18:38:25Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "The following code causes a data loss:\r\n```powershell\r\n{ PARAM($A) $A } | OUT-FILE A.PS1\r\nPWSH A.PS1 -A:(1,2)\r\n```\r\n> 1",
      "created_at": "2020-08-19T13:38:26Z",
      "updated_at": "2020-08-19T13:38:26Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@JamesWTruher has a proposed fix and is validating if it addresses the concerns raised in this issue",
      "created_at": "2020-08-19T17:08:35Z",
      "updated_at": "2020-08-19T17:08:35Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "Is there a pull request of that proposed fix? It would be nice if we could comment on the PR. Because fixing this was IMO never the complicated part. The complicated part was how to handle backwardscompatibility. And it would be nice, if we could see how the proposed fix handles that....",
      "created_at": "2020-08-19T18:04:41Z",
      "updated_at": "2020-08-19T18:04:41Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "That's good to hear, @SteveL-MSFT - a fix for _all_ problems discussed here? For v7.1, after all? And I second @TSlivede's request.\r\n\r\n@yecril71pl, that's a good find, although this one truly relates to PowerShell's own parsing (which does have _some_ special-casing for external executables), not to how the native command line is constructed _after_ parsing (which is where the problems previously discussed come from).\r\n\r\nA more succinct repro of the problem, on Unix:\r\n\r\n```powershell\r\nPS> printf '<%s>\\n' -a:(1,2,3)\r\n<-a:1>\r\n<2>\r\n<3>\r\n```\r\n\r\nThat is, only the _first_ array element was directly attached to `-a:`, the others were passed as separate arguments.\r\n\r\nThere are related problems with arguments that _look like_ PowerShell parameters, but aren't:\r\n\r\nThere is a related issue that only affects calls to _PowerShell_ commands that use `$args` / `@args`:  #6360\r\n  * `& { $args.Count; $args } -foo:bar`  yields `2, '-foo:', 'bar'`\r\n\r\nThere's also #6291, which affects both PowerShell commands and external executables (note the `.`).\r\n  * `& { $args.Count; $args } -foo.bar`  yields `2, '-foo', '.bar'`\r\n\r\nOne thing to note is that `(...)` as part of a bareword normally results in `(...)`'s output as a whole becoming a _separate_ argument, so the fact that the first element _is_ attached in the `printf` command above  is evidence of special-casing for external-executable calls; e.g.,\r\n`& { $args.Count; $args.ForEach({ \"$_\" }) } foo('bar', 'baz')` yields `2, 'foo', 'bar baz'`, the second argument being the stringification of array `'bar', 'baz'`.\r\n",
      "created_at": "2020-08-19T18:16:48Z",
      "updated_at": "2020-08-19T18:21:55Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "When PowerShell has to pass `-A:(1,2)` for an external executable, it figures out that `-A:` is a string and `(1,2)` is an array which must be marshalled as \u20181 2\u2019.  PowerShell tries to preserve the original syntax of the invocation, so, putting it all together, we get \u2018-A:1 2\u2019, whereas the correct result would be \u2018-A:\"1 2\"\u2019.  It looks like a trivial omission in the marshalling code to me.",
      "created_at": "2020-08-19T18:35:31Z",
      "updated_at": "2020-08-19T18:35:31Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "I wouldn't say, that @yecril71pl's specific problem is related to parsing (although I agree, that it doesn't have anything to do with the problem \"converting array to commandline\", which is discussed in this issue).\r\n\r\n>When PowerShell has to pass -A:(1,2) for an external executable, it figures out that -A: is a string and (1,2) is an array\r\n\r\nAlmost: `-A:` is a named parameter and the array is the value of that parameter (To test that: remove the `-` in front and you see, that it is quoted differently). But the problem isn't, that the array is incorrectly converted to a string - the problem is, that for native executables arguments are (almost) always splatted, even when using `$` and not `@` and even if the array originates from a expression such as `(1,2)`.\r\n\r\nTest for example `printf '<%s>\\n' -a:('a b',2)`: As the string `a b` contains a space it is correctly quoted, but as `2` is in the next array element and the array is splatted, `2` is not part of the first argument.\r\n\r\n<details>\r\n<summary>The magic happens in NativeCommandParameterBinder.cs</summary>\r\n\r\nAt [line 170](https://github.com/PowerShell/PowerShell/blob/master/src/System.Management.Automation/engine/NativeCommandParameterBinder.cs#L170) powershell tries to get an enumerator for the current argument value.\r\n```\r\nIEnumerator list = LanguagePrimitives.GetEnumerator(obj);\r\n```\r\nIf `list` is not `null`, powershell adds each element of the list (possibly quoted if containing spaces) to the lpCommandLine.\r\n\r\nThe elements are separated with spaces ([line 449](https://github.com/PowerShell/PowerShell/blob/master/src/System.Management.Automation/engine/NativeCommandParameterBinder.cs#L449)) by default. The only exception is if the array was a literal    \r\n(as in `printf '<%s>\\n' -a:1,2`).   \r\nThen powershell tries to use the same separator in the lpCommandLine, that was used in the script line.\r\n\r\n\r\n</details>",
      "created_at": "2020-08-19T18:43:32Z",
      "updated_at": "2020-08-19T19:21:39Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "I expect a PR when ready.  If it makes it into 7.1, we'll take it, otherwise it'll be 7.2.  Backwards compatibility is something he is addressing.  Perhaps what would help is some help writing Pester tests (using `testexe -echoargs` which can be built using `publish-pstesttools` from build.psm1).",
      "created_at": "2020-08-19T18:53:42Z",
      "updated_at": "2020-08-19T18:53:42Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": ">I expect a PR when ready\r\n\r\nThat is exactly, what I wanted to avoid - please show the code that is not ready (mark PR as work in progress).\r\n\r\nOr at least comment, what he wants to do.\r\n\r\nIt would be nice if we could discuss *how* he wants to handle backwards compatibility.",
      "created_at": "2020-08-19T18:56:08Z",
      "updated_at": "2020-08-19T18:57:01Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@TSlivede, note that since the PowerShell _CLI_ is called - an external executable - `-A:(1,2)` is parsed _before_ knowing that this token will eventually bind to _named_ `-A` parameter - that such a parameter _eventually_ comes into play is incidental to the problem.\r\n\r\n@yecril71pl:\r\n\r\n> It figures out that `-A:` is a string\r\n\r\nNo, it is special-cased during parsing, because it happens to _look like_ a PowerShell parameter.\r\n\r\nThis special-casing happens for calls to PowerShell commands that use `$args` as well (as opposed to having actual declared parameters that are bound), but it happens _differently_ for external executables (what is normally a separate argument stays attached, but in case of a collection only its _first_ element).\r\n\r\nYou can actually opt out of this special-casing if you pass `--` beforehand, but, of course, that will also pass `--`, which is only removed for calls to _PowerShell_ commands:\r\n\r\n```powershell\r\nPS> printf '<%s>\\n' -- -a:(1,2,3)\r\n<-->   # !! not removed\r\n<-a:>\r\n<1>    # array elements are *all* now passed as indiv. arguments, because (...) output is separate (splatted) argument\r\n<2>\r\n<3>\r\n```\r\n\r\nIf the argument _doesn't_ look like a PowerShell parameter, the usual behavior (output from `(...)` becomes a separate argument) kicks in even for external executables (with the usual behavior of an _array_ being splatted, i.e. being turned into individual arguments in the external-executable case).\r\n\r\n```powershell\r\n# Note: No \"-\" before \"a:\" -> output from `(...)` becomes separate argument(s)\r\nPS> printf '<%s>\\n' a:(1,2,3)\r\n<a:>\r\n<1>\r\n<2>\r\n<3>\r\n```\r\n\r\nApplying this behavior _consistently_ would make sense - a `(...)` expression as part of a bareword should _always_ become a separate argument - see #13488.\r\n\r\nIn order to pass a single argument `'-A:1 2 3'`, with the array _stringified_, use a(n implicit) _expandable string_, in which case you need `$(...)` rather than `(...)` _and_ - surprisingly - currently also `\"...\"`:\r\n\r\n```powershell\r\nPS> printf '<%s>\\n' \"-a:$(1,2,3)\"  # quotes shouldn't be needed; `-a:\"$(1,2,3)\"` would work too.\r\n<a:1 2 3> # SINGLE argument with stringified array.\r\n```\r\n\r\nYou _shouldn't_ also need `\"...\"` in this case - it is again necessary because of the anomalies relating to tokens that _look_ like parameters (which in general apply to _both_ PowerShell and external-executable calls - see #13489); if they don't, you needn't quote:\r\n\r\n\r\n```powershell\r\n# Anomaly due to looking like a parameter: $(...) output becomes separate argument\r\nPS> Write-Output -- -a:$(1,2,3)\r\n-a:\r\n1\r\n2\r\n3\r\n\r\n# Otherwise (note the absence of \"-\"): no quoting needed; treated implicitly like \r\n# \"a:$(1,2,3)\"\r\nPS> Write-Output -- a:$(1,2,3)\r\na:1 2 3  # SINGLE argument with stringified array.\r\n```\r\n\r\nThe world of compound tokens in argument mode is a complex one, with several inconsistencies - see #6467.\r\n\r\n\r\n\r\n",
      "created_at": "2020-08-19T19:29:47Z",
      "updated_at": "2020-08-20T22:54:55Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT\r\n\r\nIn its current form, `testexe -echoArgs` only prints the individual arguments that the .NET Core executable parsed from the raw command line (on Windows), not the raw command line itself.\r\n\r\nIt therefore cannot test accommodations with selective quoting for batch files and `msiexec`-style CLIs - assuming such accommodations will be implemented, which I strongly recommend; for instance, you won't be able to verify that `PROP='foo bar'` was passed as `PROP=\"foo bar\"`, with double-quoting just around the value part.\r\n\r\nHowever, in order to print the raw command line, `testexe` mustn't be a .NET _Core_ executable, because .NET Core _recreates a hypothetical command line_ that always uses `\\\"`-escaping for embedded `\"` chars., even if `\"\"` was used, and generally doesn't faithfully reflect which arguments were double-quoted and which weren't - for background, see https://github.com/dotnet/runtime/issues/11305#issuecomment-674554010.\r\n\r\n\r\nOnly a .NET _Framework_-compiled executable shows the true command line in `Environment.CommandLine`, so `testexe` would have to be compiled that way (and altered to (optionally) print the raw command line).\r\n\r\nTo test the accommodations for batch files, a separate test _batch_ file is needed, to verify that `'a&b'` is passed as `\"a&b\"` and `'a\"b'` as `\"a\"\"b\"`, for instance.",
      "created_at": "2020-08-19T19:59:20Z",
      "updated_at": "2020-08-19T20:02:54Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@mklement0 compiling for .NET Framework isn't going to be possible and would probably need to run under .NET Framework to get the right behavior.  We deliberately removed all the native code compilation out of PS repo, and I don't think we want to add it back...  One option is to have pre-built native testexe (which would have to be compiled for Windows, macOS, and various Linux distros (like Alpine separately).  Writing testexe is easy, doing all that work to publish it will take time...\r\n\r\nAlternatively, can we just rely on a simple bash script for Linux/macOS to emit the args?\r\n\r\n```bash\r\n#!/bin/bash\r\nfor i; do\r\n   echo $i\r\ndone\r\n```\r\n\r\nAnd on Windows something similar with a batch file.",
      "created_at": "2020-08-19T20:29:07Z",
      "updated_at": "2020-08-19T20:29:07Z"
    },
    {
      "author": "cspotcode",
      "author_association": "NONE",
      "body": "How about using node with a .js script?\n\n`console.log(process.execArgv.join('\\n')` or whatever string handling you\nwanna do to make the output look nice?\n",
      "created_at": "2020-08-19T20:40:22Z",
      "updated_at": "2020-08-19T20:40:25Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@cspotcode, to get the raw command line we need a WinAPI call.\r\n\r\n@SteveL-MSFT:\r\n\r\n**On Windows**, you can delegate the compilation to _Windows PowerShell_ via its CLI, [which is what I do in `dbea`](https://github.com/mklement0/Native/blob/dbe562fa46c708428adde8d00c5d38c2be1c8158/Native.psm1#L1321); here's a simple example that produces a .NET _Framework_ executable that echoes the raw command line (only), `./rawcmdline.exe`:\r\n\r\n```powershell\r\npowershell.exe -noprofile -args ./rawcmdline.exe -c {\r\n\r\n  param([string] $exePath)\r\n\r\n  Add-Type -ErrorAction Stop -OutputType ConsoleApplication -OutputAssembly $exePath -TypeDefinition @'\r\nusing System;\r\nstatic class ConsoleApp {\r\n  static void Main(string[] args) {\r\n    Console.WriteLine(Environment.CommandLine);\r\n  }\r\n}\r\n'@\r\n\r\n}\r\n```\r\n\r\nSample call:\r\n\r\n```powershell\r\nPS> ./rawcmdline.exe --% \"a&b\" PROP=\"foo bar\"\r\n\"C:\\Users\\jdoe\\rawcmdline.exe\"  \"a&b\" PROP=\"foo bar\"\r\n```\r\n\r\nAs for a _batch file_ that echoes its arguments, [`dbea` also creates one on demand](https://github.com/mklement0/Native/blob/dbe562fa46c708428adde8d00c5d38c2be1c8158/Native.psm1#L1172).\r\n\r\n**On Unix**, a simple shell script, as shown in your comment, is indeed sufficient, and you can [even use an ad hoc script that you pass to `/bin/sh` as an _argument_](https://github.com/mklement0/Native/blob/dbe562fa46c708428adde8d00c5d38c2be1c8158/Native.psm1#L1257).\r\n",
      "created_at": "2020-08-19T21:24:58Z",
      "updated_at": "2020-08-19T23:32:21Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee discussed this today, we are asking @JamesWTruher to update his PR to also include as part of his experimental feature to skip the step in the native command processor which reconstructs the array of args back to a string and just pass that to the new array args in ProcessStartInfo (there is a bit of code to make sure parameter names and values are matched appropriately).  Also, we accept that we may need an allowlist to special case known commands that still fail with the proposed change and that is something that can be added later. ",
      "created_at": "2020-08-19T22:58:56Z",
      "updated_at": "2020-08-19T22:58:56Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "For those who may not have noticed: the PR has been published (as a WIP) and is already being discussed: https://github.com/PowerShell/PowerShell/pull/13482\r\n\r\nP.S., @SteveL-MSFT, regarding getting the raw command line on Windows: of course, an alternative to delegating the compilation to Windows PowerShell / .NET _Framework_ is to enhance the existing .NET _Core_ console application to make a (platform-conditional) P/Invoke call to the [`GetCommandLine()`](https://docs.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-getcommandlinew) WinAPI function, as demonstrated below.\r\n\r\n```csharp\r\nusing System;\r\nusing System.Runtime.InteropServices;\r\n\r\nnamespace demo\r\n{\r\n  static class ConsoleApp\r\n  {\r\n    [DllImport(\"kernel32.dll\")]\r\n    private static extern System.IntPtr GetCommandLineW();\r\n\r\n    static void Main(string[] args)\r\n    {\r\n      Console.WriteLine(\"\\n{0} argument(s) received (enclosed in <...> for delineation):\\n\", args.Length);\r\n      for (int i = 0; i < args.Length; ++i)\r\n      {\r\n        Console.WriteLine(\"  <{0}>\", args[i]);\r\n      }\r\n\r\n      // Windows only: print the raw command line.\r\n      if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))\r\n      {\r\n        Console.WriteLine(\"\\nCommand line:\\n\\n  {0}\\n\", Marshal.PtrToStringUni(GetCommandLineW()));\r\n      }\r\n\r\n    }\r\n\r\n  }\r\n\r\n}\r\n```\r\n",
      "created_at": "2020-08-20T13:27:42Z",
      "updated_at": "2020-08-20T13:28:01Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT \r\n\r\n> Backwards compatibility is something he is addressing. \r\n\r\nI think it is implied by your later clarification that `ProcessStartInfo.ArgumentList` (a _collection_ of _verbatim_ arguments to used as-is on Unix and translated to a MS C/C++-convention-compliant command line on Windows by .NET Core itself) should be used, but let me state it explicitly:\r\n\r\n* **Fixing this problem properly, once and for all, _precludes any concessions to backward compatibility_.**\r\n\r\n* @JamesWTruher's PR is on the right track  as of this writing, the only problem seems to be that [empty arguments are still not passed through](https://github.com/PowerShell/PowerShell/pull/13482#discussion_r475031898). \r\n   * Once that is addressed, the fix is complete on _Unix_ - but lacks the important accommodations for CLIs on _Windows_ (see below).\r\n\r\n> we may need an allowlist to special case known commands that still fail with the proposed change and that is something that can be added later.\r\n\r\n**I urge you not to put this off until later**. \r\n\r\nInstead of an _allowlist_ (special-casing for specific executables), **simple general rules can govern the accommodations**, refined from the [ones above](https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-674445995) after [some more discussion with @TSlivede](https://github.com/PowerShell/PowerShell/pull/13482#issuecomment-677826870).\r\n\r\nThese accommodations, which are _needed on Windows only_ :\r\n\r\n* will make the vast majority of calls on Windows work properly.\r\n\r\n* are easy to conceptualize and document, in the proposed [`about_Native_Calls` help topic](https://github.com/MicrosoftDocs/PowerShell-Docs/issues/5152).\r\n\r\n* are straightforward to implement - [here's a proof-of-concept written in PowerShell, along with tests](https://github.com/PowerShell/PowerShell/pull/13482#issuecomment-678522514).\r\n\r\nSpecifically, these are:\r\n\r\n* Just like on Unix, `ProcessStartInfo.ArgumentList` is used by default - except if _one or both_ of the following conditions are met, _in which case the process command line must be constructed manually_ (and assigned to `ProcessStartInfo.Arguments` as currently):\r\n\r\n  * A batch file (`.cmd`, `.bat`) or `cmd.exe` directly is called:\r\n    * In that event, _embedded_ `\"` are escaped as `\"\"` (rather than as `\\\"`), and space-less arguments that contain any of the following `cmd.exe` metacharacters are also double-quoted (normally, only arguments _with spaces_ get double-quoted): `\" & | < > ^ , ;` - this will make calls to batch files work robustly, which is important, because many high-profile CLIs use batch files as _entry points_.\r\n  * Independently (and possibly in addition), if at least one argument that matches the regex\r\n`'^([/-]\\w+[=:]|\\w+=)(.*? .*)$'` is present, all such arguments must apply _partial_ double-quoting around the _value part only_ (what follows the `:` or `=`)\r\n     * E.g., `msiexec.exe` / `msdeploy.exe` and `cmdkey.exe`-style arguments seen by PowerShell verbatim as\r\n`FOO=bar baz` and `/foo:bar baz` / `-foo:bar baz` would be placed on the process command line as\r\n`foo=\"bar baz\"` or `/foo:\"bar baz\"` / `-foo:\"bar baz\"` making _any_ CLIs that require this style of quoting happy.\r\n\r\n  * Verbatim `\\` characters in the arguments must be handled in accordance with the MS C/C++ conventions.\r\n\r\nWhat _isn't_ covered by these accommodations:\r\n\r\n* `msiexec.exe` (and presumably `msdeploye.exe` too) supports _only_ [`\"\"`-escaping of _embedded_ `\"` chars.](https://docs.microsoft.com/en-us/windows/win32/msi/command-line-options), which the above rules would _not_ cover - except if you happen to call via a batch file or `cmd /c`.\r\n  * This should be rare enough to begin with (e.g., \r\n`msiexec.exe /i example.msi PROPERTY=\"Nat \"\"King\"\" Cole\"`), but it is probably made even rarer due to the fact that `misexec` invocations are usually _made synchronous_ to await the end of an installation, in which case you can avoid the problem in one of two ways:\r\n    * `cmd /c start /wait msiexec /i example.msi PROPERTY='Nat \"King' Cole'` - rely on calls to `cmd.exe` (then) triggering `\"\"`-escaping\r\n    * `Start-Process -Wait msiexec '/i example.msi PROPERTY=\"Nat \"\"King\"\" Cole\"'` - rely on the `-ArgumentList` (`-Args`) parameter passing a single string argument through verbatim as the process command line (even though that's not how this parameter is supposed to work - see #5576).\r\n\r\n* Any other non-conventional CLIs for which the above accommodations aren't sufficient - I'm personally not aware of any.\r\n\r\nAt the end of the day, there is always a workaround: call via `cmd /c`, or, for non-console applications, via `Start-Process`, or use `--%`; if and when we provide an `ins` (`Invoke-NativeShell`) cmdlet, it is another option; a `dbea` (`Debug-ExecutableArguments` cmdlet with `echoArgs.exe`-like abilities, but on demand also for batch files, would also help to _diagnose_ problems.\r\n\r\n---\r\n\r\nAs for the path to a breaking change vs. opt-in:\r\n\r\n* **Does implementing this as an experimental feature mean that if enough interest is shown that it will become the _default_ behavior and will therefore amount to a (nontrivial) breaking change?**\r\n\r\n* **Can you please make sure that this experimental feature is widely publicized, given its importance?**\r\n\r\n  * A general concern I have about experimental features is that their use can often be _unwitting_ in preview versions, given that _all_ experimental features are turned on by default. We definitely want people to know about and exercise this feature deliberately.\r\n\r\n\r\n",
      "created_at": "2020-08-22T19:51:15Z",
      "updated_at": "2020-09-06T17:16:01Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "We're looking at doing something for this early in 7.2, but what we need is some examples of real world command lines that currently fail so that we have appropriate tests built to validate any prototype.  It would be helpful to list out what you expect the individual arguments to be in case it's not obvious to us.  Thanks!",
      "created_at": "2020-12-03T00:10:17Z",
      "updated_at": "2020-12-03T00:10:17Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "I can't really talk too much about escaping on Linux/macOS but passing a JSON string on Windows as an argument is a big scenario where the existing rules don't work properly.\r\n\r\n```powershell\r\n$exePath = [IO.Path]::GetTempPath() + 'PrintArgv.exe'\r\n\r\n# Sorry for the hack but I didn't have time to deal with the different json libraries in .NET Core\r\n$buildPrintArgv = {\r\n    $addParams = @{\r\n        TypeDefinition = @'\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Runtime.InteropServices;\r\nusing System.Web.Script.Serialization;\r\n\r\nnamespace PrintArgv\r\n{\r\n    class Program\r\n    {\r\n        [DllImport(\"Kernel32.dll\")]\r\n        public static extern IntPtr GetCommandLineW();\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            IntPtr cmdLinePtr = GetCommandLineW();\r\n            string cmdLine = Marshal.PtrToStringUni(cmdLinePtr);\r\n\r\n            Dictionary<string, object> cmdInfo = new Dictionary<string, object>()\r\n            {\r\n                {\"command_line\", cmdLine },\r\n                {\"args\", args},\r\n            };\r\n\r\n            JavaScriptSerializer jss = new JavaScriptSerializer();\r\n            jss.MaxJsonLength = int.MaxValue;\r\n            jss.RecursionLimit = int.MaxValue;\r\n            Console.WriteLine(jss.Serialize(cmdInfo));\r\n        }\r\n    }\r\n}\r\n'@\r\n        OutputType = 'ConsoleApplication'\r\n        OutputAssembly = $exePath\r\n        ReferencedAssemblies = @('System.Web.Extensions.dll')\r\n    }\r\n    Add-Type @addParams\r\n}\r\n$buildString = \"`$exePath = '$exePath'`n\" + $buildPrintArgv.ToString()\r\npowershell.exe -EncodedCommand ([Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes($buildString)))\r\n\r\n&$exePath '{\"foo\": \"bar\"}' | ConvertFrom-Json | ConvertTo-Json\r\n```\r\n\r\nThe output of that is:\r\n\r\n```json\r\n{\r\n    \"command_line\":  \"\\\"C:\\\\Users\\\\vagrant-domain\\\\AppData\\\\Local\\\\Temp\\\\2\\\\PrintArgv.exe\\\" \\\"{\\\"foo\\\": \\\"bar\\\"}\\\"\",\r\n    \"args\":  [\r\n                 \"{foo: bar}\"\r\n             ]\r\n}\r\n```\r\n\r\nRemoving the json escaping we can see the literal values passed in were:\r\n\r\n* argc: `\"C:\\Users\\vagrant-domain\\AppData\\Local\\Temp\\2\\PrintArgv.exe\" \"{\"foo\": \"bar\"}\"`\r\n* argv[0]: `C:\\Users\\vagrant-domain\\AppData\\Local\\Temp\\2\\PrintArgv.exe`\r\n* argv[1]: `{foo: bar}`\r\n\r\nWe can see that `argv[1]` has a literal value of `{foo: bar}` which is not valid json as the double quotes that PowerShell adds to the argument string are escaped by the double quotes inside the string itself and PowerShell doesn't escape those correctly. For this to work today we need to manually escape the double quotes in the json argument with `\\\"` ourselves:\r\n\r\n```powershell\r\n&$exePath '{\\\"foo\\\": \\\"bar\\\"}' | ConvertFrom-Json | ConvertTo-Json\r\n```\r\n\r\nWhich outputs\r\n\r\n```json\r\n{\r\n    \"command_line\":  \"\\\"C:\\\\Users\\\\vagrant-domain\\\\AppData\\\\Local\\\\Temp\\\\2\\\\PrintArgv.exe\\\" \\\"{\\\\\\\"foo\\\\\\\": \\\\\\\"bar\\\\\\\"}\\\"\",\r\n    \"args\":  [\r\n                 \"{\\\"foo\\\": \\\"bar\\\"}\"\r\n             ]\r\n}\r\n```\r\n\r\nWhich really is:\r\n\r\n* argc: `\"C:\\Users\\vagrant-domain\\AppData\\Local\\Temp\\2\\PrintArgv.exe\" \"{\\\"foo\\\": \\\"bar\\\"}\"`\r\n* argv[0]: `C:\\Users\\vagrant-domain\\AppData\\Local\\Temp\\2\\PrintArgv.exe`\r\n* argv[1]: `{\"foo\": \"bar\"}`\r\n\r\nTo avoid these problems in Ansible we use a custom `Start-Process` like cmdlet called [Start-AnsibleProcess](https://github.com/ansible-collections/ansible.windows/blob/28ce8268ca0a0fbc6ebfed456efd242ff4799aa3/plugins/module_utils/Process.psm1#L119). This cmdlet either accepts `-CommandLine` or `-ArgumentList` which either takes a string to pass to `CreateProcess` directly or a list of arguments that it will escape itself. The escaping logic is located in [ConvertTo-EscapedArgument](https://github.com/ansible-collections/ansible.windows/blob/28ce8268ca0a0fbc6ebfed456efd242ff4799aa3/plugins/module_utils/Process.psm1#L73) just uses simple regex to correctly escape the argument for use with [CreateProcess](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw). The reason why we accept both a raw string that isn't touched and a list of args to escape is for a few reasons:\r\n\r\n* Allows someone to not care about how to escape args, they want this arg (or a list) to be passed correctly to the new process without worrying how to escape them\r\n* If trying to run a already escaped command, or they are escaping themselves for a reason without trying to unscape it somehow\r\n    * A common scenario I see is trying to run the `UninstallString` for an application in the registry\r\n    * This string is most likely an already escaped string that Windows itself passes directly to `CreateProcess` itself so PowerShell should be able to\r\n\r\nFrom a non-Windows perspective the ability to pass in a list of raw commands that someone expects to be escaped regardless of the platform would also be ideal. This might be complicated based on if they are being passed into a shell, same thing applies if you are calling `cmd.exe /c ...` as well.\r\n\r\nWe have a [bunch of tests](https://github.com/ansible-collections/ansible.windows/blob/28ce8268ca0a0fbc6ebfed456efd242ff4799aa3/tests/integration/targets/module_utils_Process/library/process_pwsh_tests.ps1#L275-L295) that test this logic, left being the expected argc and the right being the list of args to escape. The only scenario that I know which this logic doesn't work for is the msiexec style `KEY=value` arguments. The current logic will escape arguments like `\"KEY=value with space\"` which won't work properly with msiexec, it should be `KEY=\"value with space\"`. Not an insurmountable problem but something that should be kept in mind with however PowerShell is attempting to deal with it.\r\n\r\nI'm not sure what the plan is on PowerShell and whether this new escaping behaviour will replace the current call operator or whether a new operator or maybe something like `exec $exe $argumentList` will be used. It's going to be difficult to handle both the PowerShell syntax and specifying command line arguments in a raw like format. If preserving backwards compatibility is desired I would like to see something like the following\r\n\r\n```powershell\r\nFunction exec {\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Position=0)]\r\n        [String]\r\n        $Path,\r\n\r\n        [Parameter(Position=1, ValueFromRemainingArguments)]\r\n        [String[]]\r\n        $Arguments\r\n    )\r\n\r\n    # Converts the list of args to a single string that contains the correctly escaped arguments\r\n    $escapedArguments = $Arguments | ConvertTo-EscapedArgument\r\n\r\n    # Obviously this needs to be fleshed out but the point is the path and args are passed in correctly\r\n    [Native]::Exec(\"{0} {1}\" -f ((ConvertTo-EscapedArgument $Path), $escapedArguments)\r\n}\r\n\r\n$var = 'testing var'\r\nexec my.exe argument1 'argument with space' \"also with $var\" @('nested', 'array', 'of', 'args')\r\n\r\n# Will become the following when passed to CreateProcess\r\n# my.exe argument1 \"argument with space\" \"also with testing var\" nested array of args\r\n```\r\n\r\nIt would also be nice if it had some logic to see if the first arg was a raw command line like the following and just passed that in as is:\r\n\r\n```powershell\r\n$command = '\"C:\\Program Files\\App\\uninstall.exe\" /q \"some value\"'\r\nexec $command\r\n```\r\n\r\nIt would probably require some more complex logic like splitting the paths and seeing if the first value is a valid path. The biggest downside to this approach is that you still need to quote the arguments as an actual PowerShell string but considering those rules are what needs to happen by default when using PowerShell I don'tsee htis as an issue.",
      "created_at": "2020-12-03T10:28:49Z",
      "updated_at": "2020-12-03T10:28:49Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "_Update_: The proposal in what I hope to be its final form is now summarized in #15143.\r\n\r\n---\r\n\r\nThis thread is very long, so let me try to boil the issues down as concisely as I can (sorry, it's still long, but that's the nature of the beast):\r\n\r\n* PowerShell is a shell. A major mandate of a shell is to call external executables that have CLIs with arguments.\r\n\r\n* To that end, PowerShell, as any shell, provides a command-line syntax for encoding calls to CLIs with arguments in a single string - this syntax (quoting styles, metacharacters, ...) varies between shells.\r\n\r\n* It is a shell's responsibility to pass whatever _array of verbatim arguments_ that result from parsing the command line _based on the shell's own rules only_ to the target executable - using whatever mechanism the host platform requires.\r\n\r\n* **On Unix-like platforms, the solution is trivial**: whatever **verbatim arguments are the result of PowerShell's parsing can be passed as-is to [`System.Diagnostics.ProcessStartInfo.ArgumentList`](https://docs.microsoft.com/en-US/dotnet/api/System.Diagnostics.ProcessStartInfo.ArgumentList)**, which the underlying native code _passes through as-is_ to the target process - because that's how argument-passing works at the system level on these platforms.\r\n\r\n  * This is a fully robust solution that makes all problems go away once and for all. \r\n\r\n* **On Windows, using  [`System.Diagnostics.ProcessStartInfo.ArgumentList`](https://docs.microsoft.com/en-US/dotnet/api/System.Diagnostics.ProcessStartInfo.ArgumentList) will get us _most of the way_ there, but there are _important exceptions_**:\r\n\r\n   * On Windows, the native code doesn't pass an _array_ of _verbatim_ arguments, it passes a _command line_ too, i.e. a single string _that the target process must parse too_.\r\n\r\n      * In other words: Very unfortunately, instead of Windows simply allowing passing the verbatim arguments that the calling shell has already determined, it forces any CLI to be its own mini-shell of sorts and do its own command-line parsing. Not only is this unnecessary and cumbersome, it has two important ramifications:\r\n\r\n        * It allows CLIs to parse this command line _based on whatever rules it decides on_ - while there are _conventions_ (see below), not everyone adheres to them.\r\n\r\n        * It requires PowerShell, whose own command-line syntax cannot be expected to be understood by external CLIs (notably, single quotes (`'`) cannot be expected to have _syntactic_ function), to _rebuild a command line behind the scenes_ - and that's where the problems start (and fixing the outright _bugs_ in the current behavior alone isn't sufficient).\r\n   \r\n   * Using `.ArgumentList` delegates the responsibility of rebuilding the ultimate command line to _.NET_, which employs the widely adhered to [quoting and escaping conventions for C/C++/C# programs](https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args?view=msvc-160#parsing-c-command-line-arguments); in short: `\"...\"`-quoting only, `` `\\\" `` to embed verbatim `\"`, `\\\\` to escape a verbatim `\\` immediately before a closing syntactic `\"`.\r\n\r\n  * **This will fix the current problems for all convention-adhering CLIs, but it won't address the following major, common scenarios**:\r\n\r\n      * (a) CLIs that _only_ recognize `\"\"` as an escaped `\"`:\r\n\r\n        * Most notably, these are _batch files_ and `cmd.exe` (which is responsible for executing batch files). Despite the obsolescence of `cmd.exe`, batch files still play an important role, namely as _CLI entry points_ that simply _relay_ arguments to the actual implementation, such as a Python or Node.js script.\r\n\r\n        * Batch files, specifically, present an additional problem: because they - regrettably - parse their arguments _as if they had been passed from inside `cmd.exe`_, the latter's metacharacters must be quoted even in arguments that do not contain spaces (those with spaces must be `\"...\"`-enclosed anyway), such as verbatim `http://example.org?foo=1&bar=2`; the only robust way to do that is to enclose the argument as a whole in `\"...\"` - this must be done for all  space-less arguments that contain `cmd.exe` metacharacters.\r\n\r\n        * Note that, since batch files essentially pass the original quoting through as-is, `\"\"`-escaped `\"` chars. are also seen that way by the actual implementation - fortunately, _most_ CLIs on Windows _also_ recognize `\"\"`, interchangeably with `\\\"`. (The upshot is that CLIs that recognize `\\\"` _only_ cannot use batch-file CLI entry points, if escaped `\"` must be supported; notable examples of such CLIs are Ruby, Perl,  `powershell.exe`(!) - fortunately, `pwsh.exe` now understands `\"\"` - and any program that doesn't use the C runtime's argument parsing and uses the [CommandLineToArgv](https://docs.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-commandlinetoargvw) WinAPI function instead; this is a problem that cannot be fixed).\r\n\r\n      * (b) CLIs that require arguments that represent _key-value_ pairs to be passed with quoting _only around the value part_, such as `-foo=\"bar none\"` or `FOO=\"bar none`. Based on _PowerShell's_ rules, `FOO=\"bar none\"` ends up as verbatim string `FOO=bar none`, which PowerShell (justifiably) re-encodes as `\"FOO=bar none\"` - quoted _as a whole_ - which such CLIs don't recognize.\r\n         * Several high-profile CLIs have this requirement, notably `msiexec` and `msdeploy`.\r\n\r\n     * (c) CLIs with similar custom parsing rules, such as `find.exe` inferring from whether an argument is _double-quoted_ on the command line whether it constitutes a search term.\r\n          * E.g, `echo hi | find hi` fails in `cmd.exe`, because `hi` isn't double-quoted; from PowerShell, even `\"...\"`-enclosing doesn't help, because when it _rebuilds_ the command line, it _doesn't_ double-quote `hi`, because it contains no spaces; thus, `'hi' | find \"hi\"` breaks; while `'hi' | find '\"hi\"'` _currently_ helps, it is an example of a workaround that would break as a result of fixing the issue at hand (the fix would then _escape_ the embedded `\"`); this is where `--%` is legitimately called for - `'hi' | find --% \"hi\"'` - because it allows you to control the exact command line that the target process will receive.\r\n\r\n---\r\n\r\n**The question is - and it is not a _technical_ one - whether and to what extent we want PowerShell to accommodate exceptions (a), (b), and (c) _automatically_** on Windows:\r\n\r\n[Above](https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-678685215) I've made a detailed case for:\r\n\r\n* accommodating (a) and (b) automatically (based on _general rules_ rather than hard-coded exceptions: by argument format for (a), by executable for (b) (`cmd.exe`, which includes batch files))\r\n   * As for test cases: see https://github.com/PowerShell/PowerShell/pull/13482#issuecomment-678522514\r\n   * Note that no special tests are need for the _non_-exceptional cases, where `.ArgumentList` can be relied on to function correctly.\r\n* _not_ doing so for the - rare - (c) cases, necessitating the use of `--%` by the user to handle them.\r\n\r\nAgain, I invite you to take the `ie` function from the [Native module](https://github.com/mklement0/Native) for a spin, which does all that (e.g.\r\n`Install-Module Native; ie echoArgs.exe '{\"foo\": \"bar\"}'; \"@echo %*\" | Set-Content test.cmd; ie ./test.cmd 'FOO=bar none' 'Nat \"King\" Cole'`)\r\n\r\nMy hope is that this function will soon _no longer be necessary_ (though it will still help on older PowerShell versions), and that _direct invocation just works as expected_.\r\n\r\nIf backward compatibility is paramount, then providing a built-in equivalent to `ie` - such as the `exec` command discussed in @jborean93's comment  (although I don't think it should ever accept a whole command line as a single argument; also the name `exec` invites confusion with the builtin of that name in Unix shells) - is the next best thing.\r\n\r\n\r\n",
      "created_at": "2020-12-03T15:19:50Z",
      "updated_at": "2021-04-07T01:59:48Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 from my understanding (I could be completely wrong) but there are a few points I wanted to clarify or just want further informatoin to prove your point.\r\n\r\n> Using .ArgumentList delegates the responsibility of rebuilding the ultimate command line to .NET, which employs the widely adhered to quoting and escaping conventions for C/C++/C# programs; in short: \"...\"-quoting only, `\\\" to embed verbatim \", \\\\ to escape a verbatim \\ immediately before a closing syntactic \"\r\n\r\nI've found that this is not the case, as I understand it PowerShell currently uses the .NET Process class with `.ArgumentList` when starting a process. From what I can see .NET doesn't do any escaping of the arguments at all and it just joins them together with a space leading to even further problems. Let's use `@('{\"foo\": \"bar\"}, 'test arg')` as an example: If PowerShell or .NET escapes this array correctly using the standard Windows escaping conventions this should become `\"{\\\"foo\\\": \\\"bar\\\"}\" \"test arg\"` but in reality it isn't.\r\n\r\n```powershell\r\n# $exePath is the compile .NET app I had in https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-737849785\r\n&$exePath '{\"foo\": \"bar\"}' 'test arg' | ConvertFrom-Json | ConvertTo-Json\r\n\r\nStart-Process -FilePath $exePath -ArgumentList @('{\"foo\": \"bar\"}', 'test arg') -RedirectStandardOutput \"$env:TEMP\\stdout.txt\" -Wait\r\nGet-Content -Path \"$env:TEMP\\stdout.txt\" | ConvertFrom-Json | ConvertTo-Json\r\n```\r\n\r\nThis outputs\r\n\r\n```json\r\n{\r\n  \"command_line\": \"\\\"C:\\\\Users\\\\vagrant-domain\\\\AppData\\\\Local\\\\Temp\\\\2\\\\PrintArgv.exe\\\" \\\"{\\\"foo\\\": \\\"bar\\\"}\\\" \\\"test arg\\\"\",\r\n  \"args\": [\r\n    \"{foo: bar}\",\r\n    \"test arg\"\r\n  ]\r\n}\r\n\r\n{\r\n  \"command_line\": \"\\\"C:\\\\Users\\\\vagrant-domain\\\\AppData\\\\Local\\\\Temp\\\\2\\\\PrintArgv.exe\\\" {\\\"foo\\\": \\\"bar\\\"} test arg\",\r\n  \"args\": [\r\n    \"{foo:\",\r\n    \"bar}\",\r\n    \"test\",\r\n    \"arg\"\r\n  ]\r\n}\r\n```\r\n\r\nWe can see that PowerShell at least encloses the args with `\"` fixing some problems (but exposing others) but .NET itself doesn't do anything at all except join it together with a space. This is one of the main reasons why in Ansible we do the escaping ourselves to conform to the C/C++ standard in Windows and pass that down verbatim. So for this new tool/setup I would propose that PowerShell does the same thing as Ansible.\r\n\r\n* It accepts an array of arguments, or at least treats positional arguments as a separate one\r\n* For non-Windows it passes that down as is\r\n* For Windows it correctly escapes them according to the C/C++ logic which should solve the majority of applications out there\r\n* Pass down that \"correctly\" escaped command line to `CreateProcess` and not rely on .NET as we can see it has it's own issues\r\n\r\nUltimately PowerShell is a shell that works with objects, so if someone wants to pass an array of arguments then that shell should be correctly converting it to what the platform expects.\r\n\r\n> although I don't think it should ever accept a whole command line as a single argument\r\n\r\nMaybe the way I described how it would work was wrong but I still see this is as a valid use case and your comments added another reason why I think it's required. For applications that conform the C/C++ escaping rules then there are little reasons why people would want this behaviour but here are the reasons why I think it is needed.\r\n\r\n* When dealing with apps that reads the args directly and parse it according to their own rules\r\n    * PowerShell can't be expected to know all the applications and their rules, although it may want to handle some of the common ones like `msiexec`\r\n    * So allowing people to explicitly write the command line based on what the CLI expects is helpful\r\n* Wanting to run commands from sources that have the command line already\r\n    * The `UninstallString` registry \r\n* If in the future PowerShell does something wrong, it at least gives the user a way to correct that behaviour until a fix is in place\r\n",
      "created_at": "2020-12-04T22:12:54Z",
      "updated_at": "2020-12-04T22:12:54Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> as I understand it PowerShell currently uses the .NET Process class with .ArgumentList\r\n\r\nIt doesn't. Instead, it builds a command-line string itself and assigns it to the [`System.Diagnostics.ProcessStartInfo.Arguments`](https://docs.microsoft.com/en-US/dotnet/api/System.Diagnostics.ProcessStartInfo.Arguments) property, which is a single string; the `.ArgumentList` property didn't become available until .NET Core 2.1.\r\n\r\nThis command-line string building is broken in _direct invocation_, as discussed here, but also in these contexts, more blatantly:\r\n* in `Start-Process`: #5576\r\n* when PowerShell is installed as a global .NET tool: #11747\r\n\r\n",
      "created_at": "2020-12-04T23:36:08Z",
      "updated_at": "2020-12-04T23:36:47Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "<sup>Amended version of a since-deleted previous comment.</sup>\r\n\r\nRe executing a whole command line stored in a _string_:\r\n\r\n* Generally, use `Invoke-Expression` for a command stored in a string - assuming you fully control or trust the input. However, this isn't robust enough for something like an `UninstallString` from the registry - see below.\r\n\r\n* Otherwise, with individual arguments use `--%` to fully control the command line passed to the target process.\r\n\r\n----\r\n\r\n`UninstallString` registry entries (for uninstalling an application, in the subkeys of `HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall`) contain **command lines designed for _direct invocation_, which does _not_ involve a shell** (there are other examples, such as the `ImagePath` entries for Windows service definitions).\r\n\r\nLetting PowerShell invoke such a command via `Invoke-Expression` runs the risk of unquoted characters that would be interpreted verbatim in `cmd.exe`, notably `{`, `}` and `@` being misinterpreted by PowerShell; example of a problematic command line:  \r\n`MsiExec.exe /I{DCD5B320-89D9-4C7C-9E8B-84496588744E}`\r\n\r\nThe simplest, but not fully robust fix is to invoke such a command line via `cmd /c` and `--%`, facilitated by `Invoke-Expression`:\r\n\r\n```powershell\r\nInvoke-Expression \"cmd /c --% $commandLine\"\r\n```\r\n\r\nHowever, even that may fail if the command line contains unquoted `cmd.exe` metacharacters, such as `&`; example command line:  \r\n`foo.exe http://example.org?foo=1&bar=2`\r\n\r\nTo solve this problem, `cmd.exe` mustn't be involved either.\r\n\r\nNow, IF `--%` were allowed to be placed _at the start_ of the command line, the problem could be solved as follows (given that `--%` does _not_ delegate to `cmd.exe`):\r\n\r\n```powershell\r\n# !! Does NOT work, but arguably SHOULD - currently, `--%` mustn't be the first token on the line.\r\nInvoke-Expression \"--% $commandLine\"\r\n```\r\n\r\n**Supporting `--%` at the start of a command was proposed in #3261, but the proposal was at least initially rejected, leaving the door open for revisiting later - that time may have come.**\r\n\r\nFor now, **a fully robust solution** requires the following, cumbersome approach:\r\n\r\n```powershell\r\n# An externally provided no-shell command line, such as from an `UninstallString` registry entry.\r\n$commandLine = 'foo.exe http://example.org?foo=1&bar=2'\r\n\r\n# Split the command line into the executable and the list of arguments.\r\n# Note: The somewhat complicated regex is needed to deal with double-quoted executable paths.\r\n$exe, $argsString = $commandLine.Trim() -split '^([^\" ]+|\".+?\")' -ne ''\r\n\r\n# Invoke\r\nInvoke-Expression \"$exe --% $argsString\"\r\n```\r\n---\r\n\r\nI think it would have made sense to implement `--%` as accepting a _single, quoted string_ to begin with - which would avoid the need for `Invoke-Expression` - as argued in the bottom section of [this comment](https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-661984949) - however, that ship has sailed.\r\n\r\n**That said, if we now introduce support for `--%` _at the start_ of a command, we could conceivably implement it to require passing the command line _as a single string_,** so that the solution would simplify to:\r\n\r\n```powershell\r\n# WISHFUL THINKING:\r\n# --% at the start should require *a single string* containing the full command line.\r\n--% $commandLine\r\n```\r\n\r\nNote that **`--%`** _at the start_ of a command - **as a _statement_** - is also being **discussed in #13068, albeit for a _different_ use case: to execute a command written for a _different shell_ - the platform-native one.** (The unrealistic desire there is to think that this can be done _without quoting_ the entire foreign-shell portion of a command without introducing serious limitations and obscure behavior.)\r\n\r\nConflating these two uses cases - pass-through of an arguments string to an executable vs. executing a _shell_ command line - is `--%`'s problem to begin with.\r\n\r\nAs argued in the linked comment, an `Invoke-NativeShell` (`ins`) command that _also_ accepts a _single string_ is the right solution for the shell-command-line use case. Again, the `Native` module offers an implementation (`Install-Module Native`):\r\n\r\nWith it, you can simplify the not-fully-robust `Invoke-Expression \"cmd.exe /c --% $commandLine\"` solution from above as follows:\r\n\r\n```powershell\r\n# On Windows, executes the string as a `cmd.exe` command line.\r\nins $commandLine\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-12-06T17:02:21Z",
      "updated_at": "2020-12-06T17:06:17Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "> It doesn't. Instead, it builds a command-line string itself and assigns it to the System.Diagnostics.ProcessStartInfo.Arguments property, which is a single string; the .ArgumentList property didn't become available until .NET Core 2.1.\r\n\r\nThanks for the clarification, will have to try out `ArgumentList` at some point in the future as I was not aware of this.\r\n\r\nAs for my 2nd point, the more I think about it the more I'm starting to believe that maybe this isn't a use case that should be handled by the native parser. It seems like it adds some edge cases that just complicate the situation further instead of trying to make the native call syntax simpler rather than complex.\r\n\r\nIn reality this could be solved if `Start-Process` was refined further so that\r\n\r\n* It could pass in the cmdline string as is and invoke that\r\n* It could actually set stdout/stderr to a var or return them as extended properties on the Process object instead of relying on file level redirection",
      "created_at": "2020-12-06T19:43:17Z",
      "updated_at": "2020-12-06T19:43:17Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> the more I'm starting to believe that maybe this isn't a use case that should be handled by the native parser.\r\n\r\nIn case you're referring to the no-shell invocations of command-line strings such as from `UninstallString` registry entries:\r\n\r\n* What I'm proposing above (`--% $commandLine`) would have no edge cases: it's up to the user to construct the command-line string properly, and that will be invoked.\r\n\r\n  * .NET's `ProcessStartInfo` forces us to split that command line into executable path and arguments string, but the WinAPI's [`CreateProcess()`](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa) function itself would actually accept the command line as a whole; even if we stick with `ProcessStartInfo`, however, this splitting is not hard to do robustly behind the scenes (it is what the `$exe, $argsString = $commandLine.Trim() -split '^([^\" ]+|\".+?\")' -ne ''` PowerShell snippet above does).\r\n\r\n* _Additionally_, `Start-Process` could be extended to have something like a `-CommandLine` parameter that takes an entire command line [_update_: see #14347], but note that `Start-Process` generally serves a different purpose and is not a substitute for direct invocation, notably because the command's output streams aren't integrated with PowerShell's.\r\n\r\n  * Note that using a pass-through arguments string is already available in `Start-Process`, namely if you pass the arguments string - with proper embedded quoting - as the _only element_ to `-ArgumentList` (which is currently the only robust way to use `Start-Process`) - as with `ProcessStartInfo`, the executable must be passed separately.\r\n\r\n  * Yes, making it easier to capture stdout and stderr from a `Start-Process` call would also be nice, irrespective of the invocation syntax; if the `-Redirect*` parameters accepted _provider paths_, this would be as simple as `Start-Process ... -RedirectStandardOut variable:output`, following the model of the proposal in https://github.com/PowerShell/PowerShell/issues/4332#issuecomment-643486358 (which is about supporting that in the context of _redirections_; there's also a discussion about generalizing this for file arguments in #13699, which `Start-Process` would implicitly benefit from).\r\n",
      "created_at": "2020-12-06T21:03:25Z",
      "updated_at": "2020-12-07T19:54:03Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@jborean93, mulling over your `Start-Process` comment:\r\n\r\n I agree that enhancing `Start-Process` is the right thing to do for the `UninstallString` scenario, given that, without advance knowledge of wether the executable being invoked is a _console_ or _GUI_ application, the only way to ensure _synchronous_ execution is via `Start-Process -Wait`, so I've created proposal  #14347.\r\n\r\nWhile that lessens the need for `--% $commandLine` it would still be helpful in overcoming the current limitations of `--%`, in two respects:\r\n\r\n* the ability to use string interpolation to embed PowerShell variable references and expressions in the command (which the current, argument-only `--%` only allows in an indirect, cumbersome way, via aux. environment variables references as `%var%`).\r\n\r\n*  `--% $commandLine` , due to being syntactically unambiguous, allows unrestricted participation in a PowerShell pipeline, with support for PowerShell `>` and  line continuation.",
      "created_at": "2020-12-07T19:53:10Z",
      "updated_at": "2020-12-07T19:56:09Z"
    },
    {
      "author": "mpawelski",
      "author_association": "NONE",
      "body": ">  what we need is some examples of real world command lines that currently fail so that we have appropriate tests built to validate any prototype\r\n\r\nok, I just wanted to use [ripgreg ](https://github.com/BurntSushi/ripgrep)again to search for quoted string. I had to first guess how to escape it properly.\r\n```pwsh\r\nC:\\projects\\test [CWX-some-branch +0 ~3 -0 !]\r\n> where.exe echo.exe\r\nC:\\Program Files\\Git\\usr\\bin\\echo.exe\r\nC:\\projects\\test [CWX-some-branch +0 ~3 -0 !]\r\n> where.exe rg\r\nC:\\Users\\mariusz\\scoop\\shims\\rg.exe\r\nC:\\projects\\test [CWX-some-branch +0 ~3 -0 !]\r\n> echo.exe '\"\"\"Financials\"\"\"' #figure out how to escape \" to pass it to ripgrep. Its three \", come on \u00af\\_(\u30c4)_/\u00af\r\n\"Financials\"\r\nC:\\projects\\test [CWX-some-branch +0 ~3 -0 !]\r\n> rg -F '\"\"\"Financials\"\"\"' #ok, now i know what to pass, but it should work with just '\"Financials\"'\r\nTestProject.Resources\\Translations\\default\\locale\\de-DE\\messages.po\r\n312:msgstr \"Financials\"\r\n\r\nTestProject.Resources\\Translations\\default\\locale\\en-GB\\messages.po\r\n312:msgstr \"Financials\"\r\nC:\\projects\\test [CWX-some-branch +0 ~3 -0 !]\r\n>\r\n```\r\n",
      "created_at": "2020-12-08T16:34:01Z",
      "updated_at": "2020-12-08T16:34:01Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@mpawelski, I think by now we know what the required _workarounds_ are - see https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-562334606  (in your case, `'\\\"Financials\\\"'` would be simpler). I think we should focus the examples on how things _should_ work, ideally in the form of Pester tests, which in your case would be something like:\r\n\r\n```powershell\r\n# Should pass, but currently doesn't; using `ie rg` instead of `rg` would make it pass.\r\n'A \"quoted\" string.' | rg -F '\"quoted\" string' | Should -Not -BeNullOrEmpty\r\n```\r\n\r\nTo give a few examples using only in-box Windows programs - _all of these currently fail_:\r\n\r\nNote: \r\n\r\n* `cmd.exe`'s built-in `echo` command echoes quoting _as specified_ rather than parsing it into arguments and echoing them; while this an annoying limitation in general, here, `cmd /c echo ...` can be used as a poor man's substitute for `echoArgs.exe` to reflect the actual command line that was passed.\r\n\r\n* `choice /d Y /t 0 /m '...'` is a hack that can be used as a stand-in for proper echoing of a properly parsed-as-an-argument string (on Unix you'd use `printf %s\\n '...'`); it uses `choice.exe /m '...'` to echo the string argument with syntactic double quotes removed and `\\`-escaped embedded `\"` quotes printed verbatim, as any conventional CLI should; `/d Y /t 0` automatically answers the prompt, which causes the string `' [Y,N]?Y'` to be appended to the echoed string.\r\n\r\n### Conventional CLIs:\r\n\r\nAs stated, by delegating to `ProcessStartInfo.ArgumentList`, we don't strictly need to test these, except for a few sanity checks (this applies to _all_ tests on _Unix_).\r\n\r\nPass a JSON string as expected. That is, there should be _no_ need for an additional layer of escaping (`\\\"`), just because the string happens to be passed to an _external program_:\r\n\r\n```powershell\r\n# Currently, the target program unexpectedly sees '{ foo: 1 }` (\" stripped).\r\nchoice /d Y /t 0 /m '{ \"foo\": 1 }' | Should -Be ('{ \"foo\": 1 }' + ' [Y,N]?Y')\r\n```\r\n\r\nPass empty-string arguments as such (currently, they're _discarded_):\r\n\r\n```powershell\r\nchoice /d Y /t 0 /m '' | Should -Be ' [Y,N]?Y'\r\n```\r\n\r\n\r\n### Accommodations for non-conventional Windows CLIs / batch files:\r\n\r\n#### Accommodation (a), for batch files / `cmd.exe`:\r\n\r\nEscape `\"` as `\"\"` rather than `\\\"` for batch files / `cmd.exe`:\r\n\r\n```powershell\r\n# Pass an argument with embedded double quotes as expected.\r\n# Note that `echo` echoes the quoting as passed.\r\ncmd /c echo 'Marshall \"M&M\" Mathers' | Should -Be '\"Marshall \"\"M&M\"\" Mathers\"'\r\n```\r\n\r\nPass space-less arguments that contain `cmd.exe` metacharacters such as `&` (common in URLs) _double_quoted_ to batch files:\r\n\r\n```powershell\r\n'@echo %*' > \"test$PID.cmd\" # Create a test batch file that simply echoes its arguments.\r\n\r\n# Again, the use of `echo` reflects the quoting from the original command line.\r\n# Currently, this causes the argument to be *truncated*, followed by an *error*, due to the unprotected & char.\r\n& \".\\test$PID.cmd\" 'http://example.org?a&b' | Should -Be '\"http://example.org?a&b\"'\r\n\r\nRemove-Item \"test$PID.cmd\"\r\n```\r\n\r\n#### Accommodation (b), for `msiexec`-style CLIs, but strictly based on argument _form_: \r\n\r\nPass arguments of the form `<property>=<value with spaces>`, `-option=<value with spaces>`, `/option=<value with spaces>` and `-option:<value with spaces>`, `/option:<value with spaces>` with _only the `<value with spaces>` part double-quoted_:\r\n\r\n```powershell\r\n# Again, the use of `echo` reflects the quoting from the original command line.\r\n# Currently, \"FOO=bar none\" is passed (argument double-quoted *as a whole*).\r\ncmd /c echo FOO='bar none' | Should -Be 'FOO=\"bar none\"'\r\n```\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-12-10T14:50:23Z",
      "updated_at": "2020-12-10T18:48:51Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "You have chosen to ignore my suggestion in what resembles a review of options, so I repost:\r\n```powershell\r\nCMD /CECHO FOO=BAR | SHOULD -BE 'FOO=BAR'\r\nCMD /CECHO FOO=\"BAR\" | SHOULD -BE 'FOO=\"BAR\"'\r\nCMD /CECHO \"FOO=BAR\" | SHOULD -BE '\"FOO=BAR\"'\r\n```",
      "created_at": "2020-12-13T12:03:40Z",
      "updated_at": "2020-12-13T12:04:33Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Controlling the _exact command line_ to pass (by definition on Windows only) is _not_ the subject of this issue.\r\n\r\nTo do that, use `--%`:\r\n\r\n```powershell\r\nCMD --% /CECHO FOO=\"BAR\"| SHOULD -BE 'FOO=\"BAR\"'\r\n# ...\r\n```\r\n\r\n<sup>Note the absence of a space before `|`, to prevent that space from becoming part of `echo`'s output.</sup>\r\n\r\nAlternatively use the proposed `Invoke-NativeShell` (`ins`) (which would additionally allow you to use string interpolation):\r\n\r\n```powershell\r\nins @'\r\nECHO FOO=\"BAR\"\r\n'@ | SHOULD -BE 'FOO=\"BAR\"'\r\n```\r\n\r\nUse of `ins` is a must (meaning: you cannot do it with `--%`) if you want to pass a whole _shell command line_, notably including `>` or `|` in order to take advantage of `cmd.exe`'s binary pipeline / output redirection:\r\n\r\n```powershell\r\nins @'\r\ntype some.jpg > other.jpg\r\n'@\r\n```\r\n\r\nThe example is contrived, but the point is that you do on occasion need a raw-bytes / no-newline-appended pipeline, on Unix too, notably to be able to send a string _without a trailing newline_ to an external program, which PowerShell doesn't support - see #5974 and #13579.\r\n\r\n\r\n",
      "created_at": "2020-12-13T13:43:16Z",
      "updated_at": "2020-12-14T13:23:58Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> Controlling the _exact command line_ to pass (by definition on Windows only) is _not_ the subject of this issue.\r\n\r\nRight, the subject is how to correctly pass given arguments to executable programs (which boils down to quoting them).  And my take is: if possible, choose the quoting style as specified in the script out of the myriad ways you can correctly quote.  That would not help when expanding stored variables like `[STRING] $A = 'FOO=\"BAR\"'` but it would cover the SO use case in a generic way.\r\n\r\n\r\n",
      "created_at": "2020-12-14T10:13:51Z",
      "updated_at": "2020-12-14T10:14:32Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> which boils down to quoting them\r\n\r\nNotably, only on Windows - and it's an unfortunate necessity that we want to make as predictable as possible, without burdening PowerShell users with having to think about a second layer of parsing when they specify arguments.\r\n\r\n>  if possible, choose the quoting style as specified in the script out of the myriad ways you can correctly quote.\r\n\r\nThere is no need for this specificity, and it cannot be consistently applied.\r\n\r\nWe want to get away from a model where users are forced think about the command-line parsing peculiarities of the specific executable being invoked. Fulfilling _PowerShell's_ syntax requirements should be enough.\r\n\r\nThis is trivial to implement on Unix, but impossible to do _fully robustly_ on Windows - but with the suggested accommodations we'd get the intended behavior for all but a few edge cases - in which case `--%` can be used.\r\n\r\nAccommodation (b) would handle your `CMD /CECHO ...` examples based on a _general argument-form pattern_, ensuring that only the part after the `=` is double-quoted, and only if needed - irrespective of the _PowerShell-side_ quoting; that is, even `cmd /c echo 'FOO=bar none'` would result in `FOO=\"bar none\"`; that a target executable such as `msiexec` doesn't accept `\"FOO=bar none\"`, which it _should_ consider equivalent, is an unfortunate constraint that the accommodation handles transparently. \r\n\r\nOn Windows, CLIs, including shells, should never have gotten into the business of distinguishing `FOO=\"bar none\"` from `\"FOO=bar none\"` in individual start-up (command-line) arguments (this is different from _shell-internal_ parsing) - an convention-adhering CLIs (such as those relying on the C/C# runtime to construct the array of arguments) indeed do _not_: the resulting `argv` entry is verbatim `FOO=bar none` in both cases. \r\n\r\nAgain, this whole mess started when CLIs on Windows were forced to act as quasi-shells that must parse arguments encoded in a single string.\r\n\r\n---\r\n\r\nAs for your `[STRING] $A = 'FOO=\"BAR\"'` example:\r\n\r\nA better example would be the following, which notably does _not_ involve _embedded_ `\"` chars:\r\n\r\n(In your example, with the proposed fix, the embedded `\"` would be _escaped_ and placed as verbatim `FOO=\\\"BAR\\\"` on the ultimate command line (or, when calling a batch file, due to accommodation (a), `FOO=\"\"BAR\"\"`.)\r\n\r\n```powershell\r\n$propVal = $args[0]\r\n\r\nmsiexec FOO=$propVal\r\n```\r\n\r\nThat is, by the rules of PowerShell no quoting is required - and you shouldn't have to worry about anything else.\r\nWhatever `$propVal` expands to should make PowerShell automatically choose `FOO=<space-less-value>` or \r\n`FOO=\"<value with spaces>\"`, due to accommodation (b) (without this accommodation, using `.ArgumentList`, the latter would be passed as `\"FOO=<value with spaces>\"`)\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-12-14T14:08:37Z",
      "updated_at": "2020-12-14T14:08:37Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@vertigo220, your problem isn't directly related to the issue at hand, so I suggest you seek help on [Stack Overflow](https://stackoverflow.com/search?q=%5Bpowershell%5D+.reg+file+escaping), for instance.\r\n\r\n(The issue at hand is about calling _external programs_ from _inside PowerShell_; your problem is about calling PowerShell's CLI from _outside_ PowerShell (with commands that do not involve external programs); due to use of  a `.reg` file, you have an extra layer of `\\`-escaping to deal with.)",
      "created_at": "2021-02-01T17:25:04Z",
      "updated_at": "2021-02-01T17:25:04Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "A new PR has been created: #14692. As of this writing, it only encompasses the switch to `.ArgumentList` (enough to fix all problems on Unix) and not the [proposed accommodations for Windows](https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-738073284).",
      "created_at": "2021-02-03T21:01:27Z",
      "updated_at": "2021-02-03T21:01:27Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "@mklement0: @JamesWTruher's proposal for dealing with the Windows side of things is proposed in #14747. Would love to get your (or anyone else's) take in that issue, as that will be feeding into the implementation at #14692. ",
      "created_at": "2021-02-09T20:26:16Z",
      "updated_at": "2021-02-09T20:26:16Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Just to keep everyone in the loop:\r\n\r\nPowerShell Core 7.2.0-preview.5 was just released, which incorporates PR #14692 and therefore a new experimental feature named `PSNativeCommandArgumentPassing`, which aims to fix the problem at hand. It comes with a new preference variable, `$PSNativeCommandArgumentPassing` that accepts the values `Legacy` (the old behavior) and `Standard` (the new behavior, the default, at least in combination with the experimental feature).\r\n\r\nThis experimental feature:\r\n\r\n* _fully_ fixes the problem on Unix-like platforms.\r\n\r\n* only _partially_ fixes it on Windows, because vital accommodations for high-profile CLIs, as previously discussed, are missing - see #15143.\r\n\r\n* _breaks_:\r\n  *  `cmd /c` (`cmd /k`) calls, where a command line for `cmd.exe` is passed as a _single string_ - which is a common workaround for the problems with the previous behavior: see #15239\r\n  * `--%` (the stop-parsing symbol): see #15261 \r\n  * arguments such as `-F:` (looks like PowerShell parameter and _ends in `:`_) - see \r\n  * For an up-to-date list of all bugs, see https://github.com/PowerShell/PowerShell/issues/15143#issuecomment-822805995\r\n\r\n@joeyaiello, can you please clarify the plan with respect to the `$PSNativeCommandArgumentPassing` preference variable?\r\n\r\n* Should this experimental feature become an official one (\ud83e\udd1e), will the default value be `Legacy` or `Standard`?\r\n* In other words: Will user have to use an opt-_in_ to get the new behavior, or an opt-_out_ to preserve backward compatibility?\r\n\r\n",
      "created_at": "2021-04-15T15:57:05Z",
      "updated_at": "2021-04-19T21:46:53Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Unfortunately, the experimental feature also breaks `--%` (the stop-parsing symbol): see #15261",
      "created_at": "2021-04-17T16:21:12Z",
      "updated_at": "2021-04-17T21:58:51Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Unfortunately, the experimental feature also breaks passing arguments such as `-F:` (looks like a PowerShell parameter, _ends in `:`_) - see #15276\r\n\r\nI'll stop reporting these problems piecemeal here, and will try to maintain a current list in https://github.com/PowerShell/PowerShell/issues/15143#issuecomment-822805995\r\n",
      "created_at": "2021-04-19T21:48:41Z",
      "updated_at": "2021-04-20T01:58:54Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Because #15143 is quite information-dense, I've created two separate comments there with concrete examples:\r\n\r\n* **Easy-to-grasp _examples_ of the proposed accommodations** are [in this comment](https://github.com/PowerShell/PowerShell/issues/15143#issuecomment-822805995).\r\n\r\n* **Complementary examples of _what won't work_** unless we implement these accommodations are in [another comment](https://github.com/PowerShell/PowerShell/issues/15143#issuecomment-826330365).\r\n\r\n",
      "created_at": "2021-04-25T14:17:14Z",
      "updated_at": "2021-04-25T14:17:14Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "A decision regarding the accommodations on Windows has been made: https://github.com/PowerShell/PowerShell/issues/15143#issuecomment-833090452.",
      "created_at": "2021-05-06T21:16:13Z",
      "updated_at": "2021-05-06T21:16:13Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "This appears to be fixed in 7.3:\r\n\r\n```powershell\r\nPS> testexe -echoargs \"`\"a`\"\"\r\nArg 0 is <\"a\">\r\n```\r\n",
      "created_at": "2022-08-11T01:16:27Z",
      "updated_at": "2022-08-11T01:16:27Z"
    },
    {
      "author": "jiasli",
      "author_association": "NONE",
      "body": "> This appears to be fixed in 7.3:\r\n\r\nThanks a lot @SteveL-MSFT. May I know which PR is responsible for the fix?\r\n",
      "created_at": "2022-08-11T13:24:44Z",
      "updated_at": "2022-08-11T13:24:44Z"
    },
    {
      "author": "jiasli",
      "author_association": "NONE",
      "body": "I can verify double quotes are escaped correctly in v7.3.0-preview.6 when calling a `.exe`. \r\n\r\n```\r\n> echo $PSVersionTable\r\n\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.3.0-preview.6\r\n...\r\n\r\n> python -c \"import sys; print(sys.argv)\" '\"ab\"'\r\n['-c', '\"ab\"']\r\n```\r\n\r\nHowever, special characters (`\"`, `|`, `&`) are still not escaped correctly when invoking a `cmd` script. Consider a very simply script `test.cmd`:\r\n\r\n```cmd\r\necho %*\r\npython -c \"import sys; print(sys.argv)\" %*\r\n```\r\n\r\nFor `|`, running `test.cmd` in PowerShell v7.3.0-preview.6 gives:\r\n\r\n```\r\nPS D:\\> ./test.cmd \"a|b\"\r\n'b' is not recognized as an internal or external command,\r\noperable program or batch file.\r\n```\r\n\r\nThis differs from the behavior of Command Prompt:\r\n\r\n```\r\nD:\\>test.cmd \"a|b\"\r\n\r\nD:\\>echo \"a|b\"\r\n\"a|b\"\r\n\r\nD:\\>python -c \"import sys; print(sys.argv)\" \"a|b\"\r\n['-c', 'a|b']\r\n```\r\n\r\nThis causes problem for Azure CLI when there is `|` or `&` in argument value: https://github.com/Azure/azure-cli/issues/20972\r\n\r\nFor `\"`, running `test.cmd` in PowerShell v7.3.0-preview.6 gives:\r\n\r\n```\r\nPS D:\\> ./test.cmd \"`\"ab`\"\"\r\n\r\nD:\\>echo \"ab\"\r\n\"ab\"\r\n\r\nD:\\>python -c \"import sys; print(sys.argv)\" \"ab\"\r\n['-c', 'ab']\r\n```\r\n\r\nThis differs from the behavior of Command Prompt:\r\n\r\n```\r\nD:\\>test.cmd \"\\\"ab\\\"\"\r\n\r\nD:\\>echo \"\\\"ab\\\"\"\r\n\"\\\"ab\\\"\"\r\n\r\nD:\\>python -c \"import sys; print(sys.argv)\" \"\\\"ab\\\"\"\r\n['-c', '\"ab\"']\r\n```\r\n\r\n",
      "created_at": "2022-08-11T13:32:20Z",
      "updated_at": "2022-10-25T10:27:01Z"
    },
    {
      "author": "rivy",
      "author_association": "NONE",
      "body": "As noted by @jiasli, this issue is not actually fixed.",
      "created_at": "2022-08-11T14:42:28Z",
      "updated_at": "2022-08-11T14:42:28Z"
    },
    {
      "author": "brendandburns",
      "author_association": "CONTRIBUTOR",
      "body": "The PowerShell behavior here is the same as `bash`\r\n\r\n`test.sh`:\r\n```sh\r\n#!/bin/bash\r\n\r\necho $@\r\n```\r\n\r\n```sh\r\nbburns@DESKTOP-VHJJ57D:~$ ./test.sh \"a|b\"\r\na|b\r\nbburns@DESKTOP-VHJJ57D:~$ ./test.sh \"a&b\"\r\na&b\r\nbburns@DESKTOP-VHJJ57D:~$\r\n```\r\n\r\nIn my opinion, the bash/powershell behavior makes more sense than the `cmd` behavior. In the above example, the quotes are intended for the shell interpreter, they are not part of the user's input. The shell's job is to pass each value as a String to the command that it calls. It is the executable/command scripts responsibility to re-escape as necessary before shelling out again.",
      "created_at": "2022-08-11T16:04:11Z",
      "updated_at": "2022-08-11T16:04:48Z"
    },
    {
      "author": "brendandburns",
      "author_association": "CONTRIBUTOR",
      "body": "Furthermore this seems to be a specific behavior related to `cmd.exe` calling command scripts.\r\n\r\n```python\r\nimport sys\r\nprint(sys.argv)\r\n```\r\n\r\n```sh\r\nC:\\Users\\bburns>py test.py 'a|b'\r\n'b'' is not recognized as an internal or external command,\r\noperable program or batch file.\r\n\r\nC:\\Users\\bburns>py test.py 'a&b'\r\n['test.py', \"'a\"]\r\n'b'' is not recognized as an internal or external command,\r\noperable program or batch file.\r\n```",
      "created_at": "2022-08-11T16:10:19Z",
      "updated_at": "2022-08-11T16:11:01Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> As noted by @jiasli, this issue is not actually fixed.\r\n\r\nThis issue is about passing arguments to native executables that support passing arguments.  The executable `cmd.exe` is not one of them, it uses the whole command line instead.  The only reliable way to call `cmd.exe` is to print the expected command line out into a temporary command script and run that script without any arguments.",
      "created_at": "2022-09-16T11:27:14Z",
      "updated_at": "2022-09-16T11:27:14Z"
    },
    {
      "author": "89z",
      "author_association": "NONE",
      "body": "Update, I believe this:\r\n\r\nhttps://github.com/PowerShell/PowerShell/releases/tag/v7.3.0\r\n\r\nis the first non-preview release to correctly escape this type of command:\r\n\r\n~~~\r\ncurl.exe --trace trace.txt --json '{ \"drink\": \"coffe\" }' https://example.com\r\n~~~\r\n",
      "created_at": "2022-11-09T00:56:46Z",
      "updated_at": "2022-11-09T00:57:06Z"
    }
  ],
  "created_at": "2016-08-21T16:55:59Z",
  "labels": [
    "WG-Engine",
    "Resolution-Fixed",
    "Committee-Reviewed"
  ],
  "number": 1995,
  "state": "closed",
  "title": "Arguments for external executables aren't correctly escaped",
  "updated_at": "2022-11-09T00:57:06Z"
}