{
  "_url": "https://github.com/PowerShell/PowerShell/issues/14652",
  "author": "awakecoding",
  "body": "\r\n# PR Summary\r\n\r\nAdd a new NativeHost class in Microsoft.PowerShell.ConsoleHost.dll with a LoadAssemblyData function callable from unmanaged code to load assemblies in memory. This fixes https://github.com/PowerShell/PowerShell/issues/14641 and https://github.com/dotnet/runtime/issues/46652 for PowerShell. This modification has been confirmed to work in [a proof-of-concept PowerShell native host](https://github.com/awakecoding/pwsh-native-host).\r\n\r\n## PR Context\r\n\r\nLong story short, the ultimate goal is to make it possible for any native language such as C/C++/Rust to find, load, and host PowerShell 7 entirely at runtime, using nothing but the existing PowerShell installation. This is possible by loading the hostfxr library found alongside PowerShell dynamically to then load the PowerShell runtime config. The last step is to load bindings to make the bridge between unmanaged to managed code possible, and wrap functions from Microsoft.PowerShell.SDK.\r\n\r\nLoading the precompiled bindings is currently only possible from a file with the hostfxr APIs, which is why I originally approached the .NET runtime team first (https://github.com/dotnet/runtime/issues/46652) but eventually exhausted all options. I then opened an issue with PowerShell (https://github.com/PowerShell/PowerShell/issues/14641) to see if this could be fixed outside of the .NET runtime, after all, we only need *one* helper function exported by one of the PowerShell assemblies.\r\n\r\n## PR Checklist\r\n\r\nThis is my first contribution to the core PowerShell project, and I perfectly understand that questions are going to be asked: why is this necessary, why a new class, why this function, etc. Please just work with me to find the best place to put this single helper function meant to facilitate loading PowerShell inside a native host. I deliberately used just one function and didn't try exporting more functions because it is a small change that will require no further changes inside PowerShell. I placed it inside its own class inside Microsoft.PowerShell.ConsoleHost.dll, but I'm open to suggestions.\r\n\r\nIn other words: if I can load my assembly in memory, then I can load all the bindings I need for the native language of my choosing. It also becomes a lot easier to choose exactly how those bindings will handle marshaling, and which functions they expose to unmanaged callers. This is a one-time thing that unlocks extensibility forever because you can load anything into the assembly context to fit your needs.\r\n\r\nThe helper function always loads the assembly into the default AssemblyLoadContext. My thinking is that if I ever need to deal with non-default ALCs, I can still add more functions callable from native code to deal with non-default ALCs, even if those helper functions are first loaded in the default ALCs. However, if there are easier ways to extend the NativeHost class, I'm open to suggestions, but I'd rather keep changes as small as possible to increase the chances of this PR being accepted.\r\n",
  "closed_at": "2021-04-28T21:28:41Z",
  "comments": [
    {
      "author": "microsoft-cla-retired[bot]",
      "author_association": "NONE",
      "body": "[![CLA assistant check](https://cla.opensource.microsoft.com/pull/badge/signed)](https://cla.opensource.microsoft.com/PowerShell/PowerShell?pullRequest=14652) <br/>All CLA requirements met.",
      "created_at": "2021-01-22T21:48:02Z",
      "updated_at": "2021-01-22T21:52:16Z"
    },
    {
      "author": "awakecoding",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT @joeyaiello @iSazonov this is the only thing required to make PowerShell native hosts possible from any native language using nothing but the existing PowerShell files, [as seen on twitter](https://twitter.com/awakecoding/status/1347220048444870658)!\r\n\r\nHelp me get this in an acceptable state and I promise you'll see a special Rust library published soon making it possible to load and host PowerShell 7 with zero link-time dependencies, and zero installation required other than PowerShell. If you have \"pwsh\", then you now have it usable inside your native host process as well.",
      "created_at": "2021-01-22T22:00:29Z",
      "updated_at": "2021-01-22T22:00:29Z"
    },
    {
      "author": "TravisEz13",
      "author_association": "MEMBER",
      "body": "Security Working group reviewed, and we don't find a security issue in the public API.",
      "created_at": "2021-01-25T21:41:05Z",
      "updated_at": "2021-01-25T21:41:05Z"
    },
    {
      "author": "awakecoding",
      "author_association": "CONTRIBUTOR",
      "body": "@TravisEz13 thanks!\r\n\r\nAnybody knows what is causing some checks to fail? It appears unrelated to the changes in this PR:\r\n\r\n```\r\nWinRM based remoting session abrupt disconnect.Verifies that an abruptly disconnected Invoke-Command session produces a valid disconnected job needed for reconnect\r\nExpected exactly 'Disconnected', but got Disconnecting.\r\n```",
      "created_at": "2021-01-25T22:00:14Z",
      "updated_at": "2021-01-25T22:00:14Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Anybody knows what is causing some checks to fail? It appears unrelated to the changes in this PR:\r\n\r\nI restarted CI-Windows.",
      "created_at": "2021-01-26T03:22:24Z",
      "updated_at": "2021-01-26T03:22:24Z"
    },
    {
      "author": "awakecoding",
      "author_association": "CONTRIBUTOR",
      "body": "@anmenaga @daxian-dbw I see you've been assigned as reviewers, what would be the next step? It's a small change, but there are things that are open to debate, such as:\r\n\r\n- in which class to put the function, we only have one for now, but we leave space for adding more if required in the future.\r\n- naming of the class and, I named it 'NativeHost' but it could very well be named 'UnmanagedHost' if this is preferred\r\n- the LoadAssemblyData() function and how it uses the Default ALC, maybe there is a nice way to support non-default ALCs\r\n\r\nI'm not very familiar with ALCs, but loading my bindings to the PowerShell class inside the default ALC works just fine for me. If someone can foresee a potential limitation with ALCs and knows more about them than I do, it would be work pointing it out now.",
      "created_at": "2021-01-26T18:26:07Z",
      "updated_at": "2021-01-26T18:26:07Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as Review Needed because it has been there has not been any activity for **7 days**.\nMaintainer, please provide feedback and/or mark it as `Waiting on Author`",
      "created_at": "2021-02-03T02:00:05Z",
      "updated_at": "2021-02-03T02:00:05Z"
    },
    {
      "author": "awakecoding",
      "author_association": "CONTRIBUTOR",
      "body": "I am waiting on one of the reviewers to tell me what the next step is :)",
      "created_at": "2021-02-03T15:58:17Z",
      "updated_at": "2021-02-03T15:58:17Z"
    },
    {
      "author": "TravisEz13",
      "author_association": "MEMBER",
      "body": "Somehow we need to show that the failures are not related to your change.",
      "created_at": "2021-02-03T19:02:15Z",
      "updated_at": "2021-02-03T19:02:15Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as Review Needed because it has been there has not been any activity for **7 days**.\nMaintainer, please provide feedback and/or mark it as `Waiting on Author`",
      "created_at": "2021-02-11T02:00:06Z",
      "updated_at": "2021-02-11T02:00:06Z"
    },
    {
      "author": "awakecoding",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT @rjmholt @iSazonov @daxian-dbw @PaulHigin @TravisEz13 @anmenaga  I would like to get this PR unstuck from the mud. It's unclear from the previous discussion what change would make it finally clean enough for a merge. There's a lot of \"this might be better, maybe we should move it here\" but nothing firm from one of the 4 assigned reviewers yet?\r\n\r\nI really do not care what the class name and function name is, I just want to know what needs to be changed to make it good for a merge, especially before 7.2 becomes final? I would hate to have to wait for 7.3 just for 5 lines of code, but I would be fine with requiring 7.2 as a baseline just for this.\r\n\r\nPlease tell me exactly what to fix, I'll do it once, and then we can move on. So, I'm asking, what changes need to be done to make the current PR acceptable, please? :)",
      "created_at": "2021-03-25T16:35:29Z",
      "updated_at": "2021-03-25T16:35:29Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I reread all related links to refresh my memory.\r\n\r\nThe main fact is that .Net team has no plans now and near future to implement an solution for supporting native host scenarios and [recommends](https://github.com/dotnet/runtime/issues/46652#issuecomment-755729799) to use _custom wrap managed dll_ which can be called from native code.\r\nExample of such dll https://github.com/awakecoding/pwsh-native-host/blob/master/NativeHost/Bindings.cs\r\n\r\n---------------------\r\n\r\nBased on the fact I see two way we have.\r\n1. If MSFT PowerShell team does not want to spend even 1 cent, then we continue this PR given that the security team did not find any problems in this.\r\n    Given the specifics of this API the status of this API should be \"not public, not supported, only for external partner, can be removed in any time\".\r\n2. Second option is to implement the wrap dll as shared solution.\r\n    Considering that the project is _open source_, it would be more correct design to implement this wrap dll in PowerShell / NativeSDK repository so that other native host projects can benefit from this.\r\nSince PowerShell managed SDK is very stable the Native SDK will be stable too and shouldn't take a lot of effort to maintain.\r\nThat we need to do:\r\n    - wrap most of useful PowerShell public API in the dll and cover most of native host scenarios.\r\n    - publish as nuget signed by Microsoft\r\n    - distribute with PowerShell (reference the nuget in Microsoft.PowerShell.SDK.csproj)\r\n        -  as standalone file (a native host must ensure that this dll is loaded)\r\n        -  or with an API hook to load always or on demand (preffered I believe) from a native host\r\n\r\n/cc @SteveL-MSFT @JamesWTruher @daxian-dbw who could weight and select a direction we will follow.\r\n\n\n<blockquote><img src=\"https://avatars.githubusercontent.com/u/295841?s=400&v=4\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/awakecoding/pwsh-native-host\">awakecoding/pwsh-native-host</a></strong></div><div>pwsh native host experiment. Contribute to awakecoding/pwsh-native-host development by creating an account on GitHub.</div></blockquote>",
      "created_at": "2021-03-26T18:44:59Z",
      "updated_at": "2021-03-26T18:45:01Z"
    },
    {
      "author": "awakecoding",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov thank you for the detailed follow up. I noticed that you pointed to my larger set of bindings, and I just want to clarify that my PR is to add a single function that makes it possible to load any set of bindings not distributed with PowerShell. In other words, a single native function export to load your own bindings, and not the whole set of bindings, making it a \"bring your own bindings\" type of solution, but no additional file or installation required to load the bindings.\r\n\r\nYour first suggestion is still what I'd like: just include this single function somewhere into PowerShell and we can take it from there without further modifications to PowerShell. My very first use case for this is a Rust crate that will enable loading and using PowerShell entirely at runtime *without redistributing PowerShell, and without link time dependencies*. This is what I could validate with my proof-of-concept in C, and since then I've been working very hard to find a solution to the last problem of requiring at last one additional file on disk distributed separately.\r\n\r\nThe second suggestion of making a wrapper DLL as a shared solution would unfortunately greatly increase the scope of the project and take it in a completely new direction. Because it's very hard to know *how* foreign language XYZ would deal with the bindings, I wouldn't even consider trying to do it that way. This being said, nothing prevents implementing the first suggestion (single native function export + bring your own bindings) and then working on a useful set of bindings that most people would be fine with. However, that would be a totally different story and out-of-scope for the current work.\r\n\r\nSince the security team did not find any objections to the current PR, maybe it's already good enough for a possible merge, unless someone wants to request modifications? At this point any change request would likely be non-functional in nature (name and location in the code), but there seems to be no objection on the actual code change made here.\r\n\r\nSo, who can give their seal of approval on this one? @SteveL-MSFT ? :)",
      "created_at": "2021-03-26T19:05:20Z",
      "updated_at": "2021-03-26T19:05:20Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Since the security team did not find any objections to the current PR, maybe it's already good enough for a possible merge, unless someone wants to request modifications?\r\n\r\nI have reviewed the existing API and believe that it has nothing to do with the new API. The existing API comes from Windows PowerShell and .Net Framework - it can not be used with .Net Core and we could remove it at all. (Or is it used on Windows Nano?)\r\n\r\nSo I think we should put the new API in SMA dll as new standalone static class (with a comment about limited support as I mentioned above).",
      "created_at": "2021-03-26T19:32:15Z",
      "updated_at": "2021-03-26T19:32:15Z"
    },
    {
      "author": "awakecoding",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov thank you, the new API has nothing to do with the old one, so I do agree it has to be in its own standalone static class (which is currently the case). I'm no expert in PowerShell internals, can you tell me what SMA stands for and where it is?\r\n\r\nIn this case, all I'd need is to move the class (currently named NativeHost in NativeHost.cs) to the SMA DLL, if you could just point me to where that is :)",
      "created_at": "2021-03-26T19:43:36Z",
      "updated_at": "2021-03-26T19:43:36Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> can you tell me what SMA stands for and where it is?\r\n\r\nSMA is [System.Management.Automation](https://github.com/PowerShell/PowerShell/tree/master/src/System.Management.Automation), which is the core assembly for PowerShell.",
      "created_at": "2021-03-26T21:16:48Z",
      "updated_at": "2021-03-26T21:16:48Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "After further reviews I proposal to put new API after the class\r\nhttps://github.com/PowerShell/PowerShell/blob/be7d36603d1cc60abd4e8e738ead8f437b7869fa/src/System.Management.Automation/CoreCLR/CorePsAssemblyLoadContext.cs#L565-L589\r\n\r\nNew class name `PowerShellUnsafeAssemblyLoad` and method `LoadAssemblyFromMemory()`",
      "created_at": "2021-03-27T06:00:20Z",
      "updated_at": "2021-03-27T06:00:20Z"
    },
    {
      "author": "awakecoding",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov I updated my branch to rename the function to LoadAssemblyFromMemory() under a new class PowerShellUnsafeAssemblyLoad at the end of System.Management.Automation/CoreCLR/CorePsAssemblyLoadContext.cs. This looks like the ideal place to put it, as the helper function is really AssemblyLoadContext-related, and will always remain.\r\n\r\nThe only future extensions I could foresee for this class are more AssemblyLoadContext-related helper functions. I've heard there was talk of eventually supporting multiple ALCs for dependencies and make it easier to unload and reload modules, but it's nothing available at this point. However, I could easily see a few functions added in that new class when advanced ALC support is added to PowerShell to expose the equivalent to a native host.\r\n\r\n@rjmholt with the code moved to SMA under a new name as suggested by @iSazonov is there anything else you would see that might require changes?",
      "created_at": "2021-03-27T13:07:38Z",
      "updated_at": "2021-03-27T13:09:12Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> I've heard there was talk of eventually supporting multiple ALCs for dependencies and make it easier to unload and reload modules, but it's nothing available at this point.\r\n\r\nA conclusion was that it is not realistic to implement unloading PowerShell modules in the Engine but additional ALCs can be used to partially solve the dependency problem.",
      "created_at": "2021-03-27T14:38:22Z",
      "updated_at": "2021-03-27T14:38:22Z"
    },
    {
      "author": "awakecoding",
      "author_association": "CONTRIBUTOR",
      "body": "> LGTM.\r\n> \r\n> The team may want to add a comment about the status of this API (unsupported?).\r\n> \r\n> PowerShell Committee please review the new public API.\r\n\r\nI suggest that if we don't hear back from them we can simply finish this pull request just you and me, I'll make the changes until you are fully satisfied with it.",
      "created_at": "2021-03-30T14:58:04Z",
      "updated_at": "2021-03-30T14:58:04Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I think that the proposed public API will not change anymore. The rest (implementation, comments can always be corrected.",
      "created_at": "2021-03-30T16:49:15Z",
      "updated_at": "2021-03-30T16:49:15Z"
    },
    {
      "author": "awakecoding",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov just to make sure, the \"int\" type in .NET is always a signed 32-bit integer, right? That would have been the only thing left if it wasn't the case, so I'm just double checking. I only care that it has a predictable size, and there's no point in making it 64-bit really.",
      "created_at": "2021-03-30T16:54:18Z",
      "updated_at": "2021-03-30T16:54:18Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> @iSazonov just to make sure, the \"int\" type in .NET is always a signed 32-bit integer, right? That would have been the only thing left if it wasn't the case, so I'm just double checking. I only care that it has a predictable size, and there's no point in making it 64-bit really.\r\n\r\nYes, it is 32-bit. And it is _blittable_ type - such types can be passed between managed and unmanaged code without marshalling https://docs.microsoft.com/en-us/dotnet/framework/interop/blittable-and-non-blittable-types\n\n<blockquote><img src=\"https://docs.microsoft.com/en-us/media/logos/logo-ms-social.png\" width=\"48\" align=\"right\"><div><strong><a href=\"https://docs.microsoft.com/en-us/dotnet/framework/interop/blittable-and-non-blittable-types\">Blittable and Non-Blittable Types</a></strong></div><div>Learn about blittable and non-blittable types. Blittable data types are commonly represented in managed and unmanaged memory and don't need special handling.</div></blockquote>",
      "created_at": "2021-03-30T17:09:23Z",
      "updated_at": "2021-03-30T17:09:25Z"
    },
    {
      "author": "JamesWTruher",
      "author_association": "MEMBER",
      "body": "My big concern is that there isn't _any_ validation here. While I recognize that any validation would vastly out strip the size of the change here, it seems like there should be _something_. I expect that there's some infrastructure needs here as well, but the first time there's a problem in the wild, we'll _have_ to add validation.",
      "created_at": "2021-03-31T19:01:29Z",
      "updated_at": "2021-03-31T19:01:29Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Adding (useful) tests means we have to create a ported native host for all platforms.\r\nIs it even possible?\r\nWhat is language we should use? C? C++? Rust?\r\nHave we the native compilers in our CI VMs?\r\nOr we could have the native demo/test host in separate repository and download it as nuget.",
      "created_at": "2021-03-31T19:23:13Z",
      "updated_at": "2021-03-31T19:23:13Z"
    },
    {
      "author": "awakecoding",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov @JamesWTruher I suggest we begin by adding this simple function that is now down to two lines of actual code, making it relatively easy to review for initial inclusion.\r\n\r\nAs for testing, is there precedent for testing AssemblyLoadContext from an unmanaged host, or is there precedent for testing unmanaged code at all within PowerShell? I wouldn't want to block the initial inclusion of this function that unlocks a whole new world for easier native host implementations. Adding the ability to test automatically unmanaged code for PowerShell may prove difficult if it hasn't been done before.\r\n\r\nHere's the deal: my current proof-of-concept C code is not in a clean state, but I would definitely improve it as I work on the new Rust implementation side-by-side. I need to deal with a few portability issues (UTF-16 in Windows, cross-platform path handling, etc). I've got C utils I can import to make a minimalistic C library with a stable external API that uses UTF-8. While I don't intend to push the C implementation much beyond the basics, it should be sufficient for testing.\r\n\r\nOnce I have this first cleaned up C implementation I will get to work on porting it to Rust, and plan on working mostly with the Rust implementation from there. I suggest that the C implementation becomes the reference for anybody interested in implementing it in other languages. Maybe there would be sufficient interest in the C implementation, in this case I don't mind accepting improvements.\r\n\r\nCan we agree to include the new function before we get the ability to test it automatically? I will follow-up with the team to see how we could add testing capabilities for unmanaged hosts in the future in due time, but waiting for this now would simply prevent the project from taking off the ground.",
      "created_at": "2021-03-31T20:45:35Z",
      "updated_at": "2021-03-31T20:45:35Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> My big concern is that there isn't _any_ validation here. While I recognize that any validation would vastly out strip the size of the change here, it seems like there should be _something_. I expect that there's some infrastructure needs here as well, but the first time there's a problem in the wild, we'll _have_ to add validation.\r\n\r\n@JamesWTruher  We have a similar situation for PSES - any change in the Engine can break it, which has already happened many times but _we still don't have tests for PSES here._ (Although we have some tests for some _external_ modules!)\r\n\r\nThus, if we do not intend to make the [Native SDK](https://github.com/PowerShell/PowerShell/pull/14652#issuecomment-808439965) as a new separate project with a full set of tests, then it remains for us to delegate this testing to consumers in the same way as we do for PSES.\r\n\r\n> Once I (@awakecoding) have this first cleaned up C implementation I will get to work on porting it to Rust, and plan on working mostly with the Rust implementation from there. I suggest that the C implementation becomes the reference for anybody interested in implementing it in other languages. Maybe there would be sufficient interest in the C implementation, in this case I don't mind accepting improvements.\r\n\r\nPerhaps MSFT team has an interest to have this as a part of Native SDK.\r\nToday MSFT has many native hosts for _Windows PowerShell_. I am sure that the time will come and they will _do_ the same for _PowerShell Core_.",
      "created_at": "2021-04-01T03:40:23Z",
      "updated_at": "2021-04-01T16:58:44Z"
    },
    {
      "author": "awakecoding",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov @JamesWTruher @SteveL-MSFT in an effort to complete the current pull request, I suggest that we create a separate issue to track automated testing of native PowerShell hosts. It's important because the new function greatly reduces friction for the upcoming work.\n\nAdding support for testing native hosts in the PowerShell CI environment will likely bring up a lot of questions and it will definitely be subject to a *lot* of discussion. If the discussion leading to a 2-line function is this big, I can't help but wonder how adding the compilation and execution of a C program as part of the tests will look like. It's a discussion worth having but it won't be a piece of cake.\n\nI offer to follow up on the automated testing work after the current pull request is merged and gather everybody else interested in testing similar functionality to continue the discussion in a new issue.\n\nIs there anything else that might block the current pull request at this point? It does look like we've been to the end of it, as the next steps would be future work in separate issues.\n",
      "created_at": "2021-04-01T16:22:20Z",
      "updated_at": "2021-04-01T16:22:20Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "@awakecoding First, I want to land that we in the @PowerShell/powershell-committee absolutely agree that, at a high-level, resolving the issue you raised in #14641 is valuable. (Some folks have argued that `powershell.exe` may not be the right place to ship these hooks, but again, *high-level* value.)\r\n\r\nI understand that this sort of back-and-forth is not ideal, but the stability of PowerShell and the long-term supported nature of its APIs is not something we take lightly. Regardless of the # of LOCs, this is an API that we will have to support for many, many years to come and as such, these discussions *and* testing are required in order to make progress. Furthermore, even if it's expensive, this implies that testing cannot be an afterthought, *particularly* where we have low existing coverage. \r\n\r\nThe current thinking from the @PowerShell/powershell-committee is that, given that all (or nearly enough of all) native hosts are compatible with C, something robustly designed and similar to the APIs that exist in your proof-of-concept C bindings are actually what we'd want to ship as opposed to this low-level hook that leaves implementation of said C bindings up to individual developers. Particularly, given that this low-level hook essentially allows you to do whatever you want, there are number of unsafe things that can happen if those C bindings (or Rust or Python or whatever) are not implemented correctly.\r\n\r\n\r\nUnfortunately, we don't have quorum without @SteveL-MSFT today, and we'd like to get his opinion before we feel comfortable closing this PR, but it's something we probably will need to rework with a longer term conversation. \r\n\r\nAs a side note: is there a reason why you can't currently use your fork as the implementation that unblocks your current scenario? \r\n",
      "created_at": "2021-04-07T23:01:09Z",
      "updated_at": "2021-04-07T23:01:09Z"
    },
    {
      "author": "awakecoding",
      "author_association": "CONTRIBUTOR",
      "body": "> @awakecoding First, I want to land that we in the @PowerShell/powershell-committee absolutely agree that, at a high-level, resolving the issue you raised in #14641 is valuable. (Some folks have argued that `powershell.exe` may not be the right place to ship these hooks, but again, _high-level_ value.)\r\n\r\nThank you for recognizing the importance of adding such hooks. As you have probably noticed, I originally tried very hard to get it done inside the .NET runtime, but ultimately faced a dead end. However, since the feature is intended for PowerShell specifically, doing it inside PowerShell instead of the .NET runtime is acceptable, especially from a high-level point of view.\r\n\r\n> I understand that this sort of back-and-forth is not ideal, but the stability of PowerShell and the long-term supported nature of its APIs is not something we take lightly. Regardless of the # of LOCs, this is an API that we will have to support for many, many years to come and as such, these discussions _and_ testing are required in order to make progress. Furthermore, even if it's expensive, this implies that testing cannot be an afterthought, _particularly_ where we have low existing coverage.\r\n\r\nThere is a difference between *enabling* developers to extend PowerShell, and offering complex APIs that developers rely on and therefore need to be actively maintained. These changes are intentionally made very small to facilitate reviewing but also to reduce the maintenance burden to a minimum. If you think testing cannot be an afterthought, then we should discuss *how* we can test native applications within the PowerShell CI environment. However, judging from past discussion on smaller changes, I can only imagine how long it would take to wait for native application testing capabilities.\r\n\r\n> The current thinking from the @PowerShell/powershell-committee is that, given that all (or nearly enough of all) native hosts are compatible with C, something robustly designed and similar to the APIs that exist in your proof-of-concept C bindings are actually what we'd want to ship as opposed to this low-level hook that leaves implementation of said C bindings up to individual developers. Particularly, given that this low-level hook essentially allows you to do whatever you want, there are number of unsafe things that can happen if those C bindings (or Rust or Python or whatever) are not implemented correctly.\r\n\r\nI understand why you and the PowerShell committee think it is a good idea, but I have to strongly disagree on this point: even if we do decide to work on exposing a rich C API, we should still make it possible for third-parties to develop the entire set of bindings separately. In fact, that is *precisely* what the current changes are intended for: it is not possible to know how language XYZ would rather deal with the bindings, so don't even try to guess what it should be.\r\n\r\nFor instance, if we expose a rich set of C APIs, they will essentially be unsafe APIs from the Rust point of view, while there are many ways safer Rust to C# bindings could be implemented. However, this requires full control over the bindings from the foreign language, which is why I intend to generate, build and \"link\" the C# bindings inside the Rust library that will use them.\r\n\r\nI also certainly do not wish to enter the debate on how to handle the marshalling of certain types like strings (UTF-8 null terminated C strings vs UTF-16 on Windows for C, etc). Native Rust string types are not even null-terminated and are passed with an implicit length (char slices). If I can control both sides, I can make something much better for Rust. If we make C bindings, I'm stuck making unsafe code and deal with a C API to invoke what is in fact managed C#.\r\n\r\nI am not against making a rich set of APIs, but I consider it to be complementary, not mutually exclusive with enabling developers to write their own set of bindings correctly adapted to the foreign language of their choice. Even if we do make an official C SDK, I wouldn't be surprised if many would rather prefer to build their own with extended functionality, just because it doesn't need to be officially approved and merged upstream. In other words, third-party SDKs benefit from much higher flexibility, and they are also not an additional burden for the PowerShell team.\r\n\r\nYou mention how every API added to PowerShell needs to be supported for a long time. I understand that, which is why I don't want to add more APIs than necessary, and make it possible for others to extend on top of PowerShell without necessarily becoming officially-supported PowerShell extensions that you have to live with for the next 10 years or so.\r\n\r\n> Unfortunately, we don't have quorum without @SteveL-MSFT today, and we'd like to get his opinion before we feel comfortable closing this PR, but it's something we probably will need to rework with a longer term conversation.\r\n> \r\n> As a side note: is there a reason why you can't currently use your fork as the implementation that unblocks your current scenario?\r\n\r\nDespite what I may have suggested in the past, I never actually forked PowerShell, because it would involve building it for all platforms and distributing my modified version, which would be... a gigantic pain. I don't actually need to fork PowerShell for this specific change, because I could *install* a single DLL to expose the same function, and \"link\" 99% of my bindings inside my Rust program. However, I would be unable to distribute a simple Rust library that you can import to start using PowerShell, because everybody would have to install the same DLL with a 2-line function in it.\r\n\r\nIt may not seem like a big deal, but it is, as it causes significant friction and doesn't enable easy \"PowerShell as a library\" functionality. Languages like Rust or Go produce self-contained executables with everything statically linked, requiring just one additional file to be separately distributed will be major pain point for anybody interesting in using it.\r\n\r\nTo summarize, here are the important points to consider:\r\n\r\n- If we should delay the current PR for the lack of testability, we should discuss that in priority. I would rather not delay it, but if that's what it takes, let's make it happen sooner than later.\r\n- While I am open to making an official, richer set of APIs in a PowerShell C SDK, it should *not* be mutually exclusive with the current changes enabling third-party SDKs not officially supported by the PowerShell team.\r\n",
      "created_at": "2021-04-07T23:51:13Z",
      "updated_at": "2021-04-08T00:06:20Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> As for testing, we don't need to have a native host for testing this, instead, we can leverage the function pointer feature in C# 9, to call this method from C# with an `unmanaged` function pointer.\r\n\r\nAnd what exactly is this code testing? Only that this method is present as public.",
      "created_at": "2021-04-13T06:29:41Z",
      "updated_at": "2021-04-13T06:29:41Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> And what exactly is this code testing? Only that this method is present as public.\r\n\r\nNot sure what you mean. The `LoadTest` shows the `LoadAssemblyFromMemory` method does what it is supposed to do -- load the assembly using in-memory (native memory) data.\r\n\r\nDue to the `UnmanagedCallersOnly` attribute, `LoadAssemblyFromMemory` cannot be called directly in C#, and the `unmanaged` function pointer is the only way to call it in C# as far as I know.",
      "created_at": "2021-04-13T06:43:25Z",
      "updated_at": "2021-04-13T06:51:53Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Not sure what you mean. The `LoadTest` shows the `LoadAssemblyFromMemory` method does what it is supposed to do -- load the assembly using in-memory (native memory) data.\r\n\r\nI mean it is _obvious_ test. We have no need to test LoadFromStream() method since it was tested in .Net repo.\r\nAny useful test would have to confirm that an action (call a cmdlet and get a result) works from a native host.",
      "created_at": "2021-04-13T08:17:49Z",
      "updated_at": "2021-04-13T08:17:49Z"
    },
    {
      "author": "awakecoding",
      "author_association": "CONTRIBUTOR",
      "body": "> > Not sure what you mean. The `LoadTest` shows the `LoadAssemblyFromMemory` method does what it is supposed to do -- load the assembly using in-memory (native memory) data.\r\n> \r\n> I mean it is _obvious_ test. We have no need to test LoadFromStream() method since it was tested in .Net repo.\r\n> Any useful test would have to confirm that an action (call a cmdlet and get a result) works from a native host.\r\n\r\nNot if you consider what `LoadAssemblyFromMemory` is supposed to provide: in-memory assembly loading from an unmanaged caller. This is very clever, I thought that since we used `[UnmanagedCallersOnly]` there was no way to write the test code in C#, but it turns out we can! While it does not test the ability to make a fully unmanaged PowerShell host, it does ensure that the only helper function we export to facilitate making one will not break.\r\n\r\nTo me this fits the bill for testing the new API, and it should be enough. We can always revisit more advanced testing in the future as development progresses for the complex SDKs leveraging LoadAssemblyFromMemory, but at a later time.",
      "created_at": "2021-04-13T12:56:18Z",
      "updated_at": "2021-04-13T12:56:18Z"
    },
    {
      "author": "awakecoding",
      "author_association": "CONTRIBUTOR",
      "body": "@daxian-dbw did you intend to make a cleaned up version of your test code for inclusion in the current pull request? While the quick and dirty test looks sufficient, I'm quite sure it can't be merged as-is, and I guess it would be subject to a couple more iterations before being considered good to go, further delaying the current pull request.\r\n\r\n@iSazonov @SteveL-MSFT there are now two reviewers who approved the current pull request, but there are 3 failing checks in the CI that (again) appear unrelated to the current changes. I don't think external contributors like me have the power to manually trigger a rebuild until the checks magically pass? There seems to be a few issues in the CI causing intermittent failures, so I guess you are used to retriggering them until it works.\r\n\r\nWe're in the final sprint, let's get to the finish line :)",
      "created_at": "2021-04-13T14:00:23Z",
      "updated_at": "2021-04-13T14:00:23Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@awakecoding I will clean up the example code and push a commit with a test. We will see how the CI goes.",
      "created_at": "2021-04-13T16:57:40Z",
      "updated_at": "2021-04-13T16:57:40Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Not if you consider what `LoadAssemblyFromMemory` is supposed to provide: in-memory assembly loading from an unmanaged caller.\r\n\r\n.Net Runtime repo is right place for the test, not PowerShell. And again, only problem, which would be with the API, is marshalling a buffer with managed dll but the test does not any marshalling \"native to managed\".",
      "created_at": "2021-04-13T17:02:58Z",
      "updated_at": "2021-04-13T17:02:58Z"
    },
    {
      "author": "awakecoding",
      "author_association": "CONTRIBUTOR",
      "body": "> > Not if you consider what `LoadAssemblyFromMemory` is supposed to provide: in-memory assembly loading from an unmanaged caller.\r\n> \r\n> .Net Runtime repo is right place for the test, not PowerShell. And again, only problem, which would be with the API, is marshalling a buffer with managed dll but the test does not any marshalling \"native to managed\".\r\n\r\n@iSazonov it's either the suggested test from @daxian-dbw or it's no test at all for the current pull request to be honest. Anything beyond that would takes months of back and forth, without taking into account the work to make a proper native SDK to test against. I'm actually glad we can have *some* basic testing for the simple API we're adding.",
      "created_at": "2021-04-13T18:48:20Z",
      "updated_at": "2021-04-13T18:48:20Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "A basic test was added and the method was renamed to `LoadAssemblyFromNativeMemory`. And all CIs passed. Now the committee can review again.",
      "created_at": "2021-04-13T21:51:41Z",
      "updated_at": "2021-04-13T21:51:41Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "A number of folks are out this week, so PS-Committee will review this next week.  This change wouldn't make it in time for our next preview coming out this month anyways, but should make it into one for May.",
      "created_at": "2021-04-13T23:16:32Z",
      "updated_at": "2021-04-13T23:16:32Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee reviewed this, we would be fine with advertising this API as an ExperimentalFeature to allow community experimentation to get more feedback if this is the direction we want to keep in the long term or not.  We would also ask that if the ExperimentalFeature is not enabled, then this API should throw a NotImplementedException.",
      "created_at": "2021-04-21T22:23:53Z",
      "updated_at": "2021-04-21T22:23:53Z"
    },
    {
      "author": "awakecoding",
      "author_association": "CONTRIBUTOR",
      "body": "> @PowerShell/powershell-committee reviewed this, we would be fine with advertising this API as an ExperimentalFeature to allow community experimentation to get more feedback if this is the direction we want to keep in the long term or not. We would also ask that if the ExperimentalFeature is not enabled, then this API should throw a NotImplementedException.\r\n\r\nSteve, this would add yet another serious obstacle on top of the rest: native PowerShell hosts won't be able to use the new API without calling Enable-ExperimentalFeature, and since we need this new API to load PowerShell, the most straightforward way would be to call pwsh.exe with an encoded command on every startup of the PowerShell host program just so it can work.\r\n\r\nThis is not the only problem: how exactly do you intend to throw NotImplementedException from an [UnmanagedCallersOnly] function that currently returns void? C# exceptions don't cross over nicely to the unsafe world, it would need to be mapped to an error code, meaning LoadAssemblyFromMemory has to be modified to return an int + we need to define values for error codes.",
      "created_at": "2021-04-21T23:56:35Z",
      "updated_at": "2021-04-21T23:56:35Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@awakecoding you can use `pwsh -settings myconfig.json` which has whatever ExperimentalFeatures you want enabled along with any other configuration you want set.  Can `LoadAssemblyFromMemory` return a bool to indicate success/failure?  @daxian-dbw do you have a suggestion on this?",
      "created_at": "2021-04-22T00:53:40Z",
      "updated_at": "2021-04-22T00:53:40Z"
    },
    {
      "author": "awakecoding",
      "author_association": "CONTRIBUTOR",
      "body": "> @awakecoding you can use `pwsh -settings myconfig.json` which has whatever ExperimentalFeatures you want enabled along with any other configuration you want set. Can `LoadAssemblyFromMemory` return a bool to indicate success/failure? @daxian-dbw do you have a suggestion on this?\r\n\r\nA bool is not enough, because then we have no way to tell the difference between failure to load because of bad parameters or data, and failure to load because the experimental feature was disabled. you need an int with a list of error codes for this.\r\n\r\nAs for pwsh.exe -settings <mycustomsettings.json> it does make it less bad, but now I need to generate and write a file to the disk. The only difference is it likely won't be flagged as malicious as opposed to writing a temporary DLL to the disk.",
      "created_at": "2021-04-22T01:01:38Z",
      "updated_at": "2021-04-22T01:01:38Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I do not understand why this (adding Experimental feature) is needed if the new API does not change the current behavior in any way.",
      "created_at": "2021-04-22T05:24:27Z",
      "updated_at": "2021-04-22T05:24:27Z"
    },
    {
      "author": "AraHaan",
      "author_association": "NONE",
      "body": "I feel like changing it just to enable an experimental feature is asking too much, or perhaps it can itself check if enabled in an input json file (the function then has the param for it as a string to the full absolute path to the file that would have to be extended from the relative path), then have it load the json using System.Text.Json and check if it's enabled and if not return ``-1`` (not enabled), and if failure from anything else return any other error codes > 0.\r\n\r\nAlso I think the error codes could be exposed actually through an public enum, it would be safer that way so they are then fixed and I do not know of any programming languages that does not support enums \ud83d\ude02.",
      "created_at": "2021-04-22T05:56:18Z",
      "updated_at": "2021-04-22T05:57:02Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "The purpose of making it an `Experimental Feature` is to advertise that the @PowerShell/powershell-committee wants to have this available for the community to experiment, but it appears that .NET is open to providing this capability in the future and is probably the right place for this API and not PowerShell.  So we don't want to support an API that may become obsolete in the future.  Based on community feedback, we may decide to keep the API and remove it as `Experimental`, but that is something that is decided closer to RC after we have some data.",
      "created_at": "2021-04-22T14:31:17Z",
      "updated_at": "2021-04-22T14:31:59Z"
    },
    {
      "author": "awakecoding",
      "author_association": "CONTRIBUTOR",
      "body": "> The purpose of making it an `Experimental Feature` is to advertise that the @PowerShell/powershell-committee wants to have this available for the community to experiment, but it appears that .NET is open to providing this capability in the future and is probably the right place for this API and not PowerShell. So we don't want to support an API that may become obsolete in the future. Based on community feedback, we may decide to keep the API and remove it as `Experimental`, but that is something that is decided closer to RC after we have some data.\r\n\r\nI think we all understand the value of experimental features, but here all you really need to do is declare this API as such, not block it through a feature flag. We don't even need to throw an exception, just the presence or absence of the function is sufficient, so you can remove it in the future if the committee decides to remove it. This function is meant to be dynamically loaded, so it would fail at runtime correctly if the function is not found.\r\n\r\nChanging the function prototype to return an int instead of void and defining error codes is not a bad thing, it just makes this new function future proof with correct error handling, so I am not against it. If we do it, it can't be bool because it would make it subject to change in the future as we need to find out more than \"success/failure\".\r\n\r\nAfter all this discussion and back and forth, is it really worth it to make it even harder to use? While I am glad that there has been some movement in this area recently, I can't help but point out how excruciating the entire process has been. Please don't make PowerShell native hosts dead-on-arrival because of yet-another-obstacle preventing its adoption?",
      "created_at": "2021-04-22T15:05:32Z",
      "updated_at": "2021-04-22T15:05:32Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@awakecoding after some additional discussion, we're ok with not having the API fail if the ExperimentalFeature is not enabled.  This way, the ExperimentalFeature is still a notice that this API may change or may be removed in the future, but will make it easier to leverage so we can get some feedback.",
      "created_at": "2021-04-22T17:30:17Z",
      "updated_at": "2021-04-22T17:30:17Z"
    },
    {
      "author": "AraHaan",
      "author_association": "NONE",
      "body": "I agree the flag could be used to silence the message saying it's experimental, but other than that have it send usage data on it so you guys know it's value and how it's used.",
      "created_at": "2021-04-22T18:18:56Z",
      "updated_at": "2021-04-22T18:19:11Z"
    },
    {
      "author": "awakecoding",
      "author_association": "CONTRIBUTOR",
      "body": "I am fine if you can add the required code to see if the experimental feature is used in practice, without throwing an exception or requiring that it be explicitly enabled prior to use. That sounds like an acceptable compromise.",
      "created_at": "2021-04-22T18:23:03Z",
      "updated_at": "2021-04-22T18:23:03Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@awakecoding Given that we are going to just advertise the API as experimental without really blocking it when the experimental feature is disabled, do you still think it's not sufficient to just return 0/1 to indicate the loading success/failure?\r\n\r\nAsking this API to pass along the reason for a loading failure is nice to have, but seems an overkill to me. When this API fails, it could fail in many potential ways, e.g. possible internal failures in `UnmanagedMemoryStream` when wrapping the native memory; possible failure when reading from the `UnmanagedMemoryStream`; possible failures like \"BadImage\" thrown from `LoadFromStream`, and etc. If you want the failure reason to be passed along accurately, then you will need to understand all possible exceptions that could be thrown in such a scenario, which I don't think is straightforward or obvious to find out, and then map them to a list of error codes.\r\n\r\nThis API is more like a hack to light up something that is currently missing in .NET, rather than a permanent thing that will be maintained in PowerShell -- we will deprecate it when this functionality appears in .NET. So I would prefer to just make it simple.",
      "created_at": "2021-04-22T21:16:44Z",
      "updated_at": "2021-04-22T21:16:44Z"
    },
    {
      "author": "awakecoding",
      "author_association": "CONTRIBUTOR",
      "body": "@daxian-dbw let's go with a bool, I think we're fine with an undefined failure. We just have to stick with bool if we go with bool, because changing it to an int later on would break the ABI. I agree, let's just keep it simple, a bool it is.",
      "created_at": "2021-04-22T21:19:52Z",
      "updated_at": "2021-04-22T21:19:52Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "We can still make it a `int` return type, but only return `0` for success and `1` for failure. So, even if we have to improve it for some reason in future to return from a list of error codes, it won't break the ABI.\r\n\r\nIf this sounds fine to you, can you please update the code accordingly?",
      "created_at": "2021-04-22T21:25:19Z",
      "updated_at": "2021-04-22T21:43:04Z"
    },
    {
      "author": "awakecoding",
      "author_association": "CONTRIBUTOR",
      "body": "> We can still make it a `int` return type, but only return `0` for success and `1` for failure. So, even if we have to improve it for some reason in future to return a list of error codes, it won't break the ABI.\r\n> \r\n> If this sounds fine to you, can you please update the code accordingly?\r\n\r\nThat's even better, my primary concern was ABI stability just because of the return type, if you make it an int with a known success/failure return value (without necessarily defining error codes and an enum) that would be absolutely perfect!",
      "created_at": "2021-04-22T21:29:30Z",
      "updated_at": "2021-04-22T21:29:30Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "I believe we still need to declare an experimental feature name in [this list](https://github.com/PowerShell/PowerShell/blob/master/src/System.Management.Automation/engine/ExperimentalFeature/ExperimentalFeature.cs#L102), even though we won't really use it for anything. @SteveL-MSFT, any suggestion on the feature name?",
      "created_at": "2021-04-24T06:38:34Z",
      "updated_at": "2021-04-24T06:38:34Z"
    },
    {
      "author": "TravisEz13",
      "author_association": "MEMBER",
      "body": "Security working group:\r\nthere should be non-repudiation logging, which should include:\r\n\r\n- The user\r\n- the process\r\n- a size and hash or the assembly (or something else to identify the assembly)\r\n\r\nOnce we have code for the logging, the security working group should review the PR\r\n\r\nThis can be a separate PR",
      "created_at": "2021-04-26T20:58:23Z",
      "updated_at": "2021-04-26T20:58:23Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "I chose the name `PSLoadAssemblyFromNativeCode` for the experimental feature. @SteveL-MSFT Please let me know if you have a concern.",
      "created_at": "2021-04-26T22:06:57Z",
      "updated_at": "2021-04-26T22:06:57Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "A new test has been failing consistently in mac CIs for this PR:\r\n```\r\n    [-] native command should be killed when pipeline is disposed 94ms\r\n      Expected 0, but got 1.\r\n      50:         (Get-Process 'yes' -ErrorAction Ignore).Count | Should -Be $yes\r\n      at <ScriptBlock>, /Users/runner/work/1/s/test/powershell/Language/Scripting/NativeExecution/NativeCommandProcessor.Tests.ps1: line 50\r\n```\r\nFurther investigation is needed. /cc @SteveL-MSFT ",
      "created_at": "2021-04-28T06:17:18Z",
      "updated_at": "2021-04-28T06:17:40Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "The name of the ExperimentalFeature seems fine.  I checked out this branch and it doesn't have that test case that's failing which is quite strange as CI is running it?  I rebased to pick up the code changes related to that test change.",
      "created_at": "2021-04-28T16:58:33Z",
      "updated_at": "2021-04-28T16:58:33Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@awakecoding Congratulations! \ud83d\ude04 ",
      "created_at": "2021-04-29T02:45:27Z",
      "updated_at": "2021-04-29T02:45:27Z"
    },
    {
      "author": "awakecoding",
      "author_association": "CONTRIBUTOR",
      "body": "> @awakecoding Congratulations! \ud83d\ude04\r\n\r\nWoohoo! Now we can start looking for the next steps, I think there were mentions of many new tickets related to this one?",
      "created_at": "2021-04-29T13:05:26Z",
      "updated_at": "2021-04-29T13:05:26Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": ":tada:`v7.2.0-preview.6` has been released which incorporates this pull request.:tada:\n\nHandy links:\n* [Release Notes](https://github.com/PowerShell/PowerShell/releases/tag/v7.2.0-preview.6)\n",
      "created_at": "2021-05-27T17:32:26Z",
      "updated_at": "2021-05-27T17:32:26Z"
    }
  ],
  "created_at": "2021-01-22T21:47:47Z",
  "number": 14652,
  "state": "closed",
  "title": "Add `LoadAssemblyFromNativeMemory` function to load assemblies in memory from a native PowerShell host",
  "updated_at": "2021-09-15T18:35:34Z"
}