{
  "_url": "https://github.com/PowerShell/PowerShell/issues/16869",
  "author": "Molochnikov",
  "body": "### Summary of the new feature / enhancement\r\n\r\nWhy the hell in 2022 to create function in parent scope i need to do this:\r\n```\r\n function b() {\r\n    function a() {\r\n        function d() {\r\n            $f = (new-item -path (\"function:test\") -value {Write-Host Hello!});\r\n            $context = $host.runspace.gettype().getmethod(\"get_ExecutionContext\",([System.Reflection.BindingFlags]::NonPublic -bor [System.Reflection.BindingFlags]::Instance)).Invoke($host.runspace,$null)\r\n            $ss = $context.gettype().getmethod(\"get_EngineSessionState\",([System.Reflection.BindingFlags]::NonPublic -bor [System.Reflection.BindingFlags]::Instance)).Invoke($context,$null)\r\n            $scope = $ss.gettype().getmethods(([System.Reflection.BindingFlags]::NonPublic -bor [System.Reflection.BindingFlags]::Instance)) | Where-Object {$_.name -eq \"GetScopeByID\"} | ForEach-Object {try {$_.Invoke($ss,1)} catch {}}\r\n            $funct = $scope.gettype().getmethod(\"get_FunctionTable\",([System.Reflection.BindingFlags]::NonPublic -bor [System.Reflection.BindingFlags]::Instance)).Invoke($scope,$null)\r\n            $Funct.Add('SayHello', $f)\r\n        }\r\n        d\r\n        SayHello #good\r\n    }\r\n    a\r\n    SayHello #error\r\n }\r\n b\r\n SayHello #error\r\n```\r\n\r\nI see that you like variables much more than functions:\r\n`Set-Variable -Name canCreateVariableInParentScope -Value $true -Scope 1`\r\n\r\nI'm serious. You all racists...\r\n\r\nPlease add that fuckin `New-Set-Get-Function` commands with `-Scope` parameter!\r\n\r\n\r\n### Proposed technical implementation details (optional)\r\n\r\n_No response_",
  "closed_at": "2022-02-14T16:05:25Z",
  "comments": [
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "@Molochnikov  \r\n1. More respectful language is expected here. \r\n2. This may give you the clue you seem to be missing. \r\n```\r\nfunction foo {\r\n  write-host \"creating bar\" \r\n  function global:bar {\"I'm Global\"}\r\n}\r\n\r\n> bar\r\nbar : The term 'bar' is not recognized as the name of a cmdlet...\r\n\r\n> foo\r\ncreating bar\r\n\r\n> bar\r\nI'm Global\r\n```\r\n3.  A quick test showed this works for the script: scope but not for numbered scopes.  For this you pass the script block to run as a variable and run it with the call operator \r\n```\r\nfunction foo2 {\r\n  write-host \"creating sb\" \r\n  Set-Variable -name sb -Scope 1 -value {\r\n     param($what) \r\n    \"I'm in $what\"\r\n  }\r\n}\r\nfunction wibble {\r\n  foo2\r\n  & $sb -what \"wibble\" \r\n}\r\n```\r\n4. As an alternative a function which calls another an wants it to set things in its scope can DOT source the function it calls\r\n```\r\nfunction foo3 {\r\n  function barbar {\r\n    param ($What) \r\n    \"What scope\"\r\n  }\r\n}\r\n\r\nfunction fuz {\r\n  . foo3 \r\n  barbar\r\n}\r\n\r\n> fuz\r\nWhat scope\r\n```\r\n5. Changing the variables in the parent scope is considered \"Bad but occasionally necessary\".  Values inherit - what applies in a parent scope applies in a child scope - parameters are passed by reference so changing a member of passed variable or an inherited variable  changes that member everywhere, but assigning a value to a variable name creates a new variable  in the current scope (so setting the value of a number or a string won't pass upwards). \r\n```\r\n\r\n function eckie {\r\n$a.x = \"99\"\r\n$b =  @{x=\"99\";\"y\"=100}\r\n}\r\n\r\n> $a = @{x=1;y=2} ;$b = @{x=1;y=2}\r\n> $a,$b\r\n\r\nName                           Value                                                                                                                                                              \r\n----                           -----                                                                                                                                                              \r\ny                              2                                                                                                                                                                  \r\nx                              1                                                                                                                                                                  \r\ny                              2                                                                                                                                                                  \r\nx                              1                                                                                                                                                                  \r\n\r\n> eckie\r\n\r\n> $a,$b\r\n\r\nName                           Value                                                                                                                                                              \r\n----                           -----                                                                                                                                                              \r\ny                              2                                                                                                                                                                  \r\nx                              99             \r\ny                              2                                                                                                                                                                  \r\nx                              1            \r\n ##### The child scope changed A but created a new B \r\n```\r\n\r\n6. Only rarely does a _variable_ need to be set in a parent scope instead of returned by a function and it's seen as a bad smell.   Do you have a real-world use for doing this with functions., instead of dot sourcing or handing back a script block obviously  `name -param` is slightly neater than `& $name -param`  but from a good coding practice point of view making it super clear that something being executed was the result of executing something else does seem better \r\n\r\n\r\n",
      "created_at": "2022-02-11T09:52:44Z",
      "updated_at": "2022-02-11T09:52:44Z"
    },
    {
      "author": "Molochnikov",
      "author_association": "NONE",
      "body": "My statement is: There is no standart way to operate functions in **parent** scopes **from child** scope. Documentation **about_Scopes** states that:\r\n\r\n> You can declare variables, aliases, **functions**, and PowerShell drives in a scope **outside** of the **current** scope.\r\n\r\nThere is no excuses to do it for variables without doing the same for functions.",
      "created_at": "2022-02-11T11:47:48Z",
      "updated_at": "2022-02-11T12:00:01Z"
    },
    {
      "author": "Molochnikov",
      "author_association": "NONE",
      "body": "One practical application will be pushing closures to the parent scope in functional programming:\r\n\r\n ```\r\n       function closure($name) {\r\n            $v = 'some variable';\r\n            $f = (new-item -path (\"function:\" + $name) -value {return $v}.GetNewClosure());\r\n            $context = $host.runspace.gettype().getmethod(\"get_ExecutionContext\",([System.Reflection.BindingFlags]::NonPublic -bor [System.Reflection.BindingFlags]::Instance)).Invoke($host.runspace,$null)\r\n            $ss = $context.gettype().getmethod(\"get_EngineSessionState\",([System.Reflection.BindingFlags]::NonPublic -bor [System.Reflection.BindingFlags]::Instance)).Invoke($context,$null)\r\n            $scope = $ss.gettype().getmethods(([System.Reflection.BindingFlags]::NonPublic -bor [System.Reflection.BindingFlags]::Instance)) | Where-Object {$_.name -eq \"GetScopeByID\"} | ForEach-Object {try {$_.Invoke($ss,1)} catch {}}\r\n            $funct = $scope.gettype().getmethod(\"get_FunctionTable\",([System.Reflection.BindingFlags]::NonPublic -bor [System.Reflection.BindingFlags]::Instance)).Invoke($scope,$null)\r\n            $Funct.Add($name, $f)\r\n        }\r\n\r\n        closure 'test'\r\n        test\r\n\r\n```",
      "created_at": "2022-02-11T12:27:27Z",
      "updated_at": "2022-02-11T12:31:44Z"
    },
    {
      "author": "237dmitry",
      "author_association": "NONE",
      "body": "> One practical application will be pushing closures\r\n\r\nFunctions can be anonymous.\r\n```powershell\r\nfunction closure\r\n{\r\n    param ([string] $n)\r\n    return ({ param ([string] $m) return $n + $m }.GetNewClosure())\r\n}                              \r\n$a = closure 'test + '         \r\n$a.Invoke('one more test')\r\n& $a 'the second test' \r\n```",
      "created_at": "2022-02-11T13:31:59Z",
      "updated_at": "2022-02-11T13:31:59Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "That text does not appear in the 7.2.1 help. \r\n\r\nFunctions in an ancestor scope can be called from any level of descendant \r\nAny scope can define or redefine a function in the global scope\r\nYou are complaining about a \"worst practice\" being blocked - that if Scope X defines a function then descendant scope Y cannot change that function's behaviour when called later from X \r\n\r\n@237dmitry  has just what I was going to post posted what I was going to with one change which I should have remembered when I gave example `#3` in the first post.  When passed about function can be anonymous but they don't need to be.  \r\n\r\n```\r\nfunction closure {\r\n    param ([string] $n)\r\n    return ({ param ([string] $m) return $n + $m }.GetNewClosure())\r\n}                              \r\n\r\n$function:Test =  closure 'test + ' \r\nTest \"blah blah\"\r\n``` \r\n\r\nA function should not use variables in another scope as its parameters or for its results. ",
      "created_at": "2022-02-11T13:49:19Z",
      "updated_at": "2022-02-11T13:49:19Z"
    },
    {
      "author": "Molochnikov",
      "author_association": "NONE",
      "body": "https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_scopes?view=powershell-7.3\r\n\r\n> You can declare variables, aliases, functions, and PowerShell drives in a scope outside of the current scope.\r\n\r\n> You are complaining about a \"worst practice\" being blocked - that if Scope X defines a function then descendant scope Y cannot change that function's behaviour when called later from X\r\n\r\nIt may be \"worst practice\" case, but it is a case. Reflection is a bad practice too. Very few programmers using Reflection.Emit, but dotNet library contains it.\r\n\r\nFor functional/symbolic programming it is a case. If you can break things by changing outer scope variables why you cannot break things by changing outer scopes functions, aliases, drives? What bad in creating function in outer scope (and only upper 1,2,3... scopes) if outer scope will never contains a code that calls it?\r\n\r\n<blockquote><img src=\"https://docs.microsoft.com/media/logos/logo-powershell-social.png\" width=\"48\" align=\"right\"><div><strong><a href=\"https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_scopes\">about Scopes - PowerShell</a></strong></div><div>Explains the concept of scope in PowerShell and shows how to set and change the scope of elements.</div></blockquote>",
      "created_at": "2022-02-11T14:43:30Z",
      "updated_at": "2022-02-11T14:56:53Z"
    },
    {
      "author": "Molochnikov",
      "author_association": "NONE",
      "body": "What if i don't know which functions child scope will change?\r\n\r\nCompare the code:\r\n```\r\nfunction closure1 {\r\n    param ([string] $n)\r\n    function closure2 {\r\n        param ([string] $n)\r\n        function closure3 {\r\n            param ([string] $n)\r\n            return ({ param ([string] $m) return $n + 1 }.GetNewClosure())\r\n        }\r\n        $function:Test =  closure3 'test + '\r\n        Test \"blah blah\"\r\n        return @(({ param ([string] $m) return $n + 2 }.GetNewClosure()),$function:Test)\r\n    }\r\n    $res = closure2 'test + '\r\n    $function:Test =  $res[1]\r\n    $function:Test2 = $res[0]\r\n    Test \"blah blah\"\r\n    Test2 \"blah blah\"\r\n    return @(({ param ([string] $m) return $n + 3 }.GetNewClosure()), $function:Test, $function:Test2)\r\n}                              \r\n\r\n...\r\n\r\n\r\nfunction closure1 {\r\n    param ([string] $n)\r\n    function closure2 {\r\n        param ([string] $n)\r\n        function closure3 {\r\n            param ([string] $n)\r\n            set-function -scope 2 -name Test -value ({ param ([string] $m) return $n + 1 }.GetNewClosure())\r\n        }\r\n        Test \"blah blah\"\r\n        Test13424 \r\n        Test \"blah blah\"\r\n        Test322\r\n        set-function -scope 1 -name Test2 -value ({ param ([string] $m) return $n + 2 }.GetNewClosure())\r\n    }\r\n    Test \"blah blah\"\r\n    Test2 \"blah blah\"\r\n   Test3473842\r\nTest3473843\r\nTest3473844\r\n    return ({ param ([string] $m) return $n + 3 }.GetNewClosure())\r\n}\r\n\r\n...\r\n```",
      "created_at": "2022-02-11T15:17:45Z",
      "updated_at": "2022-02-11T15:38:29Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "Back when I was doing my Computer Science degree (which, BTW did involve some functional programming), if I had turned in an assignment that looked like either of those it would have got a D or D- (assuming it worked).  I don't think it is working as intended because \r\n```\r\n Test \"blah blah\"\r\n  return @(({ param ([string] $m) return $n + 2 }.GetNewClosure()),$function:Test)\r\n```\r\nreturns 3 things and the part which calls closure2 is expecting two closures as the first and second assuming you wanted the whole that result its easier to write\r\n```\r\nfunction closure3 {\r\n    param ([string] $n)\r\n    {param ([string] $m) $n + 1 }.GetNewClosure()\r\n}\r\nfunction closure2 {\r\n    param ([string] $n)\r\n    Test \"Ignored Param from C2\"\r\n    {param ([string] $m) $n + 2 }.GetNewClosure() \r\n} \r\n$var                    = 'test + '\r\n$function:Test          =  closure3 $var\r\n$c2Out, $function:Test2 =  closure2 $var\r\n$c2out \r\nTest  \"Ignored\"\r\nTest2 \"ignored2\"\r\n````\r\nI.e. if you want the result of closure 3 inside and outside closure 2, define it and call it outside closure 2.  Instead of defining things at the highest scope they will be needed and letting them inherit down, you're trying to define them in the scope that where will call them first and then force them up to where they will be needed later. In the version above the call to run `Test \"ignored\"` can be moved before `closeure2` is invoked. In your version to changing the sequence means changing the structure.\r\n\r\nI'd love to see a real world case where anyone actually wants to write anything like your example. \r\n",
      "created_at": "2022-02-11T16:45:54Z",
      "updated_at": "2022-02-11T16:45:54Z"
    },
    {
      "author": "Molochnikov",
      "author_association": "NONE",
      "body": "Just want to post it here:\r\n#### New developing simplifyed languages:\r\n\r\n> Hello, can you add base feature in your language to work with functions? Your docs saying that your language can do it.\r\n\r\nWow, we don't have this base feature! Yes, of course, will be on the next release!\r\n\r\n#### Dying overburdened languages with millions ways to do the same thing but don't have a base feature:\r\n\r\nWho are you? What you do here? What you want? Why you want this? I don't use it. Im professional. Docs are true. It is not the base feature. Get out of here!",
      "created_at": "2022-02-14T11:54:27Z",
      "updated_at": "2022-02-14T11:55:50Z"
    },
    {
      "author": "Molochnikov",
      "author_association": "NONE",
      "body": "Its funny that you can declare/change function in **global** scope from any scope, but cannot do it for **parent** scope from **child scope.** For me **thats is the REAL bad practice**. Not theoretical imaginary bad practice.",
      "created_at": "2022-02-14T12:29:00Z",
      "updated_at": "2022-02-14T12:47:09Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "@Molochnikov  \r\n\r\nin the real world.... \r\n\r\nWhen a feature is missing and a significant number of people want it, or an argument is made to the people who would need to work on it that they would want it if were there, then that feature **gets  the chance to compete for the limited resources available for its implementation**.   There are standard reasons given to say no. \"No-one wants it.\", \"People want it, but it goes against some principle\", \"The resource required isn't justified\",  \r\n\r\nWhen someone turns up demanding something which no-one else has ever asked for, using the \"F word\" and calling people racist (seriously, what ? )  most people won't give it any time.  And your response to explanations doesn't encourage people to support you. \r\n\r\nI'm not going to propose _function_ equivalents of the _variable_ commands in the cmdlet working group. The TLDR version is ** it's not new , not good and not wanted .** \r\n1. The premise that things can be done with variables but not functions is simply wrong. Function are specialized variables holding script blocks.  You can run a script block from a normal variable with the call operator `&`  or put one into a `$function:variable`, instead of using the `function` keyword.  Your proposal is \"different syntax for existing functionality\". \r\n2. Your latest contention that setting things in Global scope is worse than setting in a parent scope is also wrong. From a strict computer science point of view, even the inheritance we have is bad - values _should_ pass into function as parameters and out as return values. In reality things like the path, the machine name, CurrentProcessID, or working directory are variables which apply globally access to them is simplest via variables   `Connect-ToService` functions might use \"ServiceConnection\" as a well known name for something applicable to code it can't know about so that _is_ naturally global. Global variables are only bad when used for things which are not global in nature.  There are cases like the `WarningVariable` parameter where a parameter specifies a location to put something which isn't to be returned as a result, but when code in a child scope _takes it upon itself to change anything_ in a scope which called that's bad code.  If doing a search and replace for a variable name changes the effect of calling something - that's bad code - hence my comments on getting a low grade for code which does just that.  All this means that  although `Set-Variable` can be abused it is _necessary_, but anything which works in a similar way needs to show it is necessary and can't realistically be done any other way:  this does not. \r\n3. Demand? This is the first request and has 2 down votes and zero up votes. I'm sure it would save you time, but the total time you would save may never repay the time taken to add the feature. \r\n\r\nIf you persuade me (or someone else) that is good and/or widely wanted you might make some progress. But you're not winning people over. \r\n\r\nIf you want to contrast mature and immature languages; Immature ones tend to go \"Ooh something new let's do it\".  And that contributes to many of them not making it to maturity. Mature ones go \"We've seen it, solved it like this, that was good enough for the the one person who cared then, isn't that good enough for you?\". \r\n\r\n ",
      "created_at": "2022-02-14T15:56:58Z",
      "updated_at": "2022-02-14T15:56:58Z"
    }
  ],
  "created_at": "2022-02-11T08:08:38Z",
  "labels": [
    "Issue-Enhancement",
    "WG-Cmdlets",
    "Needs-Triage"
  ],
  "number": 16869,
  "state": "closed",
  "title": "New-Function Set-Function Get-Function",
  "updated_at": "2022-02-14T16:05:25Z"
}