{
  "_url": "https://github.com/PowerShell/PowerShell/issues/6817",
  "author": "mklement0",
  "body": "In the world of _assignments_,  _compound statements_ (loops and conditionals) can be used as value-returning _expressions_ too:\r\n\r\n```powershell\r\n$str = 'hi'  # simple expression\r\n$flag = if ($str -eq 'hi') { 1 } else { 0 }  # flow-control statement works too; returns 1\r\n```\r\n\r\nBy contrast, in the context of a _pipeline_ or as _sub-expressions_, flow-control statements do _not_ work as-is:\r\n\r\n```powershell\r\n# Simple expressions: OK as the 1st pipeline segment / with redirections.\r\n'hi' > out.txt\r\n'hi' | Out-File out.txt\r\n\r\n# Flow-control expressions: do NOT work (directly) as the 1st pipeline segment.\r\n# What follows the flow-control expression is treated as a *new statement* (and these \r\n# cause a syntax error here):\r\nif ($str -eq 'hi') { 1 } else { 0 } > out.txt\r\nif ($str -eq 'hi') { 1 } else { 0 } | Out-File out.txt\r\n\r\n# Similarly, trying to use a flow-control statement as a *sub-expression* \r\n# (part of a larger expression), fails:\r\n(foreach ($i in 1..3) { $i }) -join ', '   # !! Only works with $(...), not just (...)\r\n```\r\n\r\nYou can work around this:\r\n* for use in the pipeline: by enclosing the flow-control statement either in `& { ... }` / `. { ... }` for _streaming_ output.\r\n* for use in expressions: by enclosing the flow-control statement in `$(...)` or `@(...)`, which collects all output up front.\r\n\r\nHowever, the need for that is not obvious, and it is somewhat cumbersome, and in the case of sub-expressions carries a performance penalty.\r\n\r\nThere may be parsing challenges and ambiguities I'm not considering, but perhaps compound statements can be treated the same as simple expressions in these contexts, allowing their direct use as the first pipeline segment / redirection source.\r\n\r\nIn other words: **If compound statements were bona fide _expressions_, the above problems would go away** (though streaming behavior should be retained when used as the 1st pipeline segment).\r\n\r\nP.S.: \r\n  * Is there a better or more established term for _compound statements_?\r\n  * This issue was inspired by [this SO question](https://stackoverflow.com/q/50156064/45375).\r\n\r\nEnvironment data\r\n----------------\r\n\r\nWritten as of:\r\n\r\n```powershell\r\nPowerShell Core v6.0.2\r\n```\r\n",
  "closed_at": "2019-12-27T12:20:21Z",
  "comments": [
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "This kind of begs the question of why can't we use these anywhere in the pipeline directly? It would effectively remove the need for things like `Where-Object` entirely.",
      "created_at": "2018-05-04T14:09:40Z",
      "updated_at": "2018-05-04T14:09:40Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@vexx32:\r\n\r\nIt makes sense to limit use of expressions to the _first_ pipeline segment, because while expressions create _output_, they are not prepared to handle _pipeline input_. \r\nIn other words: they can _start_ a pipeline, but don't fit in the middle or at the end of pipeline.\r\n\r\nIn the world of expressions you already have `ForEach-Object` and `Where-Object` analogs: the `.ForEach()` and `.Where()`  collection \"operators\" (methods); e.g.:\r\n\r\n```powershell\r\nPS> (1..3).ForEach({ $_ + 1 })\r\n2\r\n3\r\n4\r\n```\r\n\r\nAn [RFC proposal](https://github.com/PowerShell/PowerShell-RFC/pull/126/files) (of mine) suggests surfacing these methods as bona fide PowerShell _operators_, which would allow you to write:\r\n\r\n```powershell\r\nPS> 1..3 -foreach { $_ + 1 }\r\n2\r\n3\r\n4\r\n```\r\n\r\n",
      "created_at": "2018-05-04T15:26:33Z",
      "updated_at": "2018-12-02T14:50:43Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "In https://github.com/PowerShell/PowerShell/issues/10967#issuecomment-561843650, @rjmholt has provided the explanation for why what the initial post is asking for is _not_ possible with the current grammar :\r\n\r\n> PowerShell has pipelines contained by statements, not statements contained by pipelines. That's always been the case, [...]\r\n\r\nIn short, if I understand correctly:\r\n\r\n* What I call a _compound statement_ in the initial post is _one_ form of a statement.\r\n* _Pipelines_ are another (which includes expressions by themselves and expressions as the 1st pipeline segment).\r\n\r\nCurrently, never the twain shall meet, sadly.\r\n\r\n> Essentially, with such a syntactic change you're asking for a new language, with a different treatment of syntactic and semantic constructs like expressions, pipelines and statements.\r\n\r\nAsking largely hypothetically, @rjmholt  - I do recognize how such a change would be the mother of all changes:\r\n\r\n* If we could start from scratch, would treating what I've called compound statements the same as expressions be feasible (that is, also allow them in a pipeline, but only as the _first_ segment)?\r\n\r\n* Would any current code break, if we did?\r\n\r\nIn other words: Would a grammar such as the following work (adapted from https://github.com/PowerShell/PowerShell/issues/10967#issuecomment-549167463)?\r\n\r\n```none\r\npipeline:\r\n | \u2018return\u2019 pipeline [\u2018&\u2019]\r\n | pipeline [\u2018&\u2019]\r\n | pipeline \u2018|\u2019 command_expression\r\n | expression\r\n\r\nexpression:\r\n | ...             # true expressions such as `1+2` or `'1,2' -split ','`)\r\n | command_expression\r\n | compound_expression\r\n\r\ncompound_expression:\r\n | `foreach` ...\r\n | `while` ...\r\n | `if` ...\r\n # ...\r\n\r\ncommand_expression: \r\n | \u2018Get-Item /\u2018   # e.g.\r\n```\r\n",
      "created_at": "2019-12-23T22:14:55Z",
      "updated_at": "2019-12-23T22:14:55Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> Asking largely hypothetically, @rjmholt - I do recognize how such a change would be the mother of all changes:\r\n> \r\n> * If we could start from scratch, would treating what I've called compound statements the same as expressions be feasible (that is, also allow them in a pipeline, but only as the _first_ segment)?\r\n\r\nYeah if you're starting from scratch, pretty much anything is feasible.\r\n\r\n> * Would any current code break, if we did?\r\n\r\nAll third party AST based tooling for one.  The shape of all of those API's would be dramatically different.\r\n\r\nAs for PowerShell scripts specifically, also yeah.  I mean it's probably possible to redesign the language and rewrite the parser without breaking anything, but it'd be one a hell of a trick.\r\n",
      "created_at": "2019-12-24T16:09:19Z",
      "updated_at": "2019-12-24T16:09:19Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @SeeminglyScience.\r\n\r\nBy contrast, in the context of introducing `&&` and `||` the grammar had to be modified without breaking anything(?); what are your thoughts on the impact of the change I've proposed in https://github.com/PowerShell/PowerShell/issues/10967#issuecomment-568220288? (Please comment there, if you're up for it.)",
      "created_at": "2019-12-24T16:24:19Z",
      "updated_at": "2019-12-24T16:24:19Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 I'm not sure what you're asking for in that issue, from a technical standpoint.  How do you propose that be done without making `return` and `exit` something other than statements?\r\n\r\nI think you'd have to make them pipelines or expressions, which would also be a breaking change for tooling.  Maybe you could introduce new ASTs that are the expression/pipeline version of those statements but that makes it very confusing imo.\r\n\r\nOn a more subjective note, I also just don't like how hard it would be to read.  I know PowerShell has historically been all about letting users shoot themselves in the foot, and that can be great.  However, after the whole question mark in variable names situation I'm not keen on the idea of adding more features like that.",
      "created_at": "2019-12-24T18:18:28Z",
      "updated_at": "2019-12-24T18:18:28Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "`return` wouldn't have to change (from what it was _before_ the current `&&` / `||` implementation), only `exit` would be the exception - it would be allowed to moonlight as a non-initial link in a pipeline chain, which is what users will - sensibly - expect.\r\n\r\nNote that shooting yourself in the foot is already possible; that is, `exit` works as the _first_ link of a pipeline chain:\r\n\r\n```powershell\r\n# This happily exits your session, irrespective of what comes after the `&&`\r\nexit 0 && Get-Item /foo\r\n```\r\n\r\nThat the - perfectly sensible and common - reversal does _not_ work is why I'm proposing the exception:\r\n\r\n```powershell\r\n# Doesn't work - requires $(...) around `exit 0`; ditto with `return`\r\nGet-Item /foo && exit 0 \r\n```\r\n\r\n> I think you'd have to make them pipelines or expressions, which would also be a breaking change for tooling. Maybe you could introduce new ASTs that are the expression/pipeline version of those statements but \r\n\r\nIt is the latter I was thinking of, but I'm definitely out of my depth here.\r\n\r\n> that makes it very confusing imo.\r\n\r\nIt may make the _implementation_ more confusing, of necessity (too late to change the fundamentals), but to me it definitely _lessens_ the confusion for the _users_.\r\n\r\n> letting users shoot themselves in the foot\r\n> I also just don't like how hard it would be to read.\r\n\r\nI think that my proposal _helps_ with both aspects, because in the current implementation:\r\n\r\n* That the `return` in `return ls /foo || Write-Host 'Continuing?'` applies to the _whole chain_, and not just to a chain _link_ is unexpected and confusing.\r\n\r\n* That the very common idioms `ls /foo || exit 1` and `ls /foo || return` must be written as `ls /foo || $(exit 1)` and `ls /foo || $(return)` is unexpected, confusing, and cumbersome (a hat-trick).\r\n\r\nNote that in the context of PowerShell there is no behavioral precedent to adhere to in these situations: These are new features, and the behavior I'm proposing will not only make it easier for Bash users to use them, but, I believe, generally makes more sense and is easier to conceptualize than the current implementation.\r\n\r\n",
      "created_at": "2019-12-24T19:07:31Z",
      "updated_at": "2019-12-24T19:45:00Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> `return` wouldn't have to change (from what it was _before_ the current `&&` / `||` implementation), only `exit` would be the exception - it would be allowed to moonlight as a non-initial link in a pipeline chain, which is what users will - sensibly - expect.\r\n\r\nI'm not following, why only `exit`? That makes it even harder to understand the language rules.\r\n\r\n> Note that shooting yourself in the foot is already possible; that is, `exit` works as the _first_ link of a pipeline chain:\r\n> \r\n> ```powershell\r\n> # This happily exits your session, irrespective of what comes after the `&&`\r\n> exit 0 && Get-Item /foo\r\n> ```\r\n\r\nOkay but how do you expect that to work? Because if you change `0` to `10` the result doesn't change.  The `exit` statement is taking the pipeline `0 && Get-Item /foo`, executing it, and then using the results (an array of `@(0; Get-Item /foo)`) as the \"exit code\" (which it doesn't know how to interpret and uses `0` instead).  Don't think of it as the first link, think of it as a modifier of the whole chain.  It's basically like doing this:\r\n\r\n```powershell\r\n$myInvalidExitCode = 0 && Get-Item /foo\r\nexit $myInvalidExitCode\r\n# or\r\nexit $(0 && Get-Item /foo)\r\n# also, this exits with exit code 30\r\nexit 0 && $(exit 30)\r\n```\r\n\r\nAnd that's kind of the point, the problem isn't \"how would you make it work for later portions of the chain\" it's how would you fit it into an actual link, changing the behavior significantly.\r\n\r\n> It may make the _implementation_ more confusing, of necessity (too late to change the fundamentals), but to me it definitely _lessens_ the confusion for the _users_.\r\n\r\nI hear ya, but I don't agree.  I think it makes the language a lot more confusing past the surface level, and any surface level benefit doesn't outweigh the cost of the complexity.\r\n\r\n> * That the `return` in `return ls /foo || Write-Host 'Continuing?'` applies to the _whole chain_, and not just to a chain _link_ is unexpected and confusing.\r\n> * That the very common idioms `ls /foo || exit 1` and `ls /foo || return` must be written as `ls /foo || $(exit 1)` and `ls /foo || $(return)` is unexpected, confusing, and cumbersome (a hat-trick).\r\n\r\nYeah I agree that it's unfortunate.  I still don't think it makes sense for PowerShell.\r\n\r\n> Note that in the context of PowerShell there is no behavioral precedent to adhere to in these situations:\r\n\r\nThey are extensions of pipelines which currently follow the same rules.\r\n\r\n> These are new features, and the behavior I'm proposing will not only make it easier for Bash users to use them, but, I believe, generally makes more sense and is easier to conceptualize than the current implementation.\r\n\r\nProbably right in regards to bash users, which is very regrettable.  I don't agree with the rest though.  My personal opinion is that it should stay how it is.  I understand the arguments on both sides fully, I just don't agree on this one.",
      "created_at": "2019-12-24T20:28:17Z",
      "updated_at": "2019-12-24T20:28:17Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> I'm not following, why only `exit`?\r\n\r\nMy thought was: If we change the `&&` / `||` implementation to how `return` _used to work_ - i.e., returning a _single_ pipeline's result - nothing needs to change in pipeline _chains_  - but I now realize that `return` is not itself part of a pipeline and therefore indeed requires an exception too.\r\n\r\nWith the `exit` exception also in place, you then get **consistent behavior for `return` and `exit`: both only apply to their chain _link_, not to the _rest of the chain_.**\r\n\r\n> Okay but how do you expect that to work? \r\n\r\nIn that vein: I expect `exit` to only apply to the _first link_, and, by the nature of `exit`, for the second link to be _ignored_.\r\n\r\nThat `exit 0 && Get-Item /foo` would evaluate `0 && Get-Item /foo` _as a whole_ and pass the output to `exit` is, frankly, baffling to me.\r\n(With `return` it's debatable, but there too only passing `0` - i.e. _not_ crossing chain-link boundaries - makes much more sense to me).\r\n\r\nAs an aside: that `exit` quietly ignores an invalid exit code and defaults to `0`(!) is a problem in itself.\r\nEven the fact that you can pass a (single) whole _pipeline_ to both `return` and `exit` is probably _not_ widely known, if I were to guess - most real-world uses  I've seen pass a variable / literal.\r\n\r\nScoping `return` and `exit` to a chain _link_ is what most users will likely expect - not just coming from Bash - and it allows for the natural `foo || exit`  / `foo || return` syntax.\r\n\r\nAs stated,  conditionally _exiting_ (returning from) the current scope based on _individual_ pipelines' outcomes is a primary use case for `&&` / `||` chains; passing entire chains to `exit` / `return` contravenes that goal.\r\n\r\nMy hunch is that most PowerShell users will not only naturally assume that `foo || exit` works, but also will also be oblivious to the fact that this use of `exit` doesn't fit the fundamentals of the grammar.\r\n\r\n> any surface level benefit \r\n\r\nTo me, ensuring that a feature makes sense to users is much more than a surface-level benefit.\r\n\r\n> They are extensions of pipelines which currently follow the same rules.\r\n\r\nI don't think of them as  _extensions to_ pipelines, but as a _conditional sequencing of_ them; that is, _independent pipelines_ are _combined_.\r\n\r\nOther than being forced by historical design decisions (\"The current grammar just substitutes pipeline chains for pipelines\" - https://github.com/PowerShell/PowerShell/issues/10967#issuecomment-549167463), I see no justification for the current behavior.\r\n\r\n_That said, it may well be that what I'm asking for is still too much to shoehorn into / breaks the current grammar_  -  a question I cannot answer by myself:\r\n\r\n```\r\nstatement:\r\n | ...\r\n | \u2019return\u2019 pipeline [\u2018&\u2019]\r\n | \u2019exit\u2019 pipeline\r\n | pipeline [\u2018&\u2019]\r\n | pipeline_chain\r\n\r\npipeline_chain:\r\n | pipeline_chain \u2018&&\u2019 pipeline [\u2018&\u2019]\r\n | pipeline_chain \u2018&&\u2019 \u2019return\u2019 pipeline [\u2018&\u2019]\r\n | pipeline_chain \u2018&&\u2019 \u2019exit\u2019 pipeline\r\n | pipeline_chain \u2018||\u2019 pipeline [\u2018&\u2019]\r\n | pipeline_chain \u2018||\u2019 \u2019return\u2019 pipeline [\u2018&\u2019]\r\n | pipeline_chain \u2018||\u2019 \u2019exit\u2019 pipeline\r\n | pipeline\r\n```\r\n",
      "created_at": "2019-12-24T22:29:49Z",
      "updated_at": "2019-12-24T22:31:03Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> > I'm not following, why only `exit`?\r\n> \r\n> My thought was: If we change the `&&` / `||` implementation to how `return` _used to work_ - i.e., returning a _single_ pipeline's result - nothing needs to change in pipeline _chains_ - but I now realize that `return` is not itself part of a pipeline and therefore indeed requires an exception too.\r\n> \r\n> With the `exit` exception also in place, you then get **consistent behavior for `return` and `exit`: both only apply to their chain _link_, not to the _rest of the chain_.**\r\n\r\nAnd inconsistent behavior with all other keywords, and with how all other language elements work with `return` and `exit`.  From an implementation standpoint, the only thing I can think of that would be within the realm of feasibility would be allowing *any* statement to be chained (but that has it's own problems).\r\n\r\n> > Okay but how do you expect that to work?\r\n> \r\n> In that vein: I expect `exit` to only apply to the _first link_, and, by the nature of `exit`, for the second link to be _ignored_.\r\n> \r\n> That `exit 0 && Get-Item /foo` would evaluate `0 && Get-Item /foo` _as a whole_ and pass the output to `exit` is, frankly, baffling to me.\r\n> (With `return` it's debatable, but there too only passing `0` - i.e. _not_ crossing chain-link boundaries - makes much more sense to me).\r\n\r\n\ud83e\udd37\u200d\u2642 that's how everything else works.  I get the confusion in reference to other languages, but it just doesn't make sense for PowerShell imo.\r\n\r\n> As an aside: that `exit` quietly ignores an invalid exit code and defaults to `0`(!) is a problem in itself.\r\n> Even the fact that you can pass a (single) whole _pipeline_ to both `return` and `exit` is probably _not_ widely known, if I were to guess - most real-world uses I've seen pass a variable / literal.\r\n\r\n`return` working that way is pretty wildly known from what I've seen.  `exit` is a bit surprising, though tbh I'm not really sure what I'd rather it do.  Too late to change now anyway.\r\n\r\n> Scoping `return` and `exit` to a chain _link_ is what most users will likely expect - not just coming from Bash - and it allows for the natural `foo || exit` / `foo || return` syntax.\r\n> \r\n> As stated, conditionally _exiting_ (returning from) the current scope based on _individual_ pipelines' outcomes is a primary use case for `&&` / `||` chains; passing entire chains to `exit` / `return` contravenes that goal.\r\n\r\nYeah I'm not disputing that.  When I say that I don't think it makes sense for PowerShell, and that it is not feasible, I'm saying that with this in mind.  I understand all of the reasons why on the surface this seems like the obvious right move, but I strongly disagree that it is.",
      "created_at": "2019-12-25T01:55:07Z",
      "updated_at": "2019-12-25T01:55:07Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> \ud83e\udd37\u200d\u2642 that's how everything else works\r\n\r\nBefore `&&` and `||` there was no everything else. There was just a _single_ pipeline you could pass to `return`  (which  you say is well-known; as an inconsequential aside: I hadn't heard of it until this discussion, and don't recall seeing it on Stack Overflow) and to `exit` (which we agree is uncommon).\r\n\r\nAnd that wouldn't go away with what I'm proposing.\r\n\r\nNo end user previously had to think about the fact that sticking a `return` or `exit` in front a pipeline _technically_ made it a _statement_ and that that means you can't use the whole thing _as a pipeline_  - the question simply didn't arise in the absence of pipeline _chains_.\r\n\r\nFrom an end user's perspective, conceiving of a pipeline chain as a sequence of pipelines _each_ optionally preceded by `return` or `exit`  - or made up of _just_ those keywords - makes much more sense than conceiving of `return` or `exit` as something you stick in front of an _entire chain_: the whole point of a chain is _conditional_ (exit) behavior, depending on what links execute.\r\n\r\nAnd I don't think the proposed behavior contravenes the _spirit_ of PowerShell in any way.\r\n\r\nIt does contravene the current _implementation_, however, and I get that how chaining was implemented fits in best with that.\r\n\r\n> And inconsistent behavior with all other keywords\r\n\r\nNot if you think of `exit` and `return` as something you can stick in front of a pipeline  - which you always could do - whereas you could never do that with any of the other keywords.\r\n\r\n> From an implementation standpoint, the only thing I can think of that would be within the realm of feasibility would be allowing any statement to be chained (but that has its own problems).\r\n\r\nWhile I definitely wish we could also use compound statements such as `foreach`, `while`, ... in a pipeline - as the _first_ segment only, like expressions (the original topic of this thread) - and therefore also in a chain link, my understanding is that this is what would constitute \"the mother of all changes\" and is therefore off the table.\r\n\r\nI can also see how implementing just the `return`-and-`exit`-per-chain-link proposal based on the current implementation without breaking anything may turn out to be too challenging and too much of a maintenance burden (I can't personally assess that).\r\n\r\nBut it is clear to me that the current chain implementation was dictated by the limitations of the original grammar  - whose subtleties most users are probably unaware of - not by what would make the feature most useful to end users.\r\n\r\n\r\n",
      "created_at": "2019-12-25T03:57:28Z",
      "updated_at": "2019-12-25T03:57:28Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "To bring closure to the question asked in the OP, based on @rjmholt's feedback in https://github.com/PowerShell/PowerShell/issues/10967#issuecomment-561843650:\r\nIn the context of the current grammar, the suggested change isn't possible.\r\n",
      "created_at": "2019-12-27T12:20:21Z",
      "updated_at": "2019-12-27T12:20:21Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I've summarized my conclusions from this exchange with respect to `&&` and `||` in  https://github.com/PowerShell/PowerShell/issues/10967#issuecomment-569285154.\r\n\r\nP.S.: Just noticed the thumbs-down on my previous comment, @SeeminglyScience:\r\n\r\nI get not wanting to expend more energy on a discussion at a certain point (when you feel like the disagreement is understood but no shared understanding can be reached, when you feel like not being heard, when the conversation is going around in circles, ...), but a thumbs-down as the sole feedback on a comment were multiple points were argued in detail just tells us \"I don't like this\" - and nothing else; it is a gesture of opposition without content.\r\n\r\nI value your expertise, especially in areas where my knowledge is superficial, but the overall tone of this exchange left a sour aftertaste.\r\n",
      "created_at": "2019-12-28T00:05:15Z",
      "updated_at": "2019-12-28T00:05:15Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "Sorry, I didn't mean any disrespect.  Thumbs down is less common here than in other repos, so it might have a connotation that I didn't intend.\r\n\r\nThat said, it's often stated that decisions are largely made based on community consensus.  My intent was to indicate that I disagree without bumping the thread or paraphrasing the reasons why. You could argue that it was clear I disagreed from context, but to be honest it seems like context is often lost in committee meetings.",
      "created_at": "2019-12-28T04:38:05Z",
      "updated_at": "2019-12-28T04:38:05Z"
    }
  ],
  "created_at": "2018-05-03T17:40:21Z",
  "number": 6817,
  "state": "closed",
  "title": "Can we allow compound statements (loops and conditionals) as the first pipeline segment and as sub-expressions too?",
  "updated_at": "2019-12-28T04:38:05Z"
}