{
  "_url": "https://github.com/PowerShell/PowerShell/issues/10876",
  "author": "daxian-dbw",
  "body": "`$using:` prefixed variables are used in `Foreach-Object -Parallel` and `Start-ThreadJob` to pass value of reference types. Given the value is passed by reference, it's natural to call method on it directly in a thread job or script running in another Runspace, and thus we should remove the semantics check and allow expression to be used on the `$using:` variable.\r\n\r\n# Steps to reproduce\r\n\r\n```powershell\r\n{ $using:blah.Add() }\r\n```\r\n\r\n# Expected behavior\r\n\r\nNo error thrown.\r\n\r\n# Actual behavior\r\n\r\n```none\r\nPS> { $using:blah.Add() }\r\nAt line:1 char:3\r\n+ { $using:blah.Add() }\r\n+   ~~~~~~~~~~~~~~~~~\r\nExpression is not allowed in a Using expression.\r\n+ CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException\r\n+ FullyQualifiedErrorId : InvalidUsingExpression\r\n```\r\n\r\n# Environment data\r\n\r\n<!-- provide the output of $PSVersionTable -->\r\n\r\n```none\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.0.0-preview.4\r\nPSEdition                      Core\r\nGitCommitId                    7.0.0-preview.4\r\nOS                             Microsoft Windows 10.0.18363\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Related: #10499 \r\n\r\nDepending on exactly what's preventing the current use of methods with $using: (is it a deliberate constraint applied manually? Plumbing not entirely hooked up?)  We may want to implement this alongside changing $using in threadjob/foreach -parallel to $ref:\r\n\r\nThat is, if the committee agrees with that change when it is reviewed :smile: \r\n\r\nEdit: ah, I see it has been. Nevermind then :)",
      "created_at": "2019-10-23T23:30:27Z",
      "updated_at": "2019-10-23T23:35:20Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "There are places where `Using` _can't_ provide methods (remoting, DSC) \r\nBut this is silly \r\n```\r\n$hash = @{a=1;b=2;c=3}\r\n\"a\"..\"z\" | foreach -Parallel {$using:hash[[string]$_]}\r\nParserError:\r\nLine |\r\n   1 | \"a\"..\"z\" | foreach -Parallel {$using:hash[[string]$_]}\r\n     |                                           ^ Expression is not allowed in a Using expression.\r\n``` \r\n\r\nespecially as \r\n`\"a\"..\"z\" | foreach -Parallel {$h=$using:hash; $h[[string]$_]} `\r\nworks. \r\n\r\nThis would be a good change but **it should be made clear somewhere what works and what does not**.  This fails\r\n`$x=1; 1..5 | foreach -Parallel {$using:x += $_}`\r\n\r\nbecause `$using:x` gives a read only variable. So a method which changes X should only change the copy in the parallel runspace. If users expect to change the copy in the calling workspace that will cause problems. \r\n",
      "created_at": "2019-10-24T10:01:22Z",
      "updated_at": "2019-10-24T10:01:22Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Honestly given the current strictures of $using, I would think in makes _more_ sense for #10499 to be reconsidered and a different prefix chosen, both to avoid complicating the code paths in the parser for $using (how is the _parser_ meant to differentiate $using restrictions in the different scenarios? That makes little sense to me), and to have it be clear to users.\r\n\r\nIf they get a **parse** error for applying indexing or property access to $using now, I don't think making that parse error somehow conditional based on what command it's being passed to is a good user experience at all. What about creating and storing scriptblocks ahead of time? There's no meaningful way to make the distinction in the parser.\r\n\r\nDifferent prefixes kind of have to be used here, or we have to offload the error states to the individual commands, which leaves us much more open to even more variant, confusing, and inconsistent behaviours.\r\n\r\nNot great UX at all in my opinion.",
      "created_at": "2019-10-24T10:18:52Z",
      "updated_at": "2019-10-24T10:19:39Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "I have struggled to get my head round this, but this may help others. \r\n#10499  basically says \"using in foreach-object -parallel is dangerous\" \r\n\r\nWhat we have here is the parser blocking those dangerous operations - where they are can be seen. \r\n\r\n`$x = 1 ; 1..5 | foreach -Parallel {$using:x += $_}`\r\nGives an error \" The assignment expression is not valid. The input to an assignment operator must be an object that is able to accept assignments\"\r\n\r\n`$hash = @{a=1;b=2;c=3}; \"a\"..\"z\" | foreach -Parallel {$using:hash[[string]$_]}`\r\nGives an error \"Expression is not allowed in a Using expression\"  as does \r\n`$hash = @{a=1;b=2;c=3}; \"a\"..\"z\" | foreach -Parallel {$using:hash.ContainsKey([string]$_)}`\r\n\r\nHowever one can hide the unsafe behaviour \r\n```\r\n$hash = @{a=1;b=2;c=3}; \"d\"..\"f\" | foreach -Parallel {\r\n    $p = $using:hash.psobject ;\r\n    $p.baseobject.add($_,\"99\") \r\n}\r\n$hash\r\nName                           Value\r\n----                           -----\r\ne                              99\r\nd                              99\r\na                              1\r\nb                              2\r\nc                              3\r\nf                              99\r\n```\r\nThis doesn't work for simple types like strings and integers. \r\n\r\nSo we have two requests, one here which says make it easier to do things which are not thread-safe, and #10499 - I'm not sure if it is saying block non-thread safe things completely or ensure that people can't do something unsafe by accident - the parser is doing the latter.  \r\nHaving a different prefix, say $ref: , would make it clearer that it is a thread-unsafe reference; but you can be sure than some users will just accept \"$ref\" as \"what you use to do this\" and will get themselves into trouble.... \r\nWith $using: you can call baseobject.add() or use baseobject[\"b\"] , it is cumbersome but can't be done by accident  \r\nI think every argument for one way or the other has a roughly equal counter argument \r\n",
      "created_at": "2019-10-24T13:42:17Z",
      "updated_at": "2019-10-24T13:42:29Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@jhoneill the latter parts of the discussion in #10499 make it more clear that a `$ref:` keyword rather than `$using:` was indeed the desired outcome, my apologies for not making that clear. \r\n\r\n`$ref:` isn't a _perfect_ solution, but frankly I don't think one really exists. It makes it clear that \"hey, this is a different thing you're working with here! watch out!\", it calls back to the existing `[ref]` that is occasionally useful, and if `$using:` is ignored or creates errors in threadjobs / foreach -parallel that point to using `$ref:` instead users know exactly what to search for to better understand what's going on.\r\n\r\nThere will always be users who don't fully comprehend what they're doing; I think the onus is on us to make it clear that these two usages are different in a pretty important way, and whether users seek to understand it before using it is then up to them. _Hiding_ the difference by simply modifying the existing behaviour of `$using:` is, in my opinion, doing users a disservice. It doesn't give them a good avenue to explore and further understand.",
      "created_at": "2019-10-24T13:56:42Z",
      "updated_at": "2019-10-24T13:56:42Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "The quickest workaround for calling methods is to enclose the reference in `(...)`:\r\n\r\n```powershell\r\nPS> $ht = @{ one=1 }; % -parallel { ($using:ht).Add('two', 2) }; $ht\r\n\r\nName                           Value\r\n----                           -----\r\none                            1\r\ntwo                            2\r\n```\r\n\r\nI think the confusion stems from thinking of `$using:var` as a _variable_ reference, when it reality is a variable's _value_.\r\n\r\nPowerShell - unlike Bash, for instance - doesn't normally make that distinction: in `$var = ...`,  `$var` is a _variable_ (object) whose value is being modified, whereas in `Write-Output $var` `$var` refers to the variable's _value_.\r\n\r\n`$using:var` is only ever a _value_, methinks - that's why you can't assign to it or increment it - even though its syntactic form may make you think you can.\r\n\r\nWhether the _value_ `$using:var` is something that is _mutable_ therefore entirely depends on whether `$var` in the caller's context _happens to contain an instance of a reference type_.\r\n\r\nThese are the same by-[reference]-value passing semantics as when you call a script or function (except that nothing prevents you from assigning to a parameter variable later): if the parameter value is a value-type instance, you get a copy, if it's a reference-type instance, you get a copy of the _reference_ - and therefore the potential for modifying the referenced _object_.\r\n\r\nTherefore, I don't think `$ref:` is appropriate (potential confusion with `[ref]`, which is a fundamentally different thing) or necessary.\r\n\r\nI can't think of a prefix that could capture the complexity of the above.\r\n\r\nHowever, we do have to properly _document_ the issue.\r\n\r\nAnd, back  to @daxian-dbw's original issue, there's no reason not to allow _method_ calls directly on `$using:` \"variables\", especially given that _property_ access already works (and that member access generally works on _values_ (literals) too; e.g., `'foo'.ToUpper()`):\r\n\r\n```powershell\r\nPS> $ht = @{ one=1 }; % -parallel { $using:ht.count }\r\n\r\n1\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2019-10-24T15:08:56Z",
      "updated_at": "2019-10-24T16:50:36Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 `$using:` _is_ currently a reference, not simply a value, when used in `Start-ThreadJob` or `ForEach-Object -Parallel` scriptblocks.\r\n\r\n\ud83d\ude15 ",
      "created_at": "2019-10-24T15:11:36Z",
      "updated_at": "2019-10-24T15:11:54Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@vexx32: \r\n\r\nThese terms are not mutually exclusive: \r\n\r\n* `$using:var` is the _value_ of variable `$var` from the caller's scope\r\n*  That value can be a _reference_  - namely if the caller's variable contains an instance of a reference type.\r\n\r\nThis applies to any function/script call in PowerShell - even though the syntax is different here, the concept is the same:\r\n\r\n```powershell\r\n# Same example as above, only with a local script-block call:\r\nPS> $ht = @{ one=1 }; & { param($htParam) $htParam.Add('two', 2) } $ht; $ht\r\n\r\n\r\nName                           Value\r\n----                           -----\r\none                            1\r\ntwo                            2\r\n```\r\n\r\nAgain, this is unrelated to `[ref]`, where you essentially pass a value _holder_ (variable-like object) around.\r\n\r\n----\r\n\r\nYes, in the context of `Start-ThreadJob` and `ForEach-Object -Parallel` this presents a thread-safety challenge that by definition cannot exist in the different-process based contexts where `$using:` is also supported (`Start-Job`, remoting).\r\n\r\nThat challenge is already documented in the `ForEach-Object` help topic (for version 7). \r\n\r\nDespite the context-specific differences, in all these contexts `$using:` refers to _a value from the caller's scope_, so it makes sense to use the same syntax form, and, as stated, I couldn't think of a prefix that captures the subtleties of the above without obscuring this commonality and causing further confusion.\r\n",
      "created_at": "2019-10-24T15:35:53Z",
      "updated_at": "2019-10-24T15:37:25Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "@mklement0 \r\n> * `$using:var` is the _value_ of variable `$var` from the caller's scope\r\n> * That value can be a _reference_  - namely if the caller's variable contains an instance of a reference type.\r\n> \r\n\r\nThat's not what happens in` foreach-object -parallel` \r\n\r\n### Quick demo\r\n\r\n`$hash = @{\"a\"=1}`\r\n`Invoke-Command -ScriptBlock {$using:hash}`    causes an error\r\n_A Using variable cannot be retrieved. ...  When it is used with Invoke-Command, the Using variable is valid only if the script block is invoked on a remote computer._\r\n\r\nThis works\r\n```\r\nInvoke-Command -ScriptBlock {$using:hash} -ComputerName localhost -EnableNetworkAccess\r\n\r\nName                           Value\r\n----                           -----     \r\na                              1           \r\n```\r\n\r\nCan we change the contents ? And does that change the content of source variable. ?\r\n```\r\nInvoke-Command -ScriptBlock {($using:hash).add(\"B\",2) ; $using:hash } -ComputerName localhost -EnableNetworkAccess\r\n\r\nName                           Value \r\n----                           -----  \r\na                              1        \r\nB                              2                \r\n\r\n$hash\r\n\r\nName                           Value  \r\n----                           -----       \r\na                              1 \r\n```\r\n\r\nThe \"remote\" machine can't write back to the original - it's Call-by-value behavior. \r\nNow take the same script block and run it with `foreach-object -parallel`\r\n```\r\n1,2 | ForEach-Object -Parallel {($using:hash).add(\"B\",2) ; $using:hash }\r\n\r\nName                           Value\r\n----                           -----\r\nB                              2\r\na                              1\r\nMethodInvocationException: Exception calling \"Add\" with \"2\" argument(s): \r\n\"Item has already been added. Key in dictionary: 'B'  Key being added: 'B'\"\r\nB                              2\r\na                              1\r\n```\r\nWe got an error because one thread job sees the modification made by the other. \r\n\r\n```\r\n$hash\r\n\r\nName                           Value\r\n----                           -----\r\nB                              2\r\na                              1\r\n```\r\n\r\nThe value in the callers scope has changed. This is call-by-reference behavior.\r\n\r\n @PaulHigin  explained it in post here.  \r\nhttps://devblogs.microsoft.com/powershell/powershell-foreach-object-parallel-feature/\r\n\r\n> there is a big difference when using the $using: keyword in ForEach-Object -Parallel. And that is for remoting, the variable being passed is a copy sent over the remoting connection. But with ForEach-Object -Parallel, the actual object reference is being passed from one script to another, violating normal isolation restrictions. \r\n\r\nThat's what we see here : the parallel runspaces have read/write access to a variable in the calling runspace. There might be some implementation oddity which means it is not _truly_ call-by-reference, but using the \"if it walks like a duck and quacks like a duck then just call it a duck\" logic,  that's how I'd describe it. \r\n\r\n@vexx32  Agree. I think as things are, there is a bit of \"jumping through hoops\" with using: as it is, that means you don't accidentally get unsafe behaviour. I keep meaning to look at synchronized hash tables and other things which designed for thread safety \r\n\n\n<blockquote><img src=\"https://devblogs.microsoft.com/powershell/wp-content/uploads/sites/30/2018/09/Powershell_256.png\" width=\"48\" align=\"right\"><div><img src=\"https://devblogs.microsoft.com/powershell/wp-content/uploads/sites/30/2019/02/Powershell_2561.png\" height=\"14\"> PowerShell</div><div><strong><a href=\"https://devblogs.microsoft.com/powershell/powershell-foreach-object-parallel-feature/\">PowerShell ForEach-Object Parallel Feature | PowerShell</a></strong></div><div>PowerShell ForEach-Object Parallel Feature\nPowerShell 7.0 Preview 3 is now available with a new ForEach-Object Parallel Experimental feature. This feature is a great new tool for parallelizing work, but like any tool, it has its uses and drawbacks.\nThis article describes this new feature,</div></blockquote>",
      "created_at": "2019-10-25T12:16:03Z",
      "updated_at": "2019-10-25T12:16:09Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@jhoneill: \r\n\r\nNone of what you state contradicts my explanation, except for fuzzy terminology that may explain why you think there is a disagreement (see below).\r\n\r\nYes, there is a thread-safety issue that is unique to `ForEach-Object -Parallel` and `Start-ThreadJob` (though given that you need to start each thread individually, it's probably less likely to surface there in practice).\r\n\r\nTo recap my argument: \r\n\r\n* `$using:`, across all uses cases, has the commonality of referring to the _value_ of a variable from the caller's scope (whether that value is a value-type instance or a reference-type instance), which is why it makes sense to use the same syntax form in all cases:\r\n\r\n  * In the remoting / background scenarios, that value is is always a _fully independent copy_ of the _object_ that the value refers to, so there is no concern about concurrent access; note that this copy is an _imperfect_ copy in many scenarios, because serialization / deserialization is involved, where only a handful of types are deserialized with type fidelity.\r\n\r\n  * In the `ForEach-Object -Parallel` / `Start-ThreadJob` scenarios, _the very same object reference_ is passed to the threads if the caller's variable contains a reference-type instance - and that's where you need to ensure thread safety _if_ you're modifying the object being referenced.\r\n\r\n* The thread-safety pitfall requires documenting  - it already is documented in the `ForEach-Object` topic; it wouldn't hurt to mention it in `Start-ThreadJob` too.\r\n\r\n---\r\n\r\nAs for your examples:\r\n\r\n`$using:` variables only apply in remoting / job contexts, that's why `Invoke-Command` without `-ComputerName` doesn't support them - just as it isn't supported in directly invoked script blocks (`& { $using:HOME }`  breaks, for instance)\r\n\r\n> And does that change the content of source variable. ?\r\n\r\nHere's where it gets fuzzy: It isn't the _content_ of the source variable that is changed, at least not in the sense that a _different value is now stored in it_ - the latter is impossible in this scenario.\r\n\r\nWhat changes is the _object_ that the unchanged variable-content _references_.\r\n\r\n> This is call-by-reference behavior.\r\n\r\nAs argued before, it is by-reference behavior in the same sense as passing _any_ reference-type instance to a script/function passes a copy of the _reference_.\r\n\r\nThis is fundamental PowerShell / .NET behavior that is to be expected, and needs to be understood _generally_, in _all_ contexts where you pass parameters _in-process_.\r\n\r\nTo recap my previous example:\r\n\r\n```\r\nPS> $ht = @{one=1}; & { param($htParam) $htParam.Add('two', 2) } $ht; $ht\r\n\r\nName                           Value\r\n----                           -----\r\none                            1\r\ntwo                            2\r\n```\r\n\r\n`$htParam` received a _reference_ to the same hashtable instance that `$ht` references.\r\n\r\nTechnically, this is still passing _by value_ in that a _copy of the `$ht` variable's value_ is passed.\r\n\r\n* If `$ht` contained a value-type instance, `$htParam` would indeed receive a copy of its _data_, because the variable value _is_ the data.\r\n* If `$ht` contains a reference-type instance, as in this case, `$htParam` receives  a copy of its _reference_, which, of course, points to the very same object.\r\n\r\nSo, _in effect_, what is technically by-value passing is situationally \"object-pointer passing\" - as in C/C++, except that the fact is more obvious there.\r\n\r\nThe type of by-value semantics that you have in mind - _always_ passing an _independent copy_ of the _data_  - are de facto impossible to achieve.\r\n\r\n* It would require a generic deep-cloning mechanism that works with _any_ data type - and there is no such thing.\r\n\r\n  *  Hence the imperfect _approximation_ of deep-cloning in cross-process scenarios (remoting, background jobs), where passing a _copy of the data_ is a necessity.\r\n\r\n* Even if that were an option, It would be impractical - at least as the default behavior - due to the potentially large performance penalty incurred by cloning.\r\n\r\n",
      "created_at": "2019-10-25T15:46:55Z",
      "updated_at": "2019-10-25T15:46:55Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "All this back and forth only seems to perfectly illustrate the exact reason that we should separate the two types of `$using:` behaviour, to me. \r\n\r\nConfusion and lengthy discussions are already present, and a few notes in documentation are unlikely to be sufficient to properly illustrate the differences, in my view. \ud83d\ude42 \r\n\r\nAs you say, truly deep-cloning is impossible. By and large, most $using usage is currently working with/around the serialization and job interfaces. In comparison, the way it behaves in Start-ThreadJob or ForEach-Object -Parallel is going to be very different, even if on a technicality it's _sort of_ the same kind of thing. \ud83d\ude42 ",
      "created_at": "2019-10-25T15:50:46Z",
      "updated_at": "2019-10-25T15:52:54Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "My conclusion is different:\r\n\r\n* If you want to use remoting / background jobs / thread jobs / parallel foreach-object properly, there is no way around understanding the underlying concepts - documentation should do its best to explain them.\r\n\r\n  * The way this discussion unfolded suggests to me that needing to understand the fundamentals of parameter passing is the  primary problem, which goes deeper than the `ForEach-Object -Parallel` / `Start-ThreadJob` issue at hand.\r\n\r\n  * Given how fundamentally the value-type/reference-type dichotomy impacts by-value parameter passing (which `$using:` in essence is), it is more than a technicality. I get that it's conceptually tricky, but there's no way around needing to understand it.\r\n\r\n* No different prefix name such as `$ref:` can compensate for that:\r\n\r\n  * Generally, it obscures the underlying commonality that `$using:` represents: passing a _value_ from the caller's scope and requires you to memorize another syntax.  \r\n    * Hypothetically, if `$using:` _also_ worked, with _copy-data-always_ behavior, there would be a useful distinction, but the only way to get that would be to employ serialization / deserialization (as in the cross-process scenarios), which, apart from the loss of type fidelity, would defeat the purpose of using thread-based concurrency due to the overhead involved.\r\n\r\n  * Specifically, `$ref:` may mistakenly suggest that you can pass _value-type_ instances by reference too; that is, it may more explicitly promote the misconception that `$ref:var` is a _variable_ rather than a _value_.\r\n\r\nPragmatically speaking, the issue only arises:\r\n\r\n* if a `$using:` reference expands to a _reference-type_ instance\r\n\r\n* _and_ you're _modifying_ that instance _in-place_.\r\n\r\nIt is only then that you _need_ to be aware of the thread-safety issue, and an explanation of the issue in the `ForEach-Object` topic  (already present, along with showing how to _solve_ the problem with `System.Collections.Concurrent` data types) and the `Start-ThreadJob` topic (to be added) should suffice.\r\n\r\nI suppose we should also document the _complementary_ solution: wanting to work with _thread-local clones_ of `$using:` values; e.g.:\r\n\r\n```powershell\r\n# OK, because thread-local clones of the hashtable are being modified.\r\nPS> $ht = @{one=1}; 1..2 | % -parallel { $ht = ($using:ht).Clone(); $ht.Add('two', 2); $ht }\r\n\r\nName                           Value\r\n----                           -----\r\none                            1\r\ntwo                            2\r\none                            1\r\ntwo                            2\r\n```\r\n\r\n`[hashtable]` conveniently offers - shallow - cloning, but in general you'll face the usual cloning challenges.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2019-10-25T16:42:25Z",
      "updated_at": "2019-10-25T16:42:25Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "\ud83e\udd14 Fair points.\r\n\r\nI dislike the confusion that is more or less inevitable here, but you're right in that `$ref:` will create its own misconceptions. \ud83e\udd37\u200d\u2642 \r\n\r\nAppreciate you taking the time to lay it all out! \ud83d\udc96 ",
      "created_at": "2019-10-25T16:47:51Z",
      "updated_at": "2019-10-25T16:47:51Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "@mklement0  \r\n\r\nI'll let you argue with @BrucePay , see https://github.com/PowerShell/PowerShell/issues/10499#issuecomment-529691685\r\n\r\n> >while the rest of PowerShell passes variables by value.\r\n\r\n>This is not actually correct. In fact, PowerShell _always_ passes by reference both with reference types and boxed value types.\r\n\r\nI understand what you are saying; after executing `$ht = @{one=1};` leaves `$ht` as a pointer to a hash table, not the hash table itself; Passing a copy of that pointer (call-by-value) gives behavior which looks like call-by-reference because the original pointer and the copy both point to the same data (it's like being back in 1st year computer science, 35 years ago :-) ) . It's just that the guy who implemented it says it doesn't do that. \r\n\r\n`Using:` is restricted to certain places. In remoting or DSC \"pointed to\" data is expanded, because sending a pointer to a remote machine or writing it to a MOF file won't be helpful. \r\nIn foreach-object -parallel it's a \"_live_\" pointer. It's a moot point whether that _live_ pointer is the original one or a copy...  \r\nThe point being made in #10499 a writer not realizing this `using` giving live pointers in one place could be dangerous and the point here this variables from outside the script block should act like any other scriptblock referring to its parent scope.  One solution, which doesn't tie the parser in knots is to use another label. The other is to say that making use of the live pointer is not onerous but sufficient to make it clear that you are doing it. \r\n\r\n  ",
      "created_at": "2019-10-25T19:11:28Z",
      "updated_at": "2019-10-25T19:11:28Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@jhoneill:\r\n\r\n> variables from outside the script block should act like any other scriptblock referring to its parent scope\r\n\r\nThey behave the same as in the parameter-passing / thread-based `$using:` scenario: if the parent scope's variable value happens to be an instance of a _reference type_, you _can_ modify the object being referenced (whereas if you _assigned_ to `$ht` you'd create an independent _local variable_):\r\n\r\n```powershell\r\n$ht = @{ one = 1 }; & { $ht.one = 2 }; $ht\r\n\r\nName                           Value\r\n----                           -----\r\none                            2\r\n```\r\n\r\n>  making use of the live pointer is not onerous\r\n\r\n* It's only _onerous_ (treacherous, counterintuitive) if the underpinnings aren't understood - hence the need for documenting the potential pitfalls.\r\n\r\n* On the flip side, the thread-based behavior is a _feature_  if you actively take advantage of it: it enables collaborative cross-thread population of a data structure - _if_ you understand that it is _your_ responsibility to ensure thread safety (synchronize access to the data structure).\r\nThis option is _not_ available in cross-process `$using:` scenarios (remoting, background jobs, DSC).\r\n\r\nAlso note that users who are accustomed to `$using:` in the context of remoting / background jobs / DSC probably don't expect - and certainly shouldn't - to be able to directly modify values in the _caller's_ scope.\r\n\r\nIt is only if they happen to pass `$using:` values that (a) are reference-type instances and (b) are _mutable_ and (c) in-place mutation methods are actually called that the behavior would change in the thread-based scenarios.\r\n\r\nAgain: A different namespace prefix is incapable of conveying these subtle _differences_ while obscuring the _commonalities_ and increasing developers' memory burden.\r\n",
      "created_at": "2019-10-25T22:23:33Z",
      "updated_at": "2019-10-25T22:23:33Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@jhoneill: As for the quote from https://github.com/PowerShell/PowerShell/issues/10499#issuecomment-529691685:\r\n\r\nThat PowerShell uses _boxing_ (wrapping _value-type_ instances in a _reference-type_ instance) _behind the scenes_ is irrelevant to the effective behavior in PowerShell code:\r\n\r\n```powershell\r\nPS> $i = 1; & { param($intParam) ++$intParam } $i; $i\r\n\r\n1  # The value-type instance stored in the caller's $i variable was NOT modified.\r\n```\r\n\r\nEven in C#, where you can make boxing explicit, boxing doesn't change the semantics of parameters that are ultimately value-type instances (you can paste the code directly at a [`dotnet-script`](https://github.com/filipw/dotnet-script) prompt):\r\n\r\n```csharp\r\n> class\u00a0Foo\u00a0{\u00a0public\u00a0static\u00a0void\u00a0Bar(object\u00a0i)\u00a0{\u00a0i\u00a0=\u00a02;\u00a0}\u00a0};\u00a0object\u00a0i\u00a0=\u00a01;\u00a0Foo.Bar(i); i\r\n\r\n1  // The value-type instance stored in the caller's i variable was NOT modified.\r\n```\r\n\r\nEven though local `i` parameter variable originally contains a reference to the boxed value, assigning _a different value_ to the local `i` variable has no effect on the previously referenced boxed value.\r\n",
      "created_at": "2019-10-25T22:32:47Z",
      "updated_at": "2019-10-25T22:41:33Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> @jhoneill: As for the quote from [#10499 (comment)](https://github.com/PowerShell/PowerShell/issues/10499#issuecomment-529691685):\r\n> \r\n> That PowerShell uses _boxing_ (wrapping _value-type_ instances in a _reference-type_ instance) _behind the scenes_ is irrelevant to the effective behavior in PowerShell code:\r\n\r\nLook, you can argue with Bruce if you want to :-) The OP talks about it as by reference, and   @PaulHigin 's post talks about parallel being different from other using, being by reference. \r\n\r\n> ```powershell\r\n> PS> $i = 1; & { param($intParam) ++$intParam } $i; $i\r\n> \r\n> 1  # The value-type instance stored in the caller's $i variable was NOT modified.\r\n> ```\r\n `++ $x` does` $x=$x+1` ,it doesn't call an increment() method. You said yourself  in the previous post \r\n>you can modify the object being referenced (whereas if you _assigned_ to $ht you'd create an independent local variable\r\n\r\nthen \r\n\r\n> > [requestor wants] variables from outside the script block should act like any other scriptblock referring to its parent scope\r\n> \r\n> They behave the same as in the parameter-passing / thread-based `$using:` scenario: \r\n\r\nI thought we had established using with parallel _can_ change the variable in the calling scope (unlike remoting) but method calls don't work unless the passed variable is wrapped in () unlike a script block  -from  the initial post. \r\n\r\n> _`$using:` prefixed variables are used in `Foreach-Object -Parallel` and `Start-ThreadJob` to pass value of reference types. _Given the value is passed by reference, it's natural to call method on it directly in a thread job_ or script running in another Runspace, and thus we should remove the semantics check and allow expression to be used on the `$using:` variable._\r\n> \r\n>  **Steps to reproduce**\r\n> ```powershell\r\n> { $using:blah.Add() }\r\n> ```\r\n\r\ni.e he doesn't want to write `{($using:blah).add() }` \r\n\r\n> > making use of the live pointer is not onerous\r\n> \r\n> * It's only _onerous_ (treacherous, counterintuitive) \r\n\r\nSorry I was using it in the sense of \"excessively work\" \r\n\r\n> Also note that users who are accustomed to `$using:` in the context of remoting / background jobs / DSC probably don't expect - and certainly shouldn't - to be able to directly modify values in the _caller's_ scope.\r\n\r\nThis is what was being said in #10499 . And you say _users shouldn't be able to modify values in the_ caller's _scope.._ Most people would say after this :\r\n`>$ht = @{\"Value\"=999} ; \r\n $ht.value is a value in the current scope . So then ... \r\n`> 1..3 | foreach -Parallel {start-sleep -Milliseconds (get-random 1000); ($using:ht).value = $_}`\r\n\r\nensures the last thread to try to change $ht.value is random.  \r\nBack in the parent scope it **has changed**\r\n```\r\n$ht\r\n\r\nName                           Value\r\n----                           -----\r\nValue                          2\r\n```\r\n\r\n",
      "created_at": "2019-10-26T00:06:20Z",
      "updated_at": "2019-10-26T00:06:20Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> The OP talks about it as by reference, and @PaulHigin 's post talks about parallel being different from other using, being by reference.\r\n\r\nYes. Everything that needs to be said about this has been said.\r\n\r\n> `++ $x` does `$x=$x+1` ,it doesn't call an `increment()` method. You said yourself in the previous post\r\n\r\nThe point of the example was that you can't modify _value-type_ instances in this scenario - whether or not they have _mutating methods_ (which is rare to begin with):\r\n\r\n```powershell\r\n# Define a value type with a mutating method.\r\nAdd-Type 'public struct Foo {  public int Value { get; private set; } public void Increment() { ++Value; } }'\r\n\r\n$foo = [Foo]::new()\r\n$foo.Increment()  # $foo.Value is now 1\r\n\r\n# Passing the value type as a parameter value passes a *data copy* to the\r\n# script block, so any mutating methods invoked on that copy only affect *that copy*.\r\n& { param($fooParam) $fooParam.Increment() } $foo\r\n\r\n$foo.Value # still 1\r\n```\r\n\r\n\r\n> I thought we had established using with parallel can change the variable in the calling scope (unlike remoting) but method calls don't work unless the passed variable is wrapped in `()`\r\n> i.e he doesn't want to write `{($using:blah).add() }`\r\n\r\nYes. And I agree that `(...)` shouldn't be required. Why do you mention that?\r\n\r\n> Sorry I was using it in the sense of \"excessively work\"\r\n\r\nI'm confused:\r\nUsing a \"live pointer\" is the _opposite_ of excessive work - no cloning / serialization+deserialization overhead required.\r\n\r\n> And you say _users shouldn't be able to modify values in the caller's scope..._\r\n\r\nI didn't say that, and I didn't mean to (though I certainly think it should be a _deliberate_ action).\r\nWhy do you think I did?\r\n\r\nWhat I did say was that modifying _objects_ in the caller's scope is _simply not an option_ in the _cross-process_ scenarios, so the _in-process, cross-thread_ scenario of _being able to_ modify the very same object is simply not an issue.\r\n\r\n> Back in the parent scope it **has changed**\r\n\r\nIndeed, as has been amply discussed - including the scenario where that can be used _as a feature_.\r\nWhy do you mention that?\r\n\r\n\r\n\r\n",
      "created_at": "2019-10-26T01:47:06Z",
      "updated_at": "2019-10-26T01:50:58Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "OK....  We have two competing requests. This one which says accessing a method of a `using` variable should impose less work on the author. And 10499 which says `using`  is already too easy for an author to change something in a different runspace, meaning that accidental modification can occur. Their wishes for `using` are **mutually exclusive**. IF one wants to satisfy both, changing the label from using  to something else (`ref` has been mooted), _might_ allay the fear of someone writing `using` with the wrong expectation and _could_ make life easier for authors while avoiding the need for the parser to identify different contextual behaviors allowed for `using` \r\n\r\n> > I thought we had established using with parallel can change the variable in the calling scope (unlike remoting) but method calls don't work unless the passed variable is wrapped in `()`\r\n> > i.e he doesn't want to write `{($using:blah).add() }`\r\n> \r\n> Yes. And I agree that `(...)` shouldn't be required. Why do you mention that?\r\n\r\nRight; we all know what can be observed with PowerShell as it is now. And I don't think I'm misrepresenting anything to say in a  \"Make it easier\" vs \"Already dangerously easy\"  debate you and the OP in this issue would be inclined towards the former. I'm not strongly for or against either of them. Nor am I convinced that the label should be changed in an attempt to satisfy both. I think the present position is OK, but in an uncommitted and agnostic way :-) \r\n> > Sorry I was using it in the sense of \"excessively work\"\r\n> \r\n> I'm confused:\r\n> Using a \"live pointer\" is the _opposite_ of excessive work - no cloning / serialization+deserialization overhead required.\r\n\r\nWhat I tried to say was this; making a script author write `($using:something).method` _does_ impose requirements (knowing the needs for () and inserting them) but _not excessively so_ [in my view]. The extra work makes it _deliberate_ and reduces the risk of accidental modification to [what I think is] an acceptable level but not to zero.   \r\n> > And you say _users shouldn't be able to modify values in the caller's scope..._\r\n> \r\n> I didn't say that, and I didn't mean to (though I certainly think it should be a _deliberate_ action).\r\n> Why do you think I did?\r\n \r\nI may have misunderstood / lost the context in quoting what you said 3 paragraphs from the bottom of https://github.com/PowerShell/PowerShell/issues/10876#issuecomment-546532279  \r\nIt doesn't matter whether you misspoke or I misunderstood, it's clear now (I think)     \r\n> > Back in the parent scope it **has changed**\r\n> \r\n> Indeed, as has been amply discussed - including the scenario where that can be used _as a feature_.\r\n> Why do you mention that?\r\n\r\nBecause I lost track of what you were saying should or should not be possible. Can we park that since I we agree that _it is indeed a feature_ ?  The question is \r\n\r\n1. Is this feature, as is, a _trap_, and something which should be made harder and/or blocked (issue #10499) OR \r\n2. Is this feature a _benefit_, but too hard too use as is, and should be made accessible (this issue) OR \r\n3. Does this feature, as-is impose, enough extra work to avoid being a trap; without becoming a burden on those wanting to use it.    \r\n\r\nI'm inclined towards 3 which is the status quo; nothing said for either of the others (so far) has convinced me of their case - in my view both have equal and opposite merit. \r\n ",
      "created_at": "2019-10-26T11:05:18Z",
      "updated_at": "2019-10-26T11:05:18Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I see this issue and #10499 as unrelated:\r\n\r\n* #10499: For all the reasons discussed here, I don't think any action is required to address #10499: `$using:` in thread-based contexts is a potential feature as much as a potential pitfall; you need to understand the ramifications, as documented.\r\n\r\n  * Introducing a separate prefix doesn't replace the need to understand and cannot inspire that understanding, while, conversely, obscuring common functionality and increasing developers' memory burden.\r\n\r\n  * So: yes to 2.\r\n\r\n* There was never a good reason _syntactic_ reason to require `(...)` around a `$using:` reference; `$using:var.property` already works, making `$using:var.method()` work amounts to simply removing an inconsistency.\r\n\r\n  * That said, _assigning_ to `$using:var.property` does _not_ work, and should be allowed as well; the following currently breaks:\r\n`[pscustomobject] $o = @{ one = 1 }; % -parallel { $using:o.one = 2 }; $o`\r\n\r\n  * The - non-obvious - workaround is again to use `(...)`\r\n`[pscustomobject] $o = @{ one = 1 }; % -parallel { ($using:o).one = 2 }; $o`\r\n\r\n---\r\n\r\nRe 3.:\r\n\r\nI generally think it's not a good idea to encumber the syntax in order to prevent pitfalls (see #6551, for instance); it is of necessity _arbitrary_ and therefore:\r\n\r\n* makes it non-obvious - I had to _experiment_ to find the `(...)` workarounds.\r\n\r\n* ends up burdening _proper_ use of a given feature as well.\r\n\r\nWhile it ultimately doesn't matter, I suspect that the current inability to call methods directly on `$using:` references was _not_ a deliberate feature; after all:\r\n\r\n  * It was implemented _before_ thread-based jobs / parallel foreach-object, and in the older scenarios the pitfall never presented itself, so there wouldn't have been a need to erect a syntactic barrier.\r\n\r\n  * The current barrier is inconsistent in that (get-only) _property_ access works as-is, without `(...)`\r\n\r\nThe only required barrier here is one of _necessity_: attempts to assign _directly_ to a `$using:` \"variable\" (which isn't one, despite its syntactic form - but this ambiguity is at the heart of PowerShell) - `$using:var = ...` - must be prevented (which already happens), but there is certainly room for improvement in the current _error message_, which is too general for this specific case:\r\n\r\nCurrent, general error message:\r\n\r\n> The assignment expression is not valid. \r\n> The input to an assignment operator must be an object that is able to accept assignments, such as a variable or a property.\r\n \r\nIn the case of attempting to assign to a `$using:` reference, I suggest emitting a specific error, along the lines of:\r\n\r\n> The assignment expression is not valid. \r\n> $using: references are values, not variables, so they cannot be assigned to.\r\n\r\n",
      "created_at": "2019-10-26T13:44:07Z",
      "updated_at": "2019-10-26T13:44:07Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "@mklement0 \r\nI'm starting to come round to your view :-)   I think #10499 is connected but the danger is overstated...  so no action required. \r\n\r\n`Using` in a **remoting** scenario serializes and de-serializes objects, so in a lot of cases the method is lost.   In something like this \r\n```\r\n$p = start notepad -PassThru\r\nInvoke-Command -ComputerName localhost -EnableNetworkAccess -ScriptBlock {$using:p.GetHashCode() | gm }\r\n```\r\nThe parser error is stopping me from trying to call a method which won't exist (and wouldn't make sense).  \r\nBut if I pass a hash table (for example) the deserialized object _does have_ an `add()` method and brackets let me say \"I know what I'm doing , it's OK to call _this_ method\"  `get-help about_remote_variables `doesn't give this information, so there is a _discovery problem_\r\n\r\n`Using`  in **DSC** does writes  `$VariableName = <<present value of variable>>` to the MOF file and converts all instances of `$using:` to `$` after that. Some roll-your-own serialization is needed in my experience. \r\n\r\n`Using `in a **threadjob** scenario (with `Start-threadjob` or `foreach-object parallel` has the parser behavior for remoting but is accessing the original content without serialization. \r\n`Start-threadjob -ScriptBlock {$using:p.kill() }`\r\ngives the parser error and again brackets let me say \"I know what I'm doing , it's OK to call this method\".  \r\nIn this instance  `$using:p.kill()` would work, the parser is just requiring authors to demonstrate that they know what they are doing.  I still don't think that's excessive, but (as with remoting) there is a discovery problem. \r\nHow easy it is to have one parser behaviour in one place and another somewhere else I don't know.   That's not a reason for opt not to do it, but might mean it's thought to be a good idea but not done.\r\n",
      "created_at": "2019-10-27T13:07:03Z",
      "updated_at": "2019-10-27T13:07:03Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Glad to hear it, @jhoneill.\r\n\r\nYes, only a handful of known types deserialize with type fidelity in remoting / background jobs; all others are emulated with method-less `[pscustomobject]` instances.\r\n\r\n(#10916 seems to want to change that selectively, which sounds quite challenging.)\r\n\r\nAs an aside: While that fact is specified in the [MS-PRSP](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-psrp/602ee78e-9a19-45ad-90fa-bb132b7cecec) protocol specification, there's virtually no information in the end-user documentation (`about_Remote_Output`, `about_Remote_Variables`).\r\n\r\nFor all the reasons previously discussed, my preference is _not_ to erect syntax barriers, especially not selectively - documentation should suffice.\r\n\r\n`$using:var` should be treated like any other expression, on which members can be directly accessed (`$using:var.Prop`, `$using:var.Method()`).\r\n\r\nAs for how likely it is that users will encounter the pitfall: Since methods are often lost  in cross-process parallelism due to deserialization, there may not even be an expectation of being able to call methods - anecdotally, the vast majority of remoting / background-job commands I've seen on Stack Overflow simply pass values that are accessed as-is (no method calls, rarely property access).\r\n\r\nSo that means that only the following users are affected: Those who actively use not only methods on deserialized objects, but specifically _mutating_ methods and who expect such mutations to be confined to an _independent copy_ of the caller's value.\r\n\r\n---\r\n\r\nFinally, let me offer a way through the conceptual fog of by-value vs. by-reference argument passing vs. data that happens to be a reference:\r\n\r\n* The terms _by-value_ vs. _by-reference_ are data _holder_ (container) concepts: \r\n\r\n   * They indicate whether it is a data holder's _data_ that is passed to a function/command or, loosely speaking, the data holder _itself_, the latter enabling direct manipulation of _what data is stored in the data holder_.\r\n\r\n   * In that sense, PowerShell (and C#) always pass _by value_ - unless you explicitly opt into a by-reference approach with `[ref]` (`ref`, `out`).\r\n\r\n* Separately, _data_ in .NET comes in two flavors:\r\n\r\n   * _value-type_ instances, whose _content itself_ is directly stored in data holders; a given value-type instance can never be _indirectly referenced_: accessing  a data holder's data that is a value-type instance means invariably getting a _copy_ of that data.\r\n\r\n   * _reference-type_ instances, only a _reference_ (\"pointer\") to which is stored in data holders; the data itself is stored elsewhere, and _multiple_ references can exist to it.\r\n\r\nThe two concepts are independent of one another, but it gets confusing, because something passed _by-value_ (in the data-holder sense) can still be a _reference_ (in the data sense) that the callee can potentially modify.\r\n\r\nAgain, this behavior is fundamental to all in-process parameter passing.\r\n\r\n",
      "created_at": "2019-10-29T21:14:48Z",
      "updated_at": "2019-10-29T21:21:38Z"
    }
  ],
  "created_at": "2019-10-23T23:05:03Z",
  "labels": [
    "Issue-Enhancement",
    "WG-Engine"
  ],
  "number": 10876,
  "state": "open",
  "title": "`$using` variable should support method call on it",
  "updated_at": "2019-10-29T21:21:38Z"
}