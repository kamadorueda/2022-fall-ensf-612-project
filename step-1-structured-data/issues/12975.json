{
  "_url": "https://github.com/PowerShell/PowerShell/issues/12975",
  "author": "bitcrazed",
  "body": "Following a conversation with @SteveL-MSFT where he confirmed I am not (entirely) insane \ud83d\ude1c\r\n\r\nPowerShell currently makes if VERY difficult to \r\n\r\n1. Specify that an arbitrary set of command-line args gets passed to an exe, verbatim\r\n2. That the same command-line also supports PowerShell command chaining, etc.\r\n\r\nFor example, trying to pass a Linux command-line `cd / && ls . | cowsay` to `wsl` in PowerShell 7+:\r\n```powershell\r\nwsl cd / && ls .\r\n```\r\nExpected: Directory listing of the root of the users' default Linux distro\r\nActual: Error reporting that cowsay is not a recognized command:\r\n![image](https://user-images.githubusercontent.com/961950/84838595-ae079b00-afef-11ea-849b-6b20193bef2c.png)\r\n\r\n> Note: to perform the above command, you'll need to [enable WSL and a Linux distro](https://docs.microsoft.com/en-us/windows/wsl/install-win10). Within your default distro, you'll also need to install `cowsay` via your distro's package manager. For Ubuntu and Debian, you can do this via `sudo apt install cowsay`\r\n\r\nAs can be seen from the syntax color highlighting, PowerShell is parsing `&&` as a PowerShell command continuation, not as a part of the command to be passed to `wsl`.\r\n\r\nSo, how about wrapping the args in quotes?\r\n![image](https://user-images.githubusercontent.com/961950/84838712-f58e2700-afef-11ea-8014-3a2a9ee6603a.png)\r\n\r\nDoesn't work because that would make `arg[1]` `'cd / && ls . | cowsay'` which wouldn't make sense to bash.\r\n\r\n@SteveL-MSFT recommended prefixing the command-line args with `--%` to indicate that PowerShell should pass the remaining command-line verbatim. Alas, no joy here - notice the syntax highlighting which indicates that the parser thinks the `&&` is a PowerShell command which, in this case, it is not!\r\n![image](https://user-images.githubusercontent.com/961950/84838851-62092600-aff0-11ea-8ff8-d123ec220597.png)\r\n\r\nBoo! \ud83d\ude1f\r\n\r\nOkay, so how about escaping the `&&` with a ````` (backtick)?\r\n![image](https://user-images.githubusercontent.com/961950/84839030-dba11400-aff0-11ea-9b30-312707d1d4f8.png)\r\n\r\nOh! PowerShell thinks that I meant to spawn the remaining command as a job. NOPE!\r\n\r\nHow about escaping each `&`?\r\n![image](https://user-images.githubusercontent.com/961950/84839069-f70c1f00-aff0-11ea-8e11-f06f763dc693.png)\r\n\r\nCloser!\r\n\r\nNow, how about also escaping the pipe operator:\r\n![image](https://user-images.githubusercontent.com/961950/84839092-09865880-aff1-11ea-8581-1dac1b1e78c3.png)\r\n\r\nHUZZAH! \ud83d\ude4c\r\n\r\nEscaping many symbols in lengthy command-lines could get tedious pretty quickly, especially when pasting more lengthy & complex bash command-lines into WSL, or complex page splits into `wt` (Windows Terminal):\r\n![image](https://user-images.githubusercontent.com/961950/84839250-78fc4800-aff1-11ea-8283-b1dda41871c2.png)\r\n\r\nWhile `--%` may be useful (when fixed) in some cases to pass the remainder of __this__ command-line to the tool being executed, commands couldn't be chained.\r\n\r\nSo, ideally, PowerShell should (also) provide a way of escaping a specific portion of a command-line to the preceding tool, but then continue treating the remaining command-line as PowerShell script.\r\n\r\nPerhaps enclosing the command-line segment in some of the following delimiters would work?\r\n\r\n* Pointy-braces: `<` ... `>`, e.g. `wsl <cd / && ls . | cowsay>`\r\n* Square-braces: `[` ... `]`, e.g. `wsl [cd / && ls . | cowsay]`\r\n* Curly-braces: `{` ... `}`, e.g. `wsl {cd / && ls . | cowsay}`\r\n* Double-backticks\r\n* Arrow: `<--` ... `--<<<` , e.g. `wsl <-- cd / && ls . | cowsay --<<<` \ud83d\ude1c\r\n\r\n... but will leave the choice of the enclosing delimiters to the language designers \ud83d\ude01",
  "closed_at": null,
  "comments": [
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> PowerShell currently makes if VERY difficult\r\n\r\nPowerShell is a _shell_ - just like `cmd.exe` and `bash` are.\r\n\r\nThis means: you need to understand and accommodate the running shell's syntax rules, and you need to understand that if you submit something like:\r\n\r\n```powershell\r\nwsl cd / && ls . | cat -n\r\n```\r\n\r\nthat any _unquoted_ token is subject to _PowerShell_'s syntax rules; specifically, `&&` is interpreted as _PowerShell_'s pipeline-chaining operator, and `|` is interpreted as PowerShell's pipeline operator.\r\n\r\n---\r\n\r\nAdditionally, you need to understand the external `wls.exe`  program's syntax requirements: it can execute a _WSL_ shell command passed _as individual arguments_, which means that you must _quote_  arguments selectively in order to _pass them through_ verbatim to `wsl.exe`:\r\n\r\n```powershell\r\nwsl cd / '&&' ls . '|' cat -n\r\n```\r\n\r\n---\r\n\r\nThe alternative is to explicitly pass an _entire command line_ _as a single string_ to the default WSL shell, `sh`, via its `-c` option:\r\n\r\n\r\n```powershell\r\nwsl sh -c 'cd / && ls . | cat -n'\r\n```\r\n\r\n---\r\n\r\nThere is nothing that PowerShell can reasonably do to ease this perceived pain; that the ill-fated and Windows-focused `--%` doesn't help in this case is no surprise and serves to underscore that point.\r\n\r\nGiven that an understanding of the syntax requirements allows you to solve the problem, I don't think any new syntax is called for.\r\n\r\n",
      "created_at": "2020-06-17T02:08:44Z",
      "updated_at": "2020-06-17T02:08:44Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "Yes, after discussing with @SteveL-MSFT, this behaviour seems to be quite explicitly coded for:\r\n\r\nhttps://github.com/PowerShell/PowerShell/blob/a3319d7580dabbae6a9bb06a16771fc6f6f1d4ff/src/System.Management.Automation/engine/parser/tokenizer.cs#L2311-L2315\r\n\r\n> Alas, no joy here - notice the syntax highlighting which indicates that the parser thinks the && is a PowerShell command which, in this case, it is not!\r\n\r\nTo be clear, the verbatim argument parameter is terminated by `|`, `||` and `&&`. Perhaps the `&&` behaviour is derived from the earlier idea that `&&` and `||` are statement separators, **but**, `|` still terminates the arguments in Windows PowerShell, meaning the current behaviour is totally consistent with that.\r\n\r\nAs @mklement0, the solution is to quote the `&&`.\r\n\r\nOne thing I've noticed though is that in the sparse documentation of `--%`, it only ever mentions terminating at newlines. @mklement0 are you aware of any other documentation (including 3rd party) that states otherwise?\r\n\r\nIt's not really clear to me *why* this choice was made, but even constrained in scope as it is, I think we'd need to have very strong motivation to break it.\r\n\r\n> Additionally, you need to understand the external wls.exe program's syntax requirements\r\n\r\nI imagine you're making a general statement, but I suspect @bitcrazed is reasonably familiar with those \ud83d\ude42 \r\n\r\n\r\n",
      "created_at": "2020-06-17T03:55:26Z",
      "updated_at": "2020-06-17T04:01:30Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> are you aware of any other documentation (including 3rd party) that states otherwise?\r\n\r\nI don't think it's covered in the official documentation, but I've summarized the behavior and limitations in [this Stack Overflow answer](https://stackoverflow.com/a/42601912/45375); there's also [this one](https://stackoverflow.com/a/59779509/45375), which focuses on Unix-like platforms.\r\n\r\n>  I suspect @bitcrazed is reasonably familiar with those \ud83d\ude42\r\n\r\nWell, I wasn't, until I took a closer look: `wsl.exe` truly requires _individual_ arguments, and doesn't (also) support passing the pass-through shell command _as a single string_ (command line - except if you explicitly use `sh -c` / `bash -c`), which differs from `pwsh -c`, which accepts _either_ form (though I do consider that problematic - see https://github.com/PowerShell/PowerShell/issues/4024#issuecomment-311541803 and https://github.com/PowerShell/PowerShell/pull/3963#issuecomment-307392273).\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-06-17T06:30:21Z",
      "updated_at": "2020-07-12T21:31:11Z"
    },
    {
      "author": "bitcrazed",
      "author_association": "NONE",
      "body": "@mklement0 Yes, I am very familiar with shells and shell syntax.\r\n\r\nThe problem is that the lack of an ability to delimit a portion of a command-line to be passed varbatim to the receiving command/script is something that trips users up all the time. \r\n\r\nThe stop parsing symbol (which, by the way is practically impossible to search for) is [only documented here](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_parsing?view=powershell-5.1&redirectedfrom=MSDN) (as far as I could find) and states (emphasis mine):\r\n\r\n> When calling an executable program in PowerShell, place the stop-parsing symbol before the program arguments. **This technique is much easier than using escape characters to prevent misinterpretation.**\r\n>\r\n> When it encounters a stop-parsing symbol, PowerShell treats the remaining characters in the line as a literal. The only interpretation it performs is to substitute values for environment variables that use standard Windows notation, such as %USERPROFILE%.\r\n>\r\n> The stop-parsing symbol is effective only **until the next newline or pipeline character**. You cannot use a continuation character (`) to extend its effect or use a command delimiter (;) to terminate its effect.\r\n\r\nThis is a perfect example of why I believe we need some kind of enclosure, rather than expecting users to escape their command-line actions correctly: Stop parsing up until some incorrectly/poorly documented arbitrary char/sequence seems to defeat the point of \"stop parsing\".\r\n\r\nPowerShell is awesome, but has some major impediments and barriers to adoption that need attention. Heck, this issue tripped-up me (owner of Cmd, PM for WSL & Terminal) and @SteveL-MSFT (owner of PowerShell) in an interactive WTH session yesterday afternoon.\r\n\r\nAnd this isn't just an issue that affects WSL: It also affects Windows Terminal's `wt` command-line invocations, and many other tools. Expecting users to jump through hoops to figure out that they have to manually escape complex commands is only going to perpetuate the belief of many that PowerShell is hostile to interactive use and will drive people away from using it for this purpose (see [this thread for examples](https://twitter.com/richturn_ms/status/1265155820083240962)). Which would be a dreadful shame.",
      "created_at": "2020-06-17T18:02:38Z",
      "updated_at": "2020-06-17T18:02:38Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@bitcrazed \r\n\r\n>  Yes, I am very familiar with shells and shell syntax.\r\n\r\nThen you are undoubtedly familiar with the need to escape or quote the calling shell's metacharacters if you want to _pass them through_ (use them _verbatim_).\r\n\r\nDoing so gives us the aforementioned solution:\r\n\r\n```powershell\r\nPS> wsl cd / '&&' ls . '|' cat -n\r\n# Alternative, with escape char.\r\nPS> wsl cd / `&`& ls . `| cat -n\r\n```\r\n\r\nIncidentally, you would in essence _normally_ have to do the same if you called from `cmd.exe` (the only difference being the need for _double_ quoting) - but, as it turns out - that _doesn't even work_ in this case, because of how `wsl.exe` parses the command line:\r\n\r\n```cmd\r\n:: BREAKS! because `wsl` apparently doesn't strip the double quotes and `bash` sees them\r\n:: verbatim - yet you need the double quotes in order to pass && and | through.\r\nC:\\>wsl cd / \"&&\" ls . \"|\" cat -n\r\n```\r\n\r\nHowever, using the escape character (`^` in `cmd`'s case) works: `wsl cd / ^&^& ls . ^| cat -n`\r\n\r\n**`--%` was specifically introduced for verbatim reuse of command lines written for `cmd.exe`, i.e. for accommodating the syntax _of a different shell_.**\r\n\r\n**This invariably entailed problematic compromises, and, in my opinion, `--%` should never have been implemented.**\r\n**Now that PowerShell is cross-platform, `--%` is even more problematic**, because you cannot (meaningfully) use it with command lines written for `bash` / `sh` (POSIX-like shells) - no support for single-quoted strings, no support for globbing and other shell expansions, no support for interpreting something such as `$HOME` as an (environment) variable.\r\n\r\nFocusing just on the `cmd.exe`-related compromises:\r\n\r\n* no ability to reference _PowerShell_ variables and expressions on the command line\r\n* no ability to use _redirections_ \r\n* focused on a _single_ command - which is why parsing stops at `|` (and therefore `||`) and `&&` (even though the latter wasn't even implemented at the time) - though _not_ at `;`\r\n  * Yes, the documentation is lacking; I've created https://github.com/MicrosoftDocs/PowerShell-Docs/issues/6149 to suggest fixing this.\r\n\r\n---\r\n\r\n**The underlying challenge is that PowerShell has _additional_ metacharacters, and that one of them - the escape character - differs from that of legacy shells.**\r\n\r\n* With the exception of `\\` vs. `` ` ``, which is an unfortunate consequence of the historical decision to use `\\` in paths on Windows), these additional metacharacters are the unavoidable price to pay for the added power and flexibility of the PowerShell command line (splatting, expressions in `(...)`, array literals, hash table literals, ...)\r\n\r\n  * If you want to harness this power, there is simply no way around understanding PowerShell's unique syntax requirements.\r\n\r\n* This means that command lines _written for other shells_ cannot (generally) work - which is definitely unfortunate, but unavoidable.\r\n\r\nI've previously summarized the issue in https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-640711192, where I suggest an approach other than `--%`:\r\n\r\nThe introduction of a `Invoke-NativeShell` (`ins`) cmdlet that calls the platform-native shell with a single command string; use of a here-string, if needed, can be used to pass a command line verbatim.\r\n\r\nAs an aside: the linked issue is primarily about a truly broken aspect of PowerShell, which has to date not been fixed, because the fix would be a severe breaking change: how arguments with _embedded_ double quotes are passed to external programs.\r\n\r\n---\r\n\r\n**If `wsl.exe` (also) accepted a _single_ command string to effectively pass to the `-c` option of the user's WSL default shell (`bash`, by default) - which I think it should - a single-quoted [here-]string would be the simple solution to the problem**; if you know what the default shell is, you can therefore simply do:\r\n\r\n```powershell\r\n# OK - command string is passed through as a literal\r\nPS> bash.exe -c 'cd / && ls . | cat -n'\r\n```\r\n\r\nNote that you may optionally combine this approach with up-front interpolation by PowerShell, so as to embed PowerShell variables / expressions, via `\"...\"` - something that `--%` doesn't support.\r\n\r\nIn a manner of speaking, the single-quoted [here]-strings then provide the enclosure you're looking for.\r\n\r\nThis approach also allows you to call from `cmd.exe` (with double quotes):\r\n\r\n```cmd\r\n:: OK\r\nC:\\>bash.exe -c \"cd / && ls . | cat -n\"\r\n```\r\n\r\n\r\n---\r\n\r\nIn cases where you do need to pass arguments verbatim _individually_, PowerShell offers another method, albeit not a very convenient one: _array-based splatting_:\r\n\r\n```powershell\r\n# OK\r\nPS> wsl ('cd', '/', '&&', 'ls', '.', '|', 'cat', '-n')\r\n```\r\n\r\nIn this _simple_ case you can ease the pain a bit, but it's not exactly obvious (and won't work with arguments with embedded spaces):\r\n\r\n```powershell\r\n# OK\r\nPS> wsl (-split 'cd / && ls . | cat -n')\r\n```\r\n\r\nHowever, I would expect that the far more typical case will be where calling the platform-native shell via a single command string is feasible, in which case `Invoke-NativeShell` or explicit invocation (e.g., `cmd /c '...'` or `sh -c '...'`) would work.\r\n\r\n---\r\n\r\nTo summarize:\r\n\r\n* PowerShell having additional metacharacters and a different escape character than other shells is unavoidable; the additional metacharacters give PowerShell its power and flexibility.\r\n\r\n* `--%` has always been problematic, and its lack of (meaningful) support on Unix-like platforms makes it even more so.\r\n\r\n* A cleaner alternative is to make calls to other shells explicit, via single-quoted [here-]strings, using `cmd /c '...'`, `sh -c '...'`, or - once implemented - `Invoke-NativeShell` / `ins` - or via an array constructed from single-quoted strings.\r\n\r\n* Separately, PowerShell's broken handling of embedded double quotes must be fixed - see #1995.\r\n\r\n---\r\n\r\nI definitely understand the pain of the issue, but I also think that `--%` isn't the answer - although fixing the docs should help.\r\n\r\nAs PowerShell grows in popularity, the differing syntax needs will become more widely known, and the pain of not knowing how to modify command lines written for other shells / not understanding why there is even a need to will lessen.\r\n\r\nTo me, the best we can do is:\r\n\r\n* Be clear in the docs (@sdwheeler just helpfully added two other links to https://github.com/MicrosoftDocs/PowerShell-Docs/issues/6149):\r\n   * Fix `about_Parsing`: https://github.com/MicrosoftDocs/PowerShell-Docs/issues/6149\r\n   * Introduce a conceptual help topic about calling external programs: https://github.com/MicrosoftDocs/PowerShell-Docs/issues/5152\r\n   * At least for now _document_ the broken handling of embedded `\"` chars: https://github.com/MicrosoftDocs/PowerShell-Docs/issues/2361 (the subject of #1995)\r\n\r\n* Implement the aforementioned `Invoke-NativeShell` (`ins`) cmdlet.\r\n\r\n\r\n ",
      "created_at": "2020-06-18T20:00:18Z",
      "updated_at": "2020-06-26T18:42:16Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "@bitcrazed \r\n>The problem is that the lack of an ability to delimit a portion of a command-line to be passed varbatim to the receiving command/script is something that trips users up all the time.\r\n\r\nWhat do you mean by \"portion of a command-line to be passed varbatim\"?\r\n\r\nDo you mean \r\n\r\n1. pass some sequence of characters verbatim to the called executable, such that the called executable has this sequence of characters in one element of its argument array (e.g. those characters are then available in `argv[1]` in [main](https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args?view=vs-2019#command-line-arguments))\r\n\r\nOr do you mean\r\n\r\n2. insert some sequence of characters verbatim into the [`lpCommandLine` parameter of `CreateProcess`](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw#parameters)\r\n\r\n---\r\n\r\nIf you mean (1.), then it essentially already works:\r\n```\r\nPS /home/User> /bin/echo 'cd / && ls . | cowsay'\r\ncd / && ls . | cowsay\r\nPS /home/User>\r\n```\r\n(Except for the problem of embedded quotes as discussed in https://github.com/PowerShell/PowerShell/issues/1995)\r\n\r\nOne could argue, that adding a one-line-here-string would improve some usecases, but I think, that's not really the point of this issue.\r\n\r\nAs this does already work more or less, I assume, you meant (2.)\r\n\r\n---\r\n\r\nIf you mean (2.), then let me state my opinion on that in a somewhat dramatic way:\r\n\r\nPlease please please don't add special syntax for this. This is basically what `--%` tried to do, which also should have never ever been implemented.\r\n\r\nWhy am I so strongly against this?\r\n\r\n1. It is a Windows only problem, so adding syntax would mean that powershell on Windows has different syntax than on Linux. (Or the syntax would be supported but is totally meaningless, as it is currently the case for `--%`)\r\n\r\n2. If the main commandline shell on Windows published by Microsoft adds a first-class feature (via special syntax opposed to via a cmdlet) to call executables that don't follow the typical [commandline parsing rules](https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args?view=vs-2019#parsing-c-command-line-arguments) (if the tool follows the typical rules, you don't need (2.), you can usually better use (1.)), then that encourages authors of command line tool, to not follow these rules, which only worsens the [\"Windows command line anarchy\"](https://stackoverflow.com/a/4094897/2770331). The less people follow the typical rules, the harder it is to programmaticly call external executables or generally write cross platform code, so I definitely think, that program authors should be encouraged to follow those typical rules.\r\n\r\n3. I strongly doubt, that this is a common use-case \r\n   >And this isn't just an issue that affects WSL: It also affects Windows Terminal's wt command-line invocations, and many other tools.\r\n   \r\n   Could you add some examples, where such problems occur? Because in case of WSL, I'd say that WSL's parsing of the commandline is simply [broken](https://github.com/Microsoft/WSL/issues/1746) (issue was about `bash.exe` but situation is by default not better with `wsl.exe`) in the default case - I'd consider every tool, that doesn't follow the typical [commandline parsing rules](https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args?view=vs-2019#parsing-c-command-line-arguments) broken, but WSL's default behavior is IMHO not even properly documented...\r\n\r\n   I said the \"default\" behavior of `wsl.exe` is broken - while writing this response, I noticed, that `wsl.exe` actually seems to behave as expected, when using `-e`:\r\n```\r\nPS C:\\> wsl -e bash -c 'cd / && ls . | cowsay'\r\n _______________________________________\r\n/ acct bin boot cache cygdrive data dev \\\r\n| etc home init lib lib64 lost+found    |\r\n| media mnt opt proc root run sbin snap |\r\n\\ srv sys tmp usr var                   /\r\n ---------------------------------------\r\n        \\   ^__^\r\n         \\  (oo)\\_______\r\n            (__)\\       )\\/\\\r\n                ||----w |\r\n                ||     ||\r\nPS C:\\>\r\n```\r\nSo the only thing missing for this explicit usecase is IMO a parameter to `wsl.exe` to call the default shell with the commandline arguments parsed as in any other normal exe.",
      "created_at": "2020-06-26T18:37:29Z",
      "updated_at": "2020-06-26T18:43:28Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": ">So, how about wrapping the args in quotes?\r\n<img src=\"https://user-images.githubusercontent.com/961950/84838712-f58e2700-afef-11ea-8014-3a2a9ee6603a.png\">\r\n\r\n>Doesn't work because that would make `arg[1]` `'cd / && ls . | cowsay'` which wouldn't make sense to bash.\r\n\r\nTo bash it actually makes perfect sense, to pass `cd / && ls . | cowsay` as `arg[2]`:\r\n```\r\n$ pwsh\r\nPowerShell 7.0.0\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\n\r\nhttps://aka.ms/powershell\r\nType 'help' to get help.\r\n\r\nPS /home/User> bash -c 'cd / && ls . | cowsay'\r\n _______________________________________\r\n/ acct bin boot cache cygdrive data dev \\\r\n| etc home init lib lib64 lost+found    |\r\n| media mnt opt proc root run sbin snap |\r\n\\ srv sys tmp usr var                   /\r\n ---------------------------------------\r\n        \\   ^__^\r\n         \\  (oo)\\_______\r\n            (__)\\       )\\/\\\r\n                ||----w |\r\n                ||     ||\r\nPS /home/User>\r\n```\r\nIt's not bash that can't cope with `cd / && ls . | cowsay` as an argument but `wsl.exe`.",
      "created_at": "2020-06-26T19:19:06Z",
      "updated_at": "2020-06-26T19:19:06Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "If https://github.com/PowerShell/PowerShell/issues/13068 was implemented (and I hope it will not - at least not as yet another spedial syntax/operator), I guess this issue would be resolved with that.",
      "created_at": "2020-07-02T19:45:08Z",
      "updated_at": "2020-07-02T19:45:08Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> It's not bash that can't cope with `cd / && ls . | cowsay` as an argument but `wsl.exe`.\r\n\r\n`wsl.exe` does the right thing here, although it should be noted that in order to achieve that result, it uses nonstandard command line processing.  We would not expect single quotes to work this way for a Windows program.",
      "created_at": "2020-07-12T21:21:19Z",
      "updated_at": "2020-07-12T21:21:19Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@TSlivede's point was that you currently cannot pass the meant-for-`bash` command line _as a single argument_ to `wsl.exe`, which would make the most sense. \r\n\r\nAside from that, `wsl.exe` does _not_ itself recognize `'...'` quoting - it is PowerShell that translates _its_ `'...'` quoting into `\"...\"` quoting _behind the scenes_ (You'll see that true `'...'` quoting doesn't work if you call `wsl 'cd / && ls . | cat -n'`  _from `cmd.exe`_).\r\n\r\n(Recognizing `'...'`-quoting on Windows is definitely _unusual_ (`ruby` supports it, for instance), but you cannot call it _nonstandard_, because _there is no standard_, only widely adhered-to conventions. It is ultimately up to _each executable_ to define the rules - that's the anarchy that is argument-passing on Windows).",
      "created_at": "2020-07-12T21:57:48Z",
      "updated_at": "2020-07-12T21:57:48Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> @TSlivede's point was that you currently cannot pass the meant-for-`bash` command line _as a single argument_ to `wsl.exe`, which would make the most sense.\r\n\r\n`wsl.exe` does not support passing the command line for `bash` as a single argument.  This is by design.\r\n\r\n> Arguments to run Linux binaries:\r\n> \r\n>     If no command line is provided, wsl.exe launches the default shell.\r\n> \r\n>     --exec, -e %CommandLine%\r\n>         Execute the specified command without using the default Linux shell.\r\n> \r\n>     --\r\n>         Pass the remaining command line as is.\r\n\r\nMy understanding is that `--` means \"Here be dragons\"  and the spell `WSL -- -c \"cd / && ls . | cowsay\"` should work.  It does not\u2014but it is not our problem.\r\n",
      "created_at": "2020-07-13T06:05:41Z",
      "updated_at": "2020-07-13T16:46:16Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> This is by design.\r\n\r\nBy _limiting_ design, because not only would passing the command line as a single string ease the escaping woes that prompted this issue, it would allow full access to `bash`'s CLI. For instance:\r\n\r\n```sh\r\n# Note: The following does NOT work with `bash.exe` on Windows, but works *from inside WSL*\r\n# (and from POSIX-like shells on Unix-like platforms)\r\n$ bash -c 'echo $# args; printf \"%s!\" $@' - one two\r\n2 args\r\none!two!\r\n```\r\n\r\nThat is, `bash` expects the 1st argument following `-c` to be the _ad-hoc script_ (command line) to execute, with all subsequent arguments to be passed _to that ad-hoc script_ (via `$*`/ `$@`), as _verbatim_ arguments, starting with `$0`(!).\r\n\r\n**Neither `wsl.exe` nor `bash.exe`  support such invocations**, albeit for different reasons: `wsl.exe` doesn't permit passing the ad-hoc script as a distinct argument - _all_ arguments become the ad-hoc script - whereas while `bash.exe`  with `-c` does accept the first argument as a command line / ad-hoc script, it seemingly ignores all remaining arguments (unlike true Unix `bash` executables).\r\n\r\n---\r\n\r\nNote that, by contrast, with `-e`  it _is_ appropriate to use _individual_ arguments, because then by definition _no shell_ is involved, and it is the _calling_ shell's responsibility (PowerShell, in our case) to parse the arguments.\r\n\r\n---\r\n\r\n`--` is again designed for _individual_ arguments, to unambiguously mark the start of the arguments to pass through to `bash`. Given that all of `wsl.exe`'s _own_ options must be specified _before_ the pass-through command parts anyway, this is probably rarely, if ever needed:\r\n\r\nHypothetically, if you had a command named, say, literally `-u` available in your `bash` session, you'd need to invoke it with `wsl.exe -- -u`, but _that doesn't actually work_, because ~~`wsl.exe` seemingly _ignores_ such command names _except if they are quoted_~~ (`wsl.exe -- -u` fails with `/bin/bash: -c: option requires an argument`) \r\n\r\n_Update_: It is `bash` itself that doesn't recognize `-u` as a command in this case, and the proper solution is to use \r\n`bash -c -- -u`, which, however, can _not_ be called as the seemingly equivalent `wsl.exe -- -- -u` - see [below](https://github.com/PowerShell/PowerShell/issues/12975#issuecomment-657725913).",
      "created_at": "2020-07-13T15:59:24Z",
      "updated_at": "2020-08-26T18:37:41Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "`wsl.exe -- -u` does not work because the spell `bash -c '-u'` is invalid according to `bash` itself.  `wsl.exe` does not eat up anything.  `wsl.exe -- command -- -u` is what you want to cast.  See, ma\u2019am, no quotes! \ud83d\ude0d\r\nYour other use case is covered by `wsl.exe -- set one two ^&^& echo $# args ^&^& printf %s! $@`.\r\nI agree that what happens after `wsl.exe --` defies common sense.  But it is workable\u2014and it is not our problem.\r\n\r\n\r\n",
      "created_at": "2020-07-13T17:15:29Z",
      "updated_at": "2020-07-13T17:15:29Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> `wsl.exe -- -u` does not work because the spell `bash -c '-u'` is invalid according to bash itself.\r\n\r\nGood point, I've also corrected the comment above. The reason is that `bash` cannot tell what was _originally_ quoted, in the context of the _calling_ shell; both `bash -c -u` and `bash -c '-u'` (on Unix) result in `bash` seeing the _same_ two verbatim arguments: `-c` and `-u`.\r\n\r\nHowever, `bash` itself also supports `--` as a disambiguation mechanism (as all POSIX-compatible CLIs should): what follows it is an _operand_, even if it _looks_ like an option; therefore, it is the following form that works and is simplest (no quoting needed (also works with `bash.exe`):\r\n\r\n```sh\r\n# The proper way to make bash treat -u as an operand (the script), not as an option.\r\nbash -c -- -u\r\n```\r\n\r\nAlas, this again _doesn't_ work via `wsl.exe` (_update_ - see [below](https://github.com/PowerShell/PowerShell/issues/12975#issuecomment-657729358) for the reason):\r\n\r\n```sh\r\nPS> wsl.exe -- -- -u\r\n/bin/bash: --: invalid option\r\n```\r\n\r\nSo, yes, your _workaround_ via the `command` Bash builtin is required.\r\n\r\nSimilarly:\r\n\r\n> Your other use case is covered by `wsl.exe -- set one two ^&^& echo $# args ^&^& printf %s! $@`\r\n\r\nKudos for figuring out a _workaround_.\r\n\r\n---\r\n\r\nI'm pretty sure we're on the same page, but just to spell it out: \r\n\r\nThese workarounds are (a) far from obvious and (b), more importantly, _shouldn't be necessary_.\r\n\r\nThe problems discussed are the problems of `wsl.exe` and `bash.exe` _themselves_, not PowerShell.\r\n\r\nThe proper solution is to allowing passing of an ad-hoc script / command line _as a single string_, while also supporting additional arguments to pass to the former.\r\n\r\nIn concrete terms, without breaking backward compatibility, this could mean:\r\n\r\n* Add a `-c` option to `wsl.exe` that behaves as `bash -c` does (and other major POSIX-compatible shells do).\r\n\r\n* Make `bash.exe` with the `-c` option properly pass _additional_ arguments to the ad-hoc script (first argument).\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-07-13T18:41:28Z",
      "updated_at": "2020-09-03T20:51:35Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> Alas, this again _doesn't_ work via `wsl.exe` (not sure why)\r\n\r\n`wsl.exe -- -- -u` invokes `bash -c '-- -u'`, which is equivalent to `bash -c -- '- ' -- -u`.\r\n",
      "created_at": "2020-07-13T18:48:30Z",
      "updated_at": "2020-07-13T18:48:44Z"
    },
    {
      "author": "AndrewMD5",
      "author_association": "NONE",
      "body": "Reading through this issue is bittersweet. At first I was glad to see I wasn\u2019t alone in getting tripped up in the idiosyncratic way PowerShell approach argument; but I\u2019m saddened that years later this is still fundamentally broken. It\u2019s maddening the hoops one has to jump through just to pass arguments.",
      "created_at": "2022-04-02T06:13:25Z",
      "updated_at": "2022-04-02T06:13:25Z"
    },
    {
      "author": "Luiz-Monad",
      "author_association": "NONE",
      "body": "> Reading through this issue is bittersweet. At first I was glad to see I wasn\u2019t alone in getting tripped up in the idiosyncratic way PowerShell approach argument; but I\u2019m saddened that years later this is still fundamentally broken. It\u2019s maddening the hoops one has to jump through just to pass arguments.\r\n\r\nYou can pick either this. https://github.com/mklement0/Native\r\nOr this (I like this more, it makes stupid native programs become cmdlets, and we all love cmdlets) https://petri.com/microsoft-launches-powershell-crescendo-tool/\r\nI also made this (for redirecting streams as strings, its faster)  https://github.com/Luiz-Monad/PowershellProcess\n\n<blockquote><img src=\"https://opengraph.githubassets.com/5cf326a411db84b2a71c89f55c0d61816fbe62e85f92a066f16921ec34e53572/mklement0/Native\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/mklement0/Native\">GitHub - mklement0/Native: PowerShell module for native-shell and external-executable calls.</a></strong></div><div>PowerShell module for native-shell and external-executable calls. - GitHub - mklement0/Native: PowerShell module for native-shell and external-executable calls.</div></blockquote>\n<blockquote><img src=\"https://petri-media.s3.amazonaws.com/2022/02/PowerShell-Hero-Approved.png\" width=\"48\" align=\"right\"><div><strong><a href=\"https://petri.com/microsoft-launches-powershell-crescendo-tool/\">Microsoft's PowerShell Crescendo Facilitates Native Command Wraps</a></strong></div><div>Microsoft announced that PowerShell Crescendo has hit general availability (GA) this month. The new open-source module first launched in preview back in 2020, and it lets developers quickly build PowerShell cmdlets that leverage existing command-line tools. The Redmond giant explains that native ...</div></blockquote>\n<blockquote><img src=\"https://opengraph.githubassets.com/73018a5bf2abe469bf44f6f23816fa56fa6284390e7aec4a85bd85b207d9796e/Luiz-Monad/PowershellProcess\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/Luiz-Monad/PowershellProcess\">GitHub - Luiz-Monad/PowershellProcess</a></strong></div><div>Contribute to Luiz-Monad/PowershellProcess development by creating an account on GitHub.</div></blockquote>",
      "created_at": "2022-10-29T02:26:22Z",
      "updated_at": "2022-10-29T02:26:24Z"
    },
    {
      "author": "mcuee",
      "author_association": "NONE",
      "body": "Referece: I belive I hit the same issue here.\r\n* https://github.com/avrdudes/avrdude/issues/1169\r\n\r\nPowerShell should not act smart and pass the incorrect args. You can see that it splits `-B0.5` to `-B0` and `.5` which is totally wrong.\r\n\r\n```\r\nPS C:\\work\\avr\\avrdude_test\\avrdude_bin> .\\avrdude_arg -c stk500v2 -P COM5 -B0.5 -p m8a\r\narg 0: \"C:\\work\\avr\\avrdude_test\\avrdude_bin\\avrdude_arg.exe\"\r\narg 1: \"-c\"\r\narg 2: \"stk500v2\"\r\narg 3: \"-P\"\r\narg 4: \"COM5\"\r\narg 5: \"-B0\"\r\narg 6: \".5\"\r\narg 7: \"-p\"\r\narg 8: \"m8a\"\r\navrdude_arg error: invalid bit clock period specified '0\r\n\r\n```\r\n\r\nIt does work if I use `-B\"0.5\"`.",
      "created_at": "2022-11-06T10:20:10Z",
      "updated_at": "2022-11-06T10:26:52Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@mcuee, that is one of several _bugs_ in the parameter binder, and as such a separate issue (the workaround here is to pass `'-B0.5'`); see the following issues:\r\n\r\n* https://github.com/PowerShell/PowerShell/issues/6291\r\n* All such issues: https://github.com/PowerShell/PowerShell/issues?q=is%3Aissue+is%3Aopen+parameter+parsing%2Fpassing+in%3Atitle\n\n<blockquote><img src=\"https://repository-images.githubusercontent.com/49609581/aad0ad80-cdec-11ea-8248-a37bc0571bfd\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/PowerShell/PowerShell\">Issues \u00b7 PowerShell/PowerShell</a></strong></div><div>PowerShell for every system! Contribute to PowerShell/PowerShell development by creating an account on GitHub.</div></blockquote>",
      "created_at": "2022-11-06T13:22:09Z",
      "updated_at": "2022-11-06T13:22:11Z"
    }
  ],
  "created_at": "2020-06-17T00:07:02Z",
  "number": 12975,
  "state": "open",
  "title": "PowerShell should support passing verbatim args",
  "updated_at": "2022-11-06T13:22:11Z"
}