{
  "_url": "https://github.com/PowerShell/PowerShell/issues/13068",
  "author": "SteveL-MSFT",
  "body": "## Problem Statement\r\n\r\nCurrently, there are cases where cutting and pasting a native command line fails to run as expected in PowerShell.  This may be due to incorrect parsing of quotes meant to be passed to the native command or use of PowerShell syntax that is not meant to be interpreted as PowerShell.  PowerShell has a `--%` special argument when used with native commands treats the rest of the arguments as literals passed to the native command, but has several issues:\r\n\r\n1. It is not discoverable, users need to know about this special parameter ahead of time\r\n2. `|`, `&&`, and `||` take precedence, so: `wsl --% ls | less` would execute `wsl ls` and pipe the results to `less` running in PowerShell rather than `less` running in wsl\r\n3. If you cut and paste a command line, you would need to edit the line to insert `--%` towards the beginning\r\n4. On Unix systems, the args after --% are passed verbatim w/o globbing where native commands on Unix expect the shell to perform globbing\r\n\r\n## Proposed technical implementation details\r\n\r\nProposal is to introduce a new `--%` (Call Native) operator.\r\n\r\nAny text content after this operator will call into the \"default shell\" of the OS to execute.  On Windows, this would be cmd.exe and on Unix-based systems this would be /bin/sh.  This resolves the globbing issue on Unix-based systems, and also allow `%variable%` expansion on Windows.  Unlike `--%` switch, this also means that `|`, `&&`, and `||` are treated as part of the native command line.\r\n\r\nThis means that these two are functionally the same:\r\n\r\n```powershell\r\nwsl --% ls $foo `&`& echo $PWD\r\n```\r\n\r\n```powershell\r\n--% wsl ls $foo && echo $PWD\r\n```\r\n\r\nwhere `$foo` and `$PWD` is evaluated by the shell within WSL.  Note that in the first example, you would have to know to escape `&&` to have it execute within WSL instead of within PowerShell.\r\n\r\nTo pipe output from such execution back into PowerShell, the user is required to store the results into a variable first:\r\n\r\n```powershell\r\n$out = --% ls *.txt\r\n$out | select-string hello\r\n```\r\n\r\nNote that unlike the current `&` call operator, you cannot use any PowerShell syntax, so:\r\n\r\n```powershell\r\n--% $commandline\r\n```\r\n\r\nwould not resolve `$commandline` as a variable first by PowerShell, but instead pass `$commandline` to the default shell to process unresolved.\r\n\r\nThe cut & paste problem is solved by simply pasting after `--% ` is typed.\r\n\r\nThe above example for wsl would look like:\r\n\r\n```powershell\r\n--% wsl ls | less\r\n```\r\n\r\nwhere the intent is to have that whole line execute within the WSL Linux instance.\r\n\r\n## Discoverability\r\n\r\nUsers already familiar with `--%` as a switch may easily transition to using this new operator where it makes sense.  For new users, `--%` is unique so that search engines find it easily related to PowerShell.\r\n\r\n## Alternate Considerations\r\n\r\n`&!` and `&n` were proposed as the sigil, but there was push back because `&!` is a valid operator in some languages making a web search for documentation more difficult.  There was also a concern whether visual similar to `&` call operator would be confusing to users.\r\n\r\nThere is question about supporting line-continuation when using this new operator.  I would suggest that we do not support it initially.\r\n\r\nA cmdlet solution instead of an operator solution was proposed.  We believe this doesn't solve the \"cut & paste\" problem as now you need to know to put the pipeline in single quotes and/or escape special characters.  We do believe a cmdlet as in `Invoke-NativeCommand` (noun to be determined) would be useful as an additional option instead of replacing the need for an operator.\r\n\r\n## Related issues\r\n\r\nThis should also solve these issues:\r\n\r\nhttps://github.com/PowerShell/PowerShell/issues/12491\r\nhttps://github.com/PowerShell/PowerSHell/issues/1761\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "essentialexch",
      "author_association": "NONE",
      "body": "I like the idea and find it useful, but think it would be far more useful (I'm thinking specifically in the case of a DSL) if I can get a single string expansion. So if I've built a cmd.exe compatible string in my PS, I have a way to string verbatim to cmd.exe. Perhaps\r\n\r\n`&n -command $string\r\n`\r\n\r\nThat would potentially also let me specify my interpreter:\r\n\r\n`&n -shell /bin/sh -command $string\r\n`\r\nor\r\n`&n -shell cmd.exe -command $string\r\n`\r\n\r\nin terms of the name/operator, is \"&!\" in use? That has similarity to shbang( \"#!\" ).",
      "created_at": "2020-06-30T21:24:59Z",
      "updated_at": "2020-06-30T21:24:59Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "`$!` is a good suggestion!\r\n\r\nThe shell can be specified by simply specifying it as the command:\r\n\r\n`&! /bin/sh -c blah`\r\n\r\nThe `$var` expansion creates a problem in that `$` may need to be literal to be passed to the native command/shell.  One of the problems this tries to avoid is when people need to figure out how to properly escape everything.  If you require variable expansion, you could always do:\r\n\r\n```powershell\r\n$mycommand = \"/bin/sh ls\"\r\nInvoke-Expression \"&! $mycommand\"\r\n```\r\n\r\nHowever, in cases where you want to mix PowerShell with the native command, it's probably best to use the current syntax and just be aware of what needs to be escaped properly as I would consider that advanced usage.",
      "created_at": "2020-06-30T21:31:50Z",
      "updated_at": "2020-06-30T21:31:50Z"
    },
    {
      "author": "essentialexch",
      "author_association": "NONE",
      "body": "> ```powershell\r\n> $mycommand = \"/bin/sh ls\"\r\n> Invoke-Expression \"&! $mycommand\"\r\n> ```\r\n\r\nI can't believe you just suggested iex. :-)",
      "created_at": "2020-06-30T21:35:17Z",
      "updated_at": "2020-06-30T21:35:17Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@essentialexch there are a few times where it's appropriate :)\r\n\r\nNote that in the example, expectation is that the user properly validated the contents of `$mycommand` before executing!",
      "created_at": "2020-06-30T21:36:08Z",
      "updated_at": "2020-06-30T21:36:44Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "Great writeup and a solution for problems like the one you described are definitely needed.\r\nI myself didn't know about `--%` and don't remember ever seeing it unfortunately. Therefore the proposed `&n` operator might suffer from similar discoverability problems and it doesn't look natural to me to combine a symbol with a character (and it reminds me of %f in C printf statements). Since it's a breaking change anyway Is there a reason why it couldn't be for example `&&`?\r\nMaybe it would me more intuitive to use something like brackets (or double braces?) to mark the area that you want to execute. Example: `& [ wsl ls ] | less`",
      "created_at": "2020-06-30T21:44:56Z",
      "updated_at": "2020-06-30T21:44:56Z"
    },
    {
      "author": "JustinGrote",
      "author_association": "CONTRIBUTOR",
      "body": "I agree `&!` is the more intuitive way to go for those coming from other shells, however in super-duper-linter I am usually running native commands by building a parameter array and then splatting it to the command.\r\n```\r\n$command = 'linter'\r\n$myargs = @(\r\n    '-config'\r\n    'linterconfig.path'\r\n)\r\nif ($Test) {$myargs += 'test'}\r\n& $command @myargs\r\n```\r\n\r\nSo this is the best way in case of conditional and whatnot for me",
      "created_at": "2020-06-30T21:48:36Z",
      "updated_at": "2020-06-30T21:48:36Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@bergmeister I originally thought of `&&` as visually it's similar to `&` which many people know today.  However, `&&` being a pipeline chain operator may cause confusion about what it is supposed to do.  I like the `&!` suggestion currently.",
      "created_at": "2020-06-30T21:52:55Z",
      "updated_at": "2020-06-30T21:52:55Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@JustinGrote, there's no reason to not continue to use that.  the `&!` syntax is really for cases where you just want to cut and paste or have some args that conflict with PowerShell syntax and don't want to or don't know how to escape properly",
      "created_at": "2020-06-30T21:54:29Z",
      "updated_at": "2020-06-30T21:54:29Z"
    },
    {
      "author": "oising",
      "author_association": "CONTRIBUTOR",
      "body": "Oh man, I remember having discussions with Bruce and Jason about this a decade ago. My gut feeling is that inventing another operator seems unnecessary here. I know that some people on this thread have not heard about `--%` but I'll wager than there are more than you think. What's wrong with:\r\n\r\n```powershell\r\n# run ls in wsl, return results to powershell, then pipe to wsl again, to grep.\r\n& wsl ls | wsl grep -i \"foo\"  \r\n\r\n#  the entire pipeline right of wsl will run in wsl. \r\n& --% wsl ls | grep -i \"foo\"\r\n```\r\n\r\nWhy hasn't anyone suggested this? It's logically consistent with usage of `--%` elsewhere to say \"everything after this is to be passed without special powershell treatment.\"\r\n",
      "created_at": "2020-06-30T23:50:03Z",
      "updated_at": "2020-07-01T00:31:11Z"
    },
    {
      "author": "JustinGrote",
      "author_association": "CONTRIBUTOR",
      "body": "@oising well for one, that command doesn't work because you have to preface it with the command you want to run, are you suggesting adding the functionality?\r\n![image](https://user-images.githubusercontent.com/15258962/86188362-3fe4cd00-baf3-11ea-966f-1c34ad5909c9.png)\r\n\r\nThis kinda does what is expected:\r\n`function Invoke-LiteralCommand ($command) {Invoke-Expression \"& $command --% $args\"}`\r\n\r\n`Invoke-LiteralCommand ping -W 200 www.google.com | grep icmp`",
      "created_at": "2020-07-01T00:04:49Z",
      "updated_at": "2020-07-01T00:04:49Z"
    },
    {
      "author": "oising",
      "author_association": "CONTRIBUTOR",
      "body": "@JustinGrote  Yes, I know it doesn't work now :) I am suggesting that _instead_ of `&n` or `&!` or whatever else is being talked about. It just makes more sense to me: `&` is call and `--%` is suppress powershell parsing; together they are coherent and more discoverable than adding something new. I don't like the idea of having a \"call\" and a \"call native\" operator. \r\n\r\nI've expanded my example to show the differences.",
      "created_at": "2020-07-01T00:25:48Z",
      "updated_at": "2020-07-01T00:30:45Z"
    },
    {
      "author": "JustinGrote",
      "author_association": "CONTRIBUTOR",
      "body": "@oising I'd be cool with that over a new operator, though that is a lot of obtuse typing for \"new powershell user who knows bash\" which is what I assume this would be meant for.",
      "created_at": "2020-07-01T01:03:25Z",
      "updated_at": "2020-07-01T01:03:25Z"
    },
    {
      "author": "essentialexch",
      "author_association": "NONE",
      "body": "> @oising I'd be cool with that over a new operator, though that is a lot of obtuse typing for \"new powershell user who knows bash\" which is what I assume this would be meant for.\r\n\r\nNot at all. It's for the PowerShell user that doesn't understand the complex quoting rules between PowerShell/cmd.exe/bash. As the issue title says \"call native\", for calling native executables.",
      "created_at": "2020-07-01T01:08:34Z",
      "updated_at": "2020-07-01T01:08:34Z"
    },
    {
      "author": "oising",
      "author_association": "CONTRIBUTOR",
      "body": "> > @oising I'd be cool with that over a new operator, though that is a lot of obtuse typing for \"new powershell user who knows bash\" which is what I assume this would be meant for.\r\n> \r\n> Not at all. It's for the PowerShell user that doesn't understand the complex quoting rules between PowerShell/cmd.exe/bash. As the issue title says \"call native\", for calling native executables.\r\n\r\nTrue, or for those of us who'd rather not have to think about them at all.",
      "created_at": "2020-07-01T01:16:15Z",
      "updated_at": "2020-07-01T01:16:15Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Yeah I'm with @oising. This concept exists, it's just woefully insufficient. If we're going to implement something completely new we're better off deprecating/removing the old syntax. \r\n\r\nI feel oftentimes these ideas are voiced, not enough weight is given to their actual target demographic. If users are _already_ struggling to find the existing methods, **and** finding the existing methods lacking when they are found, it's a call to a) improve documentation, and b) improve the actual functionality of the existing operators.\r\n\r\nInstead we get a weird option c) which is supposed to somehow address the past issues whilst introducing yet _another_ operator which is relying on documentation which is **already** not accessible enough for users to find it naturally.\r\n\r\nI agree that error messages and/or the suggestions system should be used to help introduce these concepts. I don't agree that we need a third? fourth? fifth? (I've literally lost count, someone help me out here) way to invoke commands. The existing methods are insufficient -- that means we should _improve_ them, not leave them behind like cobwebs to confuse users further when they start digging into them.\r\n\r\nThe first question I tend to get when people realise there's 5 ways of doing something is \"why are there 2-3 ways that literally do the same thing but don't work as well\", and my answer is as it always has been -- the PS team is _way_ too focused on making sure everything from the past decade++ still works, when trying to add/improve functionality. Here we see it again, we have existing but insufficient implementations that need revision and improvement, and the solution proposed is to further muddy the pool by adding another potentially incomplete implementation.\r\n\r\nWe should be finishing what we start, not starting another implementation all over again, IMO.",
      "created_at": "2020-07-01T01:48:54Z",
      "updated_at": "2020-07-01T01:48:54Z"
    },
    {
      "author": "romero126",
      "author_association": "CONTRIBUTOR",
      "body": "I believe if we are going to be using & for more than a few Unique use cases we should start thinking about making this considered a verb or look at standardization across the language. \r\n\r\nThe last thing I would want is confusion about what & is meant to do. In its entirety.\r\n",
      "created_at": "2020-07-01T01:50:53Z",
      "updated_at": "2020-07-01T01:50:53Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I'd consider 3 scenarios:\r\n1. Full expansion - current PowerShell behavior.\r\n2. Full literal - that is proposed in the OP.\r\n3. Partial expansion - `wsl ls $path` still works\r\n\r\nI wonder where @mklement0 comments? :-)",
      "created_at": "2020-07-01T05:37:07Z",
      "updated_at": "2020-07-01T05:37:40Z"
    },
    {
      "author": "peppekerstens",
      "author_association": "NONE",
      "body": "At start of reading this thread I thought; great idea! But after reading comments it started me thinking. I have always found the & command  'not PS standards worthy\" and something reminding me of 'PERL days' (ugh). Introducing another non-standard PS command (not being noun-verb) will not help. Certainly not those less savvy at PS.\r\n\r\nI did not know about the --% parameter either. I use the same principle as @JustinGrote as a solution. \r\n\r\nCutting/pasting commands into PS shell has never been my main 'thing'.\r\nWould we not be better of replacing those native commands with PowerShell one's?\r\nMake path for replacing cmd.exe entirely...\r\n\r\nI vote for exploring improving existing commands. And - indeed - improving some documentation on --% and & usage\r\n\r\n@iSazonov the use case @SteveL-MSFT is proposing is the 'cut paste' scenario. Partial expansion would make things much more difficult I think (on the AST side of things)",
      "created_at": "2020-07-01T05:37:54Z",
      "updated_at": "2020-07-01T05:52:45Z"
    },
    {
      "author": "SP3269",
      "author_association": "NONE",
      "body": "Immediately though of \u201c#!\u201d and then \u201c!#\u201d. Liking the \u201c&!\u201d.",
      "created_at": "2020-07-01T06:46:30Z",
      "updated_at": "2020-07-01T06:46:30Z"
    },
    {
      "author": "romero126",
      "author_association": "CONTRIBUTOR",
      "body": "We can probably look at adding token accelerators to function calls in the tokenizer. This would allow for the use of the following.\r\n\r\nIex -l \r\nOr Invoke-Expression -literal that stops parsing before passing up.\r\n\r\nI feel adding more unique tokens at the parsing level makes the barrier to entry go up and discoverability for this feature goes down.\r\n\r\nGet-Help & for example doesn't show up with anything.  And we have to look for it in about_Operators.\r\n\r\nHowever there are unique cases for the call_operator that doesn't get documented.\r\n& modulename { command }\r\nallows you to scope into a module. And I am certain there are more. But the discoverability on it is so low that it becomes difficult to find within the native documentation. And the community knows about it only through JSnover and a talk he gave showing us cool things.\r\n\r\nI believe whatever is decided on it needs to fully take into account how discoverable this \"feature\" is, from a new user perspective and keep in mind that newer users will try to use this on Powershell 5 not without knowing its new to pwsh core if the discoverability is too low.\r\n \r\n\r\n\r\n",
      "created_at": "2020-07-01T08:56:45Z",
      "updated_at": "2020-07-01T08:56:45Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "I'd love us to change the existing behaviour, but changing such a fundamental API in PowerShell would just break so many things. We could possibly consider migrating over with a configuration.\r\n\r\nBreaking things more directly might once have been possible before PS 6 went GA, but honestly, even then it would have been a serious threat to backward compatibility (not unlike Python's `print()` function).\r\n\r\nIn terms of passing arguments to subprocesses, I think both synchronous invocation and `Start-Process` invocation already have storied issues discussing an overhaul, and my feeling is that both need investing in at once for consistency. Start-Process in particular needs to update its support of passing an array of arguments.\r\n\r\nFor synchronous invocation with cmdline arg passing, I see four kinds of argument passing possible:\r\n\r\n- Current behaviour, which would become legacy, which is subject to `CommandLineToArgvW` on Windows and has unexpected results\r\n- Default behaviour, that should pass arguments by their expression value but apply the usual bareword token rules, so that things like `>` and `|` separate commands. In this mode, the value a subprocess takes from the expression should be what is displayed by `Write-Host $val`\r\n- Verbatim behaviour, where all tokens are interpreted as bareword strings until the escape token is seen. This is what `--%` is supposed to do today, but ideally would have only one end token that can be embedded on the same line like `--% ... %--`\r\n- Bash readline behaviour, where an alternate, sh-oriented escaping logic is applied, allowing simpler compatibility\r\n\r\nI think the first behaviour should be slowly phased out by introducing the second as an experimental feature and then swapping them.\r\n\r\nThe second and third behaviours could have their own sigils like `&!` and `&#` or perhaps `+% ... -%` or something. But for the verbatim mode, I think an important facet would be simplifying the escape token so that more tokens are taken verbatim. Similar to a heredoc.",
      "created_at": "2020-07-01T22:15:56Z",
      "updated_at": "2020-07-01T22:19:19Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "If the request is only to address copy-paste scenario like \"Any text content after this operator will call into the \"default shell\" of the OS to execute.\" why do not say this explicitly by `shell`? \r\n```powerhell\r\nPS> shell wsl ls | less\r\nPS> (shell wsl ls *.txt) | Select-String Hello\r\n\r\nIt is more discoverable and readable than cryptic operators in Forth/APL style.",
      "created_at": "2020-07-02T05:04:14Z",
      "updated_at": "2020-07-02T05:04:14Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "I absolutely don't see how this would resolve #1995: See https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-653174261\r\n\r\nAlso, the problem with WSL is a problem of the behavior of `wsl.exe` (see https://github.com/PowerShell/PowerShell/issues/12975#issuecomment-650353021) not of powershell.\r\n(Ok, there is a problem with powershell, but that's #1995)\r\n\r\nOh, and isn't this almost a duplicate of https://github.com/PowerShell/PowerShell/issues/12975 ? Because I can essentially mostly repeat, what I mentioned there:\r\n\r\n<blockquote>\r\n@bitcrazed \r\n<blockquote>The problem is that the lack of an ability to delimit a portion of a command-line to be passed varbatim to the receiving command/script is something that trips users up all the time.</blockquote>\r\n\r\nWhat do you mean by \"portion of a command-line to be passed varbatim\"?\r\n\r\nDo you mean \r\n\r\n1. pass some sequence of characters verbatim to the called executable, such that the called executable has this sequence of characters in one element of its argument array (e.g. those characters are then available in `argv[1]` in [main](https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args?view=vs-2019#command-line-arguments))\r\n\r\nOr do you mean\r\n\r\n2. insert some sequence of characters verbatim into the [`lpCommandLine` parameter of `CreateProcess`](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw#parameters)\r\n\r\n---\r\n\r\nIf you mean (1.), then it essentially already works:\r\n```\r\nPS /home/User> /bin/echo 'cd / && ls . | cowsay'\r\ncd / && ls . | cowsay\r\nPS /home/User>\r\n```\r\n(Except for the problem of embedded quotes as discussed in https://github.com/PowerShell/PowerShell/issues/1995)\r\n\r\nOne could argue, that adding a one-line-here-string would improve some usecases, but I think, that's not really the point of this issue.\r\n\r\nAs this does already work more or less, I assume, you meant (2.)\r\n\r\n---\r\n\r\nIf you mean (2.), then let me state my opinion on that in a somewhat dramatic way:\r\n\r\nPlease please please don't add special syntax for this. This is basically what `--%` tried to do, which also should have never ever been implemented.\r\n\r\nWhy am I so strongly against this?\r\n\r\n1. It is a Windows only problem, so adding syntax would mean that powershell on Windows has different syntax than on Linux. (Or the syntax would be supported but is totally meaningless, as it is currently the case for `--%`)\r\n\r\n2. If the main commandline shell on Windows published by Microsoft adds a first-class feature (via special syntax opposed to via a cmdlet) to call executables that don't follow the typical [commandline parsing rules](https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args?view=vs-2019#parsing-c-command-line-arguments) (if the tool follows the typical rules, you don't need (2.), you can usually better use (1.)), then that encourages authors of command line tool, to not follow these rules, which only worsens the [\"Windows command line anarchy\"](https://stackoverflow.com/a/4094897/2770331). The less people follow the typical rules, the harder it is to programmaticly call external executables or generally write cross platform code, so I definitely think, that program authors should be encouraged to follow those typical rules.\r\n\r\n3. I strongly doubt, that this is a common use-case \r\n   >And this isn't just an issue that affects WSL: It also affects Windows Terminal's wt command-line invocations, and many other tools.\r\n   \r\n   Could you add some examples, where such problems occur? Because in case of WSL, I'd say that WSL's parsing of the commandline is simply [broken](https://github.com/Microsoft/WSL/issues/1746) (issue was about `bash.exe` but situation is by default not better with `wsl.exe`) in the default case - I'd consider every tool, that doesn't follow the typical [commandline parsing rules](https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args?view=vs-2019#parsing-c-command-line-arguments) broken, but WSL's default behavior is IMHO not even properly documented...\r\n\r\n   I said the \"default\" behavior of `wsl.exe` is broken - while writing this response, I noticed, that `wsl.exe` actually seems to behave as expected, when using `-e`:\r\n```\r\nPS C:\\> wsl -e bash -c 'cd / && ls . | cowsay'\r\n _______________________________________\r\n/ acct bin boot cache cygdrive data dev \\\r\n| etc home init lib lib64 lost+found    |\r\n| media mnt opt proc root run sbin snap |\r\n\\ srv sys tmp usr var                   /\r\n ---------------------------------------\r\n        \\   ^__^\r\n         \\  (oo)\\_______\r\n            (__)\\       )\\/\\\r\n                ||----w |\r\n                ||     ||\r\nPS C:\\>\r\n```\r\nSo the only thing missing for this explicit usecase is IMO a parameter to `wsl.exe` to call the default shell with the commandline arguments parsed as in any other normal exe.\r\n</blockquote>\r\n\r\nThe only thing regarding \"portion of a command-line to be passed varbatim to the receiving command/script\", that would be improved with this operator would be meaning (2.) above, and as mentioned, I think developing in that direction is bad.\r\n\r\nIf all you want to do is a shortcut do copy&paste existing command lines, why don't you add a cmdlet (e.g. `Invoke-Shell`, that calls `bash -c` on linux and `cmd /c` on windows?\r\nThen you could just do\r\n```\r\nInvoke-Shell @'\r\nwhatever existing comandline containg '\"quotes\"' or whatnot\r\n'@\r\n```\r\nIf it must be one line, then add one-line-here-string syntax, but please don't implement a special operator, that can't be properly found and just complicates everything.\r\n\r\nAnd please don't abandon #1995 for this!",
      "created_at": "2020-07-02T19:35:30Z",
      "updated_at": "2020-07-02T19:36:24Z"
    },
    {
      "author": "jazzdelightsme",
      "author_association": "CONTRIBUTOR",
      "body": "+10 points for using the word \"sigil\".\r\n\r\nThe thing that is nice about `&!` versus `shell` is that \"shell\" is a common English word, therefore people might have an existing command named shell. (In fact, I have both a function named \"shell\" and a function named \"n\" (hence I don't like `&n`).)\r\n\r\n@oising: `& --%` is nice, except one of the express purposes of the proposed feature is to mean that `|` becomes something that is passed to the native shell; *not* something that brings you back into PowerShell parsing. And if we make the pipeline precedence different for `& --%` than for `foo $blah --% more args`, I would find that bewildering... what if you did `& $foo --% more args | blah`? Thus in my opinion, the proposed `&!` is different enough that it warrants having a different operator. (Put another way: the proposed functionality is related but *different* than combining `&` and `--%`.)\r\n\r\nThis feature is more than just for \"new PowerShell user who knows bash\" and \"user that doesn't know all the complex quoting/escaping rules\". It's also for the most expert of users, who just want to copy/paste a command from StackOverflow without having to go in and fiddle with everything. This happens to me quite a bit--a product I work on has a lot of documentation about how to do things, and the lingua franca is cmd.exe commands--so I have to go and deal with fixing the %VARIABLE_REFERENCES% etc.; it would be so much nicer to type `&! ` and then paste. In fact if this is implemented I will probably refer to it as \"the StackOverflow operator\". :D\r\n\r\n@vexx32: This isn't the \"one ring to rule them all\" call operator; just another tool in the toolbox to address a common problem. I don't think we should get rid of existing tools to make room for this one; they do different things. I understand that new users may feel overwhelmed when the toolbox has a hammer, a screwdriver, a drill, an impact drill, and a nailgun... but despite the fact that they are all for \"poking a pokey thing through one or more other things\", they are invaluable for a professional; all used in different (though related) situations.\r\n\r\n@TSlivede: I agree that #1995 is separate. But I disagree with \"It is a Windows only problem\": copying and pasting platform-specific commands from StackOverflow applies equally to any OS. (In fact, this would be very helpful for many people like me who are stronger on one platform than another--I am more proficient with Windows technologies, so when on Linux I tend to do a LOT of copying and pasting from SO.)\r\n\r\nWhether via a new operator `&!` or some `Invoke-Shell` command, I do not have such strong feelings as others... I sympathize with people complaining that the operators are hard to search for, etc. but I *really* like the terseness of `&!`.\r\n\r\n",
      "created_at": "2020-07-02T20:26:23Z",
      "updated_at": "2020-07-02T20:26:23Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@jazzdelightsme this isn't \"another tool in the toolbox\" as much as it is \"another incredibly specific screwdriver attachment for a screwdriver that already has about 3-5 that are currently already _okay_ and could stand to be improved\" in my opinion.",
      "created_at": "2020-07-02T20:38:34Z",
      "updated_at": "2020-07-02T20:38:34Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "@jazzdelightsme The \"Windows only\" part was perhaps more related to the issue where I originally posted that statement - yes OK, this is not an exact duplicate of that issue.\r\n\r\nIf #1995 is not abandoned and the feature requested here is not resolved via special Syntax but via a commandlet (or perhaps new Syntax for a one-line here string that works everywhere not just for this special case) then I am actually in favor of adding this functionality. (Or maybe not \"in favor\" but \"This is totally acceptable to me\") ",
      "created_at": "2020-07-02T20:56:38Z",
      "updated_at": "2020-07-02T21:02:03Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "Another idea: If this is issue is actually about copy&pasting full commands that were intended for native shells, maybe PsReadLine could add a feature to roughly translate a command from bash or cmd style to powershell. The translation could be triggered by a special key combination or automatically if a parsing error occurs when trying to execute a command.\r\n\r\nThis would have the additional advantage of teaching users the Syntax of powershell.\r\n\r\nRegarding discoverability: PsReadLine could always display a message for a short time that the specific key combination can be used, whenever syntactically incorrect content (that would be valid after translation) is pasted.\r\n\r\nBut I could understand if this was just a bit to complex to realize.\r\n\r\n",
      "created_at": "2020-07-02T21:18:54Z",
      "updated_at": "2020-07-02T21:18:54Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@jazzdelightsme did you talk to @joeyaiello?  I thought only he called it the `StackOverflow operator` which made me cringe even though it's very true",
      "created_at": "2020-07-02T21:31:08Z",
      "updated_at": "2020-07-02T21:31:08Z"
    },
    {
      "author": "jazzdelightsme",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT No I didn't talk to anybody about this; I arrived at \"StackOverflow operator\" independently. xD",
      "created_at": "2020-07-02T22:14:43Z",
      "updated_at": "2020-07-02T22:14:43Z"
    },
    {
      "author": "oising",
      "author_association": "CONTRIBUTOR",
      "body": "@jazzdelightsme \r\n\r\n> ... except one of the express purposes of the proposed feature is to mean that | becomes something that is passed to the native shell; not something that brings you back into PowerShell parsing.\r\n\r\nI'm not sure you've understood my suggestion; what you say is _precisely_ what I'm saying. Let me be more verbose with some strategically capitalized hints :D \r\n\r\n```powershell\r\n# NON-OPTIMAL SOLUTION: run \"ls\" in wsl, return results to powershell, then pipe to wsl again, to \"grep.\"\r\n& wsl ls | wsl grep -i \"foo\"  \r\n\r\n# NEW SOLUTION: the entire pipeline/string, INCLUDING THE PIPE SYMBOL, right of wsl will be executed in wsl. \r\n& --% wsl ls | grep -i \"foo\"\r\n\r\n# NEW SOLUTION: the entire pipeline AS ABOVE is sent to WSL, then the results are returned to powershell\r\n# and piped, in powershell, to foreach-object\r\n(& --% wsl ls | grep -i \"foo\") | % { \"match {0}\" -f $_ }\r\n\r\n# NEW SOLUTION: allow placing --% beyond first argument\r\n# pass everything right of --% to the command in $wsl \r\n$wsl = gcm wsl\r\n& $wsl --% ls | grep -i \"foo\"\r\n\r\n# or\r\n\r\n& wsl --% ls | grep -i \"foo\"\r\n\r\n# NEW SOLUTION: execute multiline pasted code without powershell parsing.\r\n& --% @'\r\n(pasted multiline code)\r\n@'\r\n``` \r\nWhat am I missing here? If the pipe appears after `--%` it's just another dumb character: an argument. There's no twiddling with operator precedence. If contained in a nested pipeline or subexpression, then start parsing for powershell again. \r\n\r\n> what if you did & $foo --% more args | blah?\r\n\r\nWell, that would attempt to execute the argument in `$foo` and pass `\"more\"`, `\"args\"`, `\"|\"` and `\"blah\"` to be treated as whatever's in `$foo` wants. The rules seem simple enough to me, but admittedly I've been using powershell/monad a long time. This isn't a major breaking change to `&` as `& $foo --% ...` treats `--%` like any other argument. So unless we've been using this sigil elsewhere nefariously, we should be safe. \r\n\r\nThoughts? \r\n",
      "created_at": "2020-07-03T00:41:18Z",
      "updated_at": "2020-07-03T01:29:45Z"
    },
    {
      "author": "oising",
      "author_association": "CONTRIBUTOR",
      "body": "I made multiple edits to the above, to cover partial line evaluation, multiline evaluation and variable positioning of `--%`.  All without introducing new sigils, operators or strange syntax. I think that covers it. The only thing is: Can the parser handle it? What do you think @lzybkr @JamesWTruher  @BrucePay  ?",
      "created_at": "2020-07-03T01:13:04Z",
      "updated_at": "2020-07-03T01:21:54Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Hear, hear, @TSlivede.\r\n\r\nForgive me for being blunt, but we've been talking about these issues for a looooong time:\r\n\r\nWhat this issue proposes  amounts to magical thinking:\r\nIt is related to the ill-fated, inherently problematic \"stop-parsing symbol\", `--%`, which in its current form is of limited use _on Windows_ (see https://github.com/MicrosoftDocs/PowerShell-Docs/issues/6149) and virtually useless on _Unix-like platforms_ (see https://github.com/MicrosoftDocs/PowerShell-Docs/issues/4963).\r\n`--%` should never have been implemented, and neither should this proposal be implemented as presented.\r\n\r\nThe magical thinking is a conceptually muddled conflation of two ideas:\r\n\r\n* (a) \"I want to pass space-separated tokens to some external program, allowing any barewords, without needing to worry about shell metacharacters such as `&` or `|`.\" - see https://github.com/PowerShell/PowerShell/issues/12975#issuecomment-646276628\r\n\r\n   * Of course, such a feature is at odds with using such commands _as part of a pipeline_ or with _pipeline-chaining operators_ (`&&` and `||`), and also placing additional commands on the same line, after `;` - and, not least, being able to use any _PowerShell variables and expressions_ in the command line.\r\n\r\n* (b) \"I want my command line treated the way I'm used to _from the shell I normally use_ (or the shell for which the command line was originally written)\", which, of course, _is_ subject to unquoted use of characters such as `&` or `|` being interpreted as metacharacters and therefore having _syntactic_ meaning.\r\n  * Case in point: neither `cmd` nor `/bin/sh` (or any POSIX-like shell such as `bash`) would accept `wsl ls | less` in a way that passes `ls`, `|` , and `less` _verbatim_ through to `wsl` - they'd all interpret _unquoted_ `|` as _their_ pipe symbol.\r\n\r\nThese ideas are at odds at one another, and require distinct solutions - neither of which requires special syntax per se:\r\n\r\n* The solution to (a) is to _abandon_ the idea and to instead use _PowerShell's own, existing syntax_ to ensure that metacharacters are used _verbatim_ - which invariably necessitates _quoting_ or _escaping_,:\r\n  * Either: quote barewords (tokens not enclosed in quotes) that contain metacharacters _as a whole_: `wsl ls '|' less`\r\n  * Or: `` ` ``-escape metacharacters _individually_ in barewords: ``wsl ls `| less``\r\n  * Or: use an _array [variable]_ to pass the arguments _verbatim_: `$wslArgs = 'ls', '|', 'less'; wsl $wslArgs`\r\n  * Of course, #1995 demonstrates that, regrettably, this approach is and always has been  broken when it comes to arguments that have _embedded_ `\"` _when calling external programs_  - _this needs to be addressed_: see below.\r\n\r\n* The solution to (b) is to actually _call the shell I normally use_, passing the command line _as a single string_.\r\n\r\n  * As @TSlivede suggests, an `Invoke-Shell` cmdlet to which you pass the command line _as a single string_ and which calls the _platform-native shell_ is the solution - and we already have syntax for verbatim strings (`'...'` or its here-string variant, `@'<newline>...<newline>'@`\r\n    * My recommendation is to call it `Invoke-NativeShell`, and to call `/bin/sh` - not `bash` - on Unix-like platforms.\r\n       * Additionally, I suggest defining `ins` as a succinct alias.\r\n  * This approach solves all conceptual problems with `--%` and with the proposal at hand:\r\n     * It make it very obvious where the command passed to the native shell ends (by virtue of being _a single string_), and it allows using an `Invoke-NativeShell` / `ins` call in a regular PowerShell pipeline / with PowerShell redirections without ambiguity.\r\n     * You can optionally use an _expandable_ string (`\"....\"` or its here-string variant) in order to embed _PowerShell_ variable values in the command line (something that `--%` can't do).\r\n\r\n---\r\n\r\nSince the powers that be have concluded that #1995 cannot be fixed lest backward compatibility be broken - after all, all existing workarounds would break, see https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-562334606 - the best thing we can do is to support the opt-in into the proper behavior with a syntax that is as succinct as possible, so as to minimize the pain of having to go out of your way to get the behavior that should always have been the default.\r\n\r\nTherefore: **special syntax such as `&!` should only be provided as the opt-in to get proper passing of arguments to external programs in order to address #1995**, based on the behavior proposed in @TSlivede's RFC - see https://github.com/PowerShell/PowerShell-RFC/pull/90. If a future PowerShell version is ever permitted to break backward compatibility, then it is direct invocation / invocation with `&` that should exhibit this behavior.\r\n\r\nFrom a user's perspective, this means: All I need to do is to satisfy _PowerShell's_ syntax requirements - see https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-640711192 - and I can rely on PowerShell to robustly pass the resulting verbatim tokens through to the target program - _this is a core mandate of any shell, which PowerShell has regrettably never satisfied with respect to external programs_.\r\n\r\nFor instance, the following command  - which currently does _not_ work as intended (when invoked directly or with `&` - see [this docs issue](https://github.com/MicrosoftDocs/PowerShell-Docs/issues/2361)) - should then work:\r\n\r\n```powershell\r\nPS> &! bash -c 'echo \"one two\"'\r\none two   # Currently (invoked with & instead of &! or with neither) prints only 'one', \r\n          # because PowerShell passes the entire argument (brokenly) as  \"echo \"one two\"\",\r\n          # which the target program sees as *2* verbatim arguments `echo one` and `two`\r\n```\r\n\r\nThose looking for a workaround in current / earlier PowerShell versions can find a simple function that will cover most use cases at https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-303345059 (limitations discussed at https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-649560892), and a more elaborate version at https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-562334606",
      "created_at": "2020-07-03T03:21:53Z",
      "updated_at": "2020-07-05T19:41:10Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "P.S.: The discovery problem of (not only symbol-based) operators is a separate problem that  is well worth addressing in its own right: the solution is to _enhance `Get-Help` to allow operator lookup_ - see #11339, which also links to an interim solution.",
      "created_at": "2020-07-03T03:26:24Z",
      "updated_at": "2020-07-03T03:26:46Z"
    },
    {
      "author": "AndrewSav",
      "author_association": "NONE",
      "body": "> Since the powers that be have concluded that #1995 cannot be fixed lest backward compatibility be broken - after all, all existing workarounds would break, see #1995 (comment) - the best thing we can do is to support the opt-in into the proper behavior with a syntax that is as succinct as possible, so as to minimize the pain of having to go out of your way to get the behavior that should always have been the default.\r\n\r\n@mklement0 I think opt-in was a part of https://github.com/PowerShell/PowerShell/issues/1995 and that was rejected. So to me it sounds like wishful thinking. Am I wrong?",
      "created_at": "2020-07-03T07:52:37Z",
      "updated_at": "2020-07-03T07:52:37Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@AndrewSav, we originally only discussed an opt-in via configuration or preference variable.\r\n\r\nHowever, @joeyaiello said the following in https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-653164987 when he closed the issue (emphasis added):\r\n\r\n> Anything we touch here is just too much of a breaking change, and **we should address the problem with a new operator**\r\n\r\nA new operator _is_ an opt-in of sorts, but an unproblematic one, I hope (though the need for it is unfortunate, but that's the price of backward compatibility).\r\n\r\nWhile this proposal purportedly also solves #1995, it doesn't, given that it aims (primarily) at accommodating the syntax of _other_ shells. Given that both problems are worth solving, independently, my proposal was this:\r\n\r\n* Let's introduce a new operator, but use it solely to fix #1995 (via https://github.com/PowerShell/PowerShell-RFC/pull/90), i.e. to fix PowerShell's _own_ (non-other-shell-emulating) broken handling of argument passing to external programs.\r\n  * New code should then always use `&!` (or whatever form we decide on)  instead of `&` when calling external programs  (you can think of it as deprecating `&` for external programs).\r\n  * When calling _PowerShell_ commands, `&!` should act like `&` does now (there never was a problem), thereby enabling the consistent use of `&!`.\r\n\r\n* To solve the reuse-command-lines-from-other-shells problem, let's implement a `Invoke-NativeShell` / `ins` cmdlet that calls the platform-appropriate native shell (`cmd /c` on Windows, `/bin/sh -c` on Unix-like platforms) with the command line passed as a _single string_.\r\n\r\n   * In the simplest case, with no `'` present in the command line, a regular single-quoted string will work; e.g.:\r\n\r\n         ins 'ls | cat -n'\r\n\r\n   * With `'` present, they can either be _doubled_; e.g.:\r\n\r\n         ins 'echo ''hi'' | cat -n'\r\n\r\n   * or, if the desire is not to have to touch the command line at all, a here-string can be used (as already shown by @TSlivede) - while this syntax is a little more cumbersome, it should always work:\r\n\r\n         ins @'\r\n           echo 'hi' | cat -n\r\n         '@\r\n\r\n   * additionally, by using an _expandable_ (interpolating) string (`\"...\"` or `@\"<newline>...<newline>\"@`), you have the option of incorporating _PowerShell_ variables into the string passed to the native shell (something that `--%` doesn't support):\r\n\r\n         $foo = 'hi'\r\n         ins @\"\r\n           echo '$foo' | cat -n\r\n         \"@\r\n\r\n    * Note:\r\n         * `Invoke-NativeShell` cmdlet would be a fairly thin wrapper around `cmd /c` / `/bin/sh -c` calls, which you could obviously make directly yourself, but it does have the advantage that you don't need to know the specific executable name and command-line passing syntax. \r\n         * As a potentially beneficial side effect, you'll be able to use common parameters such as `-OutVariable`, and can think about whether to let the `-Error*` parameters act on _stderr_ (though, for symmetry, `Invoke-Command` should then too, which would be a breaking change).\r\n        * Since POSIX-like shells support _multiple_ arguments with `-c` - the first constituting the code to execute, and the subsequent ones the arguments to pass to that code, starting with `$0`(!) - e.g. `bash -c 'echo $@' _ 1 2 3` - optional additional arguments must be supported too. \r\n       * **Since the platform-native shell is being called, such calls are by definition _not_ portable, due to the fundamental differences between `cmd` and `sh`.\r\nThis is why it's so important to fix PowerShell's _own_ argument-passing (#1995), as it then provides a reliable, truly cross-platform method of invoking external programs.**\r\n\r\n---\r\n\r\nThe final piece of the puzzle is _documentation_.\r\n\r\nhttps://github.com/MicrosoftDocs/PowerShell-Docs/issues/5152 is a longstanding proposal to write a conceptual help topic about calling external programs (e.g., `about_Native_Calls`), which should, in a single location, cover _all_ aspects that are relevant to calling external programs; aside from what's already covered there (syntax pitfalls due to additional metacharacters, absence of a raw byte pipeline, non-integration with PowerShell error handling, ...), the issues at hand should be discussed as well:\r\n\r\n* How passing arguments with embedded `\"` (and _empty_ arguments) is broken in (hopefully soon-to-be) earlier versions (currently discussed in a separate proposal, https://github.com/MicrosoftDocs/PowerShell-Docs/issues/2361), and how to work around that (manual `\\`-escaping or use of one of the helper functions from #1995, one of which is succinct enough to be directly included in the topic).\r\n\r\n* How only `&!` should be used going forward to call native (external) executables, so as to ensure proper argument-passing.\r\n\r\n* How `Invoke-NativeShell` / `ins` can be used to execute command lines _written for the platform-native shell_ as-is.\r\n\r\n",
      "created_at": "2020-07-03T12:32:40Z",
      "updated_at": "2020-07-05T12:05:47Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Interesting, today users can:\r\n1. direct invocation\r\n2. & operator\r\n3. Start-Process\r\n\r\nIt is not at all clear that users should use.\r\n\r\nAfter fixing broken behavior users will have the following features:\r\n1. direct invocation\r\n2. & operator\r\n3. Start-Process\r\n4. &! operator\r\n5. Start-ProcessV2\r\n\r\nIs not it too much for the shell to run `ping 127.0.0.1`?\r\n",
      "created_at": "2020-07-06T11:06:53Z",
      "updated_at": "2020-07-06T11:06:53Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Yeah that's my main concern with adding yet another operator as well @iSazonov. It's already confusing, and this will not help. Documentation is only a part of the puzzle. Even if we have decent documentation, the mere fact that there are _five different ways_ to do it, each of which behaves a bit differently, will **always** cause confusion.\r\n\r\nIf we care about the UX at all, we should be opting to improve existing cases over adding yet more.",
      "created_at": "2020-07-06T11:54:34Z",
      "updated_at": "2020-07-06T11:54:34Z"
    },
    {
      "author": "AndrewSav",
      "author_association": "NONE",
      "body": "> If we care about the UX at all, we should be opting to improve existing cases over adding yet more.\r\n\r\nWhich you cannot because you must be backward compatible. I feel we are going in circles. https://github.com/PowerShell/PowerShell/issues/1995 was that and it was closed for that very reason.",
      "created_at": "2020-07-06T20:48:36Z",
      "updated_at": "2020-07-06T21:00:35Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov:\r\n\r\nThe existing lack of guidance needs to be addressed even if we don't introduce a new operator:\r\n\r\n* comprehensively, via the [proposed `about_Native_Calls` topic](https://github.com/MicrosoftDocs/PowerShell-Docs/issues/5152)\r\n\r\n* in the `Start-Process` topic specifically, which currently lacks any guidance as to when it use is appropriate - see https://github.com/MicrosoftDocs/PowerShell-Docs/issues/6239\r\n\r\nTo summarize briefly:\r\n\r\n* Don't use `Start-Process` to invoke _console_ (terminal) programs (unless - which is available on Windows only - you want to run them _in a new window_).\r\n\r\n* Direct invocation and invocation via `&` are _equivalent_; (leaving script blocks aside),`&` is only ever needed for _syntactic_ reasons, whenever the command name or path is _quoted_ and/or contains _variable references_.\r\n\r\n---\r\n\r\n> After fixing broken behavior users will have the following features:\r\n> direct invocation\r\n> * & operator\r\n> * Start-Process\r\n> * &! operator\r\n> * Start-ProcessV2\r\n\r\n* No, there won't be a `Start-ProcessV2`, just a _new parameter_, `-IndividualArguments` - see https://github.com/PowerShell/PowerShell/issues/5576#issuecomment-552124719\r\n\r\n* Yes, there will be `&!` (or whatever symbol we decide on), but it effectively _supersedes both `&` and direct invocation_ (at least for _external programs_, but you'll be able to use it with _all_ command forms) - which should be easy to communicate.\r\n\r\n> Is not it too much for the shell to run `ping 127.0.0.1`?\r\n\r\n`ping 127.0.0.1` will continue to work, but if you want `bash -c 'echo \"one two\"'` to work, you'll have to use \r\n`&! bash -c 'echo \"one two\"'`\r\n\r\nThat is unfortunate, but - given that the direct invocation / `&` behavior _cannot be fixed_ - it strikes me as the best solution.\r\n\r\nFortunately, it's a simple rule to memorize: _If you want predictable argument passing to external programs, use `&!`_\r\n\r\nAlternative forms of opt-in - configuration (via `powershell.config.json`) or a preference variable - are much more problematic:\r\n\r\n* The dynamic scoping of preference variables makes it too easy to inadvertently apply the opt-in to legacy code that wasn't designed for it - see https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-650262164\r\n\r\n* Configuration would apply to sessions as a whole, making opt-out impossible altogether.\r\n\r\n* In both cases, action is needed that is _separate_ from a specific call, and looking at a given call won't tell you how it will behave - by contrast, `&!` leaves no doubt as to which behavior will ensue.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-07-06T21:59:40Z",
      "updated_at": "2020-07-08T01:34:12Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "To the end user, it looks just as awful as if we launched a calculator and found there 5 buttons for the addition operation. \ud83d\ude04 \r\n\r\nIf we want to improve it so much that we are ready for such complications, then perhaps this is enough to accept a breaking change (for direct invocation and `&`) so as to simplify the behavior and release V8.0.\r\n\r\nIf our desire is not so strong, it is possible to sufficiently improve the diagnostics (`prog.exe param1 param2 -Whatif` and the same for Start-Process -WhatIf) so that it displays what `testargs` program displays and recommendations on how to correctly perform escaping.\r\n\r\nThe script developer can afford to spend time testing and using the debugger. But in an interactive session, any user wants simplicity, brevity and clarity, and this outweighs everything.\r\n\r\n\r\n\r\n",
      "created_at": "2020-07-07T04:48:41Z",
      "updated_at": "2020-07-07T04:48:41Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov:\r\n\r\n> then perhaps this is enough to accept a breaking change (for direct invocation and &) so as to simplify the behavior and release V8.0\r\n\r\nYou certainly have _my_ vote - **but do the powers that be support this plan**? [_update_ - see #13129]\r\nIf we do take a change of this magnitude, we can finally tackle all historical baggage - see #6745\r\n\r\n> If we want to improve it so much\r\n\r\nThere are two good reasons to want it that much: \r\n\r\n* To end years of pain due to broken argument-passing - as evidenced by #1995, many related issues, and countless Stack Overflow questions.\r\n\r\n* Because - as has been stated several times before - calling external programs with arguments is a _core mandate of any shell_.\r\n\r\nHistorically, in the Windows-only days, the dearth of capable external CLIs made the inability to call them properly less problematic, and users who stayed in the walled garden of PowerShell (calling only PowerShell-native commands) didn't feel the pain. But times sure have changed:\r\n\r\nWe live in the age of a wealth of cross-platform CLIs that are crucial to development, CI, and deployment tasks.\r\nIf PowerShell wants to be taken seriously as a shell, this problem must be addressed.\r\n\r\n---\r\n\r\nEven if an allowed-to-break-backward-compatibility v8.0 happens (fingers crossed), its release could be a long time away, and we _also_ need an interim solution.\r\n\r\nAs much as the proposed enhancement to the documentation are needed, I don't think they alone sufficiently ease the pain, for lack of a readily available runtime solution.\r\n\r\nI get that the operator is ugly, but a non-breaking solution _necessitates_ additional syntax (more to type), whatever its form.\r\n\r\nAn alternative to `&!` that is less ugly, easier to type, and doesn't \"pollute\" the language is to ship a built-in _function_ with a concise name, such as the `iep` function (*I*nvoke-*E*xternal*P*rogram) that masks all the problems, shown [here](https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-562334606).\r\n(Note that we already ship functions that either wrap other functionality (e.g., `pause`) or accommodate `cmd.exe` users (e.g., `cd..` [sic]).)\r\n\r\nThus, to get `bash -c 'echo \"one two\"'` to work properly, you'd call `iep bash -c 'echo \"one two\"'`\r\nOr, to use perhaps a more realistic scenario:\r\n\r\n```powershell\r\n# Pass JSON to an external utility (Unix example)\r\n# Without `iep`, the embedded double quotes are lost and *broken JSON* is passed.\r\niep /bin/echo '{ \"foo\": \"bar\" }'\r\n```\r\n\r\nAgain, we're ultimately talking about a _compromise_ in service to preserving backward compatibility - this is inevitably a nuisance to end users.\r\n\r\n---\r\n\r\n> improve the diagnostics (prog.exe param1 param2 -Whatif and the same for Start-Process -WhatIf) so that it displays what testargs program displays and recommendations on how to correctly perform escaping.\r\n\r\nSince direct / `&`-based invocation isn't a cmdlet call and all arguments are presumed to be pass-through arguments, treating `-WhatIf` as a common parameter amounts to a breaking change (however unlikely that is in practice).\r\n\r\nIf you're willing to accept such a change, we might as well (also) support a `-DoItRight` switch (or a symbol-based one, akin to `--%`)  as an opt-in for the fixed behavior  - and that strikes me as worse than the `iep`-prefix / `&!` approach.\r\n\r\n(A non-breaking diagnostic option, I suppose, would be to enhance `Invoke-Command`, which currently doesn't support `-WhatIf` - however, if we provide a well-documented opt-in to the correct behavior, I don't think this is worth doing.)\r\n\r\n\r\n\r\n",
      "created_at": "2020-07-07T13:18:05Z",
      "updated_at": "2020-07-08T01:35:41Z"
    },
    {
      "author": "musm",
      "author_association": "NONE",
      "body": "I agree with  @iSazonov that the situation is not ideal to introduce yet another thing to do something that it supposed to work, but as mentioned by @mklement0  waiting for a breaking release that properly fixes this could be a very very very long time, and a lot of us desperately need a solution ASAP. For all I can see, the best solution currently is to just use \r\nhttps://github.com/PowerShell/PowerShell/issues/1995#issuecomment-562334606  right?  \r\n",
      "created_at": "2020-07-09T18:34:33Z",
      "updated_at": "2020-07-09T18:34:59Z"
    },
    {
      "author": "oising",
      "author_association": "CONTRIBUTOR",
      "body": "@mklement0 I'm not sure how a iep /invoke-externalprogram could work, since a cmdlet is subject to the same parameter munging we're trying to fix. This is a parser issue, right? If we tried to hide everything inside a cmdlet/function, I'd imagine it would be hideously complex given it would have to undo the munging/reconstruct intent. Or am I missing something?",
      "created_at": "2020-07-10T15:50:28Z",
      "updated_at": "2020-07-10T15:50:28Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@oising: \r\n\r\nTo be clear: the [linked `iep` function](https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-562334606) fixes #1995, not what _this_ proposal is primarily about (which I think is _not_ worth pursing, [as argued above](https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-653319079)), though do note that the stated intent in the OP is to _also_ solve #1995.\r\n\r\n#1995 is about being able to rely on _PowerShell_'s syntax (not another shell's) for passing arguments to external programs _faithfully, as seen verbatim by PowerShell after its own parsing_. \r\n\r\nPowerShell's own parsing is fine, and there are no problems as long as you pass arguments to _PowerShell_ commands.\r\n\r\nBy contrast, passing arguments to _external programs_ is badly broken, and that's what `iep` fixes.\r\n\r\nIt is broken due to flawed _re-quoting and escaping_ of the arguments _behind the scenes_, when the command line ultimately used is constructed.\r\nhttps://github.com/PowerShell/PowerShell-RFC/pull/90 proposes a proper fix (sans agreement on how to handle backward compatibility, and with a few minor questions yet to be answered), that at its core relies on the recently introduced [`System.Diagnostics.ProcessStartInfo.ArgumentList`](https://docs.microsoft.com/en-US/dotnet/api/System.Diagnostics.ProcessStartInfo.ArgumentList) to perform the proper re-quoting and escaping for us (we just pass the collection of arguments that resulted from PowerShell's own parsing) - which, incidentally, is only ever required _on Windows_; on Unix, sensibly, _there is no command line_ (outside of a shell) when you pass arguments on process startup: you just pass the arguments verbatim, as an array.\r\n\r\nIn short:\r\n\r\n* Providing `iep` as a built-in function would be a low-ceremony stopgap opt-in to offer proper argument passing to external programs,  until a proper fix - in the context of a breaking change - can be implemented\r\n\r\n* An `Invoke-NativeShell` (`ins`) cmdlet is the proper solution - not a stopgap - to providing a way to call _a different shell's_ (the native shell's) command lines, using _its_ syntax - see [above](https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-653526374).\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-07-10T17:01:36Z",
      "updated_at": "2020-07-10T17:03:20Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "Currently, there are cases where cutting and pasting a PERL command fails to run as expected in Python.  Go figure.  This must be a great disadvantage for all those cutters-and-pasters out there.  I think Python should have a special operator for that.",
      "created_at": "2020-07-12T20:54:13Z",
      "updated_at": "2020-07-12T20:54:13Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> I'm not sure you've understood my suggestion; what you say is _precisely_ what I'm saying. Let me be more verbose with some strategically capitalized hints :D\r\n> \r\n```powershell\r\n# NEW SOLUTION: the entire pipeline AS ABOVE is sent to WSL, then the results are returned to powershell\r\n# and piped, in powershell, to foreach-object\r\n(& --% wsl ls | grep -i \"foo\") | % { \"match {0}\" -f $_ }\r\n```\r\n> \r\n> What am I missing here? If the pipe appears after `--%` it's just another dumb character: an argument. There's no twiddling with operator precedence. If contained in a nested pipeline or subexpression, then start parsing for powershell again.\r\n> \r\n\r\n> \r\n> Thoughts?\r\n\r\nWhat you are missing is the need to pass a closing parenthesis as an argument to an external program.  It is a typical DWIM approach\u2014but PowerShell is not HAL.",
      "created_at": "2020-07-12T21:09:40Z",
      "updated_at": "2020-07-12T21:11:11Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for all the detailed feedback, everyone. Speaking as myself here. A few uber-points before I get more into the nitty gritty:\r\n\r\n* I'm still not on board with a vNext/8.0 that decides to break a whole new litany of stuff. Backwards compatibility matters. I know it's painful, and I'd rather live in a world where we could go back and correct every mistake that PowerShell ever made, many unintentional. But  vast majority of PS users are not hanging out here in issues, knee-deep in SO edge cases. They've copy/pasted the same workaround to something for 4-10 years, they don't necessarily know why it works, and they won't care that we were \"fixing mistakes\" when their script breaks on upgrade. They just know that \"updating PS has broken me, and I can't trust updates\", and then we end up with *even more* users slowing down their updates and adoption. \r\n* I think some folks in this issue may be projecting many different hopes and desires into this issue, or see it as an either/or with other fixes. I realize I exacerbated that by closing #1995, and I'm sorry for that (though I will say, I'm still not sure that one specifically can actually be fixed, but we will take a harder look at it), but this is really a \"trap door\" solution that gets both new and experienced users out of a bind quickly without letting frustration mount. We can still have longer-term conversations about fixes to the PS parsing side of the house so that we can offer a truly cross-platform solution for everything. \r\n\r\nNow, comments as I read:\r\n\r\n* I'm wary about the proposed desire to align with `#!` (with either `&!` or `$!` given that, in the default case, users are likely not going to specify the interpreter. If I want to do something like `$! net <stuff>`, `net.exe` is not my interpreter. And on non-Windows, the \"native\" thing to do is still to pass to sh/bash/whatever before passing to the binary being run. E.g. I don't want Python parsing `*.py` in the string `$! /usr/bin/python *.py` or even `$! python *.py`. I want Bash to do the globbing and then to hand the list of matches to `python`. \r\n* Like @oising suggested, I'm in favor of `--%` as the operator, overloaded to be used in the front. Discoverability is a problem, and given that we're already 10 years in on working on the discoverability of this one ([it's Google-able now!](https://www.google.com/search?q=--%25&oq=--%25), I say we just go with that. (I was the one that made @SteveL-MSFT put it in his proposal as an alternate consideration). Question, though: do we even need the `&` call operator here? Why not just start the line with `--% native.exe do /some $stuff`? \r\n* @rjmholt: I didn't totally understand your comment [here](https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-652672924), but it's my take that we should probably not change anything with the existing `--%` behavior where it comes *after* the executable, but I think we can do your \"new behavior\" with where it comes *before* the executable.\r\n* Read this from @jazzdelightsme and I emphatically agree:\r\n  > It's also for the most expert of users, who just want to copy/paste a command from StackOverflow without having to go in and fiddle with everything.\r\n\r\n  In my mind, this is a huge aspect of the scenario, possibly the biggest one. It's not just SO, either, it's docs from around the web that pre-suppose you're in a Bash-like shell. \r\n* Irrespective of whether things like #1995 gets fixed, the point there is that a) there's a long tail of weird edge cases like that, and b) they're really hard to fix without breaking people. It's not necessarily true of all them, but we've hit it enough over the last couple years that it's apparent to me we need a \"trap door\" like this to get people out of hairy situations where they don't want to dive down the rabbit hole of our nested escaping (only to discover there's a bug like #1995 that prevents them from working even once they *do* know what they're knowing). \r\n\r\nIn reviewing the comments, I think there are two open questions we still need to answer:\r\n\r\n1. **Do we continue to parse command separators and everything after them in PowerShell, or does the command separator also get passed verbatim to the native shell?**\r\n  I say that we should pass *everything* verbatim to the native shell as that's currently something that you can't do, and that @oising's solution of a leading parenthetical *may* be the solution in that we can still support pipes, pipeline chains, etc. if you want to mix/match native and PS parsing (though I want to get some opinions from those closer to the parser). \r\n2. **What's the operator?**\r\n  As alluded above, I like `--%` because it's already got a reputation as the \"just do what it used to do\" operator, and we're going to have to reset on discoverability with anything new. I understand arguments like @mklement0's that, if we do this, we are changing the technical meaning of `--%` (and @SteveL-MSFT has made this argument to me as well), but I don't think most people out in the wild are thinking of `--%` in terms of \"it does what it used to do in cmd\". I don't think it's a stretch to codify this assumption into the operator's definition as \"do what the native shell does here\". \r\n\r\nOrthogonally, just thought of another scenario we may or may not want to support. \r\n\r\nOn Windows, cmd (effectively) includes the current directory in its `PATH` lookup. However, PowerShell requires that the user pre-pend a `./` in order to execute any EXEs (or anything in `PATHEXT`) if the current directory is not in `PATH`. \r\n\r\nSo my open question is: do we want to actually hand the entire command string to cmd? I'd propose that if we really want to light up the copy/paste scenario with this operator, that the answer is yes, as some third-party docs/tutorials don't necessarily detail how to put the tools they expect you to use into the `PATH`. It *probably* doesn't matter that much either way, but I did want to enumerate it here. \r\n",
      "created_at": "2020-07-14T17:55:34Z",
      "updated_at": "2020-07-14T17:55:34Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> * I'm still not on board with a vNext/8.0 that decides to break a whole new litany of stuff.\r\n\r\nYeah I don't know how you fix these problems without breaking in incredibly difficult to troubleshoot ways.  Plus I don't know about y'all but even I don't want to have to juggle all these complicated binder/parser differences when writing for multiple versions.\r\n\r\nUsually if I'm arguing against breaking changes it's for other folks.  This though, seems like it'd probably be a PITA to deal with even for folks present in ITT.\r\n\r\n> * Like @oising suggested, I'm in favor of `--%` as the operator, overloaded to be used in the front. (...) Why not just start the line with `--% native.exe do /some $stuff`?\r\n\r\nI really like this.  Ideally as close to calling `CreateProcess`/`exec` as possible (plus nix env var handling and in/out redirection or console attachment).  Or maybe falling back to `cmd.exe`/`bash` completely.\r\n",
      "created_at": "2020-07-14T18:30:21Z",
      "updated_at": "2020-07-14T18:30:21Z"
    },
    {
      "author": "oising",
      "author_association": "CONTRIBUTOR",
      "body": "I'm not stuck on keeping `&` in front of `--%` either. I can justify the idea of treating raw `--%` like a directive/operator in my head at least. What about multiline? Allow `--%` with `@\"` and `\"@` for var substitutions and subexpressions, and single quote `@'` and `'@` to pass literal? Without the here strings, it's single line only?",
      "created_at": "2020-07-14T18:48:36Z",
      "updated_at": "2020-07-14T18:48:36Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "> Like @oising suggested, I'm in favor of --% as the operator\r\n\r\nWorks for me. \r\n\r\n>Question, though: do we even need the & call operator here?\r\n\r\nAs long as I can still do `--% & $computedPathToNativeExe foo;@workspace` then fine by me.  We do need to be able to use the call operator with this.\r\n\r\n> I say that we should pass everything verbatim to the native shell as that's currently something that you can't do\r\n\r\nAgreed.\r\n\r\n> I don't think it's a stretch to codify this assumption into the operator's (--%) definition as \"do what the native shell does here\".\r\n\r\nAlso agreed!",
      "created_at": "2020-07-14T18:49:06Z",
      "updated_at": "2020-07-14T18:56:39Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "Also, maybe this is a way to get in the feature to define env vars before the executable that are defined just for the executable's session (#3316):\r\n```powershell\r\n--% JEKYLL_ENV=production jekyll build\r\n```\r\nJust a thought. ",
      "created_at": "2020-07-14T18:52:53Z",
      "updated_at": "2020-07-14T18:52:53Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@rkeithhill, the idea with the `call native operator` is that the line isn't processed by PowerShell and sent verbatim to the \"default shell\" of the OS.  So in this case, your first example `--% & $computerPathToNativeExe foo;@workspace` would not work.  You would have to use the current method and escape as appropriate.  The second case `--% JEKYLL_ENV=productoin jekyll build` should just work.",
      "created_at": "2020-07-14T18:59:24Z",
      "updated_at": "2020-07-14T18:59:24Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "> the line isn't processed by PowerShell and sent verbatim to the \"default shell\" of the OS\r\n\r\nOK, that seems reasonable.  However this `--% JEKYLL_ENV=productoin jekyll build` would just work on Linux/macOS but not on Windows - at least not without some help from PowerShell, right?",
      "created_at": "2020-07-14T19:07:30Z",
      "updated_at": "2020-07-14T21:52:49Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@rkeithhill as currently proposed that won't ever work on Windows as it relies on the OS \"default\" shell.  For PowerShell declaring env var for a process, we have a different issue opened to discuss that.",
      "created_at": "2020-07-14T20:00:39Z",
      "updated_at": "2020-07-14T20:00:39Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee discussed this today, I've updated the original proposal to reflect the result of that discussion.  We'll move forward with an experimental feature implementation and get more feedback from users with working code.  We are still open on the sigil for the operator, but using `--%` for now.",
      "created_at": "2020-07-14T20:40:35Z",
      "updated_at": "2020-07-14T20:40:51Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> where `$foo` is a literal filename and `$PWD` is current directory within WSL. Note that in the first example, you would have to know to escape `&&` to have it execute within WSL instead of within PowerShell.\r\n\r\nBoth `$foo` and `$PWD` are variable references to be evaluated by `sh`.\r\n\r\n> \r\n> To pipe output from such execution back into PowerShell, the user is required to store the results into a variable first:\r\n```powershell\r\n$out = --% ls *.txt\r\n$out | select-string hello\r\n```\r\n> Note that unlike the current `&` call operator, you cannot use any PowerShell syntax, so:\r\n```powershell\r\n--% $commandline\r\n```\r\n\r\nwill try to execute `$commandline` literally (under `cmd`) or after shell expansion (under `sh`). PowerShell will not attempt to resolve that variable.\r\n\r\n> \r\n> The cut & paste problem is solved by simply pasting after `&n ` is typed.\r\n\r\nby simply pasting after `--% `\r\n\r\n \r\n> The above example for `wsl` would look like:\r\n\r\nWhich one?\r\n\r\n> Since all of the arguments after `--%` is passed to the \"default\" shell, to support pipelining into PowerShell, you would need to use a variable:\r\n\r\nThis is a repetition.\r\n \r\n",
      "created_at": "2020-07-14T21:11:37Z",
      "updated_at": "2020-07-14T21:11:37Z"
    },
    {
      "author": "romero126",
      "author_association": "CONTRIBUTOR",
      "body": "If we are going to add something useful I propose a Pivot.\n\nWhy cant we have something like a herestring Literal \n\n@!\"\"!@\n\nSo we can have a real way to do this instead of a --% which also has its own host of issues.\n\nAtleast that way we can bury the issue with \"better\" design tactics.\nAnd discoverability for these edge cases to sit in About_Strings where it should be solved in.\n\nJust a thought.",
      "created_at": "2020-07-14T22:20:17Z",
      "updated_at": "2020-07-14T22:20:17Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "I fail to see how `@!\"\u2026\"!@` is better than `Invoke-NativeShell @\"\u2026\"@`.  Are we trying to make PowerShell more Brainfuck-like?",
      "created_at": "2020-07-15T11:28:03Z",
      "updated_at": "2020-07-15T11:28:03Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "@yecril71pl \r\n>I fail to see how `@!\"\u2026\"!@` is better than `Invoke-NativeShell @\"\u2026\"@`. Are we trying to make PowerShell more Brainfuck-like?\r\n\r\nI believe, that @romero126 meant to suggest a oneline herestring literal, such that one could write\r\n```\r\nInvoke-NativeShell @!\"complicated native command with \"quotes\" and | pipe\"!@\r\n```\r\ninstead of\r\n```\r\nInvoke-NativeShell @\"\r\ncomplicated native command with \"quotes\" and | pipe\r\n\"@\r\n```\r\n\r\nIf such a oneline herestring would be considered, I'd suggest to use syntax like `@\"\"\"\u2026\"\"\"@` and `@'''\u2026'''@`, this would be IMO easier to type than `@!\"\u2026\"!@`.\r\n\r\n---\r\n\r\n@romero126 Could you clarify what you meant?\r\n",
      "created_at": "2020-07-15T13:16:16Z",
      "updated_at": "2020-07-16T13:22:40Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@yecril71pl thanks for catching those errors, updated the top message with fixes.",
      "created_at": "2020-07-15T14:21:24Z",
      "updated_at": "2020-07-15T14:21:24Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "It is unspecified whether `--%` will execute as command line or as a batch file.",
      "created_at": "2020-07-15T15:39:55Z",
      "updated_at": "2020-07-15T15:39:55Z"
    },
    {
      "author": "romero126",
      "author_association": "CONTRIBUTOR",
      "body": "> \r\n> I believe, that @romero126 meant to suggest a oneline herestring literal, such that one could write\r\n> \r\n> ```\r\n> Invoke-NativeShell @!\"complicated native command with \"quotes\" and | pipe\"!@\r\n> ```\r\n> \r\n> instead of\r\n> \r\n> ```\r\n> Invoke-NativeShell @\"\r\n> complicated native command with \"quotes\" and | pipe\r\n> \"@\r\n> ```\r\n> \r\n> If such a oneline herestring would be considered, I'd suggest to use syntax like `@\"\"\"\u2026\"\"\"@` and `@'''\u2026'''@`, this would be IMO easier to type than `@!\"\u2026\"!@`.\r\n> \r\n> @romero126 Could you clarify what you meant?\r\n\r\nI believe if we add flexibility to Strings to handle \"almost raw\" unparsed data we wouldn't have issues about this pop up.\r\n@TSlivede I agree almost Completely with what you said. Only with a slight variation. It should be able to handle BOTH single line and Multiline without interpolating anything inside the quotes. Whatever Syntax we land on to make that happen I am open to. I am more focused on the concept..\r\n\r\nWith these examples it adds a lot of Flexibility where I don't need to \"Invoke-NativeShell\" as it would just return a string. Which means we are free to manipulate it just like a string would be. So that this potentially could become a Staple of what great looks like. \r\n\r\nA Pivot like this also would mean we wouldn't have to deal with issues above where we spin our wheels on an almost solution when we can handles an edge case, vs addresses the problem as a whole.\r\n\r\nQuick Examples:\r\n``` PowerShell\r\n# For this scenario let @!\"<text>\"!@ be our HereString Verbatim\r\n\r\nInvoke-NativeShell @!\"complicated native command with \"quotes\" and | pipe\"!@\r\n# or\r\nInvoke-NativeShell @!\"\r\nComplicated native command with \"quotes\" and pipe and <tabs>\r\n\"!@\r\n\r\n#or \r\n$r = @!\"\r\ncomplicated native command with custom arguments: {0}\r\n\"!@ -format \"foo\"\r\nInvoke-NativeShell $r\r\n``` \r\n",
      "created_at": "2020-07-15T16:42:41Z",
      "updated_at": "2020-07-15T16:42:41Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "That doesn't address the issue @mklement0 cover in the second part of [this comment](https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-654851541). Fact of the matter is, we can't just pass a single string to every comand ever; in many cases they have to be split up.",
      "created_at": "2020-07-15T16:44:51Z",
      "updated_at": "2020-07-15T16:44:51Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> I believe if we add flexibility to Strings to handle \"almost raw\" unparsed data we wouldn't have issues about this pop up.\r\n\r\nThis is what `'` and `@'` are for.\r\n\r\n> With these examples it adds a lot of Flexibility where I don't need to \"Invoke-NativeShell\" as it would just return a string. Which means we are free to manipulate it just like a string would be. So that this potentially could become a Staple of what great looks like.\r\n\r\nNative commands return a sequence of strings.  `@!\"` has the potential of becoming a Staple of what unintelligible looks like.\r\n\r\n",
      "created_at": "2020-07-15T17:09:07Z",
      "updated_at": "2020-07-15T17:09:07Z"
    },
    {
      "author": "romero126",
      "author_association": "CONTRIBUTOR",
      "body": "> > I believe if we add flexibility to Strings to handle \"almost raw\" unparsed data we wouldn't have issues about this pop up.\n> \n> \n> \n> This is what `'` and `@'` are for.\n> \n> \n> \n> > With these examples it adds a lot of Flexibility where I don't need to \"Invoke-NativeShell\" as it would just return a string. Which means we are free to manipulate it just like a string would be. So that this potentially could become a Staple of what great looks like.\n> \n> \n> \n> Native commands return a sequence of strings.  `@!\"` has the potential of becoming a Staple of what unintelligible looks like.\n> \n> \n> \n> \n\nI think you are confused. With the point I was making.\nSingle quotes and Double quotes do only expand $variable or not. It does not automatically escape characters. It also limits me so I can no longer use its defining character. So instead For it to work properly as it is now. I would still have to escape characters which is the entire point of why we needed to include a &! Command.\n\nIf you have a better solution I am all ears. I do believe this hits more edge cases than adding a &!\n\n",
      "created_at": "2020-07-15T22:12:46Z",
      "updated_at": "2020-07-15T22:12:46Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> Single quotes and Double quotes do only expand $variable or not. It does not automatically escape characters. It also limits me so I can no longer use its defining character. So instead For it to work properly as it is now. I would still have to escape characters which is the entire point of why we needed to include a &! Command.\r\n\r\nWhich characters would you have to escape and why?\r\n\r\n",
      "created_at": "2020-07-15T22:55:53Z",
      "updated_at": "2020-07-15T22:55:53Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "@romero126 Now I'm confused what you are saying. Are you aware, that powershell [has a here string](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_quoting_rules#here-strings)?\r\n\r\nI previously thought, that you might consider the syntax of powershells here strings annoying (At least I am sometimes annoyed, that there has to be a newline at the beginning and the end...), but now I'm not so sure what you are saying, could you clarify?",
      "created_at": "2020-07-16T13:21:53Z",
      "updated_at": "2020-07-16T18:49:07Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@TSlivede, agreed on here-strings being syntactically somewhat cumbersome.\r\n\r\nThere is an existing proposal, #2337, that proposes improvements, and while it is focused on allowing the closing delimiter to be indented, @lzybkr also proposes a Rust-like _single-line_(-also) variation in https://github.com/PowerShell/PowerShell/issues/2337#issuecomment-391152107, which would allows us to do the following, for instance:\r\n\r\n```powershell\r\n# `ins` is `Invoke-NativeShell`\r\nins @' python -c 'print(\"hi\")' | cat -n '@\r\n```\r\n\r\nThe need for escaping would be avoided by combining _multiple_ `'` with `@`, as needed (e.g., `@'' can use @' here ''@`.\r\n\r\nIn other words: this would be a general enhancement to PowerShell string literals, usable everywhere, which `Invoke-NativeShell` would benefit from as well.\r\n\r\nGiven that #2337 is primarily focused on something else, I've created a **focused proposal in #13204** , and I suggest we continue the conversation there.\r\n",
      "created_at": "2020-07-17T15:05:02Z",
      "updated_at": "2020-07-17T17:04:08Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> The need for escaping would be avoided\r\n\r\nI've seen this a couple of times in this thread.\r\n\r\nAny indicator to the tokeniser to begin a new mode would need an escape mechanism, since you need to differentiate the indicator to the tokeniser that you're leaving that mode from the literal form of that character.\r\n\r\nThe most natural form of that today is single-quoted strings:\r\n\r\n- `'`: start single-quote tokenisation\r\n- `'`: end single-quote tokenisation\r\n- `''`: write a literal single quote within a single-quoted string\r\n\r\nI think the reason we're talking about escaping despite this is:\r\n\r\n- The `--%` operator defines too many ways to exit its mode (`|`, `&&`, `||`, `;`, newline) and allows strings within it (stripping their `'` characters)\r\n- Herestrings and co resolve to one string argument rather than an array of them\r\n\r\nWanting to pass arguments to an executable invocation mean we're actually talking about an array syntax:\r\n\r\n- How to start the array (start verbatim mode)\r\n- How to separate the array (pass a single argument to the new executable)\r\n- How the end the array (end verbatim mode)\r\n\r\n(This is a native concept on *nix, since [`exec`](https://man7.org/linux/man-pages/man3/exec.3.html) expects an array. On Windows, I think we're forced to take an array, serialise it to a particular string syntax and pass it through [`CommandLineToArgvW`](https://docs.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-commandlinetoargvw). However, .NET provides an array-based abstraction for both of these -- so arrays make the most sense still)\r\n\r\nThat means we need two escapes:\r\n\r\n- The array separator literal\r\n- The array end literal\r\n\r\nFor example, let's say:\r\n\r\n- `--%` before the command becomes the new verbatim syntax\r\n- How do we end the syntax? newline and `;` maybe?\r\n- How do we separate arguments? ` `  maybe?\r\n\r\nThe questions then are:\r\n\r\n- How do we pass a literal `;` or newline?\r\n- How do we pass a literal ` `?",
      "created_at": "2020-07-17T17:11:16Z",
      "updated_at": "2020-07-17T17:23:28Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "A native command line is not an array.  It is either a string or an AST.  Since PowerShell does not know anything about ASTs in native shells, only a string remains.",
      "created_at": "2020-07-17T17:25:58Z",
      "updated_at": "2020-07-17T17:25:58Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> A native command line is not an array. It is either a string or an AST\r\n\r\nYou haven't provided any grounds for this assertion.\r\n\r\nHere's where PowerShell builds the AST for a command (of any kind, since it does not know until runtime when the command resolves what kind of command it is):\r\n\r\nhttps://github.com/PowerShell/PowerShell/blob/f82f74d89811e91613a7450e536d652c5d8f784e/src/System.Management.Automation/engine/parser/Parser.cs#L6391-L6634\r\n\r\nNotice that command elements (including parameters and arguments) are added into an array.\r\n\r\nYou can see this in action in PowerShell like this:\r\n\r\n```\r\n> { ping 192.168.0.1 }.Ast.EndBlock.Statements[0].PipelineElements[0].CommandElements\r\n\r\nStringConstantType : BareWord\r\nValue              : ping\r\nStaticType         : System.String\r\nExtent             : ping\r\nParent             : ping 192.168.0.1\r\n\r\nStringConstantType : BareWord\r\nValue              : 192.168.0.1\r\nStaticType         : System.String\r\nExtent             : 192.168.0.1\r\nParent             : ping 192.168.0.1\r\n```\r\n\r\nThat array is compiled into expressions here:\r\n\r\nhttps://github.com/PowerShell/PowerShell/blob/f82f74d89811e91613a7450e536d652c5d8f784e/src/System.Management.Automation/engine/parser/Compiler.cs#L4127-L4160\r\n\r\nAnd then that is passed to a pipeline invocation here (notice `Expression.NewArrayInit(typeof(CommandParameterInternal[]), pipelineExprs)` is where the arguments are passed):\r\n\r\nhttps://github.com/PowerShell/PowerShell/blob/f82f74d89811e91613a7450e536d652c5d8f784e/src/System.Management.Automation/engine/parser/Compiler.cs#L3798-L3805\r\n\r\n\r\nAt runtime, when the compiled expressions are run, that becomes [this method call](https://github.com/PowerShell/PowerShell/blob/f82f74d89811e91613a7450e536d652c5d8f784e/src/System.Management.Automation/engine/runtime/Operations/MiscOps.cs#L411-L417), which passes through to this call which decides what command processor to use:\r\n\r\nhttps://github.com/PowerShell/PowerShell/blob/f82f74d89811e91613a7450e536d652c5d8f784e/src/System.Management.Automation/engine/runtime/Operations/MiscOps.cs#L29-L312\r\n\r\nEventually, when the pipeline is called, that argument array is bound to the native command using the `NativeCommandParameterBinder`:\r\n\r\nhttps://github.com/PowerShell/PowerShell/blob/f82f74d89811e91613a7450e536d652c5d8f784e/src/System.Management.Automation/engine/NativeCommandParameterBinder.cs#L69-L137\r\n\r\nThat takes the argument array, which includes AST metadata like what kind of string was used for each argument, and builds a new string for argument invocation in the `NativeCommandProcessor` here:\r\n\r\nhttps://github.com/PowerShell/PowerShell/blob/f82f74d89811e91613a7450e536d652c5d8f784e/src/System.Management.Automation/engine/NativeCommandProcessor.cs#L1094-L1166\r\n\r\nThis is done because the .NET API we currently use for process invocation is the old \"all arguments in a single string\" version, rather than the new one in .NET Core that allows you to pass an array and lets .NET rebuild the invocation as needed in a platform specific way.\r\n\r\nBut us using that API is an implementation detail. For example, we could call `fork`/`exec` directly on *nix, like we do here:\r\n\r\nhttps://github.com/PowerShell/PowerShell/blob/f82f74d89811e91613a7450e536d652c5d8f784e/src/powershell/Program.cs#L268-L330\r\n\r\nNotice that `exec` here takes an array -- we did that because it's the simplest and most direct way of passing arguments to the syscall, which is ultimately the goal of a verbatim argument syntax.\r\n",
      "created_at": "2020-07-17T18:05:11Z",
      "updated_at": "2020-07-17T18:09:52Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@rjmholt:\r\n\r\n_Functionally_, all needs are already covered by the existing string-literal forms, _if you pass the native command line as a single string_, which I strongly recommend, via a new `Invoke-NativeShell` / `ins` cmdlet.\r\n\r\n**The starting point here is as _single string_, not an array: it is an _entire command line_ - to be parsed _by the target shell_** - and it makes the most sense to reflect this in PowerShell as such - as opposed to trying to awkwardly shoehorn a different shell's syntax into PowerShell's with something like `--%`\r\n\r\n**All that `Invoke-NativeShell` has to do is to pass the single string that contains the entire native-shell command line to the native shell via its CLI:**\r\n\r\n  * on **Unix**, this means: pass the string as-is, _as whole_, as the second element of the argument _array_ passed to `exec` (with  `-c` being the first argument-array element, and `/bin/sh` the executable); expressed in .NET terms with a simple example, where `printf \"'%s'\" foo | cat -n` is the verbatim content of the single string containing the command line to pass through (note the use of `.ArgumentList`, not `.Arguments`; the doubling of `'` s an artifact of this example only):\r\n     * `$psi = [Diagnostics.ProcessStartInfo]::new('/bin/sh');  $psi.ArgumentList.Add('-c'); $psi.ArgumentList.Add('printf \"''%s''\" foo | cat -n'); [Diagnostics.Process]::start($psi).WaitForExit()`\r\n\r\n  * on **Windows**, this means: to accommodate `cmd`'s quirks, fill the `lpCommandLine` argument of `CreateProcess` as follows (with `lpApplicationName` assumed to be the value of environment variable `ComSpec`, which points to `cmd.exe`): `\"/c \" + cmdLine`, where `cmdLine` is the whole command-line string as-is; expressed in .NET terms with a simple example, where `echo a^&b & ver` is the verbatim content of the single string containing the command line to pass through:\r\n     * `$psi = [Diagnostics.ProcessStartInfo]::new($env:ComSpec);  $psi.Arguments = '/c ' + 'echo a^&b & ver'; [Diagnostics.Process]::start($psi).WaitForExit()`\r\n    * @yecril71pl, this implies the answer to your question as to whether command-prompt or batch-file semantics are to be used: it is the former, as also used by other scripting languages, such as Python with `os.system()`; the (perhaps unfortunate) implication is that you won't be able to escape `%` characters, and that `for` loop variables must use a single `%` (e.g., `%i` instead of `%%i`); and that you must prefix loop-body commands with `@` to prevent them from being echoed (e.g., `for %i in (*.txt) do @echo %i`).\r\n\r\nThis process will be _transparent to the end user_, so that all they need to focus on is to pass the native-shell command line _verbatim_, only needing to satisfy _PowerShell's_ string-literal syntax requirements:\r\n\r\nWith the form `ins @'<newline>...<newline>'@`, you already _can_ use your native-shell command lines as-is: see [above](https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-653526374) for how the various existing string-literal forms can be used, which - due to the availability of the _interpolating_ here-string form (`@\"<newline>...<newline>\"@`) as well - includes the ability to use _PowerShell_ variables and expressions in the command line (the inability to do so is one of the major shortcomings of `--%`).\r\n\r\n**What my previous comment proposes is a _new general form of raw string  literal_, which is _separate from this proposal_** (and its parsing logic is (hopefully) well-defined);  though, as stated,  `Invoke-NativeShell` calls would then be _more convenient_.\r\n\r\n\r\nInstead of what you can already do (assuming an `Invoke-NativeShell` / `ins` command):\r\n\r\n```powershell\r\n# ALREADY WORKS: Literal here-string\r\nins @'\r\npython -c 'print(\"hi\")' | cat -n\r\n'@\r\n```\r\n\r\nwith the proposed new single-line raw literal you could simplify to:\r\n\r\n```powershell\r\n# PROPOSED, more convenient syntax: new raw literal.\r\nins @' python -c 'print(\"hi\")' | cat -n '@\r\n```\r\n\r\nIf the specifics of this new raw string-literal syntax need debating, please let us do it in #13204, not here.\r\n",
      "created_at": "2020-07-17T18:11:02Z",
      "updated_at": "2020-07-18T22:12:16Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "So rereading the proposal to understand the original intent, I see it's really just asking for a better syntax for `/bin/sh -c '<command>'` + the cmd version, along with a special string escape logic for each target shell. I had based my initial conception on a special syntax and needing to work with the parser and native command processor, and on .NET's `ProcessStartInfo.Arguments` property being [very difficult to use correctly in terms of quote passing](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.processstartinfo.arguments?view=netcore-3.1#remarks).\r\n\r\nBut in fact [the `Arguments` string just gets passed through verbatim](https://github.com/dotnet/runtime/blob/6072e4d3a7a2a1493f514cdf4be75a3d56580e84/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.Win32.cs#L49). So all we need to do is pass such a string through directly.\r\n\r\nIn that case, I think any new syntax is totally unneeded (it will just complicate tokenisation logic and I suspect confuse people) and instead this is just a new command, `ins` like you say. .NET has some logic for this [here](https://github.com/dotnet/runtime/blob/6072e4d3a7a2a1493f514cdf4be75a3d56580e84/src/libraries/System.Private.CoreLib/src/System/PasteArguments.cs#L8-L97) which we'll be forced to reimplement, but that's ok since we need to be a little bit cleverer anyway.",
      "created_at": "2020-07-17T18:38:52Z",
      "updated_at": "2020-07-17T18:38:52Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "Some comments on @rjmholt's comment https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-660231641\r\n\r\n> Any indicator to the tokeniser to begin a new mode would need an escape mechanism, since you need to differentiate the indicator to the tokeniser that you're leaving that mode from the literal form of that character.\r\n\r\nI agree and I don't think an in-line here string syntax can completely avoid the need to escape.\r\n\r\n> The --% operator defines too many ways to exit its mode (|, &&, ||, ;, newline) and allows strings within it (stripping their ' characters)\r\n\r\nWhen speaking of `--%`, are you referring to the existing `--%` switch? If so, it's better to make that clear in your comment, as now `--%` is proposed to be a call operator.\r\n\r\n> Wanting to pass arguments to an executable invocation mean we're actually talking about an array syntax:\r\n\r\nThe proposal is to call the native shell (sh or cmd) and pass everything literally after the call operator `--%`, like `sh -c ...`. So it's not powershell that passes the arguments to the target executable. In that case, I think we don't need _an array syntax_, right?\r\n\r\n> How do we end the syntax? newline and ; maybe?\r\n> How do we separate arguments? 'space' maybe?\r\n\r\nI think the verbatim parsing ends at newline. To pass in a new line as part of the argument, use `\\n` I guess, just like what you do in bash directly.",
      "created_at": "2020-07-17T18:39:14Z",
      "updated_at": "2020-07-17T18:40:33Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> > A native command line is not an array. It is either a string or an AST\r\n> \r\n> You haven't provided any grounds for this assertion.\r\n> \r\n> Here's where PowerShell builds the AST for a command (of any kind, since it does not know until runtime when the command resolves what kind of command it is):\r\n\r\nIf this proposal gets implemented, it will introduce a special construct where PowerShell will not build the AST at all.",
      "created_at": "2020-07-17T18:47:18Z",
      "updated_at": "2020-07-17T18:47:18Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Glad to hear it, @rjmholt.\r\n\r\n> .NET has some logic for this here which we'll be forced to reimplement\r\n\r\nI don't think we actually need to reimplement anything, as the commands in my previous comment show: on Windows, use `.Arguments` for whole-command-line-string pass-through to the WinAPI; on Unix, use `.ArgumentList` to construct the argument _array_ that is used directly with `exec`.\r\n\r\n",
      "created_at": "2020-07-17T18:50:20Z",
      "updated_at": "2020-07-17T18:53:46Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> If this proposal gets implemented, it will introduce a special construct where PowerShell will not build the AST at all.\r\n\r\nWell it would build a different AST type, one designed for this purpose.  If it's not part of the AST then it's basically the same as a comment, nothing happens.",
      "created_at": "2020-07-17T19:04:02Z",
      "updated_at": "2020-07-17T19:04:02Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> _Functionally_, all needs are already covered by the existing string-literal forms, _if you pass the native command line as a single string_, which I strongly recommend, via a new `Invoke-NativeShell` / `ins` cmdlet.\r\n\r\nI personally like the `Invoke-NativeShell` cmdlet idea, in some ways better than the call operator `--%`. The main concern I heard about this idea is that it's more typing than `--%`+<kbd>Ctrl+v</kbd> and differentiating literal here-string from interpolating here-string is another burden to user (_I personally think `ins` is way easier to type than `--%`_).",
      "created_at": "2020-07-17T19:04:42Z",
      "updated_at": "2020-07-17T19:04:42Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> The main concern I heard about this idea is that it's more typing than `--%`+Ctrl+v and differentiating literal here-string from interpolating here-string is another burden to user (_I personally think `ins` is way easier to type than `--%`_).\r\n\r\nMaybe PSRL can help.  Similar to the issue about a key handler to surround pasted paths, PSRL could read the `CommandAst`, see it's `ins` and properly escape the pasted string.\r\n\r\n",
      "created_at": "2020-07-17T19:08:13Z",
      "updated_at": "2020-07-17T19:08:13Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> Well it would build a different AST type, one designed for this purpose. If it's not part of the AST then it's basically the same as a comment, nothing happens.\r\n\r\nSure but the tree will be trivial.  It will not reflect the meaning of the commands that are to be executed.",
      "created_at": "2020-07-17T19:12:13Z",
      "updated_at": "2020-07-17T19:12:13Z"
    },
    {
      "author": "romero126",
      "author_association": "CONTRIBUTOR",
      "body": "Start process cmd.exe redirect stdin / stdio and we can literally use a string to invoke-NativeCommand same with bash \n\n",
      "created_at": "2020-07-17T19:39:35Z",
      "updated_at": "2020-07-17T19:39:35Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Glad to hear it, @daxian-dbw.\r\nLove the idea, @SeeminglyScience .\r\n\r\n> differentiating literal here-string from interpolating here-string is another burden to user \r\n\r\nI think that's a _plus_, because - unlike `--%` - use of `@\"<newline>...<newline>\"@` allows you to directly incorporate  the values of _PowerShell_ variables and expressions into the native command line.\r\n\r\nOf course, that assumes that users know the difference between single-quoted (verbatim) and double-quoted (interpolating) strings and about selective `` ` ``-escaping of `$`, but I think it's an important (advanced) option to have.\r\n\r\nTo help the cut-and-paste users, the proposed PSReadLine feature should  default to `@'<newline>...<newline>'@` (verbatim).\r\n\r\n---\r\n\r\nUltimately, we don't want to promote a mindset where users don't need to know and understand PowerShell's unique syntax requirements - instead, we want to promote understanding of them, in light of the _added power they bring_.\r\n\r\n**But to encourage users to use PowerShell's _own_ syntax, which is by definition _cross-platform_, it must work predictably**.\r\n**To that end, #1995 must be fixed**, ideally directly, allowing a breaking change, or, if that's not an option, via a minimal-ceremony _opt-in_.\r\n\r\nTo summarize: \r\n\r\n* **Something like `--%` (the new operator form proposed here), by definition a _platform-specific_ feature, is in no way a substitute for fixing #1995**.\r\n\r\n* `Invoke-NativeShell` (`ins`) avoids all the limitations of the proposed `--%` operator and provides the \"trap door\" solution that @joeyaiello  mentioned: a quick way to execute a command line written for the native shell, without having to adapt it to PowerShell's syntax.\r\n\r\n* `--%` should remain in its original _argument_ form only, and should remain a _Windows-only_ feature (which it _effectively_, albeit not _technically_ is) - in other words: no change needed.\r\n    * Once #1995 is fixed, `--%`'s sole purpose will be to accommodate _edge cases on Windows_: allowing you to control the explicit quoting of the command line passed to rogue programs such as `msiexec` that require very specific forms of intra-argument quoting.\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-07-17T19:49:55Z",
      "updated_at": "2020-07-17T20:02:14Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "One of the other features I really want in PS v7.x is the ability to have a native command exiting with an error code stop my script, like `set -e`  as discussed in this [RFC](https://github.com/PowerShell/PowerShell-RFC/pull/88/files?short_path=e6e13bd#diff-e6e13bdbc99ad974811df49f562f816b).  **If** the solution to that is something like an `Invoke-NativeCommand`, would that get confusing with `Invoke-NativeShell`?  \r\n\r\nJust trying to play the movie forward a bit because as much as I want the call native feature, I really want my build & test scripts to error out when calling msbuild, cl, cmake, Conan, npm, etc and those native commands exit with a non-zero exit code without having to remember to check $LASTEXITCODE all the time.  If the implementation is via just another preference variable e.g. `$PSNativeCommandInErrorActionPreference` then I suppose that would impact the invocation of the native shell - it being a native \"command\" and all?",
      "created_at": "2020-07-17T22:23:54Z",
      "updated_at": "2020-07-17T22:23:54Z"
    },
    {
      "author": "oising",
      "author_association": "CONTRIBUTOR",
      "body": "> > The main concern I heard about this idea is that it's more typing than `--%`+Ctrl+v and differentiating literal here-string from interpolating here-string is another burden to user (_I personally think `ins` is way easier to type than `--%`_).\r\n> \r\n> Maybe PSRL can help. Similar to the issue about a key handler to surround pasted paths, PSRL could read the `CommandAst`, see it's `ins` and properly escape the pasted string.\r\n\r\nBut what about:\r\n\r\n```\r\n$c = gcm ins\r\n& $c ...\r\n```\r\nPSRL is going to have a hard time recognizing what's going on there. It would have to be stateful, resolve the alias ins to invoke-nativeshell, then figure out that you want to call the commandinfo, then demunge the args? I really, really dislike the idea of special casing a fake command. ",
      "created_at": "2020-07-18T03:32:46Z",
      "updated_at": "2020-07-18T03:32:46Z"
    },
    {
      "author": "oising",
      "author_association": "CONTRIBUTOR",
      "body": "> > differentiating literal here-string from interpolating here-string is another burden to user\r\n> \r\n> I think that's a _plus_, because - unlike `--%` - use of `@\"<newline>...<newline>\"@` allows you to directly incorporate the values of _PowerShell_ variables and expressions into the native command line.\r\n\r\nI'm not following you @mklement0. Why can't `--%` be taught to do this? I already gave this as a use case.",
      "created_at": "2020-07-18T03:44:54Z",
      "updated_at": "2020-07-18T03:44:54Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> I really, really dislike the idea of special casing a fake command.\r\n\r\nThere is no fake command here, only a bona fide cmdlet, `Invoke-NativeShell`, aliased to `ins`.\r\n\r\n`gcm ins`  (`Get-Command ins`) will provide information about the `ins` alias in the form of a `[System.Management.Automation.AliasInfo]` instance, which you can later pass to `&` for invocation, as with any other command or alias.\r\n\r\nTherefore, your example will work exactly as intended - it's just that if you use the `gcm`  (`Get-Command`) detour, you'll have to spell out the appropriate string-literal syntax _yourself_, without the _optional convenience command scaffolding_ that PSRL _could_ provide, if @SeeminglyScience's suggestion is implemented:\r\n\r\n```powershell\r\n$c = gcm ins\r\n& $c @'\r\npython -c 'print(\"hi\")' | cat -n\r\n'@\r\n```\r\n\r\nOr, if the new raw string-literal syntax proposed in #13204 is implemented:\r\n\r\n```powershell\r\n$c = gcm ins\r\n& $c @' python -c 'print(\"hi\")' | cat -n '@\r\n```\r\n\r\nOf course, if you're familiar with the syntax of PowerShell's string literals, a regular single-quoted string will do too: simply double the embedded `'` inside the overall `'...'` string:\r\n\r\n```powershell\r\n$c = gcm ins\r\n& $c 'python -c ''print(\"hi\")'' | cat -n'\r\n```\r\n",
      "created_at": "2020-07-18T04:01:08Z",
      "updated_at": "2020-07-18T11:31:34Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": ">  Why can't `--%` be taught to do this?\r\n\r\n* `--%` is lacking a closing delimiter, which prevents it use in Powershell pipelines, which is an unacceptable restriction (note that `(...)` enclosure is _not_ an option, because that implies up-front collection of all output lines in memory rather than _streaming_ processing).\r\n\r\n* On Unix, `--%` cannot _both_ support (unescaped) `$` as a PowerShell metacharacter _and_ as a POSIX-shell metacharacter.\r\n\r\nAgain: there is _no_ justification for and no benefit to shoehorning a _different shell's syntax_ into PowerShell - pass the native-shell command line _as a string_, to `ins`, and all conceptual problems go away.\r\n",
      "created_at": "2020-07-18T04:09:36Z",
      "updated_at": "2020-07-18T04:11:18Z"
    },
    {
      "author": "SP3269",
      "author_association": "NONE",
      "body": "Invoke-NativeShell implies that PowerShell isn\u2019t the native shell. Is that assumption always correct and always shall be? ",
      "created_at": "2020-07-18T09:10:32Z",
      "updated_at": "2020-07-18T09:10:32Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "@oising the use case is someone copy and pasting a native command from a README or something. If they're doing something more complicated than typing `ins` <kbd>SPACE</kbd> <kbd>CTRL</kbd> + <kbd>v</kbd> then they'll just build and escape their own string like normal.",
      "created_at": "2020-07-18T11:51:09Z",
      "updated_at": "2020-07-18T11:51:09Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 \r\n\r\n> **But to encourage users to use PowerShell's _own_ syntax, which is by definition _cross-platform_, it must work predictably**.\r\n> **To that end, #1995 must be fixed**, ideally directly, allowing a breaking change, or, if that's not an option, via a minimal-ceremony _opt-in_.\r\n\r\nThis is separate from the discussion on `ins`/`--%` right?  If you disagree can you clarify why that issue would affect the new command/syntax?",
      "created_at": "2020-07-18T11:57:57Z",
      "updated_at": "2020-07-18T11:57:57Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@SeeminglyScience, yes, it is separate, but that hasn't been clear in this thread. \r\nThe only reason #1995 ever came up here is that it was originally closed in favor of this issue (though fortunately reopened since), and the OP here still states that this issue will fix it (\"This should also solve these issues:\").\r\nTherefore, I wanted to stress that `ins` / `--%`  would _not_ address #1995, which requires its own fix, urgently.\r\n(Only if PowerShell's own argument passing works properly can we in good conscience recommend that users fully learn and embrace PowerShell's own syntax - which we should.)",
      "created_at": "2020-07-18T12:14:44Z",
      "updated_at": "2020-07-18T12:15:26Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@SP3269, we can cross that bridge when we get to it \ud83d\ude01.\r\n\r\nBut seriously: \r\n\r\nIf you think of \"native\" as \"written specifically for the host platform [family]\", the name would still fit, even if PowerShell should ever become the default system shell on a given platform (here's hoping, but I don't think that's realistic, at least not in the foreseeable future).\r\n\r\nAs for alternatives: \r\n\r\n* `Invoke-[System]DefaultShell` would be the most accurate name (though it would unambiguously no longer apply should PowerShell ever become a system's default shell), but \"native\" seems to be the more commonly used term in the PowerShell world.\r\n\r\n* `Invoke-LegacyShell` has some justification on Windows, but I don't think Unix users would take too kindly to that term.\r\n\r\n\r\n",
      "created_at": "2020-07-18T12:45:25Z",
      "updated_at": "2020-07-18T22:14:24Z"
    },
    {
      "author": "oising",
      "author_association": "CONTRIBUTOR",
      "body": "I think I am beginning to unravel the utter confusion I'm experiencing trying to keep track of everyone's motives, ideas and issues here. It seems that we're (@mklement0 and I, at least) are looking at this as two different solutions to two different views of the same conceptual problem. What I was suggesting was using `--%` as a hint to the _parser_ to change the way things are parsed in conjunction with the call `&` operator (not necessarily using `--%` standalone.) On the other hand, Michael seems to be looking at `ins` as a drop-in cmdlet to replace powershell's own internal native command broker and argument parser, and is not looking to change powershell's parser, instead, using strings/here-strings to capture the intended parameters (which I am saying could be used with `--%` also.) \r\n\r\n> --% is lacking a closing delimiter, which prevents it use in Powershell pipelines\r\n\r\nThis point I don't get at all. It's no more lacking a closing delimiter than ins/invoke-nativecommand is. If you need to delimit or feed from the LHS, use here-strings, else it is considered as a single statement.\r\n\r\n\r\n\r\n",
      "created_at": "2020-07-18T19:01:03Z",
      "updated_at": "2020-07-18T19:01:03Z"
    },
    {
      "author": "oising",
      "author_association": "CONTRIBUTOR",
      "body": "Regardless of whatever way is chosen, it seems that there will be a need to choose a native shell to dispatch the commandline. I suggest we use the environment variables `COMSPEC` on Windows (defaults to `%systemroot%\\system32\\cmd.exe`) and `SHELL` on Linux (defaults to `/bin/bash`) -- if SHELL doesn't exist, we should target `/bin/sh` (which in most cases is a symlink to bash anyway.)   ",
      "created_at": "2020-07-18T19:32:42Z",
      "updated_at": "2020-07-18T19:35:44Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "> >--% is lacking a closing delimiter, which prevents it use in Powershell pipelines\r\n>\r\n>This point I don't get at all. It's no more lacking a closing delimiter than ins/invoke-nativecommand is. If you need to delimit or feed from the LHS, use here-strings, else it is considered as a single statement.\r\n\r\nBasically you can't call things like `cmd --% /c someapp | someOtherApp` and have cmd handle the pipeline; PowerShell still interprets a pipeline (and a few other things like `&&` and `||` which would otherwise be useful for Unix folks) as being a PowerShell token instead of passing it to the native command as part of the argument string.",
      "created_at": "2020-07-18T19:45:24Z",
      "updated_at": "2020-07-18T19:45:24Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> and SHELL on Linux (defaults to `/bin/bash`)\r\n\r\nNo: **the _system_ shell on Unix-like platforms is _invariably_ `/bin/sh`**.\r\nThis is distinct from a given _user's_  interactive shell (reflected in `$env:SHELL` - but, unfortunately, currently not if _PowerShell_ is the user's shell, see #12150), which is (a) configurable and (b) often _defaults to_ `/bin/bash`,  but even that is not a given, as evidenced by macOS recently transitioning to `/bin/zsh` as the default interactive shell for new users.\r\n\r\n> I suggest we use the environment variables `COMSPEC` on Windows\r\n\r\nGood point, that's the better way to refer to the system shell (command interpreter) on Windows - I've updated the sample command [above](https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-660263405) accordingly.\r\n",
      "created_at": "2020-07-18T21:53:10Z",
      "updated_at": "2020-07-18T22:02:48Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> One of the other features I really want in PS v7.x is the ability to have a native command exiting with an error code stop my script, like `set -e` as discussed in this [RFC](https://github.com/PowerShell/PowerShell-RFC/pull/88/files?short_path=e6e13bd#diff-e6e13bdbc99ad974811df49f562f816b). **If** the solution to that is something like an `Invoke-NativeCommand`, would that get confusing with `Invoke-NativeShell`?\r\n> \r\n> Just trying to play the movie forward a bit because as much as I want the call native feature, I really want my build & test scripts to error out when calling msbuild, cl, cmake, Conan, npm, etc and those native commands exit with a non-zero exit code without having to remember to check $LASTEXITCODE all the time. If the implementation is via just another preference variable e.g. `$PSNativeCommandInErrorActionPreference` then I suppose that would impact the invocation of the native shell - it being a native \"command\" and all?\r\n\r\nWe have `Start-NativeExecution` in our `build` module for that purpose.",
      "created_at": "2020-07-18T21:59:21Z",
      "updated_at": "2020-07-18T21:59:21Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "I've seen that.  How exactly would you combine `Start-NativeExecution` with `Invoke-NativeShell` if you'd like the later to effectively throw on a non-zero exit code?  I really hope that something like PR #3523 makes it in along with this call native feature because I want the two to work together.   I suppose if call native winds up being implemented as a cmdlet (Invoke-NativeShell vs --%) then `-ErrorAction Stop` could be implemented to have it throw (terminating error) on a non-zero exit code.",
      "created_at": "2020-07-18T22:45:27Z",
      "updated_at": "2020-07-18T22:47:40Z"
    },
    {
      "author": "oising",
      "author_association": "CONTRIBUTOR",
      "body": "> > > --% is lacking a closing delimiter, which prevents it use in Powershell pipelines\r\n> > \r\n> > \r\n> > This point I don't get at all. It's no more lacking a closing delimiter than ins/invoke-nativecommand is. If you need to delimit or feed from the LHS, use here-strings, else it is considered as a single statement.\r\n> \r\n> Basically you can't call things like `cmd --% /c someapp | someOtherApp` and have cmd handle the pipeline; PowerShell still interprets a pipeline (and a few other things like `&&` and `||` which would otherwise be useful for Unix folks) as being a PowerShell token instead of passing it to the native command as part of the argument string.\r\n\r\nYes, I understand the *current* behaviour @vexx32 . But we're not (at least I'm not) talking about the *current* behaviour of `--%` -- we're talking about enhancing it, no? Why do I get the feeling that we're all talking around each other here? :)\r\n\r\nAs I said way, way up above, we could *enhance* `&` to work with `--%` so *this is possible*. I also think we need to be clear about implicit native exec versus explicit invocation of a shell with arguments. This is a constant source of confusion - even for seasoned windows users - that somehow cmd.exe (a shell)  is needed to \"run\" other executables; the same applies to linux/osx.\r\n\r\n\r\n",
      "created_at": "2020-07-18T22:51:20Z",
      "updated_at": "2020-07-18T22:53:46Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> Yes, I understand the _current_ behaviour @vexx32 . But we're not (at least I'm not) talking about the _current_ behaviour of `--%` -- we're talking about enhancing it, no? Why do I get the feeling that we're all talking around each other here? :)\r\n\r\nSo the current pitch for adjusting `--%` is that if it's where the command name would typically be, everything to the right of it is parsed *as is* (up to a new line) and sent directly to bash/cmd.  There's no room any PowerShell syntax like here-strings and what not because then it has all the same problems that  `--%` and the native command processor currently have.",
      "created_at": "2020-07-18T23:09:01Z",
      "updated_at": "2020-07-18T23:12:29Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> I've seen that. How exactly would you combine `Start-NativeExecution` with `Invoke-NativeShell` if you'd like the later to effectively throw on a non-zero exit code? I really hope that something like PR #3523 makes it in along with this call native feature because I want the two to work together. I suppose if call native winds up being implemented as a cmdlet (Invoke-NativeShell vs --%) then `-ErrorAction Stop` could be implemented to have it throw (terminating error) on a non-zero exit code.\r\n\r\nCurrently it will be `Start-NativeExecution { Invoke-NativeShell @whatever }`.",
      "created_at": "2020-07-19T05:49:03Z",
      "updated_at": "2020-07-19T05:49:03Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> This point I don't get at all. It's no more lacking a closing delimiter than ins/invoke-nativecommand is. If you need to delimit or feed from the LHS, use here-strings, else it is considered as a single statement.\r\n\r\n`Invoke-NativeShell` does not _need_ any closing delimiter because it is a regular command, whereas the horror of `--%` is not.",
      "created_at": "2020-07-19T05:54:03Z",
      "updated_at": "2020-07-19T05:54:03Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> > and SHELL on Linux (defaults to `/bin/bash`)\r\n> \r\n> No: **the _system_ shell on Unix-like platforms is _invariably_ `/bin/sh`**.\r\n\r\nI think the thing should be equivalent to making an executable script file and running it, which delegates the task of choosing the right shell to the operating system and we should not be bothered.  Including, if it starts with `#!`, so be it.",
      "created_at": "2020-07-19T06:02:06Z",
      "updated_at": "2020-07-19T06:02:06Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "The idea behind `Invoke-NativeShell` is to provide a convenience wrapper around the native shell's _CLI_.\r\n\r\n* On Unix, that is fully sufficient, and creating an auxiliary script file not only introduces extra overhead, but then reports a random value in `$0` (the script file path), whereas invocation via the CLI it predictably contains `/bin/sh` and can even be set explicitly by following the code-argument with another argument (e.g., `sh -c 'echo $0' foo`)\r\n   * (As an aside: creating a shell script with shebang line `#!/bin/sh` means targeting the system shell by full path just as explicitly as invoking `/bin/sh` directly).\r\n\r\n* On Windows, the execution via a batch file _would_ bring advantages (but not for delegating the task of locating the system shell, which `$env:ComSpec` predictably does), as it would avoid the problems with `%` escaping and `for` behavior mentioned [above](https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-660263405).\r\n\r\nTo address the latter as a courtesy (so that users don't have to write their own aux. batch files), for conceptual clarity, we could offer  an\r\n`-AsBatchFile` switch as an _opt-in_.\r\n\r\nThat said, if there is consensus that the majority of public `cmd` command lines used for cut-and-paste are written with _batch-file_ semantics in mind (`%%i` rather than `%i` as a loop variable, ability to escape a verbatim `%` as `%%`), perhaps invariably using an aux. batch file _on Windows_ (while sticking with the CLI on Unix) is the better solution - I do not feel strongly about this, but it would have to be clearly documented, especially given that it means exhibiting behavior that is different from other scripting languages.\r\n\r\n\r\n",
      "created_at": "2020-07-19T12:34:36Z",
      "updated_at": "2020-07-19T16:14:20Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@rkeithhill\r\n\r\nTo me, the [integration-of-native-errors RFC](https://github.com/PowerShell/PowerShell-RFC/pull/88/files?short_path=e6e13bd#diff-e6e13bdbc99ad974811df49f562f816b) you link to is worth addressing just as urgently as #1995:\r\n\r\nBoth represent necessary steps toward making external programs (native utilities) first-class citizens in PowerShell (as much as conceptually possible), _which they should always have been_.\r\n\r\nBeing a first-class citizen means: _direct_ invocation (with `&` needed  only for _syntactic_ reasons, situationally), not _via a cmdlet_.\r\nIn other words: there should never be an `Invoke-NativeCommand` cmdlet or a `Start-NativeExecution` cmdlet.\r\n\r\n(As an aside: `Start-NativeExecution` is misnamed, as many functions in the `build` module are; `Start` signals _asynchronous_ operation, whereas most of these function are _synchronous_ - see the discussion about `Start-Sleep` at https://github.com/MicrosoftDocs/PowerShell-Docs/issues/4474).\r\n\r\nTherefore, `Invoke-NativeShell` requires no special consideration: PowerShell, as it already does, will set `$LASTEXITCODE` based on the exit code reported by the native-shell executable process (`cmd` / `sh`) invoked.\r\n\r\nThen the mechanism proposed in the RFC will act on it, as it would act on directly invoked executables (e.g., if `$PSNativeCommandErrorAction = 'Stop'` is set, a script-terminating error would occur if `$LASTEXITCODE` is nonzero.)\r\n\r\n(A quick aside - this discussion doesn't belong here: As for a _per-call_ mechanism: something like\r\n`/bin/ls nosuch || $(throw 'ls failed)` works, as does `/bin/ls nosuch || $(exit $LASTEXITCODE)` (the equivalent to a POSIX shell's `/bin/ls nosuch || exit`); #10967 discusses why we unfortunately cannot avoid `$(...)` (without major changes to the grammar); similarly, needing to refer to `$LASTEXITCODE` explicitly probably cannot be avoided.)",
      "created_at": "2020-07-19T13:14:18Z",
      "updated_at": "2020-07-19T13:18:07Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> (As an aside: creating a shell script with shebang line `#!/bin/sh` means targeting the system shell by full path just as explicitly as invoking `/bin/sh` directly).\r\n\r\nThat is not what I wanted to say.  I wanted to say that PowerShell does not need to know what the default shell is because operating systems have this feature built in.  Linux knows how to execute an executable script in case it does not start with `#!` or it starts with something else, like `#!/usr/bin/env python` and Windows knows what to do to call a `.CMD` script, so we should not peek into`%COMSPEC%`\u2019n\u2019stuff either IMHO.  Windows can also execute other scripts but it is based on the script file\u2019s extension, so it obviously does not apply to this case.",
      "created_at": "2020-07-19T18:50:22Z",
      "updated_at": "2020-07-19T18:54:24Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Again, `Invoke-NativeShell`'s mandate should be calling the native shell's _CLI_, not creating auxiliary script files (with side effects) behind the scenes (except for different reasons, as discussed [above](https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-660637060)). \r\n\r\nWith respect to robustly determining the system shell, there is no problem to solve here: hard-coding `/bin/sh` on Unix is perfectly appropriate, as is consulting `$env:ComSpec` on Windows.\r\n\r\nNo, Unix platforms at the system-call level do _not_ know how to execute an executable plain-text file _without a shebang line_; that you still _can_ invoke such files is a convenience feature of POSIX-like shells: they try `exec`, then _fall back_ to interpreting such files as written _for them_; that is, it is whatever POSIX-like shell that is being run that ends up executing the file - whereas PowerShell simply _fails_, because it doesn't implement this courtesy fallback (you'll get `Program 'foo' failed to run: Exec format error`).\r\n\r\nNeedless to say, it is therefore ill-advised to create such scripts.\r\n\r\n",
      "created_at": "2020-07-19T19:03:48Z",
      "updated_at": "2020-07-19T19:12:35Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> No, Unix platforms at the system-call level do _not_ know how to execute an executable plain-text file _without a shebang line_; that you still _can_ invoke such files is a convenience feature of POSIX-like shells: they try `exec`, then _fall back_ to interpreting such files as written _for them_; that is, it is whatever POSIX-like shell that is being run that ends up executing the file - whereas PowerShell simply _fails_, because it doesn't implement this courtesy fallback (you'll get `Program 'foo' failed to run: Exec format error`).\r\n\r\n`csh` is not POSIX-like and it does not fail on `exec` a bare script.  It invokes `sh`.  So does `perl`.",
      "created_at": "2020-07-19T20:20:56Z",
      "updated_at": "2020-07-19T20:20:56Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I hope it is obvious that this makes my point: it's _up to each shell_ to decide what to do, and different shells / scripting languages do different things; PowerShell currently just fails - if it had to make a choice, and you wanted that choice to be `/bin/sh`, we're back at square one: `/bin/sh` must be assumed.\r\n",
      "created_at": "2020-07-19T20:32:21Z",
      "updated_at": "2020-07-19T20:32:21Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> I hope it is obvious that this makes my point: it's _up to each shell_ to decide what to do, and different shells / scripting languages do different things; PowerShell currently just fails - if it had to make a choice, and you wanted that choice to be `/bin/sh`, we're back at square one: `/bin/sh` must be assumed.\r\n\r\n`exec` in `perl` is a direct system call, `perl` does not modify it in any way.  In particular, it does not _choose_ the interpreter.",
      "created_at": "2020-07-19T20:36:05Z",
      "updated_at": "2020-07-19T20:36:05Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> Of course, that assumes that users know the difference between single-quoted (verbatim) and double-quoted (interpolating) strings and about selective `` ` ``-escaping of `$`, but I think it's an important (advanced) option to have.\r\n\r\nMaybe it is just me, but I would trade a thousand `\"`\u2019s for one `-f`.  ",
      "created_at": "2020-07-19T20:55:21Z",
      "updated_at": "2020-07-19T20:56:21Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "@yecril71pl \r\n>exec in perl is a direct system call, perl does not modify it in any way. In particular, it does not choose the interpreter.\r\n\r\nThat can not be true if it works with scripts without `#!` line. The exec syscall on linux does not work without `#!`, as one can easily test:\r\n\r\n```\r\nuser@Programming-PC:/tmp/exec_test$ ls\r\ntest.c  testscript\r\nuser@Programming-PC:/tmp/exec_test$ cat test.c\r\n#include <unistd.h>\r\n#include <stdio.h>\r\n \r\nint main(int argc, char **argv) {\r\n  char *binaryPath = \"./testscript\";\r\n \r\n  execl(binaryPath, binaryPath, NULL);\r\n\r\n  perror(\"Error\");\r\n \r\n  return 0;\r\n}\r\nuser@Programming-PC:/tmp/exec_test$ gcc test.c -o testexecutable\r\nuser@Programming-PC:/tmp/exec_test$ chmod +x testscript \r\nuser@Programming-PC:/tmp/exec_test$ cat testscript \r\necho test from script\r\nuser@Programming-PC:/tmp/exec_test$ #works from shell:\r\nuser@Programming-PC:/tmp/exec_test$ ./testscript \r\ntest from script\r\nuser@Programming-PC:/tmp/exec_test$ #doesn't work via exec syscall:\r\nuser@Programming-PC:/tmp/exec_test$ ./testexecutable \r\nError: Exec format error\r\nuser@Programming-PC:/tmp/exec_test$ vim testscript \r\nuser@Programming-PC:/tmp/exec_test$ cat testscript \r\n#!/bin/sh\r\necho test from script\r\nuser@Programming-PC:/tmp/exec_test$ #exec syscall works with #! line:\r\nuser@Programming-PC:/tmp/exec_test$ ./testexecutable \r\ntest from script\r\nuser@Programming-PC:/tmp/exec_test$ uname -a\r\nLinux Programming-PC 4.4.0-176-generic #206-Ubuntu SMP Fri Feb 28 05:02:04 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux\r\nuser@Programming-PC:/tmp/exec_test$ \r\n```\r\n\r\n---\r\n\r\nEdit: I just noticed, that if you use the *library function* `execlp` then according to the man page:\r\n>If  the  header  of a file isn't recognized (the attempted execve(2) failed with the error ENOEXEC), these functions will execute the shell (/bin/sh) with the path of the file as its first argument.  (If this attempt fails, no further searching is done.)\r\n\r\nHowever this is not a feature of \"linux\" but of the gnu c library - and again according to the man page it uses explicitly /bin/sh and not some userdefinable shell. (Hardcoded in the source of [`posix/execvpe.c`](https://sourceware.org/git/?p=glibc.git;a=blob;f=posix/execvpe.c;hb=HEAD#l59) (`new_argv[0] = (char *) _PATH_BSHELL;`) and [sysdeps/unix/sysv/linux/paths.h](https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/paths.h;hb=HEAD#l41) (or [sysdeps/generic/paths.h](https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/generic/paths.h;hb=HEAD#l41) - I don't know which header is used...) (`#define _PATH_BSHELL    \"/bin/sh\"`))",
      "created_at": "2020-07-19T21:24:04Z",
      "updated_at": "2020-07-19T22:01:34Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> However this is not a feature of \"linux\" but of the gnu c library - and again according to the man page it uses explicitly /bin/sh and not some userdefinable shell. (Hardcoded in the source of [`posix/execvpe.c`](https://sourceware.org/git/?p=glibc.git;a=blob;f=posix/execvpe.c;hb=HEAD#l59) (`new_argv[0] = (char *) _PATH_BSHELL;`) and [sysdeps/unix/sysv/linux/paths.h](https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/paths.h;hb=HEAD#l41) (or [sysdeps/generic/paths.h](https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/generic/paths.h;hb=HEAD#l41) - I don't know which header is used...) (`#define _PATH_BSHELL \"/bin/sh\"`))\r\n\r\nSince it comes from `sysdeps/**/linux`, it is a Linux thing.  It may also be the generic thing but it is overridable \u2014 obviously not locally but per OS.",
      "created_at": "2020-07-19T22:45:00Z",
      "updated_at": "2020-07-19T22:45:00Z"
    },
    {
      "author": "oising",
      "author_association": "CONTRIBUTOR",
      "body": "> > Yes, I understand the _current_ behaviour @vexx32 . But we're not (at least I'm not) talking about the _current_ behaviour of `--%` -- we're talking about enhancing it, no? Why do I get the feeling that we're all talking around each other here? :)\r\n> \r\n> So the current pitch for adjusting `--%` is that if it's where the command name would typically be, everything to the right of it is parsed _as is_ (up to a new line) and sent directly to bash/cmd. There's no room any PowerShell syntax like here-strings and what not because then it has all the same problems that `--%` and the native command processor currently have.\r\n\r\nOh lordy... Is everyone just trying to troll me? \ud83d\ude04  No, Patrick -- if you want to use powershell expressions, then use here-strings with `--%`. If you want multiline, use here-strings. If you want multline without variable substitution, you could use single-quote here-strings. \r\n\r\nAnyway, I don't have any skin in this game and I think I've said enough. I still think there's something seriously wrong about using a cmdlet to defer to another shell from within a shell. It's just clumsy. It's especially clumsy when you're using a cmdlet to execute another shell to execute a native command that has no need for that secondary shell in the first place. The whole thing just smells bad. \r\n\r\nedit: last word\r\n\r\nThe title of this item is \"call native operator.\" I see a wasted opportunity when we already have a call operator `&` and we already have a token that was designed to deal with passing arguments to native commands, `--%`. Right now, using `&` with `--%` is NOT recognized and as such will NOT introduce a breaking change should we decide to enable this scenario and give it specific behavior to fix the problems being discussed here.  \r\n\r\n\r\n",
      "created_at": "2020-07-19T23:47:07Z",
      "updated_at": "2020-07-19T23:51:48Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> if you want to use powershell expressions, then use here-strings with `--%`. If you want multiline, use here-strings.\r\n\r\nThe point of the operator is that it doesn't parse **literally any** PowerShell syntax.  There's no such thing as here-strings.  There's no such thing as single quoted string constants.  It's \"send the text to the right as is\" not \"evaluate the expression to the right, convert to string and send it's value\"\r\n\r\nSo for example, if you had this:\r\n\r\n```powershell\r\n--% @'\r\necho my native command\r\n'@\r\n```\r\n\r\nit would translate to:\r\n\r\n```powershell\r\ncmd.exe /c \"@'\"\r\necho my native command\r\n'@\r\n```\r\n\r\nExcept you'd get a parser error because `'@` would just be that start of a single quoted string constant containing <kbd>@</kbd>.\r\n\r\nI think maybe you're picturing the implementation differently so that it's more or less the same thing as the pitch for `ins`, but the above is the current pitch being discussed for `--%`.\r\n\r\nAlso worth noting that this is how the existing functionality works as well.  This example works mostly the same way:\r\n\r\n```powershell\r\ncmd /c --% @'\r\necho my native command\r\n'@\r\n```\r\n\r\n",
      "created_at": "2020-07-20T00:45:43Z",
      "updated_at": "2020-07-20T00:54:41Z"
    },
    {
      "author": "oising",
      "author_association": "CONTRIBUTOR",
      "body": "I repeat:\r\n\r\n> Right now, using & with --% is NOT recognized/undefined and as such will NOT introduce a breaking change should we decide to enable this scenario and **give it specific behavior to fix the problems being discussed here**.\r\n\r\nLet me spell it out even clearer: Allow here-strings to follow `--%` when used with `&`\r\n",
      "created_at": "2020-07-20T04:50:57Z",
      "updated_at": "2020-07-20T04:50:57Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "Hah that's a big oof - yeah I missed that, sorry @oising.\r\n\r\nAbout that idea I think it would be a little confusing to have `--%` mean stop parsing in some contexts and \"do a better job at native argument binding\" in others (likewise with making it work like `Invoke-NativeShell` if that's what you mean instead).",
      "created_at": "2020-07-20T11:56:46Z",
      "updated_at": "2020-07-20T11:56:46Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for digging deeper re `exec`, @TSlivede. Let me try to summarize and therefore hopefully close this tangent; applies to both Linux and macOS:\r\n\r\n**There is no system (or library) function called `exec`** on Unix, there is only a _family_ of related functions with `exec` in their name (most of them as a prefix).\r\n\r\n* The _system_ functions (`man` section `2`), `execve` at its heart, _fail_ when you try to execute a shebang-less script.\r\n\r\n* Among the _library_ functions  that _build on the system functions_ (`man` section `3` - `man 3 exec`), only those that have `p` (for \"path\", I presume) have the pass-to-the-system-shell fallback (e.g., `execlp`).\r\n  * The GNU library implementations of these functions hard-code `/bin/sh`, as @TSlivede has shown, whereas the BSD-based ones [use just `sh`](https://github.com/freebsd/freebsd/blob/8edea978e32b4a77521d59eccb0fee8cc07075c2/lib/libc/gen/exec.c#L149), and rely on `sh` to be in `$env:PATH` (though, curiously, the `man` page states `/bin/sh`).\r\n\r\nAs stated, for _direct execution_ the major POSIX-like shells (`bash`, `dash`, `ksh`, and `zsh`) fall back to executing shebang-less scripts _themselves_, which implies that they do _not_ use the fallback variants among the `exec` library functions; by contrast, `perl`'s choice for its own `exec` function was to rely on the fallback; similarly, the `exec` _builtins_ of the major POSIX-like shells rely on the fallback, except in `bash`.\r\n\r\nSince on Unix the use of a script file behind the scenes is unnecessary, we can make the same assumptions about the system shell path as the fallback library functions, and **I recommend `/bin/sh` over `sh`**, for security and predictability:\r\n\r\nDespite the [POSIX spec _not_ mandating the location of `sh`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html) (that is, strictly speaking, the BSD library functions are the compliant ones):\r\n\r\n* `/bin/sh` is safe to assume, because it is the _de facto_ standard location, not least because writing portable Unix shell _necessitates_ referring to `sh` by its full path, given that shebang lines support only _full, literal_ paths (`#!/bin/sh`).\r\n\r\n* Conversely, relying on locating `sh` via `$env:PATH` can be a security risk, given that `$env:PATH` could be manipulated to invoke a different `sh`.\r\n\r\nThe same risk applies to locating `cmd.exe` via `$env:ComSpec`, by the way, so perhaps the better way is to call the [`GetSystemDirectory`](https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsystemdirectoryw) WinAPI function and append `\\cmd.exe` to its result (we need a fallback anyway, if `$env:ComSpec` happens not to be defined).\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-07-20T20:07:52Z",
      "updated_at": "2020-08-22T13:21:44Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> `/bin/sh` is safe to assume, because it is the _de facto_ standard location, not least because writing portable Unix shell _necessitates_ referring to `sh` by its full path, given that shebang lines support only _full, literal_ paths (`#!/bin/sh`).\r\n\r\nNormally you say `#!/usr/bin/env sh` (except in system scripts).\r\n",
      "created_at": "2020-07-20T21:45:43Z",
      "updated_at": "2020-07-20T21:47:01Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "* Normally, you _don't_: googling [\"#!/bin/sh\"](https://www.google.com/search?q=%22%23%21%2Fbin%2Fsh%22) yields about 3,900,000 matches, [\"#!/usr/bin/env sh\"](https://www.google.com/search?q=%22%23%21%2Fusr%2Fbin%2Fenv+sh%22) yields about 34,100 matches.\r\n\r\n* Normally, you _shouldn't_: you want to predictably target _the_ system shell, `/bin/sh`, not whatever `sh` utility happens to come first in `$env:PATH`.\r\n\r\nThe only reason to target an executable named `sh` is to portably target the lowest-common-denominator-assume-POSIX-features-only _system_ shell, i.e. `/bin/sh`.",
      "created_at": "2020-07-21T00:20:47Z",
      "updated_at": "2020-07-21T00:20:47Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> Normally, you _don't_: googling [\"#!/bin/sh\"](https://www.google.com/search?q=%22%23%21%2Fbin%2Fsh%22) yields about 3,900,000 matches, [\"#!/usr/bin/env sh\"](https://www.google.com/search?q=%22%23%21%2Fusr%2Fbin%2Fenv+sh%22) yields about 34,100 matches.\r\n\r\nThere is no way to limit a Web search to user scripts, especially since many user scripts are not marked executable at all, and even if they are, they may rely on `execlp`; but even if most user scripts said that, we should not take _customary_ for _normal_.  The scripts to be run by PowerShell are user scripts; when users want a shell, they call `sh`, not `/bin/sh`, unless they are paranoid.",
      "created_at": "2020-07-21T05:44:11Z",
      "updated_at": "2020-07-21T05:46:35Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@oising \r\n\r\n **Passing the native-shell command line _as a single string_ (in whatever string(-literal) form is easiest), and _only_ as a single string** (save for the additional, pass-to-the-command-line arguments supported on Unix (only) discussed [above](https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-653526374)) - assuming you agree with that - **sounds like common ground.**\r\n\r\nPassing the command line as a _single string_ is the prerequisite for:\r\n* being able to incorporate such a call into a _PowerShell_ pipeline.\r\n* being able to incorporate _PowerShell variables and expression_ into the native-shell command line.\r\n\r\nPassing a single string is a _direct conceptual expression_ of what the call will do; by contrast, trying to somehow directly incorporate a different shell's syntax directly in PowerShell's with _individual_ (optionally bare-word) arguments brings unsolvable problems that result in a confusing compromise with fundamental limitations, which the existing `--%` already embodies.\r\n\r\n---\r\n\r\nWhile you could argue that it then isn't all that important whether we choose an _operator_ or a _cmdlet_ to pass that single-string command line to (save for questions of _discoverability_), I have conceptual concerns about use of both `&` and `--%` (preceded by `&`):\r\n\r\n* The concern re `&`: if we need to pass a - quoted - string containing the command line, we're effectively operating in _expression_ mode, whereas the `&` currently implies _argument_ mode (which means: _individual_ arguments, quoting only when necessary). Therefore, the involvement of `&` is confusing.\r\n\r\n* The concern re `--%` is about the Windows-only origin and muddled semantics of `--%` as the stop-parsing symbol; it would be especially confusing if `--%` as the stop-parsing symbol operated in _argument_ mode (e.g. \r\n`& /bin/ls --% dir1 dir2`), whereas `& --%` operated in _expression_ mode (e.g. `& --% '/bin/ls dir1 dir2 >out.txt'`)\r\n\r\n----\r\n\r\nLet me take a step back and examine `--%`, the stop-parsing symbol, as currently implemented:\r\n\r\nIt was an attempt to solve two ultimately unrelated problems (Windows-only at the time):\r\n\r\n* (a) A use case that also applies to other platforms: Let me reuse _command lines_ written for `cmd.exe` / the native shell as-is, so I don't have to adapt them to PowerShell's syntax.\r\n\r\n* (b) An always Windows-only problem: Let me call a _rogue CLI_ (that is, a call to a _single_ external console application) that requires a very specific style of quoting that PowerShell's generic behind-the-scenes re-quoting cannot provide, by allowing me to craft the command line ultimately passed to the WinAPI for such CLIs _verbatim_. (To limit the problem statement to this assumes that PowerShell's re-quoting generally works properly, which it never has - that is the subject of #1995).\r\n\r\n`--%` was implemented as a muddled _conflation_ of solution attempts to both (a) and (b), and ended up solving neither problem properly:\r\n\r\n* It was advertised as the solution to (a), but in reality has severe limitations, because _the only `cmd` exe feature that it emulates is the expansion of `%...%`-style environment-variable references_:\r\n\r\n    * It only ever supports a _single_ `cmd` command, given that an `|` (and \r\n`&&` and `||`, even though they weren't implemented at the time) implicitly terminate the pass-to-`cmd` portion.\r\n\r\n   * A _single_ `&` -  which is `cmd`s multi-command separator -  _is_ passed through, but that too did _not_ result in multi-command support, because - since `cmd` isn't actually involved - the `&` is passed _verbatim to the target program_; e.g.\r\n`echoArgs.exe --% a & b` doesn't echo `a` then invokes `b`, it passes verbatim arguments `a`, `&`, and `b` to `echoArgs`.\r\n\r\n   * `cmd`'s escape character (`^`) in unquoted arguments isn't honored.\r\n\r\n   * As a corollary, `%...%` tokens that refer to existing environment variables are _invariably_ expanded; an attempt to prevent that via `^` doesn't work properly (e.g.\r\n`echoArgs.exe Don't expand %^USERNAME%`, which in `cmd` prevents expansion _and strips the `^`_, retains the `^` when called from PowerShell as `echoArgs.exe --% Don't expand %^USERNAME%`\r\n\r\n* As a solution to (b), it fell short as well:\r\n\r\n  * Just like in the (a) use, there's no ability to incorporate _PowerShell_ variables and expressions into the command - except if you awkwardly first define an _aux. environment_ variable_ that you then reference via `%...%` after `--%`; e.g.\r\n`$env:FOO='foo'; echoArgs.exe --% %FOO%!`\r\n\r\n---\r\n\r\nThe proper solution to (a) would have been `Invoke-NativeShell` / `ins`, as discussed here.\r\n\r\nThe proper solution to (b) would have been to:\r\n  * support `--%` as special only as the _first_ argument\r\n  * and, just like with `ins`, require it to be followed _by a single string_ that constitutes the pass-through command line _as a whole_, again with the ability to incorporate _PowerShell_ variables and expressions by way of string interpolation (or other ways of constructing the string)\r\n  * e.g. `` msiexec --% \"/i installer.msi INSTALLLOCATION=`\"$loc`\"\" ``, with `$loc` containing `'c:\\foo\\bar none'`, would result in verbatim command line `/i installer.msi INSTALLLOCATION=\"c:\\foo\\bar none\"` getting passed through, satisfying `msiexec`'s nonstandard requirement that in `<prop>=<value>` arguments only the `<value>` part be double-quoted.\r\n\r\nWhile that isn't _convenient_, it is the price to pay for a robust solution to the anarchy that is command-line-based argument passing on Windows.\r\n\r\n\r\n\r\n",
      "created_at": "2020-07-21T17:02:52Z",
      "updated_at": "2020-07-21T17:38:44Z"
    },
    {
      "author": "oising",
      "author_association": "CONTRIBUTOR",
      "body": "@mklement0 Thank you for the patient and thoughtful reply (as usual.)\r\n\r\nSo, I wholeheartedly agree with;\r\n\r\n> The proper solution to (b) would have been to:\r\n> - support --% as special only as the first argument\r\n> - and, just like with ins, require it to be followed by a single string that constitutes the pass-through command line as a whole, > - again with the ability to incorporate PowerShell variables and expressions by way of string interpolation (or other ways of constructing the string)\r\n>  - e.g. msiexec --% \"/i installer.msi INSTALLLOCATION=`\"$loc`\"\", with $loc containing 'c:\\foo\\bar none', would result in verbatim command line /i installer.msi INSTALLLOCATION=\"c:\\foo\\bar none\" getting passed through, satisfying msiexec's nonstandard requirement that in <prop>=<value> arguments only the <value> part be double-quoted.\r\n\r\nThis is what I've been trying to expound as a generalized solution to both (a) and (b), except I still don't really get that (a) should exist as an independent problem to solve? What I'm really struggling with is if (b) is implemented _specifically_ for `&`, why can't that cover (a) also? e.g. What does `ins ...` give that `& cmd --% ...` cannot? And it won't be a breaking change other than not allowing `&` to pass `--%` as an argument (which seems ridiculously unlikely.) Bonus that you don't have to worry about comspec, shells or whatever. Let the caller decide. ",
      "created_at": "2020-07-22T03:47:58Z",
      "updated_at": "2020-07-22T03:49:03Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee reviewed this:\r\n\r\n- This will be an **experimental feature** to get real usage feedback; we are still open to the actual sigil; we defer `/bin/sh` vs `/bin/env sh` to the PR review\r\n- We will move forward with `--%` as a new operator specifically for the \"stackoverflow\" scenario where the user cuts and pastes a command-line into PowerShell and it should just work (with, of course, the new operator preceding it)\r\n- A `Invoke-NativeShell` cmdlet is separate from this proposal and could be published by the community in PowerShellGallery; also, requiring a here-string doesn't solve the user experience problem without knowing ahead of time to wrap it as a here-string\r\n- We do not want to make a breaking change to `--%` switch where existing users may depend on that behavior\r\n- Users who need streaming behavior like `--%` switch should continue to use that switch and escape special characters as necessary\r\n- There is still a discovery problem for users to know about `--%` (or any solution)\r\n- We are not currently entertaining a change to PSReadLine to modify pasted content as a here-string trying to predict user intent\r\n- We are not looking at multiple solutions that allow for here-string vs non-here-string (expansion) scenarios; e.g. `& --%` vs `--%`\r\n",
      "created_at": "2020-07-22T22:39:26Z",
      "updated_at": "2020-07-22T22:39:26Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "I also want to add that, despite @SteveL-MSFT and I closing #1995 at the same time as opening this one, it really wasn't our intent to communicate this as a definitive solution to that problem. \r\n\r\nIt's my view that the benefits of this particular feature are much more significant than the impact #1995. I think there are a LOT of StackOverflow examples and docs examples for non-PS enlightened tools that folks would like to cut/paste (myself included). \r\n\r\nThere's additionally a desire to provide proper escaping within PowerShell's own language, but I'm not seeing people hit #1995 in the wild en masse (but I'll elaborate more on this over there).",
      "created_at": "2020-07-22T22:43:39Z",
      "updated_at": "2020-07-22T22:43:39Z"
    },
    {
      "author": "essentialexch",
      "author_association": "NONE",
      "body": "> * We will move forward with `--%` as a new operator\r\n\r\nSorry to drag this out, and I'm not looking for additional discussion, but what kind of operator? (I'm primarily interested in syntax.)\r\n\r\n`$a = --% find . -iname *$pdf -print0 | xargs -0 ls -ltr`\r\n\r\nWho gets the pipe? What happens to the `$`? Similar with `&`, `&&`, and `||`.\r\n\r\nUnder what conditions, if any, will `--%` be usable in a PS pipe moving forward?\r\n\r\nThanks.",
      "created_at": "2020-07-22T23:05:18Z",
      "updated_at": "2020-07-22T23:05:18Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> Sorry to drag this out, and I'm not looking for additional discussion, but what kind of operator? (I'm primarily interested in syntax.)\r\n\r\nAST wise it probably won't technically be an operator but it's own AST type.  If it does get implemented as an operator, it'd be a unary operator.\r\n\r\n> `$a = --% find . -iname *$pdf -print0 | xargs -0 ls -ltr`\r\n> \r\n> Who gets the pipe? What happens to the `$`? Similar with `&`, `&&`, and `||`.\r\n\r\nThe string `find . -iname *$pdf -print0 | xargs -0 ls -ltr` would be sent as is to the native shell.  `$a` would still be populated though, so you could in the next line pipe that to something.\r\n\r\n> Under what conditions, if any, will `--%` be usable in a PS pipe moving forward?\r\n\r\nIf ~in the first command element slot~ it's at the start of a statement, probably not.  That's one of the draws of the new syntax.  If not ~in the first slot~ at the start, it'll continue to work like it does today.\r\n\r\n(@daxian-dbw @SteveL-MSFT if any of that is wrong please correct \u2764\ufe0f)",
      "created_at": "2020-07-22T23:12:53Z",
      "updated_at": "2020-07-23T00:31:04Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@SeeminglyScience is exactly right",
      "created_at": "2020-07-22T23:47:22Z",
      "updated_at": "2020-07-22T23:47:22Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> If in the first command element slot, probably not. That's one of the draws of the new syntax. If not in the first slot, it'll continue to work like it does today.\r\n\r\nIt may be tricky to pass the output of upstream command to the native command that will be invoked by `--%`. `--%` basically just hands the string as it to a native shell, like `bash`, but the output from upstream command cannot just be fed to `bash`, but should be fed to the native command itself, such as `find`.\r\n\r\nI think streaming behavior is not a consideration to this feature as it's mainly for the \"StackOverflow\" scenario. So I think we'd better just make `--%` a special statement ast, so that it's clear it won't work with _PowerShell_ pipelines.",
      "created_at": "2020-07-23T00:21:32Z",
      "updated_at": "2020-07-23T00:21:56Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "Ahh I knew there was a reason that \"command element slot\" was wrong.  I meant at the start of a statement.  I'll fix it, thanks!",
      "created_at": "2020-07-23T00:28:36Z",
      "updated_at": "2020-07-23T00:28:36Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> the output from upstream command cannot just be fed to `bash`\r\n\r\nDoes _upstream_ mean _us_?  I think can do: `'ls' | bash`.  Not a peculiarly smart thing to do but possible.",
      "created_at": "2020-07-23T05:48:03Z",
      "updated_at": "2020-07-23T05:48:03Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "Was discussing with @jpsnover about this and he proposed the shebang `#!` as the sigil.  In this case, you would just type:\r\n\r\n```powershell\r\n#!/bin/sh ls | grep foo\r\n#!sh | grep foo\r\n```\r\n\r\n(where the second case assumes `sh` is in the path).  In this case, we would have to decide if specifying the shell is required or if we always run that under the default shell, so in this example, `sh` is started twice.  However, there is a problem with this due to how shebang files work today.  They work in PowerShell because the shebang is ignored as a comment.  If we decide to ignore the first line in a script if it's a comment, then we still have a problem in the interactive shell where each new set of lines is a new script and there's no way today to determine if that script is run as a script or interactively.\r\n\r\nAn alternative might be to borrow markdown syntax:\r\n\r\n````powershell\r\n  ```bash\r\n  ls |\r\n  grep foo\r\n  ```\r\n````\r\n\r\nIn this example, we would use markdown code fencing syntax.  This would also solve the multi-line problem and would use a concept that isn't entirely new.  Given that we still have initial discovery problem for new users, I don't think this is that much worse in that you need to have the trailing triple-backticks.\r\n\r\nIn this case, this could potentially work:\r\n\r\n````powershell\r\n  $a = ```bash\r\n    ls |\r\n     grep foo\r\n   ``` | select-string bar\r\n````\r\n",
      "created_at": "2020-07-24T23:50:56Z",
      "updated_at": "2020-07-24T23:50:56Z"
    },
    {
      "author": "romero126",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT Markdown Syntax makes a lot of sense. If we are able to specify. other types as well such as python or perhaps by extension?\n\nThe shebang #! Would interfere with existing comments.",
      "created_at": "2020-07-25T00:23:20Z",
      "updated_at": "2020-07-25T00:23:20Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "That seems massively overcomplicated to me, both to handle in parsing and for users to actually _use_.\r\n\r\nAnd yeah, we don't need to confuse folks with lines that _should_ be comments not turning out as comments. `#Requires` is already edging on kind of weird, a full on shebang is going to confuse Windows folks at best, and probably Linux folks too.",
      "created_at": "2020-07-25T00:40:38Z",
      "updated_at": "2020-07-25T00:41:41Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "I personally would prefer to not mixing this feature with shebang, it's confusing in my opinion.\r\nAlso, if we start to use the markdown code-block syntax, then it's just a matter of time for people to request running arbitrary language code directly in PowerShell. I don't think we want to go that way ...",
      "created_at": "2020-07-25T00:46:10Z",
      "updated_at": "2020-07-25T00:47:34Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> Also, if we start to use the markdown code-block syntax, then it's just a matter of time for people to request running arbitrary language code directly in PowerShell.\r\n\r\nI would literally never stop asking for inline C# even though I know it's a bad idea.",
      "created_at": "2020-07-25T00:48:14Z",
      "updated_at": "2020-07-25T00:48:14Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "The markdown syntax does not introduce arbitrary language code because the embedded script will run in a child process.  You can place arbitrary language code inside `@'` now and nothing bad happens.",
      "created_at": "2020-07-25T07:41:17Z",
      "updated_at": "2020-07-25T07:41:17Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "In the team discussion and also with Jeffrey, we should not be against people wanting to run other languages within a PowerShell script.  As @yecril71pl noted, we are not directly supporting other languages but relying on a different process to interpret and execute that code.  The scenario here is that a user sees a block of python or bash script and just wants to use it as-is within their PowerShell script.  There's nothing requiring people to do this.  They can decide to port that other script to PowerShell if they prefer.  This just provides an option for users to be able to cut and paste into PowerShell to get stuff done.\r\n\r\nWe don't need to mix the single-line vs multi-line proposals in that we could support both although the downside is now we have two ways of doing very similar things but with different syntax.",
      "created_at": "2020-07-25T14:42:32Z",
      "updated_at": "2020-07-25T14:42:32Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "I would prefer to drop the single-line stuff.  Alien code islands should be prominent, otherwise nobody will understand what is going on.",
      "created_at": "2020-07-25T14:50:12Z",
      "updated_at": "2020-07-25T14:50:12Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@yecril71pl I'm leaning towards that myself primarily because from a discovery standpoint, the markdown syntax I think would be more easily recognizable, but that might just be because I write markdown often.  I also expect that lots of examples scripts are probably multi-line rather than just a single line as they expect some state to be retained where each single line would be an independent process.",
      "created_at": "2020-07-25T14:55:49Z",
      "updated_at": "2020-07-25T14:56:40Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> In the team discussion and also with Jeffrey, we should not be against people wanting to run other languages within a PowerShell script.\r\n\r\nAbsolutely 100%, but that doesn't mean it needs to be built directly into the language.  \r\n\r\n> As @yecril71pl noted, we are not directly supporting other languages but relying on a different process to interpret and execute that code. The scenario here is that a user sees a block of python or bash script and just wants to use it as-is within their PowerShell script.\r\n\r\nThat can already be done with here-strings right?  Can you elaborate a little bit on what benefits this provides over existing methods?\r\n\r\nAlso why stop at python and bash?  Why not C#, CIL, C++?\r\n\r\n> There's nothing requiring people to do this. They can decide to port that other script to PowerShell if they prefer. This just provides an option for users to be able to cut and paste into PowerShell to get stuff done.\r\n\r\nI'm not against this because I think I'm going to be forced to use it.  I don't like it because it's going to be difficult to maintain from a language perspective, a nightmare for editors, and ultimately encourage scripts that are unreadable unless you know several languages.\r\n\r\n---\r\n\r\nReally though this is a pretty different concept from the original topic of this thread with much wider implications.  I'd recommend creating a new issue for it.",
      "created_at": "2020-07-25T15:55:55Z",
      "updated_at": "2020-07-25T15:56:45Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> That can already be done with here-strings right? Can you elaborate a little bit on what benefits this provides over existing methods?\r\n\r\nA universal code editor will be able to detect them and decorate them appropriately, whereas there is nothing to be done with `@'` because the editor has no idea what is inside.\r\n\r\n> Also why stop at python and bash? Why not C#, CIL, C++?\r\n\r\nBecause they are not scripting languages?",
      "created_at": "2020-07-25T16:16:37Z",
      "updated_at": "2020-07-25T16:16:37Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> A universal code editor will be able to detect them and decorate them appropriately, whereas there is nothing to be done with `@'` because the editor has no idea what is inside.\r\n\r\nAn editor can tell that ` bash -c @'` contains bash just as easily as a code fence.  Also the challenging part isn't determining what language a section of code is, it's juggling language servers and syntax highlighters.  The only way it would work without significant time and effort investment would be to essentially render it like it was a here-string.\r\n\r\n> Because they are not scripting languages?\r\n\r\nC# and C++ both have script oriented subsets.  Even if they didn't, \"scripting language\" is subjective with no real definition.  It isn't helpful as a definitive boundary for what would and would not be considered for inclusion.",
      "created_at": "2020-07-25T16:27:23Z",
      "updated_at": "2020-07-25T16:27:23Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> C# and C++ both have script oriented subsets. Even if they didn't, \"scripting language\" is subjective with no real definition.\r\n\r\nA language is a (stand-alone) scripting language when you normally call `interpet options\u2026 script arguments\u2026` and that call leaves nothing except what it was intended to leave, excluding temporary stuff and private to the interpreter.  It also means that it normally requires a copy of the interpreter to run.  There are embedded scripting languages that you cannot run this way.",
      "created_at": "2020-07-25T16:33:09Z",
      "updated_at": "2020-07-25T16:35:31Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@SeeminglyScience \r\n\r\n> That can already be done with here-strings right? Can you elaborate a little bit on what benefits this provides over existing methods?\r\n\r\nPeople can use here-strings today or they can escape all the arguments passed to native commands if they can figure out how to get it right.  The intent here is to make it simpler for new users for cut-and-paste (Stackoverflow) scenarios.  \r\n\r\n> Also why stop at python and bash? Why not C#, CIL, C++?\r\n\r\nThe scenarios being supported here is a block of text passed to a native command.  Any language can be supported if it supports that calling convention.  There is no proposal to create a temp source file and have it be compiled.\r\n\r\n> I'm not against this because I think I'm going to be forced to use it. I don't like it because it's going to be difficult to maintain from a language perspective, a nightmare for editors, and ultimately encourage scripts that are unreadable unless you know several languages.\r\n\r\nThere is no expectation that you get mixed language syntax coloring.  Any nested script from another language will just be monotoned.\r\n\r\n> Really though this is a pretty different concept from the original topic of this thread with much wider implications. I'd recommend creating a new issue for it.\r\n\r\nThe proposed implementation is different from the original issue, but the problem is the same which is the cut-and-paste and \"just work\" scenario.\r\n",
      "created_at": "2020-07-25T16:56:30Z",
      "updated_at": "2020-07-25T16:56:30Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> People can use here-strings today or they can escape all the arguments passed to native commands if they can figure out how to get it right. The intent here is to make it simpler for new users for cut-and-paste (Stackoverflow) scenarios.\r\n\r\nRight but how is it actually easier? I get that it's subjective but these don't seem that different to me:\r\n\r\n~~~powershell\r\n$a = ```bash\r\n    find . -iname *$pdf -print0 | xargs -0 ls -ltr\r\n```\r\n~~~\r\n\r\nvs\r\n\r\n```powershell\r\n$a = bash -c @'\r\n   find . -iname *$pdf -print0 | xargs -0 ls -ltr\r\n'@\r\n```\r\n\r\nThey seem *almost* the same with the exception that the latter is significantly more clear in what is going to happen.\r\n\r\n> The scenarios being supported here is a block of text passed to a native command. Any language can be supported if it supports that calling convention. There is no proposal to create a temp source file and have it be compiled.\r\n\r\nWell C# wouldn't need a temp source file.  Maybe not CIL either (no idea about C++).  Either way though a code fence strictly being syntactic sugar for calling an executable (e.g. bash/python/cmd) is confusing to me.  Code fences imply *language* support imo.\r\n\r\n> There is no expectation that you get mixed language syntax coloring. Any nested script from another language will just be monotoned.\r\n\r\nIt'll still be a nightmare for tmLanguage based parsers.  They can barely handle syntax they expect atm.  More than that though, if that's the case I don't get why it's different from a here-string.  \r\n\r\n> The proposed implementation is different from the original issue, but the problem is the same which is the cut-and-paste and \"just work\" scenario.\r\n\r\nFair but we're already 145 comments into discussing the previously proposed solutions.  Especially since this thread already came to a conclusion, you'll likely see a lot more involvement in a new, dedicated thread.",
      "created_at": "2020-07-25T18:22:54Z",
      "updated_at": "2020-07-25T18:22:54Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> Well C# wouldn't need a temp source file. Maybe not CIL either (no idea about C++). Either way though a code fence strictly being syntactic sugar for calling an executable (e.g. bash/python/cmd) is confusing to me. Code fences imply language support imo.\r\n\r\nI just want to echo @SeeminglyScience's comment on this. We can [run C# script](https://github.com/dotnet/roslyn/wiki/Scripting-API-Samples) without involving compilation with the library [`Microsoft.CodeAnalysis.CSharp.Scripting`](https://www.nuget.org/packages/Microsoft.CodeAnalysis.CSharp.Scripting/). That's what dotnet-interactive uses in the C# Jupyter kernel. So it might not be unreasonable for users to ask for C# scripting or even F# scripting support with such a syntax.\r\n\r\nYou can say that the code fencing syntax in PowerShell is for calling a native command, which theoretically allows this:\r\n```\r\n    ```c:\\mypath\\MyArbitraryExe\r\n        args to my arbitrary executable\r\n    ```\r\n```\r\nbut then it's different from users' established understanding of it from markdown, which, as @SeeminglyScience called out, implies language support. Using a similar syntax with different semantics is confusing in my opinion.",
      "created_at": "2020-07-25T19:00:13Z",
      "updated_at": "2020-07-25T19:00:13Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> which theoretically allows this\r\n\r\nYou put the script inside, not the arguments, and the script is equivalent to the input stream.  Also, if this is meant to provide SO support, full paths should not be allowed.",
      "created_at": "2020-07-25T19:06:34Z",
      "updated_at": "2020-07-25T19:08:36Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> You put the script inside, not the arguments, and the script is equivalent to the input stream\r\n\r\nThe script is the argument for bash/cmd/python.\r\n\r\n> Also, if this is meant to provide SO support, full paths should not be allowed.\r\n\r\nThen switch it for this example:\r\n\r\n~~~powershell\r\n$a = ```ipconfig\r\n/all\r\n```\r\n~~~\r\n\r\nOr add the arbitrary exe to path first.",
      "created_at": "2020-07-25T19:11:46Z",
      "updated_at": "2020-07-25T19:11:46Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> > You put the script inside, not the arguments, and the script is equivalent to the input stream\r\n> \r\n> The script is the argument for bash/cmd/python.\r\n\r\nNone of them allows to pass a script as a positional argument.  `CMD` does not even allow a batch file.\r\n\r\n> \r\n> > Also, if this is meant to provide SO support, full paths should not be allowed.\r\n> \r\n> Then switch it for this example:\r\n> \r\n> $a = ```ipconfig\r\n> /all\r\n\r\nThat would not work.",
      "created_at": "2020-07-25T19:17:18Z",
      "updated_at": "2020-07-25T19:17:18Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Seems like we'd be making an awful lot of special cases on very arbitrary basis for this markdown idea to work.\r\n\r\nAlso, the main reason this is even supported in Markdown is for syntax highlighting. That's going to be a constant request if we add something like this into the language. \r\n\r\nThis is not an effective solution.",
      "created_at": "2020-07-25T19:22:05Z",
      "updated_at": "2020-07-25T19:22:05Z"
    },
    {
      "author": "essentialexch",
      "author_association": "NONE",
      "body": "> Was discussing with @jpsnover about this and he proposed the shebang `#!` as the sigil\r\n\r\njust to add my 2 cents, i think it's a mistake to restart this discussion after a solution had been announced. and personally i dislike both the shebang and markdown syntax (and both are breaking changes).",
      "created_at": "2020-07-25T22:18:58Z",
      "updated_at": "2020-07-25T22:18:58Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "I don't mind restarting discussions **if** someone has come up with something demonstrably better.  Indeed better to do that **now** than after the feature has shipped. I just don't think `#!` or the markdown approach is a better solution to supplying an \"un-PowerShell-adulterated\" command line string to a native exe.  Maybe I just need to try it to get used to it but my initial reaction is ... um, eew.",
      "created_at": "2020-07-26T00:26:26Z",
      "updated_at": "2020-07-26T00:26:26Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "_If we (and PowerShell) know that we run a native executable why do we need \"call native operator\" at all?_\r\n\r\nIf PowerShell parse an input string and get CommandAst then PowerShell does a discover of the command.\r\nIf the command is a native command PowerShell converts the ast to NativeCommandProcessor.\r\nWe can implement new (experimental NativeCommandProcessor) for the case which will re-parse the Ast extent (that is the input string) so that to get the native executable name/path and rest of the string as argument or arguments by OS rules.\r\n\r\nIf an user want copy-paste from shell he should type \"cmd <Ctrl-V>\" or \"bash <Ctrl-V>\" - that will works without editing.\r\nIf an user want copy-paste an native command line <Ctrl-V> will works too like `g++ timer.cpp @conanbuildinfo.args -o timer --std=c++11`.",
      "created_at": "2020-07-27T17:15:45Z",
      "updated_at": "2020-07-27T17:15:45Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> If an user want copy-paste from shell\r\n\r\nWe have `Get-/Set-Clipboard` for that.",
      "created_at": "2020-07-27T17:52:37Z",
      "updated_at": "2020-07-27T17:52:37Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> for the case which will re-parse the Ast extent (that is the input string) so that to get the native executable name/path and rest of the string as argument or arguments by OS rules.\r\n\r\nMy thinking here is that doing this you either:\r\n\r\n- Inefficiently parse the command AST, only to reparse the extent later as a string and throw the original AST away, OR\r\n- You take the AST and try to reform it back into a string (the way the current NativeCommandProcessor does), but in doing so things will be lost\r\n\r\nSo instead we need to preserve the string from the start. Now, I think arguably PowerShell already has three kinds of string token, but the main request in this discussion seems to be not wanting to escape things. Any string needs to be able to escape its terminator, but the solution discussed there seems to be using newline as the terminator and not being able to escape newlines (there's always semicolons).\r\n\r\nI'm not totally wedded to a newline-only terminator, but it does seem to be the only solution to not wanting to escape anything. Basically that would make a \"native call operator\" tokenise similarly to how a line comment is today &mdash; from the operator to the end of the line is the string passed to the \"native shell\".\r\n\r\nSo:\r\n\r\n```powershell\r\n--% ps -o pid,args -C bash | awk '/running_script/ { print $1 }'\r\n```\r\n\r\nwill tokenise as:\r\n\r\n```\r\n--% ps -o pid,args -C bash | awk '/running_script/ { print $1 }'\r\n|-||-----------------------------------------------------------|\r\n |                                  \\\r\nNative call operator        Invocation to be passed to native shell\r\n```\r\n\r\n(Note that we send even the space directly after `--%` to the native shell, since the string begins immediately after `--%`)\r\n\r\nThen this token is wrapped in a very simple AST, like:\r\n\r\n```csharp\r\n// We need to carefully work out what AST this inherits from\r\n// This syntax has almost no interoperability with PowerShell by design,\r\n// so can't implement fields like redirections or backgrounding faithfully.\r\n// But in order to participate in pipelines and similar, would need to extend a more concrete class\r\npublic class NativeCallInvocationAst : StatementAst\r\n{\r\n    public string NativeInvocation { get; }\r\n}\r\n```\r\n\r\nThen, after this is compiled and sent to the pipe, this uses a new native command processor to send the string directly as an argument to the native shell.\r\n\r\nWhile that all seems implementable, some questions in my mind are:\r\n\r\n- Is the native shell configurable? If not, how do we justify that? If so, should it be explicit as part of the syntax (complicating the syntax), or implemented as a preference variable (making it harder to discover and manage)?\r\n- Is such an implementation going to be discoverable and not confuse people? Will users understand how little PowerShell is doing here, or what's happening when they use `|` or `&` or even strings?\r\n- How many scenarios are going to be serviced by a single-line verbatim string here? Are we going to implement this just to find out that many people want multi-line invocations? Is the need to avoid doing something like escaping a single quote great enough to add these constraints?\r\n- This seems like a very specific scenario for a whole new language syntax. If we're creating a new verbatim string syntax, why are we coupling it directly to the concept of native invocation? If we're creating a new invocation mechanism, why are we coupling it directly to the concept of other shells? Good syntax and good language constructs compose, both syntactically and functionally, and try not to bake too much into the language itself (instead providing a platform of elements for the user to assemble as their program) &mdash; does our proposed native call syntax meet the bar for a new elementary syntax to be composed into programs? Is there a better alternative approach we could take that solves this problem in a simple way, but still allows us to keep the building blocks uncoupled so they can be composed to solve other problems?\r\n- Would other shells or other languages implement this or have they already? At a syntax level, or at any other level? If so, how?\r\n",
      "created_at": "2020-07-27T18:22:17Z",
      "updated_at": "2020-07-27T23:25:28Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> My thinking here is that doing this you either\r\n\r\n@rjmholt CommandAst has Extent property with input string. Re-parsing is as simple as split by first space on Windows or split by spaces on Unix. So I expect we lost nothing in the string and get good performance.",
      "created_at": "2020-07-27T18:49:58Z",
      "updated_at": "2020-07-27T18:49:58Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "However this gets implemented, I think we need a set of use cases to test against. Let me \"propose\" the following:\r\n\r\n* **Use case 1: I want a single exe literal (no interpolation) invocation to work without knowing about quoting/escaping rules** e.g.: ` g++ timer.cpp @conanbuildinfo.args -o timer --std=c++11`.   The current work-around for this is to figure out what to quote e..g: `g++ timer.cpp '@conanbuildinfo.args' -o timer --std=c++11`  A more complicated example might include command lines spanning multiple lines e.g.:\r\n```bash\r\ntar -cvpzf /share/Recovery/Snapshots/$(hostname)_$(date +%Y%m%d).tar.gz \\\r\n    --exclude=/proc \\\r\n    --exclude=/lost+found \r\n```\r\nCurrent workaround (swap backtick for `\\`) e.g.:\r\n```bash\r\ntar -cvpzf /share/Recovery/Snapshots/$(hostname)_$(date +%Y%m%d).tar.gz `\r\n    --exclude=/proc `\r\n    --exclude=/lost+found\r\n```\r\n* **Use case 1a: I want a single exe invocation with PS interpolation to work** e.g.: ` g++ $CppFile @conanbuildinfo.args -o timer --std=c++11`.   The current work-around for this is to figure out what to quote (single or double) and what to escape e..g: `g++ $CppFile '@conanbuildinfo.args' -o timer --std=c++11`  A more complicated example might include command lines spanning multiple lines e.g.:\r\n```bash\r\ntar -cvpzf \"/share/Recovery/Snapshots/${ComputerName}_`$(date +%Y%m%d).tar.gz\" \\\r\n    --exclude=/proc \\\r\n    --exclude=/lost+found \r\n```\r\nCurrent workaround, double-quote first arg, swap backtick for `\\` and escape the `$` at the start of `$(date + ...).\r\n\r\n* **Use case 2: I want to execute a literal *pipelined command* in another shell** e.g.: `ps -o pid,args -C bash | awk '/running_script/ { print $1 }'` and `wsl ls $foo && echo $PWD`.  _I'm not sure if this needs to be a separate use case from the previous one._   The current work-around is to quote the bash command e.g.: `bash -c 'ps -o pid,args -C bash | awk ''/-bash/ { print $1 }'''`.  This use case might include multiline strings as well e.g.:\r\n```bash\r\nps -o pid,args -C bash | \\\r\nawk '/running_script/ { print $1 }'\r\n```\r\n\r\n* **Use case 2a: I want to execute a *pipelined command* in another shell with some PS interpolation** - is this a use case?\r\n\r\n* **Use case 3: I need `npm run $scriptName` to continue to work i.e. interpolate variables**. (this may be implicit and not need to be stated).\r\n\r\nThere's a question of whether there should be use cases for `interpolating` strings i.e. `g++ $CppFile @conanbuildinfo.args -o timer --std=c++11` or do we just punt on that and say that the current escaping rules cover this?  \r\n\r\n**These are likely not the right (or all) use cases but I think it would be helpful to have documented use cases and be able to refer to them when discussing this feature otherwise it's easy to get lost in how the feature actually addresses (or not) customer use cases.**\r\n\r\nAlso, the second use case seems to me to require \"shell invocation\".  I'm not sure the first one does though.  Seems like the exe could be invoked directly.",
      "created_at": "2020-07-27T18:50:30Z",
      "updated_at": "2020-07-27T22:57:02Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@rkeithhill Could you add existing workarounds for completeness in your previous post?\r\n",
      "created_at": "2020-07-27T18:59:00Z",
      "updated_at": "2020-07-27T18:59:00Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@oising, I too appreciate your thoughtful response.\r\n\r\n> What does `ins ...` give that `& cmd --% ...` cannot?\r\n\r\n`--%` in its current, _parameter_ (symbol) form - whose behavior I presume we want to retain - cannot be used for `cmd /c --%`, because it doesn't support _multi-command_ `cmd` command lines (nor `^` as the escape char.), given that the first unquoted `|` will be interpreted as _PowerShell's_ pipe operator and that `&` is passed verbatim.\r\nThe same would apply on Unix, where `--%` is generally near-useless, and with `sh -c` fails altogether, because `sh` expects the command line as a _single_ argument (e.g., `sh -c --% echo hi` yields an empty line, because `echo` alone is executed as the command).\r\n\r\n`ins`, with its requirement to delimit the pass-through command line by passing it _as a single string_ solves these problems, and, as stated, also allows the use of string interpolation to incorporate _PowerShell_ variable and expression values.\r\n\r\nAnd the latter brings us to **why the proposed `--%` _statement_ is a _dead-end street_**:\r\n\r\n* There is _no transition path_ from executing a preexisting command line _exactly as is_ to incorporating _PowerShell_ variable and expression values into it.\r\n\r\n  * The only - obscure and cumbersome - way to achieve this is to define _auxiliary environment variables_ that store the PowerShell values of interest and that you can then reference (shell-appropriately with `%...%` or `$...`) in the native command line.\r\n\r\n* You have the awkwardness of not being able to incorporate a `--%` statement into a larger PowerShell pipeline.\r\n\r\n  * Note that there are legitimate _non_-cut-and-paste reasons to call the native shell, where you may expect this integration; specifically, passing _raw byte data_ through (an intermediate) pipeline and sending _strings without a trailing newline_ require use of the native pipe - see [this SO answer](https://stackoverflow.com/a/48372333/45375) for a real-life example.\r\n\r\n* There is also the awkwardness of the `--%` _parameter_ being virtually useless on Unix, which introduces an odd asymmetry: if the `--%` _statement_ works on Unix too, why not the `--%` _parameter_? (e.g., \r\n`/bin/echo --% 'hi     \"noon\"'` yields verbatim `'hi noon'` (rather than the expected `hi \"noon\"`), due to `echo` receiving _two_ arguments, verbatim `'hi` and `noon'`, with single quotes retained as data and double quotes stripped).\r\n\r\n---\r\n\r\n`ins`, as the suggested alternative to the `--%` statement, would ideally just be a _convenience wrapper_ around `cmd /c` and `sh -c`, but it is actually _required_:\r\n\r\n* At least _temporarily_ on Unix, as long as #1995 isn't fixed, because calling `sh -c '...'` directly currently doesn't pass arguments with embedded `\"` through properly.\r\n\r\n* _Invariably_ on Windows, because you need to pass the command line _as-is_ to `cmd`  via the `lpCommandLine` parameter of `CreateProcess` (which the `--%` parameter cannot do due to being limited to _one_ command); alternatively  trying to pass the command line as a _single string_ enclosed in `\"...\"` overall again doesn't work robustly due to #1995.\r\n\r\n---\r\n\r\nThe troubles with _argument_ passing could be avoided by providing the command line to execute _via stdin_ (which `ins` could and should also support), i.e. to _pipe_ the command line / script text to the shell executable:\r\n\r\n* On Unix, this works just fine, because passing code via _stdin_ to `sh` is essentially the same as passing a _script file_ for execution (just as `sh -c '<code>' is`):\r\n\r\n```powershell\r\nPSonUnix> @'\r\necho '{ \"foo\": \"bar\" }' | cat -n\r\n'@ | sh\r\n\r\n     1\t{ \"foo\": \"bar\" }\r\n```\r\n\r\n* Alas, on Windows `cmd` doesn't handle such input nicely: it prints its logo and echoes each command before execution, along with the prompt string: \r\n\r\n```powershell\r\nPSonWin> 'date /t & ver' | cmd\r\n\r\nMicrosoft Windows [Version 10.0.18363.836]\r\n(c) 2019 Microsoft Corporation. All rights reserved.\r\n\r\nC:\\Users\\jdoe>date /t & ver\r\nSun 07/26/2020\r\n\r\nMicrosoft Windows [Version 10.0.18363.836]\r\n\r\nC:\\Users\\jdoe>\r\n```\r\n\r\nSadly, PowerShell itself exhibits similarly unhelpful behavior: see #3223\r\n\r\n---\r\n\r\nJust like `sh` and all major POSIX-like shells (`dash`, `bash`, `ksh`, `zsh`), most scripting languages _do_ properly support stdin-as-script input, such as `python`, `node`, `ruby`, and `perl`.\r\n\r\n```powershell\r\nPS> 'print(\"hi\")' | python\r\n\r\nhi\r\n```\r\n\r\nFor incorporating _PowerShell_ variable and expression values, you again have the option of using string interpolation / concatenation:\r\n\r\n```powershell\r\nPS> $foo = 'bar'; \"print(`\"$foo`\")\" | python\r\n\r\nbar\r\n```\r\n\r\nor using the interpreter's argument-passing feature:\r\n\r\n```powershell\r\nPS> @'\r\nimport sys\r\nprint(sys.argv[1])\r\n'@ | python - bar\r\n\r\nbar\r\n```\r\n\r\n---\r\n\r\nI hope the above makes it clear that **there is _no_ need for special syntax at all - neither a `--%` statement,  nor a `#!` statement, nor Markdown code blocks** - all of which again would lack the ability to incorporate values from the calling PowerShell script.\r\n\r\nAs for the configurability of the native shell to use: For predictability, I don't think we should offer one; users who want to target a different shell can just pipe the command line to that shell's specific executable or, once #1995 is fixed, pass it as an argument.\r\n\r\n* A debatable variation is to target `/bin/bash` (with an (unlikely) fallback to `/bin/sh`) - while one would hope that published command lines rely on POSIX-mandated features only, command lines with Bash-isms (non-POSIX features that not all `/bin/sh` implementations can be expected to support) are likely out there, given the prevalence of `bash`.\r\n\r\n---\r\n\r\n@joeyaiello \r\n\r\n> It's my view that the benefits of this particular feature are much more significant than the impact #1995.\r\n\r\n**I find it mind-boggling that we spend as much effort as we have on making this cut-and-paste feature - primarily for _interactive_ convenience - an (awkward, feature-limited) first-class citizen, whereas PowerShell's fundamental inability to pass empty arguments and arguments with embedded `\"` chars. to external programs has been left unaddressed for years.**\r\n\r\n> but I'm not seeing people hit #1995 in the wild en masse\r\n\r\nI do, and for the [reasons I've previously discussed](https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-654851541) _you'll see it more and more_.\r\n\r\nAgain, I would argue **a shell that does the following, as PowerShell currently does, has a serious problem**:\r\n\r\n```powershell\r\n# On Unix\r\nPS> /bin/echo '{ \"foo\": \"bar\" }'\r\n\r\n{ foo: bar }\r\n```\r\n\r\n",
      "created_at": "2020-07-27T19:13:43Z",
      "updated_at": "2020-07-28T16:35:51Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> @rjmholt CommandAst has Extent property with input string. Re-parsing is as simple as split by first space on Windows or split by spaces on Unix. So I expect we lost nothing in the string and get good performance.\r\n\r\nYeah, I understand the draw there, and perhaps the allocations of the AST in that scenario aren't awful (although I'd argue that the language ought not to generate needless allocations for simple syntax). But all you have to do is imagine an input that bash/cmd sees as a string and PowerShell doesn't to start hitting issues:\r\n\r\nDoes not parse with current PowerShell:\r\n```powershell\r\n--% my_command \"\\\" \"\r\n```\r\n\r\nParses, but splitting by spaces gives the wrong result:\r\n```powershell\r\n--% my_command \"\\\"    \"\\\"\r\n```\r\n\r\n(We must send 4 spaces in the string, but PowerShell sees two strings separated in an array)",
      "created_at": "2020-07-27T19:20:01Z",
      "updated_at": "2020-07-27T19:23:19Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@rjmholt, all great questions at the bottom of your [comment above](https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-664560728), which to me again suggest that the right answer is: no need for special syntax.\r\n\r\nI've addressed the question about what native shell executable to use in my [previous comment](https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-664586141), but as for:\r\n\r\n> Would other shells or other languages implement this or have they already? At a syntax level, or at any other level? If so, how?\r\n\r\nI am not aware of any other language having done this at the syntax level without employing _explicit delimiters_ and allowing _interpolation_.\r\nE.g., `perl` has `` `...` `` for running shell commands, so you can run the following command from a script on Unix, for instance:\r\n`` my $foo='/'; print `ls $foo | cat -n` ``\r\n\r\nThe key aspects are the use of explicit delimiters and the ability to incorporate values from the caller - both of which are missing from the current proposal for the `--%` statement.\r\n\r\nAs stated before, we _could_ use this approach for a new _operator_ (or some sort of delimiter-based, optionally interpolating syntax), but I don't think that's worth it, given that\r\n` ins \"ls $foo | cat -n\" ` (or with a here-string variant) will do, without burdening the language with additional complexity.\r\n\r\n`perl` offers a (proper) syntax-level solution _because it isn't itself a shell_ but wants to make shell calls as convenient as possible.\r\n\r\nBy contrast, we _are_ a shell (too), and offer shell-style invocations _directly_, without any additional syntax (albeit presently flawed - see #1995).\r\nProviding special syntax to make _a different shell's_ invocations as easy as possible seems unnecessary.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-07-27T20:58:53Z",
      "updated_at": "2020-07-27T20:58:53Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "@iSazonov \r\n\r\n> _If we (and PowerShell) know that we run a native executable why do we need \"call native operator\" at all?_\r\n> \r\n> If PowerShell parse an input string and get CommandAst then PowerShell does a discover of the command.\r\n> If the command is a native command PowerShell converts the ast to NativeCommandProcessor.\r\n> We can implement new (experimental NativeCommandProcessor) for the case which will re-parse the Ast extent (that is the input string) so that to get the native executable name/path and rest of the string as argument or arguments by OS rules.\r\n> \r\n> If an user want copy-paste from shell he should type \"cmd \" or \"bash \" - that will works without editing.\r\n> If an user want copy-paste an native command line will works too like `g++ timer.cpp @conanbuildinfo.args -o timer --std=c++11`.\r\n\r\nBut wait wouldn't you never be able to use any PowerShell syntax with native commands if we did all that?  So like `sc.exe query $serviceName` would pass `$serviceName` as a literal string?",
      "created_at": "2020-07-27T22:32:38Z",
      "updated_at": "2020-07-27T22:32:38Z"
    },
    {
      "author": "essentialexch",
      "author_association": "NONE",
      "body": "> But wait wouldn't you never be able to use any PowerShell syntax with native commands if we did all that? So like `sc.exe query $serviceName` would pass `$serviceName` as a literal string?\r\n\r\nThe `--%` option is not intended to address that need.\r\n\r\n`sc.exe query $serviceName` is handled by `&\"<cmd>\"`",
      "created_at": "2020-07-27T23:20:50Z",
      "updated_at": "2020-07-27T23:20:50Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> The `--%` option is not intended to address that need.\r\n> \r\n> `sc.exe query $serviceName` is handled by `&\"<cmd>\"`\r\n\r\nYeah for sure, I don't think that's what @iSazonov is referring to though. I'm reading that as though they're suggesting a general change to how parameter binding works for native commands.",
      "created_at": "2020-07-27T23:30:48Z",
      "updated_at": "2020-07-27T23:30:48Z"
    },
    {
      "author": "essentialexch",
      "author_association": "NONE",
      "body": "> Yeah for sure, I don't think that's what @iSazonov is referring to though. I'm reading that as though they're suggesting a general change to how parameter binding works for native commands.\r\n\r\nLord, I hope not.",
      "created_at": "2020-07-27T23:32:43Z",
      "updated_at": "2020-07-27T23:32:43Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> Lord, I hope not.\r\n\r\nEh sometimes when you're brainstorming the abstract it's easy to forget about the obvious.  I mean to be fair we all read it and immediately started thinking implementation without realizing how much it would break.\r\n\r\nOr I'm missing something obvious and that's not at all what's being proposed \ud83d\ude01 ",
      "created_at": "2020-07-27T23:39:14Z",
      "updated_at": "2020-07-27T23:39:14Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@essentialexch, to be clear, re:\r\n\r\n> `sc.exe query $serviceName` is handled by `&\"<cmd>\"`\r\n\r\n`&  \"<cmd>\"` only works if `<cmd>` evaluates to a mere command _name or path_, _not including arguments_ - arguments must be passed separately, individually - and they don't per se need `\"....\"` quoting for variable references to be expanded (e.g., \r\n`$exe = 'findstr'; & \"where.exe $exe\"` fails by design; must be `& \"where.exe\" $exe` (double quotes optional here; if omitted, the `&` is then optional too))",
      "created_at": "2020-07-28T01:57:09Z",
      "updated_at": "2020-07-28T01:59:34Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Yeah for sure, I don't think that's what @iSazonov is referring to though. I'm reading that as though they're suggesting a general change to how parameter binding works for native commands.\r\n\r\n[My proposal](https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-664526006) is to fix #1995 (with breaking change) as simple as possible. Of cause interpolation does not work. Of cause it is not final proposal - it demo how we could implement a fix in minutes. And it mainly demos that we do not need a call native operator at all as @mklement0 pointed too.\r\n\r\n> Parses, but splitting by spaces gives the wrong result:\r\n\r\n@rjmholt Yes, but I think you catch the idea.\r\nFirst child of the CommandAst is StringConstantExpressionAst with the native command as BareWord. We can cut the bare word from CommandAst Extent and get parameter list without ast-s change. But we could add new ast to keep the parameter list too.\r\nI spend a time for the explanation because below I want to summarize the discussion and I feel we will need to implement some enhancement which looks complex but I feel they could be implemented simple and __with easy opt-out for backward compatibility__.\r\n\r\n-----------\r\nI believe the @SteveL-MSFT's intention of the initial proposal was to avoid a breaking change.\r\nI agree with @TSlivede and @mklement0 that this discussion showed that the new syntax is not needed since it does not solve all _fundamental_ problems like #1995 and #12975. On the other hand, it adds complexity to the language, while we want, on the contrary, to _simplify_ work with native applications.\r\n\r\n__The only way to move forward is to make a breaking change or more.__ (After that, a new operator or cmdlet might be useful in some scenarios too.)\r\n\r\n-----------\r\n\r\nWe should start with summarization of use cases and user expectations.\r\nSee @rkeithhill's [great post above](https://github.com/rkeithhill)\r\n\r\n1. Users want enable/disable interpolation.\r\nPowerShell already has strings/here-strings with single and double quotes.\r\nOur goal is to understand how to apply/refine/enhance its.\r\n2. Users want run any executable or a shell\r\n    - any executable - command starts with the app name and follows arguments \r\n        - with/without interpolation\r\n        - on single line/on multi line\r\n    - shell is probably a special case because argument(s) is a _script_\r\n        - in copy-paste scenario users don't want interpolation and want single and multi line\r\n        - in script scenario users want to enable/disable interpolation and want single and multi line\r\n\r\n    Thoughts:\r\n        This makes us think that the copy-paste scenario behavior should be the default.\r\n        Line terminators depend on executable (\\ in bash, ` in PowerShell). This makes us think that:\r\n            (1) a shell should be explicitly stated as any executable,\r\n            (2) perhaps any executable with multi line should be called by means of a shell or we have to do a special parsing (to remove \\ terminator and build argument list falling back to the issue with escaping)\r\n            (3) we could address copy-paste scenario in PSReadline. It could convert a buffer to right PowerShell command.\r\n\r\n3. Users want single line and multiline.\r\n    - perhaps we need to enhance here-strings for single line to address some scenarios as discussed previously.\r\n    - see 2 - (2) - always use a shell for multiline or implement a special parsing\r\n\r\nI don't want to write more because @TSlivede and @mklement0 could update their thoughts and conclusions from earlier but which can now be based on acceptance of breaking change(s). I'd ask to open new issue (and close all olds), enumerate all use cases (starting with @@rkeithhill's and add more), and maybe create Pester tests - it would be great step to fix the Issue.\r\n\r\nI want only add that we could consider new cmdlets to simplify user adoptions like Invoke-Shell (Invoke-NativeShell), Test-Arguments (like echoargs.exe to show that native app gets and show a help for users), Convert-Arguments (to convert user input to right escaped arguments).\r\n\r\nPS: As I showed above single line behavior could be easily opt-out for backward compatibility at run time.\r\n",
      "created_at": "2020-07-28T09:58:26Z",
      "updated_at": "2020-07-28T09:58:26Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> Line terminators depend on executable (\\ in bash, ` in PowerShell).\r\n\r\n`\\` is not a line terminator in `bash`.\r\n\r\n",
      "created_at": "2020-07-28T10:08:29Z",
      "updated_at": "2020-07-28T10:08:29Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> Of cause interpolation does not work. Of cause it is not final proposal - it demo how we could implement a fix in minutes. And it mainly demos that we do not need a call native operator at all as @mklement0 pointed too.\r\n\r\nIn the same way that we could fix all bugs in a few minutes if we just deleted the repo.  That's a pretty enormous break you're proposing.  Even if just a hypothetical I don't see how it's helpful.",
      "created_at": "2020-07-28T11:15:49Z",
      "updated_at": "2020-07-28T11:15:49Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": ">  Even if just a hypothetical I don't see how it's helpful.\r\n\r\n@SeeminglyScience It seems we are in different contexts. I say that we can implement a fix for single line native call as a breaking change but without breaking Parser. In other words, we can even switch the behavior on the fly, no matter what new behavior we would implement.\r\n",
      "created_at": "2020-07-28T11:46:26Z",
      "updated_at": "2020-07-28T11:46:51Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> In other words, we can even switch the behavior on the fly, no matter what new behavior we would implement.\r\n\r\nI guess the thing I'm missing is how do you switch that behavior on the fly without explicitly asking for it (like with a call native operator).",
      "created_at": "2020-07-28T11:51:47Z",
      "updated_at": "2020-07-28T11:51:47Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "@iSazonov \r\n\r\n> _If we (and PowerShell) know that we run a native executable why do we need \"call native operator\" at all?_\r\n> \r\n> If PowerShell parse an input string and get CommandAst then PowerShell does a discover of the command.\r\n> If the command is a native command PowerShell converts the ast to NativeCommandProcessor.\r\n> We can implement new (experimental NativeCommandProcessor) for the case which will re-parse the Ast extent (that is the input string) so that to get the native executable name/path and rest of the string as argument or arguments by OS rules.\r\n> \r\n> If an user want copy-paste from shell he should type \"cmd \" or \"bash \" - that will works without editing.\r\n> If an user want copy-paste an native command line will works too like `g++ timer.cpp @conanbuildinfo.args -o timer --std=c++11`.\r\n\r\nI want to confirm what you mean by that: Are you suggesting to essentially ignore all powershell syntax, when calling external executables?\r\n\r\nSpecifically: Are you suggesting, that running for example\r\n```\r\n/bin/echo (1..5)\r\n```\r\nin powershell will no longer out put `1 2 3 4 5` but should instead output literal `(1..5)`?\r\n\r\nIf that is actually what you are suggesting, than I have to say: I think that is a terrible idea.\r\n\r\nThat doesn't simplify things (external executables behave now **syntactically** different than internal cmdlets) and it also does't have to do anything with #1995 IMHO...",
      "created_at": "2020-07-28T15:32:06Z",
      "updated_at": "2020-07-28T15:33:42Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "@rjmholt \r\nFrom [above](https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-664560728):\r\n> - Would other shells or other languages implement this or have they already? At a syntax level, or at any other level? If so, how?\r\n\r\nThe only thing, that comes to my mind would be ipythons [`!` operator](https://ipython.readthedocs.io/en/stable/interactive/reference.html#system-shell-access):\r\n\r\nRunning `!ps -'fax' || true` in ipython outputs:\r\n```\r\n  261 pts/0    Sl     0:00          \\_ /usr/bin/python /usr/bin/ipython\r\n  311 pts/0    S      0:00              \\_ /bin/bash -c ps -'fax' || true\r\n  312 pts/0    R      0:00                  \\_ ps -fax\r\n```\r\n([ps doesn't show quotes around arguments](https://unix.stackexchange.com/questions/243142/how-to-show-quoted-command-list), but `ps -'fax' || true` is really given as one single argument to bash.)\r\n\r\nHowever, this feature still allows interpolation of python variables into that command (`{pyvar}`).\r\n\r\nAnd similar to @mklement0's [example](https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-664635110), ipython only implements this\r\n>because it isn't itself a shell\r\n\r\nIf ipython would only allow python syntax it wouldn't be very useful as a shell, so they allow this syntax to forward commands to bash to be usable as a shell. Powershell on the other hand claims to be a shell (until #1995 is solved, I won't say that it *is* a shell), so it would be quite strange to add a special syntax for calling *other* shells.",
      "created_at": "2020-07-28T15:58:25Z",
      "updated_at": "2020-07-28T15:58:25Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "If something like this gets for whatever reason actually implemented (hopefully not), I'd suggest to use `! ` instead of `--%` as the \"call shell operator\".\r\n\r\n`! ` is something people might guess (because they know `!` for that purpose from ipython (or from the vim command mode or from `less` or from `ftp`))\r\n\r\n`--%` on the other hand is harder to type, unlikely to be guessed and most importantly: The current usage of `--%` has in my opinion very little in common with the \"pass stuff to another shell\" behavior. The current `--%` emulates exactly one element of cmd syntax: variable substitution (and even that not completely). It doesn't support the escape char `^`, doesn't allow redirection to files, and so on. The only thing somewhat useful about the current `--%` is the ability to pass verbatim content into the `lpCommandLine` - but that is something that the proposed \"call shell operator\" isn't good at.\r\n\r\nOne more difference (which was already mentioned) between the proposed \"call shell operator\" and the current `--%`: One ends at pipes, the other doesn't - very confusing for new users. `!` on the other hand forwards `|` to the shell in all applications I tested so far (ipython, vim, less, ed, etc.).\r\n",
      "created_at": "2020-07-28T16:37:22Z",
      "updated_at": "2020-07-28T16:40:08Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "```powershell\r\nHELP about_Logical_Operators -S\r\n```",
      "created_at": "2020-07-28T18:00:15Z",
      "updated_at": "2020-07-28T18:00:15Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "Yeah, `!` by itself is problematic because it's a logical negation operator in the language.",
      "created_at": "2020-07-28T18:01:42Z",
      "updated_at": "2020-07-28T18:01:42Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "BTW one of the alternate proposals was `&!` - sort of a \"call native/shell\" operator.",
      "created_at": "2020-07-28T18:08:45Z",
      "updated_at": "2020-07-28T18:08:45Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I wish @TSlivede had stressed the \"hopefully not\" part more when he said \"If something like this gets for whatever reason actually implemented (hopefully not)\"\r\n\r\n* No operator/statement _with individual arguments_ can cleanly solve the I-want-to-use-PowerShell-values-in-the-native-command-line problem, given that `$` is used as the variable sigil in _both_ PowerShell and POSIX-like shells.\r\n\r\n* No operator/statement _without explicit delimiters around the entire native command line_ can solve the where-does-the-native-command-line-end problem (which you may or may not care about).\r\n",
      "created_at": "2020-07-28T18:28:36Z",
      "updated_at": "2020-07-28T18:33:20Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee discussed this today.  At this point, there doesn't seem to be agreement on the initial problem statement nor a design on how to resolve so we don't believe we can get this into 7.1 w/ a stable design.",
      "created_at": "2020-07-28T19:19:53Z",
      "updated_at": "2020-07-28T19:19:53Z"
    },
    {
      "author": "oising",
      "author_association": "CONTRIBUTOR",
      "body": "> @PowerShell/powershell-committee discussed this today. At this point, there doesn't seem to be agreement on the initial problem statement nor a design on how to resolve so we don't believe we can get this into 7.1 w/ a stable design.\r\n\r\n182 comments!",
      "created_at": "2020-07-28T19:30:54Z",
      "updated_at": "2020-07-28T19:30:54Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "There's been some great discussion on this!  I'll continue to monitor any new comments on this issue.  We still encourage the community to implement `Invoke-NativeCommand` type cmdlet published to PSGallery independent of this issue.",
      "created_at": "2020-07-28T19:37:37Z",
      "updated_at": "2020-07-28T19:37:37Z"
    },
    {
      "author": "essentialexch",
      "author_association": "NONE",
      "body": "I think it unfortunate, when you had a compromise but very useful solution at https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-662732627, to drop this. I know you want consensus, but sometimes a compromise is the best that can happen. No, it isn't perfect, but a one-liner SO solution would be extremely useful. At least in this one person's opinion.",
      "created_at": "2020-07-28T20:59:58Z",
      "updated_at": "2020-07-28T20:59:58Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@essentialexch to be clear, we don't even have consensus within the PowerShell team",
      "created_at": "2020-07-28T21:24:36Z",
      "updated_at": "2020-07-28T21:24:36Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Since this is postponed what about implementation of helpers\r\n> we could consider new cmdlets to simplify user adoptions like Invoke-Shell (Invoke-NativeShell), Test-Arguments (like echoargs.exe to show that native app gets and show a help for users), Convert-Arguments (to convert user input to right escaped arguments).\r\n\r\nI think Test-Arguments could be very useful.",
      "created_at": "2020-07-29T04:05:12Z",
      "updated_at": "2020-07-29T04:05:12Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I've just published a module, **[`Native`](https://github.com/mklement0/Native), (`Install-Module Native -Scope CurrentUser`) which I invite you all to try and whose commands I'll be using below**; the numeric use cases referenced are from @rkeithhill's comment [above](https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-664574903).\r\n\r\nIf we ever want the conceptual fog to clear, I think we need to frame the uses cases differently.\r\n_None of them require any changes in parsing_.\r\n\r\n### Use case [native-shell call]: \r\n\r\nYou want to execute an _individual command_ (use case 1) or an entire _multi-command command line_ (use case 2) _written for the platform-native shell_ (this issue):\r\n\r\n  * Since you're using  a different shell's syntax, you're passing the command (line) _as a single string_ to the target shell, for _it_ to do the parsing; PowerShell's string interpolation offers the ability to embed PowerShell values into the string passed (use case 2a). \r\n  * **`ins` (`Invoke-NativeShell`)** covers these uses cases.\r\n\r\n```powershell\r\n# Use case 1: Single executable call with line continuation, on Unix.\r\n@'\r\ntar -cvpzf /share/Recovery/Snapshots/$(hostname)_$(date +%Y%m%d).tar.gz \\\r\n    --exclude=/proc \\\r\n    --exclude=/lost+found \r\n'@ | ins\r\n\r\n# Use case 2: Entire Bash command line (also with line continuation)\r\n@'\r\nps -o pid,args | awk \\\r\n  '/pwsh/ { print $1 }'\r\n'@ | ins\r\n\r\n# Use case 2a: Entire Bash command line (also with line continuation) with string interpolation.\r\n# Note the double-quoted here-string and the need to escape the $ that is for Bash as `$\r\n$fields = 'pid,args'\r\n@\"\r\nps -o $fields | awk \\\r\n  '/pwsh/ { print `$1 }'\r\n\"@ | ins\r\n\r\n# Alternative to use case 2a: pass the PowerShell value *as a pass-through argument*,\r\n# which allows passing the script verbatim.\r\n# Bash sees the pass-through arguments as $1, ... (note that the `awk` $1 is unrelated).\r\n@'\r\nps -o $1 | awk \\\r\n  '/pwsh/ { print $1 }'\r\n'@ | ins - 'pid,args'\r\n```\r\n\r\nThe  here-string syntax isn't the most convenient (hence the suggestion to implement an in-line variant - see #13204), but you don't _have_ to use it; for verbatim commands, you can use `'...'`, which only requires _doubling_ embedded `'`, if present.\r\n\r\nAlso, here's a **reasonable substitute for the  \"StackOverflow operator\"**: \r\n\r\n**If you place the following `PSReadLine` key handler in your `$PROFILE` file, you'll be able to use <kbd>Alt-v</kbd> to scaffold a call to `ins` with a verbatim here-string into which the current clipboard text is pasted.\r\n<kbd>Enter</kbd> submits the call.**\r\n\r\n```powershell\r\n# Scaffolds an ins (Invoke-NativeShell) call with a verbatim here-string\r\n# and pastes the text on the clipboard into the here-string.\r\nSet-PSReadLineKeyHandler 'alt+v' -ScriptBlock {\r\n  [Microsoft.PowerShell.PSConsoleReadLine]::Insert(\"@'`n`n'@ | ins \")\r\n  foreach ($i in 1..10) { [Microsoft.PowerShell.PSConsoleReadLine]::BackwardChar() }\r\n  # Comment the following statement out if you don't want to paste from the clipboard.\r\n  [Microsoft.PowerShell.PSConsoleReadLine]::Insert((Get-Clipboard))\r\n}\r\n```\r\n\r\n\r\n### Use case [direct executable call]: \r\n\r\nYou want to call a _single external executable_ using _PowerShell_'s syntax, with _individual arguments_ (use cases 1a and 3).\r\n\r\n* **This is a core mandate of any shell, and it is of vital importance that it work robustly.**\r\n\r\n  * You need to be able to rely on PowerShell being able to pass through any arguments that result from _its_ parsing _as-is_ to the target executable. **This is currently not the case - see #1995**.\r\n\r\n* **It requires you to understand _PowerShell's_ syntax and _its_ argument-mode metacharacters. Of necessity, these differ from the native shells', but it is the price to pay for PowerShell's superior command-line capabilities - it's a price we want to encourage users to pay.**\r\n\r\n  * You need to be aware that `` ` `` is used as the escape character and for line continuation.\r\n  * You need to be aware that PowerShell has additional metacharacters that require quoting/escaping for verbatim use; these are (note that `@` is only problematic as an argument's first char.):\r\n\r\n     * for POSIX-like shells (e.g., Bash): `` @ { } ` `` (and `$`, if you want to prevent up-front expansion by PowerShell)\r\n     * for `cmd.exe`: `` ( ) @ { } # ` ``\r\n     * Individually `` ` ``-escaping such chars. is sufficient (e.g., `` printf %s `@list.txt ``).\r\n\r\n**While we're waiting for #1995 to be fixed, function `ie` (for *i*nvoke (external) *e*xecutable) fills the gap,** simply by prepending to a direct call; e.g., instead of the following call:\r\n\r\n```powershell\r\n# This command is currently broken, because the '{ \"name\": \"foo\" }' argument isn't properly passed.\r\ncurl.exe -u jdoe  'https://api.github.com/user/repos' -d '{ \"name\": \"foo\" }'\r\n```\r\n\r\nyou'd use the following:\r\n\r\n```powershell\r\n# OK, thanks to `ie`\r\nie curl.exe -u jdoe  'https://api.github.com/user/repos' -d '{ \"name\": \"foo\" }'\r\n```\r\n\r\nThe `Native` module comes with something akin to `echoArgs.exe`, the `dbea` (`Debug-ExecutableArguments`) command; sample output on Windows:\r\n\r\n```powershell\r\n# Note the missing first argument, the missing \" chars., and the erroneous argument boundaries.\r\nPS> dbea '' 'a&b' '3\" of snow' 'Nat \"King\" Cole' 'c:\\temp 1\\' 'a \\\" b'\r\n7 argument(s) received (enclosed in <...> for delineation):\r\n\r\n  <a&b>\r\n  <3 of snow Nat>\r\n  <King>\r\n  <Cole c:\\temp>\r\n  <1\\ a>\r\n  <\">\r\n  <b>\r\n\r\nCommand line (helper executable omitted):\r\n\r\n  a&b 3\" of snow \"Nat \"King\" Cole\" \"c:\\temp 1\\\\\" \"a \\\" b\"\r\n```\r\n\r\nBy using the `-UseIe` (`-ie`) switch, you can tell `dbea` to pass the arguments via `ie`, which demonstrates that it fixes the problems:\r\n\r\n```powershell\r\n# OK, thanks to -UseIe\r\nPS> dbea -UseIe '' 'a&b' '3\" of snow' 'Nat \"King\" Cole' 'c:\\temp 1\\' 'a \\\" b'\r\n6 argument(s) received (enclosed in <...> for delineation):\r\n\r\n  <>\r\n  <a&b>\r\n  <3\" of snow>\r\n  <Nat \"King\" Cole>\r\n  <c:\\temp 1\\>\r\n  <a \\\" b>\r\n\r\nCommand line (helper executable omitted):\r\n\r\n  \"\" a&b \"3\\\" of snow\" \"Nat \\\"King\\\" Cole\" \"c:\\temp 1\\\\\" \"a \\\\\\\" b\"\r\n```\r\n\r\nNote: Once #1995 is fixed, `ie` is no longer required; in the interest of forward compatibility, `ie` is designed to detect and automatically defer to a fix; that is, once the fix is in place, `ie` will stop applying its workarounds and will effectively act like a direct / `&` call.\r\n\r\n### Use case [direct rogue Windows executable call]: \r\n\r\nThere are two main problems, which arise on _Windows only_:\r\n\r\n* You're invoking a \"rogue\" executable that has **quoting requirements that differ from the most widely used convention**; e.g, `msiexec.exe` and `msdeploy.exe` require `prop=\"<value with spaces>\"` to be quoted precisely that way - the quoting just around the _value_ part - even though `\"prop=<value with spaces>\"`  - quoting of the entire argument - _should_ be equivalent (the latter is what PowerShell - justifiably - does behind the scenes).\r\n\r\n* You're invoking _a batch file_ with _an argument that doesn't contain spaces, but contains `cmd.exe` metacharacters_ such as `&`, `^`, or `|`; e.g.:\r\n\r\n  * `.\\someBatchFile.cmd 'http://example.org/a&b'`\r\n  * PowerShell - justifiably - passes `http://example.org/a&b` _unquoted_ (since there is no embedded whitespace), but this breaks the batch-file invocation, because `cmd.exe` - unreasonably - subjects the arguments passed to a batch file to the same parsing ruling that would apply *inside of `cmd.exe`* rather than accepting them as literals.\r\n\r\n  * Note: **While using batch files to _directly_ implement functionality is probably waning, using them as _CLI entry points_ is still very common, such as Azure's `az` CLI, which is implemented as batch file `az.cmd`.**\r\n\r\nNote: **`ie` automatically handles these scenarios for batch files and for `msiexec.exe` and `msdeploy.exe`, so for _most_ calls no extra effort should be needed**; however, it is impossible to anticipate _all_ \"rogue\" executables.\r\n\r\nThere are two ways to resolve this:\r\n\r\n* Given that `cmd.exe`, after applying its own interpretation to arguments on a command line, _does_ preserve the quoting as specified, you can delegate to an `ins` call on Windows:\r\n\r\n  * `ins '.\\someBatchFile.cmd \"http://example.org/a&b\"'`\r\n  * If you use an _expandable_ string, this again enables you to embed PowerShell values into the command string.\r\n     * ``$url = 'http://example.org/a&b'; ins \".\\someBatchFile.cmd `\"$url`\"\" ``\r\n\r\n* Alternatively, use the current `--%` implementation, but beware its limitations:\r\n\r\n  * `.\\someBatchFile.cmd --% \"http://example.org/a&b\"'`\r\n  * Given how `--%` is implemented, the only way to embed PowerShell values is to - awkwardly - define an _aux. environment variable_ and reference it with `%...%` syntax:\r\n     * ``$env:url = 'http://example.org/a&b'; .\\someBatchFile.cmd --% \"%url%\" ``\r\n\r\n---\r\n\r\n### Error handling\r\n\r\nThe pending https://github.com/PowerShell/PowerShell-RFC/pull/88 will bring better error-handling integration with external (native) executables.\r\n\r\nIn the meantime, the `Native` module ships with two features for **ad-hoc opt-in to treating a nonzero exit code as a script-terminating error**:\r\n\r\n* `ins` supports the `-e` / `-ErrorOnFailure` switch, which throws an error if `$LASTEXITCODE` is nonzero after the call to the native shell.\r\n\r\n* `iee` is a wrapper function for `ie` that analogously throws an error if `$LASTEXITCODE` is nonzero after the call to the external executable.\r\n\r\nThere are many subtleties to the commands that ship with the module.\r\nThe fairly extensive comment-based help hopefully covers them sufficiently.\r\n\r\n\r\n",
      "created_at": "2020-08-10T20:27:32Z",
      "updated_at": "2020-08-10T21:32:00Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "> If we ever want the conceptual fog to clear, I think we need to frame the uses cases differently.\r\n\r\nGreat!  What I posted earlier was just to get folks thinking about creating more and better use cases.",
      "created_at": "2020-08-10T20:52:28Z",
      "updated_at": "2020-08-10T20:52:28Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I should clarify a few important aspects of `ins` (`Invoke-NativeShell`) that differ from what I've previously proposed; the aim was to account for the ubiquity of `bash` and to provide a consistent CLI across platforms.\r\n\r\n* On **Unix**, I've decided to call `/bin/bash` rather than `/bin/sh`, given Bash's ubiquity, but you can opt into using `/bin/sh` with `-UseSh` (`-sh`) (`/bin/sh` also serves as the fallback in the unlikely event that `/bin/bash` isn't present).\r\n\r\n  * In the interest of a consistent experience across invocation forms and platforms, I've hidden the ability to set `$0`, the invocation name; that is, any pass-through arguments start with `$1`, which is consistent with how arguments are passed when you pipe the script from the pipeline, and likely what users expect:\r\n\r\n```powershell\r\n# Script as argument\r\nPSonUnix> ins 'echo $# arguments; echo \"[$1] [$2]\"' one two\r\n2 arguments\r\n[one] [two]\r\n\r\n# Script via pipeline; note the \"-\" to signal that the script is piped.\r\nPSonUnix> 'echo $# arguments; echo \"[$1] [$2]\"' | ins - one two\r\n2 arguments\r\n[one] [two]\r\n\r\n# As an aside: script as argument, with pipeline input *as data*:\r\nPSonUnix> 'one', 'two' | ins 'cat -n'\r\n     1\tone\r\n     2\ttwo\r\n```\r\n\r\n* On **Windows** I had to use a temporary _batch file_ behind the scenes for technical reasons, but I think that use of batch-file syntax is ultimately the better choice anyway (`%%i` rather than `%i`  in `for` loop variables, ability to escape `%` as `%%`).\r\n\r\n  * Use of a batch file also enables support for pass-through arguments, as on Unix:\r\n\r\n```powershell\r\n# Script as argument\r\nPSonWin> ins 'echo [%1] [%2]' one two\r\n[one] [two]\r\n\r\n# Script via pipeline; note the \"-\" to signal that the script is piped.\r\nPSonWin> 'echo [%1] [%2]' | ins - one two\r\n[one] [two]\r\n```\r\n",
      "created_at": "2020-08-11T14:17:43Z",
      "updated_at": "2020-08-11T14:17:43Z"
    },
    {
      "author": "awakecoding",
      "author_association": "CONTRIBUTOR",
      "body": "I am late to the party, but here are my two cents:\r\n\r\nReading through the past suggestions, I see \"--%\" and \"&!\" have been proposed for the new call operator. My personal preference definitely goes with \"&!\", not only it is closely related to \"&\" but it just feels much more natural than \"--%\".\r\n\r\nHere are my general impressions so far for all the times I have used the current call operator:\r\n- It works, you just have to be careful about escaping in the right places until you get the expected result\r\n- I tend to quote all of my parameters individually because I have no idea how PowerShell would interpret it\r\n- Even if it feels a bit clunky as opposed to bash, I prefer explicit quoting and escaping over unexpected results\r\n\r\nChanging the behaviour of the current call operator comes at the risk of breaking existing scripts, so it should not be taken lightly. If we choose to make breaking changes to \"&\" I suggest introducing a new $PSCallOperatorPolicy variable that could be set to \"legacy\" (or other values in the future) to restore the old behaviour in the current scope, only when needed to make things work.\r\n\r\nI do not mind the introduction of a new call operator like \"&!\" with new behaviour incompatible with the old, the only issue is that PowerShell would now have two call operators. My main concern is that we certainly don't want a third call operator in the future, so this means we have to get this one right, otherwise we'll face the same issue in a few years.\r\n\r\nHowever, even just trying to get the design perfect for the new call operator would likely make it impossible to ship, because nobody can get that kind of stuff right anyway, and it is suggested to a lot of diverging opinions and use cases we can't predict. The only true solution in my mind would be to make the new call operator extensible through arguments meant for the operator and not the native command line. An alternative approach would be to use context variables like $PSCallOperatorPolicy, but this could quickly get out of hand.\r\n\r\nWould there be a syntactically valid approach to optionally passing parameters to the call operator in the same way one can pass arguments to Start-Process? In most cases, the default, unmodified behaviour would be good, but it would make it possible to expose a lot more functionality for more advanced use cases.\r\n\r\nWhen thinking about the call operator, I always picture it in my mind as shorthand to Start-Process, but I always wish I could send it similar parameters. I have no idea if the call operator and Start-Process share a lot of the same code, but from a conceptual standpoint they are relatively close in terms of exposed functionality.\r\n\r\nHere are some ideas for an extensible \"&!\" operator:\r\n\r\n```\r\n&(<OperatorParams>)! <CommandParams>\r\n&!(<OperatorParams>) <CommandParams>\r\n```\r\n\r\nSince we already use $(<expression>) to force the evaluation of an expression, using &(<OperatorParams>)! may not be so weird after all. The goal of placing the optional parameters between parenthesis and strictly in between & and ! would be to hopefully make it much easier to parse unambiguously. Everything *after* the ! would be the regular command line to be used with the call operator.\r\n\r\nI guess we could also invert the two, which would always place the native command first:\r\n\r\n```\r\n&(<Command Params>)! <OperatorParams>\r\n&!(<CommandParams>) <OperatorParams>\r\n```\r\nWhat I like about the parenthesis here is we somehow get a feel that we \"evaluate a native command\" almost like we can evaluate a PowerShell expression, except with a different syntax. We also open the way to extend the call operator through parameters affecting its behaviour (toggle the legacy behaviour, but may even redirect stdio/stdout/stderr, etc).\r\n\r\nLet me know what you think. I can definitely join the \"new operator\" camp if there is a suitable plan to also make it extensible without breaking changes in the future. It would also be easier to come up with something that works, only to add more parameters in the future, allowing us to ship something without getting everything right the first time.",
      "created_at": "2020-12-15T19:09:45Z",
      "updated_at": "2020-12-15T19:09:45Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "I think the idea of a new operator to be used for a legacy ill\u2011defined interface is deeply misguided.",
      "created_at": "2020-12-15T22:21:58Z",
      "updated_at": "2020-12-15T22:36:29Z"
    },
    {
      "author": "awakecoding",
      "author_association": "CONTRIBUTOR",
      "body": "> I think the idea of a new operator to be used for a legacy ill\u2011defined interface idea is deeply misguided.\n\nIf we make a new operator, I don't think we need to give it a \"legacy\" parameter because one can use the older operator instead. I agree, that is not a good idea.",
      "created_at": "2020-12-15T22:32:05Z",
      "updated_at": "2020-12-15T22:32:05Z"
    },
    {
      "author": "peppekerstens",
      "author_association": "NONE",
      "body": "@awakecoding: valid points, great thinking! \r\n\r\nI've always felt a bit itchy about the native commands. Explaining to newbies; \r\n\"Yes, PS is all verb-noun doctrine...unless...there's also this... no no, they're not aliases! Yes, they do look a bit like *nix style commands. Are you confused...? Well I am also sometimes...still....\"\r\n\r\n> My main concern is that we certainly don't want a third call operator in the future, so this means we have to get this one right, otherwise we'll face the same issue in a few years.\r\n\r\nThat's not really fair. In de PS 2/3 days, who would have known that PS is going to be ported to *NIX alike systems? So who knows were we are 5 years from now. Things just...change. \r\n\r\nYou cannot design 'for everything'...unless your answer is always 42 when you don't know :smile:\r\n\r\n\r\n\r\n",
      "created_at": "2021-01-09T07:17:30Z",
      "updated_at": "2021-01-09T07:26:20Z"
    },
    {
      "author": "romero126",
      "author_association": "CONTRIBUTOR",
      "body": "After reading a ton of the community suggestions, I truly wonder if this is the right path. Based off of the syntax that people are using I honestly think it should be treated how we use a new here-string or scriptblock.\n\nSo my suggestion would be a uniquely escaped scriptblock\n\nExample:\n& {sh <your multiline bash compliant code here> sh}\n\nSyntax may change a little bit,\nHowever I do like the following options\n!{ }!\n&!{ }!&\n{sh sh}\n\nOf course there are implications on parsing and adding a new ast tree visitor, I feel like this would give us the better forward facing design elements The PS community would be able to leverage for a variety of instances vs the current suggestions that all hint at the same thing but are limited in scope.\n\nThoughts?",
      "created_at": "2021-01-09T16:53:04Z",
      "updated_at": "2021-01-09T16:54:03Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@romero126 You could re-read my comments above why this way is the navel - we don't need \"one more way\" to launch native apps.\r\n\r\n@romero126 @peppekerstens You could look #13428. If we injected PSNativeCmdlet in Engine we would be able to solve all the problems mentioned and get tremendous flexibility in development for many years.",
      "created_at": "2021-01-09T17:43:28Z",
      "updated_at": "2021-01-09T17:43:28Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": ">  I truly wonder if this is the right path.\r\n\r\nIndeed.\r\n\r\nWe're talking about a cross-platform (in _syntax_ only) mechanism for passing a command-line _string_ to the _platform-native shell_.\r\n\r\nIn a nutshell: `cmd /c ...` on Windows and `sh -c '...'` on Unix.\r\n\r\nSuch a narrow use case does _not_ call for an operator, but for a _command_ - the [previously discussed `ins` (`Invoke-NativeShell`)](https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-671572939).\r\n\r\n> how we use a new here-string or scriptblock.\r\n\r\nIn fact using the _existing string literals_, such as - if needed - a here-string is the appropriate thing to do - both conceptually and syntactically - no need to invent _new_ syntax.\r\n\r\n After all, you're passing a _string_ to an _external program_, which then interprets it according to _its_ rules.\r\n\r\nUsing strings is also the right choice for being able to use _string interpolation_, so as to be able to embed _PowerShell variables and expressions_ in the command line being passed.\r\n\r\nThe above solves all conceptual problems that would arise from shoehorning a different shell's syntax into PowerShell's syntax without proper delimiters, via an operator, as proposed here, which would invite perennial confusion and headaches.\r\n\r\n---\r\n\r\nI do understand the desire to make this use case syntactically _easier_; the choices are:\r\n\r\n* In many cases, using regular string literals will be sufficient; e.g.,\r\n`ins '/bin/echo \"Nat \\\"King\\\" Cole\"'` (Unix) / `ins 'echo Nat \"King\" Cole | findstr \"g\\\" C\"'` (Windows);\r\nyou'll just need to know that `'` must be escaped as `''` in `'...'` strings, and pass-through `$` as `` `$ `` in `\"...\"` strings.\r\n\r\n* Here-strings obviate the need for escaping (in the verbatim variant) for quick paste-it-and-submit-it scenarios:\r\n  *  While they are syntactically cumbersome, [PSReadLine can help, as previously demonstrated](https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-671572939).\r\n  * Finally, introducing an _in-line_ here-string variant would help too, which would be a general improvement to the language; e.g., \r\n`ins @' /bin/echo \"Nat 'King' Cole\" '@` - see #13204\r\n\r\n\r\n",
      "created_at": "2021-01-09T17:54:58Z",
      "updated_at": "2021-01-09T21:29:52Z"
    },
    {
      "author": "aminya",
      "author_association": "NONE",
      "body": "Whatever decision is made about the operator, I think there should be a mode to enable globally (in my $profile for example), to make all the commands have this new operator that fixes the broken behavior implicitly included before them. This allows using PowerShell like Bash without the quoting issue.\r\n\r\nWith the new mode enabled, I should be able to do this as I can in Bash:\r\n```ps1\r\n\u276f node -e 'console.log(\"good\")'\r\ngood\r\n\r\n\u276f node -e \"console.log('good')\"\r\ngood\r\n\r\n\u276f $str=\"good\"\r\n\u276f node -e \"console.log('$str')\"\r\ngood\r\n```",
      "created_at": "2021-01-21T05:43:14Z",
      "updated_at": "2021-01-21T05:45:00Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@aminya, what you're describing is an unrelated, general problem with how PowerShell passes arguments to external programs, discussed at length in https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-738073284; the plan is to initially provide a fix in the form of an experimental feature (~~not available as of this writing; an initial attempt to implement it was abandoned (https://github.com/PowerShell/PowerShell/pull/13482#issuecomment-709632395), we're waiting for a new one~~ _update_: see #14747 for the discussion and PR #14692 for the current PR).",
      "created_at": "2021-01-21T15:00:57Z",
      "updated_at": "2021-03-28T20:44:57Z"
    },
    {
      "author": "aminya",
      "author_association": "NONE",
      "body": "> @aminya, what you're describing is an unrelated, general problem with how PowerShell passes arguments to external programs, discussed at length in https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-738073284; the plan is to initially provide a fix in the form of an experimental feature (not available as of this writing; an initial attempt to implement it was abandoned (https://github.com/PowerShell/PowerShell/pull/13482#issuecomment-709632395), we're waiting for a new one).\r\n\r\nThanks. \r\n\r\nAlso, it would be good to remove the need for esc operator when we want to interpolate the flags. \r\n\r\nNotice the need for esc\r\n```ps1\r\n$someFlag=\"--some-flag\"\r\n\r\n$esc = '--%'\r\nscript/build --first-flag $esc $someFlag\r\n```\r\n\r\nIn bash this becomes\r\n```bash\r\nscript/build --first-flag $someFlag\r\n```",
      "created_at": "2021-01-22T03:36:41Z",
      "updated_at": "2021-01-22T05:17:53Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@aminya, there's no reason to use `--%` in your example and, in fact, it actively _prevents_ interpolation (if the symbol is used _literally_ and/or via `@`-prefixed splatting; the behavior you're showing with `--%` contained in a _variable_ actually _does_ result in interpolation while still stripping the `--%` and is arguably a _bug_ - see #11608); this thread already contains a detailed discussion of `--%`, the [stop-parsing symbol](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_Parsing) and its appropriate uses and limitations, starting [here](https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-653319079); independently, there _are_ [various problems with passing `-`-prefixed tokens as unnamed arguments to PowerShell commands and/or to external programs](https://github.com/PowerShell/PowerShell/issues?q=is%3Aissue+is%3Aopen+in%3Atitle+argument-passing).\r\n\r\nHowever, I suggest keeping this issue focused on the original intent: offering a convenient way to execute commands written for the platform-native shell.\r\n\r\n",
      "created_at": "2021-01-25T02:44:35Z",
      "updated_at": "2021-01-25T03:03:42Z"
    },
    {
      "author": "Luiz-Monad",
      "author_association": "NONE",
      "body": "This situation is so unfortunate for me, I need to fastly process the output for `CMake` when tracing, besides passing compiler arguments, which are kind of annoying (bad CMakeLists, but that's another problem).  I also couldn't wait for `7.2` going live.\r\nWhat I needed was redirecting the error output to the normal output by the most directly means possible, and the only way to do that is at the dotnet `IO.Stream` source.\r\n (I could recompile `CMake`, but I don't want to do that for reproducibility reasons, an external Powershell module is better anyway, as this problem could happen again in other processes).\r\nSo I made a better `Invoke-NativeProcess`  CmdLet that solve the streaming problems, besides correctly using `ArgumentLists` because it uses a copy of the Start-Process the same way the internal `NativeCommandProcessor` does.\r\n\r\nPlease provide us with better ways to hook new `CommandProcessors`, so we can directly create custom replacements instead of making CmdLets.\r\n\r\nI think if there was a simpler way to hook `CommandsProcessors`, or change which `CommandProcessor` is used for each executable, it would be much better than using `&` and relying on it doing the wrong thing (trying his best thou, but it doesn't know what its command does).\r\nI bet if `CommandProcessors` were customizable, this problem could be alleviated, because it mostly happens when integrating with external tools.\r\nSo it would be much simpler to create customized `CommandProcessors` for each tool, perhaps driven by metadata, a simple XML and powershell generates all the CmdLets/CommandProcessors to build the command line for the external application, the final user doesn't even need to know anything, is just does `Get-Help` and get the correct parameters. It would get much more integrated. An idea would be doing what syntax highlighters do in VsCode, sometimes they have a parse-tree just for highlighting, which is kind of the same problem we have with detecting which thing is a literal char and which thing is an argument that should be expanded, this is a way to drive for any kind of syntax, and work for most languages (besides C++, because, in C++, even the syntax is Turing complete, you can't know it before you make the entire compiler).\r\nA good side effect would also having standardized `-parameter` witch is better than `/s` or `--bullshit`, besides `Get-Help` being useful. \r\n\r\nMeanwhile, I have a solution, just use my `Invoke-FastProcess`\r\nThe library I made for this purpose. https://github.com/Luiz-Monad/PowershellProcess\r\n\r\n<blockquote><img src=\"https://opengraph.githubassets.com/446e455709b72508de9710b1ca8e4516671f10781bc0f1866a402c8e7cf1b9c0/Luiz-Monad/PowershellProcess\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/Luiz-Monad/PowershellProcess\">Luiz-Monad/PowershellProcess</a></strong></div><div>Contribute to Luiz-Monad/PowershellProcess development by creating an account on GitHub.</div></blockquote>",
      "created_at": "2021-06-30T20:25:30Z",
      "updated_at": "2021-06-30T21:03:40Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> So it would be much simpler to create customized `CommandProcessors` for each tool, perhaps driven by metadata, a simple XML and powershell generates all the CmdLets/CommandProcessors to build the command line for the external application,\r\n\r\nYou could look https://github.com/PowerShell/Crescendo. \r\n(I'm personally skeptical about it. It's extremely surprising that PowerShell doesn't do what it should and we need to learn yet another convoluted module just to run an application.)\r\n\r\nMy alternative proposal partially is in #13428.\r\n(This allows us to do magical things with minimal changes in Engine (based on some meta-information) as well as very specific things.)\n\n<blockquote><img src=\"https://opengraph.githubassets.com/4cb2831ead6372268b67a933229de825b7c82f78debec3fddde5800f78da7a4a/PowerShell/Crescendo\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/PowerShell/Crescendo\">PowerShell/Crescendo</a></strong></div><div>a module for wrapping native applications in a PowerShell function and module - PowerShell/Crescendo</div></blockquote>",
      "created_at": "2021-07-01T03:04:40Z",
      "updated_at": "2021-07-01T03:04:42Z"
    },
    {
      "author": "Luiz-Monad",
      "author_association": "NONE",
      "body": "> \r\n> \r\n> > So it would be much simpler to create customized `CommandProcessors` for each tool, perhaps driven by metadata, a simple XML and powershell generates all the CmdLets/CommandProcessors to build the command line for the external application,\r\n> \r\n> You could look https://github.com/PowerShell/Crescendo.\r\n> (I'm personally skeptical about it. It's extremely surprising that PowerShell doesn't do what it should and we need to learn yet another convoluted module just to run an application.)\r\n> \r\n> My alternative proposal partially is in #13428.\r\n> (This allows us to do magical things with minimal changes in Engine (based on some meta-information) as well as very specific things.)\r\n> \r\n\r\n\r\nWow, that's exactly what I needed, thank you.\r\nI can even replace `&` with my `InvokeProcess-Fast` which buffer the stream directly from the source, the `System.IO.Stream`, to an array, so it doesn't send thousands of objects onto the pipeline (sending arrays kind of partially defeats its purpose), but now I can stream 4MB of text into my console, and better, I can Tee-Objects as fast as the filesystem would write them, which gets me amazingly fast throughput, the file finishes writing in parallel faster than dumping text onto the screen, which is what I wanted. \r\nBut the most important of all, when I redirect the error stream to the output, it doesn't get stupidly slow because lots of ErrorRecords with Exceptions inside with bloody stack traces inside them... (and putting an enormous strain on the GC, exceptions are meant to be exceptional, not a container)\r\n\r\n\r\n<blockquote><img src=\"https://opengraph.githubassets.com/4cb2831ead6372268b67a933229de825b7c82f78debec3fddde5800f78da7a4a/PowerShell/Crescendo\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/PowerShell/Crescendo\">PowerShell/Crescendo</a></strong></div><div>a module for wrapping native applications in a PowerShell function and module - PowerShell/Crescendo</div></blockquote>",
      "created_at": "2021-07-02T17:58:45Z",
      "updated_at": "2021-07-02T18:02:56Z"
    },
    {
      "author": "Luiz-Monad",
      "author_association": "NONE",
      "body": "> (I'm personally skeptical about it. It's extremely surprising that PowerShell doesn't do what it should and we need to learn yet another convoluted module just to run an application.) \r\n\r\nI'm not so surprised by that, I kind of hate command line integrations between programs, seriously, calling a program by the command line and passing arguments as an array of strings that need to be parsed... \r\nPerhaps some kind of `Intent` for doing IPC, though the `Binder`, like Android does, but that's on operating systems, not shells. We can't blame Powershell too much for it.\r\nAny \"new\" kind of shell will have to deal with this bullshit one way or another.\r\n\r\nBut I agree with you that a tool like Crescendo for parsing metadata and making all command line tools have a standardized interface is absolutely needed, it should be a *core* module and very solid with the most used software, like `git`, or `cmake` in my case.\r\n\r\nPerhaps this Unix idea of everything being a text was not a good idea at all, powershell was supposed to solve that, it kind of does if you only use cmdlets... \r\nSo the next very best thing is actually automatically generating those cmdlets. \r\n",
      "created_at": "2021-07-02T18:07:56Z",
      "updated_at": "2021-07-02T18:11:59Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> Perhaps this Unix idea of everything being a text was not a good idea at all, powershell was supposed to solve that, it kind of does if you only use cmdlets...\r\n\r\nThat idea has been superseded by the desktop bus.\r\n\r\n",
      "created_at": "2021-07-02T18:53:34Z",
      "updated_at": "2021-07-02T18:53:34Z"
    }
  ],
  "created_at": "2020-06-30T20:53:26Z",
  "number": 13068,
  "state": "open",
  "title": "Call native operator",
  "updated_at": "2022-01-07T20:42:08Z"
}