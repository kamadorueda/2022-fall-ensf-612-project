{
  "_url": "https://github.com/PowerShell/PowerShell/issues/7975",
  "author": "mklement0",
  "body": "Note:\r\n* Should this suggestion gain traction, an RFC is presumably needed.\r\n* By _list string_ I mean a single string composed of items (tokens) separated by a separator, such as you would find in ` $env:PATH`, which contains a list of directories.\r\n* This suggestion is in part motivated by wanting a platform-independent mechanism for manipulating environment variables such as `$env:PATH` safely and conveniently - see #5340 and \r\nhttps://github.com/PowerShell/PowerShell-RFC/pull/92\r\n\r\nManipulating such lists with text parsing is cumbersome, error-prone, and sometimes requires platform-specific separators, so a dedicated cmdlet, say `Update-ListString` (name negotiable) could ease the burden, by offering the following operations, with support for adding/removing _arrays_ of items:\r\n\r\n* adding items:\r\n   * prepend (`-Prepend`)\r\n   * append (`-Append`)\r\n   * insert before or after a given item  (`-InsertBefore` / `-InsertAfter`) - same as `-Append`, if the item doesn't exist\r\n* replacing items:\r\n  * by name (item string) of an existing item (`-Replace`)  - same as `-Append`, if the item doesn't exist.\r\n* removing items:\r\n  * by name (item string) (`-Remove`)\r\n  * removing duplicate items on request (`-RemoveDuplicate`), keeping only the first occurrence\r\n  * remove empty items (duplicate separators) on request (`-RemoveEmpty`)\r\n\r\nOperations should be idempotent by default (desired-state logic):\r\n   * on adding, quietly do nothing if the item(s) already exist\r\n   * on removing, ignore the case where item(s) don't exist\r\n\r\nWith `-Force`, _add_ operations should enforce the specified position - `-Prepend`, `-Append`, `-InsertAt`, `-InsertBefore/After` - by moving a preexisting item accordingly.\r\n\r\nSeparators can either be specified:\r\n\r\n* freely, as a regex (as you would pass to `-split`), with `-Separator` \r\n* or  via switch `-AsDirList` (name negotiable), in which case `[IO.Path]::PathSeparator` is used, representing the platform-appropriate separator used to separate entries in `$env:PATH` (and similar variables such as `$env:CLASSPATH`).\r\n\r\nOpen questions:\r\n\r\n* Is it necessary to also support _by-index_ operations (`-InsertAt`, `-RemoveAt`, `-ReplaceAt`)? Conceivably, this could be added later.\r\n* How should _escaping_ of separators embedded in items be handled? The simplest case would be to simply _disallow_ embedded separators in items (assume that existing items don't have embedded separators, and report an error on trying to set items containing them). Conceivably, support for escaping could be added later via an `-EscapeChar` parameter.\r\n\r\nExamples:\r\n\r\n```powershell\r\n# WISHFUL THINKING\r\n\r\nPS> Update-ListString -Separator ';' 'a;b;c' -Append 'd', 'e'\r\na;b;c;d;e\r\n\r\nPS> Update-ListString -Separator ';' 'a;b;c' -Prepend 'd'\r\nd;a;b;c\r\n\r\nPS> Update-ListString -Separator ';' 'a;b;c;d' -Remove 'd', 'b'\r\na;c\r\n\r\nPS> Update-ListString -Separator ';' 'a;;c' -RemoveEmpty\r\na;c\r\n\r\nPS> Update-ListString -Separator ';' 'a;b;a;c' -RemoveDuplicate\r\na;b;c\r\n\r\nPS> Update-ListString -Separator ';' 'a;b;c' -Replace 'b', 'd'\r\na;d;c\r\n\r\n# No-op, if entry already present\r\nPS> Update-ListString -Separator ';' 'a;b;c' -Append 'b'\r\na;b;c\r\n\r\n# Enforce specified position\r\nPS> Update-ListString -Separator ';' 'a;b;c' -Append 'b' -Force\r\na;c;b\r\n```\r\n\r\nEnvironment data\r\n----------------\r\n\r\nWritten as of:\r\n\r\n```powershell\r\nPowerShell Core 6.1.0\r\n```\r\n",
  "closed_at": "2018-10-09T01:37:47Z",
  "comments": [
    {
      "author": "HumanEquivalentUnit",
      "author_association": "CONTRIBUTOR",
      "body": "You've given it a general name, but the behaviour seems very specific to \"`$PATH` variable\". Are there any other use cases anyone can come up with (not counting CLASSPATH, but outside the world of environment variables for lists of paths)?\r\n\r\nYou provisionally call it `Update-ListString`, but lists in PS (Arrays, ArrayLists and Generic.Lists) don't have operations exactly comparable to this; no InsertBefore or InsertAfter, no RemoveDuplicates. And where we do have types with comparable operations, they don't behave like these described operations do. So that name feels a bit misleading. \r\n\r\n`ArrayList.Replace()` does not append to the list in situations where the item is not found, string replace `\"words here\".Replace('test', 'potato')` does not produce `\"words here potato\"` (I wouldn't guess that 'replace' also doubled as 'Append').\r\n\r\nArrayList and Generic List have a `Remove()` method which takes out the first occurrence, and leaves the rest. If you filter a list for unique items with `Select-Unique`, then you keep the first entry and remove the subsequent ones. Your cmdlet matches this behaviour - but is that right? If I want to get rid of Java and I `-Remove 'c:\\program files\\java\\bin'` then the `-Remove` will get rid of one entry but leave possible duplicates, and `-RemoveDuplicates` will get rid of duplicates and leave one. In order to get rid of Java completely, if I don't know whether there are duplicates or not, must I run the cmdlet twice? Once to RemoveDuplicates and then again to Remove the remaining entry?\r\n\r\nThen what happens if I have two entries for Java and I `-InsertBefore`, does it get inserted twice, once for each duplicate? If it's specific for PATH variables it should probably go before the first one only, but if it's a general \"ListString\" concept, should it go before every instance? Similarly, what if I `-Replace` a duplicate entry, does that replace both duplicates? I guess it would have to in order to make sense, but then I intuit that `-Remove` has `-RemoveDuplicates` so `-Replace` should have a matching `-ReplaceDuplicates`.\r\n\r\nArrayLists and Generic Lists have `Insert(index, value)` so they don't need an `InsertAt` method, but your description here is strange:\r\n\r\n> With -Force, add operations should enforce the specified position - -Prepend, -Append, -InsertAt, -InsertBefore/After - by moving a preexisting item accordingly.\r\n\r\nIf I try to prepend, how could it ever fail such that I need to -Force it? If I try to insert at position 10 but there's only 3 things in the list, what does forcing it do? Make 7 blank entries in between? If I try to insert at position 2 and I don't force it, it has to move the following items +1 index in order to work normally, so in what situation might I need to -Force it, and what would be different?\r\n\r\n>  (-InsertBefore / -InsertAfter) - same as -Append, if the item doesn't exist\r\n\r\nIf I'm giving instructions based on my assumption that something will exist, but it doesn't exist, should that really be \"make the change somewhere else instead\", or should it really be an error?\r\n\r\n\r\nI'm not against the idea overall, but it feels tailored to the behaviours which makes sense for environment variables full of paths, and not \"Lists\" in string form. Escaping rules are likely to also be specific to environment variables. Unless there are other use cases, I think I'd prefer if that specific nature was reflected in whatever name it ends up with.",
      "created_at": "2018-10-08T23:44:48Z",
      "updated_at": "2018-10-08T23:48:59Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "I think the 90%+ use case is to manage environment variables.  Plus there is already a separate need to surface the `[System.Environment]::Get/SetEnvironmentVariable` methods as cmdlets.  I think it makes a lot of sense to create `PathVariable` management commands as part of that effort as described in https://github.com/PowerShell/PowerShell-RFC/pull/92",
      "created_at": "2018-10-09T01:00:33Z",
      "updated_at": "2018-10-09T01:00:33Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Yes, managing `$env:PATH`-like variables was definitely the motivation for this proposal.\r\n\r\nI can currently think of only `$env:PATH`, `$env:CLASSPATH` and `$env:PATHEXT` (Windows only), and for the latter use of a cmdlet is probably overkill.\r\n\r\nI was hoping it would generalize to other use cases where a list of items must be kept _inside a string_, but perhaps that's too rare a use case to worry about.\r\n\r\nI can now see how one/multiple `*-PathVariable` cmdlets - that optionally allow a variable of a different name to be targeted - is probably the better solution, so I'll close this.\r\n\r\n---\r\n\r\nIt is now a moot point, but as for your concerns, @HumanEquivalentUnit:\r\n\r\nI specifically chose the noun \"ListString\" to avoid confusion with .NET list types - comparing their methods with what I'm proposing should not enter the picture.\r\n\r\nThe guiding principle for the suggested operations was desired-state logic, which, for instance, means that something targeted is _allowed_ not to exist, with reasonable fallback behavior.\r\n\r\nTo address one question of yours as an example:\r\n\r\n> If I try to prepend, how could it ever fail such that I need to `-Force` it?\r\n\r\nIt couldn't _fail_, but the suggested default behavior was to leave a preexisting item alone, irrespective of its current position; `-Force` would then be needed to force moving it to the beginning.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2018-10-09T01:37:47Z",
      "updated_at": "2018-10-09T01:44:08Z"
    }
  ],
  "created_at": "2018-10-08T20:01:59Z",
  "labels": [
    "Issue-Discussion",
    "Resolution-Answered"
  ],
  "number": 7975,
  "state": "closed",
  "title": "Introduce a cmdlet for manipulation of list strings",
  "updated_at": "2018-10-30T05:54:17Z"
}