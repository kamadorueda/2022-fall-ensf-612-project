{
  "_url": "https://github.com/PowerShell/PowerShell/issues/11032",
  "author": "iSazonov",
  "body": "<!-- Anything that looks like this is a comment and can't be seen after the Pull Request is created. -->\r\n\r\n# PR Summary\r\n\r\nResolve #9488\r\n\r\nAdd a native dll resolver to discover and load native dlls based on OS platform and architecture.\r\n\r\n## PR Context\r\n\r\nReleated #3091\r\n\r\nIf a managed dll has native dependencies the handler will try to find these native dlls.\r\n    1. Gets the managed.dll location (folder)\r\n    2. Based on OS name and architecture name builds subfolder name where it is expected the native dll resides:\r\n    3. Loads the native dll\r\n\r\n        ///     managed.dll folder\r\n        ///                     |\r\n        ///                     |--- 'win-x64' subfolder\r\n        ///                     |       |--- native.dll\r\n        ///                     |\r\n        ///                     |--- 'win-x86' subfolder\r\n        ///                     |       |--- native.dll\r\n        ///                     |\r\n        ///                     |--- 'win-arm' subfolder\r\n        ///                     |       |--- native.dll\r\n        ///                     |\r\n        ///                     |--- 'win-arm64' subfolder\r\n        ///                     |       |--- native.dll\r\n        ///                     |\r\n        ///                     |--- 'linux-x64' subfolder\r\n        ///                     |       |--- native.so\r\n        ///                     |\r\n        ///                     |--- 'linux-x86' subfolder\r\n        ///                     |       |--- native.so\r\n        ///                     |\r\n        ///                     |--- 'linux-arm' subfolder\r\n        ///                     |       |--- native.so\r\n        ///                     |\r\n        ///                     |--- 'linux-arm64' subfolder\r\n        ///                     |       |--- native.so\r\n        ///                     |\r\n        ///                     |--- 'osx-x64' subfolder\r\n        ///                     |       |--- native.dylib\r\n\r\n## PR Checklist\r\n\r\n- [x] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [x] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [ ] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` or `[ WIP ]` to the beginning of the title (the `WIP` bot will keep its status check at `Pending` while the prefix is present) and remove the prefix when the PR is ready.\r\n- **[Breaking changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)**\r\n    - [x] None\r\n    - **OR**\r\n    - [ ] [Experimental feature(s) needed](https://github.com/MicrosoftDocs/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/About/about_Experimental_Features.md)\r\n        - [ ] Experimental feature name(s): <!-- Experimental feature name(s) here -->\r\n- **User-facing changes**\r\n    - [x] Not Applicable\r\n    - **OR**\r\n    - [x] [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [x] Issue filed: https://github.com/MicrosoftDocs/PowerShell-Docs/issues/5196\r\n- **Testing - New and feature**\r\n    - [x] N/A or can only be tested interactively\r\n    - **OR**\r\n    - [ ] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n- **Tooling**\r\n    - [ ] I have considered the user experience from a tooling perspective and don't believe tooling will be impacted.\r\n    - **OR**\r\n    - [ ] I have considered the user experience from a tooling perspective and enumerated concerns in the summary. This may include:\r\n        - Impact on [PowerShell Editor Services](https://github.com/PowerShell/PowerShellEditorServices) which is used in the [PowerShell extension](https://github.com/PowerShell/vscode-powershell) for VSCode (which runs in a different PS Host).\r\n        - Impact on Completions (both in the console and in editors) - one of PowerShell's most powerful features.\r\n        - Impact on [PSScriptAnalyzer](https://github.com/PowerShell/PSScriptAnalyzer) (which provides linting & formatting in the editor extensions).\r\n        - Impact on [EditorSyntax](https://github.com/PowerShell/EditorSyntax) (which provides syntax highlighting with in VSCode, GitHub, and many other editors).\r\n",
  "closed_at": "2019-12-09T20:03:54Z",
  "comments": [
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "This looks super promising, wow! Nice work! :heart_eyes: \r\n\r\nI have one suggestion just for compatibility; prior to 6.2 (or 6.1? Don't recall exactly) pwsh was able to search the location the library was in for native DLLs (though not subfolders). As part of one of the changes in 6.2, that was removed, and this seems like a sensible place to add it.\r\n\r\nCan we have it also check the same folder as the managed library so that anything that was using the old behaviour works again as well?",
      "created_at": "2019-11-11T11:07:09Z",
      "updated_at": "2019-11-11T11:07:09Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Can we have it also check the same folder as the managed library so that anything that was using the old behaviour works again as well?\r\n\r\nYes, we can. I think first we need to have a standard (RFC?) how we search, order is important. Also we should consider security compliance.",
      "created_at": "2019-11-11T12:35:06Z",
      "updated_at": "2019-11-11T12:35:06Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "/cc @PaulHigin @SteveL-MSFT ",
      "created_at": "2019-11-11T12:54:12Z",
      "updated_at": "2019-11-11T12:55:09Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@iSazonov we may want to look into whether there's a way to pull the acceptable RIDs from `dotnet` / if this is available from a .NET API rather than having a hardcoded set here. \ud83d\ude42 ",
      "created_at": "2019-11-11T15:04:25Z",
      "updated_at": "2019-11-11T15:04:25Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@vexx32 .Net Core has not API to expose RIDs. \r\nWe could support all RIDs from https://docs.microsoft.com/en-us/dotnet/core/rid-catalog\r\nbut it will very complicate the resolver.\r\nI hope the proposed solution covers most of use cases. Notice, that key here is that we calculate path based on managed assembly location: if the assembly is right assembly for OS, arch, runtime then we expect that native assembly also is right assembly and is in right place. I hope other scenarios is edge cases that we could delegate third-party  project developers who could use [DllImportResolver callbacks](https://github.com/dotnet/corefx/issues/32015) directly.\n\n<blockquote><img src=\"https://docs.microsoft.com/en-us/media/logos/logo-ms-social.png\" width=\"48\" align=\"right\"><div><strong><a href=\"https://docs.microsoft.com/en-us/dotnet/core/rid-catalog\">.NET Core Runtime IDentifier (RID) catalog</a></strong></div><div>Learn about the Runtime IDentifier (RID) and how RIDs are used in .NET Core.</div></blockquote>",
      "created_at": "2019-11-11T15:36:47Z",
      "updated_at": "2019-11-11T15:36:49Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@iSazonov yeah I wondered. The reason I ask is that some RIDs include OS version as well as architecture, so we might be missing (for example) a folder with `win7-x64` quite easily. Perhaps we could for the moment solve that problem with use of wildcards?",
      "created_at": "2019-11-11T15:56:02Z",
      "updated_at": "2019-11-11T15:56:18Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "It makes sense to follow the .NET RID hierarchy so that it's consistent and predictable.  It doesn't have to be an exact match, but I can image build scripts that create the native folder under the RID passed to msbuild.  So for macOS, you're just as likely to see `osx-x64` folder.",
      "created_at": "2019-11-11T16:38:53Z",
      "updated_at": "2019-11-11T16:38:53Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Will replace \"osx\" with \"osx-x64\".",
      "created_at": "2019-11-11T17:28:30Z",
      "updated_at": "2019-11-11T17:28:30Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": ">  The reason I ask is that some RIDs include OS version as well as architecture, so we might be missing (for example) a folder with win7-x64 quite easily. Perhaps we could for the moment solve that problem with use of wildcards?\r\n\r\nIt is just a case I name as \"edge\". Very unlikely to be needed. I believe any developer prefer to create portable solutions.\r\nAlso Core does not have a reliable way to determine OS/kernel version.\r\nSo I suggest only use portable RIDs. At least until we get feedback.\r\n",
      "created_at": "2019-11-11T17:39:46Z",
      "updated_at": "2019-11-11T17:39:46Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "\ud83e\udd14 along with this, would it perhaps be feasible to expose a public API to allow module authors to add specific paths to search when working in those edge cases?\r\n\r\n(maybe that's a future discussion \ud83d\ude06)",
      "created_at": "2019-11-11T17:50:23Z",
      "updated_at": "2019-11-11T17:50:43Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> to expose a public API\r\n\r\nThe API is already in .Net Core. See DllImportResolver callbacks reference above. I guess it is possible to use even script delegate for the callback.",
      "created_at": "2019-11-12T03:02:37Z",
      "updated_at": "2019-11-12T03:02:37Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@daxian-dbw _Negative_ test is useless (it failed in any case).  I added _positive_ test but I haven't possibilities to debug and fix it for Linux and MacOs. :-(",
      "created_at": "2019-11-22T09:12:15Z",
      "updated_at": "2019-11-22T09:12:15Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> Negative test is useless (it failed in any case).\r\n\r\nIt's supposed to fail and the test is to check for the exception type, expecting `BadImageFormatException`. Can you elaborate why it was not working?",
      "created_at": "2019-11-22T19:10:13Z",
      "updated_at": "2019-11-22T19:10:13Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> It's supposed to fail and the test is to check for the exception type, expecting BadImageFormatException. Can you elaborate why it was not working?\r\n\r\nWhat if a bug is to load windows dll on Linux?",
      "created_at": "2019-11-22T19:46:52Z",
      "updated_at": "2019-11-22T19:46:52Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> What if a bug is to load windows dll on Linux?\r\n\r\nYou can create the folder structure in a way to make this impossible. For example, say you create the managed dll using `Add-Type` and put it at `temp\\test`, then on x64 Windows, you only create `temp\\test\\win-x64` folder and create a dummy `native.dll` in that folder; on x64 Linux, you only create `temp/test/linux-x64` folder and create a dummy `native.so` in it. Similarly, you only create the folder that is supposed to be found by your resolution code on other corresponding platforms, so you will get either `BadImageFormatException` when the resolution succeeds, or `DllNotFoundException` when the resolution fails.",
      "created_at": "2019-11-22T21:27:18Z",
      "updated_at": "2019-11-22T21:59:04Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@daxian-dbw I added new test as you ask but it fail too.",
      "created_at": "2019-11-23T18:11:10Z",
      "updated_at": "2019-11-23T18:11:10Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "There are 2 failures in both macOS and Linux, the first one is your positive test, which I don't know why it failed.\r\nThe second one is because on Linux and macOS, all failures of loading the native library get wrapped to the `DllNotFoundException`. The difference is in the message:\r\n\r\n### Linux\r\n\r\n> Message        : Unable to load shared library '/home/dongbo/temp/blah.so' or one of its dependencies. In order to help diagnose loading problems, consider setting the LD_DEBUG environment variable: **/home/dongbo/temp/blah.so: file too short**\r\n> Message        : Unable to load shared library '/home/dongbo/temp/abc.so' or one of its dependencies. In order to help diagnose loading problems, consider setting the LD_DEBUG environment variable: **/home/dongbo/temp/abc.so: cannot open shared object file: No such file or directory**\r\n\r\n### macOS\r\n\r\n```\r\nPS:1> [System.Runtime.InteropServices.NativeLibrary]::Load(\"/Users/dongbow/tmp/blah.dylib\")\r\nException calling \"Load\" with \"1\" argument(s): \"Unable to load shared library '/Users/dongbow/tmp/blah.dylib' or one of its dependencies. In order to help diagnose loading problems, consider setting the DYLD_PRINT_LIBRARIES environment variable: dlopen(/Users/dongbow/tmp/blah.dylib, 1): no suitable image found.  Did find:\r\n\t/Users/dongbow/tmp/blah.dylib: file too short\r\n\t/Users/dongbow/tmp/blah.dylib: stat() failed with errno=203\"\r\n\r\nPS:2> [System.Runtime.InteropServices.NativeLibrary]::Load(\"/Users/dongbow/tmp/bbb.dylib\") \r\nException calling \"Load\" with \"1\" argument(s): \"Unable to load shared library '/Users/dongbow/tmp/bbb.dylib' or one of its dependencies. In order to help diagnose loading problems, consider setting the DYLD_PRINT_LIBRARIES environment variable: dlopen(/Users/dongbow/tmp/bbb.dylib, 1): image not found\"\r\n```\r\n\r\n--------------------------------------------------------------------------------\r\n\r\nI prefer to not check in binary files for testing, so I still suggest to use loading failure message to tell if the native library resolution succeeds. But we will have to write code for each platform instead of relying on the `BadImageFormatException`.\r\nOn windows, we can still check for `BadImageFormatException`. On Linux and macOS, we have to check for the exception message.",
      "created_at": "2019-11-26T19:28:46Z",
      "updated_at": "2019-11-26T19:33:20Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> There are 2 failures in both macOS and Linux, the first one is your positive test, which I don't know why it failed.\r\n\r\nI tried on WSL and I see SkiaSharp has a dependency on `fontconfig`  package.",
      "created_at": "2019-11-27T05:36:09Z",
      "updated_at": "2019-11-27T05:36:09Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@daxian-dbw After some experiments I found a trick to make the test being positive without adding new binaries. ",
      "created_at": "2019-11-27T14:06:30Z",
      "updated_at": "2019-11-27T14:06:30Z"
    },
    {
      "author": "TravisEz13",
      "author_association": "MEMBER",
      "body": "@iSazonov Please don't use 7.0-consider for PRs... I'll try to update the descriptions to say which milestones are for issues and which are for PRs.",
      "created_at": "2019-12-03T19:34:51Z",
      "updated_at": "2019-12-03T19:34:51Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Added a reference to new doc issue.",
      "created_at": "2019-12-06T05:22:38Z",
      "updated_at": "2019-12-06T05:22:38Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": ":tada:`v7.0.0-rc.1` has been released which incorporates this pull request.:tada:\n\nHandy links:\n* [Release Notes](https://github.com/PowerShell/PowerShell/releases/tag/v7.0.0-rc.1)\n",
      "created_at": "2019-12-16T21:37:40Z",
      "updated_at": "2019-12-16T21:37:40Z"
    }
  ],
  "created_at": "2019-11-11T09:56:09Z",
  "number": 11032,
  "state": "closed",
  "title": "Add native dll resolver",
  "updated_at": "2020-01-10T23:21:11Z"
}