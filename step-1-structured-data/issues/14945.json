{
  "_url": "https://github.com/PowerShell/PowerShell/issues/14945",
  "author": "jborean93",
  "body": "The `$OutputEncoding` preference variable is not the same as the `[Console]::InputEncoding` value. This can lead to a poor UX with the defaults as they are meant to be closely aligned.\r\n\r\nWindows PowerShell is also affected byt this but in a different way. In Windows PowerShell `$OutputEncoding` is strict ASCII and `[Console]::InputEncoding` is aligned to the system default settings. Pure ASCII characters are fine but anything beyond the 7-bit range will become `?` when piped into a native application.\r\n\r\n## Steps to reproduce\r\n\r\nThe simplest way to reproduce this is if you have Python 3 installed.\r\n\r\n```powershell\r\n'caf\u00e9' | python.exe -c \"import sys; data = sys.stdin.read(); print(data)\"\r\n```\r\n\r\nIf you don't have Python 3 installed then you can use the following PowerShell script\r\n\r\n\r\n```powershell\r\n[CmdletBinding()]\r\nparam (\r\n    [Parameter(Mandatory)]\r\n    [string]\r\n    $Path,  # The file the script should write the raw stdin bytes to.\r\n\r\n    [Parameter(Mandatory)]\r\n    [string]\r\n    $OutputData,  # Base64 encoded bytes that the script should output to the stdout pipe.\r\n    \r\n    # Raw = raw FileStream read and write with bytes\r\n    # .NET = [Console]::Read and [Console]::Write ($Path and $OutputData are treated as UTF-8)\r\n    [Parameter()]\r\n    [ValidateSet('Raw', '.NET')]\r\n    [string]\r\n    $Method = 'Raw',\r\n\r\n    [int]\r\n    $InputCodepage = $null,\r\n\r\n    [int]\r\n    $OutputCodepage = $null\r\n)\r\n\r\nAdd-Type -TypeDefinition @'\r\nusing Microsoft.Win32.SafeHandles;\r\nusing System;\r\nusing System.Runtime.InteropServices;\r\n\r\nnamespace RawConsole\r\n{\r\n    public class NativeMethods\r\n    {\r\n        [DllImport(\"Kernel32.dll\")]\r\n        public static extern int GetConsoleCP();\r\n\r\n        [DllImport(\"Kernel32.dll\")]\r\n        public static extern int GetConsoleOutputCP();\r\n\r\n        [DllImport(\"Kernel32.dll\")]\r\n        public static extern SafeFileHandle GetStdHandle(\r\n            int nStdHandle);\r\n\r\n        [DllImport(\"Kernel32.dll\")]\r\n        public static extern bool SetConsoleCP(\r\n            int wCodePageID);\r\n\r\n        [DllImport(\"Kernel32.dll\")]\r\n        public static extern bool SetConsoleOutputCP(\r\n            int wCodePageID);\r\n    }\r\n}\r\n'@\r\n\r\n$origInputCP = [RawConsole.NativeMethods]::GetConsoleCP()\r\n$origOutputCP = [RawConsole.NativeMethods]::GetConsoleOutputCP()\r\n\r\nif ($InputCodepage) {\r\n    [void][RawConsole.NativeMethods]::SetConsoleCP($InputCodepage)\r\n}\r\nif ($OutputCodepage) {\r\n    [void][RawConsole.NativeMethods]::SetConsoleOutputCP($OutputCodepage)\r\n}\r\n\r\ntry {    \r\n    $outputBytes = [Convert]::FromBase64String($OutputData)\r\n    $utf8NoBom = [Text.UTF8Encoding]::new($false)\r\n    \r\n    if ($Method -eq 'Raw') {\r\n        $stdinHandle = [RawConsole.NativeMethods]::GetStdHandle(-10)\r\n        $stdinFS = [IO.FileStream]::new($stdinHandle, 'Read')\r\n    \r\n        $stdoutHandle = [RawConsole.NativeMethods]::GetStdHandle(-11)\r\n        $stdoutFS = [IO.FileStream]::new($stdoutHandle, 'Write')\r\n    \r\n        $inputRaw = [byte[]]::new(1024)\r\n        $inputRead = $stdinFS.Read($inputRaw, 0, $inputRaw.Length)\r\n        $outputFS = [IO.File]::Create($Path)\r\n        $outputFS.Write($inputRaw, 0, $inputRead)\r\n        $outputFS.Dispose()\r\n        \r\n        $stdoutFS.Write($outputBytes, 0, $outputBytes.Length)\r\n    \r\n        $stdinFS.Dispose()\r\n        $stdinHandle.Dispose()\r\n        \r\n        $stdoutFS.Dispose()\r\n        $stdoutHandle.Dispose()\r\n    }\r\n    elseif ($Method -eq '.NET') {\r\n        $inputRaw = [Text.StringBuilder]::new()\r\n        while ($true) {\r\n            $char = [Console]::Read()\r\n            if ($char -eq -1) {\r\n                break\r\n            }\r\n    \r\n            [void]$inputRaw.Append([char]$char)\r\n        }\r\n        [IO.File]::WriteAllText($Path, $inputRaw.ToString(), $utf8NoBom)\r\n    \r\n        $outputString = $utf8NoBom.GetString($outputBytes)\r\n        [Console]::Write($outputString)\r\n    }    \r\n}\r\nfinally {\r\n    [void][RawConsole.NativeMethods]::SetConsoleCP($origInputCP)\r\n    [void][RawConsole.NativeMethods]::SetConsoleOutputCP($origOutputCP)\r\n}\r\n```\r\n\r\nCall it like\r\n\r\n```powershell\r\n$string = 'caf\u00e9'\r\n$stringBytes = [Text.UTF8Encoding]::new($false).GetBytes($string)\r\n$stringB64 = [Convert]::ToBase64String($stringBytes)\r\n\r\n$null = $string | powershell.exe -NoLogo -File proc_io.ps1 -Path input -OutputData $stringB64 -Method .NET\r\n\r\nFormat-Hex -Path input\r\n```\r\n\r\n## Expected behavior\r\n\r\nFor Python I expect `caf\u00e9` to be returned back\r\n\r\nFor the manual PowerShell script I expect the `input` file to contains `caf\u00e9` as a UTF-8 encoded string.\r\n\r\n```none\r\n   Label: C:\\temp\\input\r\n\r\n          Offset Bytes                                           Ascii\r\n                 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\r\n          ------ ----------------------------------------------- -----\r\n0000000000000000 63 61 66 C3 A9 0D 0A                            caf\u00c3\u00a9\ufffd\ufffd\r\n```\r\n\r\n## Actual behavior\r\n\r\nFor Python\r\n\r\n```none\r\n# Windows PowerShell\r\ncaf?\r\n\r\n# PowerShell\r\ncaf\u00c3\u00a9\r\n```\r\n\r\nThis is because the `$string = 'caf\u00e9` is encoded using the value of `$OutputEncoding` when sent to the process' stdin but the native process is using the default console input codepage (437 in my case).\r\n\r\nFor the PowerShell script\r\n\r\n```none\r\n# Windows PowerShell\r\n\r\n           Path: C:\\temp\\input\r\n\r\n           00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\r\n\r\n00000000   63 61 66 3F 3F 0D 0A                             caf??..\r\n\r\n# PowerShell\r\n\r\n   Label: C:\\temp\\input\r\n\r\n          Offset Bytes                                           Ascii\r\n                 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\r\n          ------ ----------------------------------------------- -----\r\n0000000000000000 63 61 66 E2 94 9C E2 8C 90 0D 0A                caf\u00e2\ufffd\ufffd\u00e2\ufffd\ufffd\ufffd\ufffd\r\n```\r\n\r\nSame problem here, .NET is reading the stdin based on the value of the console's input codepage which does not match up with `$OutputEncoding`. The only reason why there's a difference is because Windows PowerShell is using ASCII and so the `\u00e9` is being converted to `?`.\r\n\r\n## Environment data\r\n\r\n```none\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.1.0\r\nPSEdition                      Core\r\nGitCommitId                    7.1.0\r\nOS                             Microsoft Windows 10.0.17763\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n\r\n## Other info\r\n\r\nI'm currently trying to wrap my head around the behaviour with encoding and talking to native processes in PowerShell and this particular issue has come up. I'm not sure if we can change the default behaviour but I'm hoping to start a conversation as to why `$OutputEncoding` was changed to utf-8 on Windows. For Linux I understand but I feel like on Windows this should stay as the console's input codepage for better compatibility with other cmdline programs.",
  "closed_at": null,
  "comments": [
    {
      "author": "237dmitry",
      "author_association": "NONE",
      "body": "> The $OutputEncoding preference variable is not the same as the [Console]::InputEncoding value. \r\n\r\nNot at once understood in which difference\r\n```\r\n > Compare-Object ($OutputEncoding) ([Console]::InputEncoding)\r\n\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\nSystem.Text.UTF8Encoding+UTF8EncodingSealed =>\r\nSystem.Text.UTF8Encoding                    <=\r\n```\r\nAt first glance, everything is the same\r\n```\r\n > $OutputEncoding; [Console]::InputEncoding               \r\n                                                           \r\nPreamble          :                                        \r\nBodyName          : utf-8                                  \r\nEncodingName      : Unicode (UTF-8)                        \r\nHeaderName        : utf-8                                  \r\nWebName           : utf-8                                  \r\nWindowsCodePage   : 1200                                   \r\nIsBrowserDisplay  : True                                   \r\nIsBrowserSave     : True                                   \r\nIsMailNewsDisplay : True                                   \r\nIsMailNewsSave    : True                                   \r\nIsSingleByte      : False                                  \r\nEncoderFallback   : System.Text.EncoderReplacementFallback \r\nDecoderFallback   : System.Text.DecoderReplacementFallback \r\nIsReadOnly        : True                                   \r\nCodePage          : 65001                                  \r\n                                                           \r\nPreamble          :                                        \r\nBodyName          : utf-8                                  \r\nEncodingName      : Unicode (UTF-8)                        \r\nHeaderName        : utf-8                                  \r\nWebName           : utf-8                                  \r\nWindowsCodePage   : 1200                                   \r\nIsBrowserDisplay  : True                                   \r\nIsBrowserSave     : True                                   \r\nIsMailNewsDisplay : True                                   \r\nIsMailNewsSave    : True                                   \r\nIsSingleByte      : False                                  \r\nEncoderFallback   : System.Text.EncoderReplacementFallback \r\nDecoderFallback   : System.Text.DecoderReplacementFallback \r\nIsReadOnly        : True                                   \r\nCodePage          : 65001                                  \r\n```",
      "created_at": "2021-03-05T10:14:56Z",
      "updated_at": "2021-03-05T10:14:56Z"
    },
    {
      "author": "237dmitry",
      "author_association": "NONE",
      "body": "```\r\n > \"caf\u00e9\"               \r\ncaf\u00e9                    \r\n\r\n > \"caf\u00e9\" | Write-Output\r\ncaf\u00e9\r\n                    \r\n > \"caf\u00e9\" | Out-Host    \r\ncaf\u00e9                    \r\n\r\n > [int[]][char[]]\"caf\u00e9\"\r\n99                      \r\n97                      \r\n102                     \r\n233                     \r\n\r\n > [char]233            \r\n\u00e9                       \r\n```\r\n\r\n```\r\n > \"caf\u00e9\" | sc caf\u00e9.txt                                                  \r\n > Format-Hex -Path .\\caf\u00e9.txt                                           \r\n                                                                         \r\n   Label: C:\\Users\\herz\\Desktop\\caf\u00e9.txt                                 \r\n                                                                         \r\n          Offset Bytes                                           Ascii   \r\n                 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F         \r\n          ------ ----------------------------------------------- -----   \r\n0000000000000000 63 61 66 C3 A9 0D 0A                            caf\u00c3\u00a9\ufffd\ufffd \r\n                                                                         \r\n```\r\n???",
      "created_at": "2021-03-05T10:48:21Z",
      "updated_at": "2021-03-05T10:57:46Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "Just to clear up a few thing, the `$OutputEncoding` in PowerShell now defaults to UTF-8 but the `[Console]::InputEncoding` is dependent on a few other factors. Depending on your OS setup, or where you run PowerShell, the default value could be UTF-8 but there are cases like mine when that\u2019s not the case. This issue is to figure out whether that\u2019s the correct behaviour, I personally think the 2 variables should align with each other rather than it sometimes be the same or not.\r\n\r\nThe first tests you have with Write-Output are not related to the problem at hand. The issue when the 2 encoding settings differ is how the native application you are piping the data to will not read it as the same string. Using `[int][char]` to get the integer value for the string also does not accurately reflect how it\u2019s represented in UTF-8. Finally your last example with piping data to `sc`, AFAIK that\u2019s just an apis for `Set-Content` so there is no process boundary that replicates the problem at hand. In any case you seem to have UTF-8 as the default input console code page so you won\u2019t be able to replicate the problem.",
      "created_at": "2021-03-05T11:46:52Z",
      "updated_at": "2021-03-05T11:46:52Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "The `$OutputEncoding` preference variable is unfortunate in two respects:\r\n\r\n* In terms of _design_, it only controls _one_ aspect of character encoding - the text _piped to_ native (external) programs.\r\n   * However, it is reasonable to assume that the same encoding is to be used for output _received from_ native programs; obscurely, you currently have to control that via `[Console]::OutputEncoding`.\r\n  * In other words: `$OutputEncoding` would be much more useful (its name notwithstanding) _if it acted like `chcp`_ (which from inside a PowerShell session does _not_ work), by setting `[Console]::InputEncoding` and  `[Console]::OutputEncoding` to the specified encoding (and also using it for piping to native programs, as currently).\r\n  * Alternatively, hypothetical cmdlets such as `Get-ConsoleEncoding`, `Set-ConsoleEncoding` / `Push-ConsoleEncoding` / `Pop-ConsoleEncoding` would help.\r\n\r\n* In terms of _implementation_:\r\n  * It would have made sense to _not predefine_  `[Console]::OutputEncoding` and make it default to the active encoding (active OEM code page), as reflected by `chcp` / in `[Console]::InputEncoding`.\r\n  * That it _is_ predefined and _how_ is problematic: it _differs_ from the default encoding in Windows console / Windows Terminal windows, which is still the legacy OEM code page as determined by the legacy system locale (language for non-Unicode programs):\r\n       * Windows PowerShell: defaulting to ASCII means that any non-ASCII-range characters are invariably _lost_ when you pipe data to native programs (replaced with verbatim `?`), as you demonstrate.\r\n       * PowerShell (Core): defaulting to UTF-8 means that you send UTF-8 data to native programs, even though:\r\n          * Native programs that are Windows-code-page aware will expect the active code page instead.\r\n             * Note: This is normally the active *OEM* code page, as used by `cmd.exe`; Python appears to be doing its own thing for _direct-to-console output_ and uses the active _ANSI_ code page instead; when output is _captured or redirected_, however, it does respect the active _OEM_ code page.\r\n          * Those native programs that _do_ always output UTF-8 (such as Node.js) will by default have their _output misinterpreted_ by PowerShell, which bases its decoding of the output on `[Console]::OutputEncoding` (which by default reflects the active OEM code page).\r\n\r\n---\r\n\r\nAs is so often the case, the question is whether changing `$OutputEncoding` default  and /or behavior is an acceptable change from the perspective of maintaining backward compatibility.\r\n\r\nQuite some time ago, in  #7233, I've proposed letting _PowerShell_ console windows do their own thing and consistently default to UTF-8, which can you emulate manually as follows (this is what a hypothetical `Set-ConsoleEncoding` cmdlet would have to do in principle):\r\n\r\n```powershell\r\n# The `$global:OutputEncoding =` part is only needed in Windows PowerShell\r\n$global:OutputEncoding = [Console]::InputEncoding = [Console]::OutputEncoding = [System.Text.UTF8Encoding]::new()\r\n```\r\n\r\nIn Windows 10 you now have the option of setting the system locale to UTF-8, i.e. to enable _system-wide_ UTF-8 support (`chcp` then reports `65001`, the UTF-8 code page, ditto for the _ANSI_ code page) but this comes with two caveats:\r\n* This has far-reaching consequences: it also changes _Windows PowerShell's_ default behavior; that is, ANSI-encoded files are then no longer interpreted correctly by default; it can also break legacy console applications.\r\n* The feature is still in beta as of this writing.\r\n\r\nSee [this Stack Overflow answer](https://stackoverflow.com/a/57134096/45375) for more information.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2021-03-06T14:39:43Z",
      "updated_at": "2021-03-09T14:45:06Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "There's another factor at play:\r\n\r\n* While it is `[Console]::OutputEncoding` that determines how PowerShell decodes the output from native programs,\r\n\r\n* _no_ decoding is involved if the output is neither captured nor redirected, in which case it goes straight to the display, and, if the program uses the Unicode version of the [`WriteConsole` WinAPI function](https://docs.microsoft.com/en-us/windows/console/writeconsole), the output will _print_ correctly - irrespective of whether there's a potential encoding mismatch.\r\n\r\nIn other words:\r\n\r\n* _Not_ capturing the output may give the mistaken impression that everything works correctly,\r\n\r\n* but if there is a mismatch between the native program's actual output encoding and `[Console]::OutputEncoding`, the results will be incorrect _if captured in a variable or piped / redirected elsewhere_, because a decoding (and potential re-encoding) step is then invariably involved.\r\n\r\n* Python, specifically, further confuses matters by operating on the active _ANSI_ code page rather than the active _OEM_ code page. Only the OEM code page is controlled via `chcp` (outside PowerShell) / `[Console]::InputEncoding` (inside PowerShell).\r\n   * Note the implications: **An all-UTF-8  console will therefore NOT work properly with Python _by default_**, because the OEM-code-page-based settings for the console have no impact on the active ANSI code page; the only **exception is if _system-wide_ UTF-8 support is enabled on Windows 10**, because that sets not just the OEM, but also the ANSI code page to `65001`, the UTF-8 code page.\r\n   * However, you can explicitly **opt-into UTF-8 support** by either setting `$env:PYTHONUTF8 = 1` before calling, or, in v3.7+, by passing option `-X utf8` (case-sensitive!) to `python`.\r\n   \r\n   * As an aside: the ANSI code page is also what _Windows PowerShell_ uses by default for reading its source code and for `Get-Content` / `Set-Content` (whereas the default encoding varies widely across other cmdlets - see [this Stack Overflow answer](https://stackoverflow.com/a/40098904/45375)).\r\n\r\nFor example, using `node`, the Node.js CLI, which _always_ uses UTF-8, irrespective of the active code pages:\r\n\r\n```powershell\r\nPS> node -e \"console.log('e\u00e9')\"\r\ne\u00e9   # PRINTS fine\r\n\r\n# Note: `node` *always* outputs UTF-8\r\nPS> $output = node -e \"console.log('e\u00e9')\"; $output\r\ne\u251c\u2310  # !! Output was MISDECODED, because [Output]::ConsoleEncoding is the active OEM code page's encoding.\r\n```\r\n\r\n",
      "created_at": "2021-03-06T18:35:06Z",
      "updated_at": "2021-03-06T19:47:02Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I've created a helper function  `Debug-NativeInOutput` for diagnosing such problems, which you can install directly [from a Gist](https://gist.github.com/mklement0/eac1f18fbe0fc2798b214229b747e5dd) as follows (I can assure you that doing so is safe, but you should always check):\r\n\r\n```powershell\r\n# Download and define advanced function Debug-NativeInOutput in the current session.\r\nirm https://gist.github.com/mklement0/eac1f18fbe0fc2798b214229b747e5dd/raw/Debug-NativeInOutput.ps1 | iex\r\n```\r\n\r\nHere are the results of running with default settings in PowerShell (Core) on Windows:\r\n\r\n---\r\n\r\n* With the always-UTF8 `node` CLI:\r\n\r\n```powershell\r\n# The command passes stdin through to stdout.\r\n#  * Note: `node` (Node.js) *always* expects and outputs UTF-8\r\nPS> 'e\u00e9' | Debug-NativeInOutput { node -pe \"require('fs').readFileSync(0).toString().trim()\" }\r\nVERBOSE:\r\n# -------------- Character-encoding settings [code pages]:\r\n#\r\n#   [Console]::InputEncoding [Console]::OutputEncoding $OutputEncoding\r\n#   ------------------------ ------------------------- ---------------\r\n#   OEM United States [437]  OEM United States [437]   Unicode (UTF-8) [65001]\r\n#\r\n\r\nCommand                       : 'e\u00e9' |  node -pe \"require('fs').readFileSync(0).toString().trim()\"\r\nDecodedOutput                 : e\u251c\u2310              # !! INCORRECT\r\nDecodedUTF16CodeUnits         : 0x65 0x251c 0x2310\r\nInputUTF16CodeUnits           : 0x65 0xe9\r\nInputAsUTF8Bytes              : 0x65 0xc3 0xa9\r\nInputAsOEMBytes               : 0x65 0xe9\r\nInputAsANSIBytes              : 0x65 0x82\r\nInputMisdecodedFromUTF8AsOEM  : e\u251c\u2310\r\nInputMisdecodedFromUTF8AsANSI : e\u00c3\u00a9\r\n\r\nVERBOSE: # Uncaptured (direct-to-display by default, no decoding involved):\r\ne\u00e9            # !! CORRECT, but only due to printing *straight to the display*\r\nVERBOSE: #\r\n\r\n```\r\n\r\nThe input was sent and received as UTF-8 by `node`, which also output it  as UTF-8:\r\n* This  appeared fine when _printed straight to the display_, \r\n* but when PowerShell _decoded it_, it misinterpreted the UTF-8 byte output as _OEM_-encoded, based on the default `[Console]::OutputEncoding` value, as `e\u251c\u2310`\r\n\r\nThe solution is to set `[Console]::OutputEncoding` (and `[Console]::InputEncoding`) to UTF-8 before running the command (`$OutputEncoding` already defaults to that):\r\n\r\n```powershell\r\n$OutputEncoding = [Console]::InputEncoding = [Console]::OutputEncoding = [System.Text.UTF8Encoding]::new()\r\n```\r\n\r\n`Debug-NativeInOutput` supports doing so _temporarily_ by passing `-Encoding utf8` (it always also (temporarily) sets `$OutputEncoding` to the specified encoding).\r\n\r\n---\r\n\r\n* With the ANSI-code-page-aware `python` CLI:\r\n\r\n```powershell\r\nPS> 'e\u00e9' | Debug-NativeInOutput { python -c \"import sys; data = sys.stdin.read(); sys.stdout.write(data)\" }\r\nVERBOSE:\r\n# -------------- Character-encoding settings [code pages]:\r\n#\r\n#   [Console]::InputEncoding [Console]::OutputEncoding $OutputEncoding\r\n#   ------------------------ ------------------------- ---------------\r\n#   OEM United States [437]  OEM United States [437]   Unicode (UTF-8) [65001]\r\n#\r\n\r\nCommand                       : 'e\u00e9' |  python -c \"import sys; data = sys.stdin.read(); sys.stdout.write(data)\"\r\nDecodedOutput                 : e\u251c\u2310          # !! INCORRECT\r\nDecodedUTF16CodeUnits         : 0x65 0x251c 0x2310\r\nInputUTF16CodeUnits           : 0x65 0xe9\r\nInputAsUTF8Bytes              : 0x65 0xc3 0xa9\r\nInputAsOEMBytes               : 0x65 0xe9\r\nInputAsANSIBytes              : 0x65 0x82\r\nInputMisdecodedFromUTF8AsOEM  : e\u251c\u2310\r\nInputMisdecodedFromUTF8AsANSI : e\u00c3\u00a9\r\n\r\nVERBOSE: # Uncaptured (direct-to-display by default, no decoding involved):\r\ne\u00c3\u00a9     # !! INCORRECT, because the input was misinterpreted.\r\nVERBOSE: #\r\n````\r\n\r\nPython interpreted the UTF-8 input _as ANSI-encoded_ and also output it as such (interpreting the UTF-8 byte sequence for `e\u00e9` as an OEM-encoded string results in `e\u00c3\u00a9`).\r\n\r\n* On decoding, PowerShell decoded the ANSI bytes based on `[Console]::OutputEncoding]`, i.e. the _OEM_ encoding, which again yielded `e\u251c\u2310`.\r\n\r\n* However, because Python itself misinterpreted the input, the straight-to-display printing didn't work as expected either.\r\n\r\nThe solution is to set `$OutputEncoding`, `[Console]::OutputEncoding` (and `[Console]::InputEncoding`) to the active ANSI code page:\r\n\r\n```powershell\r\n$OutputEncoding = [Console]::InputEncoding = [Console]::OutputEncoding = \r\n  [System.Text.Encoding]::GetEncoding([cultureinfo]::CurrentCulture.TextInfo.ANSICodePage)\r\n```\r\n\r\nAgain, `Debug-NativeInOutput` supports doing so temporarily via `-Encoding ansi`.\r\n\r\n",
      "created_at": "2021-03-06T19:25:51Z",
      "updated_at": "2021-03-30T20:22:27Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@jborean93, that was one deep rabbit hole, and I had to go back and make repeated corrections to my previous comments - I hope everything is correct now.\r\n\r\nPython using the _ANSI_ legacy code page by default is what confused me.\r\nIf anything, the above shows that it would be handy to have cmdlets such as `Push-ConsoleEncoding` / `Pop-ConsoleEncoding` to deal with special encoding needs on a per-program basis.\r\n\r\n",
      "created_at": "2021-03-06T19:50:49Z",
      "updated_at": "2021-03-09T14:42:20Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Mulling this over some more, let me attempt a summary and a recommendation:\r\n\r\n* Any change we make in this area will inevitably be _breaking_.\r\n\r\n* As such, we should \"break things right\", and shed historical baggage as much as possible, as suggested below:\r\n\r\n---\r\n\r\n* Introduce `Set-ConsoleEncoding` and `Get-ConsoleEncoding` cmdlets:\r\n\r\n  *  `Set-ConsoleEncoding -Encoding <enc>` would be the equivalent of `chcp  <code-page>` (which doesn't work directly in PowerShell), and would set both `[Console]::InputEncoding` and `[Console]::OutputEncoding` to the specified encoding. \r\n      * On Unix-like platforms, the `LANG` environment variable should additionally be updated to reflect the chosen encoding, and it may make sense to limit the specifiable encodings to those officially supported via installed locales, as reflected in `locale -a` (as reported by something like `(locale -a) -match '\\.' -replace '^.+?\\.' | Sort-Object -Unique`)\r\n      * `$OutputEncoding` will be available as an optional PowerShell-only override that can support additional encodings (see below).\r\n\r\n  * `Get-ConsoleEncoding` would report the current values of `[Console]::InputEncoding` and `[Console]::OutputEncoding`, as well as `$OutputEncoding`\r\n\r\n* Make PowerShell (`ConsoleHost`) _by default_ switch the console input and output code page to UTF-8, _before_ processing  `$PROFILE` files:\r\n\r\n  * ``Console.InputEncoding = Console.OutputEncoding = new UTF8Encoding(); // like `chcp 65001` ``\r\n  * Users can override this via a `Set-ConsoleEncoding` call in their `$PROFILE`, if desired.\r\n\r\n* Extend the mandate of `$OutputEncoding`:\r\n\r\n  * Conceive of it as purely optional _on-demand override_ preference variable:\r\n     * _If set_, use its encoding to control the _pipe-to_ AND the _capture-from_ encoding (currently, it only controls the former).\r\n     * Setting it in a specific scope only therefore allows temporary overrides such as:\r\n        * `& { $OutputEncoding = [Text.Encoding]::GetEncoding([cultureinfo]::CurrentCulture.TextInfo.ANSICodePage); $out = python.exe -c \"import sys; data = sys.stdin.read(); print(data)\" }`\r\n\r\n    * This is handy for external programs that do _not_ respect the active console code page, such as `python` (ANSI), `sfc.exe` (UTF-16), `node` (UTF-8, though with the default in effect no override is needed).\r\n\r\n  * Ideally, we wouldn't predefine the variable at all - and in its absence piping to external programs would use whatever the value of `Console.OutputEncoding` is (just as is already the case for capturing data _received from_ external programs).\r\n    * If that's considered too much of a breaking change, we can make it a _dynamic-by-default_ variable that reports the value of `Console.OutputEncoding` _unless explicitly set_; setting it to `$null` later (or removing it) would restore the dynamic behavior (which wouldn't even be necessary when a locally-scoped override goes out of scope).\r\n\r\n  *  Finally, we could consider introducing a more descriptive _alias_ for `$OutputEncoding` that also reflects its extended mandate: `$PSNativeEncoding` (both could refer to the same storage location, just like `$_` and `$PSItem` already do).\r\n\r\n\r\n",
      "created_at": "2021-03-16T18:26:04Z",
      "updated_at": "2021-03-16T18:46:30Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "Thanks @mkelement0 for the detailed response, sorry for not getting back to you earlier.\r\n\r\n> no decoding is involved if the output is neither captured nor redirected, in which case it goes straight to the display\r\n\r\nThis is something I was not aware of myself so thanks for sharing it. It does look like this is only the case if a console already exists as well. If you were to do the same in a PSRemoting session where there is no console then the output is still redirected in PowerShell and `[Console]::OutputEncoding` applies.\r\n\r\nJust as an FYI this is what I used to test out this statement.\r\n\r\n```powershell\r\nAdd-Type -TypeDefinition @'\r\nusing Microsoft.Win32.SafeHandles;\r\nusing System;\r\nusing System.Runtime.InteropServices;\r\n\r\nnamespace RawConsole\r\n{\r\n    public class NativeMethods\r\n    {\r\n        [DllImport(\"Kernel32.dll\")]\r\n        public static extern int GetFileType(\r\n            IntPtr hFile);\r\n\r\n        [DllImport(\"Kernel32.dll\")]\r\n        public static extern SafeFileHandle GetStdHandle(\r\n            int nStdHandle);\r\n    }\r\n}\r\n'@\r\n\r\n$handle = [RawConsole.NativeMethods]::GetStdHandle(-11)\r\nswitch ([RawConsole.NativeMethods]::GetFileType($handle.DangerousGetHandle())) {\r\n    1 { 'Disk' }\r\n    2 { 'Char' }\r\n    3 { 'Pipe' }\r\n    default { 'Unknown' }\r\n}\r\n```\r\n\r\n> if the program uses the Unicode version of the WriteConsole WinAPI function, the output will print correctly - irrespective of whether there's a potential encoding mismatch.\r\n\r\nI don't think this case is related at all to the issue at hand. If a program uses [WriteConsole](https://docs.microsoft.com/en-us/windows/console/writeconsole) then it is writing directly to the console screen buffer and not the redirected `stdout` pipes that PowerShell has in place. This function will only work with the true console handles and if redirection has been set up then [GetStdHandle](https://docs.microsoft.com/en-us/windows/console/getstdhandle) will be a handle to the redirected pipe and cannot be used with `WriteConsole`. For example if you were to run this script like `$out = powershell.exe -File test.ps1` then `testing` will be displayed on the console and `$out` won't be set.\r\n\r\n```powershell\r\nAdd-Type -TypeDefinition @'\r\nusing Microsoft.Win32.SafeHandles;\r\nusing System;\r\nusing System.IO;\r\nusing System.Runtime.InteropServices;\r\n\r\nnamespace RawConsole\r\n{\r\n    public class NativeMethods\r\n    {       \r\n        [DllImport(\"Kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\r\n        public static extern SafeFileHandle CreateFile(\r\n            string lpFileName,\r\n            uint dwDesiredAccess,\r\n            FileShare dwShareMode,\r\n            IntPtr lpSecurityAttributes,\r\n            FileMode dwCreationDisposition,\r\n            uint dwFlagsAndAttributes,\r\n            IntPtr hTemplateFile);\r\n     \r\n        [DllImport(\"Kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\r\n        public static extern bool WriteConsoleW(\r\n            IntPtr hConsoleOutput,\r\n            string lpBuffer,\r\n            int nNumberOfCharsToWrite,\r\n            out int lpNumberOfCharsWritten,\r\n            IntPtr lpReserved);\r\n    }\r\n}\r\n'@\r\n\r\n$printString = 'testing'\r\n\r\n$handle = [RawConsole.NativeMethods]::CreateFile(\r\n    'CONOUT$',\r\n    0x40000000,  # GENERIC_WRITE\r\n    'Read, Write',\r\n    [IntPtr]::Zero,\r\n    'Open',\r\n    0,\r\n    [IntPtr]::Zero\r\n); $err = [Runtime.InteropServices.Marshal]::GetLastWin32Error()\r\n\r\nif ($handle.IsInvalid) {\r\n    throw [ComponentModel.Win32Exception]$err\r\n}\r\n\r\n$num = 0\r\n$res = [RawConsole.NativeMethods]::WriteConsoleW(\r\n    $handle.DangerousGetHandle(),\r\n    $printString,\r\n    $printString.Length,\r\n    [ref]$num,\r\n    [IntPtr]::Zero\r\n); $err = [Runtime.InteropServices.Marshal]::GetLastWin32Error()\r\n\r\nif (-not $res) {\r\n    throw [ComponentModel.Win32Exception]$err\r\n}\r\n```\r\n\r\nThis is unrelated to the problem at hand though as it bypasses anything to do with PowerShell and talks directly to the console itself.\r\n\r\n> I've created a helper function Debug-NativeInOutput for diagnosing such problems, which you can install directly from a Gist as follows (I can assure you that doing so is safe, but you should always check):\r\n\r\nI'm also trying to do the same with https://gist.github.com/jborean93/44b4688cc518d67bd7bc2192648384a3 but it's a really rough draft.\r\n\r\nAll in all I think what you are suggesting sounds about right to me. The defaults should be UTF-8 which in turn sets the console codepage to 65001 solving most (not all) native applications that are called. I also like your idea around making `$OutputEncoding` a preference like variable, especially with an alias to better reflect it's purpose. I was definitely thrown off when I found out it only affected how PowerShell pipes data into a process and not how it decodes the output from.\n\n<blockquote><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> Gist</div><div><strong><a href=\"https://gist.github.com/jborean93/44b4688cc518d67bd7bc2192648384a3\">Details about console encoding in PowerShell</a></strong></div><div>Details about console encoding in PowerShell. GitHub Gist: instantly share code, notes, and snippets.</div></blockquote>",
      "created_at": "2021-03-16T22:44:10Z",
      "updated_at": "2021-03-16T22:44:13Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @jborean93.\r\n\r\n> If a program uses WriteConsole then it is writing directly to the console screen buffer and not the redirected stdout pipes that PowerShell has in place.\r\n\r\nThat was precisely my point - things may *appear* to work *in the console*, but won't *with redirection* aka *further programmatic processing*.\r\n\r\n\ud83d\udc4d  re the rest (but note that [`$OutputEncoding` already _is_ a preference variable](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_Preference_Variables#outputencoding), just one that shouldn't be _predefined_ and whose current mandate is too narrow).\r\n\r\n",
      "created_at": "2021-03-16T23:03:28Z",
      "updated_at": "2021-03-30T20:20:18Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Having revisited this in the context of #15123:\r\n\r\nSorry for not fully addressing your feedback: I didn't dive as deep as you did.\r\n\r\nFirst of all, yes: whenever stdout _isn't_ connected to a console, the discrepancy between seemingly correct _display_ output but erroneously _decoded_ output doesn't apply, because decoding is then _invariably_ involved (capturing in a variable, redirecting to a file, piping to another command, remoting, background/thread jobs).\r\n\r\nAs for _when_ this discrepancy may arise on Windows:\r\n\r\n* At least _some_ high-profile CLIs seemingly explicitly modify their behavior based on whether they're outputting directly to a console (terminal) or not.\r\n\r\n   * My _inference_ was that such CLIs use the Unicode version of the `WriteConsole` API _situationally_, namely when stdout is connected to a console, but I have no positive proof.\r\n\r\n   * The two high-profile CLIs I know of that behave this way are `python` and `node` - there may be others.\r\n\r\n* By contrast, _.NET_ console applications do _not_ make this distinction when outputting via `Console.WriteLine()` / `Console.Out.WriteLine()`\r\n\r\nYou can verify this as follows:\r\n\r\n* _Direct-to-display_ output:\r\n\r\n```powershell\r\n# On Windows - using direct-to-display output.\r\nPS> & { python -c \"print('e\u00e9')\"; node -pe \"'e\u00e9'\"; (Add-Type -PassThru -Name foo -MemberDefinition 'public static void PrintToConsole() { Console.WriteLine(\"e\u00e9\"); }')::PrintToConsole() }\r\ne\u00e9\r\ne\u00e9\r\ne\u00e9\r\n```\r\n\r\n* _Decoded_ output, via piping to `Write-Output`:\r\n\r\n```powershell\r\n# On Windows - *decoded* output\r\nPS> & { python -c \"print('e\u00e9')\"; node -pe \"'e\u00e9'\"; (Add-Type -PassThru -Name foo -MemberDefinition 'public static void PrintToConsole() { Console.WriteLine(\"e\u00e9\"); }')::PrintToConsole() } | \r\n      Write-Output\r\ne\u0398\r\ne\u251c\u2310\r\ne\u00e9\r\n```\r\n\r\nAs you can see, only with _decoded_ output do the encoding-mismatch problems surface in the `python` (always-ANSI) and `node` (always UTF-8) calls.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n \r\n\r\n\r\n",
      "created_at": "2021-03-31T01:32:26Z",
      "updated_at": "2021-03-31T01:33:10Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "To summarize the backward-compatibility impact that the [proposed change](https://github.com/PowerShell/PowerShell/issues/14945#issuecomment-800503184) would have:\r\n\r\nIf we switch PowerShell consoles from the system's OEM code page to `65001` == UTF-8, _only_ the following cases will amount to a breaking change:\r\n\r\n* Legacy programs that use a _fixed_ OEM code page (other than `65001`).\r\n* Legacy program that respect the console's code page but _cannot handle code page `65001`_ (i.e. UTF-8) - an example of such a program is `WMIC.exe`, which is _deprecated_, however.\r\n\r\nFor \"rogue\" programs that do their own thing (e.g., Node.js, Python, `sfc.exe` - though note that Python can be configured to use UTF-8), a workaround is _already_ necessary (temporarily setting `Console]::OutputEncoding`), and it will continue to work.\r\n\r\n",
      "created_at": "2021-04-07T14:01:25Z",
      "updated_at": "2021-04-07T14:01:25Z"
    }
  ],
  "created_at": "2021-03-05T06:44:08Z",
  "labels": [
    "WG-Interactive-Console",
    "Needs-Triage"
  ],
  "number": 14945,
  "state": "open",
  "title": "$OutputEncoding and [Console]::InputEncoding are not aligned -Windows Only",
  "updated_at": "2021-04-07T14:01:25Z"
}