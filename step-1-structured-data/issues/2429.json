{
  "_url": "https://github.com/PowerShell/PowerShell/issues/2429",
  "author": "daxian-dbw",
  "body": "Fix #2293\r\n\r\n**Idea behind the Fix**\r\n~~After selecting a handler, for both try/catch and trap{}, we set `$_` with [`new ErrorRecord(rte.ErrorRecord, exceptionToPass)`](https://github.com/PowerShell/PowerShell/blob/master/src/System.Management.Automation/engine/runtime/Operations/MiscOps.cs#L1297). The `exceptionToPass` will be adopted only if [`(rte.ErrorRecord.Exception is ParentContainsErrorRecordException) == true`](https://github.com/PowerShell/PowerShell/blob/master/src/System.Management.Automation/engine/ErrorPackage.cs#L1401). So basically `$_.Exception` will always be `rte.ErrorRecord.Exception` unless it's a `ParentContainsErrorRecordException` instance. So we should just select the handler based on `rte.ErrorRecord.Exception` if it's not `ParentContainsErrorRecordException`. When it is `ParentContainsErrorRecordException`, then we go through the original code path to determine what exception to pass to user.~~\r\n\r\nThe old fix would cause unacceptable breaking changes (see the discussion below). The following is the new fix:\r\n\r\nFirst rank the given exception types -- a smaller rank indicates a more specific exception type, for example, `rank == 0` means the corresponding exception type is not derived by another other given exception types, while `rank == 1` means the corresponding exception type is derived by another exception type in the given types. `CatchAll` is considered to be derived by any other exception type. \r\n\r\nThen during the search, we try all existing searching methods in the same existing order, as long as we haven't found a handler whose exception type's rank is 0.\r\nWhen a new handler is found, we use the following algorithm to decide whether to replace the current handler (the handler that was found before the new handler):\r\n - If new-rank is less than current-rank -- meaning the new handler is more specific, then we update the current result with it.\r\n-  If new-rank is more than current-rank -- meaning the new handler is less specific, then we do NOT change the current result.\r\n- If new-rank is equal to current-rank, we do NOT change the current result UNLESS the current handler is catch-all. (This is to keep the original behavior -- prefer to use the later found exception as the exception-to-pass-in if all exceptions result in the catch-all handler.\r\n\r\n**With the Fix**\r\n\r\n``` powershell\r\nPS D:\\> try {\r\n>>     Get-ChildItem c:\\xyzzy -ea Stop\r\n>> } catch [System.Management.Automation.ItemNotFoundException] {\r\n>>     \"ItemNotFoundException caught\"\r\n>> } catch [System.Exception] {\r\n>>     \"System.Exception caught\"\r\n>> }\r\nItemNotFoundException caught\r\nPS D:\\>\r\nPS D:\\> try {\r\n>>     Get-ChildItem c:\\xyzzy -ea Stop\r\n>> } catch [System.Management.Automation.ItemNotFoundException] {\r\n>>     \"ItemNotFoundException caught\"\r\n>> } catch [System.Management.Automation.RuntimeException] {\r\n>>     \"RuntimeException caught\"\r\n>> }\r\nItemNotFoundException caught\r\n```\r\n\r\n**Task**\r\n- [x] Refine the fix\r\n- [x] Run our legacy tests to find potential regressions (ran the Github nightly build tests)\r\n- [x] Add tests\r\n",
  "closed_at": "2016-12-09T20:37:08Z",
  "comments": [
    {
      "author": "msftclas",
      "author_association": "NONE",
      "body": "Hi **@daxian-dbw**, I'm your friendly neighborhood Microsoft Pull Request Bot (You can call me MSBOT). Thanks for your contribution!\n    <p>\n        It looks like you're a Microsoft contributor (Dongbo Wang). If you're full-time, we DON'T require a Contribution License Agreement. If you are a vendor, please DO sign the electronic Contribution License Agreement. It will take 2 minutes and there's no faxing! https://cla.microsoft.com.\n    </p>\n\nTTYL, MSBOT;\n",
      "created_at": "2016-10-05T22:24:20Z",
      "updated_at": "2016-10-05T22:24:20Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "The potential breaking changes comes from trying to catch `ParentContainsErrorRecordException`?\n\nIf that's it, it seems safe. Most people just catch everything anyway.\n\nI'd like some investigation to know for sure that ActionPreferenceStopException and CmdletInvocationException are always wrapped in a ParentContainsErrorRecordException.\n",
      "created_at": "2016-10-06T18:25:41Z",
      "updated_at": "2016-10-06T18:25:41Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "I will investigate `ActionPreferenceStopException` and `CmdletInvocationException` further.\n",
      "created_at": "2016-10-06T22:00:22Z",
      "updated_at": "2016-10-06T22:00:22Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@lzybkr it turns out it causes quite a few regressions \u2639\ufe0f for example:\n\n**Before the change**\n\n```\nPS:20> try { dir c:\\xyzz -ea Stop }\n>>     catch [System.Management.Automation.ActionPreferenceStopException] {\n>>        \"ActionPreferenceStopException Caught\" }\nActionPreferenceStopException Caught\n\nPS:22> try { Invoke-Expression \"gcm -Name\" }\n>>     catch [System.Management.Automation.CmdletInvocationException] {\n>>        \"CmdletInvocationException Caught\" }\nCmdletInvocationException Caught\n```\n\n**After the change**\n\n```\nPS C:\\> try { dir c:\\xyzz -ea Stop }\n>>      catch [System.Management.Automation.ActionPreferenceStopException] {\n>>         \"ActionPreferenceStopException Caught\" }\ndir : Cannot find path 'C:\\xyzz' because it does not exist.\nAt line:1 char:7\n+ try { dir c:\\xyzz -ea Stop }\n+       ~~~~~~~~~~~~~~~~~~~~\n    + CategoryInfo          : ObjectNotFound: (C:\\xyzz:String) [Get-ChildItem], ItemNotFoundException\n    + FullyQualifiedErrorId : PathNotFound,Microsoft.PowerShell.Commands.GetChildItemCommand\n\nPS C:\\> try { Invoke-Expression \"gcm -Name\" }\n>>      catch [System.Management.Automation.CmdletInvocationException] {\n>>         \"CmdletInvocationException Caught\" }\nInvoke-Expression : Missing an argument for parameter 'Name'. Specify a parameter of type 'System.String[]' and try again.\nAt line:1 char:7\n+ try { Invoke-Expression \"gcm -Name\" }\n+       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    + CategoryInfo          : InvalidArgument: (:) [Invoke-Expression], ParameterBindingException\n    + FullyQualifiedErrorId : MissingArgument,Microsoft.PowerShell.Commands.InvokeExpressionCommand\n```\n\n**And the awkward part of the current behavior** is that sometimes `$_.Exception` in the catch block is not the same kind of exception that the catch block is supposed to capture, take the same commands as examples:\n\n```\nPS:24> try { dir c:\\xyzz -ea Stop }\n>>     catch [System.Management.Automation.ActionPreferenceStopException] {\n>>        $_.Exception.GetType().FullName }\nSystem.Management.Automation.ItemNotFoundException\n\nPS:25> try { Invoke-Expression \"gcm -Name\" }\n>>     catch [System.Management.Automation.CmdletInvocationException] {\n>>        $_.Exception.GetType().FullName }\nSystem.Management.Automation.ParameterBindingException\n```\n\nYou can see that `$_.Exception` caught by `catch [ActionPreferenceStopException]` and `catch [CmdletInvocationException]` are `ItemNotFoundException` and `ParameterBindingException` respectively.\n",
      "created_at": "2016-11-18T08:14:31Z",
      "updated_at": "2016-11-18T08:14:31Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "The root problem is we don't have a specific exception to search for handler. Instead, we have multiple candidate exceptions from which we pick up to suit the given handlers.\n\nThe fix needs to be re-worked, and ~~I think we need to change `new ErrorRecord(ErrorRecord, Exception)` to allow forceful replacement of the exception.~~ it turns out we cannot just change `ErrorRecord.Exception` forcefully to be the one we pick for a handler, because people are depending on `$_.Exception` to get the real exception. Example: https://github.com/eccentricDBA/PowerShell/blob/02734d1b415deb74b46d38fae77b8d98cce5ede2/Demos/5_Test-Connection.ps1#L16.\n\nTherefore, `new ErrorRecord(ErrorRecord, Exception)` should continue to behave the current way -- only replace the exception if `ErrorRecord.Exception` is `ParentContainsErrorRecordException`.\n",
      "created_at": "2016-11-18T18:02:45Z",
      "updated_at": "2016-11-18T19:16:12Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@lzybkr I think this try/catch fix is ready. Can you please review this PR?",
      "created_at": "2016-12-01T18:08:31Z",
      "updated_at": "2016-12-01T18:08:31Z"
    }
  ],
  "created_at": "2016-10-05T22:24:16Z",
  "number": 2429,
  "state": "closed",
  "title": "Fix try/catch to choose the more specific exception handler",
  "updated_at": "2016-12-09T20:37:08Z"
}