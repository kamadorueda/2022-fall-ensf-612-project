{
  "_url": "https://github.com/PowerShell/PowerShell/issues/10509",
  "author": "chriskuech",
  "body": "# Summary of the new feature/enhancement\r\n\r\nPowerShell aims to be cross-platform, but I have been having many issues operating on paths across both Windows and Linux.  I understand the need to support `\\` in Windows for the foreseeable future, but I would at least like the default path character to be the same on both Windows and *nix, presumably by setting the default path delimiter to `/`.  The current alternative is forcing users to normalize paths themselves with `-replace \"\\\\\", \"/\"` in their paths.\r\n",
  "closed_at": "2020-06-30T15:18:17Z",
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> The current alternative is forcing users to normalize paths\r\n\r\nPowerShell already does the work for you and you have no need to normalize paths. \r\nPowerShell is very user-friendly here - users can use slashes which they are comfortable regardless of platform.\r\nBest practice is to avoid using literal paths and use path cmdlets.\r\n  ",
      "created_at": "2019-09-11T11:08:08Z",
      "updated_at": "2019-09-11T11:08:08Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "> Best practice is to avoid using literal paths and use path cmdlets.\r\n\r\n@iSazonov Yes and no.\r\n\r\nSure, if you are combining path segments, you can use path cmdlets. But if you are writing a script that references a relative path with multiple segments, and if you intend for your script to work cross platform, you're not going to do that.\r\n\r\nIn PowerShell 7 preview 3 on Windows, tab completion completes paths using a backslash. That is the one place where I think we're doing it wrong now that PowerShell is cross platform. There should at least be an option to select the directory separator character you want used on Windows as part of tab completion: either `[System.IO.Path]::DirectorySeparatorChar` or `[System.IO.Path]::AltDirectorySeparatorChar`. Given where we are today, I suspect most folks who do any cross platform work would want tab completion of paths to use `AltDirectorySeparatorChar` on Windows by default, but as far as I know there is no way to make it do that.\r\n\r\n@chriskuech: Aside from tab completion of paths, are there other places where you feel `AltDirectorySeparatorChar` isn't being used where you would like to have an option for it to be used instead of `DirectorySeparatorChar`? I can't think of any.",
      "created_at": "2019-09-11T16:31:47Z",
      "updated_at": "2019-09-11T16:35:47Z"
    },
    {
      "author": "chriskuech",
      "author_association": "NONE",
      "body": "@KirkMunro , are you saying that there is an (at least partially implemented) way to normalize paths in PowerShell today?  If so, will it work on latest 6.x?  The use cases I was having an issue with were automatic variables and `*-Path` commands. \r\n\r\n@iSazonov, the proposed solution would not have worked for my scenario because I generated a list of paths on Windows, generated a list of paths on Linux, then attempted to compare them, which failed due to the separators. \r\n\r\nThe automatic variables consistently lack a trailing directory separator, so PowerShell beautifully allows creating paths with literals.  Ex:\r\n\r\n```powershell\r\n$RepoRoot = \"$PSScriptRoot/../..\"\r\n$SourceRoot = \"$RepoRoot/src\"\r\n$BuildRoot = \"$RepoRoot/.build\"\r\n```\r\n\r\nI think this is much more clear than\r\n\r\n```powershell\r\n$RepoRoot = Join-Path $PSScriptRoot \"../..\"\r\n$SourceRoot = Join-Path $RepoRoot \"src\"\r\n$BuildRoot = Join-Path $RepoRoot \".build\"\r\n```\r\n\r\nso I hope it can work in the future, even if not by default.",
      "created_at": "2019-09-11T16:45:12Z",
      "updated_at": "2019-09-11T16:48:13Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@chriskuech my personal habit has become something like:\r\n```powershell\r\n$SourceRoot = $RepoRoot | Join-Path -ChildPath 'src'\r\n```\r\nIt's a little clearer but yeah it's not perfect.",
      "created_at": "2019-09-11T16:54:39Z",
      "updated_at": "2019-09-11T16:54:58Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "`Join-Path` has `AdditionalChildPath` which accept string array.",
      "created_at": "2019-09-12T04:40:32Z",
      "updated_at": "2019-09-12T04:40:32Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@chriskuech Thanks for the additional information.\r\n\r\nI wasn't suggesting that PowerShell partially supports normalization of paths. I was simply calling out that I personally dislike that tab completion uses a backward slash by default on Windows, and a forward slash by default on Linux or macOS.\r\n\r\nIf I could tweak some setting to change that so that forward slash is used even on Windows paths by default, I would make that change, and this is one place where I think there may be an opportunity to make cross platform PowerShell work easier. `Join-Path` uses `[System.IO.Path]::DirectorySeparatorChar` as the path separator as well. Ideally if there were a setting to set the desired path separator when writing scripts (because we should be able to easily write scripts the way we want regardless of the platform we choose to write them on), it would be reflected in both tab completion of paths and `Join-Path` as well.\r\n\r\nThose personal needs aside, I wonder if a `Compare-Path` cmdlet would be useful. It could normalize the path separators, and even compare absolute paths with relative paths by resolving relative paths before the comparison is made if one of the paths is absolute.",
      "created_at": "2019-09-12T14:52:25Z",
      "updated_at": "2019-09-12T14:52:25Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Well, we do get _platform-specific_ normalization in `Convert-Path` and `Resolve-Path`:\r\n\r\n```powershell\r\nPS> Convert-Path C:/Windows\r\nC:\\Windows # normalized to Windows-native \"\\\"\r\n```\r\n\r\nSo, perhaps as an alternative to introducing a `Compare-Path` cmdlet, `Convert-Path` and `Resolve-Path` could be extended to support a `-UseSlash` switch (name negotiable).\r\n\r\nSeparately and complementarily, the opt-in preference mechanism for using `/` on Windows that Kirk suggests could then also apply to `Convert-Path` and `Resolve-Path` (in addition to tab completion and `Join-Path`).\r\n\r\nThe catch at the moment is that `Convert-Path` and `Resolve-Path` only work with _existing_ paths, but that is something well worth changing in its own right, as @jaykul suggested a looong time ago - see #2993 \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2019-09-12T20:20:19Z",
      "updated_at": "2019-09-12T20:20:19Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "I think it would be nice if path completion used the path separator that appears explicitly in the completion text, and if there is none, then default to the platform native separator.\r\n\r\nSo on Windows, `c:\\w` completes to `c:\\Windows\\` and `c:/w` completes to 'c:/Windows/'.\r\n\r\nI think this would cover a majority of the annoyances without requiring a configuration option, and is actually preferable because you occasionally might need the other form for whatever reason.",
      "created_at": "2019-09-12T22:21:35Z",
      "updated_at": "2019-09-12T22:21:35Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@lzybkr, I like the idea, also in light of a concern regarding  a configuration- / preference-variable-based solution that I neglected to mention: the scoping issue; with the usual _dynamic_ scoping, code that makes fixed assumptions about path separators may break (which has echoes of https://github.com/PowerShell/PowerShell-RFC/issues/7).",
      "created_at": "2019-09-12T23:06:55Z",
      "updated_at": "2019-09-12T23:06:55Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@lzybkr and when both slashes are used? `C:\\Program Files/A` -> ?",
      "created_at": "2019-09-12T23:46:20Z",
      "updated_at": "2019-09-12T23:46:20Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "So many options - random, alternate each one, always forward slash b/c it's the one true path separator, etc.\r\n\r\nMore seriously, maybe just pick the last one used, that is probably typed by the user whereas others might not be.",
      "created_at": "2019-09-12T23:54:31Z",
      "updated_at": "2019-09-12T23:54:31Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@lzybkr: There's one catch, though:\r\n\r\nIf you start _without_ a path separator, in order to reference a file/folder in the _current directory_, PowerShell will have to make the choice for you, at least based on the current completion algorithm that expands to `.\\<filename>` or `./<filename>` / `.\\<folder>\\` or `./<folder>/`, platform-appropriately.\r\n\r\nFor _files_ as _arguments_, we could sidestep that problem by expanding `fil` to just `file`, for instance (no `.\\` / `./` prefix).\r\n\r\nHowever:\r\n\r\n* for _executables_ , the automatically added `.\\` / `./` prefix is a valuable convenience if the intent is indeed to execute a script located in the current directory.\r\n\r\n* for _directories_, similarly, expanding to something with a _trailing path separator_ (`<folder>\\` or `<folder>/`) is valuable too.\r\n\r\nIn both cases there's no user action to imply the preferred separator.\r\n\r\nThat said, perhaps the solution is: if you want to control the separator, _manually start with_ `./` or `.\\` and make tab completion respect that.",
      "created_at": "2019-09-13T02:38:36Z",
      "updated_at": "2020-07-01T14:23:36Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This issue has been marked as answered and has not had any activity for **1 day**. It has been closed for housekeeping purposes.",
      "created_at": "2019-09-14T12:00:38Z",
      "updated_at": "2019-09-14T12:00:38Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov: This isn't really answered, and should be reopened to allow the ongoing discussion to continue working this out. The OP hasn't even had a chance to respond to questions asked back to him.",
      "created_at": "2019-09-14T13:35:30Z",
      "updated_at": "2019-09-14T13:35:30Z"
    },
    {
      "author": "chriskuech",
      "author_association": "NONE",
      "body": "I think I addressed all the questions to me, but let me know if I didn't.  I too am not sure why this issue is closed.  It wasn't meant as a discussion thread, rather a feature request.\r\n\r\nThe root issue at hand: \r\n* Should a cross-platform tool have non-cross-platform behavior by default?\r\n* If so, should there be a way to globally run PowerShell in a \"cross-platform\" mode?\r\n\r\nI think forcing devs to manually normalize strings with cmdlets is a definite wrong move.  I don't see any scenarios where using `/` by default would cause issues on Windows because PowerShell, as previously mentioned, is very good about handling both kinds of slashes.  Unless anyone can provide compelling situations where this would cause error, why not just use `/` by default?  Perhaps this issue needs to move to an RFC.\r\n\r\nAs more people migrate to the cloud, more and more people develop PowerShell code on Windows and run it on Linux.  There will certainly be a point in the future (if not already passed) where the number of users preferring true cross-platform behavior exceeds any who feel strongly about keeping `\\` on Windows.",
      "created_at": "2019-09-14T15:51:57Z",
      "updated_at": "2019-09-14T15:51:57Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@chriskuech: My bad, I didn't specifically pose the question to you. I was wondering if you felt a `Conpare-Path` cmdlet would help you out. That question aside though, I would like to see normalization options as well.",
      "created_at": "2019-09-14T15:57:14Z",
      "updated_at": "2019-09-14T15:57:14Z"
    },
    {
      "author": "chriskuech",
      "author_association": "NONE",
      "body": "@KirkMunro I'm not sure `Compare-Path` would help, because in the original use case (comparing paths on Linux and Windows), the root file system is different, so I have to call `Resolve-Path -Relative`.  At that point the comparison use case is just a one-liner: `| ? {($_ -replace \"\\\\\", \"/\") -in $ExpectedPaths}`.\r\n\r\nHowever, I am very hesitant to endorse any cmdlet-based solution, as it doesn't solve the root issue and will either disallow string interpolation for paths or require code changes to every path string definition.  Specifically, `Compare-Path` won't fix all my logged paths with mixed slashes.",
      "created_at": "2019-09-14T16:17:21Z",
      "updated_at": "2019-09-14T16:17:21Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@KirkMunro  @mklement0 The issue is not locked and everyone can pull comments.\r\nWe have a lot of issues without new comments and progress. Open status has lost its meaning.\r\nAs a maintainer, I intend to be more exacting in order to encourage discussions to become more rigorous specifications that can easily turn into PRs.\r\nAs for the issue, it turns into infinite - initial request was \"use forward slash on Windows\", then \"compare paths\". What is next? Remoting? It is open to continue but will be closed.\r\nWhile only one real proposal from Jason was above (to enhance completion) and we could open a tracking issue and close it by real PR.\r\n\r\n",
      "created_at": "2019-09-14T20:26:25Z",
      "updated_at": "2019-09-14T20:26:25Z"
    },
    {
      "author": "chriskuech",
      "author_association": "NONE",
      "body": "To be clear, the issue is still \"use forward slash on Windows\".  \"Compare paths\" was only brought up as one (of multiple) motivating examples.\r\n\r\n**Proposal**\r\nImplement true cross-platform behavior, where the path delimiter defaults to `/` on all platforms unless the user is tab-completing a path already containing `\\`.  I would expect this to be hidden as an experimental feature for now, but I should at least be able to enable a \"maximize cross-platform behavior\" feature in my code for optimizing the dev experience of Windows devs targeting Linux.\r\n\r\nIf this is unreasonable, I would like to know why and if there is documentation guiding when PowerShell design diverges across platforms.\r\n",
      "created_at": "2019-09-15T01:30:14Z",
      "updated_at": "2019-09-15T01:30:14Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov: Maintainers of the PS repo shouldn't be dismissive to users issues without discussion. You originally replied without taking the time to understand the needs of the OP, marking the issue as answered, but the issue was not posted as a question, it was posted as a feature request, and as can be seen by the discussion it is clearly not \"answered\".",
      "created_at": "2019-09-15T03:13:08Z",
      "updated_at": "2019-09-15T03:13:08Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "> Open status has lost its meaning.\r\n\r\nWho says? That's absolutely not true. An open issue is open, and a closed issue is closed. Those two distinctions have very clear meaning. I only look at closed issues if they are my own and I want to go back to check something. On a rare occasion I may go searching closed issues for discussions on a certain topic. But 90% or more of my time in issues is in open issues, as it should be. The only thing blurring the line between the two and making open issues lose their meaning is summarily closing them before they are resolved, like you have done with this issue.\r\n\r\n> (The discussion) is open to continue but will be closed.\r\n\r\nBased on this approach to managing issues, you're forcing people to lose the distinction between open and closed, such that they have to search all issues rather than focus on the open issues, which means checking the 2K open issues plus the 4K closed issues for discussions relevant to them instead of just focusing on the open issues. That is a broken, flawed issue management strategy.\r\n\r\n> As for the issue, it turns into infinite - initial request was \"use forward slash on Windows\", then \"compare paths\". What is next? Remoting?\r\n\r\nThat is ridiculous. The discussion is focused on dealing with Windows having a backslash as the default when you are writing scripts for cross platform. It has remained focused on that topic. You're trying to make it sound like it isn't focused at all.\r\n\r\n@iSazonov, I agree that there are too many open issues; however, the fact that there are too many open issues does not mean we should be dismissive and shut conversation down prematurely on new issues. We must continue to encourage feedback and be open to discussion about PowerShell in open issues, and only close them once they are truly resolved. The volume of open issues must be dealt with differently.",
      "created_at": "2019-09-16T02:43:00Z",
      "updated_at": "2019-09-16T11:21:49Z"
    },
    {
      "author": "he852100",
      "author_association": "NONE",
      "body": "Loyal linux users?Incomprehensible advice.\r\nYou can convince Microsoft. Ask them to use backslashes as system file paths.\r\n",
      "created_at": "2019-12-24T11:01:57Z",
      "updated_at": "2019-12-24T11:01:57Z"
    },
    {
      "author": "rkitover",
      "author_association": "CONTRIBUTOR",
      "body": "I'd like to chime in here that there are usecases where literal paths with forward slashes are needed, even on Windows.\r\n\r\nI was just writing a script where I was using .net APIs to manipulate and create zip archives. Adding entries to the zip file with this API:\r\n\r\n```powershell\r\n    [System.IO.Compression.ZipFileExtensions]::CreateEntryFromFile(\r\n        $zip, $file, $entry,\r\n        [System.IO.Compression.CompressionLevel]::Optimal\r\n    ) > $null\r\n```\r\n\r\nIn this particular case, $entry is a path within the zip archive. If I simply pass the windows path as returned by various path cmdlets, every zip utility on the planet will spew warnings about my zip file having the wrong slashes.\r\n\r\nAlso as a long time linux user and developer, I love powershell and I've been having lots of fun learning it. I've been having fun playing with my new windows server core over ssh into powershell 7 too, and I have published scripts that work perfectly with powershell on linux. I was surprised how well that works. In fact, powershell is going to be my first choice for some programs/scripts that I want to be cross-platform.\r\n\r\nBut it still makes me sad seeing all my tab completions be rewritten with backslashes.\r\n\r\nI use paths like /users/foo/somefile on windows all the time and that is what I want to use.\r\n\r\nMost of the windows APIs support forward slashes just fine. I realize there are a few exceptions, with utilities and maybe APIs, namely some cmd.exe invocations, but I just want to set something in my $profile so that by default all my paths have forward slashes, unless I am using backslashes explicitly.\r\n\r\nThis would be inoffensive to windows users and developers used to the backslashes because they would simply not use this setting, and it would default to off. Of course, they may decide to use it too if for example they decide to write cross-platform scripts and modules more.\r\n\r\nI want this setting for my scripts and modules too, so that I don't have unexpected problems like the one I showed above.",
      "created_at": "2020-03-14T11:06:29Z",
      "updated_at": "2020-03-14T11:06:29Z"
    },
    {
      "author": "aaronfranke",
      "author_association": "NONE",
      "body": "> @iSazonov users can use slashes which they are comfortable regardless of platform.\r\n\r\nDoes this mean I can configure PowerShell to use forward slashes since that's more comfortable for me as a user? I would like to change the path displayed in the prompt as well as the tab autocompletion which currently changes forward slashes into backslashes.",
      "created_at": "2020-04-20T16:53:24Z",
      "updated_at": "2020-04-20T16:53:24Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@aaronfranke, no, there is currently no way to configure PowerShell this way; I think what @iSazonov was trying to say is that when you manually type a path, you're free to choose between `\\` and `/` (and you can even mix them in a single path).",
      "created_at": "2020-04-20T16:57:14Z",
      "updated_at": "2020-04-20T16:57:14Z"
    },
    {
      "author": "he852100",
      "author_association": "NONE",
      "body": "Considering versatility, a new path symbol should be enabled instead of / and \\\uff0cTraditional symbols increase the difficulty of conversion across platforms",
      "created_at": "2020-04-20T17:18:47Z",
      "updated_at": "2020-04-20T17:18:47Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> I think what @iSazonov was trying to say is that when you manually type a path, you're free to choose between \\ and / (and you can even mix them in a single path).\r\n\r\nYes, It is PowerShell design.",
      "created_at": "2020-04-21T06:44:10Z",
      "updated_at": "2020-04-21T06:44:10Z"
    },
    {
      "author": "rkitover",
      "author_association": "CONTRIBUTOR",
      "body": "This is not a resolution of the issues that have been raised here, such as the forcible replacement of your path separators during completion, or the ability to configure path cmdlets to use your path separator of choice, should we open separate, specific issues for them?",
      "created_at": "2020-04-22T03:05:54Z",
      "updated_at": "2020-04-22T03:05:54Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@rkitover I asked about such scenarios years ago (you can find the issue) without any resolution. This convinces me that this is a cosmetic change, although it requires a lot of effort. If you are ready to invest in this area and pull a PR, then only it makes sense to open a new discussion.\r\n",
      "created_at": "2020-04-22T03:33:44Z",
      "updated_at": "2020-04-22T03:33:44Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "CP/M and clones use ``/`` for options, examples: ``DIR/P``, ``CMD/CECHO``.  These are valid commands.  If we replace ``\\`` with ``/`` everywhere, I am afraid bad misunderstandings could happen.",
      "created_at": "2020-06-15T22:19:54Z",
      "updated_at": "2020-06-15T22:37:11Z"
    },
    {
      "author": "aaronfranke",
      "author_association": "NONE",
      "body": "1. Nobody uses CP/M anymore.\r\n\r\n2. Using `/` for both options and paths at the same time works just fine on Windows in my testing.\r\n\r\n3. Modern tools use `-` for options instead, including PowerShell tools and other Microsoft tools such as .NET. Using `/` for options should be kept for backwards compatibility, but users will not have any confusion with modern tools.",
      "created_at": "2020-06-15T22:26:43Z",
      "updated_at": "2020-06-15T22:28:00Z"
    },
    {
      "author": "rkitover",
      "author_association": "CONTRIBUTOR",
      "body": "Also, I would like to note that the forward slash `/` is an invalid character name in Win32 file names:\r\n\r\nhttps://gist.github.com/doctaphred/d01d05291546186941e1b7ddc02034d3\n\n<blockquote><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> Gist</div><div><strong><a href=\"https://gist.github.com/doctaphred/d01d05291546186941e1b7ddc02034d3\">Invalid characters for Windows filenames</a></strong></div><div>Invalid characters for Windows filenames. GitHub Gist: instantly share code, notes, and snippets.</div></blockquote>",
      "created_at": "2020-06-15T23:10:11Z",
      "updated_at": "2020-06-15T23:10:13Z"
    },
    {
      "author": "markm77",
      "author_association": "NONE",
      "body": "I just want to point out I started using forward slashes only in cross-platform scripts etc and hit a problem with symbolic links.\r\n\r\nAs an example, run\r\n\r\n```powershell\r\nnew-item -itemtype SymbolicLink -path TestScript8.ps1 -target ./TestScript.ps1\r\n```\r\n\r\non Windows and you will not be able to open TestScript8.ps1 in VS Code on Windows.",
      "created_at": "2020-06-19T15:39:14Z",
      "updated_at": "2020-06-19T15:40:02Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@markm77, you've discovered a _bug_ - ~~can you please create a new issue for it~~? [_update_: see #13064]\r\n\r\nNot that it is an argument against an opt-in mechanism for defaulting to `/`, @aaronfranke, but note that there are few edge cases where `/` instead of `\\` still breaks things on Windows; e.g.:\r\n\r\n```cmd\r\nPS> cmd /c dir C:/\r\nInvalid switch - \"\"\r\n```\r\n\r\nDouble-quoting the path only helps with _directory_ paths, curiously - see https://stackoverflow.com/a/43297482/45375, which also shows that the Excel COM Automation library doesn't support `/`.\r\n\r\n\r\n\r\n\r\n<blockquote><img src=\"https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded\" width=\"48\" align=\"right\"><div>Stack Overflow</div><div><strong><a href=\"https://stackoverflow.com/questions/43290000/why-does-powershell-not-want-to-save-my-file-as-a-csv\">Why does PowerShell not want to save my file as a CSV</a></strong></div><div>$Path = 'D:/ETL_Data/TwitchTVData.xlsx'\r\n$csvPath = 'D:/ETL_Data/TwitchTVData2.csv'\r\n\r\n# Open the Excel document and pull in the 'Sheet1' worksheet\r\n$Excel = New-Object -Com Excel.Application\r\n$Workbook...</div></blockquote>",
      "created_at": "2020-06-19T16:32:23Z",
      "updated_at": "2020-07-01T14:20:52Z"
    },
    {
      "author": "markm77",
      "author_association": "NONE",
      "body": "> @markm77, you've discovered a bug - can you please create a new issue for it?\r\n\r\nBut is this a PowerShell bug? PowerShell creates the correct sym-link with specified slash as verified by examining the sym-link using `dir`. It seems though that a sym-link created with the wrong slash type can then be unusable in apps such as VS Code. Which is also understandable perhaps.\r\n\r\nNB it's quite easy to work around this issue by running `convert-item` on sym-link targets which has the added benefit of ensuring sym-links point to absolute paths (probably appropriate).",
      "created_at": "2020-06-19T16:42:22Z",
      "updated_at": "2020-06-19T16:42:22Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> NB it's quite easy to work around this issue by running `convert-item` on sym-link targets which has the added benefit of ensuring sym-links point to absolute paths (probably appropriate).\r\n\r\nInappropriate, will break upon remounting \ud83d\ude1e",
      "created_at": "2020-06-19T16:45:35Z",
      "updated_at": "2020-06-19T16:45:35Z"
    },
    {
      "author": "markm77",
      "author_association": "NONE",
      "body": "> Inappropriate, will break upon remounting \ud83d\ude1e\r\n\r\nFair comment, I don't remount (this is for local dev work) and I have a script for link re-generation I can run at any time. ```join-path``` is obviously the other solution or even better would be a ```new-item``` option to ensure links are platform-appropriate.",
      "created_at": "2020-06-19T16:48:50Z",
      "updated_at": "2020-06-19T16:50:48Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "See #12797",
      "created_at": "2020-06-19T17:03:00Z",
      "updated_at": "2020-06-19T17:03:00Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> But is this a PowerShell bug? \r\n\r\nWhile you could argue that on _Windows_ it is a WinAPI bug, given that `\\` and `/` are usually supported interchangeably, it is definitely a bug on Unix-like platforms if you do the reverse and pass a `\\` based path as the `-Target` path - on such platforms, only `/` is natively supported (it is only PowerShell that allows you to use `\\` as an alternative, which comes with its own problems - see #9244), and it is PowerShell's responsibility to translate something like `.\\TestScript.ps1` to `./TestScript.ps1` when creating the symlink.\r\n\r\nFixing this - by making PowerShell normalize the path to use the (primary) _platform-native_ separator - will also fix the issue on Windows.\r\n",
      "created_at": "2020-06-19T17:03:55Z",
      "updated_at": "2020-06-19T17:03:55Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov, #12797 fundamentally enabled support for _relative_ paths as symlink targets, but the problem at hand is the lack of platform-native separator normalization, which renders the resulting symlinks broken.",
      "created_at": "2020-06-19T17:06:25Z",
      "updated_at": "2020-06-19T17:07:23Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov  Please see #13064 for what is still broken as of PowerShell Core 7.1.0-preview.4 (which should include #12797, right)?",
      "created_at": "2020-06-30T17:00:46Z",
      "updated_at": "2020-06-30T17:00:46Z"
    },
    {
      "author": "markm77",
      "author_association": "NONE",
      "body": "Thanks @mklement0 for what looks to be a thorough investigation of relative symlink behaviour and raising of issue https://github.com/PowerShell/PowerShell/issues/13064. I had made a note to follow-up further the particular issue I had and this discussion but in fact it seems you've covered everything in https://github.com/PowerShell/PowerShell/issues/13064 and in fact taught me how to write PowerShell tests (I'm new to PowerShell).... Cheers!",
      "created_at": "2020-07-01T09:24:48Z",
      "updated_at": "2020-07-01T09:24:48Z"
    },
    {
      "author": "ypid-geberit",
      "author_association": "NONE",
      "body": "I did not follow this issue in every detail so excuse me if I miss something. The initial issue was a cross platform standarized path separator (potentially a forward slashes). @iSazonov now closed this issue. Can you please give an overview why you think this is no longer valid so that the people who were subscribed on issue close events can follow along?",
      "created_at": "2020-07-01T13:58:31Z",
      "updated_at": "2020-07-01T13:58:31Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "It was never valid, as per https://github.com/PowerShell/PowerShell/issues/10509#issuecomment-644419471 .",
      "created_at": "2020-07-01T14:13:35Z",
      "updated_at": "2020-07-01T14:13:35Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Something like what @lzybkr  [proposed above](https://github.com/PowerShell/PowerShell/issues/10509#issuecomment-531029332) is still a perfectly reasonable - and presumably easy - thing to implement; to recap:\r\n\r\n> I think it would be nice if path completion used the path separator that appears explicitly in the completion text, and if there is none, then default to the platform native separator.\r\n\r\nIt is then the user's responsibility to avoid the - rare - edge cases where `/` still breaks on Windows (see [above](https://github.com/PowerShell/PowerShell/issues/10509#issuecomment-646732854)).\r\n\r\n",
      "created_at": "2020-07-01T14:28:53Z",
      "updated_at": "2020-07-01T14:28:53Z"
    },
    {
      "author": "phu54321",
      "author_association": "NONE",
      "body": "This causes a real headache when running wsl bash scripts via powershell. Like:\r\n\r\n```\r\nbash .\\updateTemplate.sh\r\n```\r\n\r\nThis should be autocompleted to\r\n\r\n```\r\nbash ./updateTemplate.sh\r\n```\r\n\r\nIs there any other workaround for this problem? specifically I'd be totally okay if PS autocompletes path with forward slashes on bash/WSL context only.",
      "created_at": "2020-08-24T07:13:25Z",
      "updated_at": "2020-08-24T07:13:25Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Is there any other workaround for this problem?\r\n\r\nCreate custom completor for bash.",
      "created_at": "2020-08-24T07:39:30Z",
      "updated_at": "2020-08-24T07:39:30Z"
    },
    {
      "author": "NicolaiMogensen",
      "author_association": "NONE",
      "body": "> > Is there any other workaround for this problem?\r\n> \r\n> Create custom completor for bash.\r\n\r\nHow do you do this? ",
      "created_at": "2020-10-23T11:15:32Z",
      "updated_at": "2020-10-23T11:15:32Z"
    },
    {
      "author": "atimholt",
      "author_association": "NONE",
      "body": "Are we not getting any more discussion on the baseless closure of this issue? This is a major annoyance for cross-platform work. Every single time I auto-complete paths that are fed to cross-platform tools or indirectly through wsl to Linux tools, I have to march my cursor backwards through the whole path and individually replace every single backslash with a slash. No one should ever have to work this way, and it genuinely makes Powershell as a command line nearly untenable.",
      "created_at": "2020-11-21T09:27:18Z",
      "updated_at": "2020-11-21T09:27:53Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "The reason it is closed is because a forward slash introduces command options in Microsoft Windows.  It has already been said and there is nothing more to be said.",
      "created_at": "2020-11-25T11:51:51Z",
      "updated_at": "2020-11-25T11:51:51Z"
    },
    {
      "author": "aaronfranke",
      "author_association": "NONE",
      "body": "@yecril71pl Except that there is a lot more to be said than what you have in your comment.\r\n\r\n* [Forward slashes work just fine as a path separator](https://github.com/PowerShell/PowerShell/issues/10509#issuecomment-644421763), so your argument isn't really a valid reason against this.\r\n\r\n* [Maybe it should be configurable by the user](https://github.com/PowerShell/PowerShell/issues/10509#issuecomment-616680441), even if it's disabled by default, it would make a lot of people happy.",
      "created_at": "2020-11-25T12:03:17Z",
      "updated_at": "2020-11-25T12:03:17Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> @yecril71pl Except that there is a lot more to be said than what you have in your comment.\r\n> \r\n>   * [Forward slashes work just fine as a path separator](https://github.com/PowerShell/PowerShell/issues/10509#issuecomment-644421763), so your argument isn't really a valid reason against this.\r\n> \r\n\r\nTry `CMD /CDIR /A`.\r\n\r\n",
      "created_at": "2020-11-25T12:07:37Z",
      "updated_at": "2020-11-25T12:08:58Z"
    },
    {
      "author": "aaronfranke",
      "author_association": "NONE",
      "body": "@yecril71pl That's calling CMD with PowerShell. This proposal is about PowerShell, not CMD.\r\n\r\nRegardless, the existence of edge cases does not dismiss the vast majority of use cases where forward slashes are valid and the many use cases described in this thread where they are preferred.",
      "created_at": "2020-11-25T12:14:35Z",
      "updated_at": "2020-11-25T12:14:35Z"
    },
    {
      "author": "rkitover",
      "author_association": "CONTRIBUTOR",
      "body": "Anyway, what we need to do is some pull requests to improve the situation. If they are reasonable and don't break anything I don't think the developers will object. We can't just change it to forward slash everywhere, for various reasons, but we can certainly make some improvements, for example:\r\n\r\n- Make completion separator configurable, this would have to work around some edge cases as noted here. You'd set this in your `$profile`. I would expect that Windows users/developers would generally prefer the backslash as the default as it is now.\r\n\r\n- Make separator in paths returned by cmdlets like `Resolve-Path` configurable to script, module and session scope. This would help a lot with cross-platform scripting.\r\n\r\nThings to do with .NET APIs may be much harder to deal with, but then if you filter them through the configurable `Resolve-Path` it should be OK.",
      "created_at": "2020-11-25T12:24:44Z",
      "updated_at": "2020-11-25T12:24:44Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> @yecril71pl That's calling CMD with PowerShell. This proposal is about PowerShell, not CMD.\r\n\r\nIf forward slashes are to be used in arguments for PowerShell cmdlets only, it can be done.  It would be a bit inconsistent though.\r\n\r\n> Regardless, the existence of edge cases does not dismiss the vast majority of use cases where forward slashes are valid and the many use cases described in this thread where they are preferred.\r\n\r\nAn edge case is in the eye of the beholder.\r\n",
      "created_at": "2020-11-25T12:29:29Z",
      "updated_at": "2020-11-25T12:29:29Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": ">   * Make completion separator configurable, this would have to work around some edge cases as noted here. You'd set this in your `$profile`. I would expect that Windows users/developers would generally prefer the backslash as the default as it is now.\r\n\r\n\r\nYou need to create a feature request for that.  This issue says *by default* and it is closed.\r\n\r\n",
      "created_at": "2020-11-25T14:20:39Z",
      "updated_at": "2020-11-25T14:20:39Z"
    },
    {
      "author": "chriskuech",
      "author_association": "NONE",
      "body": "Seems kind of weird that we are prioritizing the experience of a legacy corner case (platform-specific aliases nonetheless) over true cross-platform functionality as advertised.  I would anything that breaks script idempotency across platforms would be considered a bug.",
      "created_at": "2020-11-29T00:19:05Z",
      "updated_at": "2020-11-29T00:19:05Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "I don't understand this whole thread -- but recent comments are particularly frustrating. When someone complains that an issue has been closed improperly, you can't then use the fact that it's been closed as an argument that the issue is wrong.\r\n\r\nLet's go back to basics, instead.\r\n\r\nI think what you really want is just to change Tab Complection. In that case, you should edit TabExpansion2. Perhaps you could accomplish what you want by iterating the return from `CompletInput` checking the `CompletionMatches` for `ResultType -in \"ProviderContainer\", \"ProviderItem\"` and then replacing the character in the `CompletionText` (and `ListItemText`, if you like). **THAT** would be safe, because it would only affect authoring, and not the execution of existing scripts.  If that's enough, we should have a conversation about changing _just_ TabExpansion2 _by default_. I think shipping a forward-slash version in a module would be enough, but I wouldn't fight too hard against changing it.\r\n\r\nBut some explanation for why I think the broader default is a bad idea: the **default** path separator is **not** just used in Tab Completion, nor is it strictly a PowerShell choice in the Provider system.\r\n\r\nThe PowerShell implementation _switches_ from `\\` to `/` **because** `System.IO.Path.DirectorySeparatorChar` switches. You can see that in the `readonly` values of [SessionStateStrings](https://github.com/PowerShell/PowerShell/blob/master/src/System.Management.Automation/engine/SessionStateStrings.cs#L19-L37), which are what's used in the [`NormalizePath`](https://github.com/PowerShell/PowerShell/blob/master/src/System.Management.Automation/namespaces/NavigationProviderBase.cs#L868) method in the provider base class. Everything in PowerShell is based on the underlying .NET implementations, and there's simply no chance the .NET framework will change that, since it is in fact, correct: Windows uses backslashes. Trying to go against that .NET default value in a more general case than just TabExpansion would be _really hard work_.\r\n\r\nThe providers affect all of the Path cmdlets.  Changing that default would affect Convert-Path and Resolve-Path and through them, millions of lines of existing PowerShell code -- including code that is calling `Convert-Path` and passing the result into `cmd` and some old Windows APIs. Changing _that_ default value would be a **breaking change**. I don't think anyone has suggested any benefits from this change would justify breaking things, right?\r\n\r\nHaving said all of that, one final note: if you want to try it, it's possible that asking those constants settable would be a trivial way to get what you originally asked for -- even if it's a little unsafe. Someone should just try [switching it](https://github.com/PowerShell/PowerShell/blob/master/src/System.Management.Automation/engine/SessionStateStrings.cs#L19-L37) to see what happens. **If that is enough**, we could talk about making it settable...",
      "created_at": "2020-11-29T06:54:04Z",
      "updated_at": "2020-11-29T06:54:04Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> Seems kind of weird that we are prioritizing the experience of a legacy corner case (platform-specific aliases nonetheless) over true cross-platform functionality as advertised. I would anything that breaks script idempotency across platforms would be considered a bug.\r\n\r\nIf you want a simple and reliable system, you go for GNU/Linux, your problems are gone and the issue is moot.  If you have to use Microsoft Windows for any reason, be prepared to deal with legacy crap.\r\n\r\n> When someone complains that an issue has been closed improperly, you can't then use the fact that it's been closed as an argument that the issue is wrong.\r\n\r\nNobody said that the issue was wrong.",
      "created_at": "2020-11-29T12:29:29Z",
      "updated_at": "2020-11-29T12:29:29Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Here's a proposal that doesn't break backward compatibility, but offers only limited functionality - pragmatically speaking, it may be enough, however.\r\n\r\nIf there's interest and once there is sufficient agreement on the specifics, I suggest we eventually open a new, focused issue. \r\n\r\n---\r\n\r\nIntroduce a new Boolean preference variable (meaningful on Windows only), say `$PSUseSlash`, which, when set to `$true` (default is `$false`) controls the following behaviors (only):\r\n\r\n* It makes tab-completion use `/` \r\n\r\n  * Separately, and independently of the preference variable, @lzybkr's suggestion to infer from the user _having typed_ a `/` as part of their path _before completion_ that `/` should be used is worth implementing.\r\n\r\n* It makes (only) those cmdlets that output paths _as strings_ use `/` by default:\r\n  * `Convert-Path`, `Join-Path`, `Split-Path`\r\n  * To support ad-hoc use of `/` too, these cmdlets will get a `-UseSlash` (`-sl`) switch.\r\n  * To convert output from other cmdlets, such as `Get-ChildItem`, to `/`-based paths, it can simply be piped to `Convert-Path [-sl]`\r\n \r\nThe general idea is to focus on the _interactive_ experience: tab-completion and interactively obtaining paths to be copied elsewhere.\r\n\r\nNote that so as not to affect scripts and functions that may not expect `/`-based paths on Windows, it is best to define the preference variable as `$private:PSUseSlash = $true`\r\n\r\n\r\n---\r\n\r\nHere's a proof-of-concept, which can be pasted into or dot-sourced from a `$PROFILE` file as-is:\r\n\r\nThe only limitation is that when you tab-complete a _directory_ path, PowerShell invariably  _appends_ `\\` - something that cannot be prevented via the `TabExpansion2` function.\r\n\r\n<details>\r\n\r\n<summary><b>Source code:</b></summary>\r\n\r\n```powershell\r\n###\r\n# WINDOWS ONLY: Support for using \"/\" as the path separator in tab completion and with Convert-Path, Join-Path.\r\n# See https://github.com/PowerShell/PowerShell/issues/10509\r\n###\r\nif ($env:OS -eq 'Windows_NT') {\r\n  # On Windows only.\r\n\r\n  # Set the preference variable to use \"/\" by default.\r\n  # IMPORTANT: To limit this to INTERACTIVE calls (calls in the global scope),\r\n  #            i.e. to not affect (non-dot-sourced) scripts and functions,\r\n  #            the variable is made PRIVATE.\r\n  $private:PSUseSlash = $true\r\n\r\n  # TAB COMPLETION:\r\n  # Modified TabExpansion2 function that for provider items and containers (file and directory paths)\r\n  # replaces `\\` with `/` on Windows.\r\n  # CAVEAT:\r\n  #  The (only) LIMITATION is that when a *directory* path is completed, PowerShell appends a \"\\\",\r\n  #  which is outside the control of this function and would require PowerShell itself to respect\r\n  #  the $PSUseSlash preference variable.\r\n  function TabExpansion2 {\r\n\r\n    <# Options include:\r\n       RelativeFilePaths - [bool]\r\n           Always resolve file paths using Resolve-Path -Relative.\r\n           The default is to use some heuristics to guess if relative or absolute is better.\r\n\r\n     To customize your own custom options, pass a hashtable to CompleteInput, e.g.\r\n           return [System.Management.Automation.CommandCompletion]::CompleteInput($inputScript, $cursorColumn,\r\n               @{ RelativeFilePaths=$false }\r\n  #>\r\n\r\n    [CmdletBinding(DefaultParameterSetName = 'ScriptInputSet')]\r\n    Param(\r\n      [Parameter(ParameterSetName = 'ScriptInputSet', Mandatory = $true, Position = 0)]\r\n      [string] $inputScript,\r\n\r\n      [Parameter(ParameterSetName = 'ScriptInputSet', Position = 1)]\r\n      [int] $cursorColumn = $inputScript.Length,\r\n\r\n      [Parameter(ParameterSetName = 'AstInputSet', Mandatory = $true, Position = 0)]\r\n      [System.Management.Automation.Language.Ast] $ast,\r\n\r\n      [Parameter(ParameterSetName = 'AstInputSet', Mandatory = $true, Position = 1)]\r\n      [System.Management.Automation.Language.Token[]] $tokens,\r\n\r\n      [Parameter(ParameterSetName = 'AstInputSet', Mandatory = $true, Position = 2)]\r\n      [System.Management.Automation.Language.IScriptPosition] $positionOfCursor,\r\n\r\n      [Parameter(ParameterSetName = 'ScriptInputSet', Position = 2)]\r\n      [Parameter(ParameterSetName = 'AstInputSet', Position = 3)]\r\n      [Hashtable] $options = $null\r\n    )\r\n\r\n    End {\r\n      $completions = if ($psCmdlet.ParameterSetName -eq 'ScriptInputSet') {\r\n        [System.Management.Automation.CommandCompletion]::CompleteInput(\r\n          <#inputScript#>  $inputScript,\r\n          <#cursorColumn#> $cursorColumn,\r\n          <#options#>      $options)\r\n      }\r\n      else {\r\n        [System.Management.Automation.CommandCompletion]::CompleteInput(\r\n          <#ast#>              $ast,\r\n          <#tokens#>           $tokens,\r\n          <#positionOfCursor#> $positionOfCursor,\r\n          <#options#>          $options)\r\n      }\r\n\r\n      # If requested, replace \"\\\" with \"/\" in file-system path completions.\r\n      if (Get-Variable -ea Ignore -Scope 1 -ValueOnly PSUseSlash) {\r\n        for ($i = 0; $i -lt $completions.CompletionMatches.Count; ++$i) {\r\n          $cm = $completions.CompletionMatches[$i]\r\n          if ($cm.ResultType -notin 'ProviderItem', 'ProviderContainer') { continue } # Not a file-system path?\r\n          # Recrate the completion with \"\\\" replaced with \"/\".\r\n          $completions.CompletionMatches[$i] = [System.Management.Automation.CompletionResult]::new(\r\n            $cm.CompletionText.Replace('\\', '/'),\r\n            $cm.ListItemText,\r\n            $cm.ResultType,\r\n            $cm.ToolTip.Replace('\\', '/')\r\n          )\r\n        }\r\n      }\r\n\r\n      # Output the potentially modified completions.\r\n      $completions\r\n    }\r\n\r\n  }\r\n\r\n  # Wrapper function for Convert-Path that adds a -UseSlash (-sl) switch to request\r\n  # /-separated output. \r\n  # This switch is implied if $PSUseSlash is available in the caller's scope and set to $true (is truthy).\r\n  function Convert-Path {\r\n    <#\r\n      .FORWARDHELPTARGETNAME Microsoft.PowerShell.Management\\Convert-Path\r\n  #>\r\n    [CmdletBinding(DefaultParameterSetName = 'Path', HelpUri = 'https://go.microsoft.com/fwlink/?LinkID=2096588', RemotingCapability = 'None')]\r\n    param(\r\n      [Parameter(ParameterSetName = 'Path', Mandatory = $true, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]\r\n      [string[]]\r\n      ${Path},\r\n  \r\n      [Parameter(ParameterSetName = 'LiteralPath', Mandatory = $true, ValueFromPipelineByPropertyName = $true)]\r\n      [Alias('PSPath', 'LP')]\r\n      [string[]]\r\n      ${LiteralPath},\r\n  \r\n      [Alias('sl')] [switch] $UseSlash # custom switch\r\n    )\r\n  \r\n    begin {\r\n  \r\n      if ($PSBoundParameters.ContainsKey('UseSlash')) { \r\n        $null = $PSBoundParameters.Remove('UseSlash') \r\n      }\r\n      elseif ((Get-Variable -ea Ignore -ValueOnly PSUseSlash) -or (Get-Variable -ea Ignore -Scope 1 -ValueOnly PSUseSlash)) {\r\n        $UseSlash = $true\r\n      }\r\n      if ($env:OS -ne 'Windows_NT') { $UseSlash = $false } # Ignore on Unix.\r\n  \r\n      $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand('Microsoft.PowerShell.Management\\Convert-Path', 'Cmdlet')\r\n      $scriptCmd = if ($UseSlash) {\r\n        { & $wrappedCmd @PSBoundParameters | ForEach-Object { $_.Replace('\\', '/') } }\r\n      }\r\n      else {\r\n        { & $wrappedCmd @PSBoundParameters }\r\n      }\r\n  \r\n      $steppablePipeline = $scriptCmd.GetSteppablePipeline($myInvocation.CommandOrigin)\r\n      $steppablePipeline.Begin($PSCmdlet)\r\n    }\r\n  \r\n    process {\r\n      try {\r\n        $null = $steppablePipeline.Process($_)\r\n      }\r\n      catch {\r\n        $PSCmdlet.ThrowTerminatingError($_)\r\n      }\r\n    }\r\n  \r\n    end { try { $steppablePipeline.End() } catch { $PSCmdlet.ThrowTerminatingError($_) } }\r\n  \r\n  }\r\n  \r\n  \r\n  # Ditto for Join-Path\r\n  function Join-Path {\r\n    <#\r\n      .FORWARDHELPTARGETNAME Microsoft.PowerShell.Management\\Join-Path\r\n  #>  \r\n    [CmdletBinding(HelpUri = 'https://go.microsoft.com/fwlink/?LinkID=2096811')]\r\n    param(\r\n      [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]\r\n      [Alias('PSPath')]\r\n      [string[]]\r\n      ${Path},\r\n    \r\n      [Parameter(Mandatory = $true, Position = 1, ValueFromPipelineByPropertyName = $true)]\r\n      [AllowEmptyString()]\r\n      [AllowNull()]\r\n      [string]\r\n      ${ChildPath},\r\n    \r\n      [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true, ValueFromRemainingArguments = $true)]\r\n      [AllowNull()]\r\n      [AllowEmptyString()]\r\n      [AllowEmptyCollection()]\r\n      [string[]]\r\n      ${AdditionalChildPath},\r\n    \r\n      [switch]\r\n      ${Resolve},\r\n    \r\n      [Parameter(ValueFromPipelineByPropertyName = $true)]\r\n      [pscredential]\r\n      [System.Management.Automation.CredentialAttribute()]\r\n      ${Credential},\r\n    \r\n      [Alias('sl')] [switch] $UseSlash # custom switch\r\n    )\r\n      \r\n    begin {\r\n      try {\r\n        if ($PSBoundParameters.ContainsKey('UseSlash')) { \r\n          $null = $PSBoundParameters.Remove('UseSlash') \r\n        }\r\n        elseif ((Get-Variable -ea Ignore -ValueOnly PSUseSlash) -or (Get-Variable -ea Ignore -Scope 1 -ValueOnly PSUseSlash)) {\r\n          $UseSlash = $true\r\n        }\r\n        if ($env:OS -ne 'Windows_NT') { $UseSlash = $false } # Ignore on Unix.\r\n    \r\n        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand('Microsoft.PowerShell.Management\\Join-Path', 'Cmdlet')\r\n        $scriptCmd = if ($UseSlash) {\r\n          { & $wrappedCmd @PSBoundParameters | ForEach-Object { $_.Replace('\\', '/') } }\r\n        }\r\n        else {\r\n          { & $wrappedCmd @PSBoundParameters }\r\n        }      \r\n    \r\n        $steppablePipeline = $scriptCmd.GetSteppablePipeline($myInvocation.CommandOrigin)\r\n        $steppablePipeline.Begin($PSCmdlet)\r\n      }\r\n      catch {\r\n        $PSCmdlet.ThrowTerminatingError($_)\r\n      }\r\n    }\r\n    \r\n    process {\r\n      try {\r\n        $null = $steppablePipeline.Process($_)\r\n      }\r\n      catch {\r\n        $PSCmdlet.ThrowTerminatingError($_)\r\n      }\r\n    }\r\n    \r\n    end { try { $steppablePipeline.End() } catch { $PSCmdlet.ThrowTerminatingError($_) } }\r\n    \r\n  }\r\n  \r\n\r\n  # Ditto for Split-Path\r\n  function Split-Path {\r\n    <#\r\n      .FORWARDHELPTARGETNAME Microsoft.PowerShell.Management\\Split-Path\r\n  #>    \r\n    [CmdletBinding(DefaultParameterSetName = 'ParentSet', SupportsTransactions = $true, HelpUri = 'https://go.microsoft.com/fwlink/?LinkID=113404')]\r\n    param(\r\n      [Parameter(ParameterSetName = 'NoQualifierSet', Mandatory = $true, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]\r\n      [Parameter(ParameterSetName = 'LeafSet', Mandatory = $true, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]\r\n      [Parameter(ParameterSetName = 'QualifierSet', Mandatory = $true, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]\r\n      [Parameter(ParameterSetName = 'ParentSet', Mandatory = $true, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]\r\n      [Parameter(ParameterSetName = 'IsAbsoluteSet', Mandatory = $true, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]\r\n      [string[]]\r\n      ${Path},\r\n  \r\n      [Parameter(ParameterSetName = 'LiteralPathSet', Mandatory = $true, ValueFromPipelineByPropertyName = $true)]\r\n      [Alias('PSPath')]\r\n      [string[]]\r\n      ${LiteralPath},\r\n  \r\n      [Parameter(ParameterSetName = 'QualifierSet', Position = 1, ValueFromPipelineByPropertyName = $true)]\r\n      [switch]\r\n      ${Qualifier},\r\n  \r\n      [Parameter(ParameterSetName = 'NoQualifierSet', ValueFromPipelineByPropertyName = $true)]\r\n      [switch]\r\n      ${NoQualifier},\r\n  \r\n      [Parameter(ParameterSetName = 'ParentSet', ValueFromPipelineByPropertyName = $true)]\r\n      [switch]\r\n      ${Parent},\r\n  \r\n      [Parameter(ParameterSetName = 'LeafSet', ValueFromPipelineByPropertyName = $true)]\r\n      [switch]\r\n      ${Leaf},\r\n  \r\n      [switch]\r\n      ${Resolve},\r\n  \r\n      [Parameter(ParameterSetName = 'IsAbsoluteSet')]\r\n      [switch]\r\n      ${IsAbsolute},\r\n  \r\n      [Parameter(ValueFromPipelineByPropertyName = $true)]\r\n      [pscredential]\r\n      [System.Management.Automation.CredentialAttribute()]\r\n      ${Credential},\r\n    \r\n      [Alias('sl')] [switch] $UseSlash # custom switch\r\n    )\r\n\r\n    begin {\r\n      try {\r\n        if ($PSBoundParameters.ContainsKey('UseSlash')) { \r\n          $null = $PSBoundParameters.Remove('UseSlash') \r\n        }\r\n        elseif ((Get-Variable -ea Ignore -ValueOnly PSUseSlash) -or (Get-Variable -ea Ignore -Scope 1 -ValueOnly PSUseSlash)) {\r\n          $UseSlash = $true\r\n        }\r\n        if ($env:OS -ne 'Windows_NT') { $UseSlash = $false } # Ignore on Unix.\r\n    \r\n        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand('Microsoft.PowerShell.Management\\Split-Path', 'Cmdlet')\r\n        $scriptCmd = if ($UseSlash -and -not $IsAbsolute) {\r\n          # note: -IsAbsolute returns a [bool]\r\n          { & $wrappedCmd @PSBoundParameters | ForEach-Object { $_.Replace('\\', '/') } }\r\n        }\r\n        else {\r\n          { & $wrappedCmd @PSBoundParameters }\r\n        }      \r\n    \r\n        $steppablePipeline = $scriptCmd.GetSteppablePipeline($myInvocation.CommandOrigin)\r\n        $steppablePipeline.Begin($PSCmdlet)\r\n      }\r\n      catch {\r\n        $PSCmdlet.ThrowTerminatingError($_)\r\n      }\r\n    }\r\n    \r\n    process {\r\n      try {\r\n        $null = $steppablePipeline.Process($_)\r\n      }\r\n      catch {\r\n        $PSCmdlet.ThrowTerminatingError($_)\r\n      }\r\n    }\r\n    \r\n    end { try { $steppablePipeline.End() } catch { $PSCmdlet.ThrowTerminatingError($_) } }\r\n    \r\n  }\r\n\r\n} # end: use of \"/\" on Windows.\r\n```\r\n\r\n</details>",
      "created_at": "2020-12-07T22:31:30Z",
      "updated_at": "2020-12-08T13:19:03Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "If it is to be named `PSUseSlash`, the non\u2011standard value should be `'/'`.  I can think of a better names though, like `PSPathSeparator` or `PSUseForwardSlashOption`.",
      "created_at": "2020-12-13T12:13:16Z",
      "updated_at": "2020-12-13T12:13:16Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "The proposed `PSUseSlash` is a _Boolean_ variable: it's a simple switch to opt into using `/` rather than `\\` on Windows.\r\nThere is no reasons to spell out `/`, not least because this is _not_ about being able to set an arbitrary separator.\r\n\r\n\"Slash\" implies \"forward slash\", so I didn't want to spell out the \"forward\" part, for brevity (see below).\r\n\r\nI don't think there's value in offering the _inverse_ functionality: allowing use of  `\\` as an opt-in on _Unix_.\r\nOr does anybody think that's needed?\r\n\r\n---\r\n\r\nAs for a better name:\r\n\r\nTo be clear, Im not wedded to `$PSUseSlash`, but here's why I chose it:\r\n\r\n* It was meant to strike a balance between verbosity and brevity.\r\n\r\n* It was meant to parallel the proposed `-UseSlash` switch, which I also did not want to be too wordy (the proposed `-sl` alias not withstanding).\r\n\r\nAs for your suggestions:\r\n\r\n* `PSPathSeparator` again suggests the ability to freely set the separator, which I don't think is called for,\r\n\r\n* `PSUseForwardSlashOption` contains the - in my estimation - redundant \"Forward\", and an \"Option\" suffix is never necessary in a preference variable.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-12-13T14:05:02Z",
      "updated_at": "2020-12-13T14:05:02Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "A `char` value is more friendly than a `bool` when using the variable, e.g.\r\n\r\n```powershell\r\n$components -join $PSPathSeparator\r\n```\r\nvs.\r\n```powershell\r\n$components -join (if ($PSUseSlash) { '/' } else { '\\\\' })\r\n```\r\n",
      "created_at": "2020-12-14T01:04:04Z",
      "updated_at": "2020-12-14T01:04:04Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@lzybkr, note that:\r\n\r\n* `-join` is a general-purpose operator, not specific to joining _paths_\r\n\r\n* whereas it is the `Join-Path` cmdlet that is path-specific and that  the proposal is for `$PSUseSlash=$true` (with `$private:PSUseSlash=$true` only in the very same scope)  to make `Join-Path` (as well as `Convert-Path` and `Split-Path`) respect this preference variable so that _no explicit reference to a path separator is needed_.\r\n\r\nTherefore, to get `/`-separated paths on Windows::\r\n\r\n* With  `$PSUseSlash=$true`  in effect, `Join-Path @components` will do.\r\n\r\n* Otherwise, on demand, use `Join-Path -sl @components` (`-sl` being the alias of `-UseSlash`)\r\n\r\n",
      "created_at": "2020-12-14T02:34:51Z",
      "updated_at": "2020-12-14T13:00:27Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "My point applies equally to the implementation of `Join-Path`.\r\n\r\nIt may feel like a `char` value is unnecessarily general, but in my opinion, it is simpler to understand and avoids the need for an `if` statement that might arise in places you haven't anticipated.",
      "created_at": "2020-12-14T03:29:07Z",
      "updated_at": "2020-12-14T03:29:07Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> It was meant to strike a balance between verbosity and brevity.\r\n\r\nPreference variables should have more descriptive names than commonly used variables.\r\n\r\n>   `PSUseForwardSlashOption` contains the - in my estimation - redundant \"Forward\", and an \"Option\" suffix is never necessary in a preference variable.\r\n\r\n*Option* to mean that the value is of logical type.\r\n",
      "created_at": "2020-12-14T09:43:08Z",
      "updated_at": "2020-12-14T09:56:56Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> My point applies equally to the implementation of `Join-Path`.\r\n> \r\n> It may feel like a `char` value is unnecessarily general, but in my opinion, it is simpler to understand and avoids the need for an `if` statement that might arise in places you haven't anticipated.\r\n\r\nI actually had the following code in mind: \r\n\r\n```powershell\r\nIF ($PSPATHSEPARATOR -EQ '/') { '/' } ELSE { GET-SYSTEMPATHSEPARATOR }\r\n```\r\n\r\nThis is unless we could error out on setting `PSPATHSEPARATOR` to an invalid value.",
      "created_at": "2020-12-14T09:54:04Z",
      "updated_at": "2020-12-14T09:54:04Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@lzybkr \r\n\r\n> It may feel like a char value is unnecessarily general\r\n\r\nYes, that was my concern - but I do see the value of having a variable that directly contains the separator, so I agree.\r\n(Just needs to be documented clearly and assigning to the variable must perform validation - see below.)\r\n\r\n@yecril71pl \r\n\r\n> This is unless we could error out on setting PSPATHSEPARATOR to an invalid value.\r\n\r\nIndeed I think we should. Here's what makes sense to me.\r\n\r\n* `$PSPathSeparator` should default to the platform-native separator, and should only be defined in the _global_ scope (an `AllScope` variable with the value set to `/` on Windows could break existing code).\r\n* The only values you should be able to assign `$PSPathSeparator` are `\\` or `/`\r\n   * `[ValidateSet('\\', '/')] $PSPathSeparator = '@' # boom`\r\n      * As an aside: this constraint should apply to local copies of the variable in _any_ scope, something we currently have a problem with: #3483\r\n   * On Unix, it is debatable whether we should allow setting `\\`; if we disallow it, we would in effect make the variable a constant there.\r\n\r\n---\r\n\r\nFinally, from the bike-shedding department: Unfortunately, .NET has introduced terminology confusion with its `[io.path]::PathSeparator` and `[io.path]::DirectorySeparatorChar` properties: leaving the inconsistency with respect to including the word \"Char\" aside, the former - confusingly - refers to the separator used for the entries in the `PATH` _environment variable_ and it is the latter that is more commonly referred to as the path separator.\r\n\r\nIf we follow the logic of these terms, we should choose `$PSItemSeparator`, \"Item\" being the generalization of \"Directory\".\r\n\r\nI do not feel strongly either way.\r\n\r\n(If changing the .NET properties were an option, I'd choose `[io.path]::PathVariableSeparator` and `[io.path]::PathSeparator`)\r\n\r\n\r\n",
      "created_at": "2020-12-14T12:58:26Z",
      "updated_at": "2020-12-14T13:01:32Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Unfortunately, there's a conceptual problem with the `$PSPathSeparator` preference variable:\r\n\r\nAs stated, so as not to risk breaking existing code, it's important to limit the behavior to _interactive_ use, by defining the variable as `$private:PSPathSeparator = '/'` in the _global_ scope.\r\n\r\nThis requires _recreating_ the variable (which is awkward to begin with), and once it is recreated, _descendent_ scopes (scripts, functions) will then not see a `$PSPathSeparator` variable at all, even though it would be helpful to have it reflect the platform's default separator in any scope where it isn't overridden.\r\n",
      "created_at": "2020-12-15T02:23:16Z",
      "updated_at": "2020-12-15T02:23:16Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "\r\n> This requires _recreating_ the variable (which is awkward to begin with), and once it is recreated, _descendent_ scopes (scripts, functions) will then not see a `$PSPathSeparator` variable at all, even though it would be helpful to have it reflect the platform's default separator in any scope where it isn't overridden.\r\n\r\nWe could always have `Get-PSPathSeparator` for that purpose.  With `Get-SystemPathSeparator` added for Premium users :wink:  ",
      "created_at": "2020-12-15T15:17:12Z",
      "updated_at": "2020-12-15T15:17:12Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> (If changing the .NET properties were an option, I'd choose `[io.path]::PathVariableSeparator` and `[io.path]::PathSeparator`)\r\n\r\n`[io.path]::SearchPathSeparator` would be OK with me.",
      "created_at": "2020-12-15T15:22:29Z",
      "updated_at": "2020-12-15T15:22:29Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> We could always have `Get-PSPathSeparator` for that purpose\r\n\r\nThe problem is that this is both syntactically awkward (`'a', 'b' -join (Get-PSPathSeparator)`) and inefficient (cmdlet call).\r\n\r\nConceptually, the path separator is a _constant_ (an _automatic variable_ in PowerShell terms), and with the proposed configurability we're turning it into _preference variable_. Either way, a _variable_ is the expected - and efficient - form.\r\n\r\n",
      "created_at": "2020-12-15T16:58:14Z",
      "updated_at": "2020-12-15T16:58:14Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> Conceptually, the path separator is a _constant_ (an _automatic variable_ in PowerShell terms), and with the proposed configurability we're turning it into _preference variable_. Either way, a _variable_ is the expected - and efficient - form.\r\n\r\nA variable that you cannot change to is not a variable.  It is an observable, equivalent to a parameterless function. I have no data regarding the (in)efficiency of a cmdlet call in PowerShell but if it is a problem for built-in cmdlets, it is a problem that should be solved.",
      "created_at": "2020-12-15T17:23:04Z",
      "updated_at": "2020-12-15T17:23:04Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Even what is _conceptually_ a constant in PowerShell is surfaced _as a variable_, such as `$true` and `$false`, for instance (and here we _will_ have a bona fide variable) - and it makes the most sense to surface the path separator as that - just like, by analogy, `[IO.Path]::DirectorySeparatorChar` is a _property_, not a _method_.",
      "created_at": "2020-12-15T17:35:45Z",
      "updated_at": "2020-12-15T17:43:21Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "What would offer a solution is if we had a _calculated_ automatic read-only variable, analogous to a `ScriptProperty` ETS member, which we could combine with Boolean preference variable `$PSUseSlash` (name negotiable, as discussed).\r\n\r\nIn fact, we already have such automatic variables, e.g., `$PWD`, so I guess we could make that happen for an all-scopes automatic `$PSPathSeparator` variable too, whose logic would be:\r\n\r\n* On Windows, if a `$PSUseSlash` preference variable is visible in the current scope and is set to `$true`, return `/`\r\n* Otherwise, return the platform-native separator.\r\n\r\nThat is, `$PSPathSeparator` would become an independent read-only variable that reflects the effective path separator with respect to tab-completion, `Convert-Path`, `Join-Path`, `Split-Path`. Even in the absence of `$PSUseSlash` it would be useful for referring to the platform-native separator.\r\n\r\n`$PSUseSlash` would then not be predefined at all, and could easily be created with `$private:PSUseSlash = $true` to avoid affecting child scopes, as needed.",
      "created_at": "2020-12-15T20:28:55Z",
      "updated_at": "2020-12-15T20:39:56Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@mklement0 `$PSPathSeparator` seems unnecessary long. We already have `$OFS` in PowerShell to identify the output field separator. I think it would be better to use a terse variable name for ease of use in scripts.\r\n\r\nDo we really need two variables for this? I've read the reasoning you have provided, but pairing up variables for this single purpose seems unnecessary to me. My preference would be to have `$OPS` (output path separator, named appropriately to match the output field separator variable), and define it such that assigning any value other than `\\` or `/` results in it being reset to the default value for that OS. You can still use the `private:` scope qualifier to assign a value that is only in a specific scope, and you can use the variable easily in scripts (e.g. `-join $OPS`).\r\n\r\nI haven't put a ton of thought into this, but up front I feel going with a terse name and avoiding having to work with multiple variables is better for scripters in this case.",
      "created_at": "2020-12-22T23:28:32Z",
      "updated_at": "2020-12-22T23:28:32Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@KirkMunro, I'd be fine with `$OPS`, but note that you still need _two_ variables, namely if you want `$OPS` to _always_ reflect the effective or platform-native separator, so that you can always rely on being able to use `$OPS` _explicitly_.\r\n\r\n`$OFS`, by contrast is _not_ defined by default, even though its effective value is a space.\r\n\r\nIn short:\r\n\r\n* If we follow the single-variable, define-on-demand `$OFS` model, we lose the ability to rely on `$OPS` to always reflect the effective - opt-in or platform-native - separator.\r\n\r\n* If we want the latter, we need a dynamic all-scopes variable that refers to a separate, define-on-demand, possibly private preference variable and defaults to the platform-native separator in its absence.\r\n\r\n",
      "created_at": "2020-12-23T13:17:20Z",
      "updated_at": "2020-12-23T16:44:16Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> (e.g. `-join $OPS`)\r\n\r\nThis particular example should be deprecated to `Join-Path`.",
      "created_at": "2020-12-23T17:00:39Z",
      "updated_at": "2020-12-23T17:00:39Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "> `$OFS`, by contrast is _not_ defined by default, even though its effective value is a space.\r\n\r\nI've never liked this, tbh, and wonder what is gained by having that variable undefined by default. I would like `$OPS` to be defined by default so that I can rely on it being there when running scripts that use it.\r\n\r\nAlso, if I ever want to know the platform-native separator, I can just invoke `[System.IO.Path]::DirectorySeparatorChar`, right? I don't need to have a variable to wrap that field.\r\n\r\n> > (e.g. `-join $OPS`)\r\n>\r\n> This particular example should be deprecated to `Join-Path`.\r\n\r\nNo, it should not.\r\n\r\nUsing `Join-Path` with `-Path`, `-ChildPath`, and `-AdditionalChildPath` parameters is cumbersome in scripts. When you want to join a bunch of different segments, `-join` is much easier to type, and I would argue it's easier to understand as well.",
      "created_at": "2020-12-23T20:34:08Z",
      "updated_at": "2020-12-23T20:34:08Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> Using `Join-Path` with `-Path`, `-ChildPath`, and `-AdditionalChildPath` parameters is cumbersome in scripts.\r\n\r\nIndeed.  That is why you should specify them as positional parameters instead.",
      "created_at": "2020-12-23T20:49:41Z",
      "updated_at": "2020-12-23T20:49:41Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> Also, if I ever want to know the platform-native separator, I can just invoke `[System.IO.Path]::DirectorySeparatorChar`\r\n\r\nYes, but that's not only a keyboardful, if you will, but also hard to remember.\r\n\r\n> I've never liked this, tbh, and wonder what is gained by having that variable undefined by default.\r\n\r\nAgreed, and that's why `$OPS` would be a dynamic all-scopes variable, and only the actual, separate preference variable that opts into using `/` on Windows too would be undefined by default (tentatively named `$PSUseSlash` in previous comments).\r\n\r\nThe sole reason this is necessary is the absence of _lexical_ scoping in PowerShell.\r\n\r\nWhile the problem of a preference variable affecting all child scopes due to dynamic scoping applies to _all_ preference variables (in the case of the global scope even affecting all modules), with the one at hand it would be especially problematic, because:\r\n\r\n* You'll primarily set it in the _global_ scope, for interactive use.\r\n* Since all code run in that session is then affected, it can break (e.g., certain COM APIs (e.g., `Shell.Application`, `Excel.Application`) and some `cmd.exe` commands only work with `\\`, and, last but not least, user code that operates on the fixed assumption that `\\` is the path separator).\r\n\r\nHence the need to have an _undefined by default_ variable, that you can easily make _private_: `$private:PSUseSlash = $true`. Of course, if you _do_ want all child scopes to use `/`, you're free to use `$PSUseSlash = $true` in any scope.\r\n\r\nAgain, the all-scopes `$OPS` automatic variable would then either respect a `$PSUseSlash` variable visible to the current scope, and report `[System.IO.Path]::DirectorySeparatorChar` otherwise.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-12-23T20:53:04Z",
      "updated_at": "2021-02-22T20:43:47Z"
    },
    {
      "author": "rkitover",
      "author_association": "CONTRIBUTOR",
      "body": "@mklement0 Hey, do you have any interest in following up on your ideas? I and I'm sure many others would love to see better forward slash support on Windows.",
      "created_at": "2021-12-22T06:28:54Z",
      "updated_at": "2021-12-22T06:28:54Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @rkitover - while I think pursuing this is worthwhile, [I hope someone else takes this on](https://github.com/PowerShell/PowerShell/pull/10238#issuecomment-830406280).",
      "created_at": "2021-12-23T04:55:18Z",
      "updated_at": "2021-12-23T04:55:18Z"
    },
    {
      "author": "doctordns",
      "author_association": "COLLABORATOR",
      "body": "> If it is to be named `PSUseSlash`, the non\u2011standard value should be `'/'`. I can think of a better names though, like `PSPathSeparator` or `PSUseForwardSlashOption`.\r\n\r\nThe word 'slash' has a colloquial meaning, at least here in the UK and connotes urination, typically by a male. Thus, a variable named PSSlash sounds somewhat inappropriate. Just saying...",
      "created_at": "2021-12-23T15:18:54Z",
      "updated_at": "2021-12-23T18:22:05Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@doctordns Don't use street and prison jargon in this respected community \r\nhttps://github.com/PowerShell/PowerShell/blob/master/CODE_OF_CONDUCT.md\n\n<blockquote><img src=\"https://repository-images.githubusercontent.com/49609581/aad0ad80-cdec-11ea-8248-a37bc0571bfd\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/PowerShell/PowerShell\">PowerShell/CODE_OF_CONDUCT.md at master \u00b7 PowerShell/PowerShell</a></strong></div><div>PowerShell for every system! Contribute to PowerShell/PowerShell development by creating an account on GitHub.</div></blockquote>",
      "created_at": "2021-12-23T18:22:09Z",
      "updated_at": "2021-12-23T18:22:11Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov , I think @doctordns' point was that _a name being considered in this discussion for an official preference variable_ might be offensive to some, and he explained why.\r\n",
      "created_at": "2021-12-23T18:34:19Z",
      "updated_at": "2021-12-24T04:41:17Z"
    },
    {
      "author": "doctordns",
      "author_association": "COLLABORATOR",
      "body": "@iSazonov - my post was meant only to convey that the proposed name had serious issues in certain locales. For what it's worth,. the term is NOT prison-related, but is one in general use in certain more laddish circles at least here in the UK. I found the proposed name offensive and tried as politely as I could, explained why. Thanks @mklement0 for understanding. \r\n\r\nPlease re-consider your reaction.",
      "created_at": "2021-12-23T19:37:31Z",
      "updated_at": "2021-12-24T04:41:27Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> @iSazonov - my post was meant only to convey that the proposed name had serious issues in certain locales. For what it's worth,. the term is NOT prison-related, but is one in general use in certain more laddish circles at least here in the UK. I found the proposed name offensive and tried as politely as I could, explained why. Thanks @mklement0 for understanding.\r\n\r\nAccording to [KCharSelect](https://utils.kde.org/projects/kcharselect/) the official name of the character is SOLIDUS.  However, the name should express the *function* of the character and not the character itself.",
      "created_at": "2021-12-23T21:36:18Z",
      "updated_at": "2021-12-24T04:42:02Z"
    },
    {
      "author": "aaronfranke",
      "author_association": "NONE",
      "body": "Yes, there's no need to have \"Slash\" in the name. `PSPathSeparatorChar` or similar makes sense to me.",
      "created_at": "2021-12-23T22:40:47Z",
      "updated_at": "2021-12-23T22:40:47Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Please re-consider your reaction.\r\n\r\n> @iSazonov , I think @doctordns' point was that _a name being considered in this discussion for an official preference variable_ might be offensive to some, and **he explained why**.\r\n\r\n_Such discussions are not acceptable here._ \r\nOfficial linguistic sources do not consider the term offensive. You can find thousands of uses of the term in GitHub repositories and directly in the code.\r\nThe correct procedure is described in the CoC. If anyone has a different opinion, follow the CoC. https://github.com/PowerShell/PowerShell/blob/master/CODE_OF_CONDUCT.md\n\n<blockquote><img src=\"https://repository-images.githubusercontent.com/49609581/aad0ad80-cdec-11ea-8248-a37bc0571bfd\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/PowerShell/PowerShell\">PowerShell/CODE_OF_CONDUCT.md at master \u00b7 PowerShell/PowerShell</a></strong></div><div>PowerShell for every system! Contribute to PowerShell/PowerShell development by creating an account on GitHub.</div></blockquote>",
      "created_at": "2021-12-24T04:41:03Z",
      "updated_at": "2021-12-24T04:41:05Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> _Such discussions are not acceptable here._ Official linguistic sources do not consider the term offensive. You can find thousands of uses of the term in GitHub repositories and directly in the code. The correct procedure is described in the CoC. If anyone has a different opinion, follow the CoC. https://github.com/PowerShell/PowerShell/blob/master/CODE_OF_CONDUCT.md\r\n\r\nThere is no procedure over there.\n\n<blockquote><img src=\"https://repository-images.githubusercontent.com/49609581/aad0ad80-cdec-11ea-8248-a37bc0571bfd\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/PowerShell/PowerShell\">PowerShell/CODE_OF_CONDUCT.md at master \u00b7 PowerShell/PowerShell</a></strong></div><div>PowerShell for every system! Contribute to PowerShell/PowerShell development by creating an account on GitHub.</div></blockquote>",
      "created_at": "2021-12-24T12:45:10Z",
      "updated_at": "2021-12-24T19:03:04Z"
    },
    {
      "author": "doctordns",
      "author_association": "COLLABORATOR",
      "body": "@yecril71pl - sorry I disagree. A proposal was made for a parameter name where the name was one that was, shall we say, unsavoury. In certain locales, it was offensive, as I attempted to explain. The juxtaposition of characters could convey things that are inappropriate If you look carefuly, you may see the issue (pm me if not and I will explain why). I can not find anything in the code of conduct that says we can not discuss rejecting offensive (to some) names. \r\n\r\n If we have to have this parameter (as I think we probably should) lets make the name inoffensive where we can. ",
      "created_at": "2021-12-24T14:57:36Z",
      "updated_at": "2021-12-24T19:03:15Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Agreed, @doctordns. (Note that @yecril71pl may have been agreeing with part of your statement, namely that the code of conduct - sensibly - contains no prohibition against discussing whether a public-facing name is inappropriate.)\r\n\r\n@iSazonov, the only plausible explanation for your comments is that you fundamentally misunderstood the nature of the discussion.\r\n\r\n",
      "created_at": "2021-12-24T15:09:52Z",
      "updated_at": "2021-12-24T19:03:24Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "To be clear, my objection was not to _the warning_, but to the sordid details. \r\n_This is categorically unacceptable in the repository._\r\nA gentle warning is enough for PowerShell  Committee to take it into account in case they discuss the issue. (For the record, Microsoft already has a list of forbidden terms.)\r\n\r\nOnce again, please stop discussing in this direction and switch to constructive suggestions.\r\nIf someone wants to clean up all of GitHub from millions of uses of the term, they can find the contacts of Microsoft responsible group at CoC.\r\nPlease read FAQ there to understand the resolution process. Notice, the process is _private_ - maybe it will give you an understanding of why you shouldn't discuss it publicly here.\r\nIf you still prefer otherwise, please use other forums. Here focus on PowerShell development.\r\nThanks for understanding!\r\n",
      "created_at": "2021-12-24T19:02:34Z",
      "updated_at": "2021-12-24T19:02:34Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> To be clear, my objection was not to the warning, but to the sordid details.\r\n\r\nThere were no sordid details - unless you consider a clinical term for a bodily function \"sordid\". \r\n\r\nAnd it should be self-evident that _some_ description of the potentially offensive meaning of the term in question is necessary.\r\n\r\nTo also be clear: I have no stake in this discussion (to me the term isn't offensive), but I find this baffling overreaction to a concern voiced by a user in good faith disconcerting.\r\n\r\n---\r\n\r\nAs for the actual discussion at hand:\r\n\r\nFWIW, the current references in the help topics don't use the term _in isolation_ (and I'm not aware of code elements using it at all)  - they use _backslash_ and _forward slash_ (again, not a personal concern of mine).\r\n\r\nAs for _constructive_ suggestions: the discussion already encompasses that too - see @aaronfranke's [comment](https://github.com/PowerShell/PowerShell/issues/10509#issuecomment-1000551038).\r\n\r\nI understand your argument that the word is commonly used and should therefore be regarded as acceptable, and perhaps that is ultimately the proper resolution to this discussion.\r\n\r\nBut there should be always be room for such a discussion (as long as the language used in the discussion doesn't violate the [CoC](https://opensource.microsoft.com/codeofconduct/), which I think was definitely _not_ the case here).\r\n\r\n",
      "created_at": "2021-12-24T19:34:53Z",
      "updated_at": "2021-12-24T19:34:53Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "Or we could just skip using that \"word\" altogether Prince style, and use images instead:  \ud83e\udd23\r\n\r\n![image](https://user-images.githubusercontent.com/5177512/147370582-e53efe90-a33f-453b-97ae-e34bc595a577.png)\r\n\r\nOK, had my fun, backing away from the keyboard.",
      "created_at": "2021-12-24T19:48:10Z",
      "updated_at": "2021-12-24T19:48:10Z"
    }
  ],
  "created_at": "2019-09-10T22:57:34Z",
  "number": 10509,
  "state": "closed",
  "title": "Use forward slashes by default in Windows",
  "updated_at": "2021-12-25T08:57:56Z"
}