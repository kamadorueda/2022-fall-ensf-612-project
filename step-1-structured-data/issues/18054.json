{
  "_url": "https://github.com/PowerShell/PowerShell/issues/18054",
  "author": "iRon7",
  "body": "### Summary of the new feature / enhancement\r\n\r\nAs a user I would like to have an idiomatic PowerShell solution to set the `-ThrottleLimit` in the script scope or global scope:\r\nSee: [What is the best way to structure an advanced multi-threaded Powershell function to work both on the pipeline as well as non-pipeline calls?](https://stackoverflow.com/a/73646440/1701026)\r\nRelated: #16898 [ ThrottleLimit not respected by ForEach-Object $SCRIPTBLOCK -Parallel -InputObject $INPUTOBJECT -ThrottleLimit 8 -AsJob](https://github.com/PowerShell/PowerShell/issues/16898)\r\n\r\n\r\n\r\n### Proposed technical implementation details (optional)\r\n\r\nThis might be a specific `-ThrottleLimit` parameter for the `ForEach-Object -Parallel` cmdlet or a more general solution as scope based parameters: e.g.:  `-Script:ThrottleLimit 16` or even a more idiomatic PowerShell steppable pipeline syntax (based on the existing `Invoke-Command` cmdlet?):\r\nA (friendly) steppablePipeline might actually come at hand everywhere were it is required to invoke a cmdlet multiple time from within a `Process` block, as e.g.: [Split CSV with powershell](https://stackoverflow.com/questions/14754287) where I would like reuse a steppable pipeline for about 10,000 iterations and than open a new one.\r\n\r\nWishful thinking:\r\n```PowerShell\r\n[CmdletBinding()]\r\nparam (\r\n    [Parameter(Mandatory,Position = 0,ValueFromPipeline)]\r\n    [string[]]\r\n    $InputPath\r\n)\r\nbegin {\r\n    $PSBoundParameters += @{\r\n        ThrottleLimit = 4\r\n        Parallel = { 'Do something' }\r\n    }\r\n    Invoke-Command -Begin ForEach-Object -ArgumentList $PSBoundParameters\r\n}\r\nprocess {\r\n    # Not sure if the following command can be more efficient at all v.s. starting a complete new pipeline\r\n    $InputPath.ForEach{ Invoke-Command -Process $MyCommand -Object $_ }\r\n}\r\nend {\r\n    Invoke-Command -End $MyCommand\r\n}\r\n```",
  "closed_at": "2022-09-10T12:27:37Z",
  "comments": [
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> As a user I would like to have an idiomatic PowerShell solution to set the `-ThrottleLimit` in the script scope or global scope:\r\n> See: [What is the best way to structure an advanced multi-threaded Powershell function to work both on the pipeline as well as non-pipeline calls?](https://stackoverflow.com/a/73646440/1701026)\r\n> Related: #16898  \r\n\r\nCan we take this a bit at a time ? \r\n Exactly what is the problem that you have setting the throttle-limit ? \r\n#16898 is `foreach ($n in 1..1000) {  \u00absomething as job\u00bb  } ` creates 1000 jobs , and `foreach ($n in 1..1000) {  $array[$n] |  foreach -parallel -throttle 8  } ` creates 1000 8-threaded jobs, which should be a surprise to no-one.\r\n\r\nAre you saying you would like to have one thread pool and share it between multiple things ?  So you could write \r\n```\r\n$SharedPool = New-ThreadPool -Limit 20\r\n1..1000 | foreach -parallel { $data[$_] | foreach -parallel {\u00abcommand\u00bb $_ } -threadPool $Using:SharedPool} \r\n```\r\nThat could be useful, but it's nothing to do with stepable pipelines, and only applies to nested foreach -parallel commands.\r\n\r\nThe stackoverflow Q (which I've replied to) seems to be \"I want to take piped input or everything in a variable do something with the whole set\"  The set is going to `foreach -Parallel` in this case but it could be `sort-object` or `select-object -unique` \r\n\r\nBased on the stackoverflow post I think you are trying to call the process block of \"foreach\" from the process block of your function based on a misunderstanding.  It is perfectly valid for something in the middle of a pipeline (i.e. \"two\" in `one | two | three`) to send its output in its end block  - and every function which doesn't define begin/process/end  _does that_.     \r\nIn `one | two | three`, two can output from its `end` block which is processed by the `process` block of three. Three only _starts_ its own end block when two's end block is finished. \r\n\r\nIf you're saying this is not very friendly \r\n```\r\nbegin   {\r\n         $parameters @{\u00abname2\u00bb = \u00abvalue2\u00bb ; \u00abname2\u00bb = \u00abvalue2\u00bb} \r\n         $wrappedCmd = Get-Command \u00abcommand\u00bb\r\n         $scriptCmd  = {& $wrappedCmd @parameters }\r\n         $steppablePipeline = $scriptCmd.GetSteppablePipeline($myInvocation.CommandOrigin)\r\n         $steppablePipeline.Begin($PSCmdlet)\r\n}\r\nprocess {$steppablePipeline.Process($_) }\r\nend     {$steppablePipeline.End()       }\r\n``` \r\nand it would be better to be able to write something like  this \r\n```\r\nbegin   {\r\n         $parameters @{\u00abname2\u00bb = \u00abvalue2\u00bb ; \u00abname2\u00bb = \u00abvalue2\u00bb} \r\n         $steppablePipeline = Invoke-Command -BeginOnly  \u00abcommand\u00bb  -argumentLies $parameters \r\n}\r\nprocess {$steppablePipeline($_) }\r\nend     {$steppablePipeline.End()       }\r\n``` \r\n\r\nYes, it condenses four lines into one. Whether that's a big help or a small one people can debate :-) I  have a feeling that it's  something the team would leave the community to do. ",
      "created_at": "2022-09-08T16:52:34Z",
      "updated_at": "2022-09-08T16:52:34Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "> Can we take this a bit at a time ?\r\n\r\nThe `$SharedPool = New-ThreadPool -Limit 20` indeed answers the stackoverflow `-ThrottleLimit` issue  I was dealing with.\r\n-Thanks \ud83d\ude0a\r\n\r\n> It is perfectly valid for something in the middle of a pipeline\r\n\r\nI know, I also want to use the steppable pipeline to gain more performance as described here: [What good does a SteppablePipeline](https://stackoverflow.com/a/73074477/1701026) as *it is more efficient than the full invocation of the wrapped cmdlet in every iteration, in a nested pipeline*.\r\n\r\nWhich indeed indeed means that the request comes down to more friendly PowerShell command where your suggestion (`Invoke-Command -BeginOnly  \u00abcommand\u00bb -argumentList $parameters  `) even makes more sense.\r\n\r\n\r\n",
      "created_at": "2022-09-08T17:23:34Z",
      "updated_at": "2022-09-08T17:23:34Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> I know, I also want to use the steppable pipeline to gain more performance as described here: [What good does a SteppablePipeline](https://stackoverflow.com/a/73074477/1701026) as _it is more efficient than the full invocation of the wrapped cmdlet in every iteration, in a nested pipeline_.\r\n\r\nIt depends on the command.  For a great many things it doesn't matter - shaving 0.1 sec off the time to get back to the prompt 1000 times in a week doesn't give back 1000 x 0.1 seconds back. Shaving 0.1 sec off each pass of loop which runs 1000 times _does_ give you the 100 seconds.  \r\n\r\nWriting a wrapper which basically goes \r\n```\r\nFunction wrap {\r\nparam ([parameter(valueFromPipeline)]$P)\r\nbegin {$S =  {\u00abblock code\u00bb}.GetSteppablePipeline() ; $s.begin()} \r\nprocess {$S.process($p)} \r\nend {$s.end()} \r\n}\r\n```\r\nIs slower than just doing   `... | foreach-object {\u00abblock code\u00bb} `  \r\n\r\nbut \r\n```\r\nFunction wrap2 {\r\nparam ([parameter(valueFromPipeline)]$P)\r\nprocess {\r\n$q = \u00absome result from $P\u00bb\r\n$q | foreach-object {\u00abblock code\u00bb}.\r\n}\r\n``` \r\nWill be slower because  {\u00abblock code\u00bb} is set up for each $P passed. \r\n\r\nThis \r\n```\r\nFunction wrap3 {\r\nparam ([parameter(valueFromPipeline)]$P)\r\nbegin   {$q = @()\r\nprocess {$q += \u00absome result from $P\u00bb}\r\nend { $q | foreach-object -parallel {\u00abblock code\u00bb} } \r\n``` \r\nMay be faster or slower depending on how quickly items arrive and how long they take to process. That link shows an example of all the items arriving ~ instantly so it is faster. If $q is ready quickly and  \u00abblock code\u00bb is slow, parallelism helps. \r\n\r\n But if items arrive slowly, you get the first item noticeably sooner with a streaming method, and if the time to process is significant the last item completes noticeably  after it arrives. If the time process is small, then the time to get all items is shortly after the last one         \r\n... but if (3) is slower `... | forEach  {\u00absome result from $P\u00bb} | foreach-object -parallel {\u00abblock code\u00bb}`      \r\nor (if the first block doesn't expand to many items)   \r\n `... | foreach-object -parallel {$r = \u00absome result from $P\u00bb ; \u00ab code using $r\u00bb}` \r\n probably beats creating your own steppable pipeline \r\n \r\n \r\n\r\n \r\n ",
      "created_at": "2022-09-08T19:41:47Z",
      "updated_at": "2022-09-08T19:41:47Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "@jhoneill,\r\n\r\nThanks for your explanations and insights. I needed some time to process this all and further play around with the steppable pipeline.\r\n\r\n> It depends on the command\r\n\r\nAgree, yet using the **steppable pipeline** vs. a **full cmdlet call** could make quite some difference in performance for cmdlets as e.g. `Set-Content` (see also: #8270). I was suspecting this for the mentioned StackOverflow question [Split CSV with powershell](https://stackoverflow.com/questions/14754287) and actually exceeded my own expectation with a [`Split-Content` function](https://stackoverflow.com/a/73671591/1701026) which is about 8 times faster than the accepted answer.\r\n\r\nAnyways,\r\n\r\n> Yes, it condenses four lines into one. Whether that's a big help or a small one people can debate :-)\r\n\r\nI do see now that the purpose for more friendly syntax is a little overdone especially as one might start of with your suggestion `{\u00abblock code\u00bb}.GetSteppablePipeline()` therefore I have closed this issue.",
      "created_at": "2022-09-10T12:27:37Z",
      "updated_at": "2022-09-12T09:27:39Z"
    }
  ],
  "created_at": "2022-09-08T10:47:18Z",
  "labels": [
    "Issue-Enhancement"
  ],
  "number": 18054,
  "state": "closed",
  "title": "idiomatic (friendly) steppablePipeline",
  "updated_at": "2022-09-12T09:27:39Z"
}