{
  "_url": "https://github.com/PowerShell/PowerShell/issues/17953",
  "author": "dkaszews",
  "body": "### Prerequisites\r\n\r\n- [X] Write a descriptive title.\r\n- [X] Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\r\n- [X] Search the existing issues.\r\n- [X] Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\r\n- [X] Refer to [Differences between Windows PowerShell 5.1 and PowerShell](https://docs.microsoft.com/powershell/scripting/whats-new/differences-from-windows-powershell).\r\n\r\n### Steps to reproduce\r\n\r\nGiven any collection of `PSCustomObject`s with different fields, they will not compare equal but still collapse into a single item under `Select-Object -Unique` or `Sort-Object -Unique`. Notable cmdlets outputting `PSCustomObject` collections are:\r\n* `Select-Object` itself (`-Unique` works when used immediately, but not later on)\r\n* `ConvertFrom-Csv`\r\n\r\nThis behavior has been mentioned in https://github.com/PowerShell/PowerShell/issues/15806 and https://github.com/PowerShell/PowerShell/issues/12059 , but neither are for this exact problem, and it affecting `Select-Object` transformations and `ConvertFrom-Csv` makes it very prominent.\r\n\r\n### Expected behavior\r\n\r\n```console\r\n> $files = Get-ChildItem | Select-Object Name\r\n\r\n> $files\r\nName\r\n----\r\ndotnet-sdk-5.0.408-linux-arm64\r\ndotnet-sdk-6.0.400-linux-arm64\r\n\r\n> $files[0] -eq $files[1]\r\nFalse\r\n\r\n> $files | Select-Object -Unique\r\nName\r\n----\r\ndotnet-sdk-5.0.408-linux-arm64\r\ndotnet-sdk-6.0.400-linux-arm64\r\n```\r\n\r\n\r\n### Actual behavior\r\n\r\n```console\r\n> $files | Select-Object -Unique\r\nName\r\ndotnet-sdk-5.0.408-linux-arm64\r\n```\r\n\r\n\r\n### Error details\r\n\r\n_No response_\r\n\r\n### Environment data\r\n\r\n```powershell\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.3.0-preview.3\r\nPSEdition                      Core\r\nGitCommitId                    7.3.0-preview.3-304-gd02c59addc24e13da3b8ee5e1a8e7aa27e00c745\r\nOS                             Linux 5.15.0-1013-raspi #15-Ubuntu SMP PREEMPT Mon Aug 8 06:33:06 UTC 2022\r\nPlatform                       Unix\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n\r\n\r\n### Visuals\r\n\r\n_No response_",
  "closed_at": null,
  "comments": [
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "\r\n```\r\n> $files = Get-ChildItem | Select-Object Name\r\n> $files  | Select-Object * -unique \r\n```\r\nWorks , but if the second doesn't have a property parameter it fails. \r\nThe two linked items suggest that select-object uses the hash code, but this casts doubt on that. \r\n\r\nI've never understood why -ExcludeProperty doesn't work unless property is specified, I wonder if both could be solved if Property defaulted to \"*\"\r\n",
      "created_at": "2022-08-23T23:57:26Z",
      "updated_at": "2022-08-23T23:57:26Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "It seems we already have such issue...\r\n\r\nUpdate:\r\n> This behavior has been mentioned in https://github.com/PowerShell/PowerShell/issues/15806 and https://github.com/PowerShell/PowerShell/issues/12059 ,\r\n\r\nYes, it is #15806 - I think it will fix this too.",
      "created_at": "2022-08-24T04:17:05Z",
      "updated_at": "2022-08-24T04:43:51Z"
    },
    {
      "author": "dkaszews",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov It's not a duplicate because #15806 is just about better hashing, which may improve for example storing `PSCustomObject` in dicts, but is never enough for equality testing. Just because two objects have same hash does not mean they are equal. I quickly found two guid strings which have same hash codes but do not have this problem:\r\n\r\n```pwsh\r\n> $x = 'f8c9ced6-86ee-432d-925a-7fcc6efeb881'\r\n> $y = '4696130c-891d-4b66-9ab8-d1d92948155e'\r\n> $x -eq $y\r\nFalse\r\n> $x.GetHashCode() -eq $y.GetHashCode()\r\nTrue\r\n> $x, $y | Select-Object -Unique\r\nf8c9ced6-86ee-432d-925a-7fcc6efeb881\r\n4696130c-891d-4b66-9ab8-d1d92948155e\r\n```",
      "created_at": "2022-08-24T06:11:52Z",
      "updated_at": "2022-08-24T06:11:52Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@dkaszews I guess hashcode is a root of the issue. You could try @SeeminglyScience's proposal https://github.com/PowerShell/PowerShell/issues/15806#issuecomment-883825587 and either confirm or disprove this.",
      "created_at": "2022-08-24T06:28:34Z",
      "updated_at": "2022-08-24T06:28:34Z"
    },
    {
      "author": "dkaszews",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov Please look at my example, it proves that hashcode is not the root of the issue because it's not a problem for other types. I can try that suggestion, but I doubt it will work. Can you at least remove the duplicate tag until I try it, so this issue will not get closed automatically? If it does indeed help, I will close it myself.",
      "created_at": "2022-08-24T06:45:09Z",
      "updated_at": "2022-08-24T06:45:09Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@dkaszews I cannot reproduce the issue. Please create repro steps like Pester tests (with creating demo files).",
      "created_at": "2022-08-24T07:22:47Z",
      "updated_at": "2022-08-24T07:22:47Z"
    },
    {
      "author": "dkaszews",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov Here is a minimal isolated test case using `ConvertFrom-Csv`. Unsure why pester thinks the first does not match, may be another bug, but you can clearly see difference in behavior\r\n\r\n```pwsh\r\n> $data = \"a`n1`n2\" | ConvertFrom-Csv\r\n> $data | Select-Object -Unique * | Should -Be $data\r\nInvalidResult: Expected @(@{a=1}, @{a=2}), but got @(@{a=1}, @{a=2}).\r\n> $data | Select-Object -Unique | Should -Be $data\r\nInvalidResult: Expected @(@{a=1}, @{a=2}), but got @{a=1}.\r\n```",
      "created_at": "2022-08-24T10:01:57Z",
      "updated_at": "2022-08-24T10:01:57Z"
    },
    {
      "author": "dkaszews",
      "author_association": "CONTRIBUTOR",
      "body": "The first failing test is due to some oddity where after going through `Select-Object` the `PSCustomObject`s no longer compare equal, so definitely another bug. Piping both expected and actual through `ConvertTo-Json -Compress` fixes it",
      "created_at": "2022-08-24T10:24:32Z",
      "updated_at": "2022-08-24T10:26:27Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": ">   I cannot reproduce the issue. \r\n@iSazonov  try this simple one in any directory with multiple files\r\n```\r\n$files = Get-ChildItem | Select-Object Name\r\n$files  | Select-Object  -unique \r\n$files  | Select-Object  -unique * \r\n```\r\nThe second line only returns one item. The third returns all of them.   The same happens if you use `Sort-Object -unique`\r\nBut if the first line is `$files = Get-ChildItem | % name` or  just `$files = Get-ChildItem `  both lines return all items\r\n\r\n\r\n**I don't think it is hashing**\r\n\r\nI think the code ( https://github.com/PowerShell/PowerShell/blob/master/src/Microsoft.PowerShell.Commands.Utility/commands/utility/Select-Object.cs  line 628 onwards)  compares base objects without note properties - and guess what... PSCustomObjects are ALL note properties -and ONLY looks at note properties if -Properties is specified. So \r\n```\r\n$a = get-item .\r\n$b = get-item .\r\n$a, $b | Select-Object -unique\r\n```\r\nCorrectly returns ONE item\r\n\r\n```\r\nAdd-Member -NotePropertyName \"foo\" -NotePropertyValue \"bar\" -InputObject $a\r\n$a, $b | Select-Object -unique\r\n```\r\nShould make a difference between a and b and return two items, but `Select-Object` ignores it because it is a note property\r\n\r\n```\r\n $a, $b | Select-Object -unique name\r\n```\r\nCorrectly only returns one object because it is not told to look at the note property that is different\r\n```\r\n $a, $b | Select-Object -unique name,foo \r\n```\r\nNow returns two objects because it IS looking at the note property. \r\n\r\n**This looks to be by design**  two objects are not considered different if they only differ in note properties, UNLESS those note properties are specified. (Which is why adding * fixes the problem in the initial example). But that design doesn't allow for PSCustomObjects \r\n\n\n<blockquote><img src=\"https://repository-images.githubusercontent.com/49609581/aad0ad80-cdec-11ea-8248-a37bc0571bfd\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/PowerShell/PowerShell\">PowerShell/Select-Object.cs at master \u00b7 PowerShell/PowerShell</a></strong></div><div>PowerShell for every system! Contribute to PowerShell/PowerShell development by creating an account on GitHub.</div></blockquote>",
      "created_at": "2022-08-24T12:10:53Z",
      "updated_at": "2022-08-24T12:10:55Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> ```\r\n> $files | Select-Object -Unique\r\n> ```\r\n\r\nBut in OP `Select-Object -Unique` doesn't work as expected, in the example `Select-Object -Unique *`.\r\n\r\nI'd want to get exact repro steps to understand that we investigate.",
      "created_at": "2022-08-24T12:32:11Z",
      "updated_at": "2022-08-24T12:32:11Z"
    },
    {
      "author": "dkaszews",
      "author_association": "CONTRIBUTOR",
      "body": "The example with csv is simpler and does not depend on the current directory, clearly demonstrating the issue. I agree with @jhoneill that `NoteProperties` being omitted by default are to blame. Defaulting `-Properties` to `*` sounds like a good solution. Alternatively, changing `Select-String` to consider `NoteProperties` when the objects would otherwise be \"empty\" can fix `PSCustomObject`, but would still be unexpected for objects which have a mix of different prop types. \r\n\r\n```pwsh\r\n> $data = \"a`n1`n2\" | ConvertFrom-Csv\r\n> $data\r\na\r\n-\r\n1\r\n2\r\n> $data | Select-Object -Unique *\r\na\r\n-\r\n1\r\n2\r\n> $data | Select-Object -Unique\r\na\r\n-\r\n1\r\n```",
      "created_at": "2022-08-24T13:08:19Z",
      "updated_at": "2022-08-24T13:09:25Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> > ```\r\n> > $files | Select-Object -Unique\r\n> > ```\r\n> \r\n> But in OP `Select-Object -Unique` doesn't work as expected, in the example `Select-Object -Unique *`.\r\n> \r\n> I'd want to get exact repro steps to understand that we investigate.\r\n\r\nIn mine it is there to show that it doesn't do what is expected too ,\r\n```\r\n$files = Get-ChildItem | Select-Object Name    # Gets something\r\n$files  | Select-Object  -unique               # Only outputs the first item not expected\r\n$files  | Select-Object  -unique *             # Outputs all items \r\n```\r\n\r\n",
      "created_at": "2022-08-24T15:02:05Z",
      "updated_at": "2022-08-24T15:02:05Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "What is a result we expect for `[pscustomobject] @{ foo=1 } -eq [pscustomobject] @{ foo=1 }`?\r\n\r\nFor `[System.Management.Automation.LanguagePrimitives]::Compare([pscustomobject] @{ foo=1 }, [pscustomobject] @{ foo=1 })`?",
      "created_at": "2022-08-25T11:09:55Z",
      "updated_at": "2022-08-25T11:09:55Z"
    },
    {
      "author": "dkaszews",
      "author_association": "CONTRIBUTOR",
      "body": "I would obviously expect value semantics, so those should compare equal. Otherwise we run into issues when putting them into associative containers. As they are currently compared by reference you can never retrieve a key without iteration. Also this means that two objects converted from the exact same JSON or CSV are not equal to each other. \r\n\r\nBut then, PowerShell has broken comparison semantics for primitive containers anyways. `@{ 'foo'=1 } -eq @{ 'foo'=1 }` also fails, while `@( 1, 2, 3 ) - eq @( 1, 2, 3 )` returns null because it is stupid: `3 -eq 1..3` is false, while `1..3 -eq 3` is `3`.",
      "created_at": "2022-08-25T12:20:14Z",
      "updated_at": "2022-08-25T12:20:33Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I think `pscustomobject` equality and comparison semantics is a key here. We need to describe them exactly and also we need to investigate whether it is possible to change this without breaking other PSObjects.",
      "created_at": "2022-08-25T12:47:13Z",
      "updated_at": "2022-08-25T12:47:33Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> PowerShell has broken comparison semantics for primitive containers anyways. `@{ 'foo'=1 } -eq @{ 'foo'=1 }` also fails, while `@( 1, 2, 3 ) - eq @( 1, 2, 3 )` returns null because it is stupid: `3 -eq 1..3` is false, while `1..3 -eq 3` is `3`.\r\n\r\n\r\nI explained this somewhere else like this . \r\n\r\n-  `9 -lt 10`  is true:  9 is less than 10  \r\n-  `11 -lt 10`  is false:  11 is Greater than 10 \r\n- so what does @(11,9) -lt 10 return. True? Because something the array IS less than 10. Or False? because something IS NOT less than 10. Or True, and False for the two members ? And you and I both know what it does do, it returns a subarray with the items that meet the condition. \r\n\r\n@iSazonov  I said above the problem with this case is note properties being ignored in select and sort. \r\n\r\nI wonder if many objects (e.g. directoryInfo) dont work with the `-eq` because their type doesn't have a CompareTo method. \r\n\r\n\r\n \r\n\r\n\r\n ",
      "created_at": "2022-08-25T14:10:28Z",
      "updated_at": "2022-08-25T14:10:28Z"
    },
    {
      "author": "dkaszews",
      "author_association": "CONTRIBUTOR",
      "body": "> so what does @(11,9) -lt 10 return\r\n\r\nIt should return an error",
      "created_at": "2022-08-25T15:19:37Z",
      "updated_at": "2022-08-25T15:19:37Z"
    },
    {
      "author": "dkaszews",
      "author_association": "CONTRIBUTOR",
      "body": "Seriously though, Python2 had a logic of everything being comparable and it lead to some really stupid results. Incomparable types were compared by typename instead. So all integers were smaller than all strings, which was really funny when you forgot a cast somewhere. I spent a week debugging issue whose root cause was `upper_limit` parameter being left as a string, meaning it never discarded elements.\r\n\r\nArrays using comparison operators for selection instead of comparison was such a bad idea, the very fact that a comparison operator can return anything other than bool. For selection, you can just use the `Where-Object` or, if you really wanted to have an operator for that, create a separate one like `?lt`. I'm half tempted to write a proposal to have comparison operators throw a `StrictMode` error with arrays, to force everyone to use `Where-Object` or `Compare-Object`. ",
      "created_at": "2022-08-25T15:27:29Z",
      "updated_at": "2022-08-25T15:27:29Z"
    },
    {
      "author": "kasini3000",
      "author_association": "NONE",
      "body": "```powershell\r\n$\u8f93\u51fa\u6570\u7ec4 = @()\r\n$a = [PSCustomObject]@{ \r\nname = '\u5f20\u4e09'\r\nage = 18\r\n}\r\n$\u8f93\u51fa\u6570\u7ec4 += $a\r\n$a = [PSCustomObject]@{ \r\nname = '\u674e\u56db'\r\nage = 18\r\n}\r\n$\u8f93\u51fa\u6570\u7ec4 += $a\r\n$\u8f93\u51fa\u6570\u7ec4 | format-table\r\n$\u8f93\u51fa\u6570\u7ec4 | Get-Unique\r\nGet-Unique -InputObject $\u8f93\u51fa\u6570\u7ec4\r\n```\r\n\r\n![17953](https://user-images.githubusercontent.com/65390418/186810330-caa2c152-0ef7-474f-a08f-2b9026e0f40d.jpg)\r\n\r\nthis is by design ?\r\n\r\nboth powershell v5.1 and powershell v7.3 return same\r\n\r\n\r\nGet-Unique specifying Property is not supported,\r\nxxx |  Get-Unique\r\nGet-Unique -InputObject\r\nThese two usages return different results, which is easy to be troubled by.\r\n\r\nAlthough Get-Unique is not included in the topic, I think this topic is related to Unique, so it should be possible to discuss Get-Unique\r\n",
      "created_at": "2022-08-26T03:18:34Z",
      "updated_at": "2022-08-26T17:26:29Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@SeeminglyScience What do you think about the issue? What about adding IEquatable in PSCustomObject and IComparable if PSCustomObject is [ordered]?",
      "created_at": "2022-08-26T05:54:16Z",
      "updated_at": "2022-08-26T05:54:16Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> > so what does @(11,9) -lt 10 return\r\n> \r\n> It should return an error\r\n\r\nThat's one of multiple valid views. \r\n\r\nThere is problem which I was taught about in my CS degree in the mid 1980s where it was called \"overloaded operators\". \r\nIn some languages = is both the test for equality and the assignment operator (others use := or == to split them up)\r\n+ is both arithmetic addition and concatenation, really it should not be. \r\nIn PowerShell % can be alias for ForEach-Object or the modulo operator, and ? and be a wildcard, the alias for where-object or the ternary operator.   \".\" can be \"run in current scope\" or the member operator. \r\n\r\nOne way to think about -eq etc is as overloaded operators which do different jobs in different contexts.  I'm a lot more bothered that `(get-item .) -eq (get-item .) ` returns false than I am that the original design making it a filter when the first operand is an array - that does have ring of \"quick and dirty, but still useful\" to it. \r\n\r\n\r\n\r\n",
      "created_at": "2022-08-26T09:34:07Z",
      "updated_at": "2022-08-26T09:34:07Z"
    },
    {
      "author": "dkaszews",
      "author_association": "CONTRIBUTOR",
      "body": "@jhoneill the problem is not overloading, it's unexpected overloading. When you're implementing a list, having a plus do element-wise addition is a valid implementation (like in Matlab), as is it doing contatenation (like in Python). But there are certain contracts that should be obeyed, especially for comparison operators, and PowerShell arrays returning anything but booleans when using comparison is flounting those rules.:\r\n\r\n1. broken typing: `$x -eq $y` may return anything depending on whether `$x` is an array and what types it holds, though at least it always returns an array without unwrapping single elements. Here's a fun one: play around with `@( $false )`\r\n1. broken symmetry: `1 -eq @( 1, 2 )` returns false, but `@( 1, 2 ) -eq 1` returns false\r\n1. broken identity: `$x -eq $x` always return null for arrays, because it means `$x | Where-Object { $_ -eq $x }`, and items will never be equal entire array, especially when the array is on left side. This is even true for single-element and empty arrays and I don't think you can ever construct an array where it will return anything other than null without cheesing it with a custom type.\r\n\r\n> I'm a lot more bothered that (get-item .) -eq (get-item .) returns false\r\n\r\nThis stems directly from broken identity. So we cannot fix it without changing how equality operators behave on arrays, which would be a major breaking change. The only thing I can think of is a `StrictMode` warning forcing use of `Compare-Object`, or going the way of Javascript and introducing a new operator like `!eq` which means \"compare, but really compare\". At least `==` in JS always returns a bool, so PS somehow managed to break its comparison even more.",
      "created_at": "2022-08-26T13:51:36Z",
      "updated_at": "2022-08-26T13:51:36Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "Just on (2) `-eq` isn't symmetrical.  \r\n`$false -eq  \"\"`  returns true because the Boolean for \"\" converts to $false. but ` \"\" -eq $false`  is false  because $false converts to the string \"false\". \r\nSo just when the novice user says \"aha so the type one right is converted to match the one the right so `3 -eq [math]::pi` will convert PI to an [int] \" we find that the rule doesn't apply when comparing numbers.\r\n\r\nOr try this \r\n```\r\n$x = 1L\r\n$y = 1s\r\n\r\n $x -eq $y\r\n```\r\nIt's true even though they store 1 as long int and short int. \r\n\r\nWe also know that this ` $hash = @{1 = \"Long\"; 1 = \"Short\"}` will give a duplicate keys error\r\n\r\n\r\n```\r\n $hash = @{$x = \"Long\"; $y = \"Short\"}\r\n $hash\r\n\r\nName                           Value\r\n----                           -----\r\n1                              Long\r\n1                              Short\r\n\r\n$hash[1]\r\n# nothing \r\n```\r\nSo a hash table allows two keys which test as equal, but if we provide a key which is equal to both it doesn't match either of them.  It also works for char and string but at least \"A\" matches the string later. What different things consider to be \"equal\" is not consistent. \r\n\r\n",
      "created_at": "2022-08-26T15:34:54Z",
      "updated_at": "2022-08-26T15:34:54Z"
    },
    {
      "author": "dkaszews",
      "author_association": "CONTRIBUTOR",
      "body": "Can we circle back to @jhoneill 's original solution to simply default `-Property` to `*`? It fixes the issue and I cannot see any flows it could break. If nobody can think of a reason that would be a breaking change, I suggest we go with it, as it is trivial to implement.\r\n\r\nAlternatively, we could implement it to look at all `NoteProperty` if and only if the object contains no `Property`. Not much more complicated and even less likely to break existing flows in case there are some objects which store their real values as `Property` and use `NoteProperty` only for metadata.",
      "created_at": "2022-09-01T15:38:02Z",
      "updated_at": "2022-09-01T15:45:52Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "This cmdlet is so complex that any workaround is bound to break something. The solution must be fundamental to be approved. But first we need the approval of the WG as a whole. /cc @jhoneill as WG member.",
      "created_at": "2022-09-02T13:23:27Z",
      "updated_at": "2022-09-02T13:26:49Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "This was discussed in cmdlet working group yesterday. \r\nIt was suggested that if the objects are  PSCustomObjects and no `-Property`  parameter is passed, `Select-Object` could behave as if `Property *` had been specified.  This will be investigated, which is not (yet) a commitment to make a change. ",
      "created_at": "2022-09-08T08:57:24Z",
      "updated_at": "2022-09-08T08:57:24Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/wg-powershell-cmdlets reviewed this and agree that the current behavior for PSCustomObject is incorrect.  We believe this is likely a bucket 3 breaking change that users are relying on the current behavior.  We considered an option to inform the user to use `-Property *` if we detect that the objects are PSCustomObjects, however, it seems more useful to fix this behavior that future users can rely upon.  So the change is only if the first object is a `PSCustomObject` and `-Property` isn't specified, then it gets set to `-Property *`.",
      "created_at": "2022-11-02T17:14:55Z",
      "updated_at": "2022-11-02T17:14:55Z"
    },
    {
      "author": "dkaszews",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT Great to hear! So the fix should be something like this? \r\n\r\n```csharp\r\nif (object is PSCustomObject && Properties.IsNullOrEmpty())\r\n{\r\n    Properties = \"*\";\r\n}\r\n```\r\n\r\nNo warning after all? Just to confirm before I sit down to implement it. ",
      "created_at": "2022-11-03T11:49:56Z",
      "updated_at": "2022-11-03T11:49:56Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@dkaszews No warning. Check only first object being PSCustomObject and Property parameter is not present.",
      "created_at": "2022-11-03T11:58:51Z",
      "updated_at": "2022-11-03T12:00:09Z"
    },
    {
      "author": "dkaszews",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT @iSazonov From code review: how should we handle `Sort-Object`? Should the change of default `Property = \"*\"` still be triggered based on first element? For `Select` we don't have much choice, as we cannot inspect extra elements without breaking streaming, but for `Sort`, the output is deferred anyway and just looking at first object makes it order dependent, which should never happen for a sorting function:\r\n\r\n```pwsh\r\n> $dict = @{ a = 0 }\r\n> $obj = [PSCustomObject] @{ a = 1 } \r\n> $obj2 = [PSCustomObject] @{ a = 2 } \r\n> $obj, $obj2, $dict | Sort-Object -Unique\r\na: 0\r\na: 1\r\na: 2\r\n> $dict, $obj, $obj2 | Sort-Object -Unique  # fix doesn't kick in\r\na: 0\r\na: 1\r\n```\r\n\r\nSo we should probably go with `Any` or `All` instead - but which? I can't find a good argument for one over another other than the first will be quicker to evaluate for cases with `PSCustomObject` in the objects, while the latter will be quicker for cases without. I think the `Any` will be safer option to make the fix more prone to kick in than not.\r\n\r\nThis also circles back to the `Select` - if you have a list of just `PSCustomObject` but prepend it with some other type, perhaps a string or something else (maybe your parser is inconsistent with nulls), then the fix won't kick in. Changing the `Property` mid run is a no-go, but maybe a warning in this case? So if you are **not** at first element but it's `PSCustomObject` and `Property` is still default with the `-Unique`, issue a single warning. ",
      "created_at": "2022-11-05T17:54:03Z",
      "updated_at": "2022-11-05T17:54:03Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Looking at the results of the proposed fix, I am not satisfied. While the main scenario is fixed by this fix (usually all objects of the same type in the pipeline), I'm afraid that we'll immediately get feedback that it doesn't work if the first object isn't a PSCustomObject. Since we're doing a slow accumulation of objects from the pipeline anyway, there's nothing stopping us from checking their type until we encounter a PSCustomObject.\r\n\r\nThis in turn makes me think that this fix is more of a workaround and the main problem is somewhere deeper and should be fixed, although it's not trivial anymore.",
      "created_at": "2022-11-05T18:12:21Z",
      "updated_at": "2022-11-05T18:12:21Z"
    },
    {
      "author": "dkaszews",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov I think the problem is in the design of the cmdlets that the unspecified property ignores `NoteProperty` for reasons I don't understand. The \"proper\" fix in my opinion would be to always take them into account, equivalent to setting default to star, regardless of the type of the objects.\r\n\r\nI proposed a different fix here:\r\n\r\n> Alternatively, we could implement it to look at all NoteProperty if and only if the object contains no Property. Not much more complicated and even less likely to break existing flows in case there are some objects which store their real values as Property and use NoteProperty only for metadata. ",
      "created_at": "2022-11-05T18:23:44Z",
      "updated_at": "2022-11-05T18:26:11Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> ignores `NoteProperty` for reasons I don't understand\r\n\r\nPerformance, I guess.",
      "created_at": "2022-11-05T18:26:33Z",
      "updated_at": "2022-11-05T18:26:33Z"
    },
    {
      "author": "dkaszews",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov You say \"performance\", I say give me the benchmarks \ud83d\ude09 . I had a programming 101 professor who would dock point for writing loops in C as `for (size_t i = 0; i < n; i++) { foo(a[i]; }` because he thought `for (int* p = array, end = array + n; p != end; ++p) { foo(*p); }` would be more \"performant\" even when I showed him they compile to exact same assembly. \r\n\r\nIs there an easy way to enumerate all types currently loaded and list their properties of each kind? That would allow to see if there might be some reasonably common case where comparing `NoteProperties` will indeed introduce a performance hit, then construct a test and get some real numbers. ",
      "created_at": "2022-11-05T18:36:39Z",
      "updated_at": "2022-11-05T18:36:39Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Really PSObject does lazy initialization internal property collections. So we have no need a benchmark - it is obvious slowly.\r\n\r\nTo be precise, I am not against the suggested correction at all, since this cmdlet is already full of contradictions. However, I would rather follow the fundamental concepts of PowerShell than mask problems. ",
      "created_at": "2022-11-05T18:56:05Z",
      "updated_at": "2022-11-05T18:56:05Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> Looking at the results of the proposed fix, I am not satisfied. While the main scenario is fixed by this fix (usually all objects of the same type in the pipeline), I'm afraid that we'll immediately get feedback that it doesn't work if the first object isn't a PSCustomObject. \r\n\r\nThere are many cases where if the first object is of one type and the later objects have different properties you don't get all the fields. (Formatting being the most obvious), another one is not a problem IMHO. \r\n\r\nFixing the problem when the objects are all similar is a net gain, not knowing what to do when they are dissimilar is a problem which doesn't have an easy or obvious solution. \r\n   \r\n\r\n\r\n",
      "created_at": "2022-11-07T08:54:32Z",
      "updated_at": "2022-11-07T08:54:32Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> @iSazonov I think the problem is in the design of the cmdlets that the unspecified property ignores `NoteProperty` for reasons I don't understand. The \"proper\" fix in my opinion would be to always take them into account, equivalent to setting default to star, regardless of the type of the objects.\r\n\r\n(The following assumes that you were proposing to make `-Property` default to `*` in all cases, not just `PSCustomObject`. Rereading it's not super clear to me if that's what you were proposing, so apologizes if not).\r\n\r\nIt's not that it ignores a particular type of property, but instead that equality (and comparison) defaults to reference equality when the target type does not implement it. Defaulting to `*` doesn't really solve anything unless you also make it recursive.\r\n\r\nIt would also be a breaking change as some objects only have a single instance per identity. `System.Type` for example, if you try to compare all of it's properties you'll run into a lot of issues, but otherwise `[type] -eq [type]` works because the ref identity is the same.",
      "created_at": "2022-11-07T17:22:08Z",
      "updated_at": "2022-11-07T17:25:40Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@SeeminglyScience My main perplexity is that PSCuscomObject behaves unpredictably in many cases, and yet is one of the key concepts. Although it appeared as a way to overcome the limitations of .Net in the absence of flexible dynamic.\r\nI think it would be much easier for everyone to understand and work with PowerShell if there were simple rules and they were enforced.",
      "created_at": "2022-11-08T03:48:03Z",
      "updated_at": "2022-11-08T03:48:03Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "I can sympathize with that, but as with many things in PowerShell, the amount of freedom afforded does limit how consistent some features can be. For example, some selective equality and comparability can be implemented but it can't work in dictionaries due to mutability. We also can't implicitly recurse an object to compare it so at best we'd be solving *some* of the problems and making the rest harder to troubleshoot. Maybe that middle ground is acceptable, but I'm not sure a simple set of rules that are inherently understandable is realistic.\r\n\r\n#15806 should be fixed for sure though.\r\n\r\n---\r\n\r\nI wonder if it's worth discussing a new operator that explicitly attempts structural comparison.",
      "created_at": "2022-11-08T18:37:12Z",
      "updated_at": "2022-11-08T18:37:12Z"
    }
  ],
  "created_at": "2022-08-23T19:38:59Z",
  "labels": [
    "WG-Engine",
    "Up-for-Grabs",
    "WG-Cmdlets-Utility",
    "In-PR"
  ],
  "number": 17953,
  "state": "open",
  "title": "PSCustomObject does not work with Select-Object -Unique and Sort-Object -Unique",
  "updated_at": "2022-11-08T18:37:13Z"
}