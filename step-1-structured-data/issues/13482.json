{
  "_url": "https://github.com/PowerShell/PowerShell/issues/13482",
  "author": "JamesWTruher",
  "body": "<!-- Anything that looks like this is a comment and can't be seen after the Pull Request is created. -->\r\n\r\n# PR Summary\r\n\r\nThis PR attempts to manage the scenario where multiple quotes and strings with spaces are sent to the Native Command Processor. The current behavior of our native executable has the following results:\r\n\r\n```powershell\r\nPS> testexe -echoargs 'one \"two three\" four' \r\nArg 0 is <one two>\r\nArg 1 is <three four>\r\n```\r\n\r\nwhich is somewhat surprising. This PR changes the behavior to:\r\n\r\n```powershell\r\nPS> testexe -echoargs 'one \"two three\" four'                                                                                   \r\nArg 0 is <one \"two three\" four>\r\n```\r\n\r\nsomewhat _more_ pathological is the following:\r\n\r\n```powershell\r\ntestexe -echoargs ' \"this is\" \"a test\" '  \r\nArg 0 is < this>\r\nArg 1 is <is a>\r\nArg 2 is <test >\r\n```\r\n\r\nwith my change:\r\n\r\n```powershell\r\ntestexe -echoargs ' \"this is\" \"a test\" '      \r\nArg 0 is < \"this is\" \"a test\" >\r\n```\r\n\r\nThis PR represents a breaking change\r\n\r\n## PR Context\r\n\r\nsee [issue 1995](https://github.com/PowerShell/PowerShell/issues/1995)\r\n\r\nThe implementation is somewhat straightforward, it inspects the string argument looking for `\"` and prepends the _native_ escape `\\` character to the `\"`. If there is already a `\\` in front of the `\"` no change is made. \r\n\r\n## PR Checklist\r\n\r\n- [x] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [x] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [ ] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [ ] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` or `[ WIP ]` to the beginning of the title (the `WIP` bot will keep its status check at `Pending` while the prefix is present) and remove the prefix when the PR is ready.\r\n- **[Breaking changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)**\r\n    - [ ] None\r\n    - **OR**\r\n    - [x] [Experimental feature(s) needed](https://github.com/MicrosoftDocs/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/About/about_Experimental_Features.md)\r\n        - [x] Experimental feature name(s): **PSEscapeDoubleQuotedStringForNativeExecutables**\r\n- **User-facing changes**\r\n    - [ ] Not Applicable\r\n    - **OR**\r\n    - [x] [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n- **Testing - New and feature**\r\n    - [ ] N/A or can only be tested interactively\r\n    - **OR**\r\n    - [x] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n- **Tooling**\r\n    - [ ] I have considered the user experience from a tooling perspective and don't believe tooling will be impacted.\r\n    - **OR**\r\n    - [x] I have considered the user experience from a tooling perspective and enumerated concerns in the summary. This may include:\r\n        - Impact on [PowerShell Editor Services](https://github.com/PowerShell/PowerShellEditorServices) which is used in the [PowerShell extension](https://github.com/PowerShell/vscode-powershell) for VSCode (which runs in a different PS Host).\r\n        - Impact on Completions (both in the console and in editors) - one of PowerShell's most powerful features.\r\n        - Impact on [PSScriptAnalyzer](https://github.com/PowerShell/PSScriptAnalyzer) (which provides linting & formatting in the editor extensions).\r\n        - Impact on [EditorSyntax](https://github.com/PowerShell/EditorSyntax) (which provides syntax highlighting with in VSCode, GitHub, and many other editors).\r\n",
  "closed_at": "2020-10-15T22:56:41Z",
  "comments": [
    {
      "author": "Artoria2e5",
      "author_association": "NONE",
      "body": "It would be nice if the nullOrEmpty check on the arg is removed too. Almost every platform has a concept of  an empty string appearing in argv.\r\n\r\nThe whole only-quote-when-unquoted still feels wonky to reason about, but ehhhh the test cases are there. (FWIW, I would really prefer forgoing the wonky code for \"need quote\" altogether.)",
      "created_at": "2020-08-19T20:41:32Z",
      "updated_at": "2020-10-02T00:39:38Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "First of all, thanks for working on this long overdue issue. And thanks for showing the (incomplete?) code in a work-in-progress pull request.\r\n\r\n> If there is already a `\\` in front of the `\"` no change is made.\r\n\r\nI think this is a very dangerous half-hearted measure. I'd honestly prefer to not change the current behavior, than to further modify the \"guess what the user wanted and try to do something maybe that could be right\" method.\r\n\r\nImplementing it this way would still not allow to pass arbitrary sting contents to executables. But instead of knowing that I have to correctly escape `\"`-chars, I would than have to write an even more complex regex replace construct to do the right thing.    \r\n*&lt;Edit>* I thought about it, the regex doesn't get more complicated, just different. *&lt;/Edit>*\r\n\r\nThis would mean changing from one inconsistent behavior to another more complicated inconsistent behavior...\r\n\r\nAnother disadvantage: The current behavior is at least relatively obvious. It is at least somewhat likely that a user would test if a string containing a quote is passed correctly. The proposed behavior would would mean, that people would only notice the problem if they explicitly test if a backslash followed by a quote is passed correctly...\r\n\r\n----\r\n\r\nNote: The correct way to escape *N* backslashes followed by `\"` is *2N+1* backslashes followed by `\"`. (`\\\"`\u2192`\\\\\\\"`, `\\\\\"`\u2192`\\\\\\\\\\\"`,...)",
      "created_at": "2020-08-19T20:44:34Z",
      "updated_at": "2020-08-19T21:08:15Z"
    },
    {
      "author": "Artoria2e5",
      "author_association": "NONE",
      "body": "Looks like this is triggering the same failures as in #13099. The Pester stuff really is a goldmine for strange hacks relating to this.",
      "created_at": "2020-08-19T20:52:35Z",
      "updated_at": "2020-08-19T20:52:35Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "> The whole only-quote-when-unquoted still feels wonky to reason about\r\n\r\nYes, I would again strongly recommend, to not do these strange tests - that always means, that one can not pass arbitrary content as an argument to an executable. Please always treat any quotes within an argument as literal quotes that need to be escaped.",
      "created_at": "2020-08-19T21:01:46Z",
      "updated_at": "2020-08-19T21:01:46Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@TSlivede the intent of not modifying an already escaped quote `\\\"` is to ensure that users already using that workaround to get quote passed aren't suddenly broken",
      "created_at": "2020-08-19T22:20:11Z",
      "updated_at": "2020-08-19T22:20:11Z"
    },
    {
      "author": "Artoria2e5",
      "author_association": "NONE",
      "body": "Well, since this is already a breaking change, I think ensuring this sort of thing is unnecessary.",
      "created_at": "2020-08-19T22:36:34Z",
      "updated_at": "2020-08-19T22:36:34Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "> @TSlivede the intent of not modifying an already escaped quote `\\\"` is to ensure that users already using that workaround to get quote passed aren't suddenly broken\r\n\r\nYes, I already guessed that - but doing it this way does not solve the problem in general. It just makes the problem harder to notice. This is not a solution - this is hiding the problem.\r\n\r\nI am fully aware that many people would be happy, that quotes would then \"just work\". So there would be less complaints to powershell. But it does not change the fact, that argument passing to external executables would be still fundamentally flawed.",
      "created_at": "2020-08-20T10:50:33Z",
      "updated_at": "2020-08-20T14:59:13Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I wholeheartedly agree, @TSlivede and @Artoria2e5.\r\n\r\nThe only worthwhile fix is one that fixes the problem once and for all, even though that means breaking existing workarounds.\r\n\r\nTo recap, that means:\r\n\r\n* On Unix, switch to `ProcessStartInfo.ArgumentList`: _nothing else is required_.\r\n\r\n* On Windows, switch to `ProcessStartInfo.ArgumentList` _by default_, but also make accommodations for batch files and high-profile `msiexec`-style CLIs, as detailed in https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-674445995\r\n  * These accommodations (as well as the `ProcessStartInfo.ArgumentList` fix _in effect_) are implemented in the [ `ie` function](https://github.com/mklement0/Native/blob/dbe562fa46c708428adde8d00c5d38c2be1c8158/Native.psm1#L453) (if you want to test it standalone, execute `$script:needQuotingWorkaround = $true` first; otherwise, use `Install-Module Native`), but note that the implementation is complicated both by needing to work around the current quoting problems and wanting to remain PSv3+-compatible - neither aspect applies to a direct fix in the engine.\r\n\r\n  * As for `--%`: it's probably fine to leave as-is, despite its limitations, given that the only remaining, hopefully exceedingly rare use for it would be for \"rogue\" CLIs on Windows that aren't handled by the accommodations; also, a future `ins` / `Invoke-NativeShell` could provide a less limited experience that makes embedding PowerShell values easier (e.g., \r\n`` ins \"someRogueExe.exe `\"a&b`\" $((Get-Date).Year)\" ``.\r\n    * On a probably academic note: If we did want to fix `--%`, it should only be supported on Windows and only support the form `--% <single-string>`; in other words: `--%` should only be special as the _first_ argument and only accept a _single - potentially expandable - string_, that fully expresses the pass-through command line (and is _not_ subject to any further interpretation - _no_ expansion of `%...%` variables).\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-08-20T12:47:05Z",
      "updated_at": "2020-08-20T15:38:29Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "> Well, since this is already a breaking change, I think ensuring this sort of thing is unnecessary.\r\n\r\nI agree. Especially as I assume, that there are more cases that would brake anyway and only a few cases that would additionally break if this would be done correctly.\r\n\r\nI assume, that there are more calls of the form `msiexec \u2026\u2026 'property=\"value with space\"'` (calls where quotes in the argument are passed through as delimiting quotes) than there are calls with manually backslash escaped quotes. And the former will definitely break, there is no way around that.",
      "created_at": "2020-08-20T15:10:19Z",
      "updated_at": "2020-08-20T15:10:19Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "> * On Windows, switch to `ProcessStartInfo.ArgumentList` _by default_, but also make accommodations for batch files and high-profile `msiexec`-style CLIs, as detailed in [#1995 (comment)](https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-674445995)\r\n\r\nI have to admit, that that I'm really not a fan of checking which executable is called and then changing the quoting. That is absolutely horrible to debug if someone has a problem.\r\n\r\n*If* there must be accommodations for msiexec style CLIs, then arguments should simply always be quoted as `prop=\"some value\"` if they match that form. It is no problem to always to that, because the arguments still work perfectly fine for any executable, that follows the common rules. (Example implementation [here](https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-303345059), @SteveL-MSFT Regarding the [powershellgallery module](https://www.powershellgallery.com/packages/NativeCommand/0.0.1), that [you created](https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-333384152) from that code: Could you either update the code or transfer the ownership to [me](https://www.powershellgallery.com/profiles/TsLiveDe)?)\r\n\r\n---\r\n\r\nAnd I'm not even sure, that we should implement such accommodations: It would be much much better if starting with the next update, Microsoft would make their executables accept arguments wich are quoted from beginning to end (e.g. `\"a=b c\"`). That can be done completely backwards compatible.\r\n\r\nIf powershell implements special handling for these parameters, then these programs will probably never be fixed and any other cross platform tools will forever be unable to properly call these programs...",
      "created_at": "2020-08-20T15:52:58Z",
      "updated_at": "2020-08-20T15:58:13Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> I have to admit, that that I'm really not a fan of checking which executable is called and then changing the quoting. \r\n\r\nNeither am I, but we would do it as a courtesy to shield users from the underlying command-line anarchy, which seems well worth doing given the high profile of `msiexec`, `msdeploy`, `cmdkey`, and possibly others.\r\n\r\nAnd, of course, in order to accommodate _batch files_ - which as CLI entry points are probably often used _without the user realizing that a batch file is involved_ - there's no other option than to check whether the (resolved) executable path ends in `.cmd` or `.bat`.\r\n\r\nAlso note that the `prop=\"foo bar\"` `msiexec`-style  accommodation is _benign_ should it be applied to a CLI that doesn't actually need it - conventional CLIs treat `\"prop=foo bar\"` and `prop=\"foo bar\"` as equivalent.\r\n\r\n> That is absolutely horrible to debug if someone has a problem.\r\n\r\n(a) The accommodations are easy to conceptualize and document - for which the proposed and sorely needed [`about_Native_Calls` topic](https://github.com/MicrosoftDocs/PowerShell-Docs/issues/5152) is the right place.\r\n\r\n\r\n(b) We should ship something akin to `echoArgs.exe` or `dbea` / `Debug-NativeExecutable` (which also supports batch files) _as part of PowerShell_, again to be prominently documented in `about_Native_Calls`.\r\n\r\n> If there must be accommodations for msiexec style CLIs, then arguments should simply always be quoted as prop=\"some value\" if they match that form\r\n\r\nThat would mean _engaging with and indulging_ the command-line anarchy, whereas we want to _abstract it away_ - for the remaining cases, if any, where that doesn't work (to be diagnosed with `dbea`), there's `--%`.\r\n\r\nPowerShell is a _shell_, which means that however I pass an argument that I want the target executable to see as verbatim `foo=bar baz` should be fine, as long as I satisfy _PowerShell_'s syntax requirements.\r\n\r\nE.g., `$propValue = 'bar baz'; msiexec ... foo=$propValue` should just work, without you having to worry about non-conventional quoting requirements enforced by a rogue CLI - would you want to think about what the value of `$propValue` _could_ be and whether it _may_ require quoting? (On a purely technical level, I'm not even sure that the parameter binder preserves the original quoting in a way that makes it still available to the command-line construction code - but, the more important point is: _we should not do it_).\r\n\r\n>  It would be much much better if starting with the next update, Microsoft would make their executables accept arguments wich are quoted from beginning to end (e.g. \"a=b c\"). That can be done completely backwards compatible.\r\n\r\nAbsolutely - these CLIs should have been fixed a long time ago, incidentally not just with respect to `prop=\"foo bar\"`, but also with respect to currently not accepting `\\\"`-escaped `\"` chars.\r\n\r\nBy contrast, the accommodations for batch files can never go away (without massively breaking backward compatibility).\r\n\r\nBut even fixing the CLIs will not help older systems that may, however, install a fixed PowerShell version.\r\n\r\n> If powershell implements special handling for these parameters, then these programs will probably never be fixed and any other cross platform tools will forever be unable to properly call these programs...\r\n\r\nAgain - I don't see how any of these accommodations could break anything - do tell us if you know of any cases.\r\n\r\n(Hypothetically, breakage is possible in the following scenario, but I do not think it is a real-world concern: A `prop=<value>` / `/opt:<value>` / `-opt:<value>` is being passed _and_ embedded `\"` are used _and_ the target executable doesn't also recognize these as `\"\"`-escaped; most CLIs on Windows _do_ support `\"\"`, usually _in addition to_ `\\\"`, and the only exceptions I'm aware of are _some_ shell/scripting hybrids that accept pieces of scripts as arguments, such as PowerShell's own CLI and Ruby and Perl; it's easy to exclude PowerShell CLI calls from the accommodation, and I think it's also worth doing for Ruby and Perl.)\r\n",
      "created_at": "2020-08-20T16:28:57Z",
      "updated_at": "2020-08-20T16:46:02Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "<details>\r\n\r\nMaybe I didn't express clear enough, what I wanted to say.   \r\n<sup>(english is not my native language, sorry)</sup>\r\n\r\n> And, of course, in order to accommodate _batch files_ - which as CLI entry points are probably often used _without the user realizing that a batch file is involved_ - there's no other option than to check whether the (resolved) executable path ends in `.cmd` or `.bat`.\r\n\r\nOk, for batch files I can accept that - its easily documentable and its not some magic list of executables.\r\n\r\n> Also note that the `prop=\"foo bar\"` `msiexec`-style accommodation is _benign_ should it be applied to a CLI that doesn't actually need it - conventional CLIs treat `\"prop=foo bar\"` and `prop=\"foo bar\"` as equivalent.\r\n\r\nYes, that was my main point - just always quote a string of the form `prop=value with space` as `prop=\"value with space\"`. This way it does not depend on the executable name and it will still always work for executables that follow the common rules.\r\n\r\n> > That is absolutely horrible to debug if someone has a problem.\r\n> \r\n> (a) The accommodations are easy to conceptualize and document - for which the proposed and sorely needed [`about_Native_Calls` topic](https://github.com/MicrosoftDocs/PowerShell-Docs/issues/5152) is the right place.\r\n\r\nI agree, that such a help topic is absolutely necessary. But adding an additional section to it, that explains that some executables are treated differently doesn't exactly make the topic easier to understand...\r\n\r\n> (b) We should ship something akin to `echoArgs.exe` or `dbea` / `Debug-NativeExecutable` (which also supports batch files) _as part of PowerShell_, again to be prominently documented in `about_Native_Calls`.\r\n\r\nAgreed. But such a `echoArgs.exe` would be much less useful if not all `.exe` files are treated the same.\r\n\r\n> > If there must be accommodations for msiexec style CLIs, then arguments should simply always be quoted as prop=\"some value\" if they match that form\r\n> \r\n> That would mean _engaging with and indulging_ the command-line anarchy, whereas we want to _abstract it away_ - for the remaining cases, if any, where that doesn't work (to be diagnosed with `dbea`), there's `--%`.\r\n> \r\n> PowerShell is a _shell_, which means that however I pass an argument that I want the target executable to see as verbatim `foo=bar baz` should be fine, as long as I satisfy _PowerShell_'s syntax requirements.\r\n> \r\n> E.g., `$propValue = 'bar baz'; msiexec ... foo=$propValue` should just work, without you having to worry about non-conventional quoting requirements enforced by a rogue CLI - would you want to think about what the value of `$propValue` _could_ be and whether it _may_ require quoting?\r\n\r\n</details>\r\n\r\nNo, of course `msiexec ... foo=$propValue` should always be equivalent to `msiexec ... foo=\"$propValue\"`. (It's bad enough, that  `echoargs.exe $val` and `echoargs.exe \"$val\"` already aren't equivalent, but I guess fixing that is a lost cause. (Behaves different if $val is an array...))\r\n>(On a purely technical level, I'm not even sure that the parameter binder preserves the original quoting in a way that makes it still available to the command-line construction code - but, the more important point is: _we should not do it_).\r\n\r\n**No, we should absolutely not do that!**  That's not what I meant.\r\n<sup>I have thought about that in the past, and I think I mentioned that suggestion in some comment somewhere. But after thinking about it some more (and reading some of your comments), I definitely don't think that's a good idea. </sup>   \r\n\r\nWhat I meant was: Always construct the lpCommandLine with arguments quoted in a way that is understood by msiexec, etc. but also (and this is of course the most important aspect) always parsed correctly by executables that follow the common rules. \r\n\r\nIf I write in powershell\r\n```\r\nechoArgs.exe my\"arg=test va\"lue\r\n```\r\nit should result in the lpCommandLine\r\n```\r\nechoArgs.exe myarg=\"test value\"\r\n```\r\n\r\n> > If powershell implements special handling for these parameters, then these programs will probably never be fixed and any other cross platform tools will forever be unable to properly call these programs...\r\n> \r\n> Again - I don't see how any of these accommodations could break anything - do tell us if you know of any cases.\r\n\r\nNo, that can't break anything. My point is: If powershell doesn't implement any accommodations, microsoft would have more pressure to finally fix msiexec.\r\n",
      "created_at": "2020-08-20T17:14:08Z",
      "updated_at": "2020-08-20T19:35:34Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "> (Hypothetically, breakage is possible in the following scenario, but I do not think it is a real-world concern: A `prop=<value>` / `/opt:<value>` / `-opt:<value>` is being passed _and_ embedded `\"` are used _and_ the target executable doesn't also recognize these as `\"\"`-escaped; most CLIs on Windows _do_ support `\"\"`, usually _in addition to_ `\\\"`, and the only exceptions I'm aware of are _some_ shell/scripting hybrids that accept pieces of scripts as arguments, such as PowerShell's own CLI and Ruby and Perl; it's easy to exclude PowerShell CLI calls from the accommodation, and I think it's also worth doing for Ruby and Perl.)\r\n\r\nEven in the `prop=\"value with space\"` (or `/prop:\"value with space\"`) cases I would still always escape quotes using the typical backslash rules. This way these arguments are still fully compatible to the common rules. Yes, msiexec, etc. won't accept embedded literal quotes this way, but I'd say that's not a terribly common use case and therefore not really powershells problem. Users that actually need that, will have to resort to `--%`.\r\n\r\nThere is a whole class of applications, that won't accept `\"\"` as an escaped quote: Every application, that uses [CommandLineToArgvW](https://docs.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-commandlinetoargvw)\r\n\r\n<details><summary>Test for yourself:</summary>\r\nCreate exe in Windows Powershell (not .net core) or compile c# code yourself:\r\n\r\n```powershell\r\nAdd-Type -TypeDefinition @\"\r\nusing System;\r\nusing System.Runtime.InteropServices;\r\npublic class Args{\r\n    [DllImport(\"Shell32.dll\")]\r\n    static extern IntPtr CommandLineToArgvW([MarshalAs(UnmanagedType.LPWStr)]string lpCmdLine, out int pNumArgs);\r\n\r\n    public static string[] CommandLineToArgv(string CmdLine){\r\n        int argc=0;\r\n        IntPtr lpLPWSTR = CommandLineToArgvW(CmdLine,out argc);\r\n        string[] argv = new string[argc];\r\n        for (int i = 0; i < argc; i++){\r\n            argv[i] = Marshal.PtrToStringUni(Marshal.ReadIntPtr(lpLPWSTR,i*IntPtr.Size));\r\n        }\r\n        return argv;\r\n    }\r\n\r\n    public static void Main(string[] args){\r\n        Console.WriteLine(Environment.CommandLine);\r\n        Console.WriteLine();\r\n        Console.WriteLine(\r\n            string.Join(\r\n                Environment.NewLine,\r\n                Args.CommandLineToArgv(Environment.CommandLine)\r\n            )\r\n        );\r\n        //Console.ReadLine();\r\n    }\r\n}\r\n\"@ -OutputType ConsoleApplication -Outputassembly args_CommandLineToArgvW.exe\r\n```\r\n(yes, I know, dirty code - no error checking, memory not freed,... but it works.)\r\n\r\nTest:\r\n```powershell\r\n.\\args_CommandLineToArgvW.exe --% \"arg with \"\" embedded\" \"second arg\"\r\n```\r\nOutput:\r\n```\r\n\"C:\\path\\to\\args_CommandLineToArgvW.exe\"  \"arg with \"\" embedded\" \"second arg\"\r\n\r\nC:\\path\\to\\args_CommandLineToArgvW.exe\r\narg with \"\r\nembedded second\r\narg\r\n```\r\n</details>\r\n\r\nOn github alone there are [35,264 code results](https://github.com/search?l=C%2B%2B&q=CommandLineToArgvW&type=Code) for CommandLineToArgvW in c++ code. Even if 90% of those would be sample applications, that would still make thousands of applications, that don't work with literal quotes escaped as `\"\"`.",
      "created_at": "2020-08-20T17:58:58Z",
      "updated_at": "2020-08-20T19:31:37Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @TSlivede - **I don't think there's any  disagreement in substance here**.\r\n\r\nI am _not_ advocating for a hard-coded list of \"rogue\" CLIs (I had considered that earlier, but decided against it), I am indeed recommending that _any_ verbatim argument seen by PowerShell _on Windows_ that looks like `foo=bar baz` or `/foo:bar baz` / `-foo:bar baz` be passed to an external executable as `foo=\"bar baz\"` or `/foo:\"bar baz\"` / `-foo:\"bar baz\"` on the process command line.\r\n\r\nOf course, this _is_ an accommodation, but a highly beneficial one.\r\n\r\nAs for the other, closely related accommodation I proposed, namely to switch to `\"\"`-escaping in the presence of such arguments:\r\n\r\nThat `CommandLineToArgvW` doesn't support `\"\"` is a good reason _not_ to do that, so I agree with you that we should not attempt this, which means that `msiexec` / `msdeploy` calls with _embedded_ `\"` chars. (e.g., \r\n`msiexec ... PROP='bar \"n\" baz'`) will fail, unless they use `--%`, as you state - to be documented in `about_Native_Calls`.\r\n\r\n> But such a `echoArgs.exe` would be much less useful if not all .exe files are treated the same.\r\n\r\nGiven the above, the only scenarios in which `echoArgs.exe` then wouldn't tell you the truth is when you call _batch files_.\r\n\r\nTherefore, we either need a separate `echoArgs.cmd` or `dbea`, whose `-UseBatchFile` switch uses a batch-file behind the scenes.\r\n",
      "created_at": "2020-08-20T18:28:10Z",
      "updated_at": "2020-08-20T18:28:10Z"
    },
    {
      "author": "Artoria2e5",
      "author_association": "NONE",
      "body": "> What I meant was: Always construct the lpCommandLine with arguments quoted in a way that is understood by msiexec, etc. but also (and this is of course the most important aspect) always parsed correctly by executables that follow the common rules.\r\n> \r\n> If I write in powershell\r\n> \r\n> ```\r\n> echoArgs.exe my\"arg=test va\"lue\r\n> ```\r\n> \r\n> it should result in the lpCommandLine\r\n> \r\n> ```\r\n> echoArgs.exe myarg=\"test value\"\r\n> ```\r\n\r\nThis can be trivially done by just escaping the two pieces separately. My PR has a TODO on that while I decide on exactly which separators I am going to need to accommodate: anything more than  `=` and `:`? ",
      "created_at": "2020-08-20T20:10:40Z",
      "updated_at": "2020-08-20T20:11:08Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@Artoria2e5\r\n\r\nI'm assuming `=` and `:` are sufficient.\r\n\r\nHowever, I wonder how aggressive we should be in applying this quoting style - even though it should be benign, if not needed.\r\n\r\nHere's a regex that matches only property=value / option-with-value-like arguments (_update_: see [below](https://github.com/PowerShell/PowerShell/pull/13482#issuecomment-677915390) regarding the valid concern about matching something like `c:\\program files` and turning it into the awkward `c:\"\\program files\"`):\r\n\r\n```powershell\r\nPS> 'prop=nospaces', '!=with spaces', 'prop=with spaces', '/opt:with spaces', '-opt:with spaces', '--opt-foo=with spaces', 'prop=with \" and spaces' | % {\r\n  if ($_ -match '^(?<key>[/-]?[-\\w]+)(?<sep>[:=])(?<value>.*? .*)$') {\r\n    '{0}{1}\"{2}\"' -f $Matches.key, $Matches.sep, ($Matches.value -replace '\"', '\\\"')\r\n  }\r\n  else {\r\n    # No special quoting needed.\r\n    $_\r\n  }\r\n}\r\n\r\nprop=nospaces\r\n!=with spaces\r\nprop=\"with spaces\"\r\n/opt:\"with spaces\"\r\n-opt:\"with spaces\"\r\n--opt-foo=\"with spaces\"\r\nprop=\"with \\\" and spaces\"\r\n```\r\n",
      "created_at": "2020-08-20T21:07:38Z",
      "updated_at": "2020-08-21T12:13:34Z"
    },
    {
      "author": "TSlivede",
      "author_association": "NONE",
      "body": "In [my implementation](https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-303345059) I also use `:` and `=` as seperators, but I allowed `:` as a seperator only for keys starting with `/` or `-`. Reason: I don't want paths quoted as `C:\"\\Program Files\"` - although that works for almost all programs, it looks stupid. Alternatively one could explicitly exclude single letter keys with `:` as seperator...",
      "created_at": "2020-08-20T21:28:21Z",
      "updated_at": "2020-08-20T21:28:21Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Good point about paths, @TSlivede (as an aside: very nice, concise implementation; `\\d` isn't necessary, it's covered by `\\w`), I actually prevent that in `ie` in a similar fashion, which still covers `msiexec` / `msdeploy` and `cmdkey`.\r\n\r\nThe question is: does it cover all high-profile cases? \r\n\r\nWe should strive for a pattern that is easy to conceptualize and document (yours qualifies), so I suggest we avoid exceptions for single-letter keys, if possible.",
      "created_at": "2020-08-20T21:52:05Z",
      "updated_at": "2020-08-20T21:52:05Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Below is **a proof-of-concept written in PowerShell that _implements all accommodations_**:\r\n\r\nNote:\r\n\r\n* Code applies to Windows only; on Unix, `ProcessStartInfo.ArgumentList` is sufficient.\r\n\r\n* On Windows, the code can be bypassed in favor of `ProcessStartInfo.ArgumentList` if neither (a) a batch file (or `cmd.exe` _directly_) is being called and (b) none of the arguments match regex `'^([/-]\\w+[=:]|\\w+=)(.*? .*)$'`, which is the previously discussed pattern for `msiexec`-style arguments.\r\n\r\nRunning the code, which includes Pester tests, yields the following, which shows how the verbatim input arguments must be transformed to form part of the command-line string that is passed to `ProcessStartInfo.Arguments` (the `ExpectedIfDifferent` column would only be filled in if the quoting didn't work as expected):\r\n\r\n```none\r\n--- NOT calling a batch file:\r\n\r\nVerbatim             Quoted                   ExpectedIfDifferent\r\n--------             ------                   -------------------\r\n                     \"\"\r\nfoo=bar none         foo=\"bar none\"\r\n/foo:bar none        /foo:\"bar none\"\r\n-foo:bar none        -foo:\"bar none\"\r\nfoo=bar \"quote\" none foo=\"bar \\\"quote\\\" none\"\r\nfoo:not me           \"foo:not me\"\r\nfoo=notme            foo=notme\r\nnotmeeither          notmeeither\r\nc:\\program files\\    \"c:\\program files\\\\\"\r\na \"b c\" d            \"a \\\"b c\\\" d\"\r\na \\\"b c\\\" d          \"a \\\\\\\"b c\\\\\\\" d\"\r\n3\" of snow           \"3\\\" of snow\"\r\nab\\                  ab\\\r\na b\\\\                \"a b\\\\\\\\\"\r\na&b                  a&b\r\na\"b                  a\\\"b\r\n\r\n--- Calling a batch file:\r\n\r\nVerbatim             Quoted                   ExpectedIfDifferent\r\n--------             ------                   -------------------\r\n                     \"\"\r\nfoo=bar none         foo=\"bar none\"\r\n/foo:bar none        /foo:\"bar none\"\r\n-foo:bar none        -foo:\"bar none\"\r\nfoo=bar \"quote\" none foo=\"bar \"\"quote\"\" none\"\r\nfoo:not me           \"foo:not me\"\r\nfoo=notme            foo=notme\r\nnotmeeither          notmeeither\r\nc:\\program files\\    \"c:\\program files\\\\\"\r\na \"b c\" d            \"a \"\"b c\"\" d\"\r\na \\\"b c\\\" d          \"a \\\\\"\"b c\\\\\"\" d\"\r\n3\" of snow           \"3\"\" of snow\"\r\nab\\                  ab\\\r\na b\\\\                \"a b\\\\\\\\\"\r\na&b                  \"a&b\"\r\na\"b                  \"a\"\"b\"\r\n```\r\n\r\nCode:\r\n\r\n```powershell\r\n# WINDOWS ONLY\r\n\r\n# Sample arguments, as seen verbatim by PowerShell before constructing\r\n# the command line.\r\n# Note: The first, empty line represents an empty argument ('' / \"\").\r\n$sampleArgs = @'\r\n\r\nfoo=bar none\r\n/foo:bar none\r\n-foo:bar none\r\nfoo=bar \"quote\" none\r\nfoo:not me\r\nfoo=notme\r\nnotmeeither\r\nc:\\program files\\\r\na \"b c\" d\r\na \\\"b c\\\" d\r\n3\" of snow\r\nab\\\r\na b\\\\\r\na&b\r\na\"b\r\n'@ -split '\\r?\\n'\r\n\r\n# Non-batch files: expected quoted forms:\r\n# * \\\"-escaping\r\n# * double-quoting only for space-less arguments.\r\n# * msiexec-style partial argument double-quoting\r\n$expectedQuoted = @'\r\n\"\"\r\nfoo=\"bar none\"\r\n/foo:\"bar none\"\r\n-foo:\"bar none\"\r\nfoo=\"bar \\\"quote\\\" none\"\r\n\"foo:not me\"\r\nfoo=notme\r\nnotmeeither\r\n\"c:\\program files\\\\\"\r\n\"a \\\"b c\\\" d\"\r\n\"a \\\\\\\"b c\\\\\\\" d\"\r\n\"3\\\" of snow\"\r\nab\\\r\n\"a b\\\\\\\\\"\r\na&b\r\na\\\"b\r\n'@ -split '\\r?\\n'\r\n\r\n# Batch files: expected quoted forms:\r\n# * \"\"-escaping instead of \\\"-escaping\r\n# * double-qouting also for space-less args with cmd.exe metachars.\r\n# * msiexec-style partial argument double-quoting\r\n$expectedQuotedForBatchFile = @'\r\n\"\"\r\nfoo=\"bar none\"\r\n/foo:\"bar none\"\r\n-foo:\"bar none\"\r\nfoo=\"bar \"\"quote\"\" none\"\r\n\"foo:not me\"\r\nfoo=notme\r\nnotmeeither\r\n\"c:\\program files\\\\\"\r\n\"a \"\"b c\"\" d\"\r\n\"a \\\\\"\"b c\\\\\"\" d\"\r\n\"3\"\" of snow\"\r\nab\\\r\n\"a b\\\\\\\\\"\r\n\"a&b\"\r\n\"a\"\"b\"\r\n'@ -split '\\r?\\n'\r\n\r\n$false, $true | ForEach-Object {\r\n\r\n  $callingABatchFile = $_\r\n\r\n  \"--- $($callingABatchFile ? 'C' : 'NOT c')alling a batch file: \" | Write-Host -ForegroundColor Green\r\n\r\n  # Quote the arguments for use as part of the raw command line.\r\n  $quotedArgs = $sampleArgs | ForEach-Object {\r\n\r\n    if ('' -eq $_) { return '\"\"' } # Empty argument, always represented as \"\"\r\n\r\n    # Analyze the argument.\r\n    $mustDQuote = $_.Contains(' ') -or ($callingABatchFile -and $_ -match '[\"&|<>^,;]')\r\n    $mustPartiallyDQuote = $mustDQuote -and $_ -match '^([/-]\\w+[=:]|\\w+=)(.+)$'\r\n    $escapedDQuote = $callingABatchFile ? '\"\"' : '\\\"'\r\n\r\n    if ($mustPartiallyDQuote) { \r\n      $prefix, $quotedArg = $Matches[1], $Matches[2]\r\n    }\r\n    else {\r\n      $prefix = ''\r\n      $quotedArg = $_\r\n    }\r\n\r\n    # Escape any embedded \" first, including doubling \\ instances before them.\r\n    $quotedArg = $quotedArg -replace '\\\\+(?=\")', '$&$&' -replace '\"', $escapedDQuote\r\n\r\n    # If double-quoting must be used, trailing '\\'s must be doubled.\r\n    if ($mustDQuote) { $quotedArg = $quotedArg -replace '\\\\+$', '$&$&' }\r\n\r\n    # Apply double-quoting, if necessary, and output:\r\n    $prefix + ($mustDQuote ? ('\"{0}\"' -f $quotedArg) : $quotedArg)\r\n\r\n  }\r\n\r\n  $expected = ($callingABatchFile ? $expectedQuotedForBatchFile : $expectedQuoted)\r\n\r\n  # Output to the host to see the transformations.\r\n  0..($sampleArgs.Count-1) | ForEach-Object {\r\n    [pscustomobject] @{ Verbatim = $sampleArgs[$_]; Quoted = $quotedArgs[$_]; 'ExpectedIfDifferent' = if ($quotedArgs[$_] -ne $expected[$_]) { $expected[$_]} }\r\n  } | Out-Host\r\n\r\n  # Run the Pester test.\r\n  try {\r\n    $quotedArgs | Should -BeExactly $expected\r\n  } catch { \r\n    $_ | Write-Error # Write error and continue.\r\n  }\r\n\r\n}\r\n```\r\n\r\n",
      "created_at": "2020-08-21T21:23:46Z",
      "updated_at": "2020-08-22T23:05:50Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as Review Needed because it has been there has not been any activity for **7 days**.\nMaintainer, please provide feedback and/or mark it as `Waiting on Author`",
      "created_at": "2020-08-30T02:00:16Z",
      "updated_at": "2020-08-30T02:00:16Z"
    },
    {
      "author": "JamesWTruher",
      "author_association": "MEMBER",
      "body": "i'm going to close this and take a different tack. Some things have changed underneath this which need to be addressed.",
      "created_at": "2020-10-15T22:56:41Z",
      "updated_at": "2020-10-15T22:56:41Z"
    }
  ],
  "created_at": "2020-08-19T20:20:46Z",
  "number": 13482,
  "state": "closed",
  "title": "WIP: Try to manage quotes in strings when calling native executables",
  "updated_at": "2020-10-15T22:56:42Z"
}