{
  "_url": "https://github.com/PowerShell/PowerShell/issues/15256",
  "author": "shadow-identity",
  "body": "Emojis do not work either in the input line or in the applications output. This cannot be done even using the standard Windows built-in tool. This feature has been in all competitive shells for years.\r\n\r\n## Steps to reproduce\r\n\r\n* Use Win + . to open the Windows Emoji Keyboard\r\n* Select any emoji to insert\r\n\r\n## Expected behavior\r\n\r\nthe selected emoji must be inserted\r\n\r\n## Actual behavior\r\n\r\nWrong symbol inserted instead\r\n![image](https://user-images.githubusercontent.com/1223112/115105613-5fed5c00-9f60-11eb-97d1-df842b6daf01.png)\r\n\r\n## Environment data\r\nWin 10 pro 20H2\r\n\r\n```none\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.1.3\r\nPSEdition                      Core\r\nGitCommitId                    7.1.3\r\nOS                             Microsoft Windows 10.0.19042\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "This issue isn\u2019t a problem with PowerShell or any other shells in Windows but rather the console host/terminal you are using. The conhost application is started up when you start PowerShell and it has very limited support for Unicode characters. This has nothing to do with limitations in PowerShell.\r\n\r\nWhat MS are recommending you to use is the Windows Terminal app which has full support for Unicode characters including emojis and the simple paste into the terminal should work. The downside is right now you cannot say use Windows Terminal when you run pwsh, you need to start pwsh from Windows Terminal which is more how things work on non-Windows hosts.",
      "created_at": "2021-04-17T07:59:49Z",
      "updated_at": "2021-04-17T07:59:49Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "From Windows Terminal pasting via the WIndows Emoji selector works when running WSL (Ubuntu 18.04) but it does NOT work when running PowerShell 7.1.3 (or CMD).  So perhaps an issue with conhost which both PS and CMD use but Ubuntu does not.  This should probably be filed on the `Windows Terminal` repo (conhost impl lives there).  Actually, first checkout these existing issues on that repo:\r\n\r\nhttps://github.com/microsoft/terminal/issues/190\r\nhttps://github.com/microsoft/terminal/issues/1503",
      "created_at": "2021-04-17T19:09:03Z",
      "updated_at": "2021-04-17T19:09:03Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "Ah my apologies I thought it was possible in WT. It does seem like PSReadLine might have issues reading surrogate pair UTF-16 characters. When trying to input \ud83d\ude0a into Windows Terminal I get the following traceback from PSReadLine\r\n\r\n```\r\nOops, something went wrong.\r\nPlease report this bug with ALL the details below, including both the 'Environment' and 'Exception' sections.\r\nPlease report on GitHub: https://github.com/PowerShell/PSReadLine/issues/new?template=Bug_Report.md\r\nThank you!\r\n\r\n### Environment\r\nPSReadLine: 2.1.0\r\nPowerShell: 7.1.3\r\nOS: Microsoft Windows 10.0.20334\r\nBufferWidth: 120\r\nBufferHeight: 30\r\n\r\nLast 2 Keys\r\n \ufffd Enter\r\n\r\n### Exception\r\nSystem.Text.EncoderFallbackException: Unable to translate Unicode character \\\\uD83D at index 0 to specified code page.\r\n   at System.Text.EncoderExceptionFallbackBuffer.Fallback(Char charUnknown, Int32 index)\r\n   at System.Text.EncoderFallbackBuffer.InternalFallback(ReadOnlySpan`1 chars, Int32& charsConsumed)\r\n   at System.Text.Encoding.GetBytesWithFallback(ReadOnlySpan`1 chars, Int32 originalCharsLength, Span`1 bytes, Int32 originalBytesLength, EncoderNLS encoder)\r\n   at System.Text.Encoding.GetBytesWithFallback(Char* pOriginalChars, Int32 originalCharCount, Byte* pOriginalBytes, Int32 originalByteCount, Int32 charsConsumedSoFar, Int32 bytesWrittenSoFar, EncoderNLS encoder)\r\n   at System.Text.Encoding.GetBytes(Char* pChars, Int32 charCount, Byte* pBytes, Int32 byteCount, EncoderNLS encoder)\r\n   at System.Text.EncoderNLS.GetBytes(Char* chars, Int32 charCount, Byte* bytes, Int32 byteCount, Boolean flush)\r\n   at System.Text.EncoderNLS.GetBytes(Char[] chars, Int32 charIndex, Int32 charCount, Byte[] bytes, Int32 byteIndex, Boolean flush)\r\n   at System.IO.StreamWriter.Flush(Boolean flushStream, Boolean flushEncoder)\r\n   at System.IO.StreamWriter.Dispose(Boolean disposing)\r\n   at System.IO.TextWriter.Dispose()\r\n   at Microsoft.PowerShell.PSConsoleReadLine.<>c__DisplayClass83_0.<WriteHistoryRange>b__0()\r\n   at Microsoft.PowerShell.PSConsoleReadLine.WithHistoryFileMutexDo(Int32 timeout, Action action)\r\n   at Microsoft.PowerShell.PSConsoleReadLine.WriteHistoryRange(Int32 start, Int32 end, Boolean overwritten)\r\n   at Microsoft.PowerShell.PSConsoleReadLine.IncrementalHistoryWrite()\r\n   at Microsoft.PowerShell.PSConsoleReadLine.MaybeAddToHistory(String result, List`1 edits, Int32 undoEditIndex, Boolean fromDifferentSession, Boolean fromInitialRead)\r\n   at Microsoft.PowerShell.PSConsoleReadLine.InputLoop()\r\n   at Microsoft.PowerShell.PSConsoleReadLine.ReadLine(Runspace runspace, EngineIntrinsics engineIntrinsics, CancellationToken cancellationToken)\r\n```\r\n\r\nThe character when UTF-16 encoded is a surrogate pair (4 bytes) that's encoded as `0xD83D 0xDE0A`. You can see in the exception it tried to only encode the first part of the pair which by itself isn't a valid character. It does seem like more work needs to be done in Windows Terminal to actually display those chars on input but maybe PSReadLine needs some extra logic to handle surrogate points.\r\n\r\nI also could totally be wrong here so happy for anyone to correct me.",
      "created_at": "2021-04-17T23:40:04Z",
      "updated_at": "2021-04-17T23:40:04Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "Looks like there is an open issue for this as well https://github.com/PowerShell/PSReadLine/issues/2358 and https://github.com/PowerShell/PSReadLine/issues/1329.",
      "created_at": "2021-04-17T23:41:47Z",
      "updated_at": "2021-04-17T23:43:22Z"
    },
    {
      "author": "ninmonkey",
      "author_association": "NONE",
      "body": "from that thread, it sounds like it is sending one `code-unit` (2bytes) at a time, rather than the `4byte` codepoint. If true that makes sense why there's an exception when I'm using `utf8`. However, it breaks on `unicode` (ie: `utf16le`) too.  \r\n\r\n```ps1\r\n    # testing \u23f0                                            \r\n    while ($true) {                                         \r\n        '0x{0:X4}' -f [int][Console]::ReadKey($true).KeyChar\r\n    }                                                       \r\n0x23F0                                                      \r\n                                                            \r\n    # testing \ud83d\udc12                                            \r\n    while ($true) {                                         \r\n        '0x{0:X4}' -f [int][Console]::ReadKey($true).KeyChar\r\n    }                                                       \r\n0xD83D                                                      \r\n0xDC12                                                      \r\n```\r\n\r\n## Breaks on either encoding\r\n\r\nFor both tests I:\r\n\r\n1. Started a new session\r\n2. Disabled PSReadlineSuggestions\r\n3. Set all 3 encodings to the same type\r\n4. type `'` then `win+.`\r\n\r\n## Test 1: UTF-16le\r\n\r\n<details><summary>\r\n (Click for full log)\r\n\r\n```ps1\r\n$OutputEncoding = [console]::InputEncoding = [console]::OutputEncoding = [System.Text.UnicodeEncoding]::new()\r\n```\r\n\r\n</summary>\r\n\r\n```ps1\r\n\ud83d\udc12> Set-PSReadLineOption -PredictionSource None\r\n$OutputEncoding = [console]::InputEncoding = [console]::OutputEncoding = [System.Text.UnicodeEncoding]::new()\r\nGet-ConsoleEncoding\r\n\r\nName                      Encoding CodePage isSingleByte\r\n----                      -------- -------- ------------\r\nOutputEncoding            Unicode      1200        False\r\n[console]::InputEncoding  Unicode      1200        False\r\n[console]::OutputEncoding Unicode      1200        False\r\n\r\n\r\n\ud83d\udc12> # now paste a '\ud83d\ude01' smiley using \"win+.\" hotkey\r\n\r\n\ud83d\udc12> '\ufffd'\r\n\r\nOops, something went wrong.\r\nPlease report this bug with ALL the details below, including both the 'Environment' and 'Exception' sections.\r\nPlease report on GitHub: https://github.com/PowerShell/PSReadLine/issues/new?template=Bug_Report.md\r\nThank you!\r\n\r\n### Environment\r\nPSReadLine: 2.2.0-beta2\r\nPowerShell: 7.1.2\r\nOS: Microsoft Windows 10.0.19041\r\nBufferWidth: 213\r\nBufferHeight: 71\r\n\r\nLast 67 Keys\r\n\r\nCtrl+l Ctrl+v Home Delete Delete [ Enter\r\nUpArrow UpArrow Enter\r\nBackspace UpArrow UpArrow Alt+Enter g e t - c o n s o l e e n Tab Enter\r\nUpArrow Ctrl+a Ctrl+x UpArrow Home UpArrow $ O u t p u t E n c o d i n g Spacebar = Spacebar Enter\r\nUpArrow Ctrl+a Ctrl+x Ctrl+v Enter\r\nUpArrow UpArrow UpArrow Enter\r\n' \ufffd ' Enter\r\n\r\n### Exception\r\n\r\nSystem.Text.EncoderFallbackException: Unable to translate Unicode character \\\\uD83D at index 1 to specified code page.\r\nat System.Text.EncoderExceptionFallbackBuffer.Fallback(Char charUnknown, Int32 index)\r\nat System.Text.EncoderFallbackBuffer.InternalFallback(ReadOnlySpan`1 chars, Int32& charsConsumed)\r\nat System.Text.Encoding.GetBytesWithFallback(ReadOnlySpan`1 chars, Int32 originalCharsLength, Span`1 bytes, Int32 originalBytesLength, EncoderNLS encoder)\r\nat System.Text.Encoding.GetBytesWithFallback(Char* pOriginalChars, Int32 originalCharCount, Byte* pOriginalBytes, Int32 originalByteCount, Int32 charsConsumedSoFar, Int32 bytesWrittenSoFar, EncoderNLS encoder)\r\nat System.Text.Encoding.GetBytes(Char* pChars, Int32 charCount, Byte* pBytes, Int32 byteCount, EncoderNLS encoder)\r\nat System.Text.EncoderNLS.GetBytes(Char[] chars, Int32 charIndex, Int32 charCount, Byte[] bytes, Int32 byteIndex, Boolean flush)\r\nat System.IO.StreamWriter.Flush(Boolean flushStream, Boolean flushEncoder)\r\nat System.IO.StreamWriter.Dispose(Boolean disposing)\r\nat System.IO.TextWriter.Dispose()\r\nat Microsoft.PowerShell.PSConsoleReadLine.<>c__DisplayClass98_0.<WriteHistoryRange>b__0()\r\nat Microsoft.PowerShell.PSConsoleReadLine.WithHistoryFileMutexDo(Int32 timeout, Action action)\r\nat Microsoft.PowerShell.PSConsoleReadLine.WriteHistoryRange(Int32 start, Int32 end, Boolean overwritten)\r\nat Microsoft.PowerShell.PSConsoleReadLine.IncrementalHistoryWrite()\r\nat Microsoft.PowerShell.PSConsoleReadLine.MaybeAddToHistory(String result, List`1 edits, Int32 undoEditIndex, Boolean fromDifferentSession, Boolean fromInitialRead)\r\nat Microsoft.PowerShell.PSConsoleReadLine.InputLoop()\r\nat Microsoft.PowerShell.PSConsoleReadLine.ReadLine(Get-Runspace runspace, EngineIntrinsics engineIntrinsics, CancellationToken cancellationToken)\r\n\r\n\ud83d\udc12> '\ufffd'\r\n\ufffd\r\n\r\n\ud83d\udc12> Get-ConsoleEncoding\r\n\r\nName                      Encoding        CodePage isSingleByte\r\n----                      --------        -------- ------------\r\nOutputEncoding            Unicode             1200        False\r\n[console]::InputEncoding  Unicode             1200        False\r\n[console]::OutputEncoding Unicode (UTF-8)    65001        False\r\n```\r\n</details>\r\n\r\n## Test 2: UTF-8\r\n\r\n<details><summary>\r\n (Click for full log)\r\n\r\n```ps1\r\n$OutputEncoding = [console]::InputEncoding = [console]::OutputEncoding = [System.Text.UTF8Encoding]::new()\r\n```\r\n\r\n</summary>\r\n\r\n```ps1\r\n\ud83d\udc12> Set-PSReadLineOption -PredictionSource None\r\n$OutputEncoding = [console]::InputEncoding = [console]::OutputEncoding = [System.Text.UTF8Encoding]::new()\r\nGet-ConsoleEncoding\r\n\r\nName                      Encoding        CodePage isSingleByte\r\n----                      --------        -------- ------------\r\nOutputEncoding            Unicode (UTF-8)    65001        False\r\n[console]::InputEncoding  Unicode (UTF-8)    65001        False\r\n[console]::OutputEncoding Unicode (UTF-8)    65001        False\r\n\r\n\ud83d\udc12> # now paste a '\ud83d\ude01' smiley using \"win+.\" hotkey\r\n\r\n\ud83d\udc12> '\ufffd'\r\n\r\nOops, something went wrong.\r\nPlease report this bug with ALL the details below, including both the 'Environment' and 'Exception' sections.\r\nPlease report on GitHub: https://github.com/PowerShell/PSReadLine/issues/new?template=Bug_Report.md\r\nThank you!\r\n\r\n### Environment\r\nPSReadLine: 2.2.0-beta2\r\nPowerShell: 7.1.2\r\nOS: Microsoft Windows 10.0.19041\r\nBufferWidth: 213\r\nBufferHeight: 84\r\n\r\nLast 31 Keys\r\n\r\nCtrl+v Home Home Delete Delete Delete Delete End Home DownArrow Shift+End Ctrl+v Ctrl+z Ctrl+v Ctrl+z Shift+Home Ctrl+v Home $ Home End DownArrow Enter\r\nUpArrow UpArrow UpArrow Enter\r\n' \ufffd ' Enter\r\n\r\n### Exception\r\n\r\nSystem.Text.EncoderFallbackException: Unable to translate Unicode character \\\\uD83D at index 1 to specified code page.\r\nat System.Text.EncoderExceptionFallbackBuffer.Fallback(Char charUnknown, Int32 index)\r\nat System.Text.EncoderFallbackBuffer.InternalFallback(ReadOnlySpan`1 chars, Int32& charsConsumed)\r\nat System.Text.Encoding.GetBytesWithFallback(ReadOnlySpan`1 chars, Int32 originalCharsLength, Span`1 bytes, Int32 originalBytesLength, EncoderNLS encoder)\r\nat System.Text.Encoding.GetBytesWithFallback(Char* pOriginalChars, Int32 originalCharCount, Byte* pOriginalBytes, Int32 originalByteCount, Int32 charsConsumedSoFar, Int32 bytesWrittenSoFar, EncoderNLS encoder)\r\nat System.Text.Encoding.GetBytes(Char* pChars, Int32 charCount, Byte* pBytes, Int32 byteCount, EncoderNLS encoder)\r\nat System.Text.EncoderNLS.GetBytes(Char[] chars, Int32 charIndex, Int32 charCount, Byte[] bytes, Int32 byteIndex, Boolean flush)\r\nat System.IO.StreamWriter.Flush(Boolean flushStream, Boolean flushEncoder)\r\nat System.IO.StreamWriter.Dispose(Boolean disposing)\r\nat System.IO.TextWriter.Dispose()\r\nat Microsoft.PowerShell.PSConsoleReadLine.<>c__DisplayClass98_0.<WriteHistoryRange>b__0()\r\nat Microsoft.PowerShell.PSConsoleReadLine.WithHistoryFileMutexDo(Int32 timeout, Action action)\r\nat Microsoft.PowerShell.PSConsoleReadLine.WriteHistoryRange(Int32 start, Int32 end, Boolean overwritten)\r\nat Microsoft.PowerShell.PSConsoleReadLine.IncrementalHistoryWrite()\r\nat Microsoft.PowerShell.PSConsoleReadLine.MaybeAddToHistory(String result, List`1 edits, Int32 undoEditIndex, Boolean fromDifferentSession, Boolean fromInitialRead)\r\nat Microsoft.PowerShell.PSConsoleReadLine.InputLoop()\r\nat Microsoft.PowerShell.PSConsoleReadLine.ReadLine(Get-Runspace runspace, EngineIntrinsics engineIntrinsics, CancellationToken cancellationToken)\r\n\r\n\ud83d\udc12> '\ufffd'\r\n\ufffd\r\n\r\n\ud83d\udc12> Get-ConsoleEncoding\r\n\r\nName                      Encoding        CodePage isSingleByte\r\n----                      --------        -------- ------------\r\nOutputEncoding            Unicode (UTF-8)    65001        False\r\n[console]::InputEncoding  Unicode (UTF-8)    65001        False\r\n[console]::OutputEncoding Unicode (UTF-8)    65001        False\r\n```\r\n\r\n</details>\r\n\r\n## Interesting\r\n\r\n@jborean93 :\r\n\r\n- When testing as `utf16le` and it crashes, it changes `[console]::OutputEncoding` to `utf8` by itself. (see log)\r\n- It left `[console]::InputEncoding` and `$OutputEncoding` set as `utf16le`\r\n- it **breaks** when `Utf16SequenceLength > 1`\r\n- it **works** when `Utf16SequenceLength == 1`\r\n\r\nThat's why the other thread had no problem with `\u23f0`, but `\ud83d\ude03` would crash\r\n```ps1\r\n\ud83d\udc12> '\ud83d\ude03\u23f0'.EnumerateRunes() | ft                                 \r\n                                                                 \r\nIsAscii IsBmp Plane Utf16SequenceLength Utf8SequenceLength  Value\r\n------- ----- ----- ------------------- ------------------  -----\r\n  False False     1                   2                  4 128515\r\n  False  True     0                   1                  3   9200\r\n```",
      "created_at": "2021-04-18T05:24:39Z",
      "updated_at": "2021-04-18T05:36:48Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "So there's definitely a problem with PSReadLine here, I can type in `Remove-Module -Name PSReadLine` then paste in emojiis without a failure. The pasted value is still not displayed properly and seems to be treated as 2 separate chars (because it's a surrogate pair) but the raw byte value is read correctly by PowerShell. For this test I am using `\ud83d\ude03` as referenced in @ninmonkey post just above. This value as UTF-8 encoded is `0xF0 0x9F 0x98 0x83`.\r\n\r\n![image](https://user-images.githubusercontent.com/8462645/115135564-cb1c5880-a05c-11eb-8f1b-62914498e451.png)\r\n\r\nSo you can paste surrogate pair chars into Windows Terminal and it is read as a correct value in pwsh as long as PSReadLine isn't involved but the text that is printed to represent that char isn't correct. Windows Terminal does support outputting those chars due to the ConPTY work that it has implemented.\r\n\r\nTLDR I think there are 2 bugs\r\n\r\n* PSReadLine is unable to handle unicode characters represented by surrogate pair in UTF-16 causing the stack trace failure\r\n  * Issues here https://github.com/PowerShell/PowerShell/issues/15256#issuecomment-821903005\r\n* Windows Terminal is unable to display those initial input characters as they are typed/pasted into the terminal\r\n  * Maybe https://github.com/microsoft/terminal/issues/190 and https://github.com/microsoft/terminal/issues/1503\r\n  * I'm less confident about these problems as WT does support emojis on output as seen by the screenshot\r\n  * This could still be an issue with pwsh re-echoing the input characters one at a time potentially\r\n  * Someone more knowledgeable on this can probably provide better info here",
      "created_at": "2021-04-18T05:48:42Z",
      "updated_at": "2021-04-18T06:16:30Z"
    },
    {
      "author": "ninmonkey",
      "author_association": "NONE",
      "body": "In regards to **Windows Terminal**, I am now able to paste, and use the `start+.` hotkey to insert glyphs.\r\n\r\n![image](https://user-images.githubusercontent.com/3892031/144862148-7f68f335-2b72-424a-baaf-b8424462e395.png)\r\n\r\nI tested `5.1`, `7.1`, and `7.2` -- they all worked on  `\ud83d\ude03` ( windows terminal preview Windows Terminal Preview\r\nVersion: 1.12.2931.0 ), although it has been working for quite a while.\r\n",
      "created_at": "2021-12-06T14:21:10Z",
      "updated_at": "2021-12-06T14:21:53Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "Although backspace only deletes half of the emoji i.e., it takes two backspaces to entirely remove the emoji.",
      "created_at": "2021-12-06T17:23:51Z",
      "updated_at": "2021-12-06T17:23:51Z"
    },
    {
      "author": "ninmonkey",
      "author_association": "NONE",
      "body": "> Although backspace only deletes half of the emoji i.e., it takes two backspaces to entirely remove the emoji.\r\n\r\nThat makes sense because when encoded as utf16, `\ud83d\ude03` [has a sequence length of 2](https://docs.microsoft.com/en-us/dotnet/api/system.text.rune.utf16sequencelength?view=net-5.0#System_Text_Rune_Utf16SequenceLength) (2 code-units required to represent one codepoint)\r\n\r\n![image](https://user-images.githubusercontent.com/3892031/145143312-e1f2233e-38dc-4399-9028-f53a6e714484.png)\r\n\r\n```ps1\r\n$grapheme = \"`u{1f469}`u{1f3fc}`u{200d}`u{1f9b3}\"\r\n$grapheme.EnumerateRunes() | ft -AutoSize\r\n```\r\n\r\n[the grapheme](https://manishearth.github.io/blog/2017/01/14/stop-ascribing-meaning-to-unicode-code-points/#grapheme-clusters) `\ud83d\udc69\ud83c\udffc\u200d\ud83e\uddb3` [woman-medium-light-skin-tone-white-hair](https://emojipedia.org/woman-medium-light-skin-tone-white-hair/) requires you to hit backspace 7 times\r\n\r\n![image](https://user-images.githubusercontent.com/3892031/145144114-8236c56c-16ca-4c72-9871-67a4002f407c.png)\r\n\r\nWhat is a 'single character' in Unicode is complicated. You can see on my screenshot, it doesn't even render `woman-medium-light-skin-tone-white-hair` as one \"character\". Depending on what version of Unicode your system supports, different people will see different number of \"characters\" for the exact same string.\r\n\r\n![image](https://user-images.githubusercontent.com/3892031/145144567-6d63a7bc-5379-4168-818c-84a8218aaf05.png)\r\n\r\n\r\n",
      "created_at": "2021-12-08T03:47:30Z",
      "updated_at": "2021-12-08T03:47:30Z"
    }
  ],
  "created_at": "2021-04-17T07:44:12Z",
  "labels": [
    "WG-Interactive-Console",
    "Needs-Triage"
  ],
  "number": 15256,
  "state": "open",
  "title": "Built-in way to paste emojis doesn't work",
  "updated_at": "2021-12-08T03:47:31Z"
}