{
  "_url": "https://github.com/PowerShell/PowerShell/issues/13664",
  "author": "robertbaker",
  "body": "<!--\r\n\r\nFor Windows PowerShell 5.1 issues, suggestions, or feature requests please use the following link instead:\r\nWindows PowerShell [UserVoice](https://windowsserver.uservoice.com/forums/301869-powershell)\r\n\r\nThis repository is **ONLY** for PowerShell Core 6 and PowerShell 7+ issues.\r\n\r\n- Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\r\n- Search the existing issues.\r\n- Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\r\n- Refer to the [known issues](https://docs.microsoft.com/powershell/scripting/whats-new/known-issues-ps6).\r\n\r\n-->\r\n\r\n## Steps to reproduce\r\n\r\n```powershell\r\ntaskkill /IM \"App With Tray Icon.exe\"\r\n```\r\nWithout moving mouse, tray icon disappears from tray immediately.\r\n\r\n```powershell\r\nStop-Process \"App With Tray Icon\"\r\n```\r\nWithout moving mouse, tray icon is stays visible. Additionally, starting the process again will display a duplicate icon, the old one disappears when hovering over it.\r\n\r\n## Expected behavior\r\n\r\nStop-Process by default should be SIGTERM, graceful.\r\nSIGKILL should only be used after timeout or -FORCE is used.\r\n\r\n## Actual behavior\r\nThe old tray icon stays visible because app is killed. (This is not actually PowerShell specific, but a technical caveat when processes are killed.)\r\n\r\n## Workaround\r\nUse taskkill in place of stop-process for processes that have tray icons.\r\n\r\n## Environment data\r\n\r\n<!-- provide the output of $PSVersionTable -->\r\n\r\n```none\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.0.3\r\nPSEdition                      Core\r\nGitCommitId                    7.0.3\r\nOS                             Microsoft Windows 10.0.20215\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@robertbaker Please check with latest PowerShell 7.1 Preview build.",
      "created_at": "2020-09-20T15:36:19Z",
      "updated_at": "2020-09-20T15:36:19Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I guess it is related to .Net API.\r\nClose as stale issue.",
      "created_at": "2021-01-18T06:46:57Z",
      "updated_at": "2021-01-18T06:46:57Z"
    },
    {
      "author": "PsychoData",
      "author_association": "NONE",
      "body": "This seems to be the case that it jumps straight to Kill instead of requesting close\r\n\r\nI believe it traces back to here https://github.com/PowerShell/PowerShell/blob/3c7f4b573e96684781b8e1935eeb0b981bcd93bc/src/Microsoft.PowerShell.Commands.Management/commands/management/Process.cs#L1250-L1253\r\n\r\nor possible here https://github.com/PowerShell/PowerShell/blob/3c7f4b573e96684781b8e1935eeb0b981bcd93bc/src/Microsoft.PowerShell.Commands.Management/commands/management/Process.cs#L1399-L1408\r\n\r\nIt seems like you could send [CloseMainWindow](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process.closemainwindow?view=netcore-3.1) and since it returns True or False, just fall back to `.Kill()` if `.CloseMainWindow()` if it was not applicable or cannot send and returned False instead. \r\n\r\nThis would enable \"soft\" closes of something like Notepad that has an unsaved document opened in it, as well as -Force closing the same document if desired.\r\n\r\nIt would also give programs a chance to handle being closed (unless they were Forced) to do things like write save a final recovery copy of unsaved documents, which they won't get if a Kill is sent",
      "created_at": "2021-01-25T18:03:06Z",
      "updated_at": "2021-01-25T18:03:06Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@PsychoData Thanks for your investigations! Do you want to pull PR? I'd review and merge.",
      "created_at": "2021-01-25T18:56:23Z",
      "updated_at": "2021-01-25T18:56:23Z"
    },
    {
      "author": "PsychoData",
      "author_association": "NONE",
      "body": "not sure I would be best for it - this would be my first foray into Posh Core coding and in a pretty core area\r\n\r\nNot sure if there are any other best practices I should hit for it too, or creating tests for it. \r\n\r\nIf someone else wanted to go for it, I would feel better about it",
      "created_at": "2021-01-25T19:53:35Z",
      "updated_at": "2021-01-25T19:53:35Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@PsychoData \r\nI see you are already reading the code. If you are wasting your time then you have interest. If you have any interest then welcome to contribute!\r\nSome parts of PowerShell are really confusing, but you can contribute to the parts that you are interested in and that you understand. You could read about Working Groups \r\n\r\nThe change you propose is not complex. I don't think we can create a reliable test for this - I think manual testing the scenario enough (with good comments in code).",
      "created_at": "2021-01-26T05:33:30Z",
      "updated_at": "2021-01-26T05:33:30Z"
    },
    {
      "author": "PsychoData",
      "author_association": "NONE",
      "body": "well - fine if you twist my arm :) ",
      "created_at": "2021-01-26T22:21:28Z",
      "updated_at": "2021-01-26T22:21:28Z"
    },
    {
      "author": "PsychoData",
      "author_association": "NONE",
      "body": "@iSazonov  there's what I threw in\r\nideally, I would be thinking some sort of .... timeout.... like `Stop-Process -timeout 500` and it sends a \"close\" request at first and if it hasn't closed within the timeout, then it sends a Kill, but that is beyond my current C# skills \r\n",
      "created_at": "2021-01-26T23:47:37Z",
      "updated_at": "2021-01-26T23:47:37Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@PsychoData Thanks for your contribution!\r\n\r\nOriginal behavior on the cmdlet is silently kill a process. We can not change the default behavior otherwise this will be a breaking change. I mean `Stop-Process notepad.exe` shouldn't wait while ask an user to save a file. So all we can do here is to make the cmdlet more smart and before calling Kill() we could call CloseMainWindow(). ~~If the method blocks current thread we should run it in async, wait some ms and fallback to Kill() if the process is still running.~~ This is a rough description, you could think more and experiment.\r\n\r\nUpdate: CloseMainWindow() doesn't block and we can do something like http://csharp-slackers.blogspot.com/2008/09/terminate-process.html\r\n\r\n---\r\nIn separate PR we could add new parameter like `-GracefullyShutdown [timeout ms]` so that change the default behavior and allow an user interaction and wait until timeout.\r\n",
      "created_at": "2021-01-27T10:05:19Z",
      "updated_at": "2021-01-27T12:43:20Z"
    },
    {
      "author": "PsychoData",
      "author_association": "NONE",
      "body": "The Powershell process doesn't wait while it asks the user to close, that thread moves right along and leaves Notepad.exe to finish closing itself, or cancel closing itself\r\n\r\nYou can see the prompt in Powershell is returning immediately and not waiting for the save/noSave/cancel prompts \r\nRunning the second time while the save prompt is up in a Modal window, it can't send the CloseMainWindow again, so it goes through as a Kill on that window, but still send Close to that one Window I had cancelled the previous close\r\n\r\nand finally, the Stop-Process -Force closes directly as Kill \r\nbut in any of the cases the pipelines are sending a close or kill command and then moving on\r\n![image](https://i.imgur.com/I6b1SMA.gif)\r\n",
      "created_at": "2021-01-27T15:28:50Z",
      "updated_at": "2021-01-27T15:28:50Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "On further thought, I see that the current proposed implementation is a breaking change. I thing we should avoid a breaking change and follow the original behavior on the cmdlet that is silently kill a process.\r\nHowever, I suppose we could make two improvements.\r\n1. Improve base behavior and first try gracefully close process\r\n2. Add new graceful shutdown behavior with new parameter like `-GracefullyShutdown [timeout ms]`\r\n---\r\nFor 1:\r\n1.  Call CloseMainWindow() and WaitForExit(20ms) (20ms here is an empiric value.)\r\n2. If the process is still running we call Kill()\r\n---\r\nFor 2:\r\n1. If GracefullyShutdown == 0 we call Kill()\r\n2. Otherwise, only call CloseMainWindow() and WaitForExit(<timeout>)\r\n\r\n/cc @mklement0 What do you think?",
      "created_at": "2021-01-30T18:14:45Z",
      "updated_at": "2021-01-30T18:14:45Z"
    },
    {
      "author": "PsychoData",
      "author_association": "NONE",
      "body": "I am not crazy about the `-GracefullyShutdown` name it makes me think that you have to specify that parameter for it to GracefullyShutdown\r\n\r\nWell, if we are going to keep it with force close (Kill) function on `Get-Process Notepad | Stop-Process`  then it would make sense to do something like `Get-Process Notepad | Stop-Process -CloseTimeout <Millis>`  and default to like ..... 200 milliseconds? \r\n\r\nand then it could iterate through the Notepad Processes, start the thread timer for the **Kill** and then send the **Close** signal. \r\nOn Expiration of the \"Kill\" timer, it can check if it has stopped and kill if needed \r\n\r\nI suppose we could do some testing - but I'm not sure 20 milliseconds would be enough time to the random processes to handle the Close event, close anything down (remember, some of that might be trying to send network session close requests, etc). But that's just deciding on a good default without tying up the timeline for too long. \r\n\r\nFor example, sometimes Outlook can close in a fraction of a second, sometimes it takes 1/2 a second, sometimes a few seconds, or sometimes it hangs for what seems like unlimited amount of time (I've seen hours) \r\n\r\na param like `-CloseTimeout`  might be a good medium to preserve the existing behavior of forcing the process to close, but giving it an (adjustable) timeout to shut itself down before killing. If they specifically need it to **Kill directly** instead of Close **then Kill**,  then I think **-Force** should still skip the **Close** and should go to **Kill** directly still, as it currently does. \r\n\r\n\r\n\r\n",
      "created_at": "2021-01-31T01:11:37Z",
      "updated_at": "2021-01-31T01:11:37Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Well, if we are going to keep it with force close (Kill) function on `Get-Process Notepad | Stop-Process` then it would make sense to do something like `Get-Process Notepad | Stop-Process -CloseTimeout <Millis>` and default to like ..... 200 milliseconds?\r\n\r\nYes, I believe it is mandatory requirement to avoid a breaking change. I like the idea about a default value for the new parameter. As for the parameter name, perhaps we could use `GracefullyStopTimeout` name.\r\n\r\n> I think -Force should still skip the Close and should go to Kill directly still, as it currently does.\r\n\r\nIt would be again a breaking change for Force parameter (today it allows only to close a process of _other_ users). I believe we could use zero timeout (in GracefullyStopTimeout parameter) for the scenario - it is easy understandable for users than complicating Force parameter.",
      "created_at": "2021-01-31T06:59:44Z",
      "updated_at": "2021-01-31T06:59:44Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov, I agree regarding the concerns about the breaking changes, but let us take a step back:\r\n\r\nConceptually, we are dealing with two modes of termination:\r\n\r\n* _Cooperative_, via signal `SIGTERM`: the process is asked to shut _itself_ down, allowing it to clean up, but it may or may not honor the termination request.\r\n\r\n* _Forced_, via signal `SIGKILL`: the process is forcefully terminated, without any awareness of that act.\r\n\r\nAs for default behavior:\r\n\r\n* `taskkill` on Windows and `kill` on Unix default to `SIGTERM` - which, given the word \"kill\" in their name, is unfortunate, but that ship has sailed a long time ago.\r\n\r\n* `Stop-Process` defaults to `SIGKILL`\r\n\r\nThis discrepancy is unfortunate, but I think we're stuck with it.\r\n\r\nIn terms of terminology, it is similarly unfortunate that \"stopping\" a process (`SIGSTOP`) in the Unix world means _suspending_ (pausing) it, with the option to resume (continue) it later (`SIGCONT`).\r\n\r\n\r\nAs for synchronous vs. asynchronous behavior:\r\n\r\n_Both_ modes of termination are inherently _asynchronous_ - they send a signal and return instantly:\r\n\r\n*  _In practice_, the `SIGKILL` method _typically_ acts quasi-_synchronously_, because the _kernel_ handles the termination.\r\n  \r\n    * However, according to the comments at https://stackoverflow.com/q/8762228/45375 re Unix platforms, \"the process won't terminate immediately. If a process is doing a system call, it will only end when the system call returns. So if it does some real heavy processing, it may take time.\"\"\r\n  \r\n    * Also, on Unix-like platforms termination may even _fail_ altogether if the target process is in an uninterruptible state. \r\n\r\n* By contrast, `SIGTERM` is much more likely to be _asynchronous_ in practice, since the process _itself_ processes the signal, processing doesn't happen until the process is given CPU time next, and the process may block termination indefinitely with a modal confirmation prompt, or generally refuse to terminate altogether.\r\n\r\n----\r\n\r\nGiven the above, I think the conceptually cleanest approach would be:\r\n\r\n* Leave the existing behavior as is (`SIGKILL` by default, potentially - though typically not - asynchronous behavior; keep existing `-Force` semantics)\r\n\r\n* Introduce two new switches:\r\n\r\n  * `-Request` or `-ByRequest` (as a shorter alternative to `-GracefullyShutdown`; name negotiable), which sends `SIGTERM` instead of the default `SIGKILL`.\r\n  \r\n    * As an aside: It's worth considering support for sending _arbitrary_ signals to processes. On Unix, this is somewhat counterintuitively done via the `kill` utility as well, so you could argue we should extend `Stop-Process` analogously, but  I don't know to what extent that makes sense on Windows, and it is a separate debate.\r\n\r\n  * `-Wait`, which waits _indefinitely_ for the process(es) to terminate, irrespective of whether termination is performed via `SIGKILL` or `SIGTERM`.\r\n\r\nIn case a _timeout_ is needed, use `-PassThru` and pipe to [`Wait-Process -Timeout`](https://docs.microsoft.com/powershell/module/microsoft.powershell.management/wait-process).\r\nThis follows the pattern of `Start-Process`, which has a `-Wait` switch, but lacks a way to specify  a timeout.\r\n\r\nAnother aside: It is unfortunate that the current `-TimeOut` parameters across the cmdlets that support them are `[int]`-typed, allowing for whole-second wait times only. We should consider changing the type to `[double]` instead to support fractional seconds (instead of a  separate `-Milliseconds` parameter, as was implemented for `Start-Sleep`), which I would expect to be a [Bucket 3: Unlikely Grey Area](https://github.com/PowerShell/PowerShell/blob/master/docs/dev-process/breaking-change-contract.md#bucket-3-unlikely-grey-area) change.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n<blockquote><img src=\"https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded\" width=\"48\" align=\"right\"><div>Stack Overflow</div><div><strong><a href=\"https://stackoverflow.com/questions/8762228/is-kill-function-synchronous\">Is kill function synchronous?</a></strong></div><div>Is the kill function in Linux synchronous? Say, I programatically call the kill function to terminate a process, will it return only when the intended process is terminated, or it just sends the si...</div></blockquote>",
      "created_at": "2021-01-31T16:23:01Z",
      "updated_at": "2021-01-31T17:01:45Z"
    },
    {
      "author": "PsychoData",
      "author_association": "NONE",
      "body": "right, re: the nomenclature, I was usually referring back to the [.NET .Kill()](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process.kill?view=net-5.0) method which will force-stop immediately and is somewhat analogous to `SIGKILL`. I am not very familiar with Unix or it's Kill method, so I didn't realize the `kill` binary would also send more types of terminations too. \r\n\r\nTo keep things clear I'm going to call it `SIGKILL` and `SIGTERM` from here on out, though I could not find a 100% certain source that [.NET .Kill()](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process.kill?view=net-5.0) equates to `SIGKILL`, or more particularly that [.NET .CloseMainWindow()](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process.closemainwindow?view=net-5.0) would equate to `SIGTERM` \r\n\r\n\r\nOn a separate point, it would probably be useful to get some extra information about what kind of terminations it was able to send (`SIGKILL`/`SIGTERM`). \r\nExample psuedocode in Begin, Process,End mentality for Stop-Process : \r\n```\r\nGet-Process  Notepad \r\n<3 Processes found>\r\nGet-Process  Notepad | Stop-Process -CloseRequest 400\r\nBegin: <nothing relevant here?> \r\nProcess: Sent Close request to Process1\r\nProcess: Start Timer for CloseRequestProcess1\r\nProcess: Sent Close request to Process2\r\nProcess: Start Timer for CloseRequestProcess2\r\nProcess: Sent Close request to Process3\r\nProcess: Start Timer for CloseRequestProcess3\r\nEnd: Wait for timers to expire OR all processes to be closed, and Kill any Processes that haven't stopped yet\r\nEnd: Process2 closed itself succesfully\r\nEnd: `CloseRequestProcess1` and `CloseRequestProcess3` timer expired\r\nEnd: Send `SIGKILL` to Process3\r\nEnd: Send `SIGKILL` to Process3\r\nEnd: Wait for any Timeout to expire\r\n```\r\n\r\nI don't know if there is a way to do the \"wait and fall back to SIGKILL\" `End` section without it having to block the pipeline up for the `SIGTERM` timeout to expire (unless it is `-PassThru`, obviously) but ideally, I would like to let it just keep going asynchronously and not stop up the pipeline. \r\nIf we can have it fall back to `SIGKILL` after a timer/timeout expires without blocking the pipeline, then we could also potentially make the CloseTimeout much larger, say 500 milliseconds, to allow for things like Outlook to close. Otherwise I think any timeout ought to stay much lower to keep blocking the pipeline to a minimum",
      "created_at": "2021-02-01T02:28:47Z",
      "updated_at": "2021-02-01T02:28:47Z"
    },
    {
      "author": "PsychoData",
      "author_association": "NONE",
      "body": "On the sidenotes, I think enabling the other types of signals to send besides SIGKILL and SIGTERM sound like a great idea, but most likely seem like it ought to be a whole separate cmdlet?\r\n\r\nConverting the `-TimeOut` to double would be nice, or maybe separate `-TimeoutMilliseconds` \r\n\r\nBut those should probably be separate issues to talk about those suggestions",
      "created_at": "2021-02-01T02:36:37Z",
      "updated_at": "2021-02-01T02:36:37Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 @PsychoData Thanks for sharing your thoughts!\r\n\r\n>  I think enabling the other types of signals to send besides SIGKILL and SIGTERM sound like a great idea, but most likely seem like it ought to be a whole separate cmdlet?\r\n\r\n.Net does not support signals at all - it is fundamental limitation. We shouldn't go in the direction (until something will be changed in .Net.)\r\n\r\n> Converting the -TimeOut to double would be nice, or maybe separate -TimeoutMilliseconds\r\n\r\nIt would confusing users. We use Timeout parameter of int type in some cmdlets. See `Get-Command -ParameterName Timeout | gcm -Syntax`. _I don't think we should discuss this here._\r\n\r\n> -Wait, which waits indefinitely for the process(es) to terminate, irrespective of whether termination is performed via SIGKILL or SIGTERM.\r\n\r\nThis functionality is in Wait-Process. We have no need to move it to Stop-Process.\r\n\r\n----\r\n\r\nMain question in the issue is should we try to make the cmdlet more smart on Windows so that call CloseMainWindow() before fallback to Kill()? If no this simplify all. Now I think this would be the best way. Can you vote for this? \r\nIn this case, we would just make two parameter sets- (1) Kill as default, (2) Terminate (or GracefullyStop) for new functionality.",
      "created_at": "2021-02-01T06:38:46Z",
      "updated_at": "2021-02-01T06:39:06Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov, I agree regarding the issues _not_ to discuss here; it is exactly why I called them _asides_: something to perhaps inspire a separate discussion, though I get that that's problematic without actually creating and/or pointing to such separate discussions, because the temptation is there to respond _here_. To close the one tangent: Point taken re signals in general, but see below.\r\n\r\n@PsychoData, re nomenclature: I should have made it clearer that I used `SIGKILL` or `SIGTERM` loosely, as shorthand to refer to the two termination modes I've described.\r\n\r\nIn terms of implementation, `SIGKILL` (forced termination) corresponds to `.Kill()` in .NET both on Windows and on Unix; `SIGTERM` (cooperative termination) corresponds to `.CloseMainWindow()` in .NET on _Windows_, but on Unix _we'd have to send the actual `SIGTERM` signal_ to get equivalent functionality - and it sounds like we'll have to go native for that, correct?\r\n\r\n---\r\n\r\n> This functionality is in `Wait-Process`. We have no need to move it to `Stop-Process`.\r\n\r\nYes, we have `Wait-Process`, but just like `Start-Process -Wait` and `Receive-Job -Wait` exist - despite the existence of the dedicated `Wait-Process` and `Wait-Job` cmdlets - implementing `-Wait` on `Stop-Process` would be a _convenience_ switch to make the _typical_ use case easier to implement; more fine-grained waiting - notably via `-TimeOut` - would then require explicit use of `Wait-Process`.\r\n\r\nIn other words: For _convenience_,  `Stop-Process -ByRequest $somePid -Wait` would be the equivalent of \r\n`Stop-Process -ByRequest $somePid -PassThru | Wait-Process` - just like it works for `Start-Process`.\r\n\r\n---\r\n\r\n> Main question in the issue is should we try to make the cmdlet more smart on Windows so that call CloseMainWindow() before fallback to Kill()? If no this simplify all. Now I think this would be the best way.\r\n\r\nI see two basic approaches:\r\n\r\n**Option A:** Focus on separation of concerns, as suggested by @iSazonov and also in my previous comment:\r\n\r\nThis means _not_ implementing any fallback logic and _not_ implementing any timeout in `Stop-Process`.\r\n\r\nYou'd get asynchronous behavior by default, as currently, but can _opt-in_ to wait _indefinitely_ with `-Wait`. Otherwise, use `-PassThru` and pipe to `Wait-Process`\r\n\r\nIn terms of syntax, this means (for brevity I'm only showing the `-Id`-based input; name of `-ByRequest` negotiable):\r\n\r\n```\r\nStop-Process [-Id] <int[]> [-PassThru] [-Force] [-ByRequest] [-Wait]\r\n```\r\n\r\nThat is, to implement a timeout with cooperative termination you'd have to use something like:\r\n\r\n```\r\nStop-Process $somePid -ByRequest -PassThru | Wait-Process -Timeout 1\r\n```\r\n\r\n`Wait-Process` reports a non-terminating error for (each) target process that doesn't terminate in the timeout period.\r\n\r\nThis means that in order to fall back to _forced_ termination you'd have to handle that error and call `Stop-Process` again, this time without `-ByRequest`.\r\n\r\nThe question is how _common_ this scenario is. If it is common, we should make things easier, in which case my suggestion is to add a `-StopOnTimeout` switch to _`Wait-Process`_, which would call `.Kill()` after the timeout has elapsed, followed by `.WaitForExit()` - or go with Option B (see below).\r\n\r\n---\r\n\r\n**Option B:** Focus on high-level logic, along the lines of @PsychoData's proposal:\r\n\r\n```\r\n# FORCED termination\r\nStop-Process [-Id] <int[]> [-PassThru] [-Force] [-Wait]\r\n\r\n# COOPERATIVE termination\r\nStop-Process [-Id] <int[]> [-PassThru] [-Force] -ByRequest [-Wait] [-Timeout <double>]\r\n```\r\n\r\nThat is, asynchronous behavior would remain the default (also with `-ByRequest`), unless you specify `-Wait`.\r\n\r\nOnly with `-ByRequest` (cooperative termination) do you get to specify a timeout, after which `.Kill()` and `.WaitForExit()` are called.\r\n\r\n(The assumption is that `.Kill()` either succeeds - in which the process does get terminated and _indefinite_ waiting is guaranteed to end (shortly) - or fails altogether, so that there's no point in supporting a timeout).\r\n\r\n---\r\n\r\nI can see arguments for both options; if needing to fall back to forced termination is a common scenario, I can see the appeal of option B.\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2021-02-01T18:15:45Z",
      "updated_at": "2021-02-01T18:15:45Z"
    },
    {
      "author": "PsychoData",
      "author_association": "NONE",
      "body": "Well, `.Kill()` returns void, so it either presumably succeeds in sending the signal and ends/returns, or throws an error that it couldn't send the .`Kill()` signal. \r\n\r\nOriginally my thinking was a third, I will call Option C\r\n\r\n**Option C:** Have Stop-Process send `SIGTERM`/`.CloseMainWindow()` by default, and only send `.Kill()` if it failed to signal \"Close\" or if `-Force` was specified then default to `.Kill()` \r\n\r\nAfter all the discussion I see why we wouldn't want to change that functionality of expecting Stop-Process to always result in a process that is `.Kill()`/Forced to close if necessary, since someone may be expecting that for their existing code that was in place - Pester Tests for example. \r\n\r\nmy thinking with Option B is that we preserve the high-level function of `Stop-Process` that it will forcibly kill something if necessary, without having to specify -Force for it to `.Kill()` a process if necessary, while only adding a small (minimum) and adjustable timeout. \r\n\r\nOption B is a nice medium between the current \"Always default to kill everything\" and my [originally provided code](https://github.com/PowerShell/PowerShell/issues/13664#issuecomment-767904909) of \"Try to send Close, but Kill if .NET says that failed to send\"\r\n\r\n\r\n",
      "created_at": "2021-02-01T19:44:02Z",
      "updated_at": "2021-02-01T19:44:02Z"
    },
    {
      "author": "PsychoData",
      "author_association": "NONE",
      "body": "I think the only point we are getting hung on talking about is that I am thinking \r\n`Stop-Process 'Notepad','Outlook'` (with a default -ByRequest implied)\r\nWould result in \r\n * Send `Outlook` and `Notepad` a **Close** signal (repeat for any additional processes specified)\r\n     * Start ByRequest timer here\r\n     * This is starting all of the ByRequest timers as close as possible in time\r\n     * Still attempt to send `.Close()` but if that fails jump straight to `.Kill()` \r\n * Wait until `ByRequest` timeout expires in the End section of the processing\r\n     * Loop until their ByRequest Timers have expired, or the processes are all stopped\r\n     * Could Optionally add a \"NoWait\" or just turn ByRequest timeout to 0 or 1 milliseconds \r\n     * If timeouts expire, and there are still valid Processes, send the `.Kill()` and let the method return/continue onward\r\n\r\nIn many... probably most... cases this timeout would not even be needed because the program will handle being sent a `.Close()` signal and just close itself before you're checking on the timeout anyway. If this used a Low default  for ByRequest (20 millis? 50? 100? No idea of a best value for that yet) then we should be looking at. \r\n\r\nKeep in mind, that if we are running on 5 processes with a 500 millis ByRequest timeout, this won't be 500+500+500+500 it would be around 500 + time to send all the `.Close()` signals. For me, using three processes, that took about 100 millis to send the `.Close()` commands and finish the cmdlet\r\n![image](https://user-images.githubusercontent.com/3719116/106511648-82fa8a80-649e-11eb-99eb-118f7ad3868a.png)\r\n\r\nSo if it had a 500 milli ByRequest timer, you are done sending the `Close()` signals long before the ByRequest time expires... and I would figure it took maybe .... 600 millis total execution time with the `send close()`, `Wait for ByRequest to expire`, and `Some Processes did not gracefully close, Kill them`  depending on how busy the machine was and could revisit the timer thread",
      "created_at": "2021-02-01T20:08:07Z",
      "updated_at": "2021-02-01T20:08:07Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Yes, we have `Wait-Process`, but just like `Start-Process -Wait` and `Receive-Job -Wait` exist - despite the existence of the dedicated `Wait-Process` and `Wait-Job` cmdlets - implementing `-Wait` on `Stop-Process` would be a _convenience_ switch to make the _typical_ use case easier to implement; more fine-grained waiting - notably via `-TimeOut` - would then require explicit use of `Wait-Process`.\r\n\r\nIn the case this could be separate enhancement since it is not mandatory for enhancement we consider here.\r\n\r\n> I should have made it clearer that I used SIGKILL or SIGTERM loosely, as shorthand to refer to the two termination modes I've described.\r\n\r\nI feel most of users follow intuitively the terms. I believe we need to follow this in parameter names too. If we ask users what is:\r\n```powershell\r\nStop-Process -Kill\r\nStop-Process -Terminate\r\n```\r\nmost of them give us right description. But `Stop-Process -ByRequest` will force them to read docs before get understanding its semantic. \r\n\r\nIf we start with adding new Terminate switch (and perhaps Kill for symmetric) this will address current issue in simplest way and open ways for future enhancements.\r\n",
      "created_at": "2021-02-02T08:56:14Z",
      "updated_at": "2021-02-02T08:56:14Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov:\r\n\r\nOn a meta note, I think at this point it is clear that before implementing anything we need to write up a _new_, focused proposal, following this discussion.\r\nTherefore I think it's worth having this discussion, even as it gets lengthy.\r\n\r\n---\r\n\r\nRe `-Wait` switch:\r\n> In the case this could be separate enhancement since it is not mandatory for enhancement we consider here.\r\n\r\nBased on my new proposal below we won't need the `-Wait` switch, after all, but _in general_ I find that argument problematic: While with Option A `-Wait` would _technically_ not be necessary (it would be with Option B),  it would greatly increase the utility of the enhancement. If `-Wait` were still in the picture, I wouldn't see a reason to do this separately, not least because I suspect it would then never be implemented.\r\n\r\n---\r\n\r\n> `Stop-Process -Kill`\r\n> `Stop-Process -Terminate`\r\n\r\nWhile I like the idea of these contrasting switches to make the two modes explicit, there is the awkwardness of then having a switch being _true by default_, namely`-Kill`.\r\n\r\nAlso:\r\n\r\n* Familiarity with the term _terminate_ likely only applies to _Unix_ users; in the context of the GUI window-centric Windows, _close_ is used, as reflected in the `.CloseMainWindow()` method name; also, _terminate_ by itself, from a natural-language perspective, doesn't adequately convey the aspect of cooperative / graceful stopping.\r\n\r\n* (_Kill_, while unambiguous in terms of common usage, is tainted by the conceptual confusion of both `taskkill.exe` and `kill` exhibiting _terminate_ / _close_ rather than kill behavior by default, but there's obviously nothing we can do about this.)\r\n\r\n* _Stop_ invariably means something different in PowerShell, which in signal terms in Unix (`SIGSTOP`) - regrettably - means _suspending_ a process.\r\n\r\n  * As an approved verb, `Stop` has no precise definition with respect to _cooperative_ vs. _forced_, but in practice `Stop-Process` is the only outlier in that it performs _forced_ stopping (`Stop-Job`, `Stop-Computer`, `Stop-Transcript` do not).\r\n  \r\n  * However, given that the [approved-verbs documentation](https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/approved-verbs-for-windows-powershell-commands) lists under \"synonyms to avoid\" for `Stop` \"End, Kill, Terminate, Cancel\", the implication is that `Stop` is meant to cover _both_ cooperative and forced stopping.\r\n\r\n  * Of course, it would then make sense to _consistently_ make cooperative stopping the default, with an _opt-int_ for forced stopping. Regrettably, `Stop-Process` not only doesn't offer cooperative stopping, but _invariably_ performs forced stopping.\r\n\r\nIn short: We won't be able to use existing terminology from one platform without it clashing with that of another.\r\n\r\nMy suggestion was motivated by using names based on platform-neutral _abstractions_ that express the _conceptual intent_; perhaps `-ByRequest` isn't great, and something like `-Graceful` (a shorter version of the previously suggested `-GracefullyShutdown`) is more descriptive.\r\n\r\n_If_ we had established semantics of `Stop` _without further qualification_ implying _cooperative_ (graceful) stopping, then we'd only ever need a switch to opt-into _forced_ stopping - and the obvious name for such a switch would be `-Force`.\r\n\r\n---\r\n\r\n@PsychoData:\r\n\r\n> (with a default `-ByRequest` implied)\r\n\r\nWe cannot default to cooperative stopping without breaking backward compatibility - users may have come to rely on _unconditional_, forced, quasi-synchronous termination.\r\n\r\nGiven the conceptual musings above, I sincerely wish we _could_ break backward compatibility, which makes this a candidate for #6745.\r\n\r\nAs for timeouts: For simplicity and predictability, I'd use the timeout as a single, overall waiting period, irrespective of how many processes are targeted: I would start a _single_ timing _in the `End` block_ (not sure what `Wait-Process` does).\r\n\r\n---\r\n\r\nLet me propose **Option C**:\r\n\r\n* Make `Stop-Process` _synchronous_ by default, with an _opt-in_ kill timeout that _only applies if `-Graceful` (`-ByRequest`) is also specified. This is similar to Option B, except that `-Wait` is no longer required.\r\n\r\n* Conversely, a new `-NoWait` switch must be used to request _asynchronous_ behavior.\r\n\r\nNote: For consistency, I suggest also making the by-default _kill_ operation synchronous (call `.WaitForExit()` after `.Kill()`): this would technically also be a breaking change, albeit an _acceptable_ one ([bucket 3: Unlikely Grey Area](https://github.com/PowerShell/PowerShell/blob/master/docs/dev-process/breaking-change-contract.md#bucket-3-unlikely-grey-area)): I think it would have virtually no impact on existing code (given that `.Kill()` forcefully terminates, I would expect the extra time spent waiting for actual termination to be negligible) while making the behavior slightly more predictable (even though it's unlikely that the current asynchronous behavior surfaces as such).\r\n\r\n```\r\n# FORCED termination, (now) synchronous by default, except if -NoWait is passed.\r\nStop-Process [-Id] <int[]> [-PassThru] [-Force] [-NoWait]\r\n\r\n# COOPERATIVE (graceful) termination: synchronous (indefinite wait) by default, except if -NoWait is passed.\r\nStop-Process [-Id] <int[]> [-PassThru] [-Force] -Graceful [-NoWait]\r\n\r\n# COOPERATIVE (graceful) termination: synchronous, but with optional timeout resulting in\r\n# *synchronous killing*  if the processes don't terminate in time.\r\nStop-Process [-Id] <int[]> [-PassThru] [-Force] -Graceful [-Timeout <double>]\r\n```\r\n\r\n@PsychoData, note that this proposal intentionally does _not_ include a built-in, automatic kill timeout with `-Graceful` termination: Users should be free to decide whether they want to:\r\n\r\n* wait indefinitely (by default), which is the safest behavior.\r\n* not wait at all (`-NoWait`)\r\n* wait for a while and, in case of non-termination within that period,  _kill_ (synchronously) (`-TimeOut <n>`) \r\n* wait for a while and, in case of non-termination, only report _an error_, via `Wait-Process`: \r\n`Stop-Process $somePid -Graceful -NoWait -PassThru | Wait-Process -Timeout $n`\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2021-02-02T20:42:39Z",
      "updated_at": "2021-02-02T20:46:52Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 for information - Terminate() method exists in WMI Win32_Process class, I guess it _kills_ a process. :-)",
      "created_at": "2021-02-03T12:51:06Z",
      "updated_at": "2021-02-03T12:51:06Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Based on @mklement0 comments I suggest follow final proposal:\r\n\r\nEnhance the cmdlet with -Graceful / -Gracefully switch which will call CloseMainWindow() method (and fallback to Kill() if the method returns fasle). This will gracefully terminate the process on Windows. No changes of a functionality on Unix.\r\n\r\nAll other enhancements we have discussed here we will consider later.\r\n\r\n/cc @SteveL-MSFT @daxian-dbw for PowerShell-Committee review.",
      "created_at": "2021-02-03T13:18:50Z",
      "updated_at": "2021-02-03T13:19:41Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @iSazonov, but let me spell out the implications of your proposal, from which I conclude that it is _not_ worth implementing as such:\r\n\r\n* The behavior will be inconsistent and potentially ineffective, because basing the behavior on whether `CloseMainWindow()` returns `$false` is insufficient - see below.\r\n\r\n* The solution will only work on Windows - even though sending `SIGTERM` would amount to equivalent functionality on Unix.\r\n\r\n---\r\n\r\nNote: I am partly out of my depth here, but I hope I'm at least fundamentally correct:\r\n\r\n* `CloseMainWindow()` returns `$false` only in two cases:\r\n\r\n   * The application _does_ have a (main) message loop (it is a GUI-subsystem application) but is _currently_  in a state where it cannot process messages - a typical example is a modal dialog currently being shown.\r\n   \r\n   * The application does _not_ have a message loop (a console-subsystem application), except if it has one _indirectly_, by running _directly_ in a _console window_, which itself _does_ have a message loop. This means:\r\n\r\n     * A console application running _directly_ in a console window - typically a _shell_ - will typically respond with `$true` _via its console window's message loop_, and it is the console window that then terminates the application.\r\n\r\n     *  By contrast, a console application launched _from a shell_ has _no_ associated window and always returns `$false`.\r\n\r\n       * In either case, a console application can optionally register for console events such as `CTRL_CLOSE_EVENT`, via the [`SetConsoleCtrlHandler`](https://docs.microsoft.com/en-us/windows/console/setconsolectrlhandler) WinAPI function, which allows them to stop gracefully, analogous to a process opting to handle `SIGTERM` on Unix. \r\n \r\n---\r\n\r\nThis implies for your proposal that if `-Graceful` is specified:\r\n\r\n* All console applications (except shells) will effectively always be _killed_ instead (as they always return `$false`).\r\n\r\n   * To fix that, the target process' controlling console window would have to be identified and the `.CloseMainWindow()` method must be called on _it_ - only that would give such console applications a chance to terminate gracefully, via their `CTRL_CLOSE_EVENT ` handlers, if any;  _edit_: however, that wouldn't be appropriate, because that means that _other_ processes would be terminated too, at the very least also the parent _shell_ process.\r\n\r\n* GUI applications may end up _not terminated at all_, because returning `$true` only indicates that the message was _processed_, not that termination will actually be performed.\r\n\r\n   * In fact, a GUI application whose message loop is responsive may put up a modal dialog _in response_ to `.CloseMainWindow()` (as in the Notepad example above) and indefinitely wait for user input. From PowerShell's perspective, such a `Stop-Process -Graceful` call would then amount to _quiet failure_: the process isn't terminated, and no error is reported.\r\n\r\n---\r\n\r\nEven if we address all the problems above - i.e. if we truly give all all targeted processes a chance to terminate gracefully - _enforcing_ (ultimate) termination should (a) be opt-in and (b) can, as stated, only be achieved by _waiting for actual termination based on a timeout_, given that `SIGTERM` / `CTRL_CLOSE_EVENT` handlers can _refuse_ to terminate in response to a request.\r\n\r\n\r\n",
      "created_at": "2021-02-03T20:08:32Z",
      "updated_at": "2021-02-04T19:36:03Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee reviewed this and agrees to not make a breaking change where automation will expect processes to be killed.  .NET currently does not provide a way to send `SIGTERM` on Unix systems and no corresponding capability on Windows (where `CloseMainWindow()` is similar, but not the same as noted for console processes).  This may be better served by a community module/cmdlet that is OS specific.",
      "created_at": "2021-02-03T23:24:41Z",
      "updated_at": "2021-02-03T23:24:41Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Even if we address all the problems above - i.e. if we truly give all all targeted processes a chance to terminate gracefully - _enforcing_ (ultimate) termination should (a) be opt-in and (b) can, as stated, only be achieved by _waiting for actual termination based on a timeout_, given that `SIGTERM` / `CTRL_CLOSE_EVENT` handlers can _refuse_ to terminate in response to a request.\r\n\r\nI believe we should do the cmdlet too smart and complex. \r\nIt is currently impossible to send an event or signal to a process so that it terminates gracefully.\r\n\r\n_The suggestion is to just add such a feature - just send the signal and nothing else._\r\n\r\nAll other smart things the user can do himself (or we can add later after receiving feedback).\r\n\r\n---\r\nWe can implement this on Unix too https://stackoverflow.com/questions/41041730/net-core-app-how-to-send-sigterm-to-child-processes\n\n<blockquote><img src=\"https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded\" width=\"48\" align=\"right\"><div>Stack Overflow</div><div><strong><a href=\"https://stackoverflow.com/questions/41041730/net-core-app-how-to-send-sigterm-to-child-processes\">.net-core app: how to send SIGTERM to child processes?</a></strong></div><div>Is it possible for .net-core app running on Linux to send SIGTERM signal to a child process?\n\nWe're thinking to port our .net app to .net-core and run it on Linux, to avoid current signal implement...</div></blockquote>",
      "created_at": "2021-02-04T07:00:04Z",
      "updated_at": "2021-02-04T07:00:06Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @iSazonov - good find, and I do think that starting small is an option, but let me flesh your suggestion out to see its full implications:\r\n\r\n* Existing `Stop-Process` behavior will remain as-is:  unconditional _kill_ behavior, _asynchronous_ (even though in practice it will _in effect_ typically be synchronous).\r\n\r\n  * Unless killing _fails_ (such as due to lack of permissions), it can safely be assumed that the target processes _will_ terminate (and may (likely) or may not already have, by the time the next PowerShell statement executes).\r\n\r\n* Introduce only _one_ new switch, `-Graceful`, which does the following:\r\n\r\n  * On Unix, it sends signal `SIGTERM`, and on Windows it calls `CloseMainWindow()`.\r\n  * If sending the signal fails (typically due to a permissions problem) or `CloseMainWindow()` returns `$false` (see below), report a _non-terminating_ error (per process).\r\n\r\nEither way (after either failing or succeeding to send `SIGTERM` /  call `CloseMainWindow()`), `Stop-Process`'s job is done, which means:\r\n\r\n* Termination may not occur at all (only in the _failure_ case do you have _instant certainty_), because the target processes may ignore the signal / close request.\r\n\r\n* If termination does occur, it may not occur until some time later (more noticeably so than with the default _kill_ behavior).\r\n\r\nTo detect whether termination occurred, a separate `Wait-Process` call is needed, sensibly with a `-Timeout` argument.\r\nIf the processes don't terminate within the timeout period _and termination must be enforced_, another `Stop-Process` call is needed, this time _without_ `-Graceful`, to effect killing.\r\n\r\n---\r\n\r\n**When use of `-Graceful`  is then meaningfully supported**:\r\n\r\n* On **Unix**-like platforms:\r\n  *  **_Any_ process** can be targeted; if a given process doesn't have a `SIGTERM` handler, the system will kill it.\r\n\r\n* On **Windows**:\r\n  * **GUI applications** can be targeted.\r\n  * (Console-based) **shells** can be targeted; more accurately, any console application that _directly_ has a console (window) attached to it.\r\n\r\nThis means that **console applications launched _from a shell_ can NOT be targeted** (such as `node.exe` started from a shell with a script that runs a local webserver, for instance):\r\n\r\n* `CloseMainWindow()` invariably returns `$false` for them, so `Stop-Process` will report a non-terminating error.\r\n  * Unless we want to go to the trouble of detecting the application type (GUI vs. console), the error message should mention both potential failure reasons: the target is either (a) a GUI app that is in a state where it cannot process messages or (b) an app that has no associated window and therefore no message loop, such as a console app (with no console directly attached).\r\n\r\n*  It seems that Windows currently fundamentally doesn't support sending a terminating request (`CTRL_C_EVENT`, `CTRL_BREAK_EVENT`, via [`GenerateConsoleCtrlEvent`](https://docs.microsoft.com/en-us/windows/console/generateconsolectrlevent)) to a _single_ process running (indirectly) inside a console - except if it was explicitly created as part of a process _group_; see https://github.com/microsoft/Terminal/issues/335 for (very in-depth) background information.\r\n\r\n   * The only way to get such processes to (potentially) terminate gracefully is if the (indirectly attached) _console window as a whole_ is closed, but that is inappropriate, if only a single process running inside that window is to be targeted.\r\n\r\n---\r\n\r\nIf everyone agrees that this - initially minimal - functionality is still beneficial and the implications are understood and well-documented, I think it's worth doing.\r\n\r\n\r\n",
      "created_at": "2021-02-05T17:48:19Z",
      "updated_at": "2021-02-05T17:48:19Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 I think it makes no sense for us to try to do something too clever since not even the platforms themselves do it. (Moreover, there are differences in async/sync behavior.)\r\nIf SIGTERM always fallback to SIGKILL then we are forced to follow this. The same should be the case on Windows - if `CloseMainWindow()` returns false then just call `Kill()`.\r\n\r\n```c#\r\nif (Graceful.Present && TryStopProcessGacefully())\r\n{\r\n    // return;\r\n}\r\nelse\r\n{\r\n    process.Kill();\r\n}\r\n...\r\n\r\nvoid TryStopProcessGacefully()\r\n{\r\n#if UNIX\r\n    SendTerminateSignal(process);\r\n    return true;\r\n#else\r\n    return CloseMainWindow();\r\n}\r\n```\r\n\r\nFor reference - Process.Kill() on Unix to implement SendTerminateSignal() https://source.dot.net/#System.Diagnostics.Process/System/Diagnostics/Process.Unix.cs,57\n\n<blockquote><div><strong><a href=\"https://source.dot.net/#System.Diagnostics.Process/System/Diagnostics/Process.Unix.cs,57\">Source Browser</a></strong></div></blockquote>",
      "created_at": "2021-02-06T14:01:33Z",
      "updated_at": "2021-02-06T14:01:35Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> it makes no sense for us to try to do something too clever\r\n\r\nI was proposing the very opposite: \r\nI was proposing to simply use the underlying platform feature, without trying to superimpose any additional logic (which I thought you were advocating for):\r\n\r\n> `SIGTERM` always fallback to `SIGKILL`\r\n\r\n* `SIGTERM` doesn't _fall back_ to termination by the system:\r\n   * Termination by the system is the _default behavior_ that any process may _choose to modify_ by implementing a signal handler.\r\n\r\n* Similarly, `.CloseMainWindow()` doesn't _fall back_ to closing the window:\r\n  * The system closing the window is the _default behavior_ that any process (that actually has a main window) may _choose to modify_ by responding to the close message.\r\n  * Calling `.CloseMainWindow()` on a process for which _there is fundamentally no window to close_ - i.e., one without a message loop (such as a console app launched from a shell) - predictably and sensibly fails (`$false`).\r\n\r\nIn the _success_ case - being able to _send_ the signal / close message - the uncertainty over whether that signal / message will _eventually, possibly asynchronously_ be  _honored_ is built into both mechanisms.\r\n\r\n_Not_ trying to resolve this uncertainty through superimposed logic is the gist of the [previous proposal](https://github.com/PowerShell/PowerShell/issues/13664#issuecomment-774185156).\r\n\r\nUsers who care about the eventual outcome must use follow-up commands, as described, at least for now.\r\n\r\nThe only challenge I see is to make users understand the limitations of what processes can be targeted on Windows.\r\n\r\n\r\n\r\n",
      "created_at": "2021-02-06T14:37:16Z",
      "updated_at": "2021-02-06T14:45:32Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov: Sorry, I misread your previous comment: there _is_ a fundamental disagreement here: I think we should _not_ fall back to killing, for the reasons stated.\r\n\r\n_Later_, we can implement superimposed high-level logic, _through additional parameters_.",
      "created_at": "2021-02-06T14:41:23Z",
      "updated_at": "2021-02-06T14:49:03Z"
    },
    {
      "author": "PsychoData",
      "author_association": "NONE",
      "body": "The only reason that we started talking about sending SIGterm, but then maybe waiting for a time out of some sort and then sending sigkill was that way we could preserve the high-level functionality that the processes **will be stopped** once the cmdlet is done running. Or if there was some error, throw an exception/error.\n\nThere should probably be some option to just send the close event without sending the kill, but foremost we should preserve the existing functionality so we don't break current deployments. \n\nI really don't think that using a separate wait-process or synchronously waiting with .WaitForExit would be a good idea at all, because that process doesn't have a way to short circuit out if it is taking 20 minutes to close. \n\n\nI looked at the code in the dotnet core clr , and there is definitely going to be no benefit to this on Unix currently, but windows still could benefit. \nOn the windows side the process for sending the actual commands to the processes currently only lists like three commands - close, kill, stop, resume - And it looks like that might could be extended, but that would be a separate argument for a separate repo with a separate team most likely. \n\nI'll try to hack together some code to demo the functionality, because I feel like all of these other extensions that have been discussed could certainly be useful, but the feature bloat from the original goal is significant.\n\nIf the dotnetCLR finally gets updated to have support for sending more types of events (preferably including arbitrarily sending whichever signal we want - like the Unix kill command) then that seems like it would be the time to revisit this and abstract the sending signals to some other function possibly. In the meantime, sending closeMainWindow would be sufficient for many Windows services, tray agents, and other processes the gracefully close themselves rather than having to be killed, and it is the closest option that we have",
      "created_at": "2021-02-06T15:35:08Z",
      "updated_at": "2021-02-06T15:38:02Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> that the process _will be stopped_\r\n\r\n* With _killing_ (the current behavior), you get that for free  (although not strictly synchronously), but _not by explicit high-level logic design_, but by a straight pass-through to the underlying system functionality.\r\n \r\n* With (potentially cooperative) termination,  the underlying system functionality offers _no_ stopping guarantee.\r\n\r\n> There should probably be some option to just send the close event without sending the kill\r\n\r\nThat's the current proposal: `-Graceful` by itself would just be a platform-abstracted way to send `SIGTERM` on Unix, and to call `.CloseMainWindow()` on Windows.\r\n\r\nI definitely would like to see the high-level functionality of _ensuring_ that the process is stopped, but the above would be a fairly simple and straightforward start _whose behavior doesn't deviate from the underlying system mechanisms_.\r\n\r\nIf `SIGTERM` / `.CloseMainRequest()` _defer_ to the target process with respect to whether it actually terminates, so should we _by default_.\r\n\r\n---\r\n\r\nAs for  a (possibly later) enhancement that _builds_ on the above:\r\n\r\nFirst, I agree that general signal support should be a separate discussion.\r\n\r\nI'm always a fan of _desired-state_ functionality, but I believe it should be _opt-in_ here, to modify the underlying system behavior _on demand_.\r\n\r\nIf you're _asking_ a process to terminate, it is _not_ a given that your intent is to _kill_ it, if it refuses to / doesn't terminate within a given timeout.\r\n\r\n> I really don't think that using a separate `wait-process` or synchronously waiting with `.WaitForExit` would be a good idea at all\r\n\r\nOf course, using a timeout makes sense to prevent infinite waiting.\r\n\r\nBut users should have a choice as to:\r\n\r\n* what happens on timeout: give up, or kill?\r\n\r\n* how long to wait - different timeouts may be appropriate for different processes / scenarios.\r\n\r\nIf we do go with a _default_ timeout (and I have no idea what period would make sense, but it definitely must be clearly documented), it should only apply if you've _opted into_ fallback-to-killing behavior, with a switch.\r\n\r\nThat leads me to **Options D and E**:\r\n\r\nWhat they share:\r\n\r\n* Retain existing behavior, and make the new `-Graceful` switch asynchronous too: if `-Graceful` succeeds, it just mean that the _request_ was successfully sent, and termination may or may not occur, and there's no guarantee when. (So far, this is the minimal enhancement suggested).\r\n  * `Stop-Process` alone would be PowerShell's cross-platform way of _killing_ a process (which is an unfortunate default, but we're stuck with).\r\n  * `Stop-Process -Graceful` would be PowerShell's cross-platform way of _requesting_ termination - with no guarantee that the request will be honored - and I'm now again tempted to bring the word _request_ in.\r\n\r\n**Option D**: _with_ a default timeout for the fall-back-to-killing opt-in:\r\n\r\n```\r\nStop-Process ... -Graceful [-KillOnTimeout [-Timeout <double>]]\r\n```\r\n\r\nThat is, `-KillOnTimeout` is the opt-in to the kill fallback, and by itself uses a _default_ timeout, which can overridden with `-Timeout` (which must be a nonzero, positive value).\r\n\r\n(Unlike _without_ the opt-in, `.CloseMainWindow()` returning `$false` should then _not_ result in a non-terminating error and should be treated like an instant timeout that triggers killing.)\r\n\r\n\r\n**Option E**: _without_ a default timeout:\r\n\r\nThis forces users who want to ensure ultimate termination after request-based termination fails to specify a timeout _explicitly_ - though I can see how that would be cumbersome if a reasonable default timeout can be provided.\r\n\r\n```\r\nStop-Process ... -Graceful [-KillTimeout <double>]\r\n```\r\n\r\n",
      "created_at": "2021-02-06T17:38:02Z",
      "updated_at": "2021-02-06T18:03:07Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Actually I missed that the current behavior actually _does_ make an attempt to gracefully terminate _some_ processes, namely (by definition Windows-only) _services_ (though note that the conditional is _not_ platform-specific and tests just by process _name_):\r\n\r\nhttps://github.com/PowerShell/PowerShell/blob/6ad5f65e18e921570711ddea75d4cbd2297de134/src/Microsoft.PowerShell.Commands.Management/commands/management/Process.cs#L1245-L1248\r\n\r\n(As an aside: the comment describing the `-Force` switch doesn't match its behavior:\r\nhttps://github.com/PowerShell/PowerShell/blob/6ad5f65e18e921570711ddea75d4cbd2297de134/src/Microsoft.PowerShell.Commands.Management/commands/management/Process.cs#L1157-L1164\r\n)\r\n\r\nThat said:\r\n\r\n* On _Unix_, this doesn't apply, and calling `Stop-Process` _always_ means: _send a kill request_.\r\n\r\n* On Windows, this accommodation for services _only_ makes for an awkward inconsistency (especially given that there's a dedicated, graceful-shutdown `Stop-Service` cmdlet - but, again, one we're stuck with.\r\n\r\n",
      "created_at": "2021-02-06T17:52:57Z",
      "updated_at": "2021-02-06T17:54:29Z"
    },
    {
      "author": "PsychoData",
      "author_association": "NONE",
      "body": "the goal isn't full-synchronous killing. \r\n\r\nIt's just as close as the libraries let us get to async, short of them being rewritten to send the signals directly and just move on\r\n\r\nsimilar to Unix, while maintaining the vanilla `Stop-Process Notepad` capability would be to just let it \r\n - send the CloseMainWindow() event - which just sends the message to the Window Handle through Interop services\r\n - give the process at least a few milliseconds to handle that close request and work on closing (the timeout) \r\n - send the Kill event, if our timeout expires and the process hasn't stopped\r\n - At this point `Stop-Process` is _done_ with it's functionality, and it exits, with the only final action it does currently being to kill the current Process if it was instructed to do so\r\n\r\nhttps://github.com/PowerShell/PowerShell/blob/master/src/Microsoft.PowerShell.Commands.Management/commands/management/Process.cs#L1281-L1290\r\n\r\nA few Example flows, \r\n\r\n`Stop-Process Notepad` where Notepad has NO UNSAVED text entered and will NOT INTERRUPT the CloseMainWindow() \r\n - Processing Starts\r\n - CloseMainWindow() is sent\r\n - Timer for Timeout is started\r\n - Processing ends\r\n - EndProcessing Starts\r\n - Loop until (Timer ends or Notepad finishes closing)\r\n - Notepad will likely finish Closing and the loop will exit\r\n - Stop-Process ends\r\n\r\n`Stop-Process Notepad` where Notepad HAS UNSAVED text entered and WILL INTERRUPT the CloseMainWindow() to prompt the user to save\r\n - Processing Starts\r\n - CloseMainWindow() is sent\r\n - Timer for Timeout is started\r\n - Processing ends\r\n - EndProcessing Starts\r\n - Loop until (Timer ends or Notepad finishes closing)\r\n - Notepad will NOT stop before the timeout and a .Kill() will be sent to finish the job\r\n - Stop-Process ends without checking if the process finished exiting\r\n\r\n`Stop-Process Outlook`\r\n - Processing Starts\r\n - CloseMainWindow() is sent\r\n - Timer for Timeout is started\r\n - Processing ends\r\n - EndProcessing Starts\r\n - Loop until (Timer ends or Outlook finishes closing)\r\n - Outlook may finish closing, or timer might expire\r\n - Stop-Process ends\r\n\r\n\r\nI don't think this would be the right place to go adjusting the flow of the Stop-Process way of handling the Services stopping. That's a different discussion in a different issue. \r\n\n\n<blockquote><img src=\"https://repository-images.githubusercontent.com/49609581/aad0ad80-cdec-11ea-8248-a37bc0571bfd\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/PowerShell/PowerShell\">PowerShell/PowerShell</a></strong></div><div>PowerShell for every system! Contribute to PowerShell/PowerShell development by creating an account on GitHub.</div></blockquote>",
      "created_at": "2021-02-06T18:50:33Z",
      "updated_at": "2021-02-06T18:50:35Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> short of them being rewritten to send the signals directly and just move on\r\n\r\nThe existing mechanisms are:\r\n\r\n* _asynchronous_ from a waiting-for-actual termination perspective\r\n* _synchronous_ with respect to waiting until the signal has been sent / the message has been posted, both of which are implementation details and happen before the actual point in time of termination, if any.\r\n\r\n> the goal isn't full-synchronous killing.\r\n\r\nOnce you superimpose (request-termination-then-)fallback-to-kill logic, you get _quasi_-synchronicity even if you don't call `.WaitForExit()` after `.Kill()`, given that killing is near-synchronous.\r\n\r\nAnd, of course, if the process terminates _within_ the timeout period, you have synchronous behavior by definition.\r\n\r\nTo put it differently: what you're invariably looking for is synchronicity with respect to knowing that actual termination _will occur_ (was successfully _initiated_), which, if a termination _request_ is first sent invariably involves _waiting_.\r\n\r\n> I don't think this would be the right place to go adjusting the flow of the Stop-Process way of handling the Services stopping.\r\n\r\nAgreed - that's why I said we're stuck with the behavior.\r\n\r\nAlso, just to remind us, the committee has already turned down any enhancement here, so this may never happen or at least not anytime soon.\r\n\r\nI'd say the only chance for this to be revisited is if we agree on a way forward that also addresses the committee's concerns, and present that in a _new_, focused feature-request issue.\r\n\r\nThe committee's concerns were:\r\n\r\n* The change should not be breaking.\r\n\r\n  * I'm not sure your proposal qualifies (see below).\r\n\r\n* >  .NET currently does not provide a way to send `SIGTERM` on Unix systems and no corresponding capability\r\n\r\n  * @iSazonov has demonstrated that it would be fairly easy to implement it ourselves.\r\n\r\n* > no corresponding capability on Windows [...] for console processes\r\n\r\n  * With a kill fallback this would be _somewhat_ mitigated, but _suboptimally_ in that such (no-directly-attached-console) console applications would then _always_ be _killed_.\r\n\r\n  * However, given that Windows itself offers no such capability, you could argue that this best-effort approach is still preferable (and once Windows does offer the ability, the cmdlet could be amended).\r\n\r\n---\r\n\r\nDo I understand  correctly that you want to bake the request-first-then-fallback-to-kill logic  into `Stop-Process` _by default_?\r\n\r\nEven though I can see the appeal of this from the perspective of trying to terminate gracefully while ultimately  _ensuring_ termination, it does constitute a breaking change:\r\n\r\n* existing code may rely on _forceful_ termination, i.e. explicitly _not_ giving the process a chance to clean up.\r\n\r\n* the invariably necessary waiting period (except, on Windows, if `.CloseMainWindow()` returns `$false`) slows down each call.\r\n\r\nEven if everyone were comfortable with this change, you would then need a switch such as `-NoKillFallback` to allow request-only functionality, and there should still be a user-specifiable `-Timeout`.\r\n\r\n",
      "created_at": "2021-02-06T21:20:59Z",
      "updated_at": "2021-02-06T21:24:46Z"
    },
    {
      "author": "PsychoData",
      "author_association": "NONE",
      "body": "I don't know - I just tried to kick something that seemed like a good idea along. \r\n\r\nFrom [the very beginning](https://github.com/PowerShell/PowerShell/issues/13664#issuecomment-767072983) I was saying I didn't think I was best for this because I knew it would be a breaking-ish change and there would likely need to be considerations for it to preserve the `.Kill()` effect directly by default, even though they had perfectly valid alternatives or fairly minor mitigations, like a single delay of maybe 500 millis for a  `-ByRequest TimeOut`, would probably need additional parameters added (Which I'm not sure how to add in .cs) to bypass the falling back to Kill() after timeout expired, possibly even more. \r\n\r\n------------\r\n\r\nBut it would be very useful for any program that properly handled a Close request, and give IT a MUCH easier way to gently close processes, without them. \r\n\r\nFor example, if I wanted to issue a restart - nothing would stop me from saying `Get-Process | Stop-Process -RequestCloseOnly` or maybe `Get-Process | where {From Logged in User} | Foreach-Parallel { $_ | Stop-Process -RequestCloseOnly }` to close every open process, as long as it wasn't something like Notepad with unsaved text, before sending a restart command. \r\n\r\n-----------\r\n\r\nSomeone else can try to chase this down if they want, but my effort to get this done is though, because my skill level was spent before I ever made the PR when @iSazonov was [pushing me to](https://github.com/PowerShell/PowerShell/issues/13664#issuecomment-767306906), exactly like I said it would be. ",
      "created_at": "2021-02-06T23:23:40Z",
      "updated_at": "2021-02-06T23:23:40Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> > `SIGTERM` always fallback to `SIGKILL`\r\n> \r\n> * `SIGTERM` doesn't _fall back_ to termination by the system:\r\n\r\nI mean if a process doesn't implement SIGTERM handler a stopping behavior will be like SIGKILL. \r\nThus, both on Windows (CloseMainWindow() returns a false) and on Unix (no SIGTERM handler) there may be processes that cannot \"gracefully stop\" and will just kill.\r\nAnd my code snippet above reflects this.",
      "created_at": "2021-02-07T06:44:58Z",
      "updated_at": "2021-02-07T06:44:58Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "You're right, but that means that on Unix the `else\r\n{\r\n    process.Kill();\r\n}` branch will never be reached - yet the process may _not_ terminate, if the process _does_ have a `SIGTERM` handler but decides not to terminate.\r\n\r\nOn Windows _it shouldn't be reached_, at least not _by default_, because that would mean superimposing destructive logic on the underlying system behavior.\r\n\r\nWith an _opt-in_ such as `-KillOnTimeout` it would be fine, however: `.CloseMainWindow()` returning `$false` could then rightfully be treated like an instant timeout;  however, on _successfully_ sending `SIGTERM` / calling `.CloseMainWindow()`  _you'd still have to wait_, because you otherwise cannot _ensure_ that termination will occur.\r\n\r\nIf the intent is for `-Graceful` to _default_ to `-KillOnTimeout`, we would need a switch that _opts out_ of the kill fallback - unless you think that that's not needed.\r\nEither way, this would mean a departure from the behavior of the underlying system call, whereas my thinking was that _by default_ we should simply expose the underlying system behavior as-is.\r\n\r\nTo summarize:\r\n\r\n* I think touching the default behavior - unconditional killing - is too much of a breaking change (as unfortunate as that default is).\r\n\r\n* This means that termination by request requires at least one opt-in switch, such as `-Graceful`.\r\n\r\n * This leaves the question of whether this switch _alone_ should effect try-gracefully-with-fallback-to-kill logic, or whether it should simply defer to the underlying system calls - which have _no_ fallback.\r\n\r\n    * Deferring to the underlying system calls would make `Stop-Process -Graceful` behave the same as `taskkill` on Windows (without `/f`, the kill switch) and `kill` on Unix (without `-9`, the kill switch); in other words: we'd have consistency, albeit with the defaults reversed (unavoidably, for backward compatibility).\r\n     * This means: \r\n       *  Like `taskkill` and `kill` by default, `-Graceful` (alone) would be happy to _send_ the termination request, and would consider that alone success, without _ensuring_ ultimate termination (that is up to the target process, _if_ it has a termination-request handler).\r\n       *  If sending _fails_, an error would occur, which on Windows would predictably occur for any console application without a directly attached console (any process without a window message loop); `taskkill` provides a meaningful error message in this case: `ERROR: The process \"<pname>\" with PID <pid> could not be terminated.\r\nReason: This process can only be terminated forcefully (with /F option).`\r\n\r\n",
      "created_at": "2021-02-07T07:33:29Z",
      "updated_at": "2021-02-07T07:33:29Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@PsychoData \r\n\r\n>  I just tried to kick something that seemed like a good idea along.\r\n\r\nAgreed - I do think we should provide this functionality, but the tricky part is _how_.\r\n\r\nThanks for the discussion; even if no immediate action follows, I think it was useful to get clarity.\r\n\r\n> Which I'm not sure how to add in .cs\r\n\r\nNote that it's perfectly fine to only contribute _conceptually_ to a discussion, without being the implementer or needing to know all technical details.\r\n\r\nI hope that it's clear that the sticking point here is the up-front conceptual work - agreeing on the end-user experience and assessing backward-compatibility concerns - and that just happened to turn out much more complex than originally anticipated.\r\n\r\n",
      "created_at": "2021-02-07T07:38:47Z",
      "updated_at": "2021-02-07T07:39:13Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 I think we all are in consensus that we don't change the default behavior of the cmdlet and we all find the new Graceful option being useful.\r\nPerhaps we need to rename Graceful switch to TryGraceful to explicitly say users that the cmdlet does not guarantee that a process will necessarily stop (due to the way the operating systems work). I suppose we don't need to worry about how processes will react to SIGTERM and CloseMainWindow(). This specific can be described in the documentation. I guess my code snippet is the best compromise. I'm sure this will cover most custom scenarios. More complex cases can always be resolved with additional commands. ",
      "created_at": "2021-02-08T08:49:06Z",
      "updated_at": "2021-02-08T08:49:06Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov \r\n\r\n>  think we all are in consensus that we don't change the default behavior of the cmdlet and we all find the new Graceful option being useful.\r\n\r\n\ud83d\udc4d\r\n\r\n> Perhaps we need to rename `-Graceful` switch to `-TryGraceful`\r\n\r\n\ud83d\udc4d\r\n\r\n> I suppose we don't need to worry about how processes will react to SIGTERM and CloseMainWindow().\r\n\r\nThat is definitely an option - we can keep desired-state logic out of the cmdlet for now, and possibly enhance later.\r\n\r\n> I guess my code snippet is the best compromise.\r\n\r\nNo, I don't think so, because _by default_ there should be _no_ fallback to killing - just like `taskkill` without `/f` (the equivalent of `-TryGraceful`) does _not_ kill if `.CloseMainWindow()` returns `$false` - instead, it reports an error that _tells you how to KILL if you really want to_.\r\n\r\nIn terms of your snippet, this means:\r\n\r\n```csharp\r\nif (TryGraceful.Present)\r\n{\r\n   if (! TryStopProcessGacefully()) \r\n  {\r\n     // Report non-terminating error along the lines of (obviously needs polishing):\r\n     // \"Graceful termination not possible (the process either doesn't support it at all (no message loop) \r\n     // or cannot process messages in its current state); to kill the process, call without -TryGraceful\"\r\n  }\r\n}\r\nelse\r\n{\r\n    process.Kill();\r\n}\r\n```\r\n\r\nAgain, desired-state logic is desirable, but falling back to killing only if the close-request cannot even be _sent_ makes for _half_ of an ensured-termination feature: a successfully sent request may still result in _non-termination_, which means that you haven't _ensured_ termination overall.\r\n\r\nA proper ensured-termination feature would require _waiting for termination_ (if the request was _successfully_ sent, otherwise you can kill instantly), which introduces the need for a timeout (at least a default one, but ideally also a user-specifiable one).\r\n\r\n(Note that on Unix the case where `SIGTERM` cannot even be _sent_ likely means a fundamental problem, such as insufficient permissions, which means that `SIGKILL` wouldn't work either; therefore, this case should just result in an _error_; this could also happen with `.Kill()` on Windows)\r\n\r\nIn terms of syntax, this means:\r\n\r\n* If we initially go _without_ ensured-termination in the picture we would only need `-TryGraceful`\r\n\r\n```\r\nStop-Process ... [-TryGraceful]\r\n```\r\n\r\n* If and when we decide to implement ensured-termination logic: \r\n\r\n```\r\nStop-Process ... -TryGraceful [-Force [-Timeout <double>]] \r\n```\r\n\r\n* `-Force` is the best choice to signal the intent to _fallback to killing_, and I think it's defensible to give the existing `-Force` switch this semantics _when combined with `-TryGraceful`_.\r\n\r\n* Unless `-Timeout` is also specified, a well-documented _default_ timeout would apply before killing is resorted to; this default timeout should probably apply _per input process_, whereas a user-specified one should apply overall.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2021-02-08T17:07:21Z",
      "updated_at": "2021-02-08T17:08:29Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 If on Windows we can detect whether a process can handle a close event (CloseMainWindow() returns false), on Unix we cannot detect this for SIGTERM. (If we haven't permissions we will get an exception in any case.) I'd prefer to have unified behavior for all OS-s. It is first argument to do not throw and just send a close event.\r\nSecond argument is there are not benefits for users to get an error.  If users initiate a grace stopping but don't care whether the process was really stopped the error makes no sense. If users care about that the process was really stopped they should explicitly check this (with Wait-Process) in any case (is there an error or not).",
      "created_at": "2021-02-09T17:21:49Z",
      "updated_at": "2021-02-09T17:21:49Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> It is first argument to do not throw and just send a close event.\r\n\r\nSending a close event: yes. \r\n\r\nIf the system tells you that it cannot, you report a non-terminating error (rather than _throwing_), just as you would with a permissions problem with `SIGTERM` on Unix).\r\n\r\nThis amounts to unified behavior _with respect to the underlying system capabilities_.\r\n\r\n> Second argument is there are not benefits for users to get an error. If users initiate a grace stopping but don't care whether the process was really stopped the error makes no sense\r\n\r\nThey may care about being able to _request_ graceful stopping, but leaving it up to the target process to comply (see below).\r\nThat is what the underlying system mechanisms provide - even if that is unsatisfying from a _desired state_ viewpoint.\r\n\r\nOn Unix, the processes _almost always_ comply - from what I can tell, even GUI applications such as `gedit` and `Firefox`, which - unlike GUI applications on _Windows_ - do _not_ pop up a modal dialog if their data is \"dirty\", and quietly terminate (potentially due to not even having a signal handler).\r\n\r\nThat is, on Unix, where only truly exceptional conditions (such as lack of permissions) prevent _sending_ the signal, sending `SIGTERM` will _typically_ result in termination - but that termination is _not guaranteed_, given that if the process has a signal handler, it may refuse (or the signal handler may crash).\r\n\r\nOn Windows, you're much more likely to run into non-termination:\r\n\r\n* (a) applications without a message loop (such as console applications called from a shell) fundamentally cannot accept the \"signal\" (the window message sent by `.CloseMainWindow()`.\r\n\r\n* (b) **applications that _do_ have a message loop and accept the \"signal\" will predictably _not_ terminate if they're GUI applications in a \"dirty\" state that causes them to pop up a modal confirmation dialog.**\r\n\r\nIn the case of (a), you deserve to know that _graceful_ termination is _fundamentally impossible_ (an unfortunate limitation of Windows) - this is what `taskkill` already does.\r\n\r\nIn the case of (b), the only assurance you have is that the signal was \"sent\" - and there's a definite chance that termination will _not_ occur.\r\n\r\nIf you implement a fallback to killing just for (a), you introduce an awkward asymmetry that additionally _hides_ a system capability: to _request_ termination _without enforcing it_.\r\n\r\nConversely, you have _not_ ensured overall that termination will take place.\r\n\r\n---\r\n\r\n**The only unified _platform-neutral_, desired-state behavior that is worth providing is the one that would (a) require opt-in via `Force` (indicating that you want to _fall back to killing_) and (b) therefore requires a more complex implementation with timeout-based waiting**, which is the only way to _guarantee_ termination.\r\n\r\n",
      "created_at": "2021-02-09T17:59:45Z",
      "updated_at": "2021-02-09T18:13:19Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "You seem to be ignoring the fact that the \"grace stopping\" is only a function of the application and it works only as the developer implemented it. There can be an infinite number of implementations. There's not even precise feedback (from the API) even on Windows. Moreover, there is not even a predefined semantics, even on Windows - the developer can assign any action to the event. There is no point in looking for something in common and trying to make a universal solution.\r\nWe can find many interactive programs that behave differently. So MS Word could ask to save a file, but VS Code couldn't. If we pay attention to services, they behave very differently from interactive applications. For example, if we send a SIGTERM to a web server, it could not mean stopping it, but a cold restart.\r\nAll we can do is send a signal and forget. We do this in Stop-Process only because we hope that, in general, application developers follow common practice for this event, however each implementation will be different for each application. We can do more only for a specific application by implementing the necessary logic in the commands following the Stop-Process in a script.",
      "created_at": "2021-02-10T04:39:21Z",
      "updated_at": "2021-02-10T04:39:21Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> All we can do is send a signal and forget.\r\n\r\nThat's what we can and should do in the simplest case (`-TryGraceful` alone).\r\n\r\nIf sending the signal / calling `.CloseMainWindow()` _fails_, we should report that as an error, which on Windows - unfortunately, but that can't be helped - categorically includes console applications not directly running in a console (as is typical, given that they're usually launched from a *shell*, which is the one running directly in the console; should Windows in the future ever provide a termination-request mechanism for such applications, we can amend the cmdlet, if that hypothetical mechanism requires something other than `.CloseMainWindow()`, which would be a misnomer in that case).\r\n\r\n(If sending _succeeds_, we're done and move on, as you suggest,)\r\n\r\nAs stated, we could do this in a first step, and implement ensured-termination logic (see below) later, if ever.\r\n\r\n> We can do more only for a specific application by implementing the necessary logic in the commands following the Stop-Process in a script.\r\n\r\nNo, as proposed, there _is_ something we can do: \r\n\r\n_If requested_, we can _ensure_ that the process terminates by _waiting_ for termination - whether with a default or specified timeout period - and if termination hasn't occurred within that timeout - for whatever reason (we can't know) - _kill_ the process then.\r\n\r\nOf course, anyone can implement that logic themselves using the existing capabilities (assuming `-TryGraceful` alone has been implemented), but that's fairly cumbersome, so \r\nwe would be offering this as built-in desired-state logic, as a  courtesy.\r\n\r\n",
      "created_at": "2021-02-10T07:23:05Z",
      "updated_at": "2021-02-10T07:31:35Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "It sounds like the only sticking point is what to do if `.CloseMainWindow()` returns `$false` with `-TryGraceful` (alone):\r\n\r\n* Approach A: Report an error and do nothing else; this is what `taskkill.exe` does. \r\n* Approach B: Automatically and quietly fall back to killing; this is what you're advocating, if I understand correctly.\r\n\r\nI find B problematic, but I can also see the appeal of its pragmatism - though it's important to understand that the kill fallback will _not_ apply to GUI applications that accept the message and then pop up a confirmation dialog.\r\n\r\nIf everyone is comfortable with it, so be it.\r\n\r\n\r\n",
      "created_at": "2021-02-10T09:14:20Z",
      "updated_at": "2021-02-10T09:18:36Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> It sounds like the only sticking point is what to do if .CloseMainWindow() returns $false with -TryGraceful (alone):\r\n\r\nYes. It is only about Windows.\r\n\r\n> Of course, anyone can implement that logic themselves using the existing capabilities (assuming -TryGraceful alone has been implemented), but that's fairly cumbersome, so\r\nwe would be offering this as built-in desired-state logic, as a courtesy.\r\n\r\nAnd yes, and no. We could do something smart if CloseMainWindow() did something smart. But see the method implementation:\r\nhttps://github.com/dotnet/runtime/blob/8a52f1e948b6f22f418817ec1068f07b8dae2aa5/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.Win32.cs#L240-L260\r\n\r\nThis method does nothing smart. It fast return false if no main window is or it is disabled - why do we need to write an error if such application makes no distinction between killing and grace stopping? For such application killing is the same as grace stopping.\r\nAnd as we can see if CloseMainWindow() sends WM_Close event it returns always true - not a result from the application as we could expect! It is exactly as on Unix for SIGTERM. \r\nThere is recommendation for processing WM_Close in [docs](https://docs.microsoft.com/en-us/windows/win32/learnwin32/closing-the-window) but this does not mean that everyone will do exactly that. For example, VS Code does not ask to save the file on close, unlike MS Word.\r\n\r\nSo on all OS-s the result is unpredictable - a script write is forced to _always check_ the result he expects in his particular scenario - no errors help.\r\n\n\n<blockquote><img src=\"https://avatars.githubusercontent.com/u/9141961?s=400&v=4\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/dotnet/runtime\">dotnet/runtime</a></strong></div><div>.NET is a cross-platform runtime for cloud, mobile, desktop, and IoT apps. - dotnet/runtime</div></blockquote>",
      "created_at": "2021-02-10T12:46:11Z",
      "updated_at": "2021-02-10T12:46:13Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> It fast return false if no main window is or it is disabled - why do we need to write an error if such application makes no distinction between killing and grace stopping?\r\n\r\nBecause you may choose _not to kill_ if graceful termination isn't possible.\r\n\r\nConsider this scenario: Notepad is open with an unsaved file, and a modal dialog happens to be displayed in it: even though graceful termination is possible with a GUI application such as Notepad _in principle_, in this case `.CloseMainWindow()` returns  `$false` and will result in _data loss_ if you fall back to killing.\r\n\r\nWith your proposal you'll get _reliable_ termination only when `.CloseMainWindow()` returns `$false`.\r\n\r\nIf it returns `$true`, given how GUI applications on Windows respond with unsaved data, there's a good chance you won't get termination at all - which you can - cumbersomely - test for manually, or, as a desired-state _convenience_ feature, we can offer this functionality via `Stop-Process` on an _opt-in_ basis; see next point.\r\n\r\nBy contrast, what I proposed would amount to `-TryGraceful` simply being a wrapper for `.CloseMainWindow()` on Windows, and its situational failure - indicated by a return value  of `$false` - would be surfaced in a PowerShell-appropriate manner, as a non-terminating error.\r\n\r\nIt is then up to the user to decide _whether killing is appropriate_. \r\nIn the simplest case the fallback-to-kill logic _as an explicit choice_ could then be achieved with:\r\n`Stop-Process -TryGraceful $somePid 2>$null || Stop-Process $somePid`\r\n\r\n> We could do something smart\r\n\r\nWe can do something _predictable_ that _ensures_ a desired outcome, namely reliable termination - covering _both_ the cannot-send-signal and signal-sent-but-process-didn't-terminate scenarios, as previously described.\r\n\r\nIt would be a  _convenience_ feature that compensates for the lack of predictability of the underlying system features.\r\n\r\nAs stated,  it requires additional parameters and a more complex implementation.\r\n\r\n",
      "created_at": "2021-02-10T13:11:40Z",
      "updated_at": "2021-02-10T13:11:40Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Let me try to bring closure to this by summarizing our options:\r\n\r\n* Existing behavior remains as-is: target processes are _killed_ by default.\r\n\r\n* A conceptually simple and therefore easy-to-implement solution is to implement (only) a `-TryGraceful` switch:\r\n\r\n  * It sends a _request_ to terminate to a target process, which it may or may not honor, but that's not `Stop-Process`' concern; the request is sent:\r\n    * in the form of the `SIGTERM` signal on Unix\r\n    * by calling `.CloseMainWindow()` on Windows.\r\n\r\n  *  On Unix, failing to send `SIGTERM` represents a condition that leaves reporting an error as the only option (it's likely a permissions problem, which means that `SIGKILL` cannot be sent either).\r\n\r\n      * _Successfully_ sending `SIGTERM` _typically_  but not necessarily results in actual, quiet termination, even of GUI applications.     \r\n        * On macOS, native GUI applications are capable of avoiding data loss by preserving unsaved changes (even in new, never-saved documents) through a feature called Resume.\r\n        * On Linux, I've only looked at Ubuntu 18.04: data loss _does_ occur, such as in GEdit; Linux systems come with a variety of GUI shells - I don't know how they behave.\r\n\r\n  *  On Windows, we have a _choice_ as to how to respond to `.CloseMainWindow()` indicating failure by way of returning `$false`:\r\n\r\n      * Context:\r\n        * `$false` is returned in two distinct scenarios:\r\n           * the target process has no message loop, either because it isn't a GUI-subsystem application or because it is a console-subsystem application that doesn't _directly_ run in a console window (which - typically, but not necessarily - only _shell_ processes do)\r\n           * the target process _does_ have a message loop, but is unable to receive messages _at the moment_, either because it hangs or because its GUI is showing a _modal dialog_ that blocks the main message loop.\r\n  \r\n        * `$true` just means that the message was successfully _sent_, but with GUI applications there is a distinct chance that they will _not_ terminate, namely if they're in a \"dirty\" state that causes them to pop up a modal dialog to ask the user to confirm the intent to terminate either with or without saving.\r\n\r\n      * Implementation options for the case when `$false` is returned:\r\n\r\n          * **Option 1**: Report a _non-terminating error_ and take no further action.\r\n            * This follows the default behavior of `taskkill.exe` (using option `/f` requests _kill_ behavior).\r\n            * If the user wants to ensure termination, they'll have to call `Stop-Process` again, _without_ `-TryGraceful`.\r\n\r\n          * **Option 2**: Fall back to _killing_ the process, which has the following implications:\r\n            * Most console applications (except those running directly in console windows, which are typically only shells) are _always killed_.\r\n            * GUI applications that hang and those that happen to be showing a modal dialog are _killed_.\r\n            * All other applications either terminate gracefully, refuse to terminate, or, in the case of GUI applications, delegate the termination decision to the user by popping up a modal confirmation dialog.\r\n\r\n  * On _both_ platforms, if ultimate _termination_ is to be _ensured_ in _all_ cases, the user will have to use _additional commands_ in order to _wait for a while_  (`Wait-Process`) and, if waiting times out, call `Stop-Process` _without_ `-TryGraceful` to effect termination by _killing_.\r\n\r\n* A more complex enhancement that provides _ensured-termination_ logic can be added later, which then needs to incorporate the timeout-based waiting and kill fallback into `Stop-Process` itself.",
      "created_at": "2021-02-12T02:53:56Z",
      "updated_at": "2021-02-12T03:15:29Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "To get a consistency on all platforms we could not use `CloseMainWindow()` but our custom method without first two checks - only send WM_Close event - we would get a behavior like with SIGTERM on Unix - send and forget. (If an user want exactly `CloseMainWindow()` behavior he can call it directly.)",
      "created_at": "2021-02-12T03:36:22Z",
      "updated_at": "2021-02-12T03:36:22Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "If you really wanted to do that, you could simply ignore `.CloseMainWindow()`'s return value.\r\n\r\nHowever, to me that's not consistency - that's just hiding an error condition from the user, given that he intent of _requesting_ termination could not be fulfilled.\r\n",
      "created_at": "2021-02-12T03:56:59Z",
      "updated_at": "2021-02-12T03:56:59Z"
    },
    {
      "author": "danielniccoli",
      "author_association": "NONE",
      "body": "It is unfortunate that SIGTERM is not the default. While I understand that some people here have concerns regarding breaking changes, I think it is not wise to have expected behaviour hidden behind a switch. Breaking changes happen all the time. From 7.0 to 7.1 to 7.2 to 7.3 (preview).\r\n\r\nI suggest to rather have a breaking change now, then forgetting to change the default behaviour in 8.0 and keep postponing this needed change for years.",
      "created_at": "2022-07-17T13:35:40Z",
      "updated_at": "2022-07-17T13:35:40Z"
    },
    {
      "author": "davesbrown",
      "author_association": "NONE",
      "body": "Not sure if this is right thread, but I've noticed a behavior where I would wait for the ProcessId to clear (zero or null?) but recently, seems something has changed.  When I use wmiobject or ciminstance to get the PID after a stop, the PID is immediately zero, but if I run handle.exe I'll still see file locks with an associated PID.",
      "created_at": "2022-08-11T20:15:41Z",
      "updated_at": "2022-08-11T20:15:41Z"
    },
    {
      "author": "manokara",
      "author_association": "NONE",
      "body": "I'm on Windows with PowerShell 7.1.5. This behavior is quite unintuitive, because there is a `-Force` switch but `Stop-Process` always acts as if it was on, killing a process without mercy instead of gracefully shutting it down. I've noticed this also happens with Task Manager - it doesn't give you an option to *request* a process to terminate, allowing for cleanup routines to be run. Being mostly a Linux user, I'm used to `SIGTERM`ing processes and only `SIGKILL`ing them as a last resort. Seems like `SIGKILL` is the default expected behavior on Windows.\r\n\r\nIn my use case, I'm dealing with console processes on a CI deployment pipeline so `CloseMainWindow()` doesn't apply. Using `taskkill` instead as OP mentioned works as expected.",
      "created_at": "2022-09-04T23:01:08Z",
      "updated_at": "2022-09-04T23:01:08Z"
    }
  ],
  "created_at": "2020-09-20T12:29:43Z",
  "number": 13664,
  "state": "open",
  "title": "Bug: Stop-Process does not issue SIGTERM as expected.",
  "updated_at": "2022-09-04T23:01:08Z"
}