{
  "_url": "https://github.com/PowerShell/PowerShell/issues/2751",
  "author": "rkeithhill",
  "body": "Given the inherent breaking changes between Windows PowerShell 5.x and PowerShell Core, especially when running on Linux and macOS, can we consider adding a few new escape characters?\r\n\r\nWith the addition of ANSI esc sequences to the Windows console host, and existence of the same on terminals in Linux and macOS,  I would like to have the following esc chars added:\r\n ```\r\n`e - ASCII escape char 0x1b\r\n`u - specify Unicode character `u<hex-digit>+ e.g. `u2261\r\n`_ - more \"visible/obvious\" line continuation\r\n```\r\nOK, so that last one is a stretch but there seems to be a few problems with line continuation in PowerShell - hard to see / trailing whitespace.  Maybe PowerShell Core presents an opportunity to tweak line continuation a little??\r\n\r\nIf the PowerShell Committee is willing to entertain this idea, is it worth writing up as an RFC?",
  "closed_at": "2017-07-01T23:15:10Z",
  "comments": [
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "I suppose it might break some script obfuscation techniques:\r\n\r\n```powershell\r\n`G`et`-`C`h`i`l`d`It`e`m\r\n```\r\n\r\nBut it does seem like a valuable addition.  We don't need the RFC just yet, but I tagged this for committee review.",
      "created_at": "2016-11-21T19:44:30Z",
      "updated_at": "2016-11-21T19:44:30Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "I'm also okay with ``` `e``` and ``` `u``` without much discussion. Not sure about ``` `_```, but we'll discuss it in our next committee meeting. ",
      "created_at": "2016-11-21T21:07:16Z",
      "updated_at": "2016-11-21T21:07:16Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "> Not sure about `_\r\n\r\nMe neither.  Just throwing it out because I do think line continuation in PowerShell is one of its weaker areas.  At one time, I was suggesting just using `_` until I realized that duh, `_` is a valid function name. :-)",
      "created_at": "2016-11-21T21:26:27Z",
      "updated_at": "2016-11-21T21:26:27Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "Maybe the line continuation problem is worthy of an issue of it's own?",
      "created_at": "2016-11-21T22:34:19Z",
      "updated_at": "2016-11-21T22:34:19Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee reviewed this and would be fine support `e and `u without the need for a RFC.  The risk as a breaking change is minimal and the value is apparent.  For line continuation, we suggest opening a separate issue to discuss that.",
      "created_at": "2016-12-01T00:24:01Z",
      "updated_at": "2016-12-01T00:24:01Z"
    },
    {
      "author": "DerpMcDerp",
      "author_association": "NONE",
      "body": "I'm against the `` `u<hex>+`` without an end of hex sequence delimiter syntax because programming languages like that prone to mistakes when the escape code is followed by text that just happens to be a hex character. My preferred solution is something that resembles Perl's bracketed hex escapes like:\r\n\r\nhttps://connect.microsoft.com/PowerShell/feedback/details/969678/add-character-literals-and-support-unicode-escape-characters-in-strings\r\n\r\nThough I would modify the above proposal so that U+10000 to U+10FFFF produce `UnicodeCodePoint` objects instead of strings:\r\n\r\nhttps://github.com/dotnet/corefxlab/blob/f89da2d8f363c9fbbe2786cdcbe0415a0a7a9ed9/src/System.Text.Primitives/System/Text/Encoding/UnicodeCodePoint.cs\r\n\r\nAnd `[UnicodeCodePoint]` to `[string]` conversion produces a UTF-16 encoded string.\r\n",
      "created_at": "2016-12-24T06:24:12Z",
      "updated_at": "2016-12-24T22:34:16Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "The way C# solves this, and what I was planning to implement, is that the token will always require four hex digits e.g.:\r\n```csharp\r\nConsole.WriteLine(\"Testing \\u0061\\u0062\\u0063def\");\r\n```\r\nSo in PowerShell that would be:\r\n```powershell\r\n\"Testing `u0061`u0062`u0063def\"\r\n```\r\nNo worse (and yeah, no better) than C# in that regard.\r\n\r\nRE UnicodeCodePoint, isn't that a bit of a corner case - using characters above BMP?  Not being sarcastic.  Just never run into a need for a Unicode surrogate pair in .NET or Windows.  And if you really need it, you can use:\r\n```\r\nPS> [System.Char]::ConvertFromUtf32(0x1F01C)\r\n\ud83c\udc1c\r\n```",
      "created_at": "2016-12-24T07:32:57Z",
      "updated_at": "2016-12-24T07:32:57Z"
    },
    {
      "author": "DerpMcDerp",
      "author_association": "NONE",
      "body": "\"foo$([Char]::ConvertFromUtf32(0x1F01C))bar\" doesn't work in places where constant strings are required so programmers would be forced to always break it into surrogates everywhere as a workaround.\r\n\r\nC++ does:\r\n\r\n```C++\r\n// lowercase for UCS-2\r\n\\u<hex>{4}\r\n// uppercase for UCS-4\r\n\\U<hex>{8}\r\n```\r\n\r\nThough requiring 8 characters makes no sense to me since unicode is prevented from going past U+10FFFF.\r\n\r\n> using characters above BMP? Not being sarcastic. Just never run into a need for a Unicode surrogate pair in .NET or Windows\r\n\r\nEmojis require codes past the BMP. I don't use them but I have to account for them when web scraping in PowerShell these days.",
      "created_at": "2016-12-24T22:21:04Z",
      "updated_at": "2016-12-24T22:31:51Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "Well, we could use `` `U<hex>{6}`` for this (or `` `U<hex>{8}`` just to be consistent with C#/C++).",
      "created_at": "2016-12-24T23:29:17Z",
      "updated_at": "2016-12-24T23:29:17Z"
    },
    {
      "author": "DerpMcDerp",
      "author_association": "NONE",
      "body": "If the syntax is going to be `` `u`` Can you consider adding the `` `{(<hex>+<space>?)*}`` form also to support Perl style hex escapes:\r\n\r\n``\"`{61 62 63}\"`` == \"abc\"\r\n\r\nSince escapes often come in batches and it's annoying/cluttered to use `` `u0061`u0062`u0063 ``\r\n\r\nIt would be acceptable for me if the ranges outside the BMP could only be done inside the braced form so only the `` `u<hex>{4} `` and `` `{(<hex>+<space>?)*}`` form become valid.",
      "created_at": "2016-12-24T23:45:47Z",
      "updated_at": "2016-12-24T23:45:47Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "The ambiguity around the number of subsequent hex. digits could be resolved analogously to JavaScript (which, as an aside, also has _fixed_-length escapes), which supports `\\u{...}` escapes, where the enclosing `{` and `}`  _unambiguously_ support  _between 1 and 8 hex. digits_:\r\n\r\nE.g., with Node.js installed, try:  \r\n\r\n```javascript\r\n> node -pe \"'Mot\\u{f6}rhead'\"\r\nMot\u00f6rhead\r\n```\r\n\r\nTranslated to (hypothetical) PowerShell:\r\n\r\n```powershell\r\n> \"Mot`u{f6}rhead\"\r\nMot\u00f6rhead\r\n\r\n> \"Where's the `u{20ac}?\"\r\nWhere's the \u20ac?\r\n```\r\n\r\nGiven that `{...}` is already used to disambiguate identifiers in variable references, that seems like a natural fit.\r\n\r\n~~Also note that this _one_ flexible construct obviates the need for a separate `` \"`e...\" `` escape.~~\r\n",
      "created_at": "2017-05-20T02:13:08Z",
      "updated_at": "2017-05-20T04:18:38Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "I'd prefer to stick closer to the C# approach.  PowerShell has been described by Jeffrey as having a \"glideslope approach to C#\".  I don't see **enough** value in the above to deviate from the C# approach.  ",
      "created_at": "2017-05-20T02:34:48Z",
      "updated_at": "2017-05-20T02:34:48Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@rkeithhill: \r\n\r\nFollowing C# isn't always the goal; in a different context, [@lzybkr said](https://github.com/PowerShell/PowerShell/issues/3820#issuecomment-302750422): \r\n\r\n> PowerShell is not C# and it was not a goal to replicate all of C#'s capabilities.\r\n\r\nPowerShell's _string literals and string interpolation_ were quite disparate from C#'s from the beginning.\r\n\r\n* Personally, when I use PowerShell strings, I _never_ think of how strings work in C#, and from a _pure PowerShell perspective_, `` \"`u{\u2026}`\" `` strikes me as a natural fit.\r\n\r\n* What prompted Jason's quote was a context - class definitions - where a piece of \"un-Powershell\" C# syntax _did_ creep in (calling base-class constructors with `: base()`), prompting _mistaken expectations of more C#-like behavior_.\r\n\r\n",
      "created_at": "2017-05-20T02:40:44Z",
      "updated_at": "2017-05-23T19:35:50Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "Well I didn't mean to imply PowerShell and C# syntax were identical - just that there are areas where you can get some \"transfer of learning\".  That's the \"glideslope\" part that Jeffrey has referred to in the past.\r\n\r\nSo given one syntax that isn't demonstrably better than the other, I'd stick with the one that reflects the C# approach.  And the C# approach also reflects how other shells like Zsh/Bash do this e.g. `\\u2620`.  This is useful when someone sees an example in say Bash, knows that PowerShell uses backtick instead of \\, swaps out the \\ for a backtick and gets it to work in PowerShell.  As Brad Abrams used to say back in the early days of .NET, as much as possible you want folks to fall into the \"pit of success\".\r\n\r\n> Also note that this one flexible construct obviates the need for a separate \"`e...\" escape.\r\n\r\nThis is moot as support for the esc char has already been added to PowerShell.\r\n\r\nI must have missed something with the class ctor chaining since `: base()` is supported in C# and in that regard, PowerShell is \"similar\" to C#.  However, unlike C#, PowerShell doesn't support `: this()` ctor chaining.",
      "created_at": "2017-05-20T03:28:39Z",
      "updated_at": "2017-05-20T03:28:39Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "<sup>Note:  \r\n. This is a rewrite of a since-removed comment that lacked focus.  \r\n. Also, I performed a flippantectomy on another still-extant comment  - my apologies, @rkeithhill -\r\n and merged it with a follow-up.</sup>\r\n\r\n> However, unlike C#, PowerShell doesn't support `: this()` ctor chaining.\r\n\r\nThat's exactly what the linked post is about. The point was that if you're familiar with C# syntax and see `: base()`, it's likely that you'll also expect `: this()` to work.\r\n\r\n> This is moot as support for the esc char has already been added to PowerShell.\r\n\r\nThanks - I missed that, and I can definitely see that it's useful (I originally misinterpreted its purpose).\r\n\r\n---\r\n\r\nAs for transfer of learning: \r\n\r\nThe `` `u `` \\ `\\u` correspondence is definitely helpful, but I think the _4-fixed-hex-digits_ demarcation is not worth adopting, or at least _not only_:\r\n\r\n  * To support _all_ Unicode code points with the fixed-digit-count approach, the _uppercase_ variant `` `U ``  with _8_ fixed hex digits would have to be adopted as well, which is awkward in PowerShell, given its fundamentally _case-insensitive_ nature.  \r\n(As an aside: the existing escapes such as `` `n` `` _are_ case-sensitive, though they arguably don't need to be.)\r\n\r\n  * The patchwork of octal, `\\x`, `\\u`, `\\U` escapes in various languages, including C#, exists for _historical_ reasons, and this is a chance to avoid carrying technical debt forward; the debt stems from:\r\n      * gradual growth of the code-point space over time (ASCII (7-bit) > \"ANSI\" (8-bit) > UCS-2 (16-bit, BMP of Unicode only) > UTF-16 (all of Unicode, with surrogate pairs, 32-bit)\r\n      * lack of support for embedded, variable-length string interpolation constructs.\r\n\r\n * A willingness to shed technical debt is already reflected in this thread's starting post considering _only_ `` `u ``, and not also `\\x` or octal escapes.\r\n\r\n  * The `{...}` form of delimiting is well established in PowerShell, can be found in several other scripting languages, and now even in C# 6's _interpolated strings_ - albeit not in the context of Unicode-character escapes.\r\n\r\n  * To recap: Instead of requiring `` `u00fc `` (4 fixed digits), allow `` `u{fc}``, with between 1 and 8 digits to _unambiguously_ cover _all_ Unicode code points with a _single_ construct.\r\n\r\n---\r\n\r\n**A look at other languages:**\r\n\r\nWhile `\\x`, `\\u`, and `\\U` are common, there are differences with respect to:\r\n\r\n * whether a _fixed_ digit count is required or whether _up-to-a-max-count_ logic.\r\n * whether `{...}` is (also) supported for unambiguously enclosing a variable number of digits.\r\n\r\n---\r\n\r\n* C#, as discussed, has fixed-digit-count `\\x`, `\\u`, and `\\U` only.\r\n\r\n* POSIX-like shells:\r\n   * The POSIX _standard_ mandates only _octal_ escapes, and then only in the context of specific utilities (e.g., for `<tab>`: `\\011` in `printf`'s format string and in `echo`'s operands), not in _string literals_ generally.\r\n  * `bash`, `ksh`, and `zsh` have a string-literal form `$'...'` that supports _variable-digit-count_, non-delimited `\\x`, `\\u`, and `\\U` escapes (also implemented in the built-in versions of the `printf` and `echo` utilities).\r\n  * `ksh`, commendably, additionally supports `{...}` for disambiguation in all 3 cases, whereas `bash`, curiously, only does so for the older `\\x` escape. (`zsh` has no support at all).\r\n\r\n* Ruby, Perl, and JavaScript (also) support `{...}`-delimited variable-digit-count escapes (though Perl's Unicode escapes look different).\r\n",
      "created_at": "2017-05-23T19:37:04Z",
      "updated_at": "2017-05-23T19:37:04Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "I have a PR for Unicode esc sequence coming.  Testing it right now.  This is the way I've implemented it so far:\r\n\r\n* `` \"`u2195\"`` - simple, common use case which can be converted from C# or Bash by simply replacing `\\` with `` ` ``.\r\n* `` \"`u{1F3F4}\"`` - specify 1 to 8 hex digits.  A hex value `> 0xFFFF` and `<= 0x10FFFF` will generate a Unicode surrogate pair e.g.:\r\n```posh\r\n\"Black flag: `u{1f3f4}\" | Out-File .\\unicode.txt -Encoding Unicode\r\n```\r\nThe above generates the following file contents:\r\n![image](https://cloud.githubusercontent.com/assets/5177512/26813694/1f77c1aa-4a3d-11e7-8181-29292d06e936.png)\r\n\r\nOne thing I'm trying to determine now is how widely should these esc sequences be supported.  For instance, double quoted strings and here strings are obvious but the following are perhaps not so obvious:\r\n\r\n**Naming variables with Unicode chars**\r\n```posh\r\nPS> ${foo`u2195} = 'bar'\r\nPS> gv foo*\r\nName                           Value\r\n----                           -----\r\nfoo\u2195                           42\r\n```\r\nI'm inclined to say yes.  C# supports Unicode esc seqs in identifiers e.g.:\r\n```c#\r\ncl\\u0061ss.st\\u0061tic(true);\r\n```\r\n**And specifying arguments (generic tokens) with Unicode chars**\r\n```posh\r\nPS> Get-Command 7z`u2195\r\nGet-Command : The term '7z\u2195' is not recognized as the name of a cmdlet, function, script file, or operable program.\r\nCheck the spelling of the name, or if a path was included, verify that the path is correct and try again.\r\nAt line:1 char:1\r\n+ Get-Command 7z`u2195\r\n+ ~~~~~~~~~~~~~~~~~~~~\r\n    + CategoryInfo          : ObjectNotFound: (7z\u2195:String) [Get-Command], CommandNotFoundException\r\n    + FullyQualifiedErrorId : CommandNotFoundException,Microsoft.PowerShell.Commands.GetCommandCommand\r\n```\r\nAgain I'm inclined to say yes to this as well.\r\n\r\nTwo other questions, I'd like to get input on.  It is worth having both forms (fixed length 4 digits and variable number of digits)?  And should the variable sequence form accept 8 hex chars or just 6?  The underlying API we use to convert the number to a Unicode surrogate pair only allows a max of 21-bit value (6 hex digits - although some 6 digit hex values will be out-of-range).  However, I note that C#'s `` \"\\Uxxxxxxxx\"`` supports 8 hex digits.  I'm wondering why they chose to support 8 digits?  Future proofing?\r\n",
      "created_at": "2017-06-06T04:45:19Z",
      "updated_at": "2017-06-06T14:35:10Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "I could use some feedback on these error messages.  Wording suggestions?\r\n\r\n![image](https://cloud.githubusercontent.com/assets/5177512/26816131/69323338-4a4d-11e7-81d2-32a22573f632.png)\r\n",
      "created_at": "2017-06-06T06:17:22Z",
      "updated_at": "2017-06-06T06:17:22Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "I've always assumed that they support only 4 or 8 simply because strings are 16bit unicode. \r\n\r\nI think you need to support them (at least) anywhere strings can be used (including if I use longer syntax, like `set-variable -Name ...` or `set-content -path function:....`) -- I mean, obviously yes to variable and function identifiers, and yes to parameters.... in fact, the argument example is just an implicit string, after all...",
      "created_at": "2017-06-07T04:11:29Z",
      "updated_at": "2017-06-07T04:11:29Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "Thanks Joel.  I'm getting close on this.  I've decided to support on 6 digits in the bracketed from.  This is from the C# docs:\r\n\r\n> Unicode characters with code points above 0x10FFFF are not supported.\r\n\r\nJust need to make sure my Pester tests pass. ",
      "created_at": "2017-06-07T04:52:08Z",
      "updated_at": "2017-06-07T04:52:08Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "It's great that you're supporting the `` `u{...} `` syntax. \r\n\r\n> It is worth having both forms (fixed length 4 digits and variable number of digits)?\r\n\r\nAt the risk of repeating myself: I think this is an opportunity to ditch the fixed-digit-count form - which would also mean: fewer error messages to worry about :)\r\n\r\nIn that vein, re error messages: perhaps the following catch-all would then do (spread across 2 lines just for readability here):\r\n\r\n    Invalid Unicode escape sequence:\r\n    Must be `u{<hex-digits>}, using between 1 and 6 hex digits, up to a maximum of 10FFFF.\r\n\r\nRe number of hex digits. in the `` `u{...} `` form:\r\n\r\n6 digits are definitely enough in the foreseeable future (though the upcoming integration of the Martian alphabet may change that).\r\nAmong the languages / shells previously mentioned, Ruby does the same (all others support 8, presumably for the reason @Jaykul mentioned).\r\n\r\n\r\n",
      "created_at": "2017-06-07T21:59:25Z",
      "updated_at": "2017-06-07T21:59:50Z"
    },
    {
      "author": "DerpMcDerp",
      "author_association": "NONE",
      "body": "@rkeithhill:\r\n\r\nDoes ``foo `u002Dbar`` or ``foo `u{2D}bar`` parse similar to `foo -bar` (i.e. gets treated as a potential keyword parameter rather than a string) ?\r\n\r\nDoes ``foo 2`u0030`` or ``2`u{30}`` parse similar `foo 20` (i.e. gets treated as number rather than a bareword/string) ?\r\n\r\nAre you planning on supporting multi-escapes e.g. ``\"`u{61 62 63}\"`` means ``\"`u{61}`u{62}`u{63}\"`` ?",
      "created_at": "2017-06-08T02:19:28Z",
      "updated_at": "2017-06-08T02:19:28Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@DerpMcDerp: Good questions, and without having looked at @rkeithhill's code and without wanting to speak for him, here's my $.02 with respect to how it _should_ work:\r\n\r\n> Does foo `u002Dbar or foo `u{2D}bar parse similar to `foo -bar`\r\n\r\nNO: Shell metacharacters such as `-` should only ever be recognized as _literals_.\r\n\r\n> Does foo 2`u0030 or 2`u{30} parse similar foo 20\r\n\r\nYES: In the parameter-value token-parsing stage, `` 2`u{30} `` should evaluate to `20` (`` 2`u0030 ``? Why, I never ...).\r\n\r\n> gets treated as number rather than a bareword/string) ?\r\n\r\nThere's no such thing as a number _at that stage_. There's only a _token_ that will bind to a parameter, and that parameter's type determines the token's interpretation.\r\n\r\nIn other words:  `` 2`u{30} ``, a.k.a. `20` may turn into a number _or_ a string - it all depends on the type of the parameter it binds to.\r\n",
      "created_at": "2017-06-08T02:53:03Z",
      "updated_at": "2017-06-08T02:53:03Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "`` foo `u002dbar`` passes a string argument to the function (even if the function has a `$Bar` parameter defined.   So no.\r\n\r\n``foo 2`u0030`` again passes a string argument to the function. So no.\r\n\r\nI don't view either as problem.\r\n\r\nRegarding support for multi-escapes, no that's what I've implemented with the current PR.  ",
      "created_at": "2017-06-08T02:55:33Z",
      "updated_at": "2017-06-08T02:55:33Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@rkeithhill \r\n\r\n> foo 2`u0030 again passes a string argument to the function. So no.\r\n\r\nConsider the following examples:\r\n\r\n```powershell\r\n> function foo { param([int] $i) \"[$i]\" }; foo ('0' + 'x' + '10')\r\n[16]\r\n\r\n> foo '+00010'\r\n[10]\r\n```\r\n\r\nClearly, what ended up binding to the `[int]` parameter was recognized as an _integer_, despite having been composed of string components, being a hex representation, or being explicitly passed as a \"string\".\r\n\r\nWhile it seems ill-advised to represent token `20` as `` 2`u{30} ``, I see no reason why it should act differently.\r\n\r\nWould your PR actually not work this way?\r\n\r\n",
      "created_at": "2017-06-08T03:03:12Z",
      "updated_at": "2017-06-08T03:10:14Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "The PR works as I've described.  It's like passing `` 7` 7`` or `` 7`t7`` as an argument.  That argument is parsed as a string due to it encountering an character esc seq.  The parser doesn't consider the \"value\" of the esc sequence.",
      "created_at": "2017-06-08T03:09:16Z",
      "updated_at": "2017-06-08T03:16:20Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@rkeithhill: I don't think there's a real disagreement here, but there's terminology confusion: there's a token-parsing stage that results in a data type-agnostic sequence of characters that is later bound to a parameter, and it is only then that coercion to the target type happens.\r\nCalling it a \"string\" before that binding happens is inviting confusion with  a `[string]`-typed parameter.\r\n\r\nJust to clear things up:\r\n\r\n Will\r\n\r\n```powershell\r\n> function foo { param([int] $i) \"[$i]\" }; foo 20\r\n[20]\r\n```\r\n\r\nNOT work the same as the following?\r\n\r\n```powershell\r\n> function foo { param([int] $i) \"[$i]\" }; foo 2`u{30}\r\n[20]\r\n```\r\n\r\n\r\n",
      "created_at": "2017-06-08T03:18:13Z",
      "updated_at": "2017-06-08T03:29:59Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "Yes but your second example coerces a string to an int (due to your typed parameter $i). This is a more informative test:\r\n```\r\nPS> function foo($p) { \"Type: $($p.GetType().FullName) value: $p\" }\r\nPS> foo 20\r\nType: System.Int32 value: 20\r\nPS> foo 2`9\r\nType: System.String value: 29\r\nPS> foo 2`u{30}\r\nType: System.String value: 20\r\n```",
      "created_at": "2017-06-08T03:38:05Z",
      "updated_at": "2017-06-08T03:38:28Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@rkeithhill: \r\n\r\nThat is indeed an interesting illustration of what happens in the _absence_ of _typed_ parameters (note that _both_ my examples coerce to `[int]`).\r\n\r\nSo it would be more accurate to say: using `` ` `` in a token (such as to initiate a Unicode escape sequence) or using explicit quoting  _defaults_ to `[string]` in the _absence of typing_ a parameter.\r\n\r\n_With_  typing, no distinction is made - whether the token was a pure \"number string\" to begin with or resulted in one after expansion of escape sequences and/or removal of quotes is immaterial.\r\n\r\n",
      "created_at": "2017-06-08T03:54:24Z",
      "updated_at": "2017-06-08T03:56:59Z"
    },
    {
      "author": "DerpMcDerp",
      "author_association": "NONE",
      "body": "@rkeithhill:\r\n\r\n* Is ``$function`u003Apause`` equivalent to `$function:pause` or `$variable:function:pause` ?\r\n\r\n* Does ``\"inside a string now $(foo `u002Dbar `u003E foo.txt)\"`` parse similar to ``\"inside a string now $(foo -bar > foo.txt)\"`` ?\r\n\r\n* Does ``\"inside a string now $(foo 2`u0030 `u007C write)\"`` parse similar to ``\"inside a string now $(foo 20 | write)\"`` ?\r\n",
      "created_at": "2017-06-08T03:58:46Z",
      "updated_at": "2017-06-08T04:05:35Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Ceterum censeo (I maintain my blissful ignorance of how thing are actually implemented): \r\n\r\n* Nothing that is the _result of an expansion (interpolation)_ should ever have _syntactical_ function. - metacharacters should only ever be recognized _as literals_.\r\n(Treating arbitrary strings as commands is the domain of `Invoke-Expression`, which should be regarded with equal suspicion as `eval` in POISX-like shells.)\r\n\r\n* Subexpressions (`$(...)`) should be _independent parsing contexts_ - whether or not they are embedded inside `\"...\"` (even though that is their primary purpose) should be immaterial.\r\n\r\n\r\n\r\n",
      "created_at": "2017-06-08T04:27:01Z",
      "updated_at": "2017-06-08T04:27:01Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "@DerpMcDerp - that doesn't parse.  You **can** create a function name with a Unicode esc seq:\r\n```posh\r\nfunction foo`u2195bar {}\r\nfoo\u2195bar  # invoke function\r\n```\r\n@mklement0 I'm mostly with you except for the last part. I don't consider it immaterial because the parameter parser is actually pretty smart about primitives e.g.:\r\n```posh\r\nPS> foo 20\r\nType: System.Int32 value: 20\r\nPS> foo 2.0\r\nType: System.Double value: 2\r\nPS> foo 20d\r\nType: System.Decimal value: 20\r\n```\r\nSo the parser has determined the type of the argument before it is passed to the function.  Then the parameter binding begins its process of type coercion (if necessary).  You can explore this with the `Trace-Command`.  Try this with your `foo` function passing in `10` and `'10'`.  Note this command seems to display more useful info in Windows PowerShell.  In PS Core, it's not so helpful.\r\n```posh\r\nPS> Trace-Command -Name ParameterBind*,TypeConversion -Expression {foo '10' } -PSHost\r\nDEBUG: ParameterBinding Information: 0 : BIND arg [10] to parameter [i]\r\nDEBUG: ParameterBinding Information: 0 :     Executing DATA GENERATION metadata:\r\n[System.Management.Automation.ArgumentTypeConverterAttribute]\r\nDEBUG: ParameterBinding Information: 0 :         result returned from DATA GENERATION: 10\r\nDEBUG: ParameterBinding Information: 0 :     BIND arg [10] to param [i] SKIPPED\r\nDEBUG: ParameterBinding Information: 0 : BIND arg [10] to parameter [i]\r\nDEBUG: ParameterBinding Information: 0 :     Executing DATA GENERATION metadata:\r\n[System.Management.Automation.ArgumentTypeConverterAttribute]\r\nDEBUG: ParameterBinding Information: 0 :         result returned from DATA GENERATION: 10\r\nDEBUG: ParameterBinding Information: 0 :     BIND arg [10] to param [i] SKIPPED\r\nDEBUG: ParameterBinding Information: 0 : BIND arg [10] to parameter [i]\r\nDEBUG: ParameterBinding Information: 0 :     Executing DATA GENERATION metadata:\r\n[System.Management.Automation.ArgumentTypeConverterAttribute]\r\nDEBUG: TypeConversion Information: 0 :         Converting \"10\" to \"System.Int32\".\r\nDEBUG: TypeConversion Information: 0 :             Converting to integer.\r\nDEBUG: ParameterBinding Information: 0 :         result returned from DATA GENERATION: 10\r\nDEBUG: ParameterBinding Information: 0 :     COERCE arg to [System.Int32]\r\nDEBUG: ParameterBinding Information: 0 :         Parameter and arg types the same, no coercion is needed.\r\nDEBUG: ParameterBinding Information: 0 :     BIND arg [10] to param [i] SUCCESSFUL\r\n\r\nPS> Trace-Command -Name ParameterBind*,TypeConversion -Expression {foo 10 } -PSHost\r\nDEBUG: ParameterBinding Information: 0 : BIND arg [10] to parameter [i]\r\nDEBUG: ParameterBinding Information: 0 :     Executing DATA GENERATION metadata:\r\n[System.Management.Automation.ArgumentTypeConverterAttribute]\r\nDEBUG: ParameterBinding Information: 0 :         result returned from DATA GENERATION: 10\r\nDEBUG: ParameterBinding Information: 0 :     BIND arg [10] to param [i] SUCCESSFUL\r\n```",
      "created_at": "2017-06-08T04:27:34Z",
      "updated_at": "2017-06-08T17:28:31Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "<sup>**Note**: Edited to incorporate @rkeithhill's feedback below.</sup>\r\n\r\nThanks, that was illuminating, and thanks for indulging my tangent; I've tried to summarize in more detail further below, which may be of interest to some.\r\n\r\n* A token that contains a Unicode escape sequence will _default_ to type `[string]` (e.g., `` `u2{30} ``) - unlike a \"straight number string\" (i.e., a character sequence that can in its entirety be interpreted as a number; e.g., `20`, which defaults to `[int]`).\r\n\r\n* However, it is the _parameter_'s type that ultimately determines the token's type, _if specified_ (other than as `[object]`, `[psobject]`, `[pscustomobject]`). \r\n\r\nTherefore:\r\n\r\n* With an _untyped_ parameter, the distinction matters: `20` becomes an `[int]`, and `` 2`u{30} `` becomes a `[string]`.\r\n\r\n* With a _typed_ parameter, there is no _functional_ distinction between `20` and `` 2`u{30} ``, although if the target type is `[int]`,  the latter must undergo a second round of type conversion _behind the scenes_.\r\n\r\n### Optional reading: Parameter parsing and types\r\n\r\nNote: The following covers only _argument-mode_ parsing and tokens that are _literals_, including _quoted_ ones (which includes `` ` ``-prefixed individual-character escapes and Unicode escape sequences) that may have _embedded_ variable references or subexpressions.  \r\nSpecifically, _isolated_ variable references and subexpressions, parenthesized expressions, use of the array-expression operator, splatting, and hashtable literals are excluded.\r\n\r\n* The parameter parsers recognizes a few types _up front, in isolation, preliminarily_:\r\n\r\n   * Something that is _unquoted_ (and has no embedded variable references/subexpressions) and can be parsed as a _number_ is converted to an appropriate number type (in the range of types from `[int]` to `[double]`, including recognition of exponential notation, hexadecimal notation, and numbers with type suffixes `l` and `d`, but _not_ including negative numbers (tokens starting with `-`)).\r\n     * For negative numbers to be recognized, you need parentheses (or the subexpression operator); e.g., `(-20)`.\r\n\r\n   * Everything else becomes a `[string]`.\r\n\r\n * During parameter binding, that preliminary type _may_ be retained _as is_: \r\n\r\n   * If its type is the _same_ as the parameter's or it is a _derived_ type.\r\n\r\n       * Note that the derived-type scenario doesn't apply here, given that the preliminary types are limited to number types (which are value types that can't be derived from) and `[string]`, which is a _sealed_ reference type.\r\n\r\n   * If the parameter is _untyped_ or declared as `[object]` (this is a corollary of the above), but also if it is declared as `[psobject]` or `[pscustomboject]` (type accelerator `[pscustomboject]` is curiously the same as `[psobject]`; both refer to `[System.Management.Automation.PSObject]`).\r\n\r\n * Otherwise, _coercion_ to the target type happens, which:\r\n    * may be able to make use of the preliminary type (e.g., coercing a preliminary `[int]` to a `[long]` parameter),\r\n     * may have to fall back to the raw string representation,\r\n     * may fail altogether.\r\n     * Successful coercions use a variety of techniques, detailed in @rkeithhill's post immediately below.\r\n\r\n\r\n",
      "created_at": "2017-06-08T17:40:14Z",
      "updated_at": "2017-08-10T17:35:57Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "Overall, pretty good summary.  I would tweak this sentence `unlike a \"straight number string\" (e.g., 20, which defaults to [int]).` to `unlike a character sequence corresponding to number (e.g., 20, which defaults to [int]).`  Saying it is a \"number string\" introduces some confusion - it is a number or a string.  :-)\r\n\r\n> but not including negative numbers (tokens starting with -)\r\n\r\nCareful on this. Remember that PowerShell parses in two modes: command and expression.  You've observed just the command mode.  You can change the behavior WRT `-<num>` by using a grouping expression or sub-expression e.g.:\r\n```posh\r\nPS> function z($n) { \"`$n is $n, type is $($n.GetType().FullName)\" }\r\nPS> z -19\r\n$n is -19, args[0] is , less than zero True\r\nPS> z (-19)\r\n$n is -19, type is System.Int32\r\n```\r\n\r\n> coercion to the target type happens, which:\r\n\r\nThe hoops that PowerShell jumps through to coerce one type to another are even more significant than that.  IIRC, PS will attempt to use Parse/TryParse methods if they exist as well as instances of ArgumentTransformationAttribute-derived classes (if the associated parameter is decorated with such attributes).  The latter allows users to inject custom logic into the type coercion process.  If the target type is a string, ToString() also fits into the process which is why if you pass a Process object to a parameter of type string, you'll get a value of `System.Diagnostics.Process (powershell)`.\r\n\r\nI believe there may be other heuristics involved including using ctors with the correct signature and possibly other methods.",
      "created_at": "2017-06-08T18:13:45Z",
      "updated_at": "2017-06-08T18:13:45Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @rkeithhill, all good stuff; yes, I was only talking about argument-mode (which is what \"about_Parsing\" calls it, at least these days), and I've edited my post to make that clearer; I've also incorporated your other suggestions, except for the background on the advanced coercion techniques (I just point to your comment).",
      "created_at": "2017-06-08T18:32:29Z",
      "updated_at": "2017-06-08T18:32:29Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "Here's the latest version of parser error messages for Unicode escape sequence parsing:\r\n![image](https://user-images.githubusercontent.com/5177512/26999447-194ab036-4d57-11e7-83e1-f02255b9d7c1.png)\r\n",
      "created_at": "2017-06-10T03:04:12Z",
      "updated_at": "2017-06-10T03:05:49Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "These error messages are very clear and helpful.\r\n\r\nIf providing that level of specificity is the consensus, then I think they're great.\r\n\r\nI wonder if the specificity is needed, however, given that someone even attempting to use this feature can be assumed to have a reasonable level of technical competence, which is why I suggested a single catch-all message earlier.\r\n\r\n(But I'm probably venturing into bike-shedding territory here.)",
      "created_at": "2017-06-10T20:19:31Z",
      "updated_at": "2017-06-10T20:19:31Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "Thanks!  RE too specific, I remember a time when the PowerShell error messages were less than helpful.  Over time I think they've gotten better in terms of not only telling you what is wrong but also, when possible, suggesting a mitigation.  \r\n\r\nLately, I've been impressed with how well `Git` does this e.g.:\r\n```\r\nPS> git statuz\r\ngit: 'statuz' is not a git command. See 'git --help'.\r\n\r\nDid you mean this?\r\n        status\r\n```\r\nSo while I agree we should keep the error messages as short as possible (otherwise TL;DR) I do think we should provide some help in terms of suggesting a fix.",
      "created_at": "2017-06-10T20:46:10Z",
      "updated_at": "2017-06-10T20:46:10Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@rkeithhill the PowerShell Team has discussed enhancing the current suggestion system to be more useful for missing or typos for cmdlets or parameters.  I didn't find an existing issue, so I opened https://github.com/PowerShell/PowerShell/issues/3988",
      "created_at": "2017-06-10T23:55:14Z",
      "updated_at": "2017-06-10T23:55:14Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "The @PowerShell/powershell-committee reviewed this and we agreed to we do not want the fixed width syntax without braces - we only want the braced syntax.\r\n\r\nArguments against the fixed width syntax:\r\n* It's harder to read\r\n* It might be similar to C#, but it's not exactly the same, so cut and paste doesn't work anyway\r\n* No possible ambiguity, e.g. `` `uabcd00 `` vs. `` `u{abcd}00``\r\n\r\n",
      "created_at": "2017-06-22T01:16:22Z",
      "updated_at": "2017-06-22T01:16:22Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "Works for me.  I'll try to get the updates finalized tomorrow night.  Just got home - spent all day of driving from Salt Lake City back to Colorado. ",
      "created_at": "2017-06-22T03:56:20Z",
      "updated_at": "2017-06-22T03:56:20Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "I rebased and squashed down to a single commit the original support for both forms.  Then I pushed a commit with support for the fixed width form removed.",
      "created_at": "2017-06-23T05:15:59Z",
      "updated_at": "2017-06-23T05:15:59Z"
    },
    {
      "author": "DerpMcDerp",
      "author_association": "NONE",
      "body": "@lzybkr What's the reason for the braced syntax being `` `u{abcd}`` instead of `` `{abcd}`` ?",
      "created_at": "2017-06-23T16:04:57Z",
      "updated_at": "2017-06-23T16:04:57Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "@DerpMcDerp - the @PowerShell/powershell-committee did not discuss dropping the `u`, so I suppose it seemed obvious we needed something.\r\n\r\nI see some advantages to keeping the `u` - it's reasonably descriptive, more similar to other languages, and it's a form of future proofing - it might be desirable to use that same syntax or very similar syntax for some future feature (I don't have anything specific in mind though.)\r\n\r\nThe only advantage I see to dropping the `u` - it's one less character, not much of an advantage.",
      "created_at": "2017-06-23T17:39:00Z",
      "updated_at": "2017-06-23T17:39:00Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "Both `` `e`` and `` `u{xxxxxx}`` have been [implemented](https://github.com/PowerShell/PowerShell/pull/3958), merged and documented.",
      "created_at": "2017-07-01T23:15:10Z",
      "updated_at": "2017-07-01T23:15:10Z"
    }
  ],
  "created_at": "2016-11-21T19:14:33Z",
  "labels": [
    "Issue-Enhancement",
    "WG-Language",
    "Up-for-Grabs",
    "Resolution-Fixed",
    "Committee-Reviewed"
  ],
  "number": 2751,
  "state": "closed",
  "title": "Is it worth writing up an RFC on adding new escape characters?",
  "updated_at": "2017-08-10T17:35:57Z"
}