{
  "_url": "https://github.com/PowerShell/PowerShell/issues/4270",
  "author": "TimCurwick",
  "body": "Fixes issue 4193, wherein it was discussed that the apostrophe, equals sign, and tilde are the last three visible en-us characters that are valid Windows file path characters but cause the assemblyname constructor to throw an error, thereby preventing scripts with class definitions from running when used in the script path. This effectively extends PR 4136 which did this for the comma.",
  "closed_at": "2017-08-25T04:44:47Z",
  "comments": [
    {
      "author": "msftclas",
      "author_association": "NONE",
      "body": "\r\n@TimCurwick,\nThanks for having already signed the Contribution License Agreement. Your agreement was validated by Microsoft. We will now review your pull request.\n_Thanks,\nMicrosoft Pull Request Bot_",
      "created_at": "2017-07-17T15:35:51Z",
      "updated_at": "2017-07-17T15:35:51Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Before fixing the Issue I would prefer to open Issue-Question in CoreFX repo to find root codes and root rules - we should understand that we should fix. Otherwise, we can fix this code indefinitely. What if a char disallowed on first place but allowed on next places? Are there disallowed char combinations? ",
      "created_at": "2017-07-17T16:47:15Z",
      "updated_at": "2017-07-17T16:48:05Z"
    },
    {
      "author": "TimCurwick",
      "author_association": "CONTRIBUTOR",
      "body": "I agree that the permanent fix should be in the .Net code. But in the meantime, I need my PowerShell 6.0 scripts to run on all of my Windows machines whether or not they have some future, fixed version of .Net installed. We probably can't find and work around every problem character. We have to draw the line somewhere. I would be content if the consensus is for the line to be where it is at the moment, as it was the comma that we fixed a couple weeks ago that was personally impacting me. But a less arbitrary line would be to fix (or work around) all affected characters in the base set of ASCII characters, which is what this PR does.",
      "created_at": "2017-07-17T18:20:43Z",
      "updated_at": "2017-07-17T19:48:36Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> Before fixing the Issue I would prefer to open Issue-Question in CoreFX repo to find root cause\r\n\r\nTotally agreed. @TimCurwick Can you please open an issue in dotnet/corefx repo?\r\n\r\n> We have to draw the line somewhere.\r\n\r\nYes, we should. Frankly speaking, it should be very rare to have chars like `,'=~` in a file path, but I agree that working around all affected chars in the base set of ASCII is a reasonable line. Even though adding `'=~` would cover the base set of ASCII chars on Windows, it's not the case on Unix platforms. On Unix platforms, you can have any characters in a file path, and I guess at least `\"` will cause the same problem.",
      "created_at": "2017-07-17T20:06:19Z",
      "updated_at": "2017-07-17T20:06:19Z"
    },
    {
      "author": "TimCurwick",
      "author_association": "CONTRIBUTOR",
      "body": "> Frankly speaking, it should be very rare to have chars like ,'=~ in a file path\r\n\r\nI agree on '=~. The comma on the other hand (which we previously fixed and is not part of this PR), is becoming more common. As companies move to OneDrive for Business, they tend to embed their full legal company name in the path, often including commas.\r\n\r\n> On Unix platforms, you can have any characters in a file path, and I guess at least \" will cause the same problem.\r\n\r\nCan someone test this? I don't have simple access to such a test box. Copy, modify and run the pester test from this PR to test a double quote.",
      "created_at": "2017-07-17T20:30:47Z",
      "updated_at": "2017-07-17T20:31:56Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> The comma, on the other hand, is becoming more common. As companies move to OneDrive for Business, they tend to embed their full legal company name in the path, often including commas.\r\n\r\nThanks for this info! I didn't know of this \ud83d\udc4d \r\n\r\n> Can someone test this? I don't have simple access to such a test box. Copy, modify and run the pester test from this PR to test a double quote.\r\n\r\ndouble quote raises the same exception (see below). But it works fine for these chars `*?<>|`.\r\n```\r\nPS:49> Get-Content './te\"st.ps1'                                                                                          \r\nclass MyClass { static [string]$MyProperty = 'Some value' }\r\n [MyClass]::MyProperty\r\nPS:50> \r\nPS:50> . './te\"st.ps1'                                                                                                    \r\nThe given assembly name or codebase was invalid. (Exception from HRESULT: 0x80131047)\r\nAt line:1 char:1\r\n+ . './te\"st.ps1'\r\n+ ~~~~~~~~~~~~~~~\r\n    + CategoryInfo          : OperationStopped: (:) [], FileLoadException\r\n    + FullyQualifiedErrorId : System.IO.FileLoadException\r\n```",
      "created_at": "2017-07-17T21:47:24Z",
      "updated_at": "2017-07-17T21:47:50Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "From MSDN docs for [AssemblyName Constructor (String)](https://msdn.microsoft.com/en-us/library/b6ccxba0(v=vs.110).aspx):\r\n>The supplied assemblyName is **parsed**, and the appropriate fields of the new AssemblyName are initialized with values from the display name. This is the recommended way of parsing display names. Writing your own code to parse display names is not recommended. \r\n\r\n[BNF notation](https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/specifying-fully-qualified-type-names).\r\nSample: `com.microsoft.crypto, Culture=en, PublicKeyToken=a5d015c7d5a0b012, Version=1.0.0.0`\r\n\r\nI guess the CoreFX parser is here:\r\nhttps://github.com/dotnet/coreclr/blob/32f0f9721afb584b4a14d69135bea7ddc129f755/src/binder/assemblyname.cpp#L183\r\nhttps://github.com/dotnet/coreclr/blob/32f0f9721afb584b4a14d69135bea7ddc129f755/src/binder/textualidentityparser.cpp#L236\r\n\r\nI have no full understanding why it disallow some characters.\r\n\r\nAnother thoughts. Can we refactor the code:\r\n```c#\r\nstring assemblyName = ClrFacade.FIRST_CHAR_PSASSEMBLY_MARK + (string.IsNullOrWhiteSpace(rootAst.Extent.File)  \r\n                                          ? \"powershell\"  \r\n                                          : rootAst.Extent.File  \r\n\r\nvar assemblyObj = new AssemblyName();\r\nassemblyObj.Name = assemblyName;\r\n\r\nvar assembly = AssemblyBuilder.DefineDynamicAssembly(assemblyObj,  \r\n                                                                   AssemblyBuilderAccess.RunAndCollect, GetAssemblyAttributeBuilders()); \r\nvar module = assembly.DefineDynamicModule(assemblyName); \r\n\r\n```\r\n\r\n",
      "created_at": "2017-07-18T15:15:37Z",
      "updated_at": "2017-07-18T18:27:06Z"
    },
    {
      "author": "TimCurwick",
      "author_association": "CONTRIBUTOR",
      "body": "> Another thoughts. Can we refactor the code\r\n\r\nI was thinking the same thing and working on a build to test the idea. I'm not sure your code snippet will quite work as it would still send the unhandled characters to the AssemblyName constructor which is what throws the error. But this should work:\r\n```CSharp\r\nstring assemblyName = ClrFacade.FIRST_CHAR_PSASSEMBLY_MARK + (string.IsNullOrWhiteSpace(rootAst.Extent.File)  \r\n                                          ? \"powershell\"  \r\n                                          : rootAst.Extent.File  \r\n\r\nvar assemblyNameObj = new AssemblyName(\"dummy\");\r\nassemblyNameObj .Name = assemblyName;\r\nvar assembly = AssemblyBuilder.DefineDynamicAssembly(assemblyNameObj, AssemblyBuilderAccess.RunAndCollect, GetAssemblyAttributeBuilders());\r\n```\r\n\r\nAt least, this would prevent the error when creating the AssemblyName. My question is whether creating the AssemblyName is the only place in the code that throws errors when the unhandled characters are used.",
      "created_at": "2017-07-18T15:47:58Z",
      "updated_at": "2017-07-18T17:56:23Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Sorry for my typo - we can remove \"dummy\":\r\n```c#\r\nvar assemblyNameObj = new AssemblyName();\r\n```",
      "created_at": "2017-07-18T18:28:06Z",
      "updated_at": "2017-07-18T18:28:06Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@TimCurwick Could you please continue?",
      "created_at": "2017-08-05T20:17:09Z",
      "updated_at": "2017-08-05T20:17:09Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@TimCurwick Please address two points:\r\n\r\n1. Use `var assemblyNameObj = new AssemblyName();`\r\n2. Use StringBuilder as Jason requested.",
      "created_at": "2017-08-15T09:32:26Z",
      "updated_at": "2017-08-15T09:32:26Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "I have a completely different approach to addressing this problem and retaining the ability of mapping assembly to script - I'll be submitting a PR soon, so I'm closing this one.",
      "created_at": "2017-08-25T04:44:47Z",
      "updated_at": "2017-08-25T04:44:47Z"
    }
  ],
  "created_at": "2017-07-17T15:35:47Z",
  "number": 4270,
  "state": "closed",
  "title": "Add unhandled assemblyname characters",
  "updated_at": "2017-08-25T04:44:47Z"
}