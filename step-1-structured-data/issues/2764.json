{
  "_url": "https://github.com/PowerShell/PowerShell/issues/2764",
  "author": "daxian-dbw",
  "body": "This is a regression introduced by .NET Core 1.1 preview release libraries. It also happens on `alpha.12` release.\r\n\r\nSteps to reproduce\r\n------------------\r\n```powershell\r\n$RequiredAssembliesForInternalWebProxy = @( [System.Net.IWebProxy].Assembly.FullName, \r\n                                            [System.Uri].Assembly.FullName )\r\n\r\n$SourceForInternalWebProxy = @\" \r\nusing System; \r\nusing System.Net;\r\n\r\nnamespace Microsoft.PowerShell.Commands.PowerShellGet \r\n{ \r\n    /// <summary>\r\n    /// Used by Ping-Endpoint function to supply webproxy to HttpClient\r\n    /// We cannot use System.Net.WebProxy because this is not available on CoreClr\r\n    /// </summary>\r\n    public class InternalWebProxy : IWebProxy\r\n    {\r\n        Uri _proxyUri;\r\n        ICredentials _credentials;\r\n\r\n        public InternalWebProxy(Uri uri, ICredentials credentials)\r\n        {\r\n            Credentials = credentials;\r\n            _proxyUri = uri;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Credentials used by WebProxy\r\n        /// </summary>\r\n        public ICredentials Credentials\r\n        {\r\n            get\r\n            {\r\n                return _credentials;\r\n            }\r\n            set\r\n            {\r\n                _credentials = value;\r\n            }\r\n        }\r\n\r\n        public Uri GetProxy(Uri destination)\r\n        {\r\n            return _proxyUri;\r\n        }\r\n\r\n        public bool IsBypassed(Uri host)\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n} \r\n\"@\r\n\r\nAdd-Type -ReferencedAssemblies $RequiredAssembliesForInternalWebProxy `\r\n         -TypeDefinition $SourceForInternalWebProxy `\r\n         -Language CSharp `\r\n         -ErrorAction SilentlyContinue\r\n```\r\n\r\nExpected behavior\r\n-----------------\r\nSucceeds\r\n\r\nActual behavior\r\n---------------\r\n```powershell\r\nAdd-Type : Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more\r\ninformation.\r\nAt line:1 char:1\r\n+ Add-Type -ReferencedAssemblies $RequiredAssembliesForInternalWebProxy ...\r\n+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n    + CategoryInfo          : NotSpecified: (:) [Add-Type], ReflectionTypeLoadException\r\n    + FullyQualifiedErrorId : System.Reflection.ReflectionTypeLoadException,Microsoft.PowerShell.Commands.AddTypeCommand\r\n\r\nPS D:\\>\r\nPS D:\\> $Error[0].Exception.LoaderExceptions\r\nMethod 'GetProxy' in type 'Microsoft.PowerShell.Commands.PowerShellGet.InternalWebProxy' from assembly 'nxg304ea.wnz,\r\nVersion=0.0.0.0, Culture=neutral, PublicKeyToken=null' does not have an implementation.\r\n```\r\n\r\nEnvironment data\r\n----------------\r\n\r\n```powershell\r\n> $PSVersionTable\r\n\r\nName                           Value\r\n----                           -----\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}\r\nPSVersion                      6.0.0-alpha\r\nWSManStackVersion              3.0\r\nPSRemotingProtocolVersion      2.3\r\nGitCommitId                    v6.0.0-alpha.12-104-g67e9bf6376b90c289d725c904280a2439de4dd3b\r\nPSEdition                      Core\r\nBuildVersion                   3.0.0.0\r\nCLRVersion\r\nSerializationVersion           1.1.0.1\r\n```\r\n",
  "closed_at": "2017-04-17T19:14:30Z",
  "comments": [
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@bmanikm and I talked about why we didn't catch it earlier, and we find\r\n1. PowerShellGet tests in PowerShellGet repo are not running on the latest powershell core release -- it's still running on `alpha.11` in PowerShellGet repo.\r\n2. This issue affects scenarios related to proxy, and only throws exception when explicitly importing PowerShellGet -- when it's loaded by auto-loading, the exception gets hidden. It's obvious that we don't have test explicitly importing this module, and the cmdlets we run in tests don't use proxy.",
      "created_at": "2016-11-22T21:57:31Z",
      "updated_at": "2016-11-22T21:57:31Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "As a workaround, we can try to leverage PS classes, instead of `Add-Type`",
      "created_at": "2016-12-01T21:12:33Z",
      "updated_at": "2016-12-01T21:12:33Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "Here is what I found, when decompiled the assembly generated by `Add-Type` vs `dotnet cli`.\r\n\r\nGetProxy() dotnet (good)\r\n------------------\r\n\r\n```\r\n.method private final hidebysig newslot virtual \r\n\tinstance class [System.Runtime]System.Uri System.Net.IWebProxy.GetProxy (\r\n\t\tclass [System.Runtime]System.Uri destination\r\n\t) cil managed \r\n{\r\n\t.override method instance class [System.Runtime]System.Uri [System.Net.Primitives]System.Net.IWebProxy::GetProxy(class [System.Runtime]System.Uri)\r\n\t// Method begins at RVA 0x2090\r\n\t// Code size 12 (0xc)\r\n\t.maxstack 1\r\n\t.locals init (\r\n\t\t[0] class [System.Runtime]System.Uri\r\n\t)\r\n\r\n\tIL_0000: nop\r\n\tIL_0001: ldarg.0\r\n\tIL_0002: ldfld class [System.Runtime]System.Uri Microsoft.PowerShell.Commands.PowerShellGet.InternalWebProxy::_proxyUri\r\n\tIL_0007: stloc.0\r\n\tIL_0008: br.s IL_000a\r\n\r\n\tIL_000a: ldloc.0\r\n\tIL_000b: ret\r\n} // end of method InternalWebProxy::System.Net.IWebProxy.GetProxy\r\n\r\n```\r\n\r\nGetProxy() Add-Type (bad)\r\n---------------------------\r\n\r\n```\r\n.method private final hidebysig newslot virtual \r\n\tinstance class [System.Private.Uri]System.Uri System.Net.IWebProxy.GetProxy (\r\n\t\tclass [System.Private.Uri]System.Uri destination\r\n\t) cil managed \r\n{\r\n\t.override method instance class [System.Private.Uri]System.Uri [System.Net.Primitives]System.Net.IWebProxy::GetProxy(class [System.Private.Uri]System.Uri)\r\n\t// Method begins at RVA 0x2090\r\n\t// Code size 12 (0xc)\r\n\t.maxstack 1\r\n\t.locals init (\r\n\t\t[0] class [System.Private.Uri]System.Uri\r\n\t)\r\n\r\n\tIL_0000: nop\r\n\tIL_0001: ldarg.0\r\n\tIL_0002: ldfld class [System.Private.Uri]System.Uri Microsoft.PowerShell.Commands.PowerShellGet.InternalWebProxy::_proxyUri\r\n\tIL_0007: stloc.0\r\n\tIL_0008: br.s IL_000a\r\n\r\n\tIL_000a: ldloc.0\r\n\tIL_000b: ret\r\n} // end of method InternalWebProxy::System.Net.IWebProxy.GetProxy\r\n\r\n```\r\n\r\n--------------------------------------------------------------\r\n\r\nThe only difference is that `System.Uri` lives in `System.Private.Uri` assembly (implementation assembly) and not in the reference assembly (System.Runtime)\r\n\r\nSince we currently don't ship reference assemblies together with PowerShell, we cannot make `Add-Type` compile against them.\r\n\r\nThat could potentially affect other inheritance cases.\r\nStill, it's not clear how to mitigate it and why it worked before and suddenly stopped now.\r\n\r\n@daxian-dbw can you follow-up about it with dotnet team, please?\r\n\r\n**Note**: the generated IL is the same in `alpha.11`, where `Add-Type` version works.\r\n\r\n**Note**: here is the IWebProxy disasm (also uses `System.Runtime`)\r\n\r\n```\r\n.class interface public auto ansi abstract System.Net.IWebProxy\r\n{\r\n\t// Methods\r\n\t.method public hidebysig newslot abstract virtual \r\n\t\tinstance class [System.Runtime]System.Uri GetProxy (\r\n\t\t\tclass [System.Runtime]System.Uri destination\r\n\t\t) cil managed \r\n\t{\r\n\t} // end of method IWebProxy::GetProxy\r\n\r\n\t.method public hidebysig newslot abstract virtual \r\n\t\tinstance bool IsBypassed (\r\n\t\t\tclass [System.Runtime]System.Uri host\r\n\t\t) cil managed \r\n\t{\r\n\t} // end of method IWebProxy::IsBypassed\r\n\r\n\t.method public hidebysig specialname newslot abstract virtual \r\n\t\tinstance class System.Net.ICredentials get_Credentials () cil managed \r\n\t{\r\n\t} // end of method IWebProxy::get_Credentials\r\n\r\n\t.method public hidebysig specialname newslot abstract virtual \r\n\t\tinstance void set_Credentials (\r\n\t\t\tclass System.Net.ICredentials 'value'\r\n\t\t) cil managed \r\n\t{\r\n\t} // end of method IWebProxy::set_Credentials\r\n\r\n\t// Properties\r\n\t.property instance class System.Net.ICredentials Credentials()\r\n\t{\r\n\t\t.get instance class System.Net.ICredentials System.Net.IWebProxy::get_Credentials()\r\n\t\t.set instance void System.Net.IWebProxy::set_Credentials(class System.Net.ICredentials)\r\n\t}\r\n\r\n} // end of class System.Net.IWebProxy\r\n\r\n```",
      "created_at": "2016-12-03T06:22:24Z",
      "updated_at": "2016-12-03T06:58:56Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "I verified that it's a **dotnet core** (not corefx) regression: if I copy-replace `System.Private.CoreLib.dll` in alpha.11 to the newer version, I get exactly the same errors.",
      "created_at": "2016-12-03T07:22:45Z",
      "updated_at": "2016-12-03T07:22:45Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "I just tried it on the latest build from master and it's gone. O_o\r\n\r\n```\r\nName                           Value                                                                                                   \r\n----                           -----                                                                                                  \r\nPSVersion                      6.0.0-alpha                                                                                            \r\nPSEdition                      Core                                                                                                   \r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}                                                                                \r\nBuildVersion                   3.0.0.0                                                                                                \r\nGitCommitId                    v6.0.0-alpha.13-25-g8abb6c3a94d304af0dd7611c865b1b2ec6460113                                           \r\nCLRVersion                                                                                                                            \r\nWSManStackVersion              3.0                                                                                                    \r\nPSRemotingProtocolVersion      2.3                                                                                                    \r\nSerializationVersion           1.1.0.1   \r\n```",
      "created_at": "2016-12-03T23:03:33Z",
      "updated_at": "2016-12-03T23:03:33Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "UPD: the error happens **only on `publish` builds**, that's what tricked me into believe that the problem is gone.",
      "created_at": "2016-12-03T23:10:33Z",
      "updated_at": "2016-12-03T23:22:11Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "I was trying to repro the problem outside the PowerShell context, but I could not. :(\r\nBoth `dotnet run` and `dotnet publish` are able to load the types from the assembly.\r\n\r\nMaybe somebody else may be able to do it.\r\n\r\n\r\nproject.json\r\n------------\r\n```json\r\n{\r\n    \"name\": \"webproxy\",\r\n    \"version\": \"1.0.0-*\",\r\n\r\n    \"buildOptions\": {\r\n        \"emitEntryPoint\": true\r\n    },\r\n\r\n    \"frameworks\": {\r\n        \"netcoreapp1.0\": {\r\n            \"dependencies\": {\r\n                \"System.Net.Primitives\": \"4.3.0-preview1-24530-04\",\r\n                \"Microsoft.NETCore.App\": \"1.1.0-preview1-001100-00\",\r\n                \"Microsoft.CodeAnalysis.CSharp\": \"1.3.1-beta1-20160616-03\",\r\n                \"System.Runtime.Loader\": \"4.3.0-preview1-24530-04\"\r\n            }\r\n        }\r\n    },\r\n\r\n    \"runtimes\": {\r\n        \"osx.10.11-x64\": { }\r\n    }\r\n}\r\n```\r\n\r\n\r\nProgram.cs\r\n-----------\r\n```csharp\r\nusing System; \r\nusing Microsoft.CodeAnalysis;\r\nusing Microsoft.CodeAnalysis.CSharp;\r\nusing System.Reflection;\r\nusing System.IO;\r\n\r\nclass Program\r\n{\r\n    static string PROGRAM = @\"\r\nusing System; \r\nusing System.Net;\r\n\r\nnamespace Microsoft.PowerShell.Commands.PowerShellGet \r\n{ \r\n    /// <summary>\r\n    /// Used by Ping-Endpoint function to supply webproxy to HttpClient\r\n    /// We cannot use System.Net.WebProxy because this is not available on CoreClr\r\n    /// </summary>\r\n    public class InternalWebProxy : IWebProxy\r\n    {\r\n        Uri _proxyUri;\r\n        ICredentials _credentials;\r\n\r\n        public InternalWebProxy(Uri uri, ICredentials credentials)\r\n        {\r\n            Credentials = credentials;\r\n            _proxyUri = uri;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Credentials used by WebProxy\r\n        /// </summary>\r\n        public ICredentials Credentials\r\n        {\r\n            get\r\n            {\r\n                return _credentials;\r\n            }\r\n            set\r\n            {\r\n                _credentials = value;\r\n            }\r\n        }\r\n\r\n        Uri IWebProxy.GetProxy(Uri destination)\r\n        {\r\n            return _proxyUri;\r\n        }\r\n\r\n        public bool IsBypassed(Uri host)\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\";\r\n\r\n    static void Main(string[] args)\r\n    {\r\n        string outputAssembly = args.Length > 0 ? args[0] : null;\r\n\r\n        var syntaxTree = CSharpSyntaxTree.ParseText(PROGRAM);\r\n        var references = new PortableExecutableReference[]\r\n        {\r\n            MetadataReference.CreateFromFile(Assembly.Load(new AssemblyName(\"System.Private.CoreLib\")).Location),\r\n            MetadataReference.CreateFromFile(Assembly.Load(new AssemblyName(\"System.Net.Primitives\")).Location),\r\n            MetadataReference.CreateFromFile(Assembly.Load(new AssemblyName(\"System.Private.Uri\")).Location),\r\n            MetadataReference.CreateFromFile(Assembly.Load(new AssemblyName(\"System.Runtime\")).Location),\r\n        };\r\n\r\n        foreach (var r in references)\r\n        {\r\n            Console.WriteLine(\"REFERENCE: \" + r.FilePath);\r\n        }\r\n\r\n        CSharpCompilation compilation = CSharpCompilation.Create(\r\n                System.IO.Path.GetRandomFileName(),\r\n                syntaxTrees: new[] { syntaxTree },\r\n                references: references,\r\n                options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));\r\n\r\n        if (outputAssembly != null)\r\n        {\r\n            var emitResult = compilation.Emit(outputAssembly);\r\n            Console.WriteLine(\"Assembly emitted in \" + outputAssembly);\r\n        }\r\n        else \r\n        {\r\n            using (var ms = new MemoryStream())\r\n            {\r\n                var emitResult = compilation.Emit(ms);\r\n\r\n                foreach (var d in emitResult.Diagnostics)\r\n                {\r\n                    Console.WriteLine(\"ERROR: \" + d.GetMessage());\r\n                }\r\n\r\n                if (emitResult.Success)\r\n                {\r\n                    ms.Flush();\r\n                    ms.Seek(0, SeekOrigin.Begin);\r\n                    \r\n                    var assembly = System.Runtime.Loader.AssemblyLoadContext.Default.LoadFromStream(ms);\r\n                    foreach (var type in assembly.ExportedTypes) {\r\n                        Console.WriteLine(\"Type \" + type.FullName);\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    Console.WriteLine(\"emitResult no success\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n```",
      "created_at": "2016-12-03T23:23:19Z",
      "updated_at": "2016-12-03T23:24:28Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "An update from @bmanikm: there were 2 `Add-Type` uses in `PowerShellGet` previously. Now he merged those 2 into one C# code snippet and use only one `Add-Type`, and `Add-Type` started to work even though the same `InternalWebProxy` implementation is used. So `PowerShellGet` is unblocked for now (at least for alpha.14 release), but this bug still stands.\r\n\r\n@bmanikm, please add more details if I miss anything.",
      "created_at": "2016-12-06T23:48:25Z",
      "updated_at": "2016-12-06T23:48:25Z"
    },
    {
      "author": "brywang-msft",
      "author_association": "NONE",
      "body": "Adding another repro. Fairly sure this is a dotnet core issue, but it could be a dotnet core fix exposing an Add-Type issue? As above, we've found the issue doesn't repro in alpha11. I copied all the dotnet core DLLs from alpha11 into alpha15, and the issue doesn't repro. I don't know how type forwarding manifests in disassemblers, but ildasm, at least, shows `[System.Private.Uri]System.Uri` in ProgTest.dll (compiled in alpha11 and alpha15) instead of `[System.Runtime]System.Uri` that's present in other disassembled assemblies (e.g. System.Net.Http.dll's HttpClient).\r\n\r\nSteps to reproduce\r\n------------------\r\nContents of Test.cs:\r\n```\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Net.Http;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace ConsoleApp1\r\n{\r\n    public class Test\r\n    {\r\n        public void Go()\r\n        {\r\n            HttpRequestMessage _httpRequest = new HttpRequestMessage();\r\n            _httpRequest.Method = new HttpMethod(\"POST\");\r\n            _httpRequest.RequestUri = new Uri(\"http://localhost:3000/cupcakes/chocolate\");\r\n        }\r\n    }\r\n}\r\n```\r\nIn PowerShell alpha15:\r\n```powershell\r\n$refs = @('System.Net.Http.dll','System.Private.Uri.dll','System.Runtime.dll')\r\n$content = get-content \"Test.cs\" | out-string\r\nwrite-verbose -message $content\r\nAdd-Type -TypeDefinition $content -ReferencedAssemblies $refs -OutputAssembly ProgTest.dll\r\nAdd-Type -Path .\\ProgTest.dll -PassThru\r\n$prog = New-Object ConsoleApp1.Test\r\n$prog.Go()\r\n```\r\n\r\nExpected behavior\r\n-----------------\r\nNo error from test script above\r\n\r\nActual behavior\r\n---------------\r\n```powershell\r\nException calling \"Go\" with \"0\" argument(s): \"Method not found: 'Void System.Net.Http.HttpRequestMessage.set_RequestUri(System.Uri)'.\"\r\nAt C:\\Program Files\\PowerShell\\6.0.0.15\\CompileProg.ps1:10 char:1\r\n+ $prog.Go()\r\n+ ~~~~~~~~~~\r\n    + CategoryInfo          : NotSpecified: (:) [], MethodInvocationException\r\n    + FullyQualifiedErrorId : MissingMethodException\r\n```",
      "created_at": "2017-02-03T01:40:06Z",
      "updated_at": "2017-02-03T01:40:06Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "Fixed via #3556:\r\n> Ship netcoreapp reference assemblies with powershell to fix the issues in Add-Type (#2764). By default Add-Type will reference all those reference assemblies when compiling C# code. If -ReferenceAssembly is specified, then we search reference assemblies first, then the framework runtime assemblies, and lastly the loaded assemblies (possibly a third-party one that was already loaded).",
      "created_at": "2017-04-17T19:14:30Z",
      "updated_at": "2017-04-17T19:14:30Z"
    }
  ],
  "created_at": "2016-11-22T20:00:23Z",
  "labels": [
    "Blocked",
    "WG-Cmdlets",
    "Resolution-Fixed"
  ],
  "number": 2764,
  "state": "closed",
  "title": "Add-Type failed to create a type that implements IWebProxy",
  "updated_at": "2017-04-17T19:14:30Z"
}