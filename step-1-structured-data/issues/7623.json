{
  "_url": "https://github.com/PowerShell/PowerShell/issues/7623",
  "author": "deathly809",
  "body": "<!--\r\n\r\nFor Windows PowerShell 5.1 issues, suggestions, or feature requests please use the following link instead:\r\n- Windows PowerShell [UserVoice](https://windowsserver.uservoice.com/forums/301869-powershell)\r\n\r\nIf it is a bug report:\r\n- make sure you are able to repro it on the latest released version. \r\nYou can install the latest version from https://github.com/PowerShell/PowerShell/releases\r\n- Search the existing issues.\r\n- Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\r\n- Refer to the [known issues](https://docs.microsoft.com/powershell/scripting/whats-new/known-issues-ps6?view=powershell-6).\r\n- Fill out the following repro template:\r\n\r\nIf it's not a bug, please remove the template and elaborate the issue in your own words.\r\n-->\r\n\r\nWhen running a script using Invoke-Command I call a program which prints to the error stream.  I have piped the error stream to the stdout and then Out-Null for the command I call and also set the ErrorAction to SilentlyContinue for Invoke-Command.  The exception is still propagated.  \r\n\r\n\r\nSteps to reproduce\r\n------------------\r\n\r\nUsing the following files,\r\n\r\n[error.ps1.txt](https://github.com/PowerShell/PowerShell/files/2315989/error.ps1.txt)\r\n[cradle.ps1.txt](https://github.com/PowerShell/PowerShell/files/2315990/cradle.ps1.txt)\r\n\r\n\r\n```powershell\r\n.\\cradle.ps1\r\n```\r\n\r\nExpected behavior\r\n-----------------\r\n\r\n```none\r\nRunning\r\nBefore\r\nAfter\r\nFinished\r\n```\r\n\r\nActual behavior\r\n---------------\r\n\r\n```none\r\nRunning\r\n\r\nIsPublic IsSerial Name                                     BaseType\r\n-------- -------- ----                                     --------\r\nTrue     False    CmdletBindingAttribute                   System.Management.Automation.CmdletCommonMetadataAttribute\r\nBefore\r\nThere was an error\r\n\r\n\r\n\r\n\r\nPSMessageDetails      :\r\nException             : System.Management.Automation.RemoteException: '1' is not recognized as an internal or external\r\n                        command,\r\nTargetObject          : '1' is not recognized as an internal or external command,\r\nCategoryInfo          : NotSpecified: ('1' is not reco...ternal command,:String) [], RemoteException\r\nFullyQualifiedErrorId : NativeCommandError\r\nErrorDetails          :\r\nInvocationInfo        : System.Management.Automation.InvocationInfo\r\nScriptStackTrace      : at <ScriptBlock>, C:\\Users\\Administrator.N22R1003-DVM\\Desktop\\Terasort\\Error\\error.ps1: line 7\r\n                        at DoIt, C:\\Users\\Administrator.N22R1003-DVM\\Desktop\\Terasort\\Error\\error.ps1: line 6\r\n                        at <ScriptBlock>, C:\\Users\\Administrator.N22R1003-DVM\\Desktop\\Terasort\\Error\\cradle.ps1: line\r\n                        10\r\n                        at <ScriptBlock>, <No file>: line 1\r\nPipelineIterationInfo : {}\r\n\r\n\r\n\r\nFinished\r\n```\r\n\r\nEnvironment data\r\n----------------\r\n\r\n<!-- provide the output of $PSVersionTable -->\r\n\r\n```powershell\r\n> $PSVersionTable\r\nName                           Value\r\n----                           -----\r\nPSVersion                      5.1.14393.2395\r\nPSEdition                      Desktop\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}\r\nBuildVersion                   10.0.14393.2395\r\nCLRVersion                     4.0.30319.42000\r\nWSManStackVersion              3.0\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\n```\r\n",
  "closed_at": "2018-08-26T20:04:44Z",
  "comments": [
    {
      "author": "MaximoTrinidad",
      "author_association": "NONE",
      "body": "First, you need to try it on PowerShell Core, as this is only for PowerShell Core issues.  So, for Windows PowerShell issues, use Uservoice at: https://windowsserver.uservoice.com/forums/301869-powershell \r\n\r\nOverall, this type of exception can only be handle using the try/catch.  \r\n\r\nIn order to reproduce in PowerShell Core, we need better steps. We don't know what commands are executing in \"Cradle.ps1\" script file.\r\n\r\nKeep in mind, Microsoft efforts are to move forward with PowerShell Core.\r\n\r\n:)\r\n\r\n",
      "created_at": "2018-08-23T21:13:10Z",
      "updated_at": "2018-08-23T21:13:10Z"
    },
    {
      "author": "deathly809",
      "author_association": "NONE",
      "body": "You cannot tell what is in a text file?  I am very confused.  Have you tried notepad?  \r\n\r\nTo help I have opened the files in notepad and copied the text files here.\r\n\r\n```\r\n#cradle.ps1\r\n\r\n# Set the error action to Stop\r\n$ErrorActionPreferenceOld = $ErrorActionPreference\r\n$ErrorActionPreference = \"Stop\"\r\n\r\n. .\\error.ps1\r\n\r\ntry {\r\n     Write-Host \"Running\"\r\n     DoIt\r\n} catch {\r\n    Write-Host \"There was an error\"\r\n    Format-list * -InputObject $_ -Force\r\n} finally {\r\n     Write-Host \"Finished\"\r\n     $ErrorActionPreference = $ErrorActionPreferenceOld\r\n}\r\n```\r\n\r\n```\r\n#error.ps1\r\n\r\nfunction DoIt {\r\n    [CmdletBinding]\r\n    Write-Host \"Before\"\r\n    # Perform action which prints to error stream\r\n    Invoke-Command -Script {\r\n        & cmd.exe /k \"echo 'test' 1&>2\" *>1 | Out-Null\r\n    } -ErrorAction SilentlyContinue | Out-Null -ErrorAction SilentlyContinue\r\n    Write-Host \"After\"\r\n}\r\n```\r\n\r\nJust in case you are confused you will need to copy AND paste these into the following files and please read the first line of the code as those correspond to the files that you need to copy and paste into,\r\n\r\n```\r\ncradle.ps1\r\nerror.ps1\r\n```\r\n\r\nthen at the command line please type,\r\n\r\n```\r\n.\\cradle.ps1\r\n```\r\n\r\nPlease let me know if that was not clear.  \r\n\r\n\r\nI have also tried in a try catch and it still throws in my real script and not this toy example and it still fails.\r\n\r\nI reproduced it in PowerShell Core, here is the version I have.  I will also file a bug with the PowerShell team.\r\n\r\n```\r\nName                           Value\r\n----                           -----\r\nPSVersion                      6.1.0-preview.4\r\nPSEdition                      Core\r\nGitCommitId                    6.1.0-preview.4\r\nOS                             Microsoft Windows 10.0.17134\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n",
      "created_at": "2018-08-23T21:42:40Z",
      "updated_at": "2018-08-23T21:42:40Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "Here's a reduced version of the code with just the relevant bits.\r\n```powershell\r\n$ErrorActionPreference=\"silentlycontinue\"\r\nInvoke-Command -Script {\r\n        & cmd.exe /c 1 *>1 | Out-Null\r\n} -ErrorAction SilentlyContinue\r\n```\r\nThis will indeed generate a error despite setting `-ErrorAction` on `Invoke-Command`. This is because `$ErrorActionPreference` is set to `Stop`. The preference variable is the ambient setting for all commands vs. the `-ErrorAction` parameter that controls the behaviour for a specific command. This means that when cmd.exe is executed, it's error action will be `Stop` causing an exception to be thrown. As @MaximoTrinidad points out, you could capture that exception with `try/catch`. On the other hand, you could change the setting of `$ErrorActionPreference` to be something other than `Stop`. You could even set it inside the `Invoke-Command` scriptblock so it's local to that block:\r\n```powershell\r\n$ErrorActionPreference=\"stop\"\r\nInvoke-Command -Script {\r\n\t$ErrorActionPreference=\"silentlycontinue\"\r\n        & cmd.exe /c 1 *>1 | Out-Null\r\n} -ErrorAction SilentlyContinue\r\n```\r\nUltimately there is no PowerShell bug here - everything is working as intended - however I'd encourage you to look at your overall error handling approach since you appear to have conflicting preferences. ",
      "created_at": "2018-08-23T21:46:32Z",
      "updated_at": "2018-08-23T21:46:32Z"
    },
    {
      "author": "MaximoTrinidad",
      "author_association": "NONE",
      "body": "Ah! Apologoies @deathly809 !!  \r\n\r\nI didn't notice you included other files.  Hehe!!\r\n\r\nThanks BruceP for assisting!! ",
      "created_at": "2018-08-23T21:49:15Z",
      "updated_at": "2018-08-23T21:49:15Z"
    },
    {
      "author": "deathly809",
      "author_association": "NONE",
      "body": "Hmmm, I will override the setting and see what happens.  Hopefully that fixes it.  Thanks!",
      "created_at": "2018-08-23T22:08:57Z",
      "updated_at": "2018-08-23T22:08:57Z"
    },
    {
      "author": "fatherofinvention",
      "author_association": "NONE",
      "body": "Hey guys, this does not seem to be fixed. Is this by design? Invoke-Command does not respect -ErrorAction parameter which means it cannot be suppressed using SilentlyContinue nor can it be trapped using aTry..Catch block.\r\n\r\nThis issue is present in both WinPS and PowerShell Core. Does not seem like intended behavior since the $Error[0] variable and $ResolutionError ErrorVariable are set by PowerShell outside of the scriptblock.\r\n\r\n`Invoke-Command -ScriptBlock { Get-Content c:\\file\\does\\not\\exist.txt } -ErrorAction SilentlyContinue -ErrorVariable ResolutionError`",
      "created_at": "2019-05-08T18:41:55Z",
      "updated_at": "2019-05-08T18:41:55Z"
    },
    {
      "author": "hallipr",
      "author_association": "NONE",
      "body": "For anyone else still seeing this, ErrorAction on Invoke-Command doesn't affect the error action inside the block you pass to Invoke-Command, just the error action for Invoke-Command and its logic.\r\n\r\nIf you're passing a ScriptBlock into a function in another context, $ErrorActionPrefence inside the script block will not be affected by $ErrorActionPreference in the function that invokes the script block.  $ErrorActionPreference appears to behave like any other scoped variable, so changing it in the calling function doesn't affect the value captured by the script block.\r\n\r\n### With ExecuteBlock defined in the script \r\n``` powershell\r\nfunction ExecuteBlock([ScriptBlock]$ScriptBlock) {\r\n    Write-Host \"  ExecuteBlock start: $ErrorActionPreference\"\r\n    \r\n    $ErrorActionPreference = \"Continue\"\r\n    Write-Host \"  ExecuteBlock set: $ErrorActionPreference\"\r\n    \r\n    Invoke-Command -ScriptBlock $ScriptBlock\r\n    Write-Host \"  ExecuteBlock end: $ErrorActionPreference\"\r\n}\r\n\r\nWrite-Host \"Script start: $ErrorActionPreference\"\r\n\r\nExecuteBlock { Write-Host \"    ScriptBlock: $ErrorActionPreference\" }\r\n\r\nWrite-Host \"Script end: $ErrorActionPreference\"\r\n```\r\n\r\n```\r\nScript start: Stop\r\n  ExecuteBlock start: Stop\r\n  ExecuteBlock set: Continue\r\n    ScriptBlock: Continue\r\n  ExecuteBlock end: Continue\r\nScript end: Stop\r\n```\r\n\r\n### With ExecuteBlock defined in a module.\r\n``` powershell\r\nfunction ExecuteBlock([ScriptBlock]$ScriptBlock) {\r\n    Write-Host \"  ExecuteBlock start: $ErrorActionPreference\"\r\n    \r\n    $ErrorActionPreference = \"Continue\"\r\n    Write-Host \"  ExecuteBlock set: $ErrorActionPreference\"\r\n    \r\n    Invoke-Command -ScriptBlock $ScriptBlock\r\n    Write-Host \"  ExecuteBlock end: $ErrorActionPreference\"\r\n}\r\n\r\nExport-ModuleMember -Alias * -Function *\r\n```\r\n\r\n``` powershell\r\nImport-Module .\\helpers.psm1 -Force\r\n\r\nWrite-Host \"Script start: $ErrorActionPreference\"\r\n\r\nExecuteBlock { Write-Host \"    ScriptBlock: $ErrorActionPreference\" }\r\n\r\nWrite-Host \"Script end: $ErrorActionPreference\"\r\n```\r\n\r\n```\r\nScript start: Stop\r\n  ExecuteBlock start: Stop\r\n  ExecuteBlock set: Continue\r\n    ScriptBlock: Stop\r\n  ExecuteBlock end: Continue\r\nScript end: Stop\r\n```\r\n\r\nThe module example proves that setting $ErrorActionPreference before calling Invoke-Command will only affect the ErrorActionPreference in the script block if the script block and the invocation are in the same scope.\r\n\r\n### Using InvokeWithContext\r\nTo invoke a script block from another scope while altering its ErrorActionPreference, you can call InvokeWithContext on the ScriptBlock\r\n\r\n``` powershell\r\nfunction ExecuteBlock([ScriptBlock]$ScriptBlock) {\r\n    Write-Host \"  ExecuteBlock start: $ErrorActionPreference\"\r\n\r\n    $ScriptBlock.InvokeWithContext($null, @([PSVariable]::new('ErrorActionPreference', 'Continue')))\r\n    \r\n    Write-Host \"  ExecuteBlock end: $ErrorActionPreference\"\r\n}\r\n```\r\n\r\n```\r\nScript start: Stop\r\n  ExecuteBlock start: Stop\r\n    ScriptBlock: Continue\r\n  ExecuteBlock end: Stop\r\nScript end: Stop\r\n```\r\n\r\n## Summing Up\r\n\r\n``` powershell\r\nfunction ExecuteBlock([ScriptBlock]$ScriptBlock) {\r\n    $ScriptBlock.InvokeWithContext($null, @([PSVariable]::new('ErrorActionPreference', 'Continue')))\r\n    Write-Host \"ExecuteBlock `$? = $?\"\r\n    Write-Host \"ExecuteBlock `$LASTEXITCODE = $LASTEXITCODE\"\r\n}\r\n\r\nExport-ModuleMember -Alias * -Function *\r\n```\r\n\r\n``` powershell\r\nImport-Module .\\helpers.psm1 -Force\r\n\r\nExecuteBlock { & cmd.exe /c \"1\" *>&1 }\r\n\r\nWrite-Host \"Script `$?: $?\"\r\n```\r\n\r\n```\r\n'1' is not recognized as an internal or external command,\r\noperable program or batch file.\r\nExecuteBlock $? = True\r\nExecuteBlock $LASTEXITCODE = 1\r\nScript $?: True\r\n```\r\n\r\nThere is a downside to InvokeWithContext.  While it lets you fix up the script blocks closure with variable and function replacements, the $? (completion success) variable appears to apply to InvokeWithContext's processing of the script block, not the success of the last command in the script block.\r\n\r\nhttps://docs.microsoft.com/en-us/dotnet/api/system.management.automation.scriptblock.invokewithcontext?view=powershellsdk-7.0.0\r\n\r\n<blockquote><img src=\"https://docs.microsoft.com/en-us/media/logos/logo-ms-social.png\" width=\"48\" align=\"right\"><div><strong><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.scriptblock.invokewithcontext\">ScriptBlock.InvokeWithContext Method (System.Management.Automation)</a></strong></div><div>A method that allows a scriptblock to be invoked with additional context in the form of a set of local functions and variables to be defined in the scriptblock's scope. The list of variables may include the special variables $input, $_ and $this. </div></blockquote>",
      "created_at": "2021-05-13T22:19:05Z",
      "updated_at": "2021-05-14T03:19:20Z"
    }
  ],
  "created_at": "2018-08-23T20:10:58Z",
  "labels": [
    "Issue-Question",
    "WG-Engine",
    "Resolution-Answered"
  ],
  "number": 7623,
  "state": "closed",
  "title": "Invoke-Command with ErrorAction SilentlyContinue still throws Exception",
  "updated_at": "2021-05-14T03:19:20Z"
}