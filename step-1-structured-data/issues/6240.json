{
  "_url": "https://github.com/PowerShell/PowerShell/issues/6240",
  "author": "powercode",
  "body": "## PR Summary\r\n\r\nThis codifies the  most common patterns encountered when writing argument completers in  an easy-to-use base class.\r\n\r\n* Complete if a text is starting with the word to complete\r\n* Complete if a text contains the word to complete\r\n* Complete if any of the text, listItem or tooltip starts with the word to complete\r\n* Complete if any of the text, listItem or tooltip contains the word to complete\r\n\r\nIt also quotes text with space in the completionText.\r\n\r\nFinally it provodes a slightly less intimidating interface to override by having the AST as a member, \r\nhence not visible in the \r\n\r\nThe interface for the consumer is \r\n\r\n```csharp\r\npublic abstract class ArgumentCompleterBase : IArgumentCompleter \r\n{\r\n    protected string WordToComplete { get; private set; }\r\n    protected CommandAst CommandAst { get; private set; }\r\n    protected abstract void AddCompletionsFor(string commandName, string parameterName, IDictionary fakeBoundParameters);\r\n    protected void CompleteWith(CompletionResult completionResult);\r\n    protected void CompleteWith(string text, string listItemText = null, \r\n            string toolTip = null,  CompletionResultType resultType = CompletionResultType.ParameterValue);\r\n    protected void CompleteWithIfTextStartsWithWordToComplete(string text, string listItemText = null,\r\n            string toolTip = null, CompletionResultType resultType = CompletionResultType.ParameterValue);\r\n     protected void CompleteWithIfAnyStartsWithWordToComplete(string text, string listItemText = null,\r\n            string toolTip = null, CompletionResultType resultType = CompletionResultType.ParameterValue);\r\n    protected void CompleteWithIfAnyContainsWordToComplete(string text, string listItemText = null,\r\n            string toolTip = null, CompletionResultType resultType = CompletionResultType.ParameterValue);\r\n    protected void CompleteWithIfTextContainsWordToComplete(string text, string listItemText = null,\r\n            string toolTip = null, CompletionResultType resultType = CompletionResultType.ParameterValue);\r\n    protected bool StartWithWordToComplete(string text);\r\n    protected bool StartWithWordToComplete(string text, StringComparison stringComparison);\r\n    protected bool ContainsWordToComplete(string text);\r\n    protected bool ContainsWordToComplete(string text, StringComparison stringComparison);\r\n}\r\n```\r\nIn PowerShell, a consumer of the base class can do the following:\r\n\r\n```powershell\r\nclass CustomArgumentCompleter : System.Management.Automation.ArgumentCompleterBase {\r\n    # override\r\n    [void] AddCompletionsFor([string] $commandName, [string] $parameterName, [Collections.IDictionary] $fakeBoundParameters) {\r\n        switch (\"${commandName}:$parameterName\") {\r\n            # handle completion based on both command and parameter name\r\n            \"Verb-Noun:ParamName\" { $this.CompleteVerbNounParam($fakeBoundParameters); break }\r\n            #\r\n            #  Add one switch clases for each parameter with generic completion\r\n            #\r\n\r\n            default {\r\n                # handle generic parameter completion\r\n                switch ($parameterName) {\r\n                    \"ParameterName\" { $this.CompleteParameterName($fakeBoundParameters); break}\r\n                    #\r\n                    #  Add one switch clases for each parameter with generic completion\r\n                    #\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    [void] CompleteVerbNounParam([Collections.IDictionary] $fakeBoundParameter) {\r\n        # complete with \"completiontext\" if wordToComplete is anywhere in \"completiontext\"\r\n        #$this.CompleteWithIfTextContainsWordToComplete(\"completiontext\")\r\n    }\r\n\r\n    [void] CompleteParameterName([Collections.IDictionary] $fakeBoundParameter) {\r\n        # complete some ParameterNames that starts with wordToComplete\r\n        #$this.CompleteWithIfStartsWithWordToComplete(\"Some ParameterName\")\r\n    }\r\n}\r\n```\r\n\r\nThis is both easy describe, as it follows a clear pattern, and \r\n\r\n## PR Checklist\r\n\r\n- [x] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [x] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] [Change is not breaking](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)\r\n- [x] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` to the beginning of the title and remove the prefix when the PR is ready.\r\n- **User-facing changes**\r\n    - [ ] Not Applicable\r\n    - **OR**\r\n    - [x] User-facing [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [ ] Issue filed - Issue link:\r\n- **Testing - New and feature**\r\n    - [ ] Not Applicable or can only be tested interactively\r\n    - **OR**\r\n    - [x] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n        - [ ] [Add `[feature]` if the change is significant or affects feature tests](https://github.com/PowerShell/PowerShell/blob/master/docs/testing-guidelines/testing-guidelines.md#requesting-additional-tests-for-a-pr)\r\n",
  "closed_at": "2018-04-23T16:48:32Z",
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@powercode Please correct PR description - it seems you lost something after \"This is both easy describe, as it follows a clear pattern, and\".",
      "created_at": "2018-02-25T17:39:32Z",
      "updated_at": "2018-02-25T17:39:32Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@SteveL-MSFT We need PowerShell Committee conclusion about public API in the PR.",
      "created_at": "2018-02-25T17:49:27Z",
      "updated_at": "2018-02-25T17:49:27Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "Summary of  @PowerShell/powershell-committee discussion on this: we all *love* this in concept, and think that it generally looks sound, but we also know that none of us have real expertise on argument completers. This is relatively small, so we don't feel like kicking it out to the RFC process, but we'd all feel a lot more comfortable if it had some bake time for feedback. \r\n\r\nSpecifically, it would be great if folks have written a lot of argument completers to provide their feedback. Off the top of my head, @lzybkr knows a ton here (not least of which because of PSReadline), and I know both @dahlbyk and @LeoColomb work on posh-git. Probably @rkeithhill has some experience in this space as well? It'd be great to hear from you all to make sure  we get the details right here. ",
      "created_at": "2018-02-28T23:24:28Z",
      "updated_at": "2018-02-28T23:24:28Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "Something that could be discussed is if we should provide helpers for writing completers for native commands too. This PR only targets parameters on cmdlets/functions, but there are common patterns there too.\r\n\r\nFor native commands, you quite often you have to find the previous item and understand if it is a flag, a parameter or a subcommand.\r\n\r\nIt is considerably more difficult to write good completers for complex native executables than it is for powershell parameters, so some helpers would be very valuable there too.\r\n",
      "created_at": "2018-03-01T12:50:18Z",
      "updated_at": "2018-03-01T12:51:57Z"
    },
    {
      "author": "dahlbyk",
      "author_association": "NONE",
      "body": "> Something that could be discussed is if we should provide helpers for writing completers for native commands too. This PR only targets parameters on cmdlets/functions, but there are common patterns there too.\r\n> \r\n> For native commands, you quite often you have to find the previous item and understand if it is a flag, a parameter or a subcommand.\r\n> \r\n> It is considerably more difficult to write good completers for complex native executables than it is for powershell parameters, so some helpers would be very valuable there too.\r\n\r\nI missed this since I first saw the issue last night, but I agree. I mentioned it earlier, but `--` handling is just one of a handful of complicating factors for posh-git:\r\n\r\n- Nearly all (but not all - shout out to `git filter-branch`) commands treat anything after ` -- ` as a file path\r\n- Git aliases need to be parsed to determined which command we're actually doing expansion for\r\n- Expanding a remote name (e.g. `origin`) might be just the origin name, or it might be part of a branch reference (e.g. `origin/master`) depending on context\r\n- When completing file paths, we sometimes give preference to paths relevant to the command (e.g. `git add <tab>` expands paths that have been modified)\r\n- I'm not sure how PowerShell completers handle command arguments aliases (`--patch` / `-p`)",
      "created_at": "2018-03-01T16:23:42Z",
      "updated_at": "2018-03-01T16:23:42Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "To be fair, I think we can see a couple of different use cases with completion. Git is in one extreme, with a very complicated command line interface. Others provide more regularity. A lot of the logic to parse git commands will be custom, but I am more on the chase for helpers that would make that task easier.\r\n",
      "created_at": "2018-03-01T17:06:18Z",
      "updated_at": "2018-03-01T17:06:18Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "It's worth point folks to my stab at making native completers easier to write [here](https://github.com/lzybkr/TabExpansionPlusPlus/blob/master/WindowsExe.ArgumentCompleters.ps1) - the `net.exe` example is similar to what I could see for `git`.",
      "created_at": "2018-03-01T17:18:16Z",
      "updated_at": "2018-03-01T17:18:16Z"
    },
    {
      "author": "dahlbyk",
      "author_association": "NONE",
      "body": "> You cannot use this base class for the git completer. It is not intended as such\r\n\r\nIn that case, ignore my Git/native-specific feedback in the context of this particular PR. \ud83d\ude00\r\n\r\n@powercode glad to participate in a discussion about how we can make native parsers easier to write. There's a bit of overlap (e.g. collecting `Results`, the `StartWithWordToComplete`/`ContainsWordToComplete` helpers), but perhaps not enough to try to share any code.\r\n\r\n> One thing that Would be nice in such a case is some built in support for testing.\r\n\r\nWe have some infrastructure to mock `git` results for a given command, but it would be great to be able to test tab expansion in isolation.",
      "created_at": "2018-03-01T17:23:23Z",
      "updated_at": "2018-03-01T17:23:23Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@powercode I think native command completion is definitely something we want to support and making it easier for the community to author completers for popular native commands on Windows/Linux would be awesome",
      "created_at": "2018-03-01T19:35:31Z",
      "updated_at": "2018-03-01T19:35:31Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "I've started prototyping and testing it out on previous completers I've written.",
      "created_at": "2018-03-01T19:43:42Z",
      "updated_at": "2018-03-01T19:44:21Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "@lzybkr I have looked at your completion tree before, and I really like the idea! I would like to have them being lazy, so we don't allocate when we don't have to.\r\n\r\nAnd if memory serves me right, I had problems with not having `conflicts_with` in the command tree.\r\n\r\nAny idea how to get that concept in?\r\n",
      "created_at": "2018-03-01T19:48:34Z",
      "updated_at": "2018-03-01T20:04:02Z"
    },
    {
      "author": "stale[bot]",
      "author_association": "NONE",
      "body": "This PR has been automatically marked as stale because it has not had activity in the last 30 days. It will be closed if no further activity occurs within 10 days.\nThank you for your contributions.\nCommunity members are welcome to grab these works.\n",
      "created_at": "2018-04-13T16:35:40Z",
      "updated_at": "2018-04-13T16:35:40Z"
    },
    {
      "author": "stale[bot]",
      "author_association": "NONE",
      "body": "This PR has be automatically close because it is stale. If you wish to continue working on the PR, please first update the PR, then reopen it.\nThanks again for your contribution.\nCommunity members are welcome to grab these works.\n",
      "created_at": "2018-04-23T16:48:28Z",
      "updated_at": "2018-04-23T16:48:28Z"
    }
  ],
  "created_at": "2018-02-25T15:06:51Z",
  "number": 6240,
  "state": "closed",
  "title": "WIP: Adding base class for custom argument completers",
  "updated_at": "2018-08-16T18:17:22Z"
}