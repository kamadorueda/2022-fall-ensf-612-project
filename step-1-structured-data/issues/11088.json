{
  "_url": "https://github.com/PowerShell/PowerShell/issues/11088",
  "author": "daxian-dbw",
  "body": "<!-- Anything that looks like this is a comment and can't be seen after the Pull Request is created. -->\r\n\r\n# PR Summary\r\n\r\nIn .NET Core 2.1, `[System.AppDomain]::CurrentDomain.GetAssemblies()` only returns the assemblies loaded in the default load context.\r\nIn .NET Core 3.0, `[System.AppDomain]::CurrentDomain.GetAssemblies()` is changed to return all assemblies loaded in the `AppDomain`, including the assemblies loaded into other AssemblyLoadContext (ALC) instances.\r\nThis results in our type resolution to behave inconsistently:\r\n - for assembly-name-fully-qualified type name, powershell cannot resolve a type when the assembly is loaded in a separate ALC.\r\n - for fully-qualified type name (without assembly name part), when 2 versions of the same assembly get loaded in two ALC, powershell will resolve the type to the first assembly that got loaded. This behavior is close to undefined because sometimes you cannot control the order of loading.\r\n\r\nThis PR changes to use `AssemblyLoadContext.Default.Assemblies` (new API added in .NET Core 3) to make sure assemblies loaded in other ALC are invisible to PowerShell type resolution.\r\n\r\n## PR Context\r\n\r\n<!-- Provide a little reasoning as to why this Pull Request helps and why you have opened it. -->\r\n\r\n## PR Checklist\r\n\r\n- [x] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [x] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` or `[ WIP ]` to the beginning of the title (the `WIP` bot will keep its status check at `Pending` while the prefix is present) and remove the prefix when the PR is ready.\r\n- **[Breaking changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)**\r\n    - [x] None\r\n    - **OR**\r\n    - [ ] [Experimental feature(s) needed](https://github.com/MicrosoftDocs/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/About/about_Experimental_Features.md)\r\n        - [ ] Experimental feature name(s): <!-- Experimental feature name(s) here -->\r\n- **User-facing changes**\r\n    - [x] Not Applicable\r\n    - **OR**\r\n    - [ ] [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n- **Testing - New and feature**\r\n    - [ ] N/A or can only be tested interactively\r\n    - **OR**\r\n    - [x] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n- **Tooling**\r\n    - [x] I have considered the user experience from a tooling perspective and don't believe tooling will be impacted.\r\n    - **OR**\r\n    - [ ] I have considered the user experience from a tooling perspective and enumerated concerns in the summary. This may include:\r\n        - Impact on [PowerShell Editor Services](https://github.com/PowerShell/PowerShellEditorServices) which is used in the [PowerShell extension](https://github.com/PowerShell/vscode-powershell) for VSCode (which runs in a different PS Host).\r\n        - Impact on Completions (both in the console and in editors) - one of PowerShell's most powerful features.\r\n        - Impact on [PSScriptAnalyzer](https://github.com/PowerShell/PSScriptAnalyzer) (which provides linting & formatting in the editor extensions).\r\n        - Impact on [EditorSyntax](https://github.com/PowerShell/EditorSyntax) (which provides syntax highlighting with in VSCode, GitHub, and many other editors).\r\n",
  "closed_at": "2019-11-26T20:40:17Z",
  "comments": [
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": ":tada:`v7.0.0-rc.3` has been released which incorporates this pull request.:tada:\n\nHandy links:\n* [Release Notes](https://github.com/PowerShell/PowerShell/releases/tag/v7.0.0-rc.3)\n",
      "created_at": "2020-02-21T23:55:24Z",
      "updated_at": "2020-02-21T23:55:24Z"
    },
    {
      "author": "stevenebutler",
      "author_association": "NONE",
      "body": "This PR prevents PowerShell from finding types in assemblies loaded from memory using\r\n```\r\n[System.Reflection.Assembly]::Load($bytes)\r\n```\r\nThis has worked in PowerShell 5.1, and PowerShell 7 up to rc2 but doesn't work in rc3.\r\n\r\nA workaround for PowerShell 7 rc3 is to use \r\n```\r\n# $ms is a MemoryStream containing the assembly bytes above\r\n[System.Runtime.Loader.AssemblyLoadContext]::Default.LoadFromStream($ms)\r\n```\r\nHowever the above code is not compatible with PowerShell 5.1 as the type doesn't exist.",
      "created_at": "2020-03-03T22:36:19Z",
      "updated_at": "2020-03-03T22:36:19Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "Are you able to expand on your scenario for using that API? I haven't seen any use cases in .NET Framework for loading an assembly from bytes other than to get around assembly resolution issues, which .NET Core has effectively resolved with the addition of assembly load contexts.\r\n\r\nReally this change is us catching up to deeper changes in .NET assembly handling, and given that these changes have occurred in the platform and something fundamentally different is happening (i.e. the loaded assembly really isn't in the current load context), it's probably appropriate to handle the loading differently on different platforms:\r\n\r\n```powershell\r\nif ($PSVersionTable.PSVersion.Major -ge 7)\r\n{\r\n    $ms = ...\r\n    [System.Runtime.Loader.AssemblyLoadContext]::Default.LoadFromStream($ms)\r\n}\r\nelse\r\n{\r\n    [System.Reflection.Assembly]::Load($bytes)\r\n}\r\n```",
      "created_at": "2020-03-03T22:53:48Z",
      "updated_at": "2020-03-03T22:53:48Z"
    },
    {
      "author": "stevenebutler",
      "author_association": "NONE",
      "body": "The core use case is when you don't want the DLL to be locked on the file system in Windows, preventing rebuilds/reinstalls etc.\r\n\r\nI typically load my more complex DLLs using add-type, but I have a native interop DLL that checks file locking status on startup and handles upgrading of assemblies and native DLLs by inspecting the install folder for locked files. I don't want loading this DLL to also cause file locking so I load it from memory - it has no external dependencies so this works fine.\r\n\r\nI used something like the above code, but I tested for the presence of the AssemblyLoadContext type, rather than tying it to the PSVersion.",
      "created_at": "2020-03-03T23:04:21Z",
      "updated_at": "2020-03-03T23:09:19Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> The core use case is when you don't want the DLL to be locked on the file system in Windows\r\n\r\nYes, this is something an ALC can solve today, since they [can be collectible/unloadable](https://docs.microsoft.com/en-us/dotnet/standard/assembly/unloadability). Meaning the strategy for handling the problem will probably change significantly moving into the future.\r\n\r\nWe've been discussing how best to support this going forward and there's no simple solution available by default in PowerShell yet, but it's certainly an area of interest.",
      "created_at": "2020-03-03T23:41:59Z",
      "updated_at": "2020-03-03T23:41:59Z"
    },
    {
      "author": "stevenebutler",
      "author_association": "NONE",
      "body": "I don't think being able to unload from a specific PowerShell will solve my issue, which is users may have multiple PowerShell windows open, each of which would have locked the DLLs when they upgrade. I currently resolve it by checking for locked files and creating a new sequence number folder for the new version of DLLs on upgrade, which is what the in-memory DLL helps with.\r\n\r\nMost of my users are on PS 5.1 as well, but I'm on both.",
      "created_at": "2020-03-03T23:46:54Z",
      "updated_at": "2020-03-03T23:50:00Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@stevenebutler Please open new issue with _repo steps_.\r\n\r\n> \\[System.Reflection.Assembly]::Load($bytes)\r\n\r\nIt is not PowerShell, it is .Net Core method. You could create simple C# application and check with different .Net Core 3 versions.",
      "created_at": "2020-03-04T12:39:01Z",
      "updated_at": "2020-03-04T12:44:41Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> It is not PowerShell, it is .Net Core method.\r\n\r\nThe preliminary issue is that PowerShell stopped resolving types outside the default ALC with the changes in this PR.\r\n\r\nHowever, Assembly.Load effectively made a breaking change first, since it loads byte assemblies into an anonymous ALC.\r\n\r\nGiven that ALCs are designed partially to replace AppDomains, I think not resolving from them is the right way to go (and I should note that fully qualified names still work).",
      "created_at": "2020-03-04T14:13:57Z",
      "updated_at": "2020-03-04T14:13:57Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@rjmholt Thanks! In the case I see another additional problem https://source.dot.net/#System.Private.CoreLib/Assembly.cs,242\n\n<blockquote><div><strong><a href=\"https://source.dot.net/#System.Private.CoreLib/Assembly.cs,242\">Source Browser</a></strong></div></blockquote>",
      "created_at": "2020-03-04T15:48:08Z",
      "updated_at": "2020-03-04T15:48:11Z"
    },
    {
      "author": "stevenebutler",
      "author_association": "NONE",
      "body": "I'm not sure I want to create an issue for this as I understand this area is changing and PowerShell has to adapt. It's obviously a change in behaviour that may break existing code, so I wanted to let people know how they could adapt. I am happy with the change I have made and don't have any issues with it now.\r\n\r\nIn case anyone does feel strongly about this and wants to raise an issue with a repro, the below pester test will repro the issue (fail) on PowerShell 7.0.0 rc3 (and release), but will pass on versions prior.\r\n\r\nFor completeness, I have included a second test that shows how to load types from memory in PowerShell, which passes on PowerShell 7.0.0rc3 and above..\r\n\r\n```powershell\r\nimport-module Pester\r\n\r\nDescribe \"PowerShell C# type visibility\" {\r\n    It \"[Assembly]::Load(`$bytes) types are visible to PowerShell\" {\r\n    \r\n        $testdll = \"$env:TEMP/visibility.dll\"\r\n        if (test-path $testdll) {\r\n            remove-item $testdll -force\r\n        }\r\n        Add-Type @\"\r\npublic class Visibility {\r\n    public static string Test = \"Found\";\r\n}\r\n\"@ -Language CSharp -OutputAssembly $testdll\r\n        $bytes = [System.IO.File]::ReadAllBytes($testdll)\r\n        [System.Reflection.Assembly]::Load($bytes)\r\n\r\n        [Visibility]::Test | should be \"Found\"\r\n\r\n    }\r\n    It \"System.Runtime.Loader.AssemblyLoadContext]::Default.LoadFromStream(`$memoryStream) types are visible to PowerShell\" {\r\n    \r\n        $testdll = \"$env:TEMP/visibility2.dll\"\r\n        if (test-path $testdll) {\r\n            remove-item $testdll -force\r\n        }\r\n        Add-Type @\"\r\npublic class Visibility2 {\r\n    public static string Test = \"Found\";\r\n}\r\n\"@ -Language CSharp -OutputAssembly $testdll\r\n        $bytes = [System.IO.File]::ReadAllBytes($testdll)\r\n\r\n        $ms = new-object System.IO.MemoryStream\r\n        try {\r\n            $ms.Write($bytes, 0, $bytes.Length)\r\n            $ms.Seek(0, [System.IO.SeekOrigin]::Begin)\r\n\r\n\r\n            # This will fail on Windows PowerShell 5.1\r\n            [System.Runtime.Loader.AssemblyLoadContext]::Default.LoadFromStream($ms)\r\n        }\r\n        finally {\r\n            $ms.Dispose()\r\n        }\r\n        [Visibility2]::Test | should be \"Found\"\r\n\r\n    }\r\n}\r\n```\r\n\r\nOutput on 7.0.0 rc3:\r\n```\r\nDescribing PowerShell C# type visibilty\r\n [-] [Assembly]::Load($bytes) types are visible to PowerShell 119ms\r\n   RuntimeException: Unable to find type [Visibility].\r\n   at <ScriptBlock>, C:\\dev\\repro-AssemblyLoad.ps1: line 18\r\n [+] System.Runtime.Loader.AssemblyLoadContext]::Default.LoadFromStream($memoryStream) types are visible to PowerShell 147ms \r\n```",
      "created_at": "2020-03-05T10:56:05Z",
      "updated_at": "2020-03-05T11:05:46Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@stevenebutler In cast you don't know yet, #12052 is tracking the issue you reported, and the PR #12203 was submitted to fix it.",
      "created_at": "2020-03-26T17:02:00Z",
      "updated_at": "2020-03-26T17:02:00Z"
    }
  ],
  "created_at": "2019-11-16T00:48:39Z",
  "number": 11088,
  "state": "closed",
  "title": "Do not resolve types from assemblies that are loaded in separate AssemblyLoadContext",
  "updated_at": "2020-03-26T17:02:00Z"
}