{
  "_url": "https://github.com/PowerShell/PowerShell/issues/15562",
  "author": "ringerc",
  "body": "## Summary of the new feature/enhancement\r\n\r\nI propose the addition of a `Start-Process -DropPrivileges` or `Start-Process -TrustLevel 'Basic User'` option to the `Start-Process` cmdlet to make it simple to run a child-process with lowered privileges from within a Powershell script that is running with elevated (effective Administrator) privileges.\r\n\r\n`Start-Process -Wait` and `Wait-Process` should both behave like they would without the drop privileges option, `-NoNewWindow` should internally create pipes to forward the I/O to and from the child process, `Stop-Process` should properly terminate the process if passed the returned process object, and the exit code from the child process should be available if `Start-Process -PassThru` is used. In short, it should behave just like a normal process that was launched without dropping administrator privileges.\r\n\r\nPresently it appears to be exceedingly difficult to run a new process without elevated (Administrator) privileges from an elevated powershell session, wait for the process to exit, consume its stdout/stderr, and capture its exit code when it terminates. See my example in https://github.com/PowerShell/PowerShell/issues/15555#issuecomment-859248204 `trustlevel.ps1`.\r\n\r\nI further suggest that the same option should also be added to `Start-Job` (but obviously not `Start-ThreadedJob`) so powershell jobs can be launched with reduced rights in a simple, straightforward manner, and interacted with as normal.\r\n\r\n## Proposed technical implementation details (optional)\r\n\r\nAdd new `-TrustLevel 'Basic User'` option to `Start-Process` on Windows, where the available options to `TrustLevel` correspond to the fields exposed by `runas.exe /showtrustlevels`\r\n\r\n```\r\nPS C:\\Users\\test> runas /showtrustlevels\r\nThe following trust levels are available on your system:\r\n0x20000 (Basic User)\r\n```\r\n\r\nInternally, Powershell would:\r\n\r\n* Create named pipes for any non-redirected I/O channels and set any required privileges to permit them to be accessed by the less-privileged child process (probably none, since the process SID will still be the same, it just won't be elevated)\r\n* [Launch a new `pwsh.exe` with the lowered trustlevel](https://stackoverflow.com/a/23901718/398670) e.g. using `SaferCreateLevel()`, `SaferComputeTokenFromLevel()` and `CreateProcessAsUser()`\r\n* Have the new `pwsh.exe` child attach to the named pipes so that the child pwsh's stdio \r\n* Invoke the requested `Start-Process` cmdlet *without* the `-TrustLevel` option from the child `pwsh.exe`, preserving all other arguments exactly\r\n* When the process exits, return a serialized representation of the `Process` object from `Start-Process -Passthru` to the parent pwsh if `-Passthru` was requested\r\n* In the parent pwsh, service the child pwsh's named pipes, forwarding input and output as appropriate, and wait for the child pwsh to exit. If `-Passthru` was requested, deserialize and return the `Process` object, with `ExitCode` etc intact and set appropriately.\r\n\r\nThe user experience would thus look like\r\n\r\n```powershell\r\n$proc = Start-Process -TrustLevel 'Basic User' -Passthru -NoNewWindow -Wait -FilePath 'mycommand.exe' -ArgumentList @('arguments here')\r\n# ... mycommand.exe output is printed as it is generated by the command, and the session blocks waiting for it to exit.\r\nif ($proc.ExitCode -ne 0) {\r\n    Write-Error \"Oops, mycommand.exe exited with $($proc.ExitCode)\"\r\n}\r\n```\r\n\r\nOn Linux the capabilities(7) model could be exposed instead of using a `TrustLevel`, but it's less important. Linux users already have much simpler ways to do things with lowered privileges than are available under Windows, and tools like `sudo` and `setpriv` do not suffer from the same limitations as `runas.exe` re exit code, stdio, etc.\r\n\r\n## Why I suggest a Windows-specific TrustLevel in preference to a generic DropPrivileges option \r\n\r\nIt'd be cross platform friendly, but less specific, to add a `-DropPrivileges `option.\r\n\r\nThe problem with this is that it's not very clear which privileges are being dropped and which are to be retained. Consider the output of running `whoami /all` on Windows:\r\n\r\n```\r\n& ${env:\\WINDIR}\\system32\\whoami.exe /all\r\n\r\n[...]\r\n\r\nPRIVILEGES INFORMATION\r\n----------------------\r\n\r\nPrivilege Name                            Description                                                        State  \r\n========================================= ================================================================== =======\r\nSeIncreaseQuotaPrivilege                  Adjust memory quotas for a process                                 Enabled\r\nSeSecurityPrivilege                       Manage auditing and security log                                   Enabled\r\nSeTakeOwnershipPrivilege                  Take ownership of files or other objects                           Enabled\r\nSeLoadDriverPrivilege                     Load and unload device drivers                                     Enabled\r\nSeSystemProfilePrivilege                  Profile system performance                                         Enabled\r\nSeSystemtimePrivilege                     Change the system time                                             Enabled\r\nSeProfileSingleProcessPrivilege           Profile single process                                             Enabled\r\nSeIncreaseBasePriorityPrivilege           Increase scheduling priority                                       Enabled\r\nSeCreatePagefilePrivilege                 Create a pagefile                                                  Enabled\r\nSeBackupPrivilege                         Back up files and directories                                      Enabled\r\nSeRestorePrivilege                        Restore files and directories                                      Enabled\r\nSeShutdownPrivilege                       Shut down the system                                               Enabled\r\nSeDebugPrivilege                          Debug programs                                                     Enabled\r\nSeSystemEnvironmentPrivilege              Modify firmware environment values                                 Enabled\r\nSeChangeNotifyPrivilege                   Bypass traverse checking                                           Enabled\r\nSeRemoteShutdownPrivilege                 Force shutdown from a remote system                                Enabled\r\nSeUndockPrivilege                         Remove computer from docking station                               Enabled\r\nSeManageVolumePrivilege                   Perform volume maintenance tasks                                   Enabled\r\nSeImpersonatePrivilege                    Impersonate a client after authentication                          Enabled\r\nSeCreateGlobalPrivilege                   Create global objects                                              Enabled\r\nSeIncreaseWorkingSetPrivilege             Increase a process working set                                     Enabled\r\nSeTimeZonePrivilege                       Change the time zone                                               Enabled\r\nSeCreateSymbolicLinkPrivilege             Create symbolic links                                              Enabled\r\nSeDelegateSessionUserImpersonatePrivilege Obtain an impersonation token for another user in the same session Enabled\r\n```\r\n\r\nThe \"PRIVILEGES INFORMATION\" can have different contents for different levels of rights. A service running under `NT AUTHORITY\\SYSTEM` or `NT AUTHORITY\\NETWORK SERVICE` will be an \"administrator\" but have a different set of rights to (say) an Administrator user logged in over ssh, or the same Administrator user in an interactive command prompt in a UAC-enabled desktop login session. \r\n\r\nSimilarly on Linux, you have a capabilities set which can be observed with `capsh --print`, e.g.\r\n\r\n```\r\nroot# capsh --print\r\nCurrent: =ep\r\nBounding set =cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read,cap_perfmon,cap_bpf,cap_checkpoint_restore\r\nAmbient set =\r\nCurrent IAB: \r\nSecurebits: 00/0x0/1'b0 (no-new-privs=0)\r\n secure-noroot: no (unlocked)\r\n secure-no-suid-fixup: no (unlocked)\r\n secure-keep-caps: no (unlocked)\r\n secure-no-ambient-raise: no (unlocked)\r\nuid=0(root) euid=0(root)\r\ngid=0(root)\r\ngroups=0(root)\r\nGuessed mode: UNCERTAIN (0)\r\n```\r\n\r\nvs\r\n\r\n```\r\ncraig$ capsh --print\r\nCurrent: =\r\nBounding set =cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read,cap_perfmon,cap_bpf,cap_checkpoint_restore\r\nAmbient set =\r\nCurrent IAB: \r\nSecurebits: 00/0x0/1'b0 (no-new-privs=0)\r\n secure-noroot: no (unlocked)\r\n secure-no-suid-fixup: no (unlocked)\r\n secure-keep-caps: no (unlocked)\r\n secure-no-ambient-raise: no (unlocked)\r\nuid=1000(craig) euid=1000(craig)\r\ngid=1000(craig)\r\ngroups=10(wheel),11(cdrom),18(dialout),36(kvm),54(lock),156(stapusr),158(stapdev),970(power),974(docker),983(libvirt),1000(craig)\r\nGuessed mode: UNCERTAIN (0)\r\n```\r\n\r\nWould `-DropPrivileges` behave like running the command under `setpriv --no-new-privs --inh-caps '-all' --bounding-set '-all'  --ambient-caps='-all'` ? Or what?\r\n\r\nAnd what would `-DropPrivileges` mean for group memberships? It's just too fuzzy.\r\n\r\n## Rationale for why Powershell should help the user with this\r\n\r\nIt's desirable to encourage people to do things with lowered privileges whenever possible so this is something that should really be easy. It's often rather impractical to run your script as an unprivileged user or under a UAC-protected admin then elevate only the specific parts you require: If under UAC, the user is barraged with interactive UAC prompts, and if under a non-UAC lesser-privileged role, you have to actually handle username/password credentials for the admin in your script due to the apparent lack of any way to delegate trust to authorize a lesser-privileged user to impersonate a privileged admin. You need `Start-Process -Credentials` with an actual admin username and password.\r\n\r\nThe specific case I encountered this with was a CI system where setup tasks require elevated privileges, but most of the task should be done without effective admin rights, while preserving the same file ownership etc and without requiring any passwords to be embedded in scripts.\r\n\r\n## Bonus suggestion\r\n\r\nI think it'd make a lot of sense to piggy-back support for `__COMPAT_LAYER=RunAsInvoker` on this too, with a `Start-Process -RunAsInvoker`. It's the reciprocal of the issue discussed above. Right now it's a bit fiddly, annoying, and distinctly under-documented in win32 to override an application's \"run as administrator\" manifest flag and run it without elevation or UAC prompting.",
  "closed_at": "2021-08-24T09:00:40Z",
  "comments": [
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "> -NoNewWindow should internally create pipes to forward the I/O to and from the child process,\r\n\r\nI don't think this is really the way to go. It would mean you need to have some background task that is constantly reading and writing the stdio streams and redirecting it. What should happen is that the existing console should be inherited to the new process. This is how `-NoNewWindow` works normally right now. I've got a snippet below that tested this scenario out and it works just fine in that particular case.\r\n\r\nFor your technical details I'm not sure why the process object needs to be serialized. The proposed `Start-Process` should return the process object and start the filename and arguments as requested. This avoids any serialization and extra middleman work that would need to occur to synchronize the data and the object returned back is actually live. I don't see why this wouldn't be possible using the combination of APIs you have mentioned unless I'm missing something\r\n\r\nHere is some test code I wrote to try out the APIs you mentioned, I've never heard of the `Safer*` ones so I was intrigued.\r\n\r\n<details>\r\n  <summary>Click to view code</summary>\r\n\r\n```powershell\r\nAdd-Type -TypeDefinition @'\r\nusing Microsoft.Win32.SafeHandles;\r\nusing System;\r\nusing System.ComponentModel;\r\nusing System.Runtime.InteropServices;\r\n\r\nnamespace Safer\r\n{\r\n    public class SafeLevelHandle : SafeHandleZeroOrMinusOneIsInvalid\r\n    {\r\n        public SafeLevelHandle() : base(true) { }\r\n\r\n        protected override bool ReleaseHandle()\r\n        {\r\n            return NativeMethods.SaferCloseLevel(this);\r\n        }\r\n    }\r\n\r\n    public enum LevelScope : uint\r\n    {\r\n        Machine = 1,\r\n        User = 2,\r\n    }\r\n\r\n    public enum Level : uint\r\n    {\r\n        Disallowed = 0x00000,\r\n        Untrusted = 0x01000,\r\n        Constrained = 0x10000,\r\n        NormalUser = 0x20000,\r\n        FullyTrusted = 0x40000,\r\n    }\r\n\r\n\r\n    [Flags]\r\n    public enum CreateFlags : uint\r\n    {\r\n        None = 0x0,\r\n        NullIfEqual = 0x1,\r\n        CompareOnly = 0x2,\r\n        MakeInert = 0x4,\r\n        WantFlags = 0x8,\r\n    }\r\n\r\n    public class NativeMethods\r\n    {\r\n        [DllImport(\"Advapi32.dll\")]\r\n        public static extern bool SaferCloseLevel(\r\n            SafeHandle hLevelHandle\r\n        );\r\n\r\n        [DllImport(\"Advapi32.dll\", EntryPoint = \"SaferComputeTokenFromLevel\", SetLastError = true)]\r\n        private static extern bool NativeSaferComputeTokenFromLevel(\r\n            SafeHandle LevelHandle,\r\n            IntPtr InAccessToken,\r\n            out SafeFileHandle OutAccessToken,\r\n            CreateFlags dwFlags,\r\n            IntPtr lpReserved\r\n        );\r\n\r\n        public static SafeHandle SaferComputeTokenFromLevel(SafeHandle level, IntPtr token, CreateFlags flags)\r\n        {\r\n            SafeFileHandle newToken;\r\n            if (!NativeSaferComputeTokenFromLevel(level, token, out newToken, flags, IntPtr.Zero))\r\n                throw new Win32Exception();\r\n\r\n            return newToken;\r\n        }\r\n\r\n        [DllImport(\"Advapi32.dll\", EntryPoint = \"SaferCreateLevel\", SetLastError = true)]\r\n        private static extern bool NativeSaferCreateLevel(\r\n            LevelScope dwScopeId,\r\n            Level dwLevelId,\r\n            int OpenFlags,\r\n            out SafeLevelHandle pLevelHandle,\r\n            IntPtr lpReserved\r\n        );\r\n\r\n        public static SafeHandle SaferCreateLevel(LevelScope scope, Level level)\r\n        {\r\n            SafeLevelHandle levelHandle;\r\n            if (!NativeSaferCreateLevel(scope, level, 1, out levelHandle, IntPtr.Zero))\r\n                throw new Win32Exception();\r\n\r\n            return levelHandle;\r\n        }\r\n    }\r\n}\r\n'@\r\n\r\n# I honestly do not know the difference between Machine and User\r\n$level = [Safer.NativeMethods]::SaferCreateLevel('Machine', 'NormalUser')\r\n$token = [Safer.NativeMethods]::SaferComputeTokenFromLevel($level, [IntPtr]::Zero, 'None')\r\n\r\n# Use $token with CreateProcessAsUser\r\n# Start-ProcessEx is from https://gist.github.com/jborean93/a7c181b1ea0a4c0c8b815af9a8cbe508 and calls CreateProcessAsUser\r\nStart-ProcessEx powershell.exe -Token $token -CreationFlags None\r\n```\r\n</details>\r\n\r\nOne thing we should be wary of is the `runas.exe /trustlevel` and the `Safer*` APIs seem to be a product from the Windows XP era before the whole UAC token split was a thing. What I found when inspecting the tokens is that there are some differences between a user's limited token and the one created by `SaferComputeTokenFromLevel`. These differences are\r\n\r\n* A safer token only contained the `SeChangeNotifyPrivilege` privilege whereas a limited token had that and `SeIncreaseWorkingSetPrivilege`\r\n* The token still contains the `High Mandatory Label` unlike your normal limited token which has a `Medium` one\r\n* It looks like the LogonLUID is still the same as the admin one, this is mostly inconsequential but has some connotations when it comes ot things like mapped drives\r\n\r\nIn saying all that it's a lot simpler to use this `Safer` API and would even work to strip a full admin account to a more restricted token compared to the limited UAC token a normal process runs as.",
      "created_at": "2021-06-11T06:12:39Z",
      "updated_at": "2021-06-11T06:12:39Z"
    },
    {
      "author": "TobiasPSP",
      "author_association": "COLLABORATOR",
      "body": "@PowerShell/wg-powershell-cmdlets has been extensively discussing this issue. The mechanisms to both elevate and de-elevate processes depend largely on the underlying operating system. Since PowerShell is operating system neutral, adding such a feature would require specific code for specific target operating systems. \r\n\r\nThat said, given the different OS architectures, the requested feature may be useful only for certain operating systems. For example, in Windows, where there is no `sudo` and support for elevating in-process, such a feature may be more useful than in Linux.\r\n\r\nThe group concluded that such a feature should surface in a separate OS-specific cmdlet. Such a cmdlet can be developed and maintained outside the core engine and hosted in a gallery module. \r\n\r\nSince on Windows there are many different routes an implementation of such a feature can take, the group encourages the community to experiment and come up with a working example. Once such a working sample exists and lives up to the expectations, the group gladly revisits this topic and discusses whether it would be helpful for enterprises to ship out of box due to security and trust reasons. For now, because of above reasoning we close the issue.",
      "created_at": "2021-08-22T13:30:56Z",
      "updated_at": "2021-08-22T13:35:50Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This issue has been marked as won't fix and has not had any activity for **1 day**. It has been closed for housekeeping purposes.",
      "created_at": "2021-08-24T09:00:39Z",
      "updated_at": "2021-08-24T09:00:39Z"
    },
    {
      "author": "bbkane",
      "author_association": "NONE",
      "body": "Was there any solution to this?\r\n\r\nWhen I SSH into my Windows machine, I get an admin prompt, and there appears to be [no way to drop privileges from the SSH prompt](https://github.com/PowerShell/Win32-OpenSSH/issues/1652). ",
      "created_at": "2022-08-19T14:54:31Z",
      "updated_at": "2022-08-19T14:54:31Z"
    },
    {
      "author": "kfsone",
      "author_association": "NONE",
      "body": "I find this to routinely be an issue because you don't actually run with \"elevated permissions\", you run as a different user.\r\n\r\nErgo:\r\n\r\n```\r\nsubst T: $env:TEMP\r\necho \"hello\" >T:foo.txt\r\nstart -verb runas cmd -argumentlist \"/c\", \"copy\", t:foo.txt, $env:TEMP\\copy.txt\r\n```\r\n\r\nwill fail, because T: does not exist for the elevated user, the point being that if you are already elevated, you can't yield back to regular user space.\r\n\r\nPerhaps the real solution then is to find a way to create yourself an elevated ps session to which you can pass invoke-command stuff.\r\n",
      "created_at": "2022-09-20T19:44:25Z",
      "updated_at": "2022-09-20T19:44:25Z"
    }
  ],
  "created_at": "2021-06-11T05:05:34Z",
  "labels": [
    "Issue-Enhancement",
    "Resolution-Won't Fix",
    "WG-Cmdlets-Management"
  ],
  "number": 15562,
  "state": "closed",
  "title": "Support lowered TrustLevel for Start-Process",
  "updated_at": "2022-09-20T19:44:25Z"
}