{
  "_url": "https://github.com/PowerShell/PowerShell/issues/16219",
  "author": "Karl255",
  "body": "### Prerequisites\n\n- [X] Write a descriptive title.\n- [X] Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\n- [X] Search the existing issues.\n- [X] Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\n- [X] Refer to [Differences between Windows PowerShell 5.1 and PowerShell](https://docs.microsoft.com/powershell/scripting/whats-new/differences-from-windows-powershell).\n\n### Steps to reproduce\n\nI'm trying to recursively copy specific files from a folder with this command:\r\n```ps\r\nCopy .\\input -Destination .\\output -Recurse -Include (\"*.txt\", \"*.json\")\r\n```\r\nNothing gets copied whatsoever.\r\n\r\nIf I use `-Filter` instead and only specify one file type filter like:\r\n```ps\r\nCopy .\\input -Destination .\\output -Recurse -Filter \"*.txt\"\r\n```\r\nThis works, copies all .txt files, keeps the folder structure AND even copies empty folders (with `-Include` *nothing* got copied at all).\n\n### Expected behavior\n\n```console\n(for the first command) Files which fit any of the given filters get copied together with the whole folder structure (even empty folder, like with `-Filter`).\n```\n\n\n### Actual behavior\n\n```console\nNothing gets copied.\n```\n\n\n### Error details\n\n_No response_\n\n### Environment data\n\n```powershell\nName                           Value\r\n----                           -----\r\nPSVersion                      7.1.4\r\nPSEdition                      Core\r\nGitCommitId                    7.1.4\r\nOS                             Microsoft Windows 10.0.19043\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\n```\n\n\n### Visuals\n\n_No response_",
  "closed_at": "2022-02-22T09:00:42Z",
  "comments": [
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "The @PowerShell/wg-powershell-cmdlets reviewed this.  The cmdlet is working as designed although we agree in a non-obvious kind of way.  Unfortunately `Get-ChildItem` and `Copy-Item` seem to treat `-Include` differently when `-Recurse` is used as `Copy-Item` applies `-Include` to `-Path` to enumerate recursively, while `Get-ChildItem` applies it after recursion.  As we expect existing users to be dependent on the current behavior, we recommend that no change should be made as it would result in breaking existing scripts.  Instead, this should be a doc issue making more clear how `-Include` and `-Exclude` is applied (today it merely says these parameters \"qualify the Path parameter\") and having some specific examples where the current behavior would be used.  Use of `-Filter` instead is the appropriate way to solve the original issue.\r\n\r\nCreated https://github.com/MicrosoftDocs/PowerShell-Docs/issues/8601",
      "created_at": "2022-02-20T01:16:30Z",
      "updated_at": "2022-02-20T01:16:30Z"
    },
    {
      "author": "Karl255",
      "author_association": "NONE",
      "body": "Thank you for your answer! I understand what `-Include` does now. Useful when using a wildcard for `-Path`.\r\n\r\n> Use of `-Filter` instead is the appropriate way to solve the original issue.\r\n\r\nThe problem with `-Filter` is that it only accept one filter, which means I'd need to run several similar commands if I wanted to copy several specific file types. A `-Filters` parameter would be a good solution, user-wise at least.",
      "created_at": "2022-02-20T12:38:29Z",
      "updated_at": "2022-02-20T12:38:38Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> The cmdlet is working **as designed** although we agree in a non-obvious kind of way.\r\n\r\nIf you make such a conclusion there must be a **valid reason** without which the described behavior of the cmdlet is an obvious bug.\r\n\r\n> The cmdlet is working as designed although we agree in a **non-obvious** kind of way.\r\n\r\nFrom https://en.wikipedia.org/wiki/Software_bug\r\n>A software bug is an error, flaw or fault in computer software that causes it to produce an incorrect or **unexpected result**, or **to behave in unintended ways**.\r\n\r\nAre you going to argue that **every** user **expects** the next command to do **nothing**?\r\n```powershell\r\nCopy-Item c:\\ d:\\  -Include *.* -Recurse\r\n```\r\nI don't think anyone from the WG would risk even a cent against it :-)\r\n\r\nIn reality, users expect quite the opposite and have been forced to use workarounds for years in the form of `dir -recurse | copy-item`.\r\nYou can find countless examples of these on GitHub or at least look at follow\r\nhttps://stackoverflow.com/questions/5432290/how-to-use-powershell-copy-item-and-keep-structure\r\nhttps://stackoverflow.com/questions/18616581/how-to-properly-filter-multiple-strings-in-a-powershell-copy-script \r\n\r\n> As we expect existing users to be dependent on the current behavior, we recommend that no change should be made as it would result in breaking existing scripts.\r\n\r\nAfter that you will still claim that someone is scripting on this absurd behavior?\r\n\r\nFinally, I would really like to see the rationale behind **this design** - why do Get-ChildItem and Remove-Item behave differently with Include/Exclude than Copy-Item? \r\nVoting 2 vs 1. :-)\r\n\r\n---\r\nAfter reviewing the existing issues and documentation, I found many contradictions and ambiguities concerning Providers. The only way I see to put things in order is to clearly describe the basic principles in RFC (that I've been working on for the last few days).\r\nNow I'm at a loss, how would you describe how filters work in PowerShell? \"PowerShell Provider Engine implements include and exclude filters with follow behavior ...\". \r\nBased on the WG's conclusion it would be \"don't even try to guess\". :-)\r\n\r\n---\r\nI am concerned about this precedent. I think it's more for WG-Engine-Providers than WG-Cmdlets-Management.\r\nLook, this is not the problem of one cmdlet https://github.com/PowerShell/PowerShell/issues?q=is%3Aissue+is%3Aopen+Include+label%3AArea-FileSystem-Provider\r\n\n\n<blockquote><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/c/c5/CIAJMK1209-en.svg/1200px-CIAJMK1209-en.svg.png\" width=\"48\" align=\"right\"><div><strong><a href=\"https://en.wikipedia.org/wiki/Software_bug\">Software bug - Wikipedia</a></strong></div></blockquote>\n<blockquote><img src=\"https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded\" width=\"48\" align=\"right\"><div>Stack Overflow</div><div><strong><a href=\"https://stackoverflow.com/questions/5432290/how-to-use-powershell-copy-item-and-keep-structure\">How to use PowerShell copy-item and keep structure</a></strong></div><div>I have a directory structure that looks like this:\n\nC:\\folderA\\folderB\\folderC\\client1\\f1\\files\nC:\\folderA\\folderB\\folderC\\client1\\f2\\files\nC:\\folderA\\folderB\\folderC\\client2\\f1\\files\nC:\\folderA\\fo...</div></blockquote>\n<blockquote><img src=\"https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded\" width=\"48\" align=\"right\"><div>Stack Overflow</div><div><strong><a href=\"https://stackoverflow.com/questions/18616581/how-to-properly-filter-multiple-strings-in-a-powershell-copy-script\">How to properly -filter multiple strings in a PowerShell copy script</a></strong></div><div>I am using the PowerShell script from this answer to do a file copy. The problem arises when I want to include multiple file types using the filter. \n\nGet-ChildItem $originalPath -filter \"*.htm\"  |...</div></blockquote>\n<blockquote><img src=\"https://repository-images.githubusercontent.com/49609581/aad0ad80-cdec-11ea-8248-a37bc0571bfd\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/PowerShell/PowerShell\">Issues \u00b7 PowerShell/PowerShell</a></strong></div><div>PowerShell for every system! Contribute to PowerShell/PowerShell development by creating an account on GitHub.</div></blockquote>",
      "created_at": "2022-02-20T20:04:00Z",
      "updated_at": "2022-02-20T20:04:02Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "It's really for WG-Engine-Providers.\r\n\r\nWe must get answers to _fundamental_ questions. Are these parameters proprietary to the engine or to cmdlets? If cmdlets then this leads to absurdly different behavior as we can see. Furthermore they are not individual cmdlets but Provider cmdlets, i.e. the cmdlets themselves are part of the PowerShell Provider Engine API - the developers do not implement these cmdlets, only the providers. So these parameters are still the property of the PowerShell Provider Engine which should define their unambiguous semantics for all kinds of providers, right? Then we should expect the parameters to work the same for all cmdlets. On the other hand if we look at the implementation we see a lot of flexibility, these parameters are saved in a CmdletProviderContext which unexpectedly contains these parameters and is not immutable! We see two consequences. Firstly, the provider can use the values of these parameters and create a different behavior than the engine. Using these parameters may be justified by their more efficient implementation, but deviations in behavior are unacceptable. Therefore we need mandatory tests for all providers which protect generic behaviors. Second, any provider's implementation can change values of these parameters on the fly, changing the behavior of the engine itself and even the behavior of other providers! This is also unacceptable and the engine should be modified to prevent this.\r\n\r\nRecursion problem was discussed in #15159 at length without final conclusion. While implementation of globstart/pathspecs looks enticing this is extremely difficult to implement and difficult to use.\r\nIf we look at the implementation of recursion in .Net, there are two predicates - ShouldRecurse and ShouldInclude. Both predicates have full access to the _current_ Item. It is intuitively clear what they are doing.\r\nIn essence, we need exactly these two operations too - _anything else is just misleading_.\r\nThis leads us to agree that these parameters (Include/Exclude) work as ShouldInclude predicate - _it likely falls into bucket 3 (unlikely grey area)_.\r\nWe can not convert Recurse parameter in ShouldRecurse  predicate it would be hug breaking change. Really Recurse  works as `ShouldRecurse  *`. Does this remind you of anything? For example, the Path parameter with globbing support? :-) \r\nI can assume that this is enough for most typical scenarios. If you need something more than globbing in Path parameter, I'd rather consider new parameters (ShouldRecurse  and ShouldInclude) in the form of _script filter functions_ that take the current _item_ as a parameter (ex., like FileInfo). This is of course slower than the native implementation, but still noticeably faster than the current globbig implementation.\r\n_So the minimum we need to do to put things in order is to admit that the parameters (Include/Exclude) work exclusively as ShouldInclude predicate and uniformly for all cmdlets._\r\n(In fact, Get-ChildItem already does something similar.)\r\n\r\n\r\n",
      "created_at": "2022-02-21T06:35:31Z",
      "updated_at": "2022-02-21T06:39:13Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This issue has been marked as by-design and has not had any activity for **1 day**. It has been closed for housekeeping purposes.",
      "created_at": "2022-02-22T09:00:41Z",
      "updated_at": "2022-02-22T09:00:41Z"
    }
  ],
  "created_at": "2021-10-09T13:22:29Z",
  "labels": [
    "Resolution-By Design",
    "WG-Cmdlets-Management",
    "Area-FileSystem-Provider"
  ],
  "number": 16219,
  "state": "closed",
  "title": "Copy-Item with -Include and -Recurse doesn't work",
  "updated_at": "2022-02-22T09:00:42Z"
}