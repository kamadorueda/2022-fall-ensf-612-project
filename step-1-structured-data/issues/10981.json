{
  "_url": "https://github.com/PowerShell/PowerShell/issues/10981",
  "author": "mikeTWC1984",
  "body": "# Summary\r\nI think it was announced but I've never heard any updates about creating secret manager in powershell.  Should we still expect this with GA version?\r\nOn Windows I used to use json files with Protect/Uprotect CMS message cmdlet's for this purpose (which is based on certificates). This is not available on nix machines at the moment, however I realized this could be recreated in there using X509Certificates namespace  classes (see code example below). Certificate stores on nix are also implemented by dotnet (e.g. CurrentUser\\My store is located under .dotnet/corefx/cryptography/x509stores/my folder), you can even use it with Invoke-Webrequest already (it can lookup cert by thumbprint in CurrentUser\\My). That being said - is there any reason not to port Certificate/CMS cmdelts and cert: provider to nix? \r\n\r\nOne more related feature that could be very useful is to add CA cert or store parameter to IWR/IRM. This would be analogy of curl's --cacert parameter. So in case if selfsigned certificate  is used on the server, we can trust that  specific certificate rather than ignoring  certificate check. Or maybe IWR can trust whatever is under CurrentUser\\root store.\r\n\r\nBelow is some quick and dirty demo that would work on linux. \r\n\r\n```powershell\r\n\r\nusing namespace System.Security.Cryptography.X509Certificates\r\nusing namespace System.Security.Cryptography\r\nAdd-Type -AssemblyName System.Security\r\n\r\n$ErrorActionPreference = \"STOP\"\r\n\r\nfunction New-SelfSignedCertificate2 { param($Name, [int]$KeyLength = 4096, [int]$Days = 365)\r\n   \r\n   $DN = [X500DistinguishedName]::new(\"CN=$Name\")\r\n   $rsa = [RSA]::Create($KeyLength)\r\n   $request = [CertificateRequest]::new($DN, $rsa, [HashAlgorithmName]::SHA256, [RSASignaturePadding]::Pkcs1)\r\n\r\n   $ext = [X509KeyUsageExtension]::new([X509KeyUsageFlags]::DataEncipherment, $false)\r\n   $oids  = [OidCollection]::new()\r\n   $oids.Add([oid]::new(\"1.3.6.1.4.1.311.80.1\")) | Out-Null # Document Encryption\r\n   $enhExt = [X509EnhancedKeyUsageExtension]::new($oids,$false)\r\n   foreach($x in $ext, $enhExt) {$request.CertificateExtensions.Add($x)}\r\n   $cert = $request.CreateSelfSigned([datetime]::UtcNow, [datetime]::UtcNow.AddDays($Days))\r\n   $pass = $cert.Thumbprint\r\n   return [X509Certificate2]::new($cert.Export([X509ContentType]::Pfx, $pass), $pass, [X509KeyStorageFlags]::PersistKeySet)\r\n}\r\n\r\nfunction Protect-CmsMessage2 { param([Parameter(ValueFromPipeline=$true)][String]$Message, [X509Certificate2]$Cert) \r\n\r\n   $opt = [System.Base64FormattingOptions]::InsertLineBreaks\r\n   $contentInfo = [System.Security.Cryptography.Pkcs.ContentInfo]::new($OutputEncoding.GetBytes($Message))\r\n   $cms = [System.Security.Cryptography.Pkcs.EnvelopedCms]::new($contentInfo)\r\n   $cms.Encrypt($cert) \r\n   $base64 =  [System.Convert]::ToBase64String($cms.Encode(), $opt )\r\n   return \"-----BEGIN CMS-----`n$base64`n-----END CMS-----\"\r\n}\r\n\r\nfunction Unprotect-CmsMessage2 { param([Parameter(ValueFromPipeline=$true)]$Cipher, $Cert)\r\n   $base64 = [regex]::Match($Cipher, 'CMS-----\\n((?:.*\\r?\\n?)*)\\n-----END').Groups[1].Value\r\n   $cms = [System.Security.Cryptography.Pkcs.EnvelopedCms]::new()\r\n   $cms.Decode([System.Convert]::FromBase64String($base64))\r\n   if($Cert) {$cms.Decrypt($Cert)} Else {$cms.Decrypt()}\r\n   return $OutputEncoding.GetString($cms.ContentInfo.Content)\r\n}\r\n\r\nfunction Import-PfxCertificate2 { param( \r\n    [Parameter(ValueFromPipeline=$true)][X509Certificate2]$Certificate\r\n   ,[String]$FilePath, [String]$Password, [String]$CertStore=\"My\"\r\n   )\r\n\r\n   If(!$Certificate) { $Certificate = [X509Certificate2]::new($FilePath, $Password, [X509KeyStorageFlags]::PersistKeySet) }\r\n      \r\n   $store = [X509Store]::new($CertStore)\r\n   $store.Open(\"ReadWrite\")\r\n   $store.Add($Certificate)\r\n   $store.Dispose()\r\n   return $true\r\n }\r\n\r\nfunction Export-PfxCertificate2 { param(\r\n   [Parameter(ValueFromPipeline=$true)][X509Certificate2]$cert,\r\n   [String]$FilePath, [String]$Password,[X509ContentType]$Type = \"Pfx\"\r\n   )\r\n   If(!$FilePath) { $FilePath = \"$($cert.SerialNumber).pfx\" }\r\n   [System.IO.File]::WriteAllBytes($FilePath, $cert.Export($Type, \"P@ssw0rd\"))\r\n}\r\n\r\n # kind of Get-ChildItem cert:\\My\r\nfunction Get-Certificate { param([String]$Thumbprint, [String]$Name=\"*\", [String]$CertStore=\"My\")\r\n  $store = [X509Store]::new($CertStore); $store.Open(\"ReadOnly\")\r\n  $certList = If($Thumbprint) { $store.Certificates.Find(\"FindByThumbprint\", $Thumbprint, $false)}\r\n        Else {$store.Certificates | Where-Object { $_.Thumbprint -like $Name -OR $_.Subject -like $Name}}\r\n  If( $certList.Count -eq 1) {return $certList[0] } Else {return $certList }\r\n}\r\nfunction Remove-Certificate { param(\r\n   [Parameter(ValueFromPipeline=$true)][X509Certificate2]$Certificate, [String]$CertStore = \"My\"\r\n)\r\n  Begin { $store = [X509Store]::new(\"My\"); $store.Open(\"ReadWrite\") }\r\n  Process { $store.Remove($Certificate) }\r\n  End { $store.Dispose() }\r\n \r\n}\r\n\r\n<# ------------- TEST -------------\r\n\r\nGet-Certificate -CertStore \"My\"\r\n\r\n# in-memory cert\r\n$cert = New-SelfSignedCertificate2 -Name \"SamplePSCoreNix\" -KeyLength 4096\r\n\r\n# Encrypt/Decrypt\r\n$cipher = Protect-CmsMessage2 -Message (irm www.example.com) -Cert $cert\r\n$cipher | Unprotect-CmsMessage2 -Cert $cert\r\n\r\n#export to file\r\n$cert | Export-PfxCertificate2 -FilePath \"SamplePSCoreNix.pfx\" -Password \"P@ssw0rd\"\r\n\r\n#  import to cert store\r\n$cert | Import-PfxCertificate2 -CertStore \"My\"\r\n\r\n# get cert from store\r\n$cert = Get-Certificate -Name \"*SamplePSCoreNix*\" -CertStore \"My\"\r\n$cipher | Unprotect-CmsMessage2  # once added to My store no need to specify cert\r\n\r\n# Remove Cert from the store\r\n$cert | Remove-Certificate -CertStore \"My\"\r\n\r\n#>\r\n```\r\n",
  "closed_at": "2020-02-12T22:00:03Z",
  "comments": [],
  "created_at": "2019-11-04T04:41:50Z",
  "labels": [
    "Issue-Enhancement"
  ],
  "number": 10981,
  "state": "closed",
  "title": "Certificates and Secret Manager on nix systems",
  "updated_at": "2020-02-12T22:00:03Z"
}