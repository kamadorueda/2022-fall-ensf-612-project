{
  "_url": "https://github.com/PowerShell/PowerShell/issues/15188",
  "author": "User843212",
  "body": "<!--\r\n\r\nFor Windows PowerShell 5.1 issues, suggestions, or feature requests please use the following link instead:\r\nWindows PowerShell [UserVoice](https://windowsserver.uservoice.com/forums/301869-powershell)\r\n\r\nThis repository is **ONLY** for PowerShell Core 6 and PowerShell 7+ issues.\r\n\r\n- Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\r\n- Search the existing issues.\r\n- Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\r\n- Refer to the [known issues](https://docs.microsoft.com/powershell/scripting/whats-new/known-issues-ps6).\r\n-->\r\n\r\n## Steps to reproduce\r\n\r\n```\r\nI have downloaded video files \"segment_1.ts ... segment_n.ts\" and want to concatenate these files to one single \"Video.ts\"\r\n\r\nI use this code::\r\n        $Segments | ForEach-Object { Get-Content $_ -Raw | Add-Content \"Video.ts\" }\r\n         with filenames stored in array \"$Segments\"\r\n```\r\n\r\n## Expected behavior\r\n\r\n```\r\nAll video files \"segment_1...n.ts\" should be concatenated to one single video file \"Video.ts\". \r\n```\r\n\r\n## Actual behavior\r\n\r\n```\r\nThe file \"Video.ts\" is created but it is much to big and e.g. VLC can't play it.\r\nThe absolutely identical code works perfectly in PowerShell 5.\r\nIt seems that the file \"Video.ts\" is some twice as big when created in PS 7 as opposed to PS 5.\r\n\r\nAs work around this code works but is much slower:\r\n      $Segments | ForEach-Object { Get-Content $_ -AsByteStream -ReadCount 0 | Add-Content \"Video.ts\" -AsByteStream }\r\n\r\nIs it possible that \"PS7 x64\" has a problem with \"int32\" to \"int64\" conversion in \"get/add-content\"?\r\n```\r\n\r\n## Environment data\r\n\r\n<!-- provide the output of $PSVersionTable -->\r\n\r\n```\r\nPSVersion                      7.1.3\r\nPSEdition                      Core\r\nGitCommitId                    7.1.3\r\nOS                             Microsoft Windows 10.0.19042\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n",
  "closed_at": "2021-04-11T00:00:05Z",
  "comments": [
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Get/Set-Content by default reads/wites  files as text, not bytes, so will likely mangle non-text data. Use `-AsByteStream` for both the Get- and Set- commands there to retrieve and store back just the raw bytes.\r\n\r\nAlso, could you please summarise the issue in the title? Thanks! \ud83d\ude0a ",
      "created_at": "2021-04-08T17:41:59Z",
      "updated_at": "2021-04-08T17:42:42Z"
    },
    {
      "author": "User843212",
      "author_association": "NONE",
      "body": "@ vexx32 - how  can I edit the title?\r\n\r\n",
      "created_at": "2021-04-08T17:46:53Z",
      "updated_at": "2021-04-08T17:57:27Z"
    },
    {
      "author": "User843212",
      "author_association": "NONE",
      "body": "> .... Use `-AsByteStream` for both the Get- and Set- commands there to retrieve and store back just the raw bytes.\r\n\r\nI have already done this as mentioned in section \"Actual behavior\" from bug report.\r\nBut this is not the point. Why e.g. is the output file \"Video.ts\" some twice as big as should be?\r\nE.g. with PS5 it is 4.321kB opposed to 7.798kB with PS7\r\n\r\nAnd copying as byte stream is some 10 times slower (or even more).\r\n",
      "created_at": "2021-04-08T18:08:50Z",
      "updated_at": "2021-04-08T18:10:32Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@User843212, you can speed the command up considerably as follows:\r\n\r\n```\r\nAdd-Content \"Video.ts\" -AsByteStream -Value (Get-Content $_ -AsByteStream -Raw)\r\n```\r\n\r\nFor best performance:\r\n\r\n* Use `-Raw` rather than `-ReadCount 0` in combination with `Get-Content -AsByteStream`.\r\n* Don't _pipe_ the resulting `[byte[]]` array to `Add-Content`, pass it via `-Value`.\r\n\r\nNote: As in your approach, the requirement is that the input file fit into memory _as a whole_.",
      "created_at": "2021-04-08T20:57:35Z",
      "updated_at": "2021-04-08T21:20:27Z"
    },
    {
      "author": "User843212",
      "author_association": "NONE",
      "body": "@mklement0 \r\nAllready done in all possible ways! (may be I should have mentioned that I am professional software developer)\r\n\r\nI have listed execution times below - timings from PS7\r\n\r\n\"-ReadCount 0\" is faster than \"-Raw\"\r\nPassing via Pipe is faster then via \"-Value\"\r\nfile size doesn't matter in this case 32 GB RAM and some 4MB file size\r\n\r\n$Segments | ForEach-Object { Get-Content $_ -Raw | Add-Content \"Video.ts\" }\r\nTotalSeconds      : 14,6     **<<< this works fine in PS5 but PS7 outputs corrupted video file \"Video.ts\"**\r\n\r\n$Segments | ForEach-Object { Get-Content $_ -AsByteStream -**ReadCount 0** | Add-Content \"Video.ts\" -AsByteStream }\r\nTotalSeconds      : 99,9    **<<< working but see the difference from 14,6 s to 99,9 s**\r\n\r\n$Segments | ForEach-Object { Get-Content $_ -AsByteStream -**Raw** | Add-Content \"Video.ts\" -AsByteStream }\r\nTotalSeconds      : 202,4\r\n\r\n$Segments | ForEach-Object { Add-Content \"Video.ts\" -AsByteStream -**Value** (Get-Content $_ -AsByteStream -**ReadCount 0**) }\r\nTotalSeconds      : 287,2\r\n\r\n$Segments | ForEach-Object { Add-Content \"Video.ts\" -AsByteStream -**Value** (Get-Content $_ -AsByteStream -**Raw**) }\r\nTotalSeconds      : 329,9",
      "created_at": "2021-04-09T00:42:12Z",
      "updated_at": "2021-04-09T01:49:01Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> maybe I should have mentioned that I am professional software developer\r\n\r\n It's sufficient to make convincing arguments, irrespective of your background.\r\n\r\n> <<< this works fine in PS5 but PS7 outputs corrupted video file \"Video.ts\"\r\n\r\nAs @vexx32 has explained, using `Get-Content` without `-AsByteStream` is only suitable for _text_ files.\r\n\r\n(That it works in Windows PowerShell (PowerShell versions up to v5.1) is a happy accident (the active ANSI code page being a single-byte encoding such as Windows-1252, where all byte values are by definition valid characters as-is; however, it would fail even in Windows PowerShell if you used the Windows 10 feature of setting the system locale to UTF-8).\r\n\r\nAs for the remaining benchmarks:\r\n\r\n* I misspoke about the influence of the pipeline _in this case_: given that both `-ReadCount 0` and `-Raw` output a _single_ object to the pipeline (a single array with `-AsByteStream` in both cases, a single array / single string without `-AsByteStream`), the overhead introduced by the pipeline vs. argument-passing should be _negligible_.\r\n\r\n  * By contrast, with commands that output multiple objects in the - usual - _streaming_ fashion, pipeline vs. argument input can make a big difference - assuming the command is even prepared to handle _array_-valued input by argument, which only some cmdlets do.\r\n\r\n* Combining `-AsByteStream` with `-ReadCount -0` vs. `-Raw` _in isolation_ exhibits a huge performance difference in favor of the latter.\r\n  * You could argue that it shouldn't, given that both construct a _single_ array comprising _all_ bytes; in practice `-ReadCount 0` outputs an`[object[]]` array, whereas the - much faster - `-Raw` outputs a `[byte[]]` array.\r\n  * Note that with _text_ input (i.e. in the absence of `-AsByteStream`), `-Raw` is only slightly faster than `-ReadCount 0`, which makes sense: it's the difference between reading a file as a single string and reading it into an array of lines.\r\n\r\n**You've clearly hit on a performance problem with _byte_ in- and output**, as the following benchmarks show, and for which I have no explanation at this point:\r\n\r\n---\r\n\r\nSee [below](https://github.com/PowerShell/PowerShell/issues/15188#issuecomment-816951590) for updated benchmarks.\r\n\r\n<details>\r\n<summary>(Outdated)</summary>\r\nYou can run the following benchmarks yourself, using the `Time-Command` function that you can download from [this Gist]((https://gist.github.com/mklement0/9e1f13978620b09ab2d15da5535d1b27):\r\n\r\n  * Assuming you have looked at the linked code to ensure that it is safe (which I can personally assure you of, but you should always check), you can install it directly as follows:\r\n  \r\n        irm https://gist.github.com/mklement0/9e1f13978620b09ab2d15da5535d1b27/raw/Time-Command.ps1 | iex\r\n\r\nBenchmark code that averages the timings of 3 runs, using 32Mb files:\r\n\r\n```powershell\r\nWrite-Verbose -vb 'Setting up...'\r\n\r\n# Create files to serve as the target and the file to add to it.\r\n$bytes = [byte[]]::new(32mb)\r\nSet-Content -AsByteStream target.bin -value $bytes\r\nSet-Content -AsByteStream add.bin -value $bytes\r\n\r\n# Create a copy of the original target to restore it betwen runs\r\nSet-Content -AsByteStream original.bin -value $bytes\r\n\r\n# Warm up the file cache to level the playing field.\r\n$null, $null, $null = (Get-Content -Raw -AsByteStream original.bin), (Get-Content -Raw -AsByteStream target.bin), (Get-Content -Raw -AsByteStream add.bin)\r\n\r\nWrite-Verbose -vb 'Running benchmarks...'\r\n\r\nWrite-Verbose -vb '---- BINARY'\r\n\r\nWrite-Verbose -vb 'Binary: Get-Content alone...'\r\nTime-Command -Count 3 `\r\n  { # -ReadCount 0\r\n    $bytes = Get-Content add.bin -AsByteStream -ReadCount 0\r\n  },\r\n  { # -Raw\r\n    $bytes = Get-Content add.bin -AsByteStream -Raw\r\n  } | Out-Host\r\n\r\n\r\nWrite-Verbose -vb 'Binary: Get-Content + Set-Content...'\r\n\r\nTime-Command -Count 3 `\r\n  { # -ReadCount 0, pipeline\r\n    Get-Content add.bin -AsByteStream -ReadCount 0 | Set-Content target.bin -AsByteStream \r\n  },\r\n  { # -Raw, pipeline\r\n    Get-Content add.bin -AsByteStream -Raw | Set-Content target.bin -AsByteStream \r\n  },\r\n  { # -ReadCount 0, argument\r\n    Set-Content target.bin -AsByteStream -Value (Get-Content add.bin -AsByteStream -ReadCount 0)\r\n  },\r\n  { # -Raw, argument\r\n    Set-Content target.bin -AsByteStream -Value (Get-Content add.bin -AsByteStream -Raw)\r\n  } | Out-Host\r\n\r\nWrite-Verbose -vb 'Binary: Get-Content + Add-Content...'\r\n\r\nTime-Command -Count 3 `\r\n  { # -ReadCount 0, pipeline\r\n    Copy-Item original.bin target.bin\r\n    Get-Content add.bin -AsByteStream -ReadCount 0 | Add-Content target.bin -AsByteStream \r\n  },\r\n  { # -Raw, pipeline\r\n    Copy-Item original.bin target.bin\r\n    Get-Content add.bin -AsByteStream -Raw | Add-Content target.bin -AsByteStream \r\n  },\r\n  { # -ReadCount 0, argument \r\n    Copy-Item original.bin target.bin\r\n    Add-Content target.bin -AsByteStream -Value (Get-Content add.bin -AsByteStream -ReadCount 0)\r\n  },\r\n  { # -Raw, argument \r\n    Copy-Item original.bin target.bin\r\n    Add-Content target.bin -AsByteStream -Value (Get-Content add.bin -AsByteStream -Raw)\r\n  } | Out-Host\r\n\r\n  Write-Verbose -vb '---- TEXT'\r\n\r\n  Write-Verbose -vb 'Text: Get-Content alone...'\r\n  Time-Command -Count 3 `\r\n    { # -ReadCount 0\r\n      $lines = Get-Content add.bin -ReadCount 0\r\n    },\r\n    { # -Raw\r\n      $wholeFileString = Get-Content add.bin -Raw\r\n    } | Out-Host\r\n  \r\n  Write-Verbose -vb 'Text: Get-Content + Set-Content...'\r\n\r\n  Time-Command -Count 3 `\r\n    { # -ReadCount 0, pipeline\r\n      Get-Content add.bin -ReadCount 0 | Set-Content target.bin\r\n    },\r\n    { # -Raw, pipeline\r\n      Get-Content add.bin -Raw | Set-Content target.bin\r\n    },\r\n    { # -ReadCount 0, argument\r\n      Set-Content target.bin -Value (Get-Content add.bin -ReadCount 0)\r\n    },\r\n    { # -Raw, argument\r\n      Set-Content target.bin -Value (Get-Content add.bin -Raw)\r\n    } | Out-Host\r\n```\r\n</details>\r\n\r\nOn my Window 10 VM running PowerShell Core 7.2.0-preview.4 I see the following results - the absolute times aren't important, but the `Factor` column should give a sense of relative performance, as well as the ratio of the binary vs. text timings:\r\n\r\n![image](https://user-images.githubusercontent.com/588825/114123278-fb773080-98bf-11eb-9a76-c260d0a3c717.png)\r\n\r\n* The huge performance discrepancy between `Get-Content -AsByteStream -Raw` and `Get-Content -AsByteStream -ReadCount 0` in isolation is strange.\r\n\r\n* That input by pipeline would be _faster_ than input by argument for binary data doesn't make sense to me. (By contrast, the ratios are expected for _text_ data).\r\n\r\n* That text processing, which involves decoding and encoding, is so much faster than byte processing doesn't make sense to me.\r\n\r\n\r\n<blockquote><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> Gist</div><div><strong><a href=\"https://gist.github.com/mklement0/9e1f13978620b09ab2d15da5535d1b27\">PowerShell function that times the execution of one or more commands, averaged over a specifiable number of runs.</a></strong></div><div>PowerShell function that times the execution of one or more commands, averaged over a specifiable number of runs. - Time-Command.ps1</div></blockquote>",
      "created_at": "2021-04-09T03:15:42Z",
      "updated_at": "2021-04-09T20:26:00Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "Every byte is converted to an object. \r\n\r\n```powershell\r\ntrace-command -Expression {add-content -AsByteStream -LiteralPath target.bin -Value (Get-Content -raw -AsByteStream add.bin)} -PSHost -Name ParameterBinding \r\n```\r\n```text\r\nBIND NAMED cmd line args [Get-Content]\r\nBIND POSITIONAL cmd line args [Get-Content]\r\nBIND cmd line args to DYNAMIC parameters.\r\n    DYNAMIC parameter object: [Microsoft.PowerShell.Commands.FileSystemContentReaderDynamicParameters]\r\n    BIND NAMED args to DYNAMIC parameters\r\n        BIND arg [True] to parameter [Raw]\r\n            COERCE arg to [System.Management.Automation.SwitchParameter]\r\n                Parameter and arg types the same, no coercion is needed.\r\n            BIND arg [True] to param [Raw] SUCCESSFUL\r\n        BIND arg [True] to parameter [AsByteStream]\r\n            COERCE arg to [System.Management.Automation.SwitchParameter]\r\n                Parameter and arg types the same, no coercion is needed.\r\n            BIND arg [True] to param [AsByteStream] SUCCESSFUL\r\n    BIND POSITIONAL args to DYNAMIC parameters\r\n        BIND arg [add.bin] to parameter [Path]\r\n            Binding collection parameter Path: argument type [String], parameter type [System.String[]], collection type Array, element type [System.String], no coerceElementType\r\n            Creating array with element type [System.String] and 1 elements\r\n            Argument type String is not IList, treating this as scalar\r\n            Adding scalar element of type String to array position 0\r\n            BIND arg [System.String[]] to param [Path] SUCCESSFUL\r\nMANDATORY PARAMETER CHECK on cmdlet [Get-Content]\r\nCALLING BeginProcessing\r\nCALLING EndProcessing\r\nBIND NAMED cmd line args [Add-Content]\r\n    BIND arg [target.bin] to parameter [LiteralPath]\r\n        COERCE arg to [System.String[]]\r\n            Trying to convert argument value from System.String to System.String[]\r\n            ENCODING arg into collection\r\n            Binding collection parameter LiteralPath: argument type [String], parameter type [System.String[]], collection type Array, element type [System.String], coerceElementType\r\n            Creating array with element type [System.String] and 1 elements\r\n            Argument type String is not IList, treating this as scalar\r\n            Coercing scalar arg value to type System.String\r\n            COERCE arg to [System.String]\r\n                Parameter and arg types the same, no coercion is needed.\r\n            Adding scalar element of type String to array position 0\r\n        BIND arg [System.String[]] to param [LiteralPath] SUCCESSFUL\r\n    BIND arg [0 0 0 0 0 0 0 0 0 0] to parameter [Value]\r\n        COERCE arg to [System.Object[]]\r\n            Trying to convert argument value from System.Management.Automation.PSObject to System.Object[]\r\n            ENCODING arg into collection\r\n            Binding collection parameter Value: argument type [PSObject], parameter type [System.Object[]], collection type Array, element type [System.Object], coerceElementType\r\n            Arg is IList with 10 elements\r\n            Creating array with element type [System.Object] and 10 elements\r\n            Argument type System.Management.Automation.PSObject is IList\r\n            COERCE collection element from type Byte to type System.Object\r\n            COERCE arg to [System.Object]\r\n                Parameter and arg types the same, no coercion is needed.\r\n            Adding element of type Byte to array position 0\r\n            COERCE collection element from type Byte to type System.Object\r\n            COERCE arg to [System.Object]\r\n                Parameter and arg types the same, no coercion is needed.\r\n            Adding element of type Byte to array position 1\r\n            COERCE collection element from type Byte to type System.Object\r\n            COERCE arg to [System.Object]\r\n                Parameter and arg types the same, no coercion is needed.\r\n            Adding element of type Byte to array position 2\r\n            COERCE collection element from type Byte to type System.Object\r\n            COERCE arg to [System.Object]\r\n                Parameter and arg types the same, no coercion is needed.\r\n            Adding element of type Byte to array position 3\r\n            COERCE collection element from type Byte to type System.Object\r\n            COERCE arg to [System.Object]\r\n                Parameter and arg types the same, no coercion is needed.\r\n            Adding element of type Byte to array position 4\r\n            COERCE collection element from type Byte to type System.Object\r\n            COERCE arg to [System.Object]\r\n                Parameter and arg types the same, no coercion is needed.\r\n            Adding element of type Byte to array position 5\r\n            COERCE collection element from type Byte to type System.Object\r\n            COERCE arg to [System.Object]\r\n                Parameter and arg types the same, no coercion is needed.\r\n            Adding element of type Byte to array position 6\r\n            COERCE collection element from type Byte to type System.Object\r\n            COERCE arg to [System.Object]\r\n                Parameter and arg types the same, no coercion is needed.\r\n            Adding element of type Byte to array position 7\r\n            COERCE collection element from type Byte to type System.Object\r\n            COERCE arg to [System.Object]\r\n                Parameter and arg types the same, no coercion is needed.\r\n            Adding element of type Byte to array position 8\r\n            COERCE collection element from type Byte to type System.Object\r\n            COERCE arg to [System.Object]\r\n                Parameter and arg types the same, no coercion is needed.\r\n            Adding element of type Byte to array position 9\r\n        BIND arg [System.Object[]] to param [Value] SUCCESSFUL\r\nBIND POSITIONAL cmd line args [Add-Content]\r\nBIND cmd line args to DYNAMIC parameters.\r\n    DYNAMIC parameter object: [Microsoft.PowerShell.Commands.FileSystemContentWriterDynamicParameters]\r\n    BIND NAMED args to DYNAMIC parameters\r\n        BIND arg [True] to parameter [AsByteStream]\r\n            COERCE arg to [System.Management.Automation.SwitchParameter]\r\n                Parameter and arg types the same, no coercion is needed.\r\n            BIND arg [True] to param [AsByteStream] SUCCESSFUL\r\n    BIND POSITIONAL args to DYNAMIC parameters\r\nMANDATORY PARAMETER CHECK on cmdlet [Add-Content]\r\nCALLING BeginProcessing\r\nCALLING EndProcessing\r\n```",
      "created_at": "2021-04-09T10:17:42Z",
      "updated_at": "2021-04-09T10:17:42Z"
    },
    {
      "author": "237dmitry",
      "author_association": "NONE",
      "body": "Is this correct or not I don't know . For example we have two binary files 1.bin and 2.bin, we want to concatenate them to 3.bin:\r\n```powershell\r\nNew-PSDrive -Name test -PSProvider filesystem -Root .\r\nNew-Item 3.bin\r\n${test:3.bin} = ${test:1.bin} + ${test:2.bin}\r\nRemove-PSDrive test\r\n```\r\nI was trying with two 32Mb empty files. It took ~600 milliseconds, the result file was exactly 64Mb.",
      "created_at": "2021-04-09T13:56:49Z",
      "updated_at": "2021-04-09T13:56:49Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "You can do a similar thing with any named drives, so I think that should work? `${c:\\test\\file.bin}` is also a valid query in that syntax (on Windows, anyway).\r\n\r\nNot exactly the most well known workaround, but if it works, that's pretty good!",
      "created_at": "2021-04-09T14:01:05Z",
      "updated_at": "2021-04-09T14:01:18Z"
    },
    {
      "author": "237dmitry",
      "author_association": "NONE",
      "body": "> You can do a similar thing with any named drives\r\n\r\nYes, but only in Windows. The most interesting thing about this approach is that you can work as with typed variables:\r\n```\r\n> Get-Content 1.txt\r\n1\r\n\r\n> [int] ${c:1.txt} += 1\r\n> Get-Content 1.txt\r\n2\r\n\r\n> ${c:1.txt} += 1\r\n> Get-Content 1.txt\r\n21\r\n\r\n> [array] ${c:1.txt} += 1\r\n> Get-Content 1.txt\r\n21\r\n1\r\n```",
      "created_at": "2021-04-09T14:12:28Z",
      "updated_at": "2021-04-09T14:12:28Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Great sleuthing, @powercode.\r\n\r\n@237dmitry, as [discussed only recently](https://github.com/PowerShell/PowerShell/issues/15135#issuecomment-813073197), namespace variable notation with the file-system provider has many limitations, and this case is no exception: `${test:1.bin}` is effectively the same as `Get-Content test:1.bin` / `Get-Content test:3.bin`, i.e it reads and writes _text_ with the default encoding (UTF-8 in PowerShell Core). In other words, this will corrupt your binary files:\r\n\r\n```powershell\r\nNew-PSDrive -Name test -PSProvider filesystem -Root .\r\n# Create 2-byte files containing 0xFF values.\r\n[byte[]] (, 0xff * 2) | Set-Content -AsByteStream 1.bin, 2.bin\r\n${test:3.bin} = ${test:1.bin} + ${test:2.bin}\r\nRemove-PSDrive test\r\nFormat-Hex 3.bin\r\n```\r\n\r\nThe above yields:\r\n\r\n```\r\n          Offset Bytes                                           Ascii\r\n                 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\r\n          ------ ----------------------------------------------- -----\r\n0000000000000000 EF BF BD EF BF BD EF BF BD EF BF BD 0A          \u00ef\u00bf\u00bd\u00ef\u00bf\u00bd\u00ef\u00bf\u00bd\u00ef\u00bf\u00bd\ufffd\r\n```\r\n\r\n* The invalid-as-UTF-8 `0xFF` bytes became (UTF-8-encoded) `\ufffd` characters (the Unicode replacement character, `U+FFFD`)\r\n* A newline was invariably added.",
      "created_at": "2021-04-09T14:15:08Z",
      "updated_at": "2021-04-09T14:20:45Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "What I'm gathering from this issue is that there currently is no good (read: unnecessarily slow/intensive) way to join binary files in PowerShell at all without reaching for .NET methods and manually doing it.\r\n\r\nI would suggest this is probably best resolved by adding a `Join-File` cmdlet with `[string[]] -Path`, `[string] -Destination`, and an optional `-Append` switch. .NET can do this; PowerShell's pipeline semantics get in the way of doing this neatly. We can work around this by adding a cmdlet to bypass the pipeline shenanigans that currently cause issues here.",
      "created_at": "2021-04-09T14:21:21Z",
      "updated_at": "2021-04-09T14:21:21Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@vexx32, while ~~nothing will beat the speed of a native utility~~ [see [below](https://github.com/PowerShell/PowerShell/issues/15188#issuecomment-816951590)] with raw byte handling (`type >>` on Windows, `cat >>` on Unix), the primary problem here is the implementation of `Set-Content` / `Add-Content` with an `[object[]]`-typed `-Value` parameter.\r\n\r\n@powercode, correct me if I'm wrong, but I think that if we made `-Value` just `[object]`, with the cmdlets performing array / enumerable detection internally, the performance benefits of the `[byte[]]` array that `-AsByteStream -Raw` brings could be preserved.\r\n\r\n",
      "created_at": "2021-04-09T14:25:39Z",
      "updated_at": "2021-04-09T20:27:00Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Of course, that doesn't preclude _also_ introducing a `Join-File` utility, which sounds like a good idea.",
      "created_at": "2021-04-09T14:35:50Z",
      "updated_at": "2021-04-09T14:35:50Z"
    },
    {
      "author": "User843212",
      "author_association": "NONE",
      "body": "mklement0\" brought me to this idea:\r\n$Segments | ForEach-Object { Get-Content $_ **-Encoding 1252** | Add-Content \"Video.ts\" **-Encoding 1252**\r\n\r\nThis works only almost correctly because every '\"CR\" 0xD' is translated to \"CR/LF\" '0xD/'0xA'.\r\nUsing \"Add-Content\" with \"**-NoNewline**\" removes every '0xD'.\r\nIs there a convenient way to not translate a CR into Windows style?",
      "created_at": "2021-04-09T15:54:05Z",
      "updated_at": "2021-04-09T15:58:15Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Good point, @User843212, that should work, though I recommend `-Encoding 28591`, i.e. ISO-8859-1, given that it it is a true subset of Unicode (unlike Windows-1252). You can avoid the newline problem with `Get-Content -Raw` , which reads the file content as a _single, multiline string_, and `Add-Content -NoNewLine`, which prevents the addition of a trailing newline.\r\n\r\nIn other words:\r\n\r\n```powershell\r\n$Segments | ForEach-Object { \r\n  Get-Content $_ -Raw -Encoding 28591 | Add-Content \"Video.ts\" -NoNewLine -Encoding 28591 \r\n}\r\n```",
      "created_at": "2021-04-09T16:11:33Z",
      "updated_at": "2021-04-09T16:14:04Z"
    },
    {
      "author": "User843212",
      "author_association": "NONE",
      "body": "@mklement0 - it (seems to) works fine.  Very well done!\r\nIn a first attempt I had forgotten the \"-Raw\" argument and I wonder that \"-Raw\" works together with \"-Encoding\".\r\nI thought \"-Raw\" forbids \"-Encoding\" or at least makes it being ignored\r\n\r\nAnd what is even more impressive is the timing!\r\n\r\n...  { Get-Content $_ -Raw -Encoding ISO-8859-1 | Add-Content \"Video.ts\" -Encoding ISO-8859-1 -NoNewline }\r\nTotalSeconds 4,7 (instead of the previous best value of 14 - 381 segment files added up to 550MB )\r\n\r\n",
      "created_at": "2021-04-09T17:24:39Z",
      "updated_at": "2021-04-09T17:41:34Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Glad to hear it, @User843212. It should work robustly, becaus all byte values are valid code points in ISO-8859-1 (`-Encoding 28591`).\r\n\r\nIt is certainly a pragmatic solution, but it's important to note:\r\n\r\n* The file size will _double_ in memory, as the `[byte]` values become `[char]` instances, which are in effect `[uint16]` values representing UTF-16 code units. In effect, a NUL byte is inserted after every byte in the input array.\r\n\r\n* The character decoding and encoding that is involved in textual operations slows things down - although given the current suboptimal `Add-Content` implementation, it is still much faster than with `-AsByteStream`.\r\n\r\nHowever, with only a bit of .NET-fu you can avoid both problems above:\r\n\r\n```powershell\r\n$fs = [IO.File]::OpenWrite((Convert-Path target.bin))\r\n$null = $fs.Seek(0, 'End')\r\n\r\n$Segments | Get-Content -AsByteStream -Raw | ForEach-Object { $fs.Write($_) }\r\n\r\n$fs.Close()\r\n```\r\n\r\nOf course, that shouldn't be necessary, and we should look into improving `Set-Content` / `Add-Content -AsByteStream`.\r\n\r\n",
      "created_at": "2021-04-09T18:25:01Z",
      "updated_at": "2021-04-09T18:25:01Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "And, yes, the name of the `-Raw` switch is unfortunate, because it suggests raw byte handling, whereas all it does is read the file _as a whole_ (as a single _string_ by default, as a single `[byte[]]` array with `-AsByteStream`). Renaming it to something like `-Whole` has been suggested, but was turned down (see #7715).",
      "created_at": "2021-04-09T18:33:26Z",
      "updated_at": "2021-04-09T18:33:26Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I've refined the benchmarks to more clearly show the impact of the `Add-Content` / `Set-Content -AsByteStream` implementation and the massive performance penalty it occurs.\r\n\r\n.NET solutions - both pure and in combination with `Get-Content -AsByteStream -Raw` - are also included, which perform best overall, and about the same between them.\r\n\r\nThe benchmarks  also include a call to `cmd /c 'type >>'` on Windows, and to `sh -c 'cat >>'` on Unix;\r\nCalling the native shell executable is necessary for the raw byte handling of `>>`:\r\n  * On Unix, at least with the 32MB files, a `cat >>` solution is actually slower than a .NET solution, though not by much, which I presume is in part due to the additional startup cost of the `sh` child process.\r\n  * On Windows, `type >>` is suprisingly slow and not worth considering.\r\n\r\nWhile the `-Encoding 28591` workaround performs acceptably (and certainly far outperforms the `Add-Content -AsByteStream` solutions), the .NET-based/-assisted real byte solutions perform noticeably better (although the factor differs by platform), and have the added advantage of not doubling the size of the file content in memory.\r\n\r\n`Get-Content -AsByteStream -ReadCount 0` is remarkably slow, much slower than `Get-Content -ReadCount 0`, i.e. getting all _lines_ as single array.\r\n(`Get-Content -AsByteStream` with neither `-ReadCount 0` nor `-Raw` wasn't included in the benchmarks, because it results in prohibitively slow byte-by-byte streaming through the pipeline.)\r\n\r\n---\r\n\r\nResults, based on 32MB test files (absolute numbers aren't important, but the `Factor` column is):\r\n\r\n* On Windows 10 20H2, PowerShell Core 7.2.0-preview.4\r\n\r\n![image](https://user-images.githubusercontent.com/588825/114234894-61f66000-994d-11eb-96d6-deb7deabe168.png)\r\n\r\n* On macOS 10.15.7 with PowerShell Core 7.2.0-preview.4:\r\n\r\n![image](https://user-images.githubusercontent.com/588825/114234870-5dca4280-994d-11eb-9171-6983130266a9.png)\r\n\r\n<details>\r\n<summary>Benchmark source code:</summary>\r\n\r\n* **Note**: The script downloads and defines benchmark function `Time-Command` from [this Gist](https://gist.github.com/mklement0/9e1f13978620b09ab2d15da5535d1b27), after prompting for confirmation.\r\n\r\n```powershell\r\nWrite-Verbose -vb 'Setting up...'\r\n\r\n# Download and define function `Time-Command` on demand (will prompt).\r\nif (-not (Get-Command -ea Ignore Time-Command)) {\r\n  $gistUrl = 'https://gist.github.com/mklement0/9e1f13978620b09ab2d15da5535d1b27/raw/Time-Command.ps1'\r\n  if ((Read-Host \"`n====`n  OK to download and define benchmark function ``Time-Command`` from Gist ${gistUrl}?`n=====`n(y/n)?\").Trim() -notin 'y', 'yes') { Write-Warning 'Aborted.'; exit 2 }\r\n  Invoke-RestMethod $gistUrl | Invoke-Expression 3>$null\r\n  if (-not ${function:Time-Command}) { exit 2 }\r\n}\r\n\r\nPush-Location ('temp:/', \"$env:TEMP\")[$env:OS -eq 'Windows_NT'] -ea Stop\r\n\r\n# Create files to serve as the target and the file to add to it.\r\n$fileSize = 32mb\r\n$bytes = [byte[]]::new($fileSize)\r\n$dir = $PWD.ProviderPath\r\n[IO.File]::WriteAllBytes(\"$dir/add.bin\", $bytes)\r\n[IO.File]::WriteAllBytes(\"$dir/target.bin\", $bytes)\r\n# Create a copy of the original target to restore it betwen runs.\r\n[IO.File]::WriteAllBytes(\"$dir/original.bin\", $bytes)\r\n\r\n# Warm up the file cache to level the playing field.\r\n$null, $null, $null = (Get-Content -Raw -AsByteStream original.bin), (Get-Content -Raw -AsByteStream target.bin), (Get-Content -Raw -AsByteStream add.bin)\r\n\r\n# Use the following inside blocks to output the resulting file size for verification, if needed:\r\n#    (Get-Item target.bin).Length / 1mb | Write-Verbose -vb\r\n\r\n# Script block for use with ForEach-Object for appending bytes via .NET\r\n$sbAppend = {\r\n  $fs = [IO.File]::OpenWrite((Convert-Path target.bin))\r\n  $null = $fs.Seek(0, 'End')\r\n  $fs.Write([byte[]] $_)\r\n  $fs.Close()\r\n}\r\n\r\n# Script block for restoring the original target file to prevent it from growing too large,\r\n# executed between commands - these timings will be filtered out.\r\n$sbRestoreTargetFile = { if ((Get-Item target.bin).Length -gt $fileSize) { Copy-Item original.bin target.bin } }\r\n\r\nWrite-Verbose -vb 'Running benchmarks (2 groups; will take minutes)...'\r\n\r\nWrite-Verbose -vb '--- 1 of 2: READING ONLY'\r\n\r\nTime-Command -Count 3 `\r\n{ # TEXT: Get-Content ONLY: -ReadCount 0 -Encoding 28591 (not truly byte-preserving)\r\n  $null = Get-Content add.bin -ReadCount 0 -Encoding 28591\r\n},\r\n{ # TEXT: Get-Content ONLY: -Raw -Encoding 28591\r\n  $null = Get-Content add.bin -Raw -Encoding 28591\r\n},\r\n{ # BINARY: Get-Content ONLY: -AsByteStream -ReadCount 0\r\n  $null = Get-Content add.bin -AsByteStream -ReadCount 0\r\n},\r\n{ # BINARY: Get-Content ONLY: -AsByteStream -Raw\r\n  $null = Get-Content add.bin -AsByteStream -Raw\r\n} | Select-Object Factor, Secs*, Command | Out-Host\r\n# !! Byte-by-byte streaming is PROHIBITIVELY SLOW, so not worth including in the test.\r\n# { # BINARY: Get-Content ONLY: -AsByteStream only (streaming bytes)\r\n#   $null = Get-Content add.bin -AsByteStream\r\n# } \r\n\r\n\r\nWrite-Verbose -vb '--- 2 of 2: READING & APPENDING'\r\n\r\n$timings = Time-Command -Count 3 `\r\n{ # TEXT: Get-Content+Add-Content: -ReadCount 0, pipeline (not truly byte-preserving)\r\n  Get-Content add.bin -ReadCount 0 -Encoding 28591 | Add-Content target.bin -Encoding 28591 \r\n},\r\n$sbRestoreTargetFile, \r\n{ # TEXT: Get-Content+Add-Content: -Raw, pipeline\r\n  Get-Content add.bin -Raw -Encoding 28591 | Add-Content target.bin -NoNewLine -Encoding 28591 \r\n},\r\n$sbRestoreTargetFile,\r\n{ # TEXT: Get-Content+Add-Content: -ReadCount 0, argument (not truly byte-preserving)\r\n  Add-Content target.bin -NoNewLine -Encoding 28591 -Value (Get-Content add.bin -ReadCount 0 -Encoding 28591)\r\n},\r\n$sbRestoreTargetFile,\r\n{ # TEXT: Get-Content+Add-Content: -Raw, argument\r\n  Add-Content target.bin -Encoding 28591 -NoNewLine -Value (Get-Content add.bin -Raw -Encoding 28591)\r\n},\r\n$sbRestoreTargetFile,\r\n{ # BINARY: Native utility: cmd /c 'type >>' or sh -c 'cat >>'\r\n  if ($env:OS -eq 'Windows_NT') {\r\n    cmd /c 'type add.bin >> target.bin'\r\n  } else {\r\n    sh -c 'cat add.bin >> target.bin'\r\n  }\r\n},\r\n$sbRestoreTargetFile,\r\n{ # BINARY: pure .NET:\r\n  $fs = [IO.File]::OpenWrite((Convert-Path target.bin))\r\n  $null = $fs.Seek(0, 'End')\r\n  $fs.Write(\r\n    [IO.File]::ReadAllBytes((Convert-Path add.bin))\r\n  )\r\n  $fs.Close()\r\n},\r\n$sbRestoreTargetFile,\r\n{ # BINARY: Get-Content+.NET: -AsByteStream -ReadCount 0\r\n  Get-Content add.bin -AsByteStream -ReadCount 0 | ForEach-Object $sbAppend\r\n},\r\n$sbRestoreTargetFile,\r\n{ # BINARY: Get-Content+.NET: -Raw\r\n  Get-Content add.bin -AsByteStream -Raw | ForEach-Object $sbAppend\r\n},\r\n$sbRestoreTargetFile,\r\n{ # BINARY: Get-Content+Add-Content: -AsByteStream -ReadCount 0, pipeline\r\n  Get-Content add.bin -AsByteStream -ReadCount 0 | Add-Content target.bin -AsByteStream\r\n},\r\n$sbRestoreTargetFile,\r\n{ # BINARY: Get-Content+Add-Content: -AsByteStream -Raw, pipeline\r\n  Get-Content add.bin -AsByteStream -Raw | Add-Content target.bin -AsByteStream\r\n},\r\n$sbRestoreTargetFile,\r\n{ # BINARY: Get-Content+Add-Content: -AsByteStream -ReadCount 0, argument\r\n  Add-Content target.bin -AsByteStream -Value (Get-Content add.bin -AsByteStream -ReadCount 0)\r\n},\r\n$sbRestoreTargetFile,\r\n{ # BINARY: Get-Content+Add-Content: -AsByteStream -Raw, argument\r\n  Add-Content target.bin -AsByteStream -Value (Get-Content add.bin -AsByteStream -Raw)\r\n} | Where-Object Command -notmatch 'Copy-Item'\r\n\r\n# Because the $sbRestoreTargetFile were included in the timings, the .Factor column values\r\n# are off, which we must correct now.\r\n$minTiming = ($timings.Factor | Measure-Object -Minimum).Minimum\r\n\r\n# Output with the corrected factors.\r\n$timings | Select-Object @{ n='Factor'; e={ '{0:N2}' -f ($_.Factor / $minTiming) } }, Secs*, Command\r\n\r\n# Clean up.\r\nRemove-Item original.bin, add.bin, target.bin\r\n\r\nPop-Location\r\n```\r\n</details>",
      "created_at": "2021-04-09T20:23:02Z",
      "updated_at": "2021-04-09T20:31:16Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "After emerging from this remarkably deep rabbit hole, my conclusions are:\r\n\r\n* `Set-Content` / `Add-Content` with `-AsByteStream` should be able to use `[byte[]]` arrays as input as-is, for vastly improved performance. Making the `-Value` parameter `[object]` rather than its current type, `[object[]]`, may be the key.\r\n\r\n\r\n* `Get-Content -AsByteStream -ReadCount <n>` could use optimization too.\r\n\r\n",
      "created_at": "2021-04-09T20:29:53Z",
      "updated_at": "2021-04-09T20:29:53Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This issue has been marked as answered and has not had any activity for **1 day**. It has been closed for housekeeping purposes.",
      "created_at": "2021-04-11T00:00:04Z",
      "updated_at": "2021-04-11T00:00:04Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 I agree that it could be solved by changing the parameter type.\r\n\r\nThen logic within get-content could be used to determine the most efficient way to handle the content passed to the cmdlet. The main issue would be to ensure compatibility with the current implementation.",
      "created_at": "2021-04-12T08:25:46Z",
      "updated_at": "2021-04-12T08:25:46Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @powercode  - please see #15208.",
      "created_at": "2021-04-12T22:46:29Z",
      "updated_at": "2021-04-12T23:02:31Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "As for improving the performance of `-ReadCount <n>` with `Get-Content -AsByteStream`, see #15209",
      "created_at": "2021-04-13T00:01:18Z",
      "updated_at": "2021-04-13T00:01:18Z"
    }
  ],
  "created_at": "2021-04-08T17:37:57Z",
  "labels": [
    "Issue-Question",
    "Resolution-Answered"
  ],
  "number": 15188,
  "state": "closed",
  "title": "Concatenating files with >> Get-Content | Add-Content << fails?",
  "updated_at": "2021-04-13T00:01:18Z"
}