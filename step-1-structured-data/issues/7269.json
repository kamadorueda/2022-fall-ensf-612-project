{
  "_url": "https://github.com/PowerShell/PowerShell/issues/7269",
  "author": "KirkMunro",
  "body": "This is a long-time pet peeve of mine.\r\n\r\nYou're writing a script. You want to debug it. You set a breakpoint on a line in your script with a command that comes from a script module that is not loaded yet. You hit the breakpoint, which happens before the command is executed. You press F11 to step in, and.......you find yourself stepping through your module manifest?\r\n\r\nThis happens because the module manifest is technically PowerShell (although it is restricted language), and since the module hasn't loaded yet, it loads, which runs through the manifest, so you get to step through it.\r\n\r\nSteps to reproduce\r\n------------------\r\n\r\nCreate the following file at path C:\\test.ps1:\r\n\r\n```\r\nFind-Module foo\r\n\r\n'Hello'\r\n```\r\n\r\nNow run the following\r\n```powershell\r\nSet-PSBreakpoint -Script C:\\test.ps1 -Line 1\r\n. C:\\test.ps1\r\n```\r\n\r\nOnce you are at that breakpoint, press s to \"step into the Find-Module command\". This will step you into the module manifest for PowerShellGet instead. From there you need to press o to step out of the manifest, and into the Find-Module command in the psm1 file.\r\n\r\nExpected behavior\r\n-----------------\r\n\r\nStepping into a module manifest is pretty much useless. There needs to be a way to step into a function in an unloaded module without going through the manifest first. If we must keep it, then we need a way to mark a manifest with the DebuggerHidden attribute (which currently is not possible because you can only apply that attribute when you are using CmdletBinding with a param block, and the param block is not allowed in the restricted manifest language). If we're in agreement that it is indeed useless, then treat all manifest files as debugger hidden and bring people to the location they were expecting when they stepped into the function that their breakpoint was on.\r\n\r\nActual behavior\r\n---------------\r\n\r\nAs described above, the debugger takes you through the manifest.\r\n\r\nEnvironment data\r\n----------------\r\n\r\n```powershell\r\n> $PSVersionTable\r\nName                           Value\r\n----                           -----\r\nPSVersion                      6.0.0\r\nPSEdition                      Core\r\nGitCommitId                    v6.0.0\r\nOS                             Microsoft Windows 10.0.17692\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@PaulHigin Care to share your thoughts on this? Since I originally logged this issue, I've been thinking that manifests, which only allow for a handful of variables as well as Import-LocalizedData, ConvertFrom-StringData, Write-Host, Out-Host, and Join-Path should use the DebuggerHidden attribute. There's really not much to debug, if anything at all, and it would be great if the debugger would simply ignore them when scripters step through their code.\r\n\r\nThe current behavior (allowing the debugger to step into the manifest) pretty much makes the debugging experience unusable. Every time I step into a command from a module that isn't loaded, and end up in the manifest, I quickly stop what I was doing, make sure the module was loaded, and then go back to my debugging, because you can't avoid stepping through the entire manifest if you unintentionally step into it (and that can take a very long time for manifests that have a lot of exports). I'd like to correct the behavior so that the debugger simply skips over manifests entirely.",
      "created_at": "2018-11-08T13:19:11Z",
      "updated_at": "2019-09-12T18:56:13Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "This seems reasonable to me. I also think that the attribute could be applied to all `psd1` files, not just module manifests.\r\n\r\n`DebuggerStepThrough` might be more appropriate on the off chance that you really do want to debug by setting a breakpoint, or perhaps step into code that is called from the manifest.",
      "created_at": "2018-11-08T16:32:19Z",
      "updated_at": "2018-11-08T16:32:19Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for that suggestion @lzybkr. I agree this would be useful for all psd1 files, and will implement it that way.\r\n\r\nAs for the suggestion about `DebuggerStepThrough`vs `DebuggerNotUserCode`, looking through PowerShell Core it seems that DebuggerNotUserCode isn't implemented/supported right now, unless I'm missing something. That surprises me a little because I thought we had support for 3 debugger attributes (DST, DH, and DNUC).",
      "created_at": "2018-11-08T19:05:05Z",
      "updated_at": "2018-11-08T19:05:05Z"
    },
    {
      "author": "PaulHigin",
      "author_association": "COLLABORATOR",
      "body": "I agree with @lzybkr.  And overall I agree this will improve debugging experience.",
      "created_at": "2018-11-08T22:59:24Z",
      "updated_at": "2018-11-08T22:59:24Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "After spending some time working on this issue, I've come to the conclusion that the debugger attributes don't work as they should today (I already knew this, really, but not to the extent that I know now), and there are a number of bugs that I'd like to address here. Some of these bugs get in the way of this proposed change, and I've wanted to dig in here for a while (I've run into some of these issues during presentations and meant to come back and figure out why), so now's as good a time as any.\r\n\r\n@lzybkr and @PaulHigin, I could really use your thoughts here, so if you can go through the details below and let me know if I'm missing something or if there is something you're not in agreement with, I would appreciate it.\r\n\r\nThe point of this exercise (and this issue I logged was just a very small part of it) is to enable effective debugging. As someone who uses the PowerShell debugger quite a bit, the way it works today is not very effective and I would like to remedy that, which will require more changes than what I mentioned above, because the above changes are blocked by the issues listed below, so a deeper analysis is necessary.\r\n\r\n## Current debugger attribute functionality in PowerShell 6.1\r\n\r\nFor reference, a lot of what I have been reading on this subject is documented [here](https://docs.microsoft.com/en-us/visualstudio/debugger/just-my-code?view=vs-2017#BKMK__NET_Framework_Just_My_Code).\r\n\r\n### DebuggerHidden (DH)\r\n\r\n- Applies always, even if Just My Code (JMC) is turned off (more on JMC below)\r\n- Step into is treated as step over\r\n- Breakpoints not triggerable\r\n- Shows up in call stack\r\n    - BUG: according to DH docs in MSDN, DH frames should not appear in the call stack at all\r\n    - FIX: identify and hide DH frames from the call stack, since they are truly meant to be internal/hidden functionality, and not for users to see\r\n- Examples where this would be used: low-level formatting code that ships with a module or with PowerShell itself (i.e. format.ps1xml extensions), or PowerShell code invoked from a compiled executable (exe or dll) that is meant to be internal, and not visible to end users at all\r\n\r\n### DebuggerStepThrough (DST)\r\n\r\n- Step into is treated as step over\r\n    - LEGACY: you can step into DST blocks in PowerShell 5.1, but that's not right either\r\n    - BUG: Step into should be treated as step through, stopping on the first command that is not in a script block with DH or DST\r\n    - FIX: when stepped into, the debugger should walk the code until it finds an invoked block that does not have one of these debugger attributes attached it it, and step into that code (this is what the name of this attribute means)\r\n- Breakpoints always triggerable\r\n    - DESIGN ISSUE: according to docs, breakpoints should not always be triggerable in DST blocks; instead, they should only be triggerable when JMC is disabled, so that users can debug code they didn't write if/when they need to (but not internal DH code, that's off limits); as things stand today, users can not debug as effectively because BPs are always triggerable in non-user code, even when this attribute is applied, and when you ship code, you want users to work with it as a black box by default, only being able to hit breakpoints in code that isn't theirs if they explicitly do something to make that happen\r\n    - FIX: add Just My Code (JMC) support to PowerShell, as a debugger parameter that is on ($true) by default but can be turned off (set to $false), and have BPs triggerable in DST blocks only if JMC is turned off (all BP types)\r\n    - ALT FIX: if having JMC supported as a feature is not desirable, only explicit breakpoints (ie. line breakpoints) should be triggerable (since this code is not owned by the scripter, they should have to explicitly place a BP in the code in order for it to trigger -- this design keeps variable and command breakpoints highly effective, and only designed for use with JMC, without having to add a JMC option)\r\n    - ALT FIX 2: add JMC, but instead of having it be a JustMyCode boolean property, have it be an bitwise enum flag called NonUserCodeBreakpoints, allowing users to control what is allowed (options would include Disabled, meaning all non-user code breakpoints would be skipped, or a combination of Line, Command, and Variable enumeration values to identify which types of BPs could be triggered in non-user code)\r\n    - THOUGHTS: There are pros/cons to each proposed fix. The first proposal would mean any BP could be triggerable in DST blocks, but adds an additional flag that must be disabled to allow that to happen. The second proposal avoids the need for a flag, but makes it impossible to trigger command/variable BPs in DST blocks. The third proposal provides the most control, satisfying both of the first two proposals, but needs a little more explanation/documentation. My preference is for the third option (ALT FIX 2), because it allows users to control what types of breakpoints should be supported in non-user code (which could be their own released modules if they are debugging a reported issue), without having to modify the code. If that is not desirable, then I would vote for the first option, so that all BP types could be turned on or off in non-user code.\r\n- Shows up in call stack like any other command\r\n    - BUG: DST docs state that DST frames should appear in the call stack as \"[external]\", visible via double-click, but otherwise not visible\r\n    - FIX: render DST frames in the call stack as \"[external]\" with no arguments or location, unless Get-PSCallStack is invoked with a new -Force parameter, in which case users get to see DST frames.\r\n- Examples where this would be used: your own commands that you have already debugged and don't want to step through unless you go out of your way to enable breakpointing in that code; your own commands that you've already debugged that invoke script block parameters; once you've debugged the commands themselves, you can add this attribute so that you can step through other code with the debugger without going through code that you don't need to go through; module manifests and other psd1 files that are invoked (this is done automatically for you for module manifests and data files in PowerShell)\r\n\r\n### DebuggerNonUserCode (DNUC)\r\n\r\n- Internally treated as DST today\r\n    - DESIGN ISSUE: MSDN documentation states the following:\r\n        > The debugger behavior when the DebuggerNonUserCodeAttribute is present is _similar_ to using a combination of the DebuggerHiddenAttribute attribute, which hides the code from the debugger, and the DebuggerStepThroughAttribute attribute, which tells the debugger to step through, rather than into, the code it is applied to.\r\n\r\n        This clearly identifies a difference between DNUC and DST, and the current implementation ignores this.\r\n    - FIX: Like DH, DNUC frames should not appear in the call stack, and like DST, breakpoints should be triggerable in DNUC blocks based on JMC settings, and users should be able to step through (not into) the DNUC blocks like they can with DST. Essentially DNUC is DST, but with the internals hidden from the call stack.\r\n- Examples where this would be used: modules that you ship (sign and publish in the PowerShell Gallery)\r\n\r\n### All Debugger Attributes\r\n\r\n- Users must re-apply them in any nested functions or script blocks that are invoked internally\r\n    - DESIGN ISSUE: This results in bugs, even in PowerShell, because of scenarios where you need to invoke code in a new scope.\r\n    - FIX: Whenever a debugger attribute is applied on a block of code, apply it recursively to all nested script blocks and functions as well (i.e. apply to any script blocks or functions that are defined within that block of code, recursively -- this allows for easy attribution of an entire module by setting up the attribute in script module scope)\r\n\r\n### Other Issues\r\n\r\nWhile reviewing all of this, I discovered that Get-PSCallStack returns a bunch of StringBuilder data in the Arguments property in PowerShell 6.1. That's a bug that needs fixing as well.\r\n\r\n### Outstanding questions\r\n\r\nShould DNUC be something users explicitly opt into, which would be onerous/annoying, or should this be automatic for installed modules that come from the gallery? I like automatic for this for installed modules, because they obviously are non-user code as far as the local machine is concerned. With JMC options added to PowerShell, users can still debug such modules, but only if they opt-in, which allows such modules to behave more like binary modules do -- black boxes that come with a bunch of commands you can use, with the benefit that you can view the source and debug if you would like to.\r\n\r\nShould DH treat step into as step through, so that if it internally invokes code that was given to it (a script block, for example), that it can do so without exposing that to the end user? I'm on the fence on this one. On one hand, if it treats step into as step over, it acts as a bouncer, keeping the debugger out of the code completely, regardless of what is invoked internally. On the other hand, if it treats step into as step through, it allows users to invoke something that internally invokes a script block they provide to it without exposing the invocation on the call stack and without allowing debugging.\r\n\r\nWhat about classes? Does PowerShell use these attributes with classes today? I haven't dug into how these attributes work with classes/methods/properties in PowerShell at all yet, but from the outside I think the exact same behavior would apply, and the only decisions would be whether or not these attributes can be applied on classes, methods, properties, accessors, etc.\r\n\r\n### End result\r\n\r\nThe end result of these changes should result in debugger attributes behaving as follows:\r\n\r\n||Step into|Breakpoints triggerable|Call stack visibility|\r\n|--|--|--|--|\r\n|**DebuggerHidden**|Treated as step over (or through, see questions)|Never|None|\r\n|**DebuggerNonUserCode**|Treated as step through <sup>1</sup>|Depends on JMC settings <sup>2</sup>|None|\r\n|**DebuggerStepThrough**|Treated as step through <sup>1</sup>|Depends on JMC settings <sup>2</sup>|Visible when -Force'd <sup>3</sup>|\r\n\r\n<sup>1</sup> `t, stepThrough` will be added as a new debugger option, allowing users to get into nested code more efficiently from the debugger.\r\n<sup>2</sup> New option added to `ScriptDebugger` class.\r\n<sup>3</sup> New parameter added to `Get-PSCallStack` cmdlet and related method.\r\n\r\nThat's enough of my thoughts on this for now. I'm looking forward to hearing more about the original intent for these attributes in PowerShell and helping figure out how they should be working to enable effective debugging.\r\n",
      "created_at": "2018-11-10T19:32:51Z",
      "updated_at": "2018-11-12T15:56:29Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "That's a lot to discuss, maybe worth an RFC, or maybe this is the RFC?\r\n\r\nSome quick thoughts:\r\n\r\n* What is JMC from the PowerShell point of view? We don't have projects, so it's not clear.\r\n* `Get-CallStack` is used in ways outside of debugging, it's default behavior shouldn't change. Internal debugger use could, but the cmdlet shouldn't.",
      "created_at": "2018-11-12T15:13:31Z",
      "updated_at": "2018-11-12T15:13:31Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "I thought about an RFC for this, given the depth, but it's also a relatively simple set of non-breaking changes to make, and I don't necessarily want to slow down the process (i.e. I'm hoping a few decisions can be made and/or clarifications identified in my analysis, so that I can just get it done).\r\n\r\nIn my mind, JMC from PowerShell is simply a line in the sand between scripts/functions/modules I write (that I want easy debugger access into) and the same that I don't write. If I ship a script/module that someone ends up using, and it's properly tested/debugged, ideally the functions in that module should run as close to compiled cmdlets do as possible, so that my logic does not impact their debugging experience with their own code. Using the debugger attributes, I also have the flexibility to add an attribute to hide some of my own code from the debugger, which I would want to do for modules I have tested as well, so that my debugging experience is optimal when using those commands as well. I think that's a pretty clear line in the sand that can be drawn, implicitly in the case of installed content (scripts/modules), and explicitly everywhere else I want to use it (or just make explicit use mandatory if we must, but there is an opportunity for implicit work here that I really like).\r\n\r\nRegarding `Get-PSCallStack`, how is it used outside of debugging? Profiling? What if the behavior change was only in the default output in the F&O layer, marking certain frames as external? And for hidden frames showing, I wonder if that's a design flaw that should be fixed. Hidden should mean hidden.\r\n\r\n",
      "created_at": "2018-11-12T15:53:49Z",
      "updated_at": "2018-11-12T15:53:49Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "How does PowerShell know it's **your** code? In other words, you need to make an attempt at defining how to implement JMC so we can have a useful discussion about the possible changes.\r\n\r\n> Regarding `Get-PSCallStack` ...\r\n\r\nI believe people have used `Get-PSCallStack` to get a count of the number of scopes, e.g. for use with `Get-Variable -Scope $num`. I feel like I've seen other non-debugging uses too, but I don't recall specifics so I can't say *if* a change would break those use cases.\r\n\r\n",
      "created_at": "2018-11-12T16:24:15Z",
      "updated_at": "2018-11-12T16:24:15Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "I would consider PowerShell code to be \"My Code\" if the following are true:\r\n\r\n1. The code does not belong to an installed package (script or module).\r\n1. The code does not have one of the following debugger attributes set on it: `DebuggerHidden`, `DebuggerStepThrough`, `DebuggerNonUserCode`.\r\n\r\nThat's it. If either of those are false, then it's not my code, in which case the JMC options proposed may allow me to set breakpoints in it and debug it, but only if it's not in a `DebuggerHidden` block of code.\r\n\r\nI was thinking about scopes when you mentioned `Get-PSCallStack` use outside of the debugger, and how they should work with things like `DebuggerHidden` (i.e. should `Get-Variable -Scope 1` return variables in that scope if it uses `DebuggerHidden`? Or should `-Scope 1` be treated as the scope one level higher in that scenario, effectively hiding the frame (my preference).\r\n\r\nPushing the JMC and call stack parts of this aside, something I may work on that can (and should) be fixed is the step through logic (and breakpointing logic for `DebuggerHidden`) so that the debugger ends up where it needs to based on the attributes that are used. None of that is dependent on JMC. JMC really only applies to call stack visibility, influencing when breakpoints work, and applying default debugger attributes. I can probably get away with fixing the step through parts now and then pulling the JMC portions of this discussion into an RFC so that more eyes are on it, gathering more information in the meantime.",
      "created_at": "2018-11-12T17:05:01Z",
      "updated_at": "2018-11-12T17:05:01Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "In an environment like VSCode we have a workspaceFolder.  Any file not under that folder could be considered \"not my code\".  Maybe there could be a call to register a path for what is considered \"my code\". ",
      "created_at": "2018-11-13T03:37:26Z",
      "updated_at": "2018-11-13T03:37:26Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "Maybe. Need to think about profiles (all users profiles are user code, but they're just individual files in folders where there may be non-user code as well). Given how people can put files anywhere though, and organize their system however they like, I think it would be better if products/apps could register a path for what is considered \"**not** my code\" instead. Maybe something like `$env:PSModulePath`, so users could also mark specific paths as not their code if products don't do it themselves (in cases where products install PowerShell scripts/modules outside of PowerShellGet/PackageManagement).",
      "created_at": "2018-11-13T14:57:50Z",
      "updated_at": "2018-11-13T15:00:51Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "I'd rather not have to know where Pester / PSSA is installed.  I mighth have installed it or maybe I'm using the versions installed under the install folder for the PowerShell extension for VSCode.  Also, the PowerShell extension for VSCode could register the workspaceFolder(s) paths and for \"most\" people that would be a sensible default.  \r\n\r\nBTW we do this already to some extent in the extension's debug code.  We \"dim\" stack frames that are from script not under the current workspaceFolder.",
      "created_at": "2018-11-16T01:55:23Z",
      "updated_at": "2018-11-16T01:55:23Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "I'm going to move the discussion about debugger attributes into its own issue.",
      "created_at": "2019-09-12T18:55:13Z",
      "updated_at": "2019-09-12T18:55:13Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "I moved the bulk of the discussion about attributes in general into #10530, so that this issue could be used specifically to discuss hiding manifests from the debugger.",
      "created_at": "2019-09-13T03:06:35Z",
      "updated_at": "2019-09-13T03:06:35Z"
    }
  ],
  "created_at": "2018-07-11T17:03:15Z",
  "number": 7269,
  "state": "open",
  "title": "Module manifests should use DebuggerHidden automatically",
  "updated_at": "2019-09-13T03:06:35Z"
}