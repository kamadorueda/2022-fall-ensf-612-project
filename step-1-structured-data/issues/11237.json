{
  "_url": "https://github.com/PowerShell/PowerShell/issues/11237",
  "author": "mklement0",
  "body": "**Important**:\r\n\r\n* The proposal below is undoubtedly a change that cannot be made without breaking existing code. \r\nHowever, I don't think the existing problems can be fixed while maintaining backward compatibility.\r\nTherefore, use of an implementation of this proposal would have to be on an _opt-in_ basis by future function / script authors, via an [optional feature](https://github.com/PowerShell/PowerShell-RFC/pull/220) or, should there ever be one, a \"vNext\" PowerShell version that is allowed to break backward compatibility in the interest of [fixing many longstanding problems](#6745).\r\n\r\n* This will probably have to become an RFC, if there's sufficient interest - this issue is meant to get the conversion started and gauge that interest.\r\n\r\n# Summary of the new feature/enhancement\r\n\r\nThere are several **problems** with the existing parameter-set handling:\r\n\r\n* In the absence of explicitly designating a _default_ parameter set, PowerShell tries to _infer_ one, but does so inconsistently (#11143) and sometimes incorrectly (#11235).\r\n\r\n* `$PSCmdlet.ParameterSetName`, meant to reflect the parameter set in effect (selected by the combination of arguments and/or pipeline input), obscurely and confusingly reflects `__AllParameterSets` in argument-less invocations or in invocations that comprise parameters without explicit set association.\r\n   * `__AllParameterSets` is also the internal name of the \"meta\" set automatically assigned to parameters without explicit set association, and it signals that a given parameter belongs to _all_ parameter sets (if any exist beyond the implied unnamed one).\r\n  * As such, the name `__AllParameterSets` should be considered an implementation detail, and making it do double duty as the name of the effective set is obscure and confusing.\r\n\r\n* Ill-defined parameter sets do not become apparent until _runtime_, as opposed to _parse time_, including misspelled attribute property names. Problems may not be discovered until later, when a specific combination of arguments and inputs is used on invocation (e.g., unintentionally allowing / disallowing argument-less invocation).\r\n\r\n* Designating an otherwise undefined default parameter set as the default - e.g., `[CmdletBinding(DefaultParameterSetName='PossiblyAccidentalDefault')]` is quietly accepted (and an invocation without arguments or only with parameters not explicitly associated with sets make it the effective on). \r\n   * While this technique is actually currently _required_ to implement a function that explicitly allows passing _no_ arguments alongside parameters with explicit set associations (it is also the easiest way to allow invocations binding all-parameter-sets parameters only), it is non-obvious and brittle.\r\n\r\n* On a minor note, the `Name` suffix in the attribute property names seems unnecessarily verbose (`ParameterSetName`, `DefaultParameterSetName`).\r\n\r\n# Proposed technical implementation details (optional)\r\n\r\n* Enforce the following _at parse time_ to signal that there's a fundamental problem with the function / script that needs resolving, as opposed to the current _situational_ failures that depend on the specifics of a given invocation. This also has the advantage of being able to provide _specific error messages_ with clear _resolution directions_.\r\n\r\n  * If an _explicit parameter set_ is associated with _at least one parameter_, enforce having to explicitly designate a _default_ parameter set in `[CmdletBinding()]`. This avoids the obscurity of the current, situational _inference_ of the default and instead signals explicit intent.\r\n\r\n  * Do not permit designating an undefined parameter set as the default in the `[CmdletBinding()]` attribute - the name must refer to a set named in at least one `[Parameter()]` attribute.\r\n\r\n  * If feasible, ensure up front that there are no unknown / mistyped property names in the `[CmdletBinding()]`, `[Parameter()]`, ... attributes.\r\n\r\n* Make `''` (empty string) the (non)-name for the _implied, unnamed_ parameter set to become effective in argument-less invocations and invocations with all-parameter-sets parameters only. \r\n   * `[CmdletBinding(DefaultParameterSetName='')]` will signal the explicit intent to allow invocations without arguments altogether, as well as invocations comprising all-parameter-sets parameters only.\r\n  * `$PSCmdlet.DefaultParameterSetName` will then reflect `''` (the empty string) in such invocations.\r\n\r\n* Allow omitting the wordy `Name` suffix from the `DefaultParameterSetName` and `ParameterSetName` attribute properties.\r\n\r\n### Example\r\n\r\nConsider a function `Write-Message`, which should wrap `Write-Host` as follows:\r\n\r\n* Print a default message, if no arguments are passed at all.\r\n* If only a `-Message` argument is passed, print that message as-is.\r\nIf one of the mutually exclusive `-AsError` or `-AsWarning` switches is passed, print the (default or explicit) message in a switch-specific color.\r\n\r\n**Current declaration**:\r\n\r\n```powershell\r\nfunction Write-Message {\r\n  # * Without artificially designating a default parameter set, \r\n  #   argument-less and -Message-only invocations don't work.\r\n  # * If  'ArtificalName' happens to be a leftover / mistyped name, you may \r\n  #   accidentally be enabling undesired invocations.\r\n  [CmdletBinding(DefaultParameterSetName = 'ArtificalName')]\r\n  param(\r\n    # Optional message that has a default.\r\n    [string] $Message = 'Completed.',\r\n\r\n    # Note: Whether you use `Mandatory` or not makes no difference here.\r\n    [Parameter(ParameterSetName = 'err')] [switch] $AsError,\r\n    [Parameter(ParameterSetName = 'warn')] [switch] $AsWarning\r\n  )\r\n\r\n  $writeHostArgs = @{ Object = $Message }\r\n\r\n  if ($AsError) { $writeHostArgs.ForegroundColor = 'Red' }\r\n  elseif ($AsWarning) { $writeHostArgs.ForegroundColor = 'Yellow' }\r\n\r\n  Write-Host @writeHostArgs\r\n}\r\n```\r\n\r\n**Declaration with the proposal implemented**:\r\n\r\n```powershell\r\nfunction Write-Message {\r\n  # * Designating '' as the default parameter set unambiguously signals the intent to \r\n  #   allow argument-less and all-parameter-sets-parameters-only invocations.\r\n  # * Any other name would have to refer to a set explicitly mentioned in at least one\r\n  #    [Parameter()] attribute.\r\n  [CmdletBinding(DefaultParameterSet = '')]\r\n  param(\r\n    # Optional message that has a default.\r\n    [string] $Message = 'Completed.',\r\n\r\n    # Note: Whether you use `Mandatory` or not makes no difference here.\r\n    [Parameter(ParameterSet = 'err')] [switch] $AsError,\r\n    [Parameter(ParameterSet = 'warn')] [switch] $AsWarning\r\n  )\r\n\r\n  $writeHostArgs = @{ Object = $Message }\r\n\r\n  if ($AsError) { $writeHostArgs.ForegroundColor = 'Red' }\r\n  elseif ($AsWarning) { $writeHostArgs.ForegroundColor = 'Yellow' }\r\n\r\n  Write-Host @writeHostArgs\r\n}\r\n```\r\n\r\n",
  "closed_at": null,
  "comments": [],
  "created_at": "2019-12-02T19:50:07Z",
  "number": 11237,
  "state": "open",
  "title": "Make parameter sets of advanced functions/scripts more robust and more predictable",
  "updated_at": "2019-12-02T19:50:07Z"
}