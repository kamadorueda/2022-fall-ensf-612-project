{
  "_url": "https://github.com/PowerShell/PowerShell/issues/17701",
  "author": "iRon7",
  "body": "### Summary of the new feature / enhancement\r\n\r\nPowerShell `Write-*` cmdlets are sending information to the related output streams which (all?) are eventually displaying information in a way the end-user would probably prefer to receive it but as a script *developer*, the way this is displayed is often misleading.\r\n\r\nFor a new PowerShell scripter, a known pitfall is the object enrolment were is unclear what type is actually being output from the pipeline in the case of a single item.\r\nAnd there are a lot of different object types that *all* show the same \"**empty**\" result as e.g. `''`, `$Null`, `@()`, `@('')`, `@($Null)`,`@($Null, '')`,\r\n\r\nSee e.g. [`#17683` $null should be indicated by a blank line, especially when within an array](https://github.com/PowerShell/PowerShell/issues/17683).\r\n\r\n\r\n### Proposed technical implementation details (optional)\r\n\r\nIt would be nice if e.g. the `Write-Debug` cmdlet would an addition `-Object` parameter that reveals *developer* information about a specific object.\r\n\r\nCurrently, any argument other than a string provided to the `Write-Object` cmdlet results in an error:\r\n\r\n```PowerShell\r\n$Name  = 'John', 'Doe'\r\nWrite-Debug $Name\r\n```\r\n> **Write-Debug: Cannot convert 'System.Object[]' to the type 'System.String' required by parameter 'Message'. Specified method is not supported.**\r\n\r\nWhat I would like to see instead (as a developer), is a formatted object that doesn't leave any room for misinterpretation (e.g. the same way as it is required to be formatted for the PowerShell engine)\r\n\r\n**Wishful thinking:**\r\n\r\n```PowerShell\r\n$Name  = 'John', 'Doe'\r\nWrite-Debug $Name\r\n'John',\r\n'Doe'\r\n```\r\n\r\n```PowerShell\r\n$Name  = $Null\r\nWrite-Debug $Name\r\n$Null\r\n```\r\n\r\n```PowerShell\r\n$Name  = ''\r\nWrite-Debug $Name\r\n''\r\n```\r\n\r\n```PowerShell\r\n$Name  = @()\r\nWrite-Debug $Name\r\n@()\r\n```\r\n\r\n```PowerShell\r\n$Name  = @('', $Null)\r\nWrite-Debug $Name\r\n@('', $Null)\r\n```\r\n\r\nThis could go as deep as something prototyped here: [ConvertTo-Expression](https://github.com/iRon7/ConvertTo-Expression) which definitely doesn't make it an easy request.\r\n",
  "closed_at": "2022-08-24T10:01:21Z",
  "comments": [
    {
      "author": "fMichaleczek",
      "author_association": "NONE",
      "body": "I think you are asking for new Format-* cmdlets.\r\n\r\nFormat-Hex is nice for string, char and valuetype, but not good with null\r\n\r\nFormat-Custom is nice with object, hashtable and collections.\r\n\r\nA command Format-Pretty should be a good feature.\r\n\r\n```powershell\r\nPS C:\\> $Name  = 'John', 'Doe'\r\nPS C:\\> $Name | Format-Hex\r\n\r\n   Label: String (System.String) <4BDBB0C1>\r\n\r\n          Offset Bytes                                           Ascii\r\n                 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\r\n          ------ ----------------------------------------------- -----\r\n0000000000000000 4A 6F 68 6E                                     John\r\n\r\n   Label: String (System.String) <4A3432CE>\r\n\r\n          Offset Bytes                                           Ascii\r\n                 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\r\n          ------ ----------------------------------------------- -----\r\n0000000000000000 44 6F 65                                        Doe\r\n\r\nPS C:\\> (Get-UICulture).Calendar | Format-Custom -Depth 1\r\n\r\nclass GregorianCalendar\r\n{\r\n  MinSupportedDateTime =\r\n    class DateTime\r\n    {\r\n      Date = 1/1/0001 00:00:00\r\n      Day = 1\r\n      DayOfWeek = Monday\r\n      DayOfYear = 1\r\n      Hour = 0\r\n      Kind = Unspecified\r\n      Millisecond = 0\r\n      Microsecond = 0\r\n      Nanosecond = 0\r\n      Minute = 0\r\n      Month = 1\r\n      Second = 0\r\n      Ticks = 0\r\n      TimeOfDay = 00:00:00\r\n      Year = 1\r\n      DateTime = Monday, January 1, 0001 00:00:00\r\n    }\r\n  MaxSupportedDateTime =\r\n    class DateTime\r\n    {\r\n      Date = 12/31/9999 00:00:00\r\n      Day = 31\r\n      DayOfWeek = Friday\r\n      DayOfYear = 365\r\n      Hour = 23\r\n      Kind = Unspecified\r\n      Millisecond = 999\r\n      Microsecond = 999\r\n      Nanosecond = 900\r\n      Minute = 59\r\n      Month = 12\r\n      Second = 59\r\n      Ticks = 3155378975999999999\r\n      TimeOfDay = 23:59:59.9999999\r\n      Year = 9999\r\n      DateTime = Friday, December 31, 9999 23:59:59\r\n    }\r\n  AlgorithmType = SolarCalendar\r\n  CalendarType = Localized\r\n  Eras =\r\n    [\r\n      1\r\n    ]\r\n\r\n  TwoDigitYearMax = 2029\r\n  IsReadOnly = True\r\n}\r\n```\r\n\r\nThe base serialization is CliXml, if you want to import/export object, you could export and display CliXml.\r\n\r\n```powershell\r\nPS>  (Get-UICulture).Calendar | Export-CliXml -Path $env:TMP/cal.clixml -Depth 1 -Force\r\nPS> Get-Content -Path \"$env:TMP/cal.clixml\"\r\n<Objs Version=\"1.1.0.1\" xmlns=\"http://schemas.microsoft.com/powershell/2004/04\">\r\n  <Obj RefId=\"0\">\r\n    <TN RefId=\"0\">\r\n      <T>System.Globalization.GregorianCalendar</T>\r\n      <T>System.Globalization.Calendar</T>\r\n      <T>System.Object</T>\r\n    </TN>\r\n    <ToString>System.Globalization.GregorianCalendar</ToString>\r\n    <Props>\r\n      <DT N=\"MinSupportedDateTime\">0001-01-01T00:00:00</DT>\r\n      <DT N=\"MaxSupportedDateTime\">9999-12-31T23:59:59.9999999</DT>\r\n      <S N=\"AlgorithmType\">SolarCalendar</S>\r\n      <S N=\"CalendarType\">Localized</S>\r\n      <Obj N=\"Eras\" RefId=\"1\">\r\n        <TN RefId=\"1\">\r\n          <T>System.Int32[]</T>\r\n          <T>System.Array</T>\r\n          <T>System.Object</T>\r\n        </TN>\r\n        <LST>\r\n          <I32>1</I32>\r\n        </LST>\r\n      </Obj>\r\n      <I32 N=\"TwoDigitYearMax\">2029</I32>\r\n      <B N=\"IsReadOnly\">true</B>\r\n    </Props>\r\n  </Obj>\r\n</Objs>\r\n\r\nPS> Import-Clixml  -Path \"$env:TMP/cal.clixml\"\r\n\r\nMinSupportedDateTime : 1/1/0001 00:00:00\r\nMaxSupportedDateTime : 12/31/9999 23:59:59\r\nAlgorithmType        : SolarCalendar\r\nCalendarType         : Localized\r\nEras                 : {1}\r\nTwoDigitYearMax      : 2029\r\nIsReadOnly           : True\r\n\r\n```\r\n",
      "created_at": "2022-07-20T01:46:59Z",
      "updated_at": "2022-07-20T01:46:59Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "@fMichaleczek,\r\n\r\n> I think you are asking for new Format-* cmdlets.\r\n\r\nI guess that is indeed close to what I would like to see, but I do not want to predefine the `<noun>` in the the `Format-*` cmdlet as I have no clue what is in the object in advance (or what went wrong in my script). Take e.g. the [StackOverflow questions concerning \"*You cannot call a method on a null-valued expression*\"](https://stackoverflow.com/search?q=PowerShell+You+cannot+call+a+method+on+a+null-valued+expression). The developers, get a clear error but are still not able to understand the cause of the issue. This is to my opinion because the standard display outputs are generally designed for the end-users (and not for the developers\u00b9). In these outputs there is no easy way to distinguish between a `$Null` and objects as `''`, `@()`, `@('')`, `@($Null)` and `@($Null, '')`. Besides objects are quite flat in the end-users output where it gets even more vague determine value and the type of a property, e.g. `$Object.Property.Method()`, where the `Property` might be unexpectedly `$Null` or something else then imagined.\r\n\r\n<sup>1) Also knowing that there aren't always sophisticated source code editors available in environments as production</sub>\r\n\r\nTake the linked issue  [`#17683` $null should be indicated by a blank line, especially when within an array](https://github.com/PowerShell/PowerShell/issues/17683) as a example, as a developer I would like to be able to reveal the cause what happend here:\r\n\r\n```PowerShell\r\n$a = $Null, 1\r\n$a\r\n1\r\nConvertTo-Expression $a # Could be any statement/cmdlet or even a kind of developer mode\r\n$Null,\r\n1\r\n```\r\n\r\nAlso take the very specific bug(?), I recently reported here: [`#17702` The last cell of an empty column read by ConvertFrom-Csv is inconsistently `$Null`](https://github.com/PowerShell/PowerShell/issues/17702). How would anyone able to easily reveal this?\r\n\r\n```\r\n$Data = ConvertFrom-Csv @'\r\nId,Name,Note\r\n01,John,\r\n02,Jack,\r\n03,Ryan,Just a note\r\n04,Luke,\r\n05,Noah,\r\n'@\r\n\r\nConvertTo-Expression $Data # Could be any statement/cmdlet or even a kind of developer mode\r\n[pscustomobject]@{\r\n    Id = '01'\r\n    Name = 'John'\r\n    Note = ''\r\n},\r\n[pscustomobject]@{\r\n    Id = '02'\r\n    Name = 'Jack'\r\n    Note = ''\r\n},\r\n[pscustomobject]@{\r\n    Id = '03'\r\n    Name = 'Ryan'\r\n    Note = 'Just a note'\r\n},\r\n[pscustomobject]@{\r\n    Id = '04'\r\n    Name = 'Luke'\r\n    Note = ''\r\n},\r\n[pscustomobject]@{\r\n    Id = '05'\r\n    Name = 'Noah'\r\n    Note = $Null      # <-- here is the issue\r\n}\r\n```\r\n\r\nI indeed could also have used [`PSSerializer.Serialize` Method](https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.psserializer.serialize) for this:\r\n\r\n```PowerShell\r\n[System.Management.Automation.PSSerializer]::Serialize($Data)\r\n<Objs Version=\"1.1.0.1\" xmlns=\"http://schemas.microsoft.com/powershell/2004/04\">\r\n  <Obj RefId=\"0\">\r\n    <TN RefId=\"0\">\r\n      <T>System.Object[]</T>\r\n      <T>System.Array</T>\r\n      <T>System.Object</T>\r\n    </TN>\r\n    <LST>\r\n      <Obj RefId=\"1\">\r\n        <TN RefId=\"1\">\r\n          <T>System.Management.Automation.PSCustomObject</T>\r\n          <T>System.Object</T>\r\n        </TN>\r\n        <MS>\r\n          <S N=\"Id\">01</S>\r\n          <S N=\"Name\">John</S>\r\n          <S N=\"Note\"></S>\r\n        </MS>\r\n      </Obj>\r\n      <Obj RefId=\"2\">\r\n        <TNRef RefId=\"1\" />\r\n        <MS>\r\n          <S N=\"Id\">02</S>\r\n          <S N=\"Name\">Jack</S>\r\n          <S N=\"Note\"></S>\r\n        </MS>\r\n      </Obj>\r\n      <Obj RefId=\"3\">\r\n        <TNRef RefId=\"1\" />\r\n        <MS>\r\n          <S N=\"Id\">03</S>\r\n          <S N=\"Name\">Ryan</S>\r\n          <S N=\"Note\">Just a note</S>\r\n        </MS>\r\n      </Obj>\r\n      <Obj RefId=\"4\">\r\n        <TNRef RefId=\"1\" />\r\n        <MS>\r\n          <S N=\"Id\">04</S>\r\n          <S N=\"Name\">Luke</S>\r\n          <S N=\"Note\"></S>\r\n        </MS>\r\n      </Obj>\r\n      <Obj RefId=\"5\">\r\n        <TNRef RefId=\"1\" />\r\n        <MS>\r\n          <S N=\"Id\">05</S>\r\n          <S N=\"Name\">Noah</S>\r\n          <Nil N=\"Note\" />\r\n        </MS>\r\n      </Obj>\r\n    </LST>\r\n  </Obj>\r\n</Objs>\r\n```\r\nBut that method is not easily available, requires knowledge of `xml` *and* the specific PowerShell schema (understanding what e.g. the `Nil` tag means) and quiet difficult to read for a human.\r\n\r\nBasically: to talk to the PowerShell engine, I am required to \"speak **PowerShell**\".\r\nAs a developer, while debugging, I would like to see the engine to be able to respond back in **PowerShell** language.\r\n\r\nAs said before, I realize that a PowerShell *language* serializer is not build without fight (taking issues along with cycled properties and [lose of fidelity](https://github.com/iRon7/ConvertTo-Expression/issues/7) in account) but at the other hand, I think that I have proven with the [ConvertTo-Expression](https://github.com/iRon7/ConvertTo-Expression) script isn't entirely impossible. Besides there are other leverages apart from debugging, a PowerShell *language* serializer lets you easily round-trip objects and could therefore be useful in building Pester scripts, DSC and to [create a Minimal, Reproducible Example](https://stackoverflow.com/help/minimal-reproducible-example)s.\r\n\r\n",
      "created_at": "2022-07-20T08:50:22Z",
      "updated_at": "2022-07-20T15:12:49Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "> `# Could be any statement/cmdlet or even a kind of developer mode`\r\n\r\nSecond thoughts: I think this should actually controlled from a kind of `SupportsDebugging` [cmdlet binding attribute](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_cmdletbindingattribute) which would than also partly cover the pitfall mentioned in #15781 [Strict Write-Output](https://github.com/PowerShell/PowerShell/issues/15781).\r\n\r\nMeaning if the `SupportsDebugging` attribute is supplied to an advanced function and the concerned function is invoked with the common `-Debug` parameter, the objects at the end of the success stream will displayed _in PowerShell notation_ rather than end-user strings.\r\n\r\nThis would imply that most existing cmdlets (that produce objects) might support this `SupportsDebugging` attribute as well in the future. But `write-*` cmdlets should specifically be excluded (except for maybe [`Write-Output`](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/write-output) which -afaik- in fact eventually handles the display output at the end of the pipeline)\r\n\r\n**Wishful thinking:**\r\n\r\n```PowerShell\r\nfunction MyScript {\r\n    [CmdletBinding(SupportsDebugging=$True)]\r\n    Param( \r\n    )\r\n\r\n    Param ($Parameter1)\r\n    Begin{}\r\n    Process{\r\n        $a = ConvertFrom-JSON \"[]\" # https://github.com/PowerShell/PowerShell/issues/16548\r\n        $a\r\n    }\r\n    End{}\r\n}\r\n\r\nMyScript\r\n\r\nMyScript -Debug\r\n$Null\r\n```\r\n",
      "created_at": "2022-07-21T07:58:38Z",
      "updated_at": "2022-07-21T08:11:40Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "WG-Engine discussed this today (8/22/2022).\r\n\r\nSuch a feature (Format-Pretty|Debug|All|???) would be a good candidate for a community-supplied PowerShell module.  We're not sure using the `-Debug` parameter would be appropriate since that simply enables `Write-Debug` messages to go to the Debug stream.  Those do not go to the Output stream.",
      "created_at": "2022-08-23T01:38:40Z",
      "updated_at": "2022-08-23T01:38:40Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This issue has been marked as declined and has not had any activity for **1 day**. It has been closed for housekeeping purposes.",
      "created_at": "2022-08-24T10:01:20Z",
      "updated_at": "2022-08-24T10:01:20Z"
    }
  ],
  "created_at": "2022-07-18T10:09:58Z",
  "labels": [
    "Issue-Enhancement",
    "WG-Engine",
    "Resolution-Declined"
  ],
  "number": 17701,
  "state": "closed",
  "title": "PowerShell should be better able to reveal developer information on an unknown object",
  "updated_at": "2022-08-24T10:01:21Z"
}