{
  "_url": "https://github.com/PowerShell/PowerShell/issues/13944",
  "author": "mklement0",
  "body": "Sometime after 7.0, a new ETS script property named `CommandLine` was introduced for `System.Diagnostics.Process` instances, so that you could query a given process' command line.; e.g.:\r\n\r\n```powershell\r\n# Currently Windows and Linux only: get the PowerShell session's own command line.\r\n(Get-Process -Id $PID).CommandLine\r\n```\r\n\r\nAs an aside: The property doesn't yet support macOS - see #13943.\r\n\r\nOn Linux, this is in effect implemented via the following command, using Linux' special files:\r\n\r\n```powershell\r\nGet-Content /proc/$PID/cmdline \r\n```\r\n\r\nThe problem is that the content of these files contains the verbatim arguments as originally used during process creation _separated with `NUL` characters_, which in the terminal - due to `NUL` getting ignored  - presents like _directly joined_ arguments, which is unhelpful to the human observer.\r\n\r\nThe question is how much effort we want to expend to present a _functional_ command line that is the _equivalent_ of the original:\r\n\r\n* A simple solution would be to simply _space_-concatenate the verbatim arguments - \r\n`` (Get-Content /proc/$PID/cmdline) -replace \"`0\", ' ' `` - for a friendlier presentation:\r\n\r\n  * This results in loss of information: the original argument boundaries aren't preserved.\r\n  * However, it may be good enough for the _human_ observer, and it is what the standard `ps` utility does with `-o command=`, which is the only similarly simple solution for _macOS_ - see #13943.\r\n\r\n* Trying to recreate a _functional_ command line would require substantially more effort - namely for recreating required _quoting and escaping_ - and has an inherent _conceptual_ problem:\r\n\r\n  * Given that PowerShell syntax differs from that of POSIX-compatible shells: _which shell's syntax_ do you use for the reconstruction? Arguably, it should be PowerShell's (which, of course, is still fundamentally hampered by #1995).\r\n\r\n\r\n## Steps to reproduce\r\n\r\nOn Linux, from PowerShell\"\r\n\r\n```powershell\r\npwsh -noprofile -command 'Get-Content /proc/$PID/cmdline'\r\n```\r\n\r\n## Expected behavior\r\n\r\nA string with the following verbatim content:\r\n\r\n```none\r\n/usr/bin/pwsh -noprofile -command Get-Content /proc/$PID/cmdline\r\n```\r\n\r\nThis assumes simple space concatenation without any attempt to recreated required quoting and escaping; see discussion above.\r\n\r\n\r\n## Actual behavior\r\n\r\nSince the verbatim arguments are `NUL`-concatenated, they appear as directly concatenated; note the lack of spaces between `pwsh`, `-noprofile`, `-command`, and the latter's argument:\r\n\r\n```none\r\n/usr/bin/pwsh-noprofile-commandGet-Content /proc/$PID/cmdline\r\n```\r\n\r\n## Environment data\r\n\r\n```none\r\nPowerShell Core 7.1.0-rc.2\r\n```\r\n\r\n\r\n",
  "closed_at": null,
  "comments": [],
  "created_at": "2020-10-30T16:10:00Z",
  "labels": [
    "Issue-Question",
    "WG-Engine",
    "Waiting - DotNetCore"
  ],
  "number": 13944,
  "state": "open",
  "title": "Unexpected behavior of the new .CommandLine ETS script property on Process objects on Linux",
  "updated_at": "2021-01-18T12:53:39Z"
}