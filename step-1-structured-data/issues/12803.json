{
  "_url": "https://github.com/PowerShell/PowerShell/issues/12803",
  "author": "jimbobmcgee",
  "body": "# Summary of the new feature/enhancement\r\nIs there any mileage or desire for an option that enforces the use of semicolon (and only semicolon) as the command terminator for a given script?\r\n\r\nI regularly find myself at odds between the \"natural\" line-continuation points within the PowerShell language, and where *I* want to place a newline for the long-term readability of my scripts.  As such, I find myself resorting to escaping newlines with the backtick, which I am repeatedly led to believe is *a bad thing\u2122*.\r\n\r\nI completely *understand* why the natural points are what they are, but most of the reasons seem to boil down to the expectation that a newline can terminate the command.  If the script parser could be informed that semicolon was the only command terminator in a given script, it could bypass having to make continuation checks at each newline and make whitespace mostly-insignificant.  This would allow for better alignment of pipelines and command parameters, without having to resort to backtick and without the language seeming to have *opinions* as to where line continuation should happen.\r\n\r\n# Proposed technical implementation details (optional)\r\nI see this as an extension to `#Requires` because of its existing script scope, however, the notion of *requiring command termination* is not semantically ideal.  As such, this could reasonably be via any other script-wide directive.  It *could* be a dedicated `Set-CommandTermination` command, or maybe an additional parameter to `Set-StrictMode` (although there may be lexical scope expectations around such).\r\n\r\nIt would certainly need to be an opt-in state, so as not to affect existing scripts.\r\n\r\nIt might be desirable to later extend this to allow for alternate command terminators&mdash;such as `DoubleNewline`&mdash;for those who find semicolons repulsive.\r\n\r\nIt is intended to facilitate such script formatting as the following (which is appreciably my personal preference), without requiring further complex line-continuation checks:\r\n\r\nInstead of...\r\n\r\n    Import-Module DummyExample\r\n    Invoke-DummyPipelineProducer -SomeArgument -OtherArgument |\r\n      Invoke-DummyLongParameterList -SomeSwitch -OtherSwitch -SomeParameter 12345 -Expression (\r\n        Invoke-DummyMethod | Select-Object -First 1) |\r\n      Where-Object { $_.SomeProperty -contains (\r\n        Invoke-DummyFilterList -Type A | Select-Object -First 1) } |\r\n      Select-Object -ExpandProperty Foo |\r\n      ForEach-Object {\r\n        if (-not (Test-Dummy $_)) { Invoke-DummyAction $_ }\r\n        else { Write-Verbose \"$_ already done\" }\r\n      }\r\n\r\n...or the backtick-laden...\r\n\r\n    Import-Module DummyExample\r\n    Invoke-DummyPipelineProducer -SomeArgument -OtherArgument `\r\n      | Invoke-DummyLongParameterList `\r\n          -SomeSwitch `\r\n          -OtherSwitch `\r\n          -SomeParameter 12345 `\r\n          -Expression (Invoke-DummyMethod | Select-Object -First 1) `\r\n      | Where-Object { $_.SomeProperty -contains (\r\n          Invoke-DummyFilterList -Type A | Select-Object -First 1 `\r\n        ) } `\r\n      | Select-Object -ExpandProperty Foo `\r\n      | ForEach-Object {\r\n          if (-not (Test-Dummy $_)) { Invoke-DummyAction $_ }\r\n          else { Write-Verbose \"$_ already done\" }\r\n        }\r\n    \r\n...we could write...\r\n\r\n    #Requires -CommandTermination Semicolon;\r\n    Import-Module DummyExample;\r\n    Invoke-DummyPipelineProducer -SomeArgument -OtherArgument\r\n      | Invoke-DummyLongParameterList\r\n          -SomeSwitch\r\n          -OtherSwitch\r\n          -SomeParameter 12345\r\n          -Expression (Invoke-DummyMethod | Select-Object -First 1)\r\n      | Where-Object { \r\n          $_.SomeProperty -contains (Invoke-DummyFilterList -Type A\r\n                                       | Select-Object -First 1) \r\n        }\r\n      | Select-Object -ExpandProperty Foo\r\n      | ForEach-Object {\r\n          if (-not (Test-Dummy $_)) { Invoke-DummyAction $_ }\r\n          else { Write-Verbose \"$_ already done\" }\r\n        };\r\n\r\nUnfortunately, I can't comment as to how much effort this would add to the script parser.",
  "closed_at": null,
  "comments": [
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "The pipe-after-newline thing is already a thing in PowerShell 7. So that's already in the parser.\r\n\r\nThe other one you mention (parameters after newlines), I think @KirkMunro had a PR for, or an RFC, though I'm not clear on whether it's one that was decided that is being accepted or not. No idea there.\r\n\r\nYou can also use splatting (see `Get-Help about_Splatting`) to define parameters before you call commands and make that look a bit neater.\r\n\r\nBeyond that, see also @markekraus' wonderful post [Bye Bye Backtick](https://get-powershellblog.blogspot.com/2017/07/bye-bye-backtick-natural-line.html) - there are a _ton_ of natural newline continuations already available to you that most folks overlook.\r\n\r\nAddressing the more general point about opting in to enforcing `;` for newlines, I don't think there's really wide demand for and there's quite a lot of work in that deceptively simple-looking change. Add to that the fact that adding a check for some such setting in every parser rule would probably bog down the parsing speed something feirce... I don't think that's likely to ever really happen, honestly.",
      "created_at": "2020-05-27T00:32:07Z",
      "updated_at": "2020-05-27T00:36:37Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "The parameters-across-multiple-lines-without-backticks PR you mention - yet to be reviewed by the committee - is at https://github.com/PowerShell/PowerShell-RFC/pull/179.",
      "created_at": "2020-05-27T13:35:11Z",
      "updated_at": "2020-05-27T13:35:11Z"
    },
    {
      "author": "jimbobmcgee",
      "author_association": "NONE",
      "body": "Thank you both for your responses.  I am aware of both KirkMunro's PRs and the article that you link, and these were almost-exactly *why* I thought to make this suggestion in the first place.  \r\n\r\nThe article is very thorough in its description of the places where natural line-continuation can take place, and nearly all of them are the *opposite* of where I would want to put them.  The rules are inconsistent (keyword `foreach` *can*, pipelined `foreach` *can't*; prefixed incrementors *can*, postfixed increment *can't*, etc.).  This seems more like an attempt to document the *limitations* of the parser, rather than an intentional effort to promote a consistent style.  \r\n\r\nSplatting is a useful nicety, but it feels like a band-aid which is being used precisely *because* there is no support for parameters being on their own line, rather than because it is the better way of calling commands.  For all its usefulness, there are certainly negative aspects (assignment of a new hashtable variable, loss of implicit unquoted strings, required explicit array notation, required explict `$true`/`$false` for `[Switch]` parameters, no tab completion in the editor, for example).\r\n\r\nThe recent work by KirkMunro seems admirable&mdash;indeed, he may have a similar coding style to my own&mdash;but I am not sure that iteratively altering the parser to suit coding style issues as they arise is the right approach, as it will surely only lead to a very, very complex set of rules.  RFC179 is already (rightfully) under scruitiny for backwards compatibility with prefixed iterators.\r\n\r\nI appreciate that issues of coding *style* are entirely subjective but all of the issues I have come across seem to stem from the decision to treat newline as the command terminator.  I am not expecting a massive sea-change in that mentality after 7+ major iterations of the language, but it does seem to me that most of those style-related issues could be put to bed by \"simply\" allowing the script-writer to use alternative termination.\r\n\r\nI understand that this is \"deceptively simple-looking\".  I concede I have no experience with language parsing (else I would attempt to investigate this myself) but does anyone have any notion as to how difficult it would be to alter the logic that identifies the end of a command?  \r\n\r\nWithout looking, my best-guess at this stage is that PS parses a stream of \"tokens\" in some sort of finite state machine, with END-OF-COMMAND being one of those tokens, where END-OF-COMMAND is currently set as [newline OR semicolon] (since semicolon is already a command separator.  If that guesswork is anywhere near correct, couldn't a variable terminator be used instead?",
      "created_at": "2020-05-27T14:34:52Z",
      "updated_at": "2020-05-27T14:34:52Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "It's not even really about identifying the end of a command. As you say, in many cases a newline is sufficient. However, there are cases where newlines are ignored, deliberately. Quite a lot of them, as you seem to be at some somewhat aware.\r\n\r\nSo you can't just look for a different token suddenly; all of that existing newline-ignoring code would break, and there is quite a lot of it. As far as I recall, there isn't an explicit end-of-command token for that reason; newlines are not _always_ an end-of-command/expression/line/statement depending on context. The tokenizer can't necessarily generate an end-of-command token on its own, that has to be recognised contextually in the parser.\r\n\r\nYou'd have to find a way to introduce that concept to the parser without also breaking both the existing functionality, and also making sure that current line continuations still work correctly when you change the end-of-command/statement/expression/etc token.",
      "created_at": "2020-05-27T14:41:18Z",
      "updated_at": "2020-05-27T14:42:28Z"
    },
    {
      "author": "jimbobmcgee",
      "author_association": "NONE",
      "body": "(For clarity, the work that I had initially viewed by KirkMunro was comprised of [PR#8938](https://github.com/PowerShell/PowerShell/pull/8938) and [PR#9614](https://github.com/PowerShell/PowerShell/pull/9614), *not* the open RFC linked by mklement0 [RFC PR#179](https://github.com/PowerShell/PowerShell-RFC/pull/179) -- whether this materially impacts the discussion is unknown.)",
      "created_at": "2020-05-27T17:43:03Z",
      "updated_at": "2020-05-28T16:43:02Z"
    }
  ],
  "created_at": "2020-05-27T00:13:22Z",
  "labels": [
    "Issue-Enhancement"
  ],
  "number": 12803,
  "state": "open",
  "title": "Feature Request: Enforcement of non-newline command terminator (e.g. semicolon) within scripts, via opt-in directive",
  "updated_at": "2020-05-28T16:43:02Z"
}