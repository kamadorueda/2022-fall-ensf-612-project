{
  "_url": "https://github.com/PowerShell/PowerShell/issues/15586",
  "author": "LogRaam",
  "body": "From the source code provided in this ticked (attached file).\r\n\r\nWith a class [Player] having a constructor Player([string]p1)\r\nAnd with another class [Game] with a method SetScoreForPlayer([Player]$p1, [int]p2) { ... }\r\nWhen calling method SetScoreForPlayer(\"p1\", p2) from an instance of [Game] where p1 is of type [string] but first param from SetScoreForPlayer([Player]$p1, [int]p2) is of type [Player]\r\nThen the runtime call the constructor of [Player], passing the string value of \"p1\" to it.\r\n\r\nThere is no reason why $aGame.SetScoreForPlayer(\"p1\", p2) should call [Player]'s constructor.\r\n\r\n\r\nWith $p1 = [Player]::new(\"Jhon\")\r\nIf I call  SetScoreForPlayer(p1, p2)\r\nWhere p1 is of the right type (of [Player])\r\nThen the code will work as expected.\r\n\r\nPlease refer to the attached source file: [Bug.zip](https://github.com/PowerShell/PowerShell/files/6658267/Bug.zip)\r\n\r\n\r\nExtracted source code example:\r\n\r\n\r\n```\r\nclass Player {\r\n    [string]$Name\r\n    [int]$Score = 0\r\n\r\n    Player([string]$name){\r\n        $this.Name = $name\r\n    }\r\n}\r\n\r\nclass Game{\r\n    [Player[]]$Players = @()\r\n\r\n    [string]SetScoreForPlayer([Player]$player, [int]$score){\r\n        foreach ($player in $this.Players) {\r\n            if ($player.Name -eq $player.Name) {\r\n                $player.Score = $score\r\n            }\r\n        }\r\n        throw \"Player $($player.Name) aren't playing in this game\"\r\n    }\r\n}\r\n\r\n\r\n\r\n$p = [Player]::new(\"Jhon\")\r\n\r\n$game = [Game]::new()\r\n$game.Players += $p\r\n\r\n\r\nwrite-host \"Here is $($game.SetScoreForPlayer(\"$p\", 3))\"\r\n\r\n\r\n```\r\n\r\n",
  "closed_at": "2021-06-15T23:48:49Z",
  "comments": [
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "This isn't a bug in PowerShell's code, but I can see a few issues in the code snippet you've given here:\r\n\r\n**(1:)** The expression `\"$p\"` will evaluate to basically the same as `$p.ToString()` because it's a string expression. So when you call `$game.SetScoreForPlayer(\"$p\", 3)` you're effectively calling `$game.SetScoreForPlayer($p.ToString(), 3)`\r\n\r\nIn order to convert the string value `\"$p\"` into a `[Player]` object instance, PS must call the constructor. If you don't intend to create a new [Player] object with that call, you need to pass in the value `$p` directly, without adding quotes. The quotes will force a conversion to string, and then PS will attempt to convert that string into the desired data type. (If `[Player]`'s constructor did not take a `[string]` value, PS would simply fail the conversion outright and throw an exception calling that method.)\r\n\r\nThe second and third issues are in this method:\r\n\r\n```powershell\r\n    [string]SetScoreForPlayer([Player]$player, [int]$score){\r\n        foreach ($player in $this.Players) {\r\n            if ($player.Name -eq $player.Name) {\r\n                $player.Score = $score\r\n            }\r\n        }\r\n        throw \"Player $($player.Name) aren't playing in this game\"\r\n    }\r\n```\r\n\r\n**(2:)** You're using `$player` as the method parameter and then overwriting it in the method. So the comparison `$player.Name -eq $player.Name` is entirely meaningless. If you rename one of your `$player` variables, this code should do what you want.\r\n\r\n**(3:)** You _always_ throw an exception at the end of the method, regardless of whether the player was found or not. One way to work around this is to add a `return` statement before the end of the code in the `if` block.\r\n\r\n<details>\r\n<summary>\r\nFixes for 2 and 3\r\n</summary>\r\n\r\n```powershell\r\n    [string] SetScoreForPlayer([Player]$player, [int]$score) {\r\n        foreach ($p in $this.Players) {\r\n            if ($p.Name -eq $player.Name) {\r\n                $p.Score = $score\r\n                return\r\n            }\r\n        }\r\n\r\n        throw \"Player $($player.Name) aren't playing in this game\"\r\n    }\r\n```\r\n</details>\r\n\r\nHope that helps!",
      "created_at": "2021-06-15T21:20:34Z",
      "updated_at": "2021-06-15T21:20:54Z"
    },
    {
      "author": "LogRaam",
      "author_association": "NONE",
      "body": "Thank You for your reply.\r\n\r\nI've done some tests based on your suggestion.  I learned that passing a\r\nstring to a hard typed param is the same behavior as casting a string to a\r\nspecific type.\r\n\r\nHere is my test:\r\n\r\n```\r\nclass aClass {\r\n    $AValue\r\n\r\n    aClass($value){\r\n        $this.AValue = $value\r\n    }\r\n}\r\n\r\nclass anotherClass {\r\n    [void]DoSomething([aClass]$param){\r\n        Write-Host $param\r\n    }\r\n}\r\n\r\n$a = [aClass]::new(\"A\")\r\n\r\n\"$a\"                #Print aClass in Terminal\r\n$a.ToString()       #Print aClass in Terminal\r\n\r\n[aClass]\"a string\"\r\n#Cast the string to [aClass] that calls upon [aClass]'s constructor.\r\n[anotherClass]::new().DoSomething(\"here is a string\")\r\n#Cast the string to the param's hard typed type [aClass] that calls\r\nupon [aClass]'s constructor.\r\n\r\n[anotherClass]::new().DoSomething($a)   #This line doesn't call the\r\nconstructor of [aClass] and executes\r\nthe method as intended.\r\n\r\n```\r\nIt seems that if the expression [anotherClass]::new().DoSomething(\"\r\nhere is a string\") evaluate to [aClass]\"a string\" instead of $a.ToString().\r\n\r\nThank You for your support.\r\n\r\nLogRaam\r\n",
      "created_at": "2021-06-15T23:40:54Z",
      "updated_at": "2021-06-15T23:50:09Z"
    }
  ],
  "created_at": "2021-06-15T19:46:20Z",
  "labels": [],
  "number": 15586,
  "state": "closed",
  "title": "[BUG] Calling Method with wrong param type call another class constructor instead",
  "updated_at": "2021-06-15T23:50:09Z"
}