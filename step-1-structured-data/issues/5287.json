{
  "_url": "https://github.com/PowerShell/PowerShell/issues/5287",
  "author": "powercode",
  "body": "Underpinnings to make calling of Extension methods /Linq\r\neasier from PowerShell.\r\n\r\nEnables the following that previously had to be done via\r\nreflection.\r\n\r\n```powershell\r\nclass M {\r\n    static [int] DoubleStrLen([string] $value) { return 2 * $value.Length }\r\n    \r\n    static [long] AggregateString([string[]] $values, [func[string, int]] $selector) {\r\n        [long] $res = 0\r\n        foreach($s in $values){\r\n            $res += $selector.Invoke($s)\r\n        }\r\n        return $res\r\n    }        \r\n}\r\n\r\n[M]::AggregateString((gci).Name, [M]::DoubleStrLen)\r\n```\r\n\r\nEach PSMethod is created as with a unique type for the combinations of\r\nmethod signatures in the MethodInfos it represents.\r\n\r\nPSMethod<T> where T is a MethodGroup<>, potentially recursive in the\r\nlast template argument.\r\n\r\nThis way, we can determine by just looking at the type of a PSMethod\r\nif there exists a conversion from the PSMethod to a delegate.\r\n",
  "closed_at": "2017-12-02T02:40:36Z",
  "comments": [
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "I would still like a discussion about what's the right thing to do methods with more than 63 overloads and or more than 16 generic parameters.\r\n\r\nThese are for sure edge cases, but it would be nice to at least handle them gracefully\r\n",
      "created_at": "2017-11-02T18:34:14Z",
      "updated_at": "2017-11-02T18:34:14Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "@powercode - if you want full generality, as long as `MethodGroup` is an internal type, you can have a special case where, if the last type parameter is `MethodGroup`, then you have essentially a linked list, and the type parameters to that last `MethodGroup` is the continuation of the list.\r\n\r\nTo be concrete, say we only support 1 or 2 methods in `MethodGroup`, but you have 3 overloads. You would encode that as:\r\n\r\n```\r\nMethodGroup[\r\n    Func[int, int],\r\n    MethodGroup[\r\n        Func[string, string],\r\n        Func[long, long]]]\r\n```\r\n\r\nUsing this trick, you could use a single generic type to represent all generic type parameters, the length of the list would encode T0, T1, etc.\r\n\r\n```\r\nPSGenericType[unit] # T0\r\nPSGenericType[PSGenericType[unit]] # T1\r\nPSGenericType[PSGenericType[PSGenericType[unit]]] # T2\r\n# etc.\r\n```\r\n",
      "created_at": "2017-11-02T20:35:31Z",
      "updated_at": "2017-11-02T20:35:31Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "@lzybkr I kinda already to that:\r\n```\r\ncase 7: return typeof(MethodGroup<,,,>).MakeGenericType(types[0], types[1], types[2], CreateMethodGroup(types, 3, 4));\r\n```\r\n\r\nIt is recursive in the last parameter.",
      "created_at": "2017-11-02T21:00:25Z",
      "updated_at": "2017-11-02T21:00:47Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "I just learned that I need to have a representation of Span<T> too. That special class cannot be used as a generic argument. https://github.com/dotnet/corefxlab/blob/master/docs/specs/span.md ",
      "created_at": "2017-11-03T12:08:39Z",
      "updated_at": "2017-11-03T12:08:39Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "@lzybkr  I will explore the `PSGenericType[unit]` route in the weekend. I liked the idea better than the hardcoded types. Or maybe a combination, that if more than `n` parameters, use the template",
      "created_at": "2017-11-03T12:30:11Z",
      "updated_at": "2017-11-03T12:30:11Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "A few further improvement points\r\n--------------------------------------\r\n1. `DelegateArgsComparator.ParameterTypesMatches` doesn't consider the Variance in delegate parameter types. A method signature `int CallMe(object input)` should be able to be converted to `Func<string, int>`.\r\n2. `PSMethod.MatchesPSMethodProjectedType` doesn't handle the case where both `targetType` and `projectedSourceType` are the same `ByRef` type or `Pointer` type.\r\n3. I think the 'Unit' type name should be changed to 'VOID'. Use type `Unit` to represent `void` is not intuitive and I misread it to `uint` when first looking at the code.\r\n4. I don't get the point of having `ReplaceGenericTypeArgumentsWithMarkerTypes`. After making a generic method using our synthetic reference/value types, the generated `MethodInfo` signature won't match any real delegates except in one condition -- the original generic method doesn't use the generic type argument for any of its parameters or return type -- I think it's rare for this condition to be met for a generic method.\r\n\r\nTwo questions about the design\r\n----------------------------------------------\r\n1. It's eye-opening for me to see how you can track the signature information using the generic type argument of `PSMethod<>` \ud83d\ude2e But why do you choose the current design over adding a `List<Type>` field/property to `PSMethod` to keep all the `Func<...>` delegate types? \r\nWith a `List<Type>` field/property, you don't need the algorithm to create `MethodGroup<...>` or to enumerate the `Func<...>` type from the `MethodGroup<...>` type, and we won't need to make that many generic types, and the code would be easier to understand too.\r\n2. I agree that we need pseudo types to represent `ByRef` type (ref/out), `Pointer` type `void` type and even `TypeReference`, but why do we need `PSEnum<>` to wrap enum types?",
      "created_at": "2017-12-01T21:12:42Z",
      "updated_at": "2017-12-02T01:33:02Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "@daxian-dbw - The use of `PSMethod<>` allows for faster conversions.\r\n\r\nIf you have a conversion from `PSMethod` to `Action`, `Action<int>`, `Action<int,int>`, etc., then it requires a more expensive check to determine the conversion validity.\r\n\r\nIf it is type based, then there is no conversion from `PSMethod` to `Action<int>`, but there is for `PSMethod<MethodGroup<Action<int>>>` to `Action<int>`.\r\n\r\nPut another way, the `FigureConversion` logic essentially relies on types. If you look closely, you'll see that value dependent conversions do exist, but the design only accommodates them because I couldn't see a better way to support that rarely used scenario.",
      "created_at": "2017-12-01T21:39:15Z",
      "updated_at": "2017-12-01T21:39:15Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@lzybkr That makes perfect sense now. I forgot about the conversion cache.\r\n\r\n- Without `PSMethod<>` type, the cache is useless for this kind of conversion -- we will end up doing the validity check on every `PSMethod -> Delegate` conversion.\r\n- With the `PSMethod<>` type, no duplicate validity check is needed. For invalid \r\n`PSMethod<> -> Delegate` conversions, the conversion cache will have a `ConvertNoConversion` for the `FromType, ToType` tuples, powershell won't need to do the check again.\r\n\r\nCan you please also shed some light on the `PSEnum<>` question?",
      "created_at": "2017-12-02T00:51:19Z",
      "updated_at": "2017-12-02T00:51:19Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "The failed tests in macOS build are known test failures. It's tracked by #5590.",
      "created_at": "2017-12-02T01:01:56Z",
      "updated_at": "2017-12-02T01:01:56Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "@powercode  will have to address `PSEnum<>` - he just took my basic idea and worked out all the details - and I do mean all, I might have skipped `Pointer` because you can't really use it from PowerShell.",
      "created_at": "2017-12-02T01:17:19Z",
      "updated_at": "2017-12-02T01:17:19Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@powercode I will merge this PR, but let's continue the discussion if you have time \ud83d\ude04",
      "created_at": "2017-12-02T02:38:40Z",
      "updated_at": "2017-12-02T02:38:40Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "Sorry all for my horrible response time. I have to revisit the code and look at it. Some of the special cases, like `pointer`, never shows up from PowerShell, but I ran into them by enumerating all methods in all loaded assemblies and tried to make sure I could create `PSMethod<>`s for them.\r\n\r\n",
      "created_at": "2017-12-30T16:37:39Z",
      "updated_at": "2017-12-30T16:37:39Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Should we document the feature?",
      "created_at": "2018-01-03T15:11:02Z",
      "updated_at": "2018-01-03T15:11:02Z"
    }
  ],
  "created_at": "2017-10-31T21:30:47Z",
  "number": 5287,
  "state": "closed",
  "title": "Conversions from PSMethod to Delegate",
  "updated_at": "2018-10-15T21:50:53Z"
}