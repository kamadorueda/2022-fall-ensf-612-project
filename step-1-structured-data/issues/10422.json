{
  "_url": "https://github.com/PowerShell/PowerShell/issues/10422",
  "author": "vexx32",
  "body": "<!-- Anything that looks like this is a comment and can't be seen after the Pull Request is created. -->\r\n\r\n# PR Summary\r\n\r\nThis changes the operator binders for `-lt`/`-gt` (etc.) to recognise null-like values the same as it does for `null`, so that it treats them as a `0` value when comparing to a numeric value.\r\n\r\n```powershell\r\n[nullstring]::Value -gt 3 # False\r\n[dbnull]::Value -gt 2 # False\r\n```\r\n\r\n## PR Context\r\n\r\nFixes #10404\r\n\r\n## PR Checklist\r\n\r\n- [x] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [x] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` or `[ WIP ]` to the beginning of the title (the `WIP` bot will keep its status check at `Pending` while the prefix is present) and remove the prefix when the PR is ready.\r\n- **[Breaking changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)**\r\n    - [x] None\r\n    - **OR**\r\n    - [ ] [Experimental feature(s) needed](https://github.com/MicrosoftDocs/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/About/about_Experimental_Features.md)\r\n        - [ ] Experimental feature name(s): <!-- Experimental feature name(s) here -->\r\n- **User-facing changes**\r\n    - [ ] Not Applicable\r\n    - **OR**\r\n    - [x] [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n- **Testing - New and feature**\r\n    - [ ] N/A or can only be tested interactively\r\n    - **OR**\r\n    - [x] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n- **Tooling**\r\n    - [x] I have considered the user experience from a tooling perspective and don't believe tooling will be impacted.\r\n    - **OR**\r\n    - [ ] I have considered the user experience from a tooling perspective and enumerated concerns in the summary. This may include:\r\n        - Impact on [PowerShell Editor Services](https://github.com/PowerShell/PowerShellEditorServices) which is used in the [PowerShell extension](https://github.com/PowerShell/vscode-powershell) for VSCode (which runs in a different PS Host).\r\n        - Impact on Completions (both in the console and in editors) - one of PowerShell's most powerful features.\r\n        - Impact on [PSScriptAnalyzer](https://github.com/PowerShell/PSScriptAnalyzer) (which provides linting & formatting in the editor extensions).\r\n        - Impact on [EditorSyntax](https://github.com/PowerShell/EditorSyntax) (which provides syntax highlighting with in VSCode, GitHub, and many other editors).\r\n",
  "closed_at": "2020-01-15T17:46:46Z",
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "One question is performance degradation.\r\nI guess we need replace\r\n`public static bool IsNullLike(object obj) => obj == DBNull.Value || obj == NullString.Value || IsNull(obj);` \r\nwith\r\n`public static bool IsNullLike(object obj) => IsNull(obj) || obj == DBNull.Value || obj == NullString.Value;`",
      "created_at": "2019-08-23T05:10:15Z",
      "updated_at": "2019-08-23T05:10:15Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Good call, @iSazonov, made that change. \ud83d\udc96 ",
      "created_at": "2019-08-23T15:55:03Z",
      "updated_at": "2019-08-23T15:55:03Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "I played the changes a bit and found an issue:\r\n\r\n```powershell\r\n> [System.DBNull]::Value -ge [NullString]::Value\r\nTrue\r\n> [NullString]::Value -le [System.DBNull]::Value\r\nTrue\r\n```\r\nHowever, we don't consider `[DBNull]::Value -eq [NullString]::Value` , see https://github.com/PowerShell/PowerShell/pull/9794/files#diff-c6cad5a3db5d6bcb21228e483b7506d1R31-R42\n\n<blockquote><img src=\"https://avatars2.githubusercontent.com/u/32407840?s=400&v=4\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicon.ico\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/PowerShell/PowerShell/pull/9794\">Consider DBNull.Value and NullString.Value the same as $null by vexx32 \u00b7 Pull Request #9794 \u00b7 PowerShell/PowerShell</a></strong></div><div>PR Summary\nCloses #9561\n\nAdds LanguagePrimitives.IsNullLike() method to account for DBNull.Value and NullString.Value so that they can be considered the same as a null value where sensible in Power...</div></blockquote>",
      "created_at": "2019-09-03T21:21:10Z",
      "updated_at": "2019-09-03T21:21:13Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@daxian-dbw yeah I can see how that would arise, for sure. It is an anomaly, but it makes some sense here.\r\n\r\nWith `-ge` operators we are explicitly using either only a string or a numeric comparison mode. As a result, both operands must be converted into a numeric form or a string form for the comparison. Both cast to `0` or an empty string if we treat them the same way PowerShell currently handles conversions to these types from `$null`. \r\n\r\nIs there a better option available for us to use here?",
      "created_at": "2019-09-03T21:42:24Z",
      "updated_at": "2019-09-03T21:43:26Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Taking that `[DBNull]::Value -eq [NullString]::Value` is false we should fix `-ge` and `-le` I believe.",
      "created_at": "2019-09-04T03:30:46Z",
      "updated_at": "2019-09-04T03:30:46Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Is there a sensible result for either comparison? In what sense is one version of a null value numerically greater or lesser than another? Or should we be doing something very unusual and always returning $false for any such comparison?\r\n\r\nIn other words, should this be the case?\r\n```ps\r\n$NullString = [NullString]::Value\r\n$DBNull = [DBNull]::Value\r\n\r\n$NullString -ge $DBNull # -> false\r\n$NullString -le $DBNull # -> false\r\n$NullString -gt $DBNull # -> false\r\n$NullString -lt $DBNull # -> false\r\n$DBNull -ge $NullString # -> false\r\n$DBNull -le $NullString # -> false\r\n$DBNull -gt $NullString # -> false\r\n$DBNull -lt $NullString # -> false\r\n```\r\n\r\nWhile this is possible, I'm not sure it's sensible. `-ge`, `-gt`, and their counterparts are deliberately implemented from the beginning as different from `-eq` and `-ne`. The latter convert types when needed only; the former will always evaluate as either a numeric or a string comparison.\r\n\r\nIt boils down to a pretty simple problem: what is the expected result here? In my view, it should be reasonably intuitive, and although perhaps initially surprising, I think the current behaviour makes more sense than the alternatives I can see at the moment.",
      "created_at": "2019-09-04T03:41:48Z",
      "updated_at": "2019-09-04T03:45:23Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "We could add samples for $null in the list.",
      "created_at": "2019-09-04T04:31:22Z",
      "updated_at": "2019-09-04T04:31:22Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@iSazonov all comparisons with null-like values and $null reflect that they're equal. I'll have to verify -ge and -le but I believe they evaluate as equal in all cases. :slightly_smiling_face: ",
      "created_at": "2019-10-02T22:28:18Z",
      "updated_at": "2019-10-02T22:28:51Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@iSazonov updated list of what the suggested change `$DBNull -ge $NullString => $false `_and_ `$DBNull -le $nullString=> $false` would look like with $null included:\r\n\r\n(Personally, I don't think this makes sense; these comparisons have always worked on a slightly different basis to `-eq`/`-ne` as they're stringly numeric/string comparisons anyway.)\r\n\r\n```ps\r\n$NullString = [NullString]::Value\r\n$DBNull = [DBNull]::Value\r\n\r\n$NullString -ge $DBNull # -> false\r\n$NullString -le $DBNull # -> false\r\n$NullString -ge $null # -> true\r\n$NullString -le $null # -> true\r\n\r\n$NullString -gt $DBNull # -> false\r\n$NullString -lt $DBNull # -> false\r\n$NullString -gt $null # -> true (?)\r\n$NullString -lt $null # -> false (?)\r\n\r\n$DBNull -ge $NullString # -> false\r\n$DBNull -le $NullString # -> false\r\n$DBNull -ge $null # -> true\r\n$DBNull -le $null # -> true\r\n\r\n$DBNull -gt $NullString # -> false\r\n$DBNull -lt $NullString # -> false\r\n$DBNull -gt $null # -> true (?)\r\n$DBNull -lt $null # -> false (?)\r\n```\r\n\r\nI think that _despite_ $NullString and $DBNull being not equal to each other, comparisons with `-ge` or `-le` (or indeed `-gt` or `-lt`) are explicitly either based on numeric value or string sort order. As such, they should convert to `0` or empty string and give a `$true` result for both `-ge`/`-le` and a `$false` result for `-gt/-lt` \u2014 this is how the current implementation in this branch would work.\r\n\r\nThoughts, @daxian-dbw? \ud83d\ude42\r\n\r\n",
      "created_at": "2019-10-03T20:17:07Z",
      "updated_at": "2019-10-03T20:17:07Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@daxian-dbw @SteveL-MSFT friendly ping for review! \ud83d\udc96 \ud83d\ude0a ",
      "created_at": "2019-10-12T19:52:19Z",
      "updated_at": "2019-10-12T19:52:19Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@PoshChan please retry macos, linux",
      "created_at": "2019-10-15T01:25:39Z",
      "updated_at": "2019-10-15T01:25:39Z"
    },
    {
      "author": "PoshChan",
      "author_association": "COLLABORATOR",
      "body": "@vexx32, successfully started retry of `PowerShell-CI-macOS, PowerShell-CI-Linux`",
      "created_at": "2019-10-15T01:26:12Z",
      "updated_at": "2019-10-15T01:26:12Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Okay, finally got the binder issue sorted. Very odd that it wasn't surfacing on the Windows VM; it was showing locally on my Windows machine when I checked.\r\n\r\nThe logic paths there are horribly confusing, and that nested tree of ternary needs a lot of puzzling out. I'm sorely tempted to say we need to refactor it completely so that we can actually see what's going on there, but I don't really see much of a better way to write it unfortunately.\r\n\r\nI could refactor it to a small set of `if/else if/else` statements instead, potentially? Before/after comparison:\r\n\r\n### BEFORE\r\n\r\n```csharp\r\nif (enumerable == null\r\n    && (LanguagePrimitives.IsNullLike(target.Value)\r\n        || LanguagePrimitives.IsNullLike(arg.Value)))\r\n{\r\n    Expression result = target.LimitType.IsNumeric()\r\n        ? CompareWithZero(target, Expression.GreaterThanOrEqual)\r\n        : arg.LimitType.IsNumeric()\r\n            ? CompareWithZero(arg, Expression.LessThanOrEqual)\r\n            : LanguagePrimitives.IsNullLike(arg.Value)\r\n                ? ExpressionCache.BoxedTrue\r\n                : ExpressionCache.BoxedFalse;\r\n\r\n    return new DynamicMetaObject(result, target.CombineRestrictions(arg));\r\n}\r\n```\r\n\r\n### AFTER\r\n\r\n```csharp\r\nif (enumerable == null\r\n    && (LanguagePrimitives.IsNullLike(target.Value)\r\n        || LanguagePrimitives.IsNullLike(arg.Value)))\r\n{\r\n    Expression result;\r\n    if (target.LimitType.IsNumeric())\r\n    {\r\n        result = CompareWithZero(target, Expression.GreaterThanOrEqual);\r\n    }\r\n    else if (arg.LimitType.IsNumeric())\r\n    {\r\n        result = CompareWithZero(arg, Expression.LessThanOrEqual);\r\n    }\r\n    else\r\n    {\r\n        result = LanguagePrimitives.IsNullLike(arg.Value)\r\n            ? ExpressionCache.BoxedTrue\r\n            : ExpressionCache.BoxedFalse;\r\n    }\r\n\r\n    return new DynamicMetaObject(result, target.CombineRestrictions(arg));\r\n}\r\n```\r\n\r\nPersonally, I feel like the latter is significantly clearer, and since ternary is essentially just syntax sugar iirc, this should have the same performance as the original.",
      "created_at": "2019-10-15T03:31:16Z",
      "updated_at": "2019-10-15T03:46:43Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@daxian-dbw Please look the last binder fix. It is very sensitive code.",
      "created_at": "2019-10-15T03:46:54Z",
      "updated_at": "2019-10-15T03:46:54Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@daxian-dbw @iSazonov I'll note this in the PR description too, but that last fix resolves quite a long-standing issue with `-ge` comparisons with `$null`.\r\n\r\n![image](https://user-images.githubusercontent.com/32407840/66799016-8484f580-eedd-11e9-9c1d-540271075e54.png)\r\n\r\n(This is in pwsh v7-preview3, but this disparity dates back to Windows PowerShell. Given `$null` has always been handled by `-ge` as a zero value when comparing to _other_ items, the fact that it's somehow considered \"less than\" a zero literal is... bizarre.)\r\n\r\nWith the most recent commit this is no longer an issue, and is also resolved for the above case as well.\r\n\r\nIf you feel this is wrong somehow, I can roll back the commit and alter the tests instead. (@SteveL-MSFT, I suppose this is why my tests originally had the operations backwards to what looks right, heh!)",
      "created_at": "2019-10-15T03:52:10Z",
      "updated_at": "2019-10-15T03:59:17Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "/cc @mklement0 You might be interested in last commit.\r\n",
      "created_at": "2019-10-15T04:00:43Z",
      "updated_at": "2019-10-15T04:00:43Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@vexx32 You could add a test for your last comment - to explicitly demo the side effect.",
      "created_at": "2019-10-15T04:10:22Z",
      "updated_at": "2019-10-15T04:10:22Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@iSazonov that should do the trick. If you want me to break them out completely separately, let me know, but I figured I may as well make the most of the testcases setup I have going already. \ud83d\ude42 ",
      "created_at": "2019-10-15T04:16:30Z",
      "updated_at": "2019-10-15T04:16:30Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@vexx32  The problem with making `$null -eq 0` evaluate to `$true` is that it breaks existing code that uses `$null -eq ...` to test the RHS for being truly `$null`.\r\n\r\nAside from potentially breaking existing code, this would leave PowerShell users with no straightforward way to test a value for `$null`.\r\n\r\nGenerally, it is the LHS that determines the type for the comparison,  so from that perspective `$null -eq 0` evaluating to `$false` makes sense (only the unequivocally _arithmetic_ operators `/` and `-` seems to coerce the LHS to a number too).\r\n\r\nEven if `$null -eq 0` remains `$false`, your PR will result in  the inability to test for `$null` specifically, as distinct from other null-like values such as `[DbNull]::Value` - though I suppose that's unavoidable, at least when testing with `-eq`\r\n\r\n@KirkMunro's PR https://github.com/PowerShell/PowerShell/pull/10704 comes to the rescue here, which will allow testing with `... -is $null`.\r\n\r\nAn obscure workaround is to use `[object]::ReferenceEquals()`.\r\n",
      "created_at": "2019-10-15T05:12:17Z",
      "updated_at": "2019-10-15T05:12:17Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "It looks like huge breaking change.",
      "created_at": "2019-10-15T07:00:49Z",
      "updated_at": "2019-10-15T07:00:49Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Agreed.\r\n\r\nTo put it differently: The existing asymmetry of `-eq`'s behavior - as surprising as it may be - is a feature, not a bug.",
      "created_at": "2019-10-15T07:39:56Z",
      "updated_at": "2019-10-15T07:39:56Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 I have not modified the `-eq` / `-ne` binders here. They are unaffected. The asymmetry only pertains to `-ge` / `-le`\r\n\r\nThis is why I have deemed the asymmetry worth changing. As you say, in an **arithmetic** case, the LHS is converted to a number regardless, and this has always been the case with these operators in the past when given a null value. However, the result does not match with all other conversions from null, and instead treats null as _less than_ zero, despite the fact that null values are unequivocally treated as greater than all negative values already.\r\n\r\nCasting null to a number results in **zero**. This change simply allows the -ge/-le binders to respect that instead of treating it like a weird `-$epsilon`",
      "created_at": "2019-10-15T10:44:39Z",
      "updated_at": "2019-10-15T11:15:50Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "To put it another way.... The expression `[int]$null` is `0`\r\n\r\nYet (currently) `$null -ge 0` is `$false`\r\n\r\n... That's what's wrong there. ",
      "created_at": "2019-10-15T11:22:14Z",
      "updated_at": "2019-10-15T11:22:50Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> ... That's what's wrong there.\r\n\r\nI'd ask what was wrong in scripts that we should fix? :-) It feels like we're trying to improve something that doesn't need improvement :-)",
      "created_at": "2019-10-15T11:41:18Z",
      "updated_at": "2019-10-15T11:41:18Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Perhaps. I'd argue that getting mathematical consistency should be a a desirable target. @daxian-dbw , your thoughts?",
      "created_at": "2019-10-15T11:53:31Z",
      "updated_at": "2019-10-15T11:53:31Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "I'd argue that like all comparison operators in PowerShell, the type used in the comparison is consistently driven by the type of the operand on the left-hand side.\r\n\r\nWith that, I expect `$null -ge 0` to always return `$false`, and `0 -le $null` to always return true. From a mathematical standpoint that shouldn't confuse you once you learn that the type used in the comparison is driven by the operand on the left-hand side. That's just a programming rule you need to understand, not a gotcha or a trick.",
      "created_at": "2019-10-15T12:00:54Z",
      "updated_at": "2019-10-15T12:01:21Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Hmm, that is usually true. But if it were, `0 -ge $null` should _also_ be true. And it's not. This is the _only_ case where $null is explicitly treated as less than zero. And yet also greater than any negative value.",
      "created_at": "2019-10-15T12:09:41Z",
      "updated_at": "2019-10-15T12:10:42Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> The asymmetry only pertains to -ge / -le\r\n\r\nI see, thanks; I hadn't noticed that distinction.\r\n\r\nThat's less problematic, but to me that still amounts to a problematic inconsistency - though I just realized we already have that inconsistency with `-le`.\r\n\r\nIf I understand you correctly, your change would then result in the following:\r\n\r\n```powershell\r\n$null -eq 0 # -> $false\r\n\r\n$null -ge 0 # -> $true - this is what your change will bring\r\n\r\n$null -le 0 # -> $true  # !! This is already the case, which I didn't expect.\r\n$null -lt 0 # -> $true  # !! This is currently the case, which I didn't expect.\r\n```\r\n\r\nIf it is the quasi-zero-ness of `$null` that makes the `-le` and `-ge` cases return `$true`, then why wouldn't the `-eq` case return `$true` also? Of course, `$null -lt 0` returning `$true` makes no sense.\r\n\r\nIn the abstract,  it would make more sense to let the type (non-type) of the LHS - `$null` - in this case consistently drive the behavior, so that the `-le` and `-ge` cases _fail_ with `Cannot compare $null because it is not IComparable`.\r\n\r\nNote that `-ge` and `-le` don't  _just_ have arithmetic meaning, and given that `$null` is the _LHS_ you cannot, strictly speaking, make that assumption (the way it is made with the non-overloaded `/` and `-` operators).\r\n\r\nFor instance, `'10' -ge 2` is `$false`, because _lexical_ comparison is performed - the LHS type drives the interpretation of `-ge`.\r\n\r\nIn short: Whether `-ge` / `-le` / `-gt` / `-lt` can be meaningfully applied depends on whether the type at hand implements `IComparable`.\r\n\r\n----\r\n\r\nI see the following ways to resolve this.\r\n\r\n* Do nothing - live with and document the inconsistency (not my preference).\r\n\r\n* Consistently make the LHS type/non-type dictate the behavior, which means switching the `-ge` / `-le` / `-gt` / `-lt` cases to _failing_ with `Cannot compare $null because it is not IComparable` \r\n\r\n  *  I can see how there's code out there that does `if ($uninitializedVariable -le 0) ...` (though the `if ($uninitializedVariable -ge 0) ...` currently doesn't work meaningfully - which is what motivates your fix, and neither does `if ($uninitializedVariable -lt 0) ...`).\r\n\r\n* Leave the `$null -eq 0` -> `$false` exception in place to preserve backward compatibility and make only the `-ge` / `-le` / `-gt` / `-lt` cases behave _numerically_, meaning that `$null` as the LHS is treated like `0` - that amounts to your fix, @vexx32, _plus_ also making `$null -lt 0` return `$false`.\r\n",
      "created_at": "2019-10-15T12:13:27Z",
      "updated_at": "2019-11-14T02:00:12Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "The `-eq` case doesn't return true because it's not explicitly a mathematical operation, equality is more than just math. A greater/less than comparison, though, is a mathematical operation. Or string sorting, in our cases.\r\n\r\nPretty sure I have your last option there completely implemented. There should be a test confirming your point about `$null -lt 0` but I will double check.",
      "created_at": "2019-10-15T12:17:46Z",
      "updated_at": "2019-10-15T12:17:46Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Good point about `0 -ge $null` / `0 -gt $null` / `0 -le $null` currently misbehaving too, @vexx32\r\n\r\nThere, the case is clear-cut: the numeric LHS should coerce the `$null` to a number, which should be `0`.\r\n\r\nWould this need to be a separate fix?\r\n\r\n> A greater/less than comparison, though, is a mathematical operation.\r\n\r\nWell, it's whatever the type's `IComparable` implementation defines it to be - and that doesn't have to be _numeric_ comparison, which is what we're - inconsistently - assuming here.\r\n\r\n> Or string sorting, in our cases.\r\n\r\nAgain, this comes from the _LHS_ dictating the behavior (in line with what @KirkMunro says) - and the consistent implementation of that for `$null` would be to say: you cannot compare `$null` (except to itself, with `-eq`).\r\n\r\n",
      "created_at": "2019-10-15T12:25:33Z",
      "updated_at": "2019-10-15T12:26:34Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I am happy to commit that fix separately in another PR if we prefer. Now that I see where it went wrong, it's a fairly simple asymmetry to resolve.",
      "created_at": "2019-10-15T12:34:22Z",
      "updated_at": "2019-10-15T12:34:43Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Would this need to be a separate fix?\r\n\r\nWill it again a breaking change?",
      "created_at": "2019-10-15T13:15:29Z",
      "updated_at": "2019-10-15T13:15:29Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov: \r\n\r\nIt would technically be a breaking changing, but given that the current behavior is useless in the cases we'd be fixing, I don't expect that to be a problem.\r\n\r\nLet me try to summarize the discussion, to make sure we're on the same page:\r\n\r\n* `$null -eq 0` retains its current behavior of evaluating to `$false`, because `$null` as the LHS with `-eq` must continue to function as the is-it-`$null`[-like] test.\r\n\r\n* `-ge` / `-le` / `-gt` / `-lt` behavior will be modified so that `$null` on _either_ side is implicitly treated like `0`, to make the current behavior with these operators consistent. \r\n\r\n* While this distinction between `-eq` vs.  `-ge` / `-le` / `-gt` / `-lt` behavior amounts to an overall inconsistency with respect to letting the LHS drive type coercions, given the current behavior, it strikes me as a reasonable way forward:\r\n   * The truly consistent behavior - failing with `Cannot compare $null because it is not IComparable` with `$null` as the LHS when combined with `-ge` / `-le` / `-gt` / `-lt` - is probably not that useful and _may_ break existing scripts (though the treat-as-`0` behavior currently only works in _some_ cases - see tests below).\r\n   * Absent that, I suppose another option is to _always_ return `$false` if the RHS isn't null-like, but that could again break existing scripts. \r\n\r\nAt the very least, the cases where `$null`[-like] is the _RHS_ and currently doesn't behave like `0` with a numeric LHS should be fixed.\r\n\r\nTo put it in terms of Pester tests:\r\n\r\n**Null-like as the _RHS_**:\r\n\r\n```powershell\r\n# These currently fail and should be fixed in any event.\r\n# $null[-like] should consistently be coerced to 0 in these cases.\r\n0 -eq $null | Should -BeTrue\r\n0 -ne $null | Should -BeFalse\r\n0 -gt $null | Should -BeFalse\r\n0 -le $null | Should -BeTrue\r\n\r\n# These already work as expected.\r\n0 -ge $null | Should -BeTrue\r\n0 -lt $null | Should -BeFalse\r\n```\r\n\r\n**Null-like as the _LHS_**:\r\n\r\n```powershell\r\n# Passes, and shouldn't change.\r\n# Anything other than a null-like type on the RHS should result in $false\r\n$null -eq 0 | Should -BeFalse\r\n\r\n# These are currently the only cases with $null as the LHS were\r\n# numeric interpretation works as expected:\r\n$null -le 0 | Should -BeTrue\r\n$null -lt 0 | Should -BeFalse\r\n\r\n# These currently fail from a treat-null-as-0 perspective.\r\n$null -ge 0 | Should -BeTrue\r\n$null -lt 0 | Should -BeFalse\r\n```\r\n\r\n",
      "created_at": "2019-10-15T14:05:38Z",
      "updated_at": "2019-10-16T01:39:17Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 Thanks for the summarization!\r\nThis is twice in example above\r\n> 0 -gt $null | Should -BeFalse\r\n\r\nDifference `$null -eq 0` and `0 -eq $null` is too unexpected and I believe this should not be in the scripting language, it is very bad UX.",
      "created_at": "2019-10-15T14:27:51Z",
      "updated_at": "2019-10-15T14:27:51Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @iSazonov, I've removed the duplicate test from my previous comment.\r\n\r\n> Difference $null -eq 0 and 0 -eq $null is too unexpected\r\n\r\nI agree that it is unfortunate, but not _fundamentally_ - asymmetrical `-eq` behavior is very much part of PowerShell (see below) - but because it creates a surprising behavioral difference between `-eq` / `-ne` on the one hand and `-ge` / `-le` / `-gt` / `-lt` on the other, which doesn't exist for other types (again, if `$null -ge 0` is `$true` because `$null` is treated like `0`, why wouldn't `$null -eq 0` be `$true` as well?)\r\n\r\nHowever, we cannot change `$null -eq 0` / `$null -ne 0`, because historically `$null -eq ...` has been the only robust test for comparing any value to `$null`.\r\n\r\nPragmatically speaking, interpretation of LHS `$null` as `0` with `-ge` / `-le` / `-gt` / `-lt` does make sense, especially if you consider use of uninitialized variables that evaluate to `$null` on the LHS (e.g., `if ($uninitializedVar -gt 0)`), but the - unavoidable - downside is the different behavior of  `$uninitializedVar -eq ...` / `$uninitializedVar -ne ...`\r\n\r\nAs for the fundamental asymmetry with `-eq`, due to type coercions: consider the following case:\r\n```powershell\r\nPS> 2 -eq '+2'\r\nTrue\r\n\r\nPS> '+2' -eq 2\r\nFalse\r\n```\r\n",
      "created_at": "2019-10-15T15:14:29Z",
      "updated_at": "2019-10-15T15:14:29Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Yeah, we can't avoid that difference. If we try to mess around with that we'll get in the way of PS's array-filtering semantics with `-eq` and similar operators, as well as the type coercion semantics.\r\n\r\nIt is also a bit confusing, but it does follow clearly defined rules -- unlike the current behaviour with `-ge`/`-le` \ud83d\ude01 ",
      "created_at": "2019-10-15T16:03:06Z",
      "updated_at": "2019-10-15T16:03:06Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Yeah, we can't avoid that difference.\r\n\r\nWe have been living with this for a long time.\r\nI think the best way for the project with a long history is to correct specific problems that arise in practical scenarios. As long as there is no significant business scenario, it makes no sense to make a breaking change. I would prefer such a conservative way until significant improvement ideas appear for which users will be ready to make significant changes in their bussines.\r\n\r\n",
      "created_at": "2019-10-15T17:12:50Z",
      "updated_at": "2019-10-15T17:12:50Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I understand your concerns there @iSazonov. But I would prefer the language behave as consistently as possible; the fewer strange exceptions to the rules are, the better.\r\n\r\n@daxian-dbw can you or the @PowerShellTeam weigh in on this aspect? It's not critical to this PR, but I feel it would make sense to take care of within the scope of this PR if we're going to do so.\r\n\r\nQuick summary: the `-ge` and `-le` operators treat `$null` as though it's a `-epsilon` (larger than any negative number but smaller than zero) value when the other side of the operator is a numeric value. This is counter to all other coercions involving `$null` as a number where it is considered _equal_ to `0`. I propose that `0 -le $null` and `0 -ge $null` both return `$true`, and `$null` be considered precisely `0` in a purely numeric context.",
      "created_at": "2019-10-15T17:33:18Z",
      "updated_at": "2019-10-15T17:36:11Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee reviewed this and is concerned that changing this behavior will break other scenarios that rely on the variants of null to be different due to loss of information.  We did not conclude on this but agreed it isn't necessary for PS7.",
      "created_at": "2019-11-14T00:44:20Z",
      "updated_at": "2019-11-14T00:44:20Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@SteveL-MSFT is that specifically about having `-ge` and `-le` treat $null as `0` that we're wanting to retain? Or are you talking about this PR as a whole? (If so; the current behaviour for NullString/DBNull with `-ge` and `-le` is simply to throw an error, so I don't think we'd be breaking much here.) \ud83d\ude42 ",
      "created_at": "2019-11-14T01:28:52Z",
      "updated_at": "2019-11-14T01:28:52Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "cc @JamesWTruher ",
      "created_at": "2019-12-04T23:48:02Z",
      "updated_at": "2019-12-04T23:48:02Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee has discussed this last week as part of a broader `[DBNull]` discussion.  Concern is whether we made the right decision to allow `[DBNull]::value -eq $null` which has brought up many other related issues and also introducing regressions.  We agreed to revert the change where `[DBNull]::value -eq $null` and encourage continued discussion particularly with DB users of PowerShell to understand the pain points related to use of DBNull and how to best address it in PowerShell thinking holistically across the language including other operators and method invocations, etc... that have come up.",
      "created_at": "2020-01-15T17:46:41Z",
      "updated_at": "2020-01-15T17:46:41Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> encourage continued discussion particularly with DB users of PowerShell\r\n\r\nPlease add reference to the issue.",
      "created_at": "2020-01-16T03:11:01Z",
      "updated_at": "2020-01-16T03:11:01Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "Created https://github.com/PowerShell/PowerShell/issues/11604",
      "created_at": "2020-01-16T19:21:19Z",
      "updated_at": "2020-01-16T19:21:19Z"
    }
  ],
  "created_at": "2019-08-22T17:23:00Z",
  "number": 10422,
  "state": "closed",
  "title": "Improve Null-Like behaviour in comparisons",
  "updated_at": "2020-06-13T22:08:35Z"
}