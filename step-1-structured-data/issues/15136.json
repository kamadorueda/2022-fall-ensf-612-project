{
  "_url": "https://github.com/PowerShell/PowerShell/issues/15136",
  "author": "iRon7",
  "body": "## Add **`-FromPattern`** and **`-ToPattern`** parameters to [`Select-String`](https://docs.microsoft.com/powershell/module/microsoft.powershell.utility/select-string) cmdlet.\r\n\r\nIt is often required to select the lines between two other lines define by regulars expressions as show from e.g. the Stackoverflow  Q&As:\r\n- [Extract specific text and extract](https://stackoverflow.com/questions/66886161/extract-specific-text-and-extract)\r\n- [How to select between multiple lines in power shell?](https://stackoverflow.com/questions/53393884/how-to-select-between-multiple-lines-in-power-shell)\r\n- [How to read lines between 2 special characters in txt-file with Powershell](https://stackoverflow.com/questions/47611180/how-to-read-lines-between-2-special-characters-in-txt-file-with-powershell)\r\n- [Unable to get data between multiple keyword using powershell](https://stackoverflow.com/questions/45615089/unable-to-get-data-between-multiple-keyword-using-powershell)\r\n- [Need Regex to match multiple lines until Match is found between common delimiters](https://stackoverflow.com/questions/37178732/need-regex-to-match-multiple-lines-until-match-is-found-between-common-delimiter?r=SearchResults \"Need Regex to match multiple lines until Match is found between common delimiters\")\r\n- [Extract multiple lines of text between two key words from shell command in powershell](https://stackoverflow.com/questions/26890978/extract-multiple-lines-of-text-between-two-key-words-from-shell-command-in-power)\r\n- [Extract block of text using regex and powershell](https://stackoverflow.com/questions/53952978/extract-block-of-text-using-regex-and-powershell)\r\n- [Need to search a line from a long config file with powershell](https://stackoverflow.com/questions/50270218/need-to-search-a-line-from-a-long-config-file-with-powershell)\r\n- [Powershell Regex: Reading a multi-line string between two points](https://stackoverflow.com/questions/27942804/powershell-regex-reading-a-multi-line-string-between-two-points?r=SearchResults \"Powershell Regex: Reading a multi-line string between two points\")\r\n- [How can I deleted lines from a certain position?](https://stackoverflow.com/a/70169550/1701026)\r\n- [Regex match multiple lines from file](https://stackoverflow.com/q/70952582/1701026)\r\n- [Extract data from log file and copy data to another text file using powershell](https://stackoverflow.com/questions/71436014/extract-data-from-log-file-and-copy-data-to-another-text-file-using-powershell)\r\n- ...\r\n\r\nTo setup a function using the [`Select-String`](https://docs.microsoft.com/powershell/module/microsoft.powershell.utility/select-string) cmdlet and properly stream the input and output, currently requires to get track of whether any line needs to be passed thru or not. Therefore functions for this often end up in stalling the pipeline and doing an expensive regular expression over a full multiple line text string.  \r\n`-FromPattern` and `-ToPattern` parameters would allow for a better implementation and an easier syntax to perform this specific common string selection.\r\n\r\n## Include or Exclude?\r\nThis propose raises the question whether the found line that contains the `-FromPattern` and `-ToPattern`  expression should be included or excluded in the output.  \r\nIn my vision for this propose the output should start right after the point where the `-FromPattern` expression is found (and output any succeeding string) and stop right before the point where the `-ToPattern` expression is found (and output any preceding string). This will allow the developer to select what needs to be passed thru using the concerned regular expressions:\r\n\r\n## Prototype\r\n```PowerShell\r\nfunction SelectString {\r\n    [CmdletBinding()] param(\r\n        [Parameter(ValueFromPipeLine = $True)][String]$String,\r\n        [Regex]$FromPattern,\r\n        [Regex]$ToPattern\r\n    )\r\n    begin {\r\n        $PassThru = !$PSBoundParameters.ContainsKey('FromPattern') -and $PSBoundParameters.ContainsKey('ToPattern')\r\n    }\r\n    process {\r\n        $Start = 0\r\n        do { # There could be (multiple) $FromPattern/$ToPattern matches in one line\r\n            if ($PassThru) {\r\n                $ToMatch = if ($PSBoundParameters.ContainsKey('ToPattern')) { $ToPattern.Match($String, $Start) }\r\n                if ($ToMatch.Success) {\r\n                    $PassThru = $False\r\n                    $Length = $ToMatch.Index - $Start\r\n                    if ($Length) { $String.SubString($Start, $Length) }\r\n                    $Start = $ToMatch.Index + $ToMatch.Length\r\n                }\r\n                else {\r\n                    $String.SubString($Start)\r\n                    $Start = $String.Length\r\n                }\r\n            }\r\n            if (!$PassThru) {\r\n                $FromMatch = if ($PSBoundParameters.ContainsKey('FromPattern')) { $FromPattern.Match($String, $Start) }\r\n                if ($FromMatch.Success) {\r\n                    $PassThru = $True\r\n                    $Start = $FromMatch.Index + $FromMatch.Length\r\n                }\r\n                else {\r\n                    $Start = $String.Length\r\n                }\r\n            }\r\n        } Until ($Start -ge $String.Length)\r\n    }\r\n}\r\n```\r\n<sub>(Note: this prototype is case sensitive.)</sub>\r\n\r\n## Examples\r\n\r\nIn the examples below the follow string list is use for `$Test`:\r\n```PowerShell\r\n$Test = @'\r\n[One]\r\n[Two]\r\n<Start>[Three]\r\n[Four]\r\n[Five][Six]\r\n[Seven]<End>\r\n[Eight]\r\n[Nine]\r\n'@ -Split '[\\r\\n]+'\r\n```\r\n### Example 1\r\nSelect everything between the `-From` and `-To`  expression:\r\n```PowerShell\r\n$Test | SelectString -From '\\<Start\\>' -To '\\<End\\>'\r\n\r\n[Three]\r\n[Four]\r\n[Five][Six]\r\n[Seven]\r\n```\r\n\r\n### Example 2\r\nExclude the lines that matches the `-From` and `-To`  expression:  \r\n(By matching the whole line)\r\n```PowerShell\r\n$Test | SelectString -From '\\<Start\\>.*' -To '.*\\<End\\>'\r\n\r\n[Four]\r\n[Five][Six]\r\n```\r\n\r\n### Example 3\r\nInclude the lines that matches the `-From` and `-To`  expression:\r\n(By using lookbehind and lookforward regular expressions)\r\n```PowerShell\r\n$Test | SelectString -From '(?=\\<Start\\>)' -To '(?<=\\<End\\>)'\r\n\r\n<Start>[Three]\r\n[Four]\r\n[Five][Six]\r\n[Seven]<End>\r\n```\r\n\r\n### Example 4\r\nSelect multiple items in a single line:\r\n<sub>(Note: [# Revisit the behavior of chaining Select-String calls `#14850`](https://github.com/PowerShell/PowerShell/issues/14850))</sub>\r\n```PowerShell\r\n$Test | SelectString -From '\\<Start\\>' -To '\\<End\\>' | SelectString -From '\\[' -To '\\]'\r\n\r\nThree\r\nFour\r\nFive\r\nSix\r\nSeven\r\n```\r\n\r\n## Caveats\r\nThe `Select-String` cmdlet has already quite some parameters, some of the parameters (like `-Pattern` should be mutual exclusive with these proposed `-FromPattern` and `-ToPattern` parameters.\r\nThe `-Context` parameter might still apply: where the first integer refers to the number of lines before the line where the `-FromPattern` expression is found and the second integer to the number of lines after the line where the `-ToPattern` expression is found.",
  "closed_at": null,
  "comments": [
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I like the idea; a few comments:\r\n\r\n* `-From` and `-To` is probably a better pairing, though perhaps, given that `-Pattern` is already `[string[]]` typed,  a `-Between` switch is enough (though perhaps then having to enforce exactly 2 arguments in the cmdlet itself is awkward, and the shift in logic would have to be well-documented).\r\n\r\n* Whether to include the delimiting patterns or not could be handled similar to the `-split` operator: exclude by default, except if _capture groups_ are present in the patterns. This would be a simpler alternative to the look-around assertions.\r\n\r\n* What about extracting _multiple_ blocks? Following the current behavior, this should happen _by default_, except if `-List` is present, which, however, currently only applies to _files_ as input: at most one match _per file_. `-AllMatches` relates to multiple matches _per line_ (input object), and should probably not be repurposed in this context.\r\n\r\n* What if a _multiline_ string _as a single object_ is provided as the input - should automatic splitting into lines then be performed?\r\n\r\n",
      "created_at": "2021-04-01T17:23:05Z",
      "updated_at": "2021-04-01T17:23:05Z"
    },
    {
      "author": "p0W3RH311",
      "author_association": "NONE",
      "body": "great idea,\r\n\r\naother idea is to use another parameterSets `Byfields`, and use` -FieldsSeparators` parameter. the two parameter is separated by `|` and its must include 2 filed like this\r\n\r\n`$test | select-string -FieldsSeperator '\\<Start\\>|\\<End\\>'`\r\n",
      "created_at": "2021-04-02T02:51:19Z",
      "updated_at": "2021-04-02T02:51:19Z"
    },
    {
      "author": "bpayette",
      "author_association": "CONTRIBUTOR",
      "body": "You can do this sort of thing using the `switch` statement. For example, to output everything between \"start\" and \"stop\" do\r\n```powershell\r\n$extractedText = switch -regex ($test) { \"start\" {$print=$true} {$print} {$_} \"end\" {$print=$false}}\r\n```\r\nIt's a bit more work but this approach is ultimately more powerful (and faster). Now a nice addition to `switch` would be regex \"ranges\" like:\r\n```powershell\r\nswitch -regex ($test) { \"start\",\"end\" {$_}}\r\n```\r\nwhich simplifies everything. (The `switch` statement is roughly modelled on AWK but was never as complete as I wanted it to be.)",
      "created_at": "2021-04-02T02:52:32Z",
      "updated_at": "2021-04-02T02:52:32Z"
    },
    {
      "author": "p0W3RH311",
      "author_association": "NONE",
      "body": "@BrucePay \r\n\r\nthe range extension is powerfull and i hope it implemented. \r\nalso select-string need -fieldsSeparators like in awk  ",
      "created_at": "2021-04-02T03:43:14Z",
      "updated_at": "2021-04-02T03:43:14Z"
    },
    {
      "author": "doctordns",
      "author_association": "COLLABORATOR",
      "body": "I hate an operator named `-Till` - what soil is going to be tilled by it?\r\n\r\nWhy not `-Until`",
      "created_at": "2021-04-02T13:24:25Z",
      "updated_at": "2021-04-02T13:24:25Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "Thanks for the comments and support,\r\n\r\n@mklement0,\r\n> `-From` and `-To` is probably a better pairing\r\n\r\nYou probably right, the reason I used `Till` is because in my language (Dutch) we use different conjunctions for a verb like `Select` (***from** X **To** Y*) than a verb like `Move`  (***from** X **To** Y*) and they do have indeed a slightly different meaning.  \r\nAnyways,  I don't care much with parameter names are eventually chosen. I have changed the original purpose according to this suggestion. (Also note @doctordns' suggestion: `Until` might also be correct).\r\n\r\n> a `-Between` switch is enough\r\n\r\nBesides your own counter argument, I would also like to be able to omit one or the other parameter. The point is that the default expression for both parameters is not an empty expression but more something like [`(?=a)b`](https://stackoverflow.com/a/3609359) (always false). This will work for omitting the `-ToPattern` parameter, but there is even a little pitfall in omitting the `-FromPattern` parameter: you might think this should default to something like `.*` to start with the first line, but the result be that it will immediately reenables the \"PassTrue\" again after the `ToPattern` is found. Knowing that I would also expect to receive *multiple* `From`/`To` blocks when they exist, e.g.:\r\n```PowerShell\r\n($Test + $Test) |SelectString -From '\\<Start\\>.*' -To '.*\\<End\\>'\r\n\r\n[Four]\r\n[Five][Six]\r\n[Four]\r\n[Five][Six]\r\n```\r\nIn other words, To receive just the last block, I would like to be able to do this:\r\n(Select everything from the first `End` marker and then select everything between `Start` and `End`)\r\n```PowerShell\r\n($Test + $Test) |SelectString -From '\\<End\\>.*' |SelectString -From '\\<Start\\>.*' -To '.*\\<End\\>'\r\n```\r\nI have updated the prototype a little for being able to omit the `-FromPattern` or `-ToPattern` parameters.  \r\nYou can of cause still do something similar with a single `-Between` parameter but I think it is less clearer with omitting the `From` or `To`.\r\n\r\n> `-List` and `-AllMatches`\r\n\r\nAs in the example in the above response, I think that these parameters are indeed a little redundant taken the flexibility of these purposed parameters. Anyways, if the purpose is accepted, I am happy to give it some deeper thoughts on how these existing parameters could be combined (or mutual excluded).\r\n\r\n> What if a _multiline_ string _as a single object_ is provided as the input - should automatic splitting into lines then be performed?\r\n\r\nI don't think they should be automatically be split. Instead, I would like to be able to do this:\r\n```PowerShell\r\n... |Out-String -Stream |Select-String ...\r\n```\r\n(According to your issue [`Out-String -Stream`  unexpectedly does not split multi-line input strings into individual lines too `#14638`](https://github.com/PowerShell/PowerShell/issues/14638))\r\n\r\n@p0W3RH311,\r\n\r\n> use `-FieldsSeparators` parameter\r\n\r\nI think that regular expressions are to complicated by itself to be joined to a single string (what if \"`|`\" is part of my search pattern?).",
      "created_at": "2021-04-02T15:37:30Z",
      "updated_at": "2021-04-03T07:42:08Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "@bpayette,\r\n> It's a bit more work but this approach is ultimately more powerful (and faster)\r\n\r\nI like your alternative, but <strike>I don't see why it is \"*more powerful (and faster)*\". Besides</strike> as you mentioned yourself, it is more work and apparently requires more programming skills. Taken your own example, you should initiate `$print`, if you neglect to do so and coincidently define `$print` at a higher scope (which in most cases trutifies), it will fail and start to output from the beginning.",
      "created_at": "2021-04-02T16:15:15Z",
      "updated_at": "2021-04-08T08:01:56Z"
    },
    {
      "author": "p0W3RH311",
      "author_association": "NONE",
      "body": "@iRon7 \r\n\r\n`I think that regular expressions are to complicated by itself to be joined to a single string (what if \"|\" is part of my search pattern?).`\r\n\r\nthe solution is to umbed the 2 regex inside quote/dquote like:\r\n\r\n`$test | select-string -FieldsSeperator \"'^\\|'|'\\|$'\"`\r\n\r\nor maybe more clean and powershell-way with hash\r\n\r\n\r\n```\r\n$test | select-string -FieldsSeperator @{ \r\n  First = 'regex'\r\n  Last = 'regex'\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2021-04-02T17:54:39Z",
      "updated_at": "2021-04-02T17:55:51Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@p0W3RH311, I don't think we want to refashion `Select-String` into an `awk`-like utility, which is both much more open-ended in its purpose while offering convenient features for splitting _each line_ into fields, which doesn't really apply to `Select-String`.\r\n\r\n@iRon7, understood re separate `-FromPattern` and `-ToPattern` parameters and splitting multi-line input.\r\n\r\n>  I don't see why it is \"more powerful (and faster)\".\r\n\r\n`switch` is indeed much more open-ended and flexible than `Select-String` and, as a language statement that doesn't (typically) process pipeline input object by object, it is generally significantly faster (especially with collections already in memory in full); the only case in which `Select-String` can (slightly) outperform `switch -File` is when `Select-String` is passed a _filename_ rather than object-by-object pipeline input, in which case it reads the file itself, efficiently.\r\n\r\nBut, as in previous conversations, this is not an either-or scenario:\r\n_Both_ your proposal and @BrucePay's `switch` enhancement sound like they may be worthwhile.\r\n\r\n(If that is the consensus, then the new features should at least work _similarly_, and one challenge that comes to mind is that the `'<regex>', '<regex>'` syntax - familiar from both `awk` and `sed` - has _inclusive_ logic; that is, the lines matching the patterns are selected too. Also, given the context, the syntax may inspire the expectation that `'<regex>', '<regex>'` will select any _single_ line matching _any one_ of the (two) specified regexes. `switch` offers great flexibility already, but does have complexity, and adding to that may be a concern.)\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2021-04-02T20:00:41Z",
      "updated_at": "2021-04-02T20:00:41Z"
    },
    {
      "author": "p0W3RH311",
      "author_association": "NONE",
      "body": "@mklement0 \r\n\r\nhello, thanks for your precision. but the second example  is a powershell-way and its much elegant and flexible than awk or sed , perhaps we can extented like:\r\n\r\n```\r\n$test | select-string -FieldsSeperator @{ \r\n  First = 'regex'\r\n  Last = 'regex'\r\n  Inclusive = $true/$false\r\n}\r\n```\r\n\r\nselect-string is inspired from grep but its limited and miss a lot of thing ",
      "created_at": "2021-04-03T02:23:28Z",
      "updated_at": "2021-04-03T02:26:58Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "@bpayette,\r\n\r\n<sub>@mklement0, is right (as usual\ud83d\ude0a) \"*it is not an either-or scenario*\". Therefore, I hidded my previous comment and rewrote it below)</sub>\r\n\r\n```PowerShell\r\n$extractedText = switch -regex ($test) { \"start\" {$print=$true} {$print} {$_} \"end\" {$print=$false}}\r\n```\r\nUsing the current switch statement, as you mentioned yourself and an argument for this propose; it is more work and requires more programming skills. Taken your own example, you should initiate `$print`, if you neglect to do so and coincidently define `$print` at a higher scope (which in most cases trutifies), it will fail as it will start to output from the beginning.\r\n\r\n```PowerShell\r\nswitch -regex ($test) { \"start\",\"end\" {$_}}\r\n```\r\nI definitely, like the `switch` range suggestion. One thing to consider thou, is how to being able to omit one or the other pattern (to select *everything from `\"start\"` marker to the **end-of-Stream*** or *select everything from the **Start-of-Stream** to the `\"end\"` marker*, see also my comment on: [`a -Between switch is enough`](https://github.com/PowerShell/PowerShell/issues/15136#issuecomment-812582319)).\r\nAnyways, I would recommend to open a seperate [Feature Request/Idea \ud83d\ude80](https://github.com/PowerShell/PowerShell/issues/new?assignees=&labels=Issue-Enhancement%2C+Needs-Triage&template=Feature_Request.md&title=Feature+Request) for this.\r\n",
      "created_at": "2021-04-03T10:11:54Z",
      "updated_at": "2021-04-03T12:24:00Z"
    }
  ],
  "created_at": "2021-04-01T15:11:39Z",
  "labels": [
    "Issue-Enhancement",
    "WG-Language",
    "Needs-Triage"
  ],
  "number": 15136,
  "state": "open",
  "title": "Add `-From` and `-To` parameters to `Select-String`",
  "updated_at": "2022-11-08T10:25:18Z"
}