{
  "_url": "https://github.com/PowerShell/PowerShell/issues/17957",
  "author": "CanineBarbie",
  "body": "### Prerequisites\n\n- [X] Write a descriptive title.\n- [X] Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\n- [X] Search the existing issues.\n- [X] Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\n- [X] Refer to [Differences between Windows PowerShell 5.1 and PowerShell](https://docs.microsoft.com/powershell/scripting/whats-new/differences-from-windows-powershell).\n\n### Steps to reproduce\n\nI have found this or similar behaviour when using using Start-ThreadJob or another Runspace and PS::Create. Class instances are not serialised and report their proper class name via GetType. The timing of calls to nested methods determines whether the call succeeds or causes a deadlock of some kind. The lockup causes the task/job to reaming in a \"running\" state forever, not faulted or able to exit. Is this caused by something like a race? I'm not expert enough in multi-threading to know what's going on.\r\n\r\nThis code reproduces the issue in PS 7.2.6. The calls that would be fatal are commented. The purpose was initially to test whether the GC would prematurely collect object instances passed to other threads after the instance went out of scope on the calling thread, but then I encountered (again) the issue I describe here.\r\n\r\n```\r\n$ErrorActionPreference = \"Stop\"\r\nSet-StrictMode -Version Latest\r\n\r\nclass test_class : System.IDisposable\r\n{\r\n    test_class([int] $Id)\r\n    {\r\n        $this._id = $Id\r\n    }\r\n\r\n    [int] $_id\r\n\r\n    [void] Dingaling()\r\n    {\r\n        \"{0}:{1} is disposed? {2}\" -f $this.GetType(), $this._id, $this._disposed | Out-Host\r\n    }\r\n\r\n    [int] GetId()\r\n    {\r\n        return $this._id\r\n    }\r\n\r\n    [void] NullFunc()\r\n    {\r\n        # does nothing at all!\r\n    }\r\n\r\n    [void] CallThisNullFunc()\r\n    {\r\n        \"calling this.NullFunc\" | Out-Host\r\n        \"our type is $($this.GetType())\" | Out-Host\r\n        $this | Out-String | Out-Host\r\n        #$this.NullFunc | Out-String | Out-Host # fatal\r\n        $this.NullFunc() # fatal\r\n        \"returned from this.NullFunc\" | Out-Host\r\n    }\r\n\r\n    [void] CallThisDispose()\r\n    {\r\n        \"yo ho ho, callin' this.Dispo'\" | Out-Host\r\n        $this.Dispose()\r\n    }\r\n    \r\n    $_disposed = $false\r\n\r\n    [void] Dispose()\r\n    {\r\n        $this.Dispose($true)\r\n        #[System.GC]::SuppressFinalize($this)\r\n    }\r\n\r\n    [void] Dispose([bool] $Disposing)\r\n    {\r\n        \"yarrr we be disposin' {0}!\" -f $this._id | Out-Host\r\n        $this._disposed = $true\r\n    }\r\n    \r\n    [void] Finalize()\r\n    {\r\n        \"yarrr we be finalizin' {0}!\" -f $this._id | Out-Host\r\n        $this.Dispose($false)\r\n    }\r\n} # end class\r\n\r\nfunction test_func2\r\n{\r\n    $test2 = [test_class]::new(2)\r\n    $test2.Dingaling()\r\n    #$test2 = $null # should be collected by gc\r\n}\r\n\r\ntest_func2\r\n\"call gc after test_func2\"\r\n[System.GC]::Collect()\r\n\r\n$otherPs = [powershell]::Create()\r\n$otherPs.RunspacePool = [runspacefactory]::CreateRunspacePool(1,2)\r\n$otherPs.RunspacePool.Open()\r\n\r\nfunction test_func\r\n{\r\n    # use a function so test goes out of scope\r\n    $test = [test_class]::new(1)\r\n\r\n    $otherPs.AddScript({param($test)\r\n        #$test.Dispose() # no problems if called here\r\n        $test.CallThisNullFunc() # fine here\r\n        $test.Dingaling()\r\n        \r\n        Start-Sleep -Seconds 10\r\n        \r\n        $test.Dingaling()\r\n        $test.Dingaling()\r\n        #$test.Dispose() # fatal if called here\r\n        $test.Dingaling()\r\n        \"our id is $($test.GetId())\"\r\n        $test.NullFunc() # this is fine\r\n        $test.CallThisNullFunc() # fatal if called here, script will never end\r\n        #$test.CallThisDispose() # also fatal here\r\n        #$test.Dispose() # or here\r\n    })\r\n    $otherPs.AddArgument($test)\r\n}\r\n\r\n\"call test_func\"\r\ntest_func\r\n\r\n\"begin invoke\"\r\n$timer = [System.Diagnostics.Stopwatch]::new()\r\n$timer.Start()\r\n$runState = $otherPs.BeginInvoke()\r\n\r\n#Start-Sleep -Seconds 15 # doesn't help\r\n\r\nwhile (-not $runState.IsCompleted) {\r\n    \"not done yet: {0}\" -f ($runState | Out-String)\r\n    Start-Sleep -MilliSeconds 3000\r\n    [System.GC]::Collect()\r\n\r\n    if (20 -lt $timer.Elapsed.TotalSeconds) {\r\n        \"terminate test after {0}s\" -f $timer.Elapsed.TotalSeconds\r\n        break\r\n    }\r\n}\r\n\r\n$otherPs.InvocationStateInfo # \"running\"... forever\r\n$otherPs.EndInvoke($runState) # fails to return\r\n\"runspace faulted? {0}\" -f $otherPs.HadErrors\r\n$otherPs.Streams.Error | Out-Host\r\n\r\n$otherPs.RunspacePool.Close()\r\n$otherPs.Dispose()\r\n$otherPs = $null\r\n\r\n1..10 | ForEach-Object {\r\n    Start-Sleep -MilliSeconds 1000\r\n    \"do gc collection then quit\"\r\n    [System.GC]::Collect()\r\n}\r\n```\n\n### Expected behavior\n\n```console\nPS class methods that call other methods via $this.OtherMethod() should succeed.\n```\n\n\n### Actual behavior\n\n```console\nOnly PS class methods that do not call $this.OtherMethod succeed. Methods that call $this.OtherMethod succeed until the point at which they call OtherMethod. Then we encounter a deadlock of some kind.\r\n\r\n**However** this depends on the timing of the call. As shown in the comments, calls made immediately after the worker thread begins appear to work; calls made after `Start-Sleep` will fail.\n```\n\n\n### Error details\n\n_No response_\n\n### Environment data\n\n```powershell\n$psversiontable\r\n\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.2.6\r\nPSEdition                      Core\r\nGitCommitId                    7.2.6\r\nOS                             Microsoft Windows 10.0.22000\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\n```\n\n\n### Visuals\n\n_No response_",
  "closed_at": "2022-09-02T20:01:33Z",
  "comments": [
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "Duplicate of #12801",
      "created_at": "2022-09-01T17:13:31Z",
      "updated_at": "2022-09-01T17:13:31Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "Not exactly duplicate in reported behavior but same cause. PowerShell classes are bound to the runspace they're created in and cannot safely be used between different runspaces.",
      "created_at": "2022-09-01T17:14:00Z",
      "updated_at": "2022-09-01T17:14:00Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This issue has been marked as duplicate and has not had any activity for **1 day**. It has been closed for housekeeping purposes.",
      "created_at": "2022-09-02T20:01:32Z",
      "updated_at": "2022-09-02T20:01:32Z"
    }
  ],
  "created_at": "2022-08-24T10:59:31Z",
  "labels": [
    "Issue-Bug",
    "Resolution-Duplicate"
  ],
  "number": 17957,
  "state": "closed",
  "title": "Unexpected behaviour calling nested methods in PS class passed to other thread",
  "updated_at": "2022-09-02T20:01:33Z"
}