{
  "_url": "https://github.com/PowerShell/PowerShell/issues/6889",
  "author": "ChrisMagnuson",
  "body": "There are often scenarios where you need `$PSBoundParameters` but with some parameter(s) excluded, some renamed, and others possibly added to get the correct parameters needed for another function your calling.\r\n\r\nThere are many existing ways to manipulate `$PSBoundParameters` but they are not intuitive due to the type of `$PSBoundParameters`.\r\n\r\nIf we had `$PSBoundParametersObject` we could do things like:\r\n```\r\n$ParametersNeededToCallFunction = $PSBoundParametersObject | \r\nSelect-Object -Property <Properties> -ExcludeProperty <ExcludedProperties> | \r\nAdd-Member -MemberType NoteProperty -Name Path -Value \"C:\\Path\" -PassThru |\r\nAdd-Member -MemberType AliasProperty -Name ComputerName -Value IPAddress\r\n```\r\n\r\nAdding the ability to splat PSCustomOjbects we could then do:\r\n```\r\nInvoke-Something @ParametersNeededToCallFunction\r\n```\r\n\r\nThis would allow better knowledge reuse as someone who takes the time to learn Select-Object and Add-Memeber now can intuitively deal with bound parameters.\r\n\r\nThis would be better than having to learn about and deal with a lot of the quirks related to `System.Management.Automation.PSBoundParametersDictionary` which are not as generally applicable.",
  "closed_at": null,
  "comments": [
    {
      "author": "ChrisMagnuson",
      "author_association": "NONE",
      "body": "In case it helps provide context, I use a helper function [ConvertFrom-BSBoundParameters](https://github.com/Tervis-Tumbler/WebServicesPowerShellProxyBuilder/blob/8f344871349b565c7e270b74bdfef9df032348f8/WebServicesPowerShellProxyBuilder.psm1#L153) to accomplish a [similar style of coding ](https://github.com/Tervis-Tumbler/TervisActiveDirectory/blob/684257fae2bfdcd9aaeabf08fdadb76d63449bbe/TervisActiveDirectory.psm1#L12) now.",
      "created_at": "2018-05-17T14:25:10Z",
      "updated_at": "2018-05-17T14:27:07Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "This is a neat idea, but I must say this should have a slightly shorter name!",
      "created_at": "2018-05-19T14:11:05Z",
      "updated_at": "2018-05-19T14:11:05Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "I'm not sure I see how this is a win. Because `$PSBoundParameters` is essentially just a hashtable, all the normal things you do with hashtables just work. Adding a property is simple assignment:\r\n``` \r\n$PSBoundParameters.Name = \"c:\\Path\"\r\n$PSBoundParameters.ComputerName = $ipaddress\r\n```\r\nand removing a property is done with the `Remove()` method.\r\n```\r\n$PSBoundParameters.Remove(\"propertytoremove\")\r\n```\r\nThis seems simpler than messing around with `Select-Object` and `Add-Member` and will definitely be much faster. What am I missing?",
      "created_at": "2018-05-24T00:34:28Z",
      "updated_at": "2018-05-24T00:34:28Z"
    },
    {
      "author": "ChrisMagnuson",
      "author_association": "NONE",
      "body": "@BrucePay I have taken what you have said to heart and been writing code since you posted this in the style you proposed as I figured doing it this way would help me better explain the difficulties with this pattern.\r\n\r\nSome observations:\r\n\r\n1. `$PSBoundParameters.Remove(\"propertytoremove\")` returns `True` or `False` depending on whether the property was present so in practice you always have to remember to do something like `| Out-Null` or you will likely break code calling your function\r\n2. If we had `$PSBoundParametersObject` the code we write feels cleaner and more clear\r\n   1. Below are two examples of the same function that ends up calling another function that makes a web service call that needs to have some parameters in the body of the request, some in the query string, and some to change the behavior of the function making the request (like setting authorization headers).\r\n\r\n### Using $PSBoundParameters as it is today\r\n```\r\nfunction New-FreshDeskTicket {\r\n    param (\r\n        $name,\r\n        $requester_id,\r\n        $email,\r\n        $facebook_id,\r\n        $phone,\r\n        $twitter_id,\r\n        $unique_external_id,\r\n        $subject,\r\n        #.. 17 more parameters go here but removed for brevity\r\n        $Credential,\r\n        $SubDomain\r\n    )\r\n\r\n    $InvokeAPIParameters = @{}\r\n    $PSBoundParameters.Keys | \r\n    Where-Object Name -In \"Credential\",\"SubDomain\" | \r\n    ForEach-Object { \r\n        $InvokeAPIParameters.Add($_, $PSBoundParameters.$_)\r\n    }\r\n\r\n    $QueryStringParameters = @{}\r\n    $PSBoundParameters.Keys | \r\n    Where-Object Name -In \"requester_id\",\"unique_external_id\" | \r\n    ForEach-Object { \r\n        $QueryStringParameters.Add($_, $PSBoundParameters.$_)\r\n    }\r\n\r\n    $PSBoundParameters.Remove(\"Credential\") | Out-Null\r\n    $PSBoundParameters.Remove(\"Domain\") | Out-Null\r\n    \r\n    Invoke-FreshDeskAPI -Body $PSBoundParameters -QueryString $QueryStringParameters -Resource tickets -Method Post @InvokeAPIParameters\r\n}\r\n```\r\n\r\n### Using $PSBoundParametersObject\r\n```\r\nfunction New-FreshDeskTicket {\r\n    param (\r\n        $name,\r\n        $requester_id,\r\n        $email,\r\n        $facebook_id,\r\n        $phone,\r\n        $twitter_id,\r\n        $unique_external_id,\r\n        $subject,\r\n        #.. 17 more parameters go here but removed for brevity\r\n        $Credential,\r\n        $SubDomain\r\n    )\r\n    $InvokeAPIParameters = $PSBoundParametersObject | Select-Object -Property Credential,SubDomain    \r\n    $QueryStringParameters = $PSBoundParametersObject | Select-Object -Property requester_id,unique_external_id\r\n    $BodyParameters = $PSBoundParametersObject | Select-Object -ExcludeProperty Credential,Domain,requester_id,unique_external_id\r\n\r\n    #When https://github.com/PowerShell/PowerShell/issues/7049 is resolved we won't need the following if statement\r\n    if (-Not $InvokeAPIParameters) {\r\n        $InvokeAPIParameters = [PSCustomObject]@{} \r\n    }\r\n    \r\n    Invoke-FreshDeskAPI -Body $BodyParameters -QueryString $QueryStringParameters -Resource tickets -Method Post @InvokeAPIParameters\r\n}\r\n```\r\n",
      "created_at": "2018-08-10T15:53:39Z",
      "updated_at": "2018-08-10T16:37:59Z"
    },
    {
      "author": "dragonwolf83",
      "author_association": "NONE",
      "body": "You can pretty much do everything in your `PSBoundParametersObject` example if you use `.GetEnumerator()`. The code is just as simple as yours:\r\n\r\n```PowerShell\r\nfunction New-FreshDeskTicket {\r\n    param (\r\n        $name,\r\n        $requester_id,\r\n        $email,\r\n        $facebook_id,\r\n        $phone,\r\n        $twitter_id,\r\n        $unique_external_id,\r\n        $subject,\r\n        #.. 17 more parameters go here but removed for brevity\r\n        $Credential,\r\n        $SubDomain\r\n    )\r\n\t\r\n    $InvokeAPIParameters = $PSBoundParameters.GetEnumerator() | Where-Object Key -In \"Credential\", \"SubDomain\"\r\n    $QueryStringParameters = $PSBoundParameters.GetEnumerator() | Where-Object Key -In \"requester_id\", \"unique_external_id\"\r\n    $BodyParameters = $PSBoundParameters.GetEnumerator() | Where-Object Key -NotIn @($InvokeAPIParameters.key + $QueryStringParameters.Key)\r\n\t\r\n    if( -not $InvokeAPIParameters ) {\r\n        Invoke-FreshDeskAPI -Body $BodyParameters -QueryString $QueryStringParameters -Resource tickets -Method Post @InvokeAPIParameters\r\n    }\r\n}\r\n\r\nNew-FreshDeskTicket -Credential \"TestCred\" -SubDomain \"TestDomain\" -requester_id \"ID1\" -unique_external_id \"EXID1\" -name \"TestName\" -email \"TestEmail\"\r\n```",
      "created_at": "2018-08-11T00:43:01Z",
      "updated_at": "2018-08-11T00:45:12Z"
    },
    {
      "author": "ChrisMagnuson",
      "author_association": "NONE",
      "body": "@dragonwolf83 I am having trouble getting an example working the way your describing things should:\r\n\r\n```\r\nPS > function Test-PSBoundGetEnumerator { param ($test1,$test2) $PSBoundParameters.GetEnumerator() | where key -in Test1,Test2 }\r\nPS > $Variable = Test-PSBoundGetEnumerator -test1 value1 -test2 value2                                           \r\nPS > $Variable                                                                                                   \r\n\r\nKey   Value\r\n---   -----\r\ntest1 value1\r\ntest2 value2\r\n\r\nPS > $Variable | gm                                                                                              \r\n\r\n\r\n   TypeName: System.Collections.Generic.KeyValuePair`2[[System.String, System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, \r\nPublicKeyToken=7cec85d7bea7798e],[System.Object, System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, \r\nPublicKeyToken=7cec85d7bea7798e]]\r\n\r\nName        MemberType Definition\r\n----        ---------- ----------\r\nDeconstruct Method     void Deconstruct([ref] string key, [ref] System.Object value)\r\nEquals      Method     bool Equals(System.Object obj)\r\nGetHashCode Method     int GetHashCode()\r\nGetType     Method     type GetType()\r\nToString    Method     string ToString()\r\nKey         Property   string Key {get;}\r\nValue       Property   System.Object Value {get;}\r\n\r\n   TypeName: System.Object[]\r\n\r\nName           MemberType            Definition\r\n----           ----------            ----------\r\nAdd            Method                int IList.Add(System.Object value)\r\nAddress        Method                System.Object&, System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7c...\r\nClear          Method                void IList.Clear()\r\nClone          Method                System.Object Clone(), System.Object ICloneable.Clone()\r\nCompareTo      Method                int IStructuralComparable.CompareTo(System.Object other, System.Collections.IComparer compa...\r\nContains       Method                bool IList.Contains(System.Object value)\r\nCopyTo         Method                void CopyTo(array array, int index), void CopyTo(array array, long index), void ICollection...\r\nEquals         Method                bool Equals(System.Object obj), bool IStructuralEquatable.Equals(System.Object other, Syste...\r\nGet            Method                System.Object Get(int )\r\nGetEnumerator  Method                System.Collections.IEnumerator GetEnumerator(), System.Collections.IEnumerator IEnumerable....\r\nGetHashCode    Method                int GetHashCode(), int IStructuralEquatable.GetHashCode(System.Collections.IEqualityCompare...\r\nGetLength      Method                int GetLength(int dimension)\r\nGetLongLength  Method                long GetLongLength(int dimension)\r\nGetLowerBound  Method                int GetLowerBound(int dimension)\r\nGetType        Method                type GetType()\r\nGetUpperBound  Method                int GetUpperBound(int dimension)\r\nGetValue       Method                System.Object GetValue(Params int[] indices), System.Object GetValue(int index), System.Obj...\r\nIndexOf        Method                int IList.IndexOf(System.Object value)\r\nInitialize     Method                void Initialize()\r\nInsert         Method                void IList.Insert(int index, System.Object value)\r\nRemove         Method                void IList.Remove(System.Object value)\r\nRemoveAt       Method                void IList.RemoveAt(int index)\r\nSet            Method                void Set(int , System.Object )\r\nSetValue       Method                void SetValue(System.Object value, int index), void SetValue(System.Object value, int index...\r\nToString       Method                string ToString()\r\nItem           ParameterizedProperty System.Object IList.Item(int index) {get;set;}\r\nCount          Property              int Count {get;}\r\nIsFixedSize    Property              bool IsFixedSize {get;}\r\nIsReadOnly     Property              bool IsReadOnly {get;}\r\nIsSynchronized Property              bool IsSynchronized {get;}\r\nLength         Property              int Length {get;}\r\nLongLength     Property              long LongLength {get;}\r\nRank           Property              int Rank {get;}\r\nSyncRoot       Property              System.Object SyncRoot {get;}\r\n\r\nPS > Test-PSBoundGetEnumerator @Variable                                                                         \r\n\r\nKey   Value\r\n---   -----\r\ntest1 [test1, value1]\r\ntest2 [test2, value2]\r\n\r\nPS > $VariableHash = @{test1 = \"value1\"; test2 = \"value2\"}                                                                                                                                      \r\nPS > Test-PSBoundGetEnumerator @VariableHash                                                                     \r\n\r\nKey   Value\r\n---   -----\r\ntest2 value2\r\ntest1 value1\r\n\r\n```\r\nIt doesn't appear that splatting a `System.Object[]` of `System.Collections.Generic.KeyValuePair``2[[System.String, System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, \r\nPublicKeyToken=7cec85d7bea7798e],[System.Object, System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, \r\nPublicKeyToken=7cec85d7bea7798e]]` behaves the same way as splatting a `System.Collections.Hashtable`.",
      "created_at": "2018-08-13T09:34:54Z",
      "updated_at": "2018-08-13T09:34:54Z"
    },
    {
      "author": "dragonwolf83",
      "author_association": "NONE",
      "body": "Your right, it is including the key with the value as the value. In theory, the `ToDictionary` LINQ Extension Method should convert it back to a workable state but don't know if that is working yet in 6.0+.\r\n\r\nMaybe Splatting just needs to be updated to handle passing the `KeyValuePair` type directly and handle that weirdness for us.",
      "created_at": "2018-08-13T15:11:26Z",
      "updated_at": "2018-08-13T15:11:26Z"
    },
    {
      "author": "ChrisMagnuson",
      "author_association": "NONE",
      "body": "@dragonwolf83 Just for information's sake, the above test was with PowerShell version 6.1.0-preview.2.\r\n\r\nI think your intuition about how this should work not aligning with how it actually works is further evidence that this does not align with the principle of least astonishment and that things would be better/less surprising if we had an object to work with and could splat objects instead of dealing with the idiosyncrasies of dictionaries/hashtables for this particular purpose.",
      "created_at": "2018-08-13T17:00:52Z",
      "updated_at": "2018-08-13T17:00:52Z"
    }
  ],
  "created_at": "2018-05-17T14:16:24Z",
  "labels": [
    "WG-Language",
    "Issue-Discussion"
  ],
  "number": 6889,
  "state": "open",
  "title": "Add $PSBoundParametersObject and support for Splatting PSCustomObjects",
  "updated_at": "2018-08-13T17:00:52Z"
}