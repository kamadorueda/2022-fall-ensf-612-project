{
  "_url": "https://github.com/PowerShell/PowerShell/issues/14510",
  "author": "ljb",
  "body": "Using splatting when calling `Invoke-Command` has a different behavior than calling it without splatting. See my examples below.\r\n\r\nThe issue only seems to occur when `$values` is assigned `[System.Management.Automation.Internal.AutomationNull]::Value` (which is the case when there are no elements in the pipeline). If I hard code `$values` to be `$null` the code works as expected. Maybe `[System.Management.Automation.Internal.AutomationNull]::Value` is not converted to a normal `$null` when using splatting. \ud83e\udd14 \r\n\r\nIn the first case `$Values` ends up being a `[pscustomobject]` that `foreach` is able to iterate over, something that is unexpected.\r\n\r\n## Steps to reproduce\r\nRun the following, but change `some-machine` to a proper remote machine.\r\n\r\n```\r\nfunction GetValues {\r\n\r\n}\r\n\r\n$values = GetValues\r\n\r\n$invokeCommandParams = @{\r\n    ArgumentList = $values, \"dummy\"\r\n}\r\n\r\nInvoke-Command -ComputerName \"some-machine\" @invokeCommandParams {\r\n    param($Values, $Dummy)\r\n    Write-Host \"Inside the first script block\"\r\n    Write-Host \"Is null: $($null -eq $Values)\"\r\n    Write-Host \"Is empty string: $('' -eq $Values)\"\r\n    Write-Host \"Type: $($Values.GetType())\"\r\n    foreach ($value in $Values) {\r\n        Write-Host \"Inside the loop. Value is $value\"\r\n    }\r\n}\r\n\r\nInvoke-Command -ComputerName \"some-machine\" -ArgumentList $values, \"dummy\" {\r\n    param($Values, $Dummy)\r\n    Write-Host \"Inside the second script block\"\r\n    Write-Host \"Is null: $($null -eq $Values)\"\r\n    Write-Host \"Is empty string: $('' -eq $Values)\"\r\n    foreach ($value in $Values) {\r\n        Write-Host \"Inside the loop. Value is $value\"\r\n    }\r\n}\r\n```\r\n\r\n## Expected behavior\r\nI expected both calls to `Invoke-Command` to behave in the same way, which would have yielded the following output:\r\n\r\n```none\r\nInside the first script block\r\nIs null: True\r\nIs empty string: False\r\nType:\r\n\r\nInside the second script block\r\nIs null: True\r\nIs empty string: False\r\n```\r\n\r\n## Actual behavior\r\n```none\r\nInside the first script block\r\nIs null: False\r\nIs empty string: True\r\nType: System.Management.Automation.PSCustomObject\r\nInside the loop. Value is\r\n\r\nInside the second script block\r\nIs null: True\r\nIs empty string: False\r\n```\r\n\r\n## Environment data\r\n```none\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.2.0-preview.2\r\nPSEdition                      Core\r\nGitCommitId                    7.2.0-preview.2\r\nOS                             Microsoft Windows 10.0.19042\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n\r\nIt get the same behavior on PowerShell 5 aswell.\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "ljb",
      "author_association": "NONE",
      "body": "I tried to simplify my example by removing the `-ComputerName` parameter. But without that parameter the example works as expected. So the problem might be related to the serialization that occurs during remoting.",
      "created_at": "2020-12-30T07:55:44Z",
      "updated_at": "2020-12-30T07:58:01Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Good point, @ljb - you can also demonstrate the problem with a background job, where serialization is involved too:\r\n\r\n```powershell\r\n$automationNull = [System.Management.Automation.Internal.AutomationNull]::Value\r\n\r\n# Note: At least one additional argument is required to trigger the symptom.\r\n$htArgs = @{ ArgumentList = $automationNull, 'foo' }\r\n\r\n# Note: [System.Management.Automation.Internal.AutomationNull]::Value is treated\r\n#       like $null in expression contexts.\r\n$sb = { $null -eq $args[0] ? '(null)' : $args[0].GetType().Name }\r\n\r\n# OK - direct argument passing:\r\nStart-Job $sb -ArgumentList $automationNull, 'foo' |\r\n  Receive-Job -Wait -AutoRemoveJob | Should -Be '(null)'\r\n\r\n# !! BROKEN - via splatting:\r\nStart-Job $sb @htArgs |\r\n  Receive-Job -Wait -AutoRemoveJob | Should -Be '(null)'\r\n```\r\n\r\nIn effect, `[System.Management.Automation.Internal.AutomationNull]::Value` turns into a _regular_ `[PSCustomObject]` instance (without properties) on deserialization.\r\n\r\n",
      "created_at": "2020-12-30T14:46:10Z",
      "updated_at": "2020-12-30T17:55:52Z"
    },
    {
      "author": "ljb",
      "author_association": "NONE",
      "body": "Another similar case is when the using scope is used together with `Invoke-Command`:\r\n```Powershell\r\n$values = [System.Management.Automation.Internal.AutomationNull]::Value\r\nInvoke-Command -ComputerName \"some-machine\" {\r\n    $localValues = $using:values\r\n    Write-Host \"Is empty string: $('' -eq $localValues)\"\r\n    Write-Host \"Type: $($localValues.GetType())\"\r\n}\r\n```\r\nThis will result in the following:\r\n```\r\nIs empty string: True\r\nType: System.Management.Automation.PSCustomObject\r\n```\r\n\r\nThis has nothing to do with splatting. But it might be caused by the same underlying circumstances as the splatting examples.",
      "created_at": "2020-12-30T17:36:27Z",
      "updated_at": "2020-12-30T17:36:27Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Yes, the common denominator is the cross-process (whether locally or across machine boundaries) serialization infrastructure, which also applies to the `$using:` \"scope\"; again, the problem can also be demonstrated with a background job:\r\n\r\n```powershell\r\n$automationNull = [System.Management.Automation.Internal.AutomationNull]::Value\r\nStart-Job { ($using:automationNull).GetType().Name } | Receive-Job -Wait -AutoRemoveJob # -> 'PSCustomObject`\r\n```\r\n\r\nSplatting only _surfaces_ the symptom, because it seems to bypass code used in _direct_ argument binding that (surprisingly) converts `[System.Management.Automation.Internal.AutomationNull]::Value` to `$null`. Similarly, no such conversion happens with `$using:`.\r\n\r\nWithout having done thorough analysis, here's my guess as to why this happens:\r\n\r\n* _In-process_ it is _reference equality_ based on the _singleton_ `[System.Management.Automation.Internal.AutomationNull]::Value` that is used to detect such values (and  treats them as a collection with no properties and no elements).\r\n\r\n* The serialization infrastructure is apparently not aware of this special value, and serializes it as a regular `[psobject]` instance (with a static, property-less  `[System.Management.Automation.PSCustomObject]` instance as its base object). The _rehydrated_ regular `[pscustomobject]` instance is obviously _not_ the same as `[System.Management.Automation.Internal.AutomationNull]::Value` in the target process, and therefore not recognized as such.\r\n\r\nIn short: Given that the in-process `[System.Management.Automation.PSCustomObject]`  has no distinguishing characteristics other than being a _singleton_,  fixing this would require extending the serialization infrastructure to be aware of and correctly handle this value.\r\n\r\nHowever: `[System.Management.Automation.Internal.AutomationNull]::Value` _does_ differ in its serialized form from an empty `[psobject]` instance, so _perhaps_ this existing differing representation is enough to unequivocally identify `[System.Management.Automation.Internal.AutomationNull]::Value` on rehydration, which then wouldn't require extending the remoting protocol:\r\n\r\n```powershell\r\n[System.Management.Automation.PSSerializer]::Serialize(@([System.Management.Automation.Internal.AutomationNull]::Value, [psobject]::new()))\r\n```\r\n\r\n<sup>Note that parameter `[System.Management.Automation.Internal.AutomationNull]::Value` or even `@([System.Management.Automation.Internal.AutomationNull]::Value)` alone wouldn't work, because conversion to `$null` / no-element enumeration to an empty array would kick in.</sup>\r\n\r\nThe above yields the following; note how the `[psobject]` instance is simply represented as an empty `<Object>` element, unlike automation null:\r\n\r\n```none\r\n<Objs Version=\"1.1.0.1\" xmlns=\"http://schemas.microsoft.com/powershell/2004/04\">\r\n  <Obj RefId=\"0\">\r\n    <TN RefId=\"0\">\r\n      <T>System.Object[]</T>\r\n      <T>System.Array</T>\r\n      <T>System.Object</T>\r\n    </TN>\r\n    <LST>\r\n      <Obj RefId=\"1\">\r\n        <TN RefId=\"1\">\r\n          <T>System.Management.Automation.PSCustomObject</T>\r\n          <T>System.Object</T>\r\n        </TN>\r\n      </Obj>\r\n      <Obj RefId=\"2\">\r\n        <TNRef RefId=\"1\" />\r\n      </Obj>\r\n    </LST>\r\n  </Obj>\r\n</Objs>\r\n```",
      "created_at": "2020-12-30T18:56:03Z",
      "updated_at": "2020-12-30T21:16:44Z"
    }
  ],
  "created_at": "2020-12-29T20:06:35Z",
  "number": 14510,
  "state": "open",
  "title": "Inconsistent behavior for splatting when using Invoke-Command",
  "updated_at": "2020-12-30T21:16:44Z"
}