{
  "_url": "https://github.com/PowerShell/PowerShell/issues/11937",
  "author": "rrg92",
  "body": "# Summary of the new feature/enhancement\r\n\r\nI guess the way how powershell handles events, can cause events being processed in a different order than it was generated\r\n\r\nIf possible, include a parameter on Register-Object event to let user choose if order which was generated must be preserved.\r\n\r\n<!-- \r\nA clear and concise description of what the problem is that the new feature would solve.\r\nTry formulating it in user story style (if applicable):\r\n'As a user I want X so that Y.' with X being the being the action and Y being the value of the action.\r\n-->\r\n\r\n# Proposed technical implementation details (optional)\r\n\r\nI guess that fact of events being handled in a thread pool is causing the out of order (`ThreadPool.QueueUserWorkItem(new WaitCallback(...`).\r\nhttps://github.com/PowerShell/PowerShell/blob/d58a82ad19fbfad81e85778c8b08cb1b28f58fce/src/System.Management.Automation/engine/EventManager.cs#L923-L961\r\nFor example, using powershell to get events generated by SqlClient.SqlConnection.InfoMessage event , causes messages and errors generated by SQL Server being returned in incorrect order, when consumed with Get-Event cmdlet.\r\n\r\nTo confirm that, I had implemented a custom event handle using a custom type with Add-Type.\r\nI got the SqlConnection and add my own delegate to InfoMessage event, and inserted it on a Queue collection. On powershell, I could read the queue and all messages was generated in correct order.\r\n\r\n\r\n\r\n<!-- \r\nA clear and concise description of what you want to happen.\r\nConsider providing an example PowerShell experience with expected result.\r\n-->\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@rrg92 Please use more useful issue title.\r\n\r\n> I guess the way how powershell handles events, can cause events being processed in a different order than it was generated\r\n\r\n@daxian-dbw @PaulHigin Can you confirm the guess?",
      "created_at": "2020-02-28T18:23:34Z",
      "updated_at": "2020-02-28T18:23:34Z"
    },
    {
      "author": "rrg92",
      "author_association": "NONE",
      "body": "@iSazonov , sorry. I forgot to change title when opening. It is more intuitive now.",
      "created_at": "2020-02-28T19:47:12Z",
      "updated_at": "2020-02-28T19:47:12Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "I think @rrg92 is right. When using `Register-ObjectEvent`, PowerShell will register a delegate to the object event that calls to `ProcessNewEvent` with `processInCurrentThread` being `false`, so the call will go through the thread pool code path. And `ThreadPool.QueueUserWorkItem` doesn't preserve the order of execution for the delegates passed to it.",
      "created_at": "2020-02-28T19:48:58Z",
      "updated_at": "2020-02-28T19:48:58Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> that calls to ProcessNewEvent with processInCurrentThread being false,\r\n\r\nIf we add an option to use `true` can we fall in a thread dead lock?",
      "created_at": "2020-02-28T20:13:03Z",
      "updated_at": "2020-02-28T20:13:29Z"
    }
  ],
  "created_at": "2020-02-24T04:27:08Z",
  "number": 11937,
  "state": "open",
  "title": "Add option to allow preserve event order on  Register-ObjectEvent",
  "updated_at": "2020-02-28T20:13:29Z"
}