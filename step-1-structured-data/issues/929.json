{
  "_url": "https://github.com/PowerShell/PowerShell/issues/929",
  "author": "andschwa",
  "body": "The PowerShell aliases that conflicted with Linux and OS X were removed in #786, specifically commit 7d9f43966.\n\nHowever, new discussion is happening on how to handle this better than just removing the aliases.\n",
  "closed_at": "2017-04-18T17:16:20Z",
  "comments": [
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "This makes using `rm`, `ls`, etc. sucky, since globbing isn't performed:\n\n```\n> touch blah.tmp\n> ls *.tmp                                                                                                          \nls: *.tmp: No such file or directory\n> Get-ChildItem *.tmp\n\n    Directory: /Users/andrew/src/PowerShell\n\n\nMode                LastWriteTime         Length Name                                                                                 \n----                -------------         ------ ----                                                                                 \n------           5/3/16   8:39 PM              0 blah.tmp\n\n> rm *.tmp\nrm: *.tmp: No such file or directory\n> Remove-Item *.tmp\n> Get-ChildItem *.tmp\n```\n\nBlah.\n",
      "created_at": "2016-05-04T03:41:27Z",
      "updated_at": "2016-05-04T17:07:29Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "Usability sync generally agrees that the interactive experience sucks without the aliases. What we don't agree on is what alternatives should be offered to users who want to use the native binaries by default. Some options that have been floated include:\n- An environment variable to turn off all the aliases that collide with *nix binaries\n- A single character (like `^`) that automatically falls into the native PATH\n- Tell people they have to `bash -c` (many said this is too many characters to be usable)\n- Tell people that they have to provide the full path (this experience technically already works, but it's very poor)\n- Side suggestion: Leverage the \"hinting subsystem\" to tell people that they may have wanted to use the native command if they use parameter sets that match patterns against the native *nix binaries. This can still only work when the command fails (`rm -e`, for instance, would not fail). \n",
      "created_at": "2016-05-05T23:31:55Z",
      "updated_at": "2016-05-05T23:31:55Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "I think this is something we want to figure out sooner rather than later, so I've moved it to v0.5.0. In my opinion, a PowerShell setting to switch modes is the best first step.\n",
      "created_at": "2016-05-18T17:44:49Z",
      "updated_at": "2016-05-18T17:44:49Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "@andschwa and default would be ....?\n",
      "created_at": "2016-05-18T17:48:35Z",
      "updated_at": "2016-05-18T17:48:35Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "@vors my _personal_ opinion: the PowerShell aliases enabled; because you're running PowerShell.\n\nEventually we're going to want a first-time startup \"getting started\" guide for PowerShell anyway, and would state that this is an available setting.\n",
      "created_at": "2016-05-18T17:52:42Z",
      "updated_at": "2016-05-18T17:52:42Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "@BrucePay any updates on this?\n",
      "created_at": "2016-06-08T21:16:56Z",
      "updated_at": "2016-06-08T21:16:56Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "Usability sync today reiterated that the aliases should go back in. (Piping to `sort` is yet another data point in having a totally broken PS experience.)\n\nLeaving Bruce as an assignee to determine the best path forward with the above mitigations. @andschwa: we probably need someone else assigned to do the work to put the aliases back. \n",
      "created_at": "2016-06-13T18:11:07Z",
      "updated_at": "2016-06-13T18:11:07Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "I just had a conversation with @jpsnover and he is very clear that we are **not** putting aliases back. We should create inbox `aliases.ps1` file and promote dot-sourcing it.\n",
      "created_at": "2016-07-14T00:31:40Z",
      "updated_at": "2016-07-14T00:31:40Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "It's probably worth pointing out that `ls` in bash typically isn't simply `ls`, it's an alias with some default arguments, with maybe the most notable to output using color.\n\nPowerShell aliases don't work at all like aliases in Linux, so we'd need to either define `ls` as a function, or enhance our aliases to work more like bash aliases.\n\nIt might also be worth spending some time analyzing modules in the gallery to see how many wouldn't work as is with the aliases removed - `sort` is especially concerning.\n",
      "created_at": "2016-07-14T05:08:12Z",
      "updated_at": "2016-07-14T05:08:12Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "The aliases are not in today, and we should make sure for Aug17 we have a healthy discussion about the pros/cons of the alias situations for people to join into. \n",
      "created_at": "2016-07-21T21:34:01Z",
      "updated_at": "2016-07-21T21:34:01Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "Looks like we have a story, closing the issue.\n",
      "created_at": "2016-07-27T17:23:39Z",
      "updated_at": "2016-07-27T17:23:39Z"
    },
    {
      "author": "kilasuit",
      "author_association": "COLLABORATOR",
      "body": "My 2p on this - a new PowerShell settings Variable similar to $PSModuleAutoLoadingPreference that was introduced in PSv3 would allow this to be controlled by the end user in their profiles (could also put together a simple example that shows some commands running with and without the PS Aliases as a good \n\nSuggestive name $PSUsePowerShellAliases and if it is not explicitly set to true (within profile or interactively) then the standard *nix aliases would be used in place.\nI believe that this would likely also give a better UX for those that may now decide to test the water with PowerShell that wouldn't have done before as its not taking away what they know but allows those of us that know the PS way the ability to do so as well.\n",
      "created_at": "2016-08-14T21:08:19Z",
      "updated_at": "2016-08-14T21:08:19Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "> not taking away what they know \n\nAbsolutely. If there has to be a compromise then it should be in favor of Linux Bash users i.e. potential new PowerShell users.  The existing PowerShell faithful can recreate their *nix aliases easily enough or better yet, wean themselves off those aliases.  \n\nIn fact, now that we have PowerShell on Linux, I'd like to see the built-in *nix aliases removed from all OS versions of PowerShell Core - if they aren't already.  That would leave built-in aliases that match the built-in PowerShell commands and don't attempt to \"fool\" you.  \n",
      "created_at": "2016-08-16T17:29:00Z",
      "updated_at": "2016-08-18T18:38:03Z"
    },
    {
      "author": "toenuff",
      "author_association": "NONE",
      "body": "I'm a fan for removing the common aliases from ps on Linux by default - I am not a fan of \"fixing\" this on Windows as Keith suggests.  My argument for this is that if you win over a Linux user to PowerShell and then they decide to also try it on Windows, they will not have the common aliases.  \n",
      "created_at": "2016-08-17T03:10:10Z",
      "updated_at": "2016-08-17T03:10:10Z"
    },
    {
      "author": "1RedOne",
      "author_association": "CONTRIBUTOR",
      "body": "Could this be added to PSReadline, the ability to enable Linux Aliases or not?  For me, it's simple to fix my code which uses short names for functions.  Still, I'm going to always type `LS` first and expect it to operate like the PowerShell LS alias for `Get-ChildItem`.\n",
      "created_at": "2016-08-18T16:34:15Z",
      "updated_at": "2016-08-18T16:34:15Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "Please feel free to use this issue to voice your opinion on what PowerShell's behavior should be.\n",
      "created_at": "2016-08-18T17:43:15Z",
      "updated_at": "2016-08-18T17:43:15Z"
    },
    {
      "author": "eFiggy",
      "author_association": "NONE",
      "body": "I think that what @kilasuit, @rkeithhill, and @1RedOne touched on seems like the best solution -- have it disabled by default on Linux and macOS but at the same time, make it easy for us to enable it in the console or in our scripts. \n\nExisting scripts can be updated to check for this variable and disable or enable the option right then and there, and it beats pouring through a bunch of code to look for short names that won't behave as anticipated.\n\nOff-topic -- beyond excited about PowerShell being available on other platforms! \ud83d\ude04 \n",
      "created_at": "2016-08-18T17:57:12Z",
      "updated_at": "2016-08-18T17:57:12Z"
    },
    {
      "author": "kilasuit",
      "author_association": "COLLABORATOR",
      "body": "regarding PSReadLine then @lzybkr should be able to suggest if that is a possibility at all though i'd prefer it as a PS Variable than a requirement for PSReadLine as there are those like @juneb that don't use PSReadline at all\n",
      "created_at": "2016-08-18T19:24:56Z",
      "updated_at": "2016-08-18T19:24:56Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "I could certainly publish a sample for PSReadline to replace specific aliases with the PowerShell cmdlet, it would be based on this sample: https://github.com/lzybkr/PSReadLine/blob/master/PSReadLine/SamplePSReadlineProfile.ps1#L354\n\nThat said, I don't think it's a real solution..\n\nThe biggest issue in my mind is the conflict between script portability and familiarity.  We've provided guidance that scripts shouldn't use aliases, but it's still common practice.  Some aliases might be more problematic than others, e.g. `sort` might be used more than `ps` or `ls` in scripts.\n\nWe've certainly discussed some options such as providing a module you just import to get those aliases back.  But we haven't settled on anything yet and are hoping for more feedback.\n",
      "created_at": "2016-08-18T19:32:27Z",
      "updated_at": "2016-08-18T19:32:27Z"
    },
    {
      "author": "ForNeVeR",
      "author_association": "NONE",
      "body": "Replacing PowerShell commands with native executables without globbing support definitely won't help with convincing bash guys to use PowerShell.\n\nSo, guys, maybe it'll be better to simply add globbing support to native executables? That will solve all the problems and make PowerShell more usable to everyone, right? Link #954.\n",
      "created_at": "2016-08-19T03:13:27Z",
      "updated_at": "2016-08-19T03:13:27Z"
    },
    {
      "author": "Gaelan",
      "author_association": "NONE",
      "body": "As a *nix user who has barely ever touched windows, I'd like to put in a strong vote for leaving the aliases in. Many years of muscle memory have taught me to use `ls`, `rm`, etc. I don't want to have to re-learn my muscle memory (then re-re-learn it whenever I end up in bash) to get the native Powershell experience.\n\nCorrect me if I'm wrong here, but is this any different for `dir` on windows? In PS on Windows, `dir` isn't `dir.exe`. It's `Get-ChildItem`. On *nix, why should `ls` be `/bin/ls` instead of `Get-ChildItem`?\n",
      "created_at": "2016-08-19T06:58:42Z",
      "updated_at": "2016-08-19T06:58:42Z"
    },
    {
      "author": "ForNeVeR",
      "author_association": "NONE",
      "body": "@Gaelan I got your point, but please consider that there is no `dir.exe` file in Windows. `dir` is an internal command of `cmd` command processor, similar to `bash` builtin. Maybe that's the (one) reason because PowerShell wasn't designed to call that external `dir.exe` command directly.\n",
      "created_at": "2016-08-19T10:57:36Z",
      "updated_at": "2016-08-19T10:57:36Z"
    },
    {
      "author": "ygra",
      "author_association": "NONE",
      "body": "@Gaelan, @ForNeVeR: While cmd-built-ins won't ever clash because they don't exist as programs, there are PowerShell aliases that conflict with native executables, even on Windows.\n\nIn general I don't think there _is_ a safe way of keeping aliases and _not_ breaking things because theoretically every single alias (except maybe those that cannot exist in the file system, like `?`) could shadow a native executable which can then no longer be called (at least not by its basename).\n\n```\nPS> gal|?{gcm \"$_.exe\" -ea 0}\n\nCommandType     Name\n-----------     ----\nAlias           fc -> Format-Custom\nAlias           sc -> Set-Content\nAlias           sort -> Sort-Object\nAlias           where -> Where-Object\nAlias           write -> Write-Output\n```\n\nSo the only _safe_ route would be to have no aliases at all, which kinda defeats the purpose. And no doubt, the default aliases are most of all convenient. I don't have a good answer here, actually.\n",
      "created_at": "2016-08-19T14:09:51Z",
      "updated_at": "2016-08-19T14:12:43Z"
    },
    {
      "author": "Brekkjern",
      "author_association": "NONE",
      "body": "I would personally prefer the aliases to be left in. They are generally there to make navigation and general shell usage faster and more comfortable. Removing them will degrade the experience of using PowerShell.\n\nI support the idea of possibly adding a way to indicate you are calling the builtin Linux binary instead. Maybe even as a profile preference?\n",
      "created_at": "2016-08-19T14:23:43Z",
      "updated_at": "2016-08-19T14:23:43Z"
    },
    {
      "author": "kilasuit",
      "author_association": "COLLABORATOR",
      "body": "If you look through the history in here I have suggested what I think to be the best solution from a UX perspective for aliases that map to an equivalent non-Windows commands\n",
      "created_at": "2016-08-19T14:27:15Z",
      "updated_at": "2016-08-19T14:27:15Z"
    },
    {
      "author": "DrPizza",
      "author_association": "NONE",
      "body": "This is a long-standing PowerShell issue. I complain that it has no command comparable to cmd's `dir` or even to `ls`. The response, every single time, is \"but there's an alias!\".\n\nAliases are not and have never been a solution to this problem. The `dir` and `ls` aliases do not provide the functionality that `dir` and `ls` provide. The same is true for the `wget` and `curl` aliases.\n\nThe entire approach to the aliases needs to be rethought, and that will mean breaking changes.\n",
      "created_at": "2016-08-19T14:30:04Z",
      "updated_at": "2016-08-19T14:30:04Z"
    },
    {
      "author": "sleepypikachu",
      "author_association": "NONE",
      "body": "Why can't system defined aliases just be second class citizens to binaries in PATH?\n",
      "created_at": "2016-08-19T14:31:02Z",
      "updated_at": "2016-08-19T14:31:12Z"
    },
    {
      "author": "okket",
      "author_association": "NONE",
      "body": "~~I'd say remove all *nix aliases on Linux, OS X builds until you figured out what to do.~~\n\nEdit: Thanks for clarifying that this has already been done, sorry for the interruption.\n",
      "created_at": "2016-08-19T14:33:03Z",
      "updated_at": "2016-08-19T14:47:08Z"
    },
    {
      "author": "ForNeVeR",
      "author_association": "NONE",
      "body": "@okket that have been done already. We're discussing if something needs to be changed.\n",
      "created_at": "2016-08-19T14:41:29Z",
      "updated_at": "2016-08-19T14:41:29Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "Seems to me that we should just put all the aliases in files people can source in their profiles, and then, provide a default system-specific profile ...\n\n```\nbash-aliases.ps1\ndos-aliases.ps1\ninitial-aliases.ps1\n```\n\nIf nothing else, that serves to remind people that not everyone has the same short names.\n\nLet's not forget (@sleepypikachu) that PowerShell's aliases don't _do_ anything except rename the command **and** override command resolution order. Bash's `alias` functionality requires _functions_ in PowerShell.\n",
      "created_at": "2016-08-19T16:25:13Z",
      "updated_at": "2016-08-19T16:25:13Z"
    },
    {
      "author": "dragonwolf83",
      "author_association": "NONE",
      "body": "@Gaelan your muscle-memory gets you to use the alias, but would you be frustrated with the parameters and behavior not working the same as the real command?\n\nThat is the real issue here and @DrPizza is spot on. A great example is, _dir /s_. That command fails in PowerShell so you have to change it to dir -recurse.\n\nSo there are really three related issues here:\n1. Not all parameters are aliased\n2. Not all native parameters or behavior is mapped in the PowerShell CmdLet.\n3. Need a way to run native command if alias exists\n\nI don't think #1 is too bad of an issue and would make things worse if they were aliased. Dir -recurse is a more readable parameter than dir /s anyway. Plus with the cross-plat, it makes scripts inconsistent when trying to move from Windows to Linux and the reverse. \n\n#2 and #3 are most important. I never used curl, but I know I've run into limitations with Invoke-WebRequest that I would expect curl to be able to do. (Don't remember off top of head).\n\nShort-term, I think you need both a config option as well as a way to call the native command if the alias is enabled. \n\nDefault, leave it enabled. This is PowerShell.... on Linux. It should behave as PowerShell so they can learn what CmdLets to use. My co-worker with a Linux and Perl background found it much easier to figure out the cmds he needed to get a script working. I think it was grep, ls, and man that was key for him. Using man should help them figure out how to use the cmd properly.\n\nLong-term, add coverage to the native cmdlets to have all the parameters and capabilities of native commands. This enhances PowerShell for Windows and Linux by giving us more powerful options. Some of the behaviors will likely need to be converted to multiple CmdLets and use Objects and Pipelines, but that is a great thing! If it didn't do that, then what would be the point of PowerShell?\n",
      "created_at": "2016-08-19T21:36:32Z",
      "updated_at": "2016-08-19T21:36:32Z"
    },
    {
      "author": "KexyBiscuit",
      "author_association": "NONE",
      "body": "My opinion is to keep as is. No alias on PowerShell (except select and etc., they're required), alias on Windows PowerShell.\n\nProviding an option is better, but to provide all aliases as options is... well, not impossible.\n",
      "created_at": "2016-08-20T05:28:08Z",
      "updated_at": "2016-08-20T05:28:08Z"
    },
    {
      "author": "borgdylan",
      "author_association": "NONE",
      "body": "IMHO having ls alias to dir makes sense, since I could easily use Where-Object to filter files. I have been a Linux user for years and typing dir is not as natural as using ls.\n",
      "created_at": "2016-08-20T15:33:22Z",
      "updated_at": "2016-08-20T15:33:22Z"
    },
    {
      "author": "bgshacklett",
      "author_association": "NONE",
      "body": "It seems to me that consistency is important. I'm not against removing the aliases from other platforms, but having an interface that behaves differently depending upon the OS bothers me. One of the major points of having PS running on *nix is that it's one interface to manage everything. If the aliases are going to be removed from PowerShell on the newly supported platforms, I think some consideration should be made to whether they should be removed on Windows as well.\n",
      "created_at": "2016-08-20T17:55:42Z",
      "updated_at": "2016-08-20T17:55:42Z"
    },
    {
      "author": "be5invis",
      "author_association": "NONE",
      "body": "No, I strongly support that PS provide aliases by default, but the real thing beneath should have the exactly same functionality (and maybe parameter compatibility) with the original native binaries, except for typing support.\n**PowerShell without types is useless.**\n",
      "created_at": "2016-08-21T16:31:50Z",
      "updated_at": "2016-08-21T16:31:50Z"
    },
    {
      "author": "willhurley004",
      "author_association": "NONE",
      "body": "Using the underlying system binaries and adopting the unix tools philosophy will promote adoption.  As a person who does devops at unix shops, I was pleasantly surprised to find that the normal unix binaries were somewhat working in this implementation.  Regarding the \\* character issue, I think most people in the *nix side would be comfortable with using an escape character in front of the \\* when indicating *nix shell glob as opposed to whatever its currently behavior is in powershell.  Probably would be an acceptable solution for | as a pipe producing an object instead of a stream of octets passing between files goes against published standards and will hinder adoption. http://pubs.opengroup.org/onlinepubs/009695399/functions/pipe.html\n",
      "created_at": "2016-08-22T04:18:58Z",
      "updated_at": "2016-08-22T04:18:58Z"
    },
    {
      "author": "ForNeVeR",
      "author_association": "NONE",
      "body": "@be5invis please note: **nobody is going to remove types from PowerShell**; either `gci` and `Get-ChildItem` stays the same in both Windows PowerShell and Linux PowerShell. Here we're only talking about whether builtin alias like `ls -> Get-ChildItem` should exist on Linux or not. Your **scripts** shouldn't call `ls` or `gci` anyways if you mean to call `Get-ChildItem` (because using aliases in scripts is not recommended and never were recommended). `ls` and `gci` are only convenience aliases for command-line usage, and it _could_ confuse the Linux user if `ls` is suddenly aliased to `Get-ChildItem` and not his favorite native command; it will confuse him even more if he haven't a concise way to call this command directly.\n",
      "created_at": "2016-08-22T05:21:35Z",
      "updated_at": "2016-08-22T05:21:35Z"
    },
    {
      "author": "chantisnake",
      "author_association": "NONE",
      "body": "I am for uses command to enable alias on powershell.\nKeep all alias and slowly deprecate the them on Windows powershell.\n\nI think using command like \n\n```\nEnable-Alias Unix\nEnable-Alias dos\n```\n\nTo enable alias has following advantages\n1. It solves the problem for people who wants to use native curl\n2. It discourages people to use alias in scripts (which distructs the readability of the script.)\n3. It is also super easy for people who love those alias to enable them\n4. and it barely compromise any performance.\n",
      "created_at": "2016-08-22T06:09:52Z",
      "updated_at": "2016-08-23T02:58:30Z"
    },
    {
      "author": "be5invis",
      "author_association": "NONE",
      "body": "@ForNeVeR I use `ls` as `gci` all the day because it is one letter shorter...\nHowever introducing this change (remove unix-y and dos-y aliases) is definitely a breaking change (it is not like `curl`). A \u201cperfect\u201d solution may be implementing these commands to a typed enhancement of existing tools.\nFor scripts, maybe... a `using` statement?\n",
      "created_at": "2016-08-22T09:47:30Z",
      "updated_at": "2016-08-22T09:48:33Z"
    },
    {
      "author": "chantisnake",
      "author_association": "NONE",
      "body": "@ForNeVeR I think you have misunderstood @be5invis . He is a strong supporter of powershell. I think what he means by \"powershell without type is useless\" is that people should not use native curl in powershell.\n\n---\n\n@be5invis Also I think your idea of compatibility of native curl is far reaching. The powershell grammar is not compatible with standard unix grammar, for example you can do `rm -rf` in unix but in powershell you have to do `rm -r -fo`.\nTherefore you will never reach parameter compatibility no matter what.\n",
      "created_at": "2016-08-23T02:25:17Z",
      "updated_at": "2016-08-23T02:25:17Z"
    },
    {
      "author": "be5invis",
      "author_association": "NONE",
      "body": "@chantisnake So why not add a parameter called \u201crf\u201d, which is equalivent to `-recurse -force`?\n",
      "created_at": "2016-08-24T08:54:43Z",
      "updated_at": "2016-08-24T08:54:43Z"
    },
    {
      "author": "ygra",
      "author_association": "NONE",
      "body": "@be5invis This goes against how parameters work in PowerShell. They are orthogonal, and if not, there are different parameter sets. They also only have long names and instead of short names they can individually be abbreviated as long as they remain unambiguous. In your case you'd also need to add an alias to that parameter, `fr`. Also suddenly `-Recurse` would no longer be able to be shortened to `-r` but instead would have to be `-re` to not clash with your proposed `-rf` parameter.\n\nYou could ask the same question from the other side: Why not specify both parameters separately? You're willing to go against PowerShell code principles and conventions in quite a big way only to keep pretending you're still working with the same Unix tools, even if you're not. However, the GNU parameter conventions with their short and long names are hardly universal and lots of well-established tools go against them, e.g. `tar`, or `find`. Yet you're not up in arms on their bug trackers to change them. While a core part of Unix has always been that there are a billion different utility programs that each work in slightly different ways, suddenly having yet another one of them (admittedly doing a bit more and trying to encompass lots of other utilities in itself) is so disconcerting and problematic that it has to be changed? I don't think so.\n\nRemember: The shell on your machine is yours. Just as people alias `rm` to `rm -i` for their own comfort, there is nothing preventing you from removing the `rm` alias and have a function wrapping `Remove-Item` called `rm` with an `-rf` parameter.\n\nBut trying to change PowerShell in its entirety to completely replicate every single Unix tool is fairly misguided.\n",
      "created_at": "2016-08-24T14:11:20Z",
      "updated_at": "2016-08-24T14:11:20Z"
    },
    {
      "author": "Liturgist",
      "author_association": "NONE",
      "body": "The functionality and output of `ls` has been well defined for many years. The `ls` command outputs an octet stream in a well known format. The `ls` command does not output DirectoryInfo and FileInfo objects. Having `ls` output something different is at a minimum confusing and possibly a bit deceptive.\n\nWhen the user is ready to have the benefits of objects in the pipeline, the user will learn about Get-ChildItem and gci. If the user does not want to have the benefits of, or deal with, objects in the pipeline, the user might be better off using using bash, ksh, csh, sh, etc.\n\nThe same thing can be said of the `DIR` command on Windows.\n\nLet *nix be *nix and make Powershell the best it can be.\n",
      "created_at": "2016-09-03T22:48:34Z",
      "updated_at": "2016-09-03T22:48:34Z"
    },
    {
      "author": "Gaelan",
      "author_association": "NONE",
      "body": "@Liturgist \n\n> When the user is ready to have the benefits of objects in the pipeline, the user will learn about Get-ChildItem and gci. If the user does not want to have the benefits of, or deal with, objects in the pipeline, the user might be better off using using bash, ksh, csh, sh, etc.\n\nThis contradicts your point. If people are using Powershell, then they probably want objects in the pipeline. We shouldn't make then relearn basic commands to take advantage of this.\n",
      "created_at": "2016-09-04T18:10:20Z",
      "updated_at": "2016-09-04T18:10:20Z"
    },
    {
      "author": "be5invis",
      "author_association": "NONE",
      "body": "Agree with @Gaelan.\nIf someone does not want objects, they can simply switch to bash or zsh.\nThey want the benefits of objects, and aliasing things like `ls` to a compatible but typed version will give them exactly what they want.\n",
      "created_at": "2016-09-04T18:32:37Z",
      "updated_at": "2016-09-04T18:32:37Z"
    },
    {
      "author": "Liturgist",
      "author_association": "NONE",
      "body": "@Gaelan and @be5invis, I understand the desire to limit the amount of change a user must do to use Powershell. My fingers seem to type `ls` before my brain even sends a signal to them.\n\nThe problem is that those existing basic commands to not produce objects. The actual change to be made is not from `ls` to `gci`. The bigger change is from the thinking done to process lines of text to thinking about the properties of and what methods can be applied to an object.\n\nIt is every user's right to make whatever aliases they want. I would agree that it could be made easy for the user to do this by adding a method and property to $Host (System.Management.Automation.Internal.Host.InternalHost) to enable or disable native command replacement. I have seen others, but is there a GUI profile configuration tool included with Powershell?\n",
      "created_at": "2016-09-05T17:38:39Z",
      "updated_at": "2016-09-05T17:39:15Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "> If someone does not want objects, they can simply switch to bash or zsh.\n\nWhy can't PowerShell provide an \"easy on-ramp\" for folks that have used bash for years and then decide to dip their toes in the PowerShell waters?  Let them start with what they know and start to phase in PowerShell features (like object emitting commands and objects in the pipeline) as they grow more comfortable using PowerShell.\n\nI can't tell you how many times I've had to use the line \"_PowerShell is a **shell**.  It will executable your favorite native utilities just fine_\" to get people past the notion that they could only use PowerShell with those funny sounding commands and to get them to actually give PowerShell a try.  PowerShell needs to respect and work with popular, native utilities as best as it can - period.  That is after all, one of the primary jobs of a \"shell\".\n",
      "created_at": "2016-09-05T18:23:10Z",
      "updated_at": "2016-09-05T18:23:10Z"
    },
    {
      "author": "be5invis",
      "author_association": "NONE",
      "body": "@rkeithhill So let me clearify: For users want to use Powershell, they want types, right? However your native tools, like `/bin/ls`, cannot communicate with types. Therefore, switching to a typed shell, but without typed utils, the change is meaningless.\n\nTherefore, typical Unix users may want to type the identical command, but get the typed result directly. So there is two options:\n1. Purpose a typed IPC protocol and tell Linus to update their tools \u2014 No, they wont\u2019t, because it is purposed by their **ENEMY**, the **EVIL LORD**, the **destroyer of the free world**! They are going to \u201cembrace extend and extinguish\u201d us! or...\n2. Alias `ls` to a builtin with compatible parameters.\n",
      "created_at": "2016-09-05T18:36:31Z",
      "updated_at": "2016-09-05T18:36:31Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "> For users want to use Powershell, they want types, right?\n\nEventually, they probably will.  That said, I work with a number of devs I've started on PowerShell by **merely** selling them on using it with Git and Posh-Git (something CMD can't provide).  They rarely pipeline anything at this point but I expect them to get there.  That point is, the git.exe utility behaves under PowerShell just as it behaves under CMD.  Easy transition.  \n\nTo me, ls (like ps, grep, sed, awk, gcc, curl, etc) is just another native utility that any \"shell\" should be able to run.  Now, if someone is ready for and wants the object emitting command for listing container contents, they can use `Get-ChildItem` or its alias `gci`.  If they are of the bent that they will never use the native `ls` utility, then they can create a `ls` alias for Get-ChildItem in their profile.     \n\nBTW I don't think trying to make `Get-ChildItem` parameter compatible with `ls` is feasible.  You'll get hung up pretty quickly with PowerShell parameters not being case-sensitive e.g. -c/-C, -d/-D, -i/-I.  And PowerShell doesn't support parameter combining e.g. ls -rt.  It's a reach and it violates PowerShell's Monad principle.  A task like sorting would be done by a separate cmdlet (Sort-Object) and not by Get-ChildItem itself.\n",
      "created_at": "2016-09-05T19:10:53Z",
      "updated_at": "2016-09-05T19:10:53Z"
    },
    {
      "author": "be5invis",
      "author_association": "NONE",
      "body": "@rkeithhill I am not going to make `Get-ChildItem` being compatible with `ls`. I am purposing another cmdlet, may be called `UnixCompatibles-ls` as its full name, and have a separate command parser which accepts GNU getopt flavor, instead of PowerShell.\n",
      "created_at": "2016-09-05T19:14:00Z",
      "updated_at": "2016-09-05T19:14:00Z"
    },
    {
      "author": "ygra",
      "author_association": "NONE",
      "body": "@be5invis Isn't the easier option at that point a separate function that runs `ls`, passing it all its arguments, parses the output and creates objects from them? A completely separate command parser (along with completely separate command metadata, formatting for `Get-Help`, ...) is a bit overkill (apart from replicating much of PowerShell's internal workings in an incompatible manner.\n\nThere's always going to be two separate worlds here, one native, one typed. PowerShell already services both of them, by being able to execute native programs and cmdlets. I personally don't see any benefit (just a massive undertaking in development effort) in trying to add a layer above native commands that replicates their parameter metadata within PowerShell. Besides, what would you do about `tar`, or `find` (and lots of other programs), which AFAIK don't adhere to the GNU conventions. Implement yet _another_ command parser, along with wrapper functions to call those? Note also that for a command parser to work, the native program's arguments have to be parsed within PowerShell and must not conflict with the language. Something that might be difficult with weird things like `[`.\n",
      "created_at": "2016-09-05T19:23:45Z",
      "updated_at": "2016-09-05T19:28:10Z"
    },
    {
      "author": "be5invis",
      "author_association": "NONE",
      "body": "@ygra It is okay either.\n",
      "created_at": "2016-09-05T19:25:47Z",
      "updated_at": "2016-09-05T19:25:47Z"
    },
    {
      "author": "Liturgist",
      "author_association": "NONE",
      "body": "> For users want to use Powershell, they want types, right?\n\n@be5invis, perhaps this is where a bit of disconnect occurs. No, they do not want types. The user wants to get their work, or play, done. The user knows that `ls` produces a stream of text.\n\nIs `UnixCompatibles` a verb? Would this change the user's $PROFILE script permanently, or only for this session? I would not want Get-ChildItem to be ls compatible. Let `ls` be `ls` and do what `ls` does. It sounds like this would give the user a choice to replace `ls` with `Get-ChildItem`. That's fine. I am not sure that I want that, but for those who do, that's fine.\n",
      "created_at": "2016-09-05T19:26:22Z",
      "updated_at": "2016-09-05T19:27:43Z"
    },
    {
      "author": "Gaelan",
      "author_association": "NONE",
      "body": "@Liturgist I think what @be5invis means is that if people went to the trouble of switching to Powershell (as opposed to staying with Bash), it is because they want something Powershell provides. If people wanted a stream of text out of `ls`, (on Linux or macOS) they would never have bothered with Powershell.\n",
      "created_at": "2016-09-06T04:22:44Z",
      "updated_at": "2016-09-06T04:22:44Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "@Gaelan So I shouldn't use PowerShell if I need to use gcc or git?  What's wrong with letting folks decide if they want text (ls) or objects (gci)?  There are more reasons to use PowerShell than just its OO nature - powerful as it is.  Heck I'd rather use PowerShell just for its C/C# like control flow statements (vs if/fi and switch case/esac) and its proper type system (where numbers are numbers and not strings).\n",
      "created_at": "2016-09-06T05:16:17Z",
      "updated_at": "2016-09-06T05:16:17Z"
    },
    {
      "author": "Gaelan",
      "author_association": "NONE",
      "body": "@rkeithhill \n\n> So I shouldn't use PowerShell if I need to use gcc or git?\n\nOn a *nix system, if users just wanted to use the shell for gcc or git they wouldn't bother with PowerShell, because the shell that came with their OS does that perfectly well.\n\n> Heck I'd rather use PowerShell just for its C/C# like control flow statements (vs if/fi and switch case/esac)\n\nPerhaps if someone was already using PowerShell they would prefer it because of that, but I doubt that someone would install PS just for that.\n\n> its proper type system (where numbers are numbers and not strings)\n\n`/bin/ls` doesn't work with the type system either: if I run `ls -l`, I will get file sizes as a string instead of a proper PS number.\n\nI feel like the reasons a new user would switch to PS on *nix largely revolve around the OO and the type system. We should make it as easy as possible for new users to get started with PS\u2013if I saw something about PS, tried to check it out, only to discover that I needed to relearn everything about the command line to use it, I would probably be much less likely to bother with learning it than if I could fire up PS, type `ls` and immediately see the type system in action. Yes, I could use aliases, but if I'm just trying out PS in a few spare minutes I'm unlikely to want to do much configuration before I jump in and start playing around.\n",
      "created_at": "2016-09-06T05:58:26Z",
      "updated_at": "2016-09-06T05:58:26Z"
    },
    {
      "author": "ForNeVeR",
      "author_association": "NONE",
      "body": "> On a *nix system, if users just wanted to use the shell for gcc or git they wouldn't bother with PowerShell, because the shell that came with their OS does that perfectly well.\n> \n> Perhaps if someone was already using PowerShell they would prefer it because of that, but I doubt that someone would install PS just for that.\n\nSorry, but I strongly disagree. As a Linux user, **I** want to use PowerShell instead of shell that came with my OS. For everything. Because it's awesome, you know :)\n\nHeck, I am even packaging PowerShell for [NixOS](https://nixos.org/) right now just to use it for everything.\n\nPlease consider that our target users are not only native Unix users who accidentally use Windows+PowerShell, but also Windows users who accidentally use Unix+PowerShell ;)\n",
      "created_at": "2016-09-06T06:59:29Z",
      "updated_at": "2016-09-06T06:59:29Z"
    },
    {
      "author": "xoofx",
      "author_association": "NONE",
      "body": "> A single character (like ^) that automatically falls into the native PATH\n\nI would also prefer to keep aliases compatible across OS whenever they are valid on these platforms and use an escape character (like `^ls`) to get an implicit access to native commands, as suggested by @joeyaiello\nI'm not familiar with the whole PowersShell philosophy, but what could be wrong with such an approach?\n",
      "created_at": "2016-11-19T08:56:52Z",
      "updated_at": "2016-11-19T08:56:52Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "Actually, one more point for using a single-character escaping: bash already does it. https://twitter.com/climagic/status/806536501232340992\r\n\r\n`\\ls` ignores all aliases.",
      "created_at": "2016-12-07T17:50:48Z",
      "updated_at": "2016-12-07T17:50:48Z"
    },
    {
      "author": "Liturgist",
      "author_association": "NONE",
      "body": "Is the answer to aliases solved by enabling WSL (Windows Subsystem for Linux)? This will provide native sed, awk, ls, etc. commands in a bash shell.\r\n\r\nWhile it is still beta code for Windows 10, surely it will be coming and made available in Server 2016 and 2012.",
      "created_at": "2017-02-20T20:23:28Z",
      "updated_at": "2017-02-20T20:23:28Z"
    },
    {
      "author": "bgshacklett",
      "author_association": "NONE",
      "body": "@Liturgist Currently, the WSL is a very separate environment from PowerShell. The commands are not callable from a PowerShell session. Additionally, this would likely be considered a regression by many current Windows PowerShell users as many scripts would break if they received the output from, say, GNU `ls` rather than `ls -> Get-ChildItem`. While the use of aliases was never recommended in scripts, the fact remains that they have been used and breakage would cause difficulty for many people.",
      "created_at": "2017-02-21T20:46:50Z",
      "updated_at": "2017-02-21T20:46:50Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "@Liturgist: @bgshacklett is on right here. The problem is not that *something* happens when you type `ls`, the question is what parameters you expect while using that, and whether or not the output emitted is consumable in an object-oriented fashion by other PowerShell cmdlets (i.e. `ls | Where-Object Name -like *foo*` won't work if you're using the WSL `ls`). ",
      "created_at": "2017-02-21T22:20:59Z",
      "updated_at": "2017-02-21T22:20:59Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "The original issue with conflicting aliases with native cmds has been addressed.  If there is a need to have the capability to add back popular Windows PowerShell aliases, that should be a separate issue.",
      "created_at": "2017-04-18T17:16:20Z",
      "updated_at": "2017-04-18T17:16:20Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "Opened https://github.com/PowerShell/PowerShell/issues/3610 to capture secondary issue",
      "created_at": "2017-04-20T21:08:55Z",
      "updated_at": "2017-04-20T21:08:55Z"
    }
  ],
  "created_at": "2016-04-28T21:40:40Z",
  "labels": [
    "OS-macOS",
    "OS-Linux",
    "Usability",
    "WG-DevEx-Portability",
    "Issue-Discussion",
    "Resolution-Fixed"
  ],
  "number": 929,
  "state": "closed",
  "title": "Figure out aliases",
  "updated_at": "2017-04-20T21:08:55Z"
}