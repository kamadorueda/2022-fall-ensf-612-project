{
  "_url": "https://github.com/PowerShell/PowerShell/issues/4242",
  "author": "mklement0",
  "body": "<sup>Updated based on feedback from @PetSerAl to clarify Category B.</sup>\r\n\r\n`-InputObject <psobject>` and `-InputObject <object>` parameters bind values that are collections _as-is_ to the parameter variable.\r\nUnless the cmdlet explicitly checks for collection-valued input and iterates over it, the collection is processed _as itself, as a single object_.\r\n\r\nThe core cmdlets that have such a parameter can be categorized as follows:\r\n\r\n<sup>`ConvertTo-Json` is the only cmdlet where the parameter is `[object]`-typed rather than `[psobject]`-typed - it is unclear to me why.  \r\n`Register-Object` is not covered below, because its `-InputObject` parameter doesn't actually pipeline-bind.</sup>\r\n\r\n* **Category A**: _A few_ cmdlets do make a useful distinction between a collection passed as a whole via `-InputObject` vs. item iteration via the pipeline, notably `Get-Member`.\r\n* For the _majority_ of cmdlets, processing a collection as a whole is pointless, and these cmdlets currently fall into the two remaining categories:\r\n    * **Category B**: If a collection is passed via `-InputObject`, they explicitly iterate over the collection, though potentially differently than with pipeline input.\r\n        * For such cmdlets, using the pipeline and using `-InputObject` is effectively equivalent, but only for _flat_ collections.\r\n    * **Category C**: If a collection is passed via `-InputObject`, that collection is processed as a single object, which, given the premise, doesn't make sense.\r\n        * For such cmdlets, the `-InputObject` parameter _should be documented as not for direct use_, it being a mere implementation detail that facilitates pipeline input.\r\n            * The documentation of _some_ of these cmdlets already mentions the pitfall of using `-InputObject`, but by no means all.\r\n        * Alternatively, these cmdlets could be modified to perform explicit iteration, as the cmdlets in the previous category do.  While this would technically be a breaking change, it probably falls into [Bucket 3: Unlikely Grey Area](https://github.com/PowerShell/PowerShell/blob/master/docs/dev-process/breaking-change-contract.md#bucket-3-unlikely-grey-area)\r\n\r\nHere's my attempt at mapping the cmdlets that ship with PowerShell to these categories:\r\n\r\n* Category A: OK: Useful distinction between pipeline input and explicit -InputObject use:\r\n\r\n    * `Add-Member`\r\n    * `Export-Clixml`\r\n    * `Get-Member`\r\n    * `Trace-Command`\r\n\r\n* Category B:  SOMEWHAT PROBLEMATIC: No effective distinction between pipeline input and explicit `-InputObject` use for _flat_ collections, but behavior differs with _nested_ ones:\r\n\r\n    * `Format-Custom`\r\n    * `Format-List`\r\n    * `Format-Table`\r\n    * `Format-Wide`\r\n    * `Out-Host`\r\n    * `Out-String`\r\n    *  `Out-File`\r\n    *  `Join-String`\r\n    *  `Set-Content` / `Add-Content`\r\n\r\n* Category C: PROBLEMATIC: Distinction between pipeline input and explicit `-InputObject` use, with `-InputObject` input performing no enumeration, making it useless:\r\n\r\n    * `ConvertTo-Csv`\r\n    * `ConvertTo-Html`\r\n    * `ConvertTo-Xml`\r\n    * `Export-Csv`\r\n    * `ForEach-Object`\r\n    * `Format-Hex`\r\n    * `Get-Unique`\r\n    * `Group-Object`\r\n    * `Invoke-Command`\r\n    * `Measure-Command`\r\n    * `Measure-Object`\r\n    * `Select-Object`\r\n    * `Select-String`\r\n    * `Sort-Object`\r\n    * `Start-Job`\r\n    * `Where-Object`\r\n\r\nAmong the Category C cmdlets, the **help topics of the following contain misleading information**:\r\n  * `ConvertTo-Csv`\r\n  * `ConvertTo-Xml`\r\n  * `Export-Csv`\r\n  * `Format-Hex`\r\n  * `Invoke-Command`\r\n  * `Measure-Command` - but see https://github.com/PowerShell/PowerShell-Docs/issues/2140\r\n  * `Start-Job`\r\n\r\nTo give a concrete example of the problematic current documentation, the `Export-Csv` help topic currently states:\r\n\r\n> -InputObject\r\n> Specifies the objects to export as CSV strings. Enter a variable that contains the objects or type a command or expression that gets the objects. You can also pipe objects to Export-CSV.\r\n\r\nSee #3865 - which @BrucePay rightly closed as by-design - for what happens when you believe the documentation (which I did).\r\n\r\nAs stated, given how this cmdlet currently works, the documentation _should_ effectively say something like:\r\n\r\n> -InputObject is an auxiliary parameter that enables pipeline input. Don't use this parameter directly, use the pipeline instead.\r\n\r\nOf course, the alternative is to change the behavior to perform explicit iteration, as stated.\r\n\r\nGenerally, though, when implementing item-by-item-processing cmdlets, `-InputObject <psobject>` is inherently problematic:\r\n\r\n  * With _pipeline_ input, it conveniently iterates for you via the `Process` block\r\n  * But with explicit `-InputObject` use, you get no useful behavior by default and your choices are:\r\n     * Document your parameter along the lines of \"Nothing to see here. Use the pipeline instead\".\r\n     * Explicitly iterate over the variable in your `Process` block (at which point you may as well declare your parameter explicitly as array-valued, `-InputObject <psobject[]>`).\r\n\r\n---\r\n\r\nHere's the full matrix of cmdlets and their behavior from which the categorization above was obtained. The source code is further below, which also contains direct links to the help topics.\r\n\r\nNote: `True` values in column `IsSame` only indicate equivalence for _flat_ collections.\r\n\r\n```none\r\nCmdlet           IsSame HelpClaimsIsSame ShouldBeSame FailsWithArrayInputObject Comment                                                                        \r\n------           ------ ---------------- ------------ ------------------------- -------                                                                        \r\nAdd-Member        False             True        False                     False                                                                                \r\nConvertTo-Csv     False             True         True                     False                                                                                \r\nConvertTo-Html    False            False         True                     False                                                                                \r\nConvertTo-Xml     False             True         True                     False                                                                                \r\nExport-Clixml     False             True        False                     False                                                                                \r\nExport-Csv        False             True         True                     False                                                                                \r\nForEach-Object    False            False         True                     False                                                                                \r\nFormat-Custom      True             True         True                     False                                                                                \r\nFormat-Hex        False             True         True                      True Help merely contains a placeholder for the -InputObject description (as of 2...\r\nFormat-List        True             True         True                     False                                                                                \r\nFormat-Table       True             True         True                     False                                                                                \r\nFormat-Wide        True             True         True                     False                                                                                \r\nGet-Member        False            False        False                     False                                                                                \r\nGet-Unique        False            False         True                     False                                                                                \r\nGroup-Object      False            False         True                     False                                                                                \r\nInvoke-Command    False             True         True                     False                                                                                \r\nMeasure-Command   False             True         True                     False                                                                                \r\nMeasure-Object    False            False         True                     False                                                                                \r\nOut-Default        True             True         True                     False Help just states (as of 26 May 2017): \"Accepts input to the cmdlet.\"           \r\nOut-File          False             True         True                     False                                                                                \r\nOut-Host           True             True         True                     False                                                                                \r\nOut-Null                                                                  False Output behavior by definition doesn't apply.                                   \r\nOut-String         True             True         True                     False                                                                                \r\nSelect-Object     False            False         True                     False                                                                                \r\nSelect-String     False            False         True                     False                                                                                \r\nSet-ItemProperty                                                          False Couldn't figure out -InputObject use. -InputObject description uses *singlua...\r\nSort-Object       False            False         True                     False                                                                                \r\nStart-Job         False             True         True                     False Hard-coded result (test too complex to model here)                             \r\nTrace-Command     False             True        False                     False Help states \"You can enter a variable that represents the input that the exp...\r\nWhere-Object      False            False         True                     False                                                                                \r\n```\r\n\r\nTest-function source code\r\n---------------\r\n\r\n```none\r\nfunction Test-InputObjectParam {\r\n\r\n  [CmdletBinding()]\r\n  param()\r\n\r\n  set-strictmode -version 1\r\n\r\n\r\n  $inCollCustObj = [System.Collections.Generic.List[pscustomobject]] ([pscustomobject] @{ foo = 1; bar = 2 }, [pscustomobject] @{ foo = 3; bar = 4 })\r\n  $inCollStr = 'one', 'two', 'three'\r\n\r\n  $tempFiles = ($tempFile1 = New-TemporaryFile), ($tempFile2 = New-TemporaryFile) \r\n\r\n  # Use this command to scaffold the hashtable of tests below.\r\n  <#\r\n    Get-Command -Type cmdlet -ParameterName inputobject | ? { \r\n      $_.Parameters.InputObject.ParameterType -in [psobject], [object] -and $_.Parameters.InputObject.ParameterSets.Values.ValueFromPipeline \r\n    } | % { \"'$($_.Name)' = @{`n  ShouldbeSame = `n}`n\" }\r\n  #>\r\n\r\n  # !! Those cmdlets that DO unwrap a collection passed to -InputObject\r\n  # !! accept only a *single* collection.\r\n  # !! Something like -InputObject (1, 2), (3,4) still causes different output.\r\n\r\n  $tests = [ordered] @{\r\n\r\n    'Add-Member' = @{\r\n      ShouldBeSame = $False\r\n      HelpClaimsIsSame = $True\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Utility/Add-Member.md'\r\n      Params = @{ NotePropertyMembers = @{ 'addedProp' = 666 }; PassThru = $True }\r\n      Test = { ($inColl.psobject.Properties).Name -notcontains 'addedProp' }\r\n    }\r\n\r\n    'ConvertTo-Csv' = @{\r\n      ShouldBeSame = $True\r\n      HelpClaimsIsSame = $True\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Utility/ConvertTo-Csv.md'\r\n      Params = @{}\r\n    }\r\n\r\n    'ConvertTo-Html' = @{\r\n      ShouldBeSame = $True\r\n      HelpClaimsIsSame = $False\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Utility/ConvertTo-Html.md'\r\n      HelpOK = $False\r\n      Params = @{}\r\n    }\r\n\r\n    'ConvertTo-Xml' = @{\r\n      ShouldBeSame = $True\r\n      HelpClaimsIsSame = $True\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Utility/ConvertTo-Xml.md'\r\n      Params = @{ As = 'String' }\r\n    }\r\n\r\n    'Export-Clixml' = @{\r\n      ShouldBeSame = $False\r\n      HelpClaimsIsSame = $True\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Utility/Export-Clixml.md'\r\n      Params = @{ LiteralPath = $null }\r\n    }\r\n\r\n    'Export-Csv' = @{\r\n      ShouldBeSame = $True\r\n      HelpClaimsIsSame = $True\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Utility/Export-Csv.md'\r\n      Params = @{ LiteralPath = $null }\r\n    }\r\n\r\n    'ForEach-Object' = @{\r\n      ShouldBeSame = $True\r\n      HelpClaimsIsSame = $False\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/ForEach-Object.md'\r\n      Params = @{ Process = { \"[$_]\" } }\r\n    }\r\n\r\n    'Format-Custom' = @{\r\n      ShouldBeSame = $True\r\n      HelpClaimsIsSame = $True\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Utility/Format-Custom.md'\r\n      Params = @{}\r\n    }\r\n\r\n    'Format-Hex' = @{\r\n      ShouldBeSame = $True\r\n      HelpClaimsIsSame = $True\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Utility/Format-Hex.md'\r\n      Params = @{}\r\n      UseStrings = $True\r\n      Comment = 'Help merely contains a placeholder for the -InputObject description (as of 26 May 2017): \"{{Fill InputObject Description}}.\"'\r\n    }\r\n\r\n    'Format-List' = @{\r\n      ShouldBeSame = $True\r\n      HelpClaimsIsSame = $True\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Utility/Format-List.md'\r\n      Params = @{}\r\n    }\r\n\r\n    'Format-Table' = @{\r\n      ShouldBeSame = $True\r\n      HelpClaimsIsSame = $True\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Utility/Format-Table.md'\r\n      Params = @{}\r\n    }\r\n\r\n    'Format-Wide' = @{\r\n      ShouldBeSame = $True\r\n      HelpClaimsIsSame = $True\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Utility/Format-Wide.md'\r\n      Params = @{}\r\n    }\r\n\r\n    'Get-Member' = @{\r\n      ShouldBeSame = $False #\r\n      HelpClaimsIsSame = $False\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Utility/Get-Member.md'\r\n      Params = @{}\r\n    }\r\n\r\n    'Get-Unique' = @{\r\n      ShouldBeSame = $True\r\n      HelpClaimsIsSame = $False\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Utility/Get-Unique.md'\r\n      Params = @{}\r\n    }\r\n\r\n    'Group-Object' = @{\r\n      ShouldBeSame = $True\r\n      HelpClaimsIsSame = $False\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Utility/Group-Object.md'\r\n      Params = @{}\r\n      UseStrings = $true\r\n    }\r\n\r\n    'Invoke-Command' = @{\r\n      ShouldBeSame = $True\r\n      HelpClaimsIsSame = $True\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/Invoke-Command.md'\r\n      Params = @{ ScriptBlock = { $Input | Measure-Object | % Count } }\r\n    }\r\n\r\n    'Measure-Command' = @{\r\n      ShouldBeSame = $True\r\n      HelpClaimsIsSame = $True\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Utility/Measure-Command.md'\r\n      Params = @{ Expression = { $_.GetType().Name | Write-Information -InformationVariable res } }\r\n      UseResVariable = $True\r\n    }\r\n\r\n    'Measure-Object' = @{\r\n      ShouldBeSame = $True\r\n      HelpClaimsIsSame = $False\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Utility/Measure-Object.md'\r\n      Params = @{}\r\n      Test = { $res1.Count -eq $res2.Count }\r\n    }\r\n\r\n    # Note: Output from this cmdlet's test commands won't be suppressed below.\r\n    'Out-Default' = @{\r\n      ShouldBeSame = $True\r\n      HelpClaimsIsSame = $True\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Utility/Out-Default.md'\r\n      Params = @{ OutVariable = 'res' }\r\n      UseResVariable = $True\r\n      Comment = 'Help just states (as of 26 May 2017): \"Accepts input to the cmdlet.\"'\r\n    }\r\n\r\n    'Out-File' = @{\r\n      ShouldBeSame = $True\r\n      HelpClaimsIsSame = $True\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Utility/Out-File.md'\r\n      Params = @{ LiteralPath = $null }\r\n    }\r\n\r\n    # Note: Output from this cmdlet's test commands won't be suppressed below.\r\n    'Out-Host' = @{\r\n      ShouldBeSame = $True\r\n      HelpClaimsIsSame = $True\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/Out-Host.md'\r\n      Params = @{ OutVariable = 'res' }\r\n      UseResVariable = $True\r\n    }\r\n\r\n    'Out-Null' = @{\r\n      Skip = $True\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/Out-Null.md'    \r\n      Comment = 'Output behavior by definition doesn''t apply.'\r\n    }\r\n\r\n    'Out-String' = @{\r\n      ShouldBeSame = $True\r\n      HelpClaimsIsSame = $True\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Utility/Out-String.md'    \r\n      Params = @{ Stream = $True }\r\n    }\r\n\r\n    'Select-Object' = @{\r\n      ShouldBeSame = $True\r\n      HelpClaimsIsSame = $False\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Utility/Select-Object.md'\r\n      Params = @{ Last = 1 }\r\n    }\r\n\r\n    'Select-String' = @{\r\n      ShouldBeSame = $True\r\n      HelpClaimsIsSame = $False\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Utility/Select-String.md'\r\n      Params = @{ Pattern = 'n' }\r\n      UseStrings = $true\r\n    }\r\n\r\n    'Set-ItemProperty' = @{\r\n      Skip = $True\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Management/Set-ItemProperty.md'\r\n      Comment = 'Couldn''t figure out -InputObject use. -InputObject description uses *singluar* and seems incorrect.'\r\n    }\r\n\r\n    'Sort-Object' = @{\r\n      ShouldBeSame = $True\r\n      HelpClaimsIsSame = $False\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Utility/Sort-Object.md'\r\n      Params = @{ Descending = $True }\r\n      UseStrings = $true\r\n    }\r\n\r\n    # Manually determined results:\r\n    # $coll = 1, 2\r\n    # Receive-Job -Wait -AutoRemoveJob (Start-Job { $Input | Measure-Object } -Input $coll) # -> 1\r\n    # Receive-Job -Wait -AutoRemoveJob ($coll | Start-Job { $Input | Measure-Object }) # -> 2\r\n    'Start-Job' = @{\r\n      Skip = $True\r\n      ShouldBeSame = $True\r\n      HardcodedIsSame = $False\r\n      HelpClaimsIsSame = $True\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/Start-Job.md'\r\n      Params = @{ LiteralPath = $null }\r\n      UseStrings = $True\r\n      Comment = 'Hard-coded result (test too complex to model here)'\r\n    }\r\n\r\n    'Trace-Command' = @{\r\n      ShouldBeSame = $False\r\n      HelpClaimsIsSame = $True\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Utility/Trace-Command.md'\r\n      Params = @{ Name = 'type*'; Expression = { $Input | Measure-Object | % Count } }\r\n      Comment = 'Help states \"You can enter a variable that represents the input that the expression accepts, or pass an object through the pipeline.\"'\r\n    }\r\n\r\n    'Where-Object' = @{\r\n      ShouldBeSame = $True\r\n      HelpClaimsIsSame = $False\r\n      HelpSourceUrl = 'https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/Where-Object.md'\r\n      Params = @{ FilterScript = { 'one' -eq $_ } }\r\n      UseStrings = $True\r\n    }\r\n\r\n  }\r\n\r\n\r\n  foreach ($cmdlet in $tests.keys) {\r\n    $test = $tests[$cmdlet]\r\n    $htParams = $test.Params\r\n    if (-not $test.Skip) {\r\n      $usesOutFiles = $htParams.ContainsKey('LiteralPath')\r\n      $inColl = if ($test.UseStrings) { $inCollStr } else { $inCollCustObj }\r\n      if ($usesOutFiles) { $htParams.LiteralPath = $tempFile1 }\r\n      $res1 = & $cmdlet -InputObject $inColl @htParams -EA SilentlyContinue -EV err\r\n      if ($test.UseResVariable) { $res1 = $res }\r\n      if ($usesOutFiles) { $htParams.LiteralPath = $tempFile2 }\r\n      $res2 = $inColl | & $cmdlet @htParams\r\n      if ($test.UseResVariable) { $res2 = $res }\r\n    }\r\n    [pscustomobject] @{\r\n      Cmdlet = $cmdlet\r\n      IsSame = if ($test.Skip) {\r\n                $test.HardcodedIsSame\r\n              } elseif ($err -or $null -eq $res1) {\r\n                $False\r\n              } elseif ($test.Test) {\r\n                & $test.Test $res1, $res1\r\n              } else {\r\n                if ($usesOutFiles) {\r\n                    (Get-Content -Raw $tempFile1) -eq (Get-Content -Raw $tempFile2)\r\n                } else {\r\n                  (Compare-Object -SyncWindow 0 $res1 $res2).Count -eq 0\r\n                }\r\n              }\r\n      HelpClaimsIsSame = $test.HelpClaimsIsSame\r\n      ShouldBeSame = $test.ShouldBeSame\r\n      FailsWithArrayInputObject = $err.Count -gt 0\r\n      Comment = $test.Comment\r\n      HelpSourceUrl = $test.HelpSourceUrl\r\n    }\r\n    if ($test.Skip) {\r\n      Write-Verbose \"SKIPPED: =============== $cmdlet\"\r\n    } elseif ($usesOutFiles) {\r\n      Write-Verbose \"*1: -InputObject* =============== $cmdlet\"\r\n      Write-Verbose (Get-Content -Raw $tempFile1)\r\n      Write-Verbose \"*2: Pipeline*     =============== $cmdlet\"\r\n      Write-Verbose (Get-Content -Raw $tempFile2)\r\n    } else {\r\n      Write-Verbose \"*1: -InputObject* ================ $cmdlet\"\r\n      Write-Verbose ($res1 | Out-String)\r\n      Write-Verbose \"*2: Pipeline*     ================ $cmdlet\"\r\n      Write-Verbose ($res2 | Out-String)\r\n    } \r\n  }\r\n\r\n  Remove-Item -ea Ignore $tempFiles\r\n\r\n}\r\n\r\n' --- Those where pipeline input and -InputObject use are equivalent:'\r\nTest-InputObjectParam | ? { $_.IsSame -and $_.ShouldBeSame } | % cmdlet\r\n\r\n\r\n' --- Those where the distinction between pipeline input and -InputObject makes sense:'\r\nTest-InputObjectParam | ? { $False -eq $_.ShouldBeSame -and $false -eq $_.IsSame } | % cmdlet\r\n\r\n\r\n' --- Those where there is a distinction between pipeline input and -InputObject, but it makes no sense:'\r\nTest-InputObjectParam | ? { $_.ShouldBeSame -and $false -eq $_.IsSame } | % cmdlet\r\n\r\n' --- Those where there is a distinction between pipeline input and -InputObject, but it makes no sense, and the help topics don''t clarify that:'\r\nTest-InputObjectParam | ? { $_.ShouldBeSame -and $false -eq $_.IsSame -and $_.HelpClaimsIsSame } | % cmdlet\r\n```\r\n\r\nEnvironment data\r\n----------------\r\n\r\n<!-- provide the output of $PSVersionTable -->\r\n\r\n```powershell\r\nPowerShell Core v6.0.0-beta.3 on macOS 10.12.5\r\nPowerShell Core v6.0.0-beta.3 on Ubuntu 16.04.1 LTS\r\nPowerShell Core v6.0.0-beta.3 on Microsoft Windows 10 Pro (64-bit; v10.0.14393)\r\nWindows PowerShell v5.1.15063.413 on Microsoft Windows 10 Pro (64-bit; v10.0.15063)\r\n```\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "PetSerAl",
      "author_association": "CONTRIBUTOR",
      "body": "**Category B** is actually empty (try `$a = 1,(2,(3,4))` as test object). If cmdlet itself iterate over collection, then difference would be in how many levels are iterated, unless you are making collection flat.",
      "created_at": "2017-07-17T22:50:27Z",
      "updated_at": "2017-07-17T22:50:27Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @PetSerAl.\r\n\r\nI can see how with _nested_ collections the behavior differs:\r\n\r\n```powershell\r\n> Format-List -InputObject 1, (2, (3, 4))\r\n1\r\n\r\nLength         : 2\r\nLongLength     : 2\r\nRank           : 1\r\nSyncRoot       : {2, 3 4}\r\nIsReadOnly     : False\r\nIsFixedSize    : True\r\nIsSynchronized : False\r\nCount          : 2\r\n```\r\n\r\nvs:\r\n\r\n```powershell\r\n> 1, (2, (3, 4)) | Format-List \r\n1\r\n2\r\n\r\n\r\nLength         : 2\r\nLongLength     : 2\r\nRank           : 1\r\nSyncRoot       : {3, 4}\r\nIsReadOnly     : False\r\nIsFixedSize    : True\r\nIsSynchronized : False\r\nCount          : 2\r\n```\r\n\r\nSo is it fair to summarize Category B as comprising cmdlets that exhibit equivalent behavior only with _flat_ collections?\r\n\r\n",
      "created_at": "2017-07-18T16:09:37Z",
      "updated_at": "2017-07-18T16:09:37Z"
    },
    {
      "author": "PetSerAl",
      "author_association": "CONTRIBUTOR",
      "body": "@mklement0 Yes, I think, you can possible phrase it like that.",
      "created_at": "2017-07-18T16:37:19Z",
      "updated_at": "2017-07-18T16:37:19Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @PetSerAl - I've updated the original post.",
      "created_at": "2017-07-18T16:52:50Z",
      "updated_at": "2017-07-18T16:52:50Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 in terms of the implementation differences with cmdlets or advanced functions that attempt to account for both input methods, I believe there is an [`ExpectingInput`](https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.invocationinfo.expectinginput?view=powershellsdk-1.1.0) value that can be used to determine if the cmdlet is being used in a pipeline capacity, which might help to properly mirror the implementations, rather than blindly iterating over whatever happens to be stored in `InputObject` at the time.",
      "created_at": "2019-01-09T13:15:28Z",
      "updated_at": "2019-01-09T13:15:28Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Good tip, @vexx32.\r\n\r\nWere you thinking along the following lines?\r\n\r\n```powershell\r\nfunction foo {\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(ValueFromPipeline)]\r\n        [object] $Param1  # declare as scalar\r\n    )\r\n\r\n    process {\r\n      if ($MyInvocation.ExpectingInput) { # pipeline input, already enumerated\r\n        \"[$Param1]\"\r\n      } else { # argument input, enumerate explicitly\r\n        foreach ($o in $Param1) { \"[$o]\" }\r\n      }\r\n    }\r\n\r\n}\r\n```\r\n\r\n`foo 1, (2, 3)` and `1, (2, 3) | foo` then both result in:\r\n\r\n```none\r\n[1]\r\n[2 3]\r\n```\r\n\r\nHowever, `foreach` isn't truly equivalent to pipeline enumeration, notably with `$null` as input: `$null | foo` vs. `foo $null`.\r\nWhat is needed to robustly emulate pipeline enumeration without involving a (costly) additional pipeline? Or is special-casing `$null` with `foreach` the best we can do?\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2019-01-09T14:03:03Z",
      "updated_at": "2019-01-09T14:03:03Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "\ud83e\udd14 \r\n\r\nI think you can snip that last disparity fairly easily:\r\n\r\n```powershell\r\nforeach ($o in @($Param1)) { \"[$o]\" }\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/32407840/50904558-94bbf180-13ee-11e9-8aaf-2cfdea46aa2e.png)\r\n",
      "created_at": "2019-01-09T14:09:42Z",
      "updated_at": "2019-01-09T14:11:45Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Cool, thanks.\r\n\r\nCan we conclude that the best way to implement an item-by-item processing cmdlet that also supports collections as arguments via `-InputObject` is to use the above approach, based on a _scalar_ `-InputObject` declaration (`[object] $Param`)?\r\n\r\n(Using `[object[]] $Param1` would work too, but needlessly creates an array for each pipeline input object.)",
      "created_at": "2019-01-09T14:15:25Z",
      "updated_at": "2019-01-09T14:15:25Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Pretty much, I would think, yeah. With that in mind, any cmdlet or function that should mirror the pipeline logic with its direct input parameters should look like this in PS from your example:\r\n\r\n```powershell\r\nif ($MyInvocation.ExpectingInput) {\r\n    $Param1 # do things with or output $Param1\r\n}\r\nelse { \r\n     foreach ( $o in @($Param1) ) {\r\n        $o # do things with or output $o\r\n    }\r\n}\r\n```\r\n\r\nSimilarly in C# cmdlets we can cast to `(Array)` on direct input before enumerating for a similar effect, I think. As you say, we probably don't want to force all pipeline items to be wrapped in an array if we can avoid it.\r\n\r\nEDIT: Also, with PSObject-typed parameter, the pattern for C# would need to look something like this:\r\n\r\n```csharp\r\nobject inputItems = null;\r\nif (MyInvocation.ExpectingInput)\r\n{\r\n    inputItems = InputObject.BaseObject;\r\n}\r\nelse\r\n{\r\n    inputItems = new List<object>();\r\n    foreach (object item in (Array)InputObject.BaseObject)\r\n    {\r\n        inputItems.Add(item);\r\n    }\r\n}\r\n// do things with inputItems and output or something\r\nWriteObject(inputItems, true);\r\n```\r\n\r\nThis would be necessary since an array of any length will still be stored inside a singular PSObject.\r\n\r\nNot 100% sure how to get at ExpectingInput from a cmdlet, but I think it might be in SessionState somewhere? It's been a while since I had to look for it on the C# side...",
      "created_at": "2019-01-09T14:15:28Z",
      "updated_at": "2019-01-11T18:09:28Z"
    },
    {
      "author": "PetSerAl",
      "author_association": "CONTRIBUTOR",
      "body": "@mklement0 \r\n>Using `[object[]] $Param1` would work too, but needlessly creates an array for each pipeline input object.\r\n\r\nCasting something to array does not necessary wrap it into single element array. And pipeline does not restricted to scalars only. How are you planning to distinguish `1..3 | foo` from `1..3 | % { ,,$_ } | foo` or from `1..3 | % { ,[System.Collections.Generic.List[object]]::new((,$_)) } | foo`? In all three cases `foo` will see `$Param1` as array with single integer, if `foo` declare it as `[object[]] $Param1`.\r\n",
      "created_at": "2019-01-12T14:53:23Z",
      "updated_at": "2019-01-12T14:53:23Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "It isn't required to declare the array as `[object[]]`; `[object]` is capable of wrapping an array object. \ud83d\ude04 ",
      "created_at": "2019-01-12T16:44:09Z",
      "updated_at": "2019-01-12T16:44:09Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Good point, @PetSerAl - I was too narrowly focused on flat input collections.\r\n\r\nDo you agree that the `[object]`-based approach summarized by @vexx32 above is the best approach, given the current capabilities?\r\n\r\nLonger-term, I wonder if we could introduce something like `[Parameter(ValueFromPipeline, EnumerateArgument)]` to move equal treatment of pipeline input and collection arguments into the plumbing (arguably, that should have been the default all along). However, presumably that would forfeit the performance benefit that comes from needing only a _single_ invocation of the `process` block.",
      "created_at": "2019-01-13T12:51:12Z",
      "updated_at": "2019-01-13T12:52:03Z"
    },
    {
      "author": "PetSerAl",
      "author_association": "CONTRIBUTOR",
      "body": "@mklement0\r\nI am fine with current behavior. I think it should not be changed. IIRC, from v1 it is been explicitly stated in documentation, that `$Object | Get-Member` is different from `Get-Member -InputObject $Object`. When I explicitly use `-InputObject` parameter, it is always because I want behavior, that is different from what pipeline input does. I see no good reason why someone should generally expect that `Command-Name -InputObject $Object` is the same as `$Object | Command-Name`.",
      "created_at": "2019-01-13T13:25:48Z",
      "updated_at": "2019-01-13T13:25:48Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@PetSerAl: While for `Get-Member` specifically (category A) it makes perfect sense for the behavior to differ, for the vast majority of cmdlets it does not, and - as argued in the initial post of this issue - if the current behavior is retained, the virtually useless-as-a-direct-argument-recipient `-InputObject` parameter for those cmdlets (category C) should be documented as an _implementation detail_ (along the lines of \"this parameter is just here to facilitate pipeline input - do not use it directly\").\r\n\r\nThat's certainly one way to go, and it would make this discussion moot.\r\n\r\nAs shown above, however, there is precedent for item-by-item processing cmdlets that perform their own enumeration (though, as you've demonstrated, the behavior is only identical to input via the pipeline for non-nested collections) - category B.\r\n\r\nWe can either live with these existing anomalies - and discourage explicit `-InputObject` use going forward except for category-A-like cmdlets - or make it easier to create cmdlets that (fully) allow interchangeable use of the pipeline and direct arguments.\r\n\r\nOne reason to do the latter is the very paradigm of declaring pipeline support: you start with declaring a _parameter_ that may _also_ be bound via the pipeline.\r\n\r\nA pragmatic reason to allow it is that (for collections already in memory) direct-argument use is faster than pipeline use; e.g., the direct-argument variant of the following two commands is about 3 times faster on my laptop:\r\n\r\n```powershell\r\nMeasure-Command { 1..1e5 | Out-String }  # pipeline\r\nMeasure-Command { Out-String -InputObject (1..1e5) }  # direct argument\r\n```\r\n\r\nAny syntactic sugar we introduce should then offer similar performance benefits, but I'm unclear on whether that's feasible.\r\n \r\n",
      "created_at": "2019-01-13T13:52:18Z",
      "updated_at": "2019-01-13T13:55:26Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "As I mention [here](https://github.com/PowerShell/PowerShell/issues/8610#issuecomment-454002177), it might make sense to simply have `-InputObject` parameters be designated purely for pipeline use. In such a case, perhaps it would make the most sense to separate pipeline from regular use via parameter sets in most cases, potentially even declaring an entire parameter set as only usable for the pipeline?",
      "created_at": "2019-01-14T13:48:13Z",
      "updated_at": "2019-01-14T13:49:03Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "From the *PowerShell scripting* view, is there a general **best practice** definition for this?\r\nMeaning:\r\n\r\n```PowerShell\r\nfunction Test {\r\n    param (\r\n        [Parameter(ValueFromPipeline)]\r\n        [string]$Param\r\n    )\r\n\r\n    process {\r\n        Write-Output $Param # My process\r\n    }\r\n}\r\n```\r\n\r\nvs:\r\n\r\n```PowerShell\r\nfunction Test {\r\n    param (\r\n        [Parameter(ValueFromPipeline)]\r\n        [string[]]$Param\r\n    )\r\n\r\n    process {\r\n        $Param |FroEach-Object { Write-Output $Param } # My Process\r\n    }\r\n}\r\n```\r\n\r\nSee also: [Looping over a pipeline parameter - what is the point?](https://stackoverflow.com/questions/72711942/looping-over-a-pipeline-parameter-what-is-the-point)",
      "created_at": "2022-06-22T13:41:06Z",
      "updated_at": "2022-06-22T13:54:48Z"
    }
  ],
  "created_at": "2017-07-13T17:20:41Z",
  "labels": [
    "Area-Maintainers-Documentation",
    "WG-Cmdlets"
  ],
  "number": 4242,
  "state": "open",
  "title": "Consistently document a scalar -InputObject parameter as an implementation detail or make item-by-item processing cmdlets explicitly iterate over collections",
  "updated_at": "2022-09-14T21:02:48Z"
}