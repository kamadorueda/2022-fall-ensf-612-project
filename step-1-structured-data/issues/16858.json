{
  "_url": "https://github.com/PowerShell/PowerShell/issues/16858",
  "author": "EtemenNiguru",
  "body": "### Prerequisites\n\n- [X] Write a descriptive title.\n- [X] Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\n- [X] Search the existing issues.\n- [X] Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\n- [X] Refer to [Differences between Windows PowerShell 5.1 and PowerShell](https://docs.microsoft.com/powershell/scripting/whats-new/differences-from-windows-powershell).\n\n### Steps to reproduce\n\nI'm proceed Japanese text in PowerShell with range operator(..)\r\n\r\nGenerally, range operator used like as \"a\" .. \"c\".\r\n```PowerShell\r\nPS> \"a\"..\"c\"\r\na\r\nb\r\nc\r\n```\r\nTherefore range operator can also be used Japanese Kanji.\r\n```PowerShell\r\nPS > \"\u4e00\"..\"\u4e03\"\r\n\u4e00\r\n\u4e01\r\n\u4e02\r\n\u4e03\r\n```\r\nThat characters Unicode code point is \"\u4e00\" to U+4E00, \"\u4e03\" to U+4E03 at CJK unified ideographs in Unicode 14.0.0 .\r\nHowever, a bit Kanji and symbol (include Emoji) cannot represent by single char type. These are called surrogate pairs character.\r\n\r\nExamples follow:\r\n```PowerShell\r\nPS> \"`u{29E3D}\"\r\n\ud867\ude3d\r\nPS> \"`u{1F600}\"\r\n\ud83d\ude03\r\n```\r\n\r\nThen it is cannot cast string to char type.\r\n```PowerShell\r\n# Normal Kanji.\r\nPS> [char]\"`u{4E00}\"\r\n\u4e00\r\n# Surrogate pairs character.\r\nPS> [char]\"`u{29e3d}\"\r\nInvalidArgument: Cannot convert value \"\ud867\ude3d\" to type \"System.Char\". Error: \"String must be exactly one character long.\"\r\n\ud83d\ude03\r\nPS> [char]\"`u{1F600}\"\r\nInvalidArgument: Cannot convert value \"\ud83d\ude00\" to type \"System.Char\". Error: \"String must be exactly one character long.\"\r\n\r\n```\r\nPlease look at the page [Character encoding in .NET](https://docs.microsoft.com/en-us/dotnet/standard/base-types/character-encoding-introduction)\r\n\r\nTo excerpt from the page.\r\n> However, for some languages and for some symbols and emoji, it takes two char instances to represent a single character. \r\n\r\nFor that reason, I think that the range operator can only be using characters which can be cast to char type. But I think surrogate pairs characters should also be supported at the context of semantics.\r\n\r\nSorry for my bad english.\r\n\r\n\n\n### Expected behavior\n\n```console\nPS> \"\u4e00\"..\"\u4e00\"\r\n\u4e00\r\nPS> \"`u{4E00}\"..\"`u{4E00}\"\r\n\u4e00\r\nPS> \"\ud867\ude3d\"..\"\ud867\ude3d\"\r\n\ud867\ude3d\r\nPS> \"`u{29e3d}\"..\"`u{29e3d}\"\r\n\ud867\ude3d\n```\n\n\n### Actual behavior\n\n```console\nPS> \"\u4e00\"..\"\u4e00\"\r\n\u4e00\r\nPS> \"`u{4E00}\"..\"`u{4E00}\"\r\n\u4e00\r\nPS> \"\ud867\ude3d\"..\"\ud867\ude3d\"\r\nOperationStopped: Input string was not in a correct format.\r\nPS> \"`u{29e3d}\"..\"`u{29e3d}\"\r\nOperationStopped: Input string was not in a correct format.\n```\n\n\n### Error details\n\n```console\nPS> Get-Error\r\nException             :\r\n    Type       : System.FormatException\r\n    TargetSite :\r\n        Name          : ThrowOverflowOrFormatException\r\n        DeclaringType : System.Number, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e\r\n        MemberType    : Method\r\n        Module        : System.Private.CoreLib.dll\r\n    Message    : Input string was not in a correct format.\r\n    Data       : System.Collections.ListDictionaryInternal\r\n    Source     : System.Private.CoreLib\r\n    HResult    : -2146233033\r\n    StackTrace :\r\n   at System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)\r\n   at System.String.System.IConvertible.ToInt32(IFormatProvider provider)\r\n   at System.Convert.ToInt32(Object value)\r\n   at System.Management.Automation.ParserOps.RangeOperator(Object lval, Object rval)\r\n   at System.Management.Automation.Interpreter.FuncCallInstruction`3.Run(InterpretedFrame frame)\r\n   at System.Management.Automation.Interpreter.EnterTryCatchFinallyInstruction.Run(InterpretedFrame frame)\r\nCategoryInfo          : OperationStopped: (:) [], FormatException\r\nFullyQualifiedErrorId : System.FormatException\r\nInvocationInfo        :\r\n    ScriptLineNumber : 1\r\n    OffsetInLine     : 1\r\n    HistoryId        : -1\r\n    Line             : \"`u{29e3d}\"..\"`u{29e3d}\"\r\n    PositionMessage  : At line:1 char:1\r\n                       + \"`u{29e3d}\"..\"`u{29e3d}\"\r\n                       + ~~~~~~~~~~~~~~~~~~~~~~~~\r\n    CommandOrigin    : Internal\r\nScriptStackTrace      : at <ScriptBlock>, <No file>: line 1\n```\n\n\n### Environment data\n\n```powershell\nPS> > $PSVersionTable\r\n\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.2.1\r\nPSEdition                      Core\r\nGitCommitId                    7.2.1\r\nOS                             Linux 5.13.0-28-generic #31~20.04.1-Ubuntu SMP Wed Jan 19 14:08:10 UTC 2022\r\nPlatform                       Unix\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\n```\n\n\n### Visuals\n\n_No response_",
  "closed_at": null,
  "comments": [
    {
      "author": "kasini3000",
      "author_association": "NONE",
      "body": "hex:29E3D == 171581\r\nThe .net framework can only handle characters smaller than 65535, I don't know if it has changed in .net 6 now.\r\nIf not, I am pessimistic that this problem will never be solved.\r\nkey point:\r\n\r\n```powershell\r\nPS C:\\ProgramData\\kasini3000> [char]17158\r\n\u4306\r\nPS C:\\ProgramData\\kasini3000> [char]171581\r\nInvalidArgument: Cannot convert value \"171581\" to type \"System.Char\". Error: \"Value was either too large or too small for a character.\"\r\n```",
      "created_at": "2022-02-08T08:59:59Z",
      "updated_at": "2022-02-09T08:03:21Z"
    },
    {
      "author": "JamesWTruher",
      "author_association": "MEMBER",
      "body": "I agree with @kasini3000, this seems to be a behavior with .net\r\n```\r\nPS> \"`u{29e3d}\"           \r\n\ud867\ude3d\r\nPS> [char]\"`u{29e3d}\"   \r\nInvalidArgument: Cannot convert value \"\ud867\ude3d\" to type \"System.Char\". Error: \"String must be exactly one character long.\"\r\nPS> \"`u{29e3d}\".length     \r\n2\r\n```\r\nso powershell can't necessarily turn it into a single character.",
      "created_at": "2022-03-03T22:03:18Z",
      "updated_at": "2022-03-03T22:05:21Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "WG-Engine:\r\n\r\nThere are a few ways we could potentially go about implementing this as an enhancement, all of which would likely involve use of the new(ish) System.Text.Rune type:\r\n\r\n- Change the object types returned from `\"a\"..\"z\"` and all string ranges like this from `[char]` to `[System.Text.Rune]`, and enumerate a numeric range over the rune values, return a set of values with Runes. This would be a breaking change, as it would mean usages like `[string]::new('a'..'z')` would stop working.\r\n- Introduce the above behaviour only for ranges that definitely exceed the `[char]` value range. This would avoid breakages but introduce some inconsistency in how the lower and upper ranges are handled. Also up for question would be how do we handle ranges that attempt to cross this 'barrier' range.\r\n- Do something along the lines of the above, but convert the generated runes to strings before returning them. This would be a little more compatible than the first option, a bit more consistent than the second option, but would still be a significant change from the original implementation.\r\n\r\nThere are other possible options, but we felt these represented the most likely cases. Some possible concerns raised were:\r\n\r\n- We're unsure how useful this kind of feature may end up being if the Unicode character ranges aren't as contiguous as they are for the lower values. None of us have the necessary familiarity with all the Unicode code pages, so ultimately we don't feel this is a huge concern, but nor do we think it's wise to define custom ways for the ranges to work, it would have to stick by the ordering presented by .NET for the contiguous integer values of Runes.\r\n- The formatting system currently doesn't render raw Rune values, instead it defaults to a List format view showing the Rune's properties. This is something we might want as follow up work if this feature is extended in this way. (Rendering them is fairly simple, calling .ToString() on the Runes suffices.)\r\n- The formatting system is not very well set up for rendering these kinds of characters currently, so it may be a little more likely to surface any issues there with how it's designed.\r\n\r\nUltimately, we're unsure if this is something we want to provide in this way as yet. It would be good to see if there's more community interest in this request before we commit to providing this. We're inclined to leave this issue open for discussion for a few months before we assess it again.\r\n\r\n---\r\n\r\nSince I was playing with it a bit, here's a function that provides similar behaviour that may be of interest to folks who want to play with what this might potentially end up looking like and see how it suits their use cases:\r\n\r\n```ps1\r\nfunction Get-Runes {\r\n    <#\r\n        .SYNOPSIS\r\n        Gets the range of Runes from the defined range. Usage: Get-Runes \u4e00..\u4e03\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [ValidatePattern('^.\\.\\..$', ErrorMessage = \"Invalid format for character range\")]\r\n        [string]\r\n        $Range\r\n    )\r\n\r\n    $start, $end = $Range -split '\\.\\.'\r\n    [System.Text.Rune]$startRune = $start.EnumerateRunes() | Select -First 1\r\n    [System.Text.Rune]$endRune = $end.EnumerateRunes() | Select -First 1\r\n\r\n    ($startRune.Value)..($endRune.Value) -as [System.Text.Rune[]]\r\n}\r\n```",
      "created_at": "2022-03-04T02:03:36Z",
      "updated_at": "2022-03-04T02:11:27Z"
    }
  ],
  "created_at": "2022-02-08T07:00:20Z",
  "number": 16858,
  "state": "open",
  "title": "Range operator doesn't work in surrogate pairs character",
  "updated_at": "2022-06-09T18:15:48Z"
}