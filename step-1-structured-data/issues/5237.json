{
  "_url": "https://github.com/PowerShell/PowerShell/issues/5237",
  "author": "HumanEquivalentUnit",
  "body": "I see novices posting variations of this over and over on the internet:\r\n\r\n> I have this code: `get-thing | select name` but why are there @{} in my output and how do I get rid of them? Why doesn't the output equal `-eq 'user1'` ? Why doesn't my string split/replace work on it?\r\n\r\nAnd they're too novice to understand the object pipeline well and know what it means to have an object with one property. They want the name, that looks like the way to do it, it looks like it works, but it doesn't actually do what they want.\r\n\r\nThere's lots of people tripping over this basically-useless edge-case, over and over and over on their way to learning PowerShell well.\r\n\r\nCan we come up with a way to smooth that for beginners *before* they know enough to avoid it? (i.e. putting a rule in PSScriptAnalyzer would be too late to help).\r\n\r\nIt's my suspicion that selecting one thing, `select-object -property OnePropertyHere` , is an anti-pattern, and has so few legitimate use cases that they would have to be contrived to show what it does. \r\n\r\nIdeas:\r\n\r\n - Selecting one thing should throw an exception \"you probably don't want to do that, go read a tutorial on the object pipeline\". \r\n - Selecting one thing should output a warning to the verbose stream.\r\n - `Select Name` should acted as if you specified `-ExpandProperty Name` and output a value, not an object. This would be a breaking change, but..\r\n   - Then it would be useful for people who *do* know about the object pipeline as well, who still (I speculate) have few real uses for selecting an object with one property. Where the alternatives are currently the laborious `-ExpandProperty`, the convenient but ugly `|% name` or the awkward `(  ).Name`, then simply `select-object -property name` would do what you most likely actually want it to do. (Downside, how would you then specify if you do want an object with one property?)\r\n - There should be another cmdlet for this use case which is clearly named to show that it won't output an object, because even \"select an object and expand a property so the output is not necessarily an object\" is a bit awkward when you stare at it for a while. e.g. `select-value` or `select-propertyvalue` or `get-objectproperty` or etc.\r\n\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I wonder why a beginner don't read a cmdlet description and examples.",
      "created_at": "2017-10-26T07:00:59Z",
      "updated_at": "2017-10-26T07:00:59Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "I think changing `select-object` would just move the problem you are trying to address to another cmdlet. The reason why this trips novices up is that the language is object-centric. At some point a novice is going to need to learn that. They just happen to experience it with `select-object` first because i is a common cmdletd.\r\n\r\n> It's my suspicion that selecting one thing, select-object -property OnePropertyHere , is an anti-pattern,\r\n\r\nIt's not, really. You may have an object where only one of the properties is useful. The objects generated by this may be used as seed objects where other properties are added in the pipeline. Or you may be passing an object to a command that takes more than one of your source objects' properties as a `ValueFromPipelineByPropertyName` but only one is correct in the context. or you may simpley need to create a single column CSV with a header to import into an external system (Yammer takes a few single column CSV's, for example)\r\n\r\n> Selecting one thing should throw an exception \"you probably don't want to do that, go read a tutorial on the object pipeline\".\r\n\r\nDefinitely not for the reason mentioned above.\r\n\r\n> Selecting one thing should output a warning to the verbose stream.\r\n\r\nI don't think this one is a good idea either.\r\n\r\n>`Select Name` should acted as if you specified `-ExpandProperty Name`\r\n\r\nThat would get confusing with a difference in operation between `Select-Object Porp1` and `Select-Object Prop1, Prop2`.\r\n\r\n> There should be another cmdlet for this use case\r\n\r\nI don't think it's worth adding a completely other cmdlet for this.\r\n\r\n> select an object and expand a property so the output is not necessarily an object\r\n\r\nWhere do you see that? \r\n\r\nThis is probably something that is better fixed with documentation. Perhaps adding an example of this as  common gotcha would be a good start. The `Export-Csv` cmdlet has an example of avoiding the mangling of objects caused by passing objects to `Format-Table` first. i suspect any \"fix\" done in `Select-Object` would just push that initial exposure to objects on to another cmdlet.",
      "created_at": "2017-10-26T09:01:23Z",
      "updated_at": "2017-10-26T09:01:23Z"
    },
    {
      "author": "RichardSiddaway",
      "author_association": "NONE",
      "body": "I can think of a number of reasons for selecting a single property that are extremely valid and don't see any reason to change the current behaviour of select-object\r\n",
      "created_at": "2017-10-26T15:55:34Z",
      "updated_at": "2017-10-26T15:55:34Z"
    },
    {
      "author": "HumanEquivalentUnit",
      "author_association": "CONTRIBUTOR",
      "body": "@RichardSiddaway I cite [your own blog post](https://richardspowershellblog.wordpress.com/2015/12/23/objects-properties-and-values/) where you say \"*One thing that seems to keep causing confusion is using Select-Object to pick off one or more properties from a set of objects*\", and you blog that it \"keeps\" causing confusion *9 years* after you started blogging about PowerShell.\r\n\r\nYou don't see any reason to try and do anything to improve it?\r\n",
      "created_at": "2017-10-26T18:03:03Z",
      "updated_at": "2017-10-26T18:03:03Z"
    },
    {
      "author": "RichardSiddaway",
      "author_association": "NONE",
      "body": "It's not a problem that technology can fix. Its an education problem. I've seen many people jump into using PowerShell, and other technologies, and make assumptions about how they work or just don't bother to discover how they work. This is where many of the problem you cite come from.\r\n\r\nChanging the behaviour of select-object in the way you advocate isn't going to solve those problems as you'll just be moving the problem area to another cmdlet - probably one of more of  sort-object, where-object or foreach-object",
      "created_at": "2017-10-26T18:10:40Z",
      "updated_at": "2017-10-26T18:10:40Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Is our docs well or we need add anything in the cmdlet help to address the Issue?",
      "created_at": "2017-10-26T18:23:14Z",
      "updated_at": "2017-10-26T18:23:14Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov The docs could be improved with an example to calls out the common gotcha. ",
      "created_at": "2017-10-26T18:26:38Z",
      "updated_at": "2017-10-26T18:26:38Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "I can see adding a rule to ScriptAnalyzer, but I'm not sure the behavior should be changed.\r\n\r\nI will say most places I see this pattern, it is not necessary.\r\n\r\nConsistency is important here. For example, if the properties are dynamically selected, selecting one or more properties shouldn't cause weird problems downstream.",
      "created_at": "2017-10-26T18:28:51Z",
      "updated_at": "2017-10-26T18:28:51Z"
    },
    {
      "author": "HumanEquivalentUnit",
      "author_association": "CONTRIBUTOR",
      "body": "@markekraus \"where do you see that?\" - imagine you want to write lines of text to a plain text file, and the accepted way was to use `Export-Csv` but tag on the parameter `-ExpandProperty` to tell it not to write a CSV. Is that something you'd expect to be within `Export-Csv`'s remit? Would you be looking there for that feature, or think that was an odd place to put it? With that comparison, would you say `Select-Object` with a parameter is the best place to select non-PSObject output?",
      "created_at": "2017-10-26T19:00:38Z",
      "updated_at": "2017-10-26T19:00:38Z"
    },
    {
      "author": "HumanEquivalentUnit",
      "author_association": "CONTRIBUTOR",
      "body": "I'll note that the question in the title was really \"Can that experience be improved for beginners?\" instead of just \"change select-object yes/no\". The consideration of dynamic (wildcard) property selection is another convincing dealbreaker against that.\r\n\r\n@lzybkr  \"I will say most places I see this pattern, it is not necessary.\" - most places you see ExpandProperty it is not necessary, or most places you see selecting one property is not necessary?\r\n\r\nAs another idea for an approach, what if the default output formatter included a line of type information, or other type marker in the output? So when you do `Get-ChildItem c:\\path | select-object name` and see a screen full of names, and the header scrolled off, there's still some indication that you have not-text. If the type matters and you need to know it - can it be made visible?\r\n\r\nStackOverflow has ~400 comments relating to '%expandproperty%' and picking some to see either code suggestions to use ExpandProperty, or people giving thanks for suggesting it, e.g.\r\n\r\n```\r\nPostId\tText\r\n42003324\tThanks, included -expandproperty\r\n36187162\t`|Select -ExpandProperty HomeDrivePath`\r\n44873829\t`Select-Object -ExpandProperty UserName`\r\n36658641\tI always forget about `-ExpandProperty`!\r\n45428798\t`| select -ExpandProperty SAMAccountName |`\r\n17870097\tThank-you the, -ExpandProperty Node, did it :)\r\n42003324\tor select -expandproperty to just get the value\r\n29017197\tThank you for that. `-ExpandProperty`...who knew.\r\n33171965\t@DaveSexton `Select  -ExpandProperty Measurements`\r\n39231089\tTry `select-object -ExpandProperty DisplayVersion`\r\n38185398\tGet-AzureRmLocation | Select -ExpandProperty Location\r\n27942669\tNice. Didn't know about expandProperty. Thanks Duncan.\r\n33017054\tShould not it be `Select-Object -ExpandProperty Index`?\r\n33507224\tI think it should be select count -ExpandProperty Count.\r\n40345578\t`Select-Object mail` ? `Select-Object -ExpandProperty mail`\r\n6375323\tYou're just emulating a `select -expandproperty size` there.\r\n38338320\ttry changing that last part to `select -expandproperty ipaddress`\r\n23139592\tSee my edit and tell me if -ExpandProperty shows the entire value.\r\n25261455\tcheers, both options worked. I'll go and read up on -expandproperty\r\n21394652\tAlternatively you could do `Select-Object -ExpandProperty identity`.\r\n14139818\tThanks @Kayasax, was spot on !! ( I didn't knew about ExpandProperty)\r\n30718643\tThanks!  `Select-Object -ExpandProperty FullName`  is working for me.\r\n39268354\tUse `Select-Object -ExpandProperty` instead of `Select-Object -Property`\r\n18145840\tI used -ExpandProperty name to get exactly value named \"Administratoren\".\r\n29973404\tChange `select SAMAccountName` to `select -ExpandProperty SAMAccountName`\r\n43764032\tWhat if you change Select-Object Name to Select-Object -ExpandProperty Name\r\n25395736\tAlso: `measure-command { ... } | select-object -expandproperty TotalSeconds`\r\n29067832\tHave you tried `Select -ExpandProperty Servername` instead of `Format-Table`?\r\n40331593\tHi, try `$listoflogs = Get-EventLog -List | Select-Object -ExpandProperty Log`.\r\n25566906\tDo it work with Select-Object -ExpandProperty instead of Select-Object -Property?\r\n33021473\tAh I thought its good for storing as well. Thank you!  -ExpandProperty works good.\r\n17581252\tThanks @jbsmith! The `-ExpandProperty` parameter to `Select-Object` did the trick.\r\n[etc.]\r\n```\r\n\r\nand imagining that's the forever-future as one by one, people fall into that trap and have to be helped past it. \r\n\r\nHelp.\r\nUse `-expandproperty`\r\nThanks.\r\n\r\nHelp.\r\nUse `-expandproperty`\r\nThanks.\r\n\r\nHelp.\r\nUse `-expandproperty`\r\nThanks.\r\n\r\nHelp.\r\nUse `-expandproperty`\r\nThanks.\r\n\r\nIn a world where that is not happening anymore, and Select-Object is not broken, what else could have changed to smooth over that annoyance? \r\n",
      "created_at": "2017-10-26T19:14:28Z",
      "updated_at": "2017-10-26T19:15:34Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "> What else could have changed to smooth over that annoyance?\r\n\r\nForced education camps, maybe? /s\r\n\r\nI mean.. this is more about a fundamental difference between PowerShell and other languages and just about every novice (even those experienced in other languages, maybe even especially so) is going to run into this. It's like `return` and \"leaky\" functions. These are core paradigm differences about the language that can only be learned about either by actually studying the language before coding it, or through trial and error. \r\n\r\nDocumentation may help, but only if users read it. A warning would be annoying for a non-novice who knows what they're doing. PSScriptAnalyzer rule would be nice.... if a novice knew about those, they probably already know better.",
      "created_at": "2017-10-26T19:29:18Z",
      "updated_at": "2017-10-26T19:29:18Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "@HumanEquivalentUnit - most uses of `Select-Object` actually - with or without `-ExpandProperty`, with one or more property names. But my experience could be highly skewed, so fee free to ignore if you think I'm way off. ;)",
      "created_at": "2017-10-26T20:31:32Z",
      "updated_at": "2017-10-26T20:31:32Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": ":-) Looking on StackOverflow has ~400 comments \"I didn't knew about ExpandProperty\" I think we must install PowerShell in \"Beginner Mode\" with only available Get-Help cmdlet and unlock rest cmdlets only after the beginner pass an exam for 1000 points.\r\n\r\n",
      "created_at": "2017-10-27T03:53:52Z",
      "updated_at": "2017-10-27T03:53:52Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov Like a tutorial level in games.\r\n\r\nThough, on a more serious note... Maybe if `pwsh` had a `-Tutorial` switch with a guided REPL that would maybe help.",
      "created_at": "2017-10-27T08:47:11Z",
      "updated_at": "2017-10-27T08:47:11Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "`powershell /?` already show the link `PowerShell Online Help https://aka.ms/pscore6-docs`.",
      "created_at": "2017-10-27T09:02:15Z",
      "updated_at": "2017-10-27T09:02:35Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov Yup. but there is a massive difference between static documentation and an interactive tutorial. There was something similar with learnpython.com and I cen't remember the name but there was one you could run right from the command line. This is more \"food for thought\" than a serious suggestion.",
      "created_at": "2017-10-27T09:25:35Z",
      "updated_at": "2017-10-27T09:25:35Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I think you should open new Issue for the good suggestion. ",
      "created_at": "2017-10-27T09:37:28Z",
      "updated_at": "2017-10-27T09:37:28Z"
    },
    {
      "author": "HumanEquivalentUnit",
      "author_association": "CONTRIBUTOR",
      "body": "> I mean.. this is more about a fundamental difference between PowerShell and other languages and just about every novice [..] is going to run into this.\r\n\r\nJust about everyone, huh? Can some insightful enough change make it a ramp to run up, instead of a wall to run into?\r\n\r\nHave you heard the meme that \"Vi/Vim is impossible for novices to quit\" ? Did that go away because `vimtutor` exists? Not to say documentation and tutors are a bad idea, but - what is it that's leading people to think that the text or number they see is exactly what they have? Or making it so that people don't find their way to `-ExpandProperty` during the process of typing and using, rather than having to turn to a reference?\r\n\r\nWith PSReadLine and the changes to conhost , is there any way the default output formatting could change color or style (underline?) to distinguish between when the text you see is representing PSObjects/complex objects vs strings/value types ?\r\n\r\nI don't think this is quite the right problem for documentation - it's one thing to say \"I need to login, let me look for a cmdlet option relating to authentication\", but if you don't know that you need just one property of an object, you won't go looking for anything like that in the documentation, and if you read past it, you won't recognise the terminology to know that was describing the solution to your problem.\r\n\r\n> I think we must install PowerShell in \"Beginner Mode\" with only available Get-Help cmdlet and unlock rest cmdlets only after the beginner pass an exam for 1000 points.\r\n\r\nAre you trying to make it Oracle PowerShell now? \ud83d\ude06 Unlock the PowerShell 2 engine for free, PowerShell 5.1 by entering your $10k certification exam code. Cmdlets, $100/month/10 cmdlets, objects in the pipeline, $10/property, $15/method...\r\n",
      "created_at": "2017-10-27T16:32:56Z",
      "updated_at": "2017-10-27T16:34:40Z"
    },
    {
      "author": "RichardSiddaway",
      "author_association": "NONE",
      "body": "At what point do you propose we stop trying to make things as simple as possible for new users. Any technology has a learning curve. This is one step on the PowerShell learning curve",
      "created_at": "2017-10-27T18:28:39Z",
      "updated_at": "2017-10-27T18:28:39Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@HumanEquivalentUnit I will reiterate: if you make this easier on `Select-Object` you will just be passing the buck on to another cmdlet. This isn't about `Select-Object` but about a fundamental paradigm of PowerShell that needs to be learned one way or another. `Select-Object` is just the first place many users encounter the need to learn this paradigm. This is something that should be addressed with documentation and possibly a tutorial as any technical solution will likely lead to a slippery slope of cascading requests to make changes to the language until this paradigm is either lost or buried and the language no longer PowerShell.",
      "created_at": "2017-10-27T18:45:37Z",
      "updated_at": "2017-10-27T18:45:37Z"
    },
    {
      "author": "HumanEquivalentUnit",
      "author_association": "CONTRIBUTOR",
      "body": "@markekraus I agree it's a fundamental paradigm change, I disagree about the passing-the-buck or the panic of losing the core of the language. The point is not to hide the paradigm in select-object and pretend it doesn't exist, pushing the discovery elsewhere, so that people ignore it for longer and run into the exact same problem somewhere else. The point of any change would be to reveal the paradigm earlier, to make it so that the paradigm couldn't be ignored that long at all, to always have it visible, to have interactive lead-in clues to the paradigm and to where to look and what to do, helping people learn rather than not helping. e.g. people who convert to string end up posting messages like `why do I have @{name='file.txt'} and how do I get rid of the weird characters?`, but people who look at the output in other ways and it looks like text *don't even know they have a problem that reading the documentation would help with*.\r\n\r\nLike, how this GitHub reply window supports MarkDown formatting, but it has WYSIWYG controls and a preview tab, but Reddit posts support MarkDown formatting, has no indication that it does, and people continually can't format code, and apologise for not knowing how. \r\n\r\nThat doesn't mean people no longer have to learn about MarkDown, or that it's too-simple, it means the interface is helpful rather than hidden. Even if you know nothing about it, you can see the buttons are there always on screen as a very big hint that it's not just a plain textbox.\r\n\r\n@RichardSiddaway .. at the point where new users aren't suffering in ways that can be ameliorated? At the point where everyone on the planet uses PowerShell so there are no new users? When nobody on the planet has any new suggestions for possible improvements?  When there are no remaining humans with enough interest to discuss any ideas? Why would you assume the time to stop is \"roughly now\" instead of \"in twenty or fifty years\"? I mean, I understand that resources are always limited, but this is open source, anybody could contribute more resources if they wanted to. I'm a bit surprised that nobody has seen my point of view in this thread, and if this thread gets closed as \"no interest\", well I guess that's .. fine. But I wouldn't use that as any indication to say \"everyone, stop proposing ideas to make things simpler, it's all done and dusted now and forever\". Why limit that?\r\n",
      "created_at": "2017-10-27T20:56:45Z",
      "updated_at": "2017-10-27T21:00:38Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "I wonder if would be useful to have a mechanism that displays tips for interactive users kind of like PSSA supplies tips for scripters.  Well, except that interactive use analysis would be forgiving of using aliases and other wrist-saving techniques.  \r\n\r\nPerhaps this is something that could be prototyped as a PSReadline function and bound to a keyboard shortcut.  Press <kbd>Ctrl+i</kbd> to invoke a function that analyzes the current command and provides tips.  That could be interesting.",
      "created_at": "2017-10-27T21:22:51Z",
      "updated_at": "2017-10-27T21:22:51Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "Interactive suggestions are easy to extend in the console host - start [here](https://github.com/PowerShell/PowerShell/blob/14af3e12972873676f76b2a456a86c1bf33749b9/src/System.Management.Automation/engine/hostifaces/HostUtilities.cs#L335)",
      "created_at": "2017-10-27T21:27:06Z",
      "updated_at": "2017-10-27T21:27:06Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@HumanEquivalentUnit \r\n>  The point of any change would be to reveal the paradigm earlier, to make it so that the paradigm couldn't be ignored that long at all, \r\n\r\nAnd you and I are not disagreeing there. But the question is how? Because, changing `select-object` is pretty much a waste of effort, because (as I am repeating myself) it will just move the problem elsewhere not address the root cause. But you mocked our attempts at brainstorming an interactive solution. So, what is your solution, if any, when a change to `select-object` is off the table? ",
      "created_at": "2017-10-27T21:32:03Z",
      "updated_at": "2017-10-27T21:34:26Z"
    },
    {
      "author": "ScriptAutomate",
      "author_association": "CONTRIBUTOR",
      "body": "@HumanEquivalentUnit \r\n\r\nIt sounds like this issue thread is an extension of these:\r\n- Why does `Export-CSV` return `System.Object` in my spreadsheets?\r\n- Why does using `Export-CSV` after `Format-Table` in a pipeline mess all the output up?\r\n- Why doesn't `get-process | select 'CPU(s)'` show anything?\r\n- How come `\"Found process: $Process\"` outputs `Found process: System.Diagnostics.Process ((sd-pam))` ???\r\n- What's the point of `Get-Member`? Properties and Methods? Wha?\r\n- What is `measure` actually counting?\r\n- What is the pipeline even doing in PowerShell?\r\n\r\nIn the end, absolutely all of these questions are about **objects and how they are being handled in PowerShell**, and how it is not just text output manipulation. You can't answer any of these without bringing the _object_ into play in an explanation. Even a `String` is an object in PowerShell! As has been explained in this thread, _the issue is in understanding objects_. Look at the cmdlet name of `Select-Object` -- it has `Object` in the name!\r\n\r\nYou've also rephrased your question for the most part when you said:\r\n\r\n> If the type matters and you need to know it - can it be made visible?\r\n\r\n`Get-Member` would need to be used. PowerShell gives the best default output it can based on what it believes needs to be presented as value. _\"If...you need to know it\"_ is a relative/subjective statement in this case. `Select-Object` isn't the _problem_ of what you see on StackOverflow, it is often part of the _solution_ in their use cases by helping them drill down into the values they are looking for in that specific situation. Those specific objects, perhaps, could be debated on how the default formatted output is shown?\r\n\r\nRunning `help about_Format.ps1xml` will explain a lot about how default formatting to the console is happening as it is, and how it can be customized.\r\n\r\n`Get-Process` default console output throws many people off when first starting out with PowerShell. It's not `Select-Object` that needs to be fixed right?\r\n\r\nIf the issue has to do with _nested objects_ and how they are displayed, the reason they are displayed as they are is based on default values that should be shown -- not the type. An quick example that may not look complex at first is simply:\r\n```\r\nPS > $PSVersionTable\r\n\r\nName                           Value                                                                                                                                                                               \r\n----                           -----                                                                                                                                                                               \r\nPSVersion                      6.0.0-beta.9                                                                                                                                                                        \r\nPSEdition                      Core                                                                                                                                                                                \r\nGitCommitId                    v6.0.0-beta.9                                                                                                                                                                       \r\nOS                             Linux 4.10.0-38-generic #42~16.04.1-Ubuntu SMP Tue Oct 10 16:32:20 UTC 2017                                                                                                         \r\nPlatform                       Unix                                                                                                                                                                                \r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}                                                                                                                                                             \r\nPSRemotingProtocolVersion      2.3                                                                                                                                                                                 \r\nSerializationVersion           1.1.0.1                                                                                                                                                                             \r\nWSManStackVersion              3.0\r\n```\r\nWhich is just a hashtable of multiple objects that differ when it comes to object types. We see summarized _values_. `PSCompatibleVersions` is a list of `System.Version` object types, displayed in a summarized/truncated fashion. The objects themselves look entirely different in output when called directly:\r\n```\r\nPS > $PSVersionTable.PSCompatibleVersions                                                                                                                                                            \r\n\r\nMajor  Minor  Build  Revision\r\n-----  -----  -----  --------\r\n1      0      -1     -1      \r\n2      0      -1     -1      \r\n3      0      -1     -1      \r\n4      0      -1     -1      \r\n5      0      -1     -1      \r\n5      1      10032  0       \r\n6      0      0      -1\r\n```\r\n\r\nEven in this case, the console is showing a reduced list of properties:\r\n\r\n```\r\nPS > $PSVersionTable.PSCompatibleVersions | select -First 1                                                                                                                                          \r\n\r\nMajor  Minor  Build  Revision\r\n-----  -----  -----  --------\r\n1      0      -1     -1\r\n\r\nPS > $PSVersionTable.PSCompatibleVersions | select -First 1 | Get-Member                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        TypeName: System.Version                                                                                                                                                                                                                                                                                                                                                                                                             \r\nName          MemberType Definition                                                                                                                                                         \r\n----          ---------- ----------                                                                                                                                                         \r\nClone         Method     System.Object Clone(), System.Object ICloneable.Clone()                                                                                                            \r\nCompareTo     Method     int CompareTo(System.Object version), int CompareTo(version value), int IComparable.CompareTo(System.Object obj), int IComparable[version].CompareTo(version other)\r\nEquals        Method     bool Equals(System.Object obj), bool Equals(version obj), bool IEquatable[version].Equals(version other)                                                           \r\nGetHashCode   Method     int GetHashCode()                                                                                                                                                  \r\nGetType       Method     type GetType()                                                                                                                                                     \r\nToString      Method     string ToString(), string ToString(int fieldCount)                                                                                                                 \r\nBuild         Property   int Build {get;}                                                                                                                                                   \r\nMajor         Property   int Major {get;}                                                                                                                                                   \r\nMajorRevision Property   int16 MajorRevision {get;}                                                                                                                                         \r\nMinor         Property   int Minor {get;}                                                                                                                                                   \r\nMinorRevision Property   int16 MinorRevision {get;}                                                                                                                                         \r\nRevision      Property   int Revision {get;}\r\n\r\nPS > $PSVersionTable.PSCompatibleVersions | select -First 1 | select *                                                                                                                                                 \r\n\r\n\r\nMajor         : 1\r\nMinor         : 0\r\nBuild         : -1\r\nRevision      : -1\r\nMajorRevision : -1\r\nMinorRevision : -1\r\n```\r\n\r\nThe solution to _\"wait, there's more, I'm not just a string, int32, or double and I even have properties that don't output to console by default...\"_ would be learning the value of `Get-Member` to learn more. `$PSVersionTable` is a mixed bag of stuff when it comes to types:\r\n\r\n```\r\n$PSVersionTable.values | get-member | select TypeName -Unique                                                                                                                                   \r\n\r\nTypeName                                    \r\n--------                                    \r\nSystem.Management.Automation.SemanticVersion\r\nSystem.String                               \r\nSystem.Version[]                            \r\nSystem.Version\r\n```\r\n\r\nThere are [video courses](https://mva.microsoft.com/search/SearchResults.aspx#!q=powershell&lang=1033), [technical books](https://www.amazon.com/Learn-Windows-PowerShell-Month-Lunches), [docs/learning-powershell in this same repository](https://github.com/PowerShell/PowerShell/blob/master/docs/learning-powershell/working-with-powershell-objects.md), [interactive free on-demand virtual labs](https://vlabs.holsystems.com/vlabs/technet?eng=VLabs&auth=none&src=vlabs&altadd=true&labid=20434&lod=true), and other places that explain (how objects work in) PowerShell.\r\n\r\n[The Monad Manifesto](http://www.jsnover.com/Docs/MonadManifesto.pdf) explains the reasoning behind why PowerShell isn't just another shell with a text manipulation pipeline. \r\n\r\n@markekraus If there were a hypothetical interactive tutorial for the local console, wouldn't it be better for someone to make a PowerShell Module as opposed to a modification/add to PowerShell itself as a feature? Otherwise, you just pushed a tutorial to systems where people aren't even going to need it. `Update-Help` exists to avoid carrying the help documentation everywhere by default, too, and makes it so that PowerShell itself doesn't need to update when help documentation is updated for a single module.\r\n\r\nShould this issue be closed?",
      "created_at": "2017-11-04T10:54:47Z",
      "updated_at": "2017-11-04T10:54:47Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "> If there were a hypothetical interactive tutorial for the local console, wouldn't it be better for someone to make a PowerShell Module as opposed to a modification/add to PowerShell itself as a feature? \r\n\r\nThat is where I would start, but, there is some merit in it being a native part of the system. The problem is that someone new to the language who just runs `pwsh` in their console for the first time probably has no clue what modules are or how to install them (and even as a veteran user, I have to say that PowerShellGallery is not the most user friendly tool once you know about it). They have several hurdles of knowledge and acclamation to jump first. If the underlying goal of @HumanEquivalentUnit's request was to make this easier for the novice user, then including an interactive tutorial with PowerShell and not apart from it makes perfect sense. \r\n\r\nThe part about the tutorial being forced was only a jest. @iSazonov recently had #5275 merged which adds a small banner on how to get help. That banner could just be expanded slightly to include something like `or 'Start-Tuorial' for an interactive tutorial.` The interactive tutorial could very well be a separate module and only loaded when called. It could even be just a stub that begins by walking the user through installing the actual tutorial module from the the gallery, that way the initial footprint could be small.\r\n\r\nIn any case, this is all just brain storming.\r\n\r\n> Should this issue be closed?\r\n\r\nI have changed the label to be a discussion. I'll leave this open for a few more days to see if there is any more feed back and then close it. The consensus appears to be that `select-object` shouldn't be changed, but the discussion as started to hit at solutions for the root cause.",
      "created_at": "2017-11-04T12:05:51Z",
      "updated_at": "2017-11-04T12:07:54Z"
    },
    {
      "author": "ScriptAutomate",
      "author_association": "CONTRIBUTOR",
      "body": "@markekraus @HumanEquivalentUnit Okay, cool. That makes sense, and you're both right that the guidance for a newbie would be great. Would have been helpful for most others when we were starting out.\r\n\r\nI noticed the new small banner for help by that @iSazonov merged, which looks great. Reminds me of ipython's initial banner:\r\n```\r\nPython 3.6.2 (default, Sep 10 2017, 19:48:49) \r\nType 'copyright', 'credits' or 'license' for more information\r\nIPython 6.2.1 -- An enhanced Interactive Python. Type '?' for help.\r\n\r\nIn [1]: \r\n```\r\nI like the idea of it being a stub for installing the tutorial, perhaps walking the user through basic commands and diving into them as objects via the pipeline. The idea sort of reminds me of the `Start-Demo` module (or the modified version `StartDemo`), if perhaps there was a default demo maybe. I haven't tested that module out in a good while -- and I'm not sure if it needs any modification for Core, but it may be a starting point.",
      "created_at": "2017-11-21T18:37:49Z",
      "updated_at": "2017-11-21T18:41:07Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "I like the idea of `Start-Tutorial` (perhaps a community driven module...), although not keen on having it in the core package.  Would prefer we add the feature https://github.com/PowerShell/PowerShell/issues/5523 so perhaps the first time they run `pwsh`, we can suggest they try `Start-Tutorial` if this is their first time.",
      "created_at": "2017-11-22T00:10:47Z",
      "updated_at": "2017-11-22T00:10:47Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "We should probably note somewhere (select-object docs?) that if you just want to get the value of a single property, you should do\r\n`ls | foreach name`\r\ninstead of\r\n`ls | select name`",
      "created_at": "2018-03-09T20:47:07Z",
      "updated_at": "2018-03-09T20:47:07Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@BrucePay you should probably submit a PR to fix `Select-Object` [doc](https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Utility/Select-Object.md) which is where people might see this",
      "created_at": "2018-03-12T19:54:39Z",
      "updated_at": "2018-03-12T19:54:39Z"
    },
    {
      "author": "Pxtl",
      "author_association": "NONE",
      "body": "A programming language should make the easy things simple.  In this problem, the most common use-case has been made complicated, creating a jagged edge for developers - one that experienced developers are familiar with working around, but trips up newbies.  In C#, the default use of \"select\" is to work like \"expandproperty\" and the Powershell approach of creating a hashtable is \"select new {}\", and this is much more sensible.\r\n\r\n\"foreach\" works, as @BrucePay mentioned, but it's quite counterintuitive to use \"foreach\" that way.\r\n\r\nBasically, this is a language-design failure that is unfortunately going to live forever because of backwards compatibility.  The only real way out would be to introduce a new commandlet or alias with an intuitive name.",
      "created_at": "2021-10-21T15:21:36Z",
      "updated_at": "2021-10-21T15:21:36Z"
    }
  ],
  "created_at": "2017-10-25T20:49:50Z",
  "labels": [
    "Issue-Discussion"
  ],
  "number": 5237,
  "state": "open",
  "title": "Request / Discussion: Select-Object with one property causes many problems for beginners and has few legitimate use cases for anyone. Can that experience be improved for beginners?",
  "updated_at": "2021-10-21T15:21:36Z"
}