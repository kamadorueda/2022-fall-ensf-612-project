{
  "_url": "https://github.com/PowerShell/PowerShell/issues/16001",
  "author": "mklement0",
  "body": "### Prerequisites\r\n\r\n- [X] Write a descriptive title.\r\n- [X] Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\r\n- [X] Search the existing issues.\r\n- [X] Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\r\n- [X] Refer to [Differences between Windows PowerShell 5.1 and PowerShell](https://docs.microsoft.com/powershell/scripting/whats-new/differences-from-windows-powershell).\r\n\r\n### Steps to reproduce\r\n\r\nNote: There may be a technical limitation that necessitates this behavior, but it's not clear to me what it is, and the behavior is surprising. If this asymmetry cannot be helped, it should be documented.\r\n\r\n_Locally_, `Start-Process` can be used to launch a process that lives on _independently of the calling session._. That is, exiting the caller's session does not affect the launched process.\r\n\r\nIn _remote_ invocations, a `Start-Process`-launched process is automatically terminated when the remote session ends.\r\n\r\nOn Windows, from an elevated  session on a machine set up for remoting (`Enable-PSRemoting -Force` having been run from an elevated session), run the following (make sure that no Notepad instances are running):\r\n\r\n```\r\nInvoke-Command -ComputerName . -ConfigurationName \"PowerShell.$($psversiontable.PSVersion)\"  { Start-Process Notepad }\r\nStart-Sleep 2\r\nGet-Process Notepad\r\n```\r\n\r\n\r\n### Expected behavior\r\n\r\nInformation about the Notepad process launched via \"loopback remoting\" should print.\r\n\r\n\r\n### Actual behavior\r\n\r\nAn error occurs, because exiting the remote session automatically terminated the Notepad process.\r\n\r\n\r\n### Error details\r\n\r\n_No response_\r\n\r\n### Environment data\r\n\r\n```powershell\r\nPowerShell Core 7.2.0-preview.9\r\n```\r\n\r\n\r\n### Visuals\r\n\r\n_No response_",
  "closed_at": "2021-08-26T15:43:18Z",
  "comments": [
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "This is due to the WSMan session or SSH process spawned being done so in what is called a [Windows Job](https://docs.microsoft.com/en-us/windows/win32/procthread/job-objects). If I was to open a new remote session and start a process you can see the job object contains the pwsh process (`wsmprovhost.exe`) and the children that it has started:\r\n\r\n![image](https://user-images.githubusercontent.com/8462645/130894979-7bfbe10b-cee4-44e0-8cc8-6d56efce7c64.png)\r\n\r\nThe thing also applies to SSH, albeit with a slightly different process tree due to how the remoting subsystem actually works.\r\n\r\n![image](https://user-images.githubusercontent.com/8462645/130895167-9a34e31b-8164-4d76-8987-893492215f0c.png)\r\n\r\nThis behaviour is controlled by the daemons outside of PowerShell's control and while there are ways to escape the job it's not something you should be doing normally. Typically jobs are used to contain what a process can do which is important for network logons as you don't want to use up all the resources of a host through a network interface. The same thing also applies to just plain ssh connections even on Unix so this behaviour isn't a Windows specific thing.\r\n\r\nTo escape the job on Windows you have different methods available to you\r\n\r\n* Create the process with [CreateProcess](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw) and `CREATE_BREAKAWAY_FROM_JOB`\r\n  * You need PInvoke for this as the process creation flags aren't exposed in .NET\r\n  * This won't work for WSMan connection as it doesn't allow `JOB_OBJECT_LIMIT_BREAKAWAY_OK` on the job - SSH does though\r\n  * Because of the 2 points above I wouldn't recommend it\r\n* Use WMI/CIM with [Win32_Process.Create](https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/create-method-in-class-win32-process)\r\n  * WMI is special in that it spawns the process under the WMI service and thus it is not in the same job as the caller\r\n  * This means it will outlive the connection\r\n  * The downside is there is nothing to monitor that process and you can easily start having zombie processes if you aren't careful\r\n* Create a scheduled task/job\r\n  * These are managed by the task scheduler with all the advantages and disadvantages they bring\r\n\r\nThe WMI route is definitely the simplest to achieve so usually that's my first port of call unless I need something a bit more robust\r\n\r\n```powershell\r\n$processCreateParams = @{\r\n    ClassName = \"Win32_Process\"\r\n    MethodName = \"Create\"\r\n    Arguments = @{\r\n        CommandLine = 'notepad.exe'\r\n    }\r\n}\r\n$procInfo = Invoke-CimMethod @processCreateParams\r\nif ($procInfo.ReturnValue -ne 0) {\r\n    $msg = switch($procInfo.ReturnValue) {\r\n        2 { \"Access denied\" }\r\n        3 { \"Insufficient privilege\" }\r\n        8 { \"Unknown failure\" }\r\n        9 { \"Path not found\" }\r\n        21 { \"Invalid parameter\" }\r\n        default { \"Other\" }\r\n    }\r\n    Write-Error -Message \"Failed to start process: $($procInfo.ReturnValue) ($msg)\"\r\n}\r\n\r\n# This is subject to race conditions so be careful if the process ends before this is run\r\n$proc = Get-Process -Id $procInfo.ProcessId\r\n```",
      "created_at": "2021-08-26T03:35:43Z",
      "updated_at": "2021-08-26T03:38:45Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I agree it is for PowerShell-Docs.",
      "created_at": "2021-08-26T03:41:42Z",
      "updated_at": "2021-08-26T03:41:42Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for the great analysis, @jborean93. I've created https://github.com/MicrosoftDocs/PowerShell-Docs/issues/8020 and I'm closing this.\r\n\r\nIt would be good to have a workaround for Unix-like platforms too:\r\n\r\nFor non-GUI applications:\r\n\r\nAll I was able to come up with is this awkwardness, using a `pwsh` CLI call as an example:\r\n\r\n```powershell\r\nStart-ThreadJob { nohup pwsh -nop -c '1..30 | % { Add-Content -NoNewLine /tmp/t.txt -value .; sleep 1 }; Add-Content /tmp/t.txt -Value done' }\r\n```\r\n\r\nNote:\r\n* `Start-Job` does _not_ work (presumably because when the job ends, all the processes it spawned are terminated); as an aside: while testing, I've run into #16004\r\n* Oddly, `nohup` doesn't create its `nohup.out` file where it normally and unconditionally collects to-terminal output in this case.\r\n\r\nFor GUI applications (an exotic scenario, for sure):\r\n\r\n* On Ubuntu, invoking GUI applications from a remote session doesn't seem to work at all; trying to launch `gedit` prints the following:\r\n\r\n```none\r\nUnable to init server: Could not connect: Connection refused\r\n(gedit:5694): Gtk-WARNING **: 11:31:02.563: cannot open display:\r\n```\r\n\r\n* On macOS, you can simply use `open -a <appName>` (e.g, `open -a Reminders`), which makes the process not only survive exiting the remoting session, but shows up on the logged-in user's desktop. (Haven't tried when no one is logged on.)\r\n\r\n",
      "created_at": "2021-08-26T15:43:18Z",
      "updated_at": "2021-08-26T15:43:18Z"
    }
  ],
  "created_at": "2021-08-26T03:05:39Z",
  "number": 16001,
  "state": "closed",
  "title": "Remote sessions terminate Start-Process-launched processes on exit",
  "updated_at": "2021-08-26T15:43:18Z"
}