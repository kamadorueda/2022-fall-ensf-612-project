{
  "_url": "https://github.com/PowerShell/PowerShell/issues/7509",
  "author": "vexx32",
  "body": "## PR Summary\r\n\r\nImplements 'u' and 's' token case in the Tokenizer.cs and CharTraits.cs parsing which allows the use of uint or short literals as numbers with a 'u' and/or 's' suffix:\r\n```powershell\r\nPS> $Value = 108u\r\nPS> $Value.GetType().FullName\r\nSystem.UInt32\r\n\r\nPS> $Short = 105.5us\r\nPS> $Short\r\n106\r\nPS> $Short.GetType().FullName\r\nSystem.UInt16\r\n```\r\n\r\nI also tidied up some of the code in the vicinity to inline some of the very temporary variable definitions.\r\n\r\nComprehensive Summary:\r\n\r\n* Adds type suffixes for `u` and `s` - `uint` and `short`, respectively.\r\n* Adds some logic to test whether `UInt32` or `UInt64` is the appropriate return type by comparing the multiplied value against `UIUnt32.MaxValue` when neither `l` nor `s` is supplied.\r\n* Adds `[short]`, `[ushort]`, `[uint]`, and `[ulong]` type accelerators to help out people coming from C# or other languages. Mapped to `int16`, `uint16`, `uint32`, and `uint64`, respectively.\r\n* Maintains parity with existing `l` / `L` suffix, where it will also perform rounding functions when applied to a `real` literal while also ensuring it still returns an appropriate `uint` or `ulong` value: `105.5u => 106`\r\n* Defines a new flags enum `NumberSuffixFlags` that takes care of one-or-more numerical type suffixes.\r\n* Can explicitly parse `ul`-suffixed numeric values as `ulong` and `us`-suffixed values as `ushort`.\r\n* Explicitly specified length types for `short` and `long` as well as declared `unsigned` types **will** error out and register as an invalid numeric literal if their values after multiplication exceeds the type contraints. This is intentional; if the user specifies a value that cannot be satisfied e.g., `500sgb` (500 short, gigabyte multiplier) then the parser should not be expected to figure out what they meant. \r\n* Converts `strNum` parameter of `TryGetNumberValue` to `ReadOnlySpan<char>` to hopefully get a little better performance as it flies through all the `TryParse`s.\r\n\r\n## PR Checklist\r\n\r\n- [X] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [X] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [X] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [X] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` to the beginning of the title and remove the prefix when the PR is ready.\r\n- **User-facing changes**\r\n    - [X] User-facing [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [ ] Issue filed - Issue link:\r\n- **Testing - New and feature**\r\n    - [x] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n        - [ ] [Add `[feature]` if the change is significant or affects feature tests](https://github.com/PowerShell/PowerShell/blob/master/docs/testing-guidelines/testing-guidelines.md#requesting-additional-tests-for-a-pr)\r\n\r\n(not sure on *all* of those points; never worked on this repo before; feel free to let me know about stuff I'm missing)",
  "closed_at": "2018-09-06T00:34:07Z",
  "comments": [
    {
      "author": "msftclas",
      "author_association": "NONE",
      "body": "[![CLA assistant check](https://cla.opensource.microsoft.com/pull/badge/signed)](https://cla.opensource.microsoft.com/PowerShell/PowerShell?pullRequest=7509) <br/>All CLA requirements met.",
      "created_at": "2018-08-13T04:10:02Z",
      "updated_at": "2018-10-24T08:29:18Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@vexx32 Please add tests.",
      "created_at": "2018-08-13T09:47:26Z",
      "updated_at": "2018-08-13T09:47:26Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@SteveL-MSFT Should we get PowerShellCommittee approvement?",
      "created_at": "2018-08-13T09:48:26Z",
      "updated_at": "2018-08-13T09:48:26Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I'll get on that this evening. Just realised there's one more case it should handle; native ulong input when there's no multiplier.\r\n\r\nYou guys think it's worth looking at adding short type accelerators for `[uint]` and/or `[ulong]` as well to have parity with regular int accelerators?",
      "created_at": "2018-08-13T10:40:41Z",
      "updated_at": "2018-08-13T10:40:55Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "OK Forgive me for not really.. being aware here. \r\n\r\nAre we talking xUnit or Pester tests in this instance? The latter I can do easily, the former... well, I'll have to do some reading!",
      "created_at": "2018-08-13T16:14:25Z",
      "updated_at": "2018-08-13T16:14:25Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@iSazonov hopefully these tests are workable. I tried to place them in as sensible a place as I could find; with the other parser notation tests.\r\n\r\nI've also modified the accelerator checks to accept the new `[uint]` and `[ulong]` type accelerators. I think. ",
      "created_at": "2018-08-13T20:57:59Z",
      "updated_at": "2018-08-13T20:57:59Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Okay, I think I properly fixed both the tests and my ulong parsing. \ud83d\ude0a ",
      "created_at": "2018-08-13T22:41:58Z",
      "updated_at": "2018-08-13T22:41:58Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Appreciate the comments so far!\r\n\r\nOkay, so updated the tests to match everything properly, and put in `[ushort]` for `uint16` as well. I'm not sure of the prevalence of (U)int16 usage in PS, but I don't think making them a little more accessible to those coming from other languages is at all a bad idea. :grin: ",
      "created_at": "2018-08-14T10:37:09Z",
      "updated_at": "2018-08-14T10:37:09Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I still don't know what was up with the VSTS build before, but everything's working now. \ud83d\ude04 ",
      "created_at": "2018-08-14T12:49:03Z",
      "updated_at": "2018-08-14T12:49:03Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Alright, I officially give up on matching whatever wacky indentation was initially here. It's good enough.",
      "created_at": "2018-08-14T16:01:30Z",
      "updated_at": "2018-08-14T16:01:30Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee reviewed this.  We have already taken many other changes that impact portability to older PowerShells, but the workaround is (as noted above) not to use these newer features.  Committee accepts this change.",
      "created_at": "2018-08-15T22:38:44Z",
      "updated_at": "2018-08-15T22:38:44Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Thanks, guys! I've been poking at those AppVeyor/VSTS build errors, but as far as I can see, I don't think there's anything there that I've broken myself. Looks like some modules aren't loading properly or something?",
      "created_at": "2018-08-16T00:41:09Z",
      "updated_at": "2018-08-16T00:41:09Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@iSazonov ; @lzybkr \r\n\r\nI know it's a bit on the late end of things, but it just occurred to me that (while I'm meddling here, heh!) I could also add an `s` suffix to denote `short` (`(u)int16`) values. Wouldn't really take all that much to add. Do you think it's worth doing?",
      "created_at": "2018-08-16T02:46:17Z",
      "updated_at": "2018-08-16T02:55:15Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I think that this is not so important for the scripting language, but if we have already added a lot of suffixes, then we should have a full set of suffixes.\r\n\r\nPlease update the PR title and description to describe latest enhancements.",
      "created_at": "2018-08-16T03:54:01Z",
      "updated_at": "2018-08-16T03:54:01Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Roger that, will do. Double checking that it builds correctly with ReadOnlySpan in TryGetNumberValue parameter, and then I'll push that too.",
      "created_at": "2018-08-16T03:57:52Z",
      "updated_at": "2018-08-16T03:57:52Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "So this builds fine locally and I've tested the packagemanagement imports (the ones giving the build grief) and I'm not seeing issues on my Win10 system.\r\n\r\nNot sure what's breaking the build but as far as I can tell it doesn't seem to be my changes here. :/",
      "created_at": "2018-08-16T13:52:04Z",
      "updated_at": "2018-08-16T13:52:04Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Reopen The PR to restart CIs.",
      "created_at": "2018-08-16T14:23:33Z",
      "updated_at": "2018-08-16T14:23:33Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Awesome, looks like it's just failing on some 'uploading artifacts' tasks on the VSTS builds. I won't pretend to know what that's about but it looks like something being addressed in #7535 \ud83d\ude04 ",
      "created_at": "2018-08-16T15:54:15Z",
      "updated_at": "2018-08-16T15:54:15Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "I don't see a need for a `short` suffix - coercion to smaller types isn't usually necessary, but in the interest of completeness, I don't care either.\r\n\r\nThat said, a byte suffix is needed for completeness, and that needs to be considered by the committee - because `b` could also be used for binary literals.",
      "created_at": "2018-08-16T21:00:40Z",
      "updated_at": "2018-08-16T21:00:40Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Actually, the topic of a byte / binary signifier was brought up in discussion of this in the PS Slack.\r\n\r\nThat idea was mentioned, as well as the possible alternative for `0b000001` type syntax to mirror the hex syntax. Since it looks like that parsing is also done in the tokenizer here, I would be happy to explore either of those options.\r\n\r\nWhat do you think of that option?",
      "created_at": "2018-08-16T21:07:22Z",
      "updated_at": "2018-08-16T21:37:38Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@vexx32 I would suggesting having the byte and binary in a separate PR with separate discussion",
      "created_at": "2018-08-16T21:52:35Z",
      "updated_at": "2018-08-16T21:52:35Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Fair enough. :)\r\n\r\nI think I've done as much as is sensible at this point, then!",
      "created_at": "2018-08-16T21:58:50Z",
      "updated_at": "2018-08-16T21:58:50Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Huh, that's interesting...\r\n\r\n@lzybkr @rjmholt OK, so now I need to ask. Am I *supposed* to let large hex number patterns read as negatives? Are they *supposed* to only fit into, like, int16 / int32 hex block patterns?\r\n\r\nBecause if so, I can do a simple length check and see what it needs to get parsed as. Or just flat out parse hex *only* as `[u]int[16|32|64]`\r\n\r\nWhat exactly is the desired behaviour of hex literals? Because in my parsing them as `bigint` either I've made them better or worse, and I don't work with them enough to know which is which!\r\n\r\nAlso, parsing purely as `BigInteger` for all non-`real` types and then casting seems to have sped up the parser a good bit as opposed to doing sequential `TryParse`s.",
      "created_at": "2018-08-18T17:02:34Z",
      "updated_at": "2018-08-18T17:04:03Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Okay I talked it over with @jaykul in the Slack and came to the conclusion that:\r\n\r\n1. We should probably respect sign bits at int32 and int64 levels, at the very least\r\n2. There may be a potential (if highly edge case) use for larger hex literals, so I haven't limited them to int values; they will happily parse as decimals for the moment or doubles if they get high enough (though at that point their utility is questionable, since there's no accuracy at that high of a value for a double.)\r\n  * The sign bit is every 8 hex characters it would seem, so higher values respect that pattern also, at the present time. \r\n\r\nHow do you guys want to handle large hex values?",
      "created_at": "2018-08-18T17:56:01Z",
      "updated_at": "2018-08-18T17:56:01Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "Hmmmmmmm I don't have an immediate intuition on how we ought to handle sign or large literals in hex. It's the kind of deep language question we should consult a few sources on. Let me do some research \ud83d\ude04 ",
      "created_at": "2018-08-18T18:03:43Z",
      "updated_at": "2018-08-18T18:08:38Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Appreciate it, Robert!\r\n\r\nOK, I *think* what I have might be OK.\r\n\r\nCurrently (if the string is a hex string) it does this:\r\n\r\n1. Check length of hex string.\r\n2. If it's not divisible by 8, assume there isn't a sign bit and prepend a `0` to make sure `BigInteger.TryParse` doesn't assume the first character is meant to determine sign.\r\n",
      "created_at": "2018-08-18T19:52:44Z",
      "updated_at": "2018-08-18T22:45:18Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Currently (according to the sole remaining failing test) we're expecting hex literals to automatically read s `UInt32` if they're over `Int32` size range.... or something.\r\n\r\nI think I can mimic that behaviour, but the question is -- should we? And if we do, then I can do a similar thing for `UInt64` hex literals as well.",
      "created_at": "2018-08-18T20:23:39Z",
      "updated_at": "2018-08-18T20:39:36Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "OK So essentially if you have a hex value that is a multiple of 8 digits it expects a sign bit and adheres to it. Otherwise it assumes the value is positive when parsing (if you have a negative sign before the hex literal it is still respected and flips the final value).\r\n\r\nIt doesn't really make... sense... (in my opinion) for the value to go into doubles territory -- that's kind of against the point of *using* hex (unit precision) so since we already parse as `bigint` in this region (and always have, I've just kind of rolled it all together here) I figured if you're asking for a hex literal *that* big you might actually need it for some insane scenario and thought -- why not just yield the `bigint` value already there for the taking.\r\n\r\nI'd love to hear your thoughts on it, though, as always! This is filtered through my own brain, so there may well be stuff in here that we should avoid doing for reasons I haven't thought of yet (yes `bigint` can cause OOM errors but the parser is already using it to check bounds anyway and always has; this won't introduce any new overflow possibilities that weren't already there just by virtue of entering stupidly huge decimals).\r\n\r\n@iSazonov @rjmholt @lzybkr \r\n\r\n![image](https://user-images.githubusercontent.com/32407840/44304417-72371800-a329-11e8-8450-705a46f4bdb7.png)\r\n![image](https://user-images.githubusercontent.com/32407840/44304421-82e78e00-a329-11e8-8841-b2faa5d2c84c.png)\r\n\r\nAnd regarding that failing test on `Get-Random`:\r\n\r\n```powershell\r\nPS C:\\Users\\Joel\\source\\repos\\PSCore\\PowerShell> get-random 0xfffffffffffffffffffffffffffffffff\r\n5.04272284445114E+39\r\n```\r\n^^ that is why. \ud83d\ude04 ",
      "created_at": "2018-08-19T00:01:16Z",
      "updated_at": "2018-08-19T00:59:38Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "@SteveL-MSFT I don't care about the back porting issue but I worry a great deal that so many changes to PowerShell's numeric processing will break backwards compatibility in a significant way. I think we need to revisit the impact of this change at next week's committee meeting.",
      "created_at": "2018-08-19T04:51:14Z",
      "updated_at": "2018-08-19T04:51:14Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Fun fun~ Keep me posted \ud83d\ude04 \r\n\r\nFWIW, I haven't really changed all that much from the outside looking in; it parses standard things just the same. The only significantly different behaviour (other than the new type suffixes) is that it doesn't just give up on large hex literals anymore. :)\r\n\r\nAnd... though I need to draw up proper benchmarks... a few brief tests seem to indicate it's a bit quicker than before, which is usually a good thing. \ud83d\udc4d ",
      "created_at": "2018-08-19T05:21:41Z",
      "updated_at": "2018-08-19T05:21:41Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "As for sign:\r\n1. Currently PowerShell implement \r\n```powershell\r\n-0x1A\r\n\r\n-26\r\n```\r\n2. Currently PowerShell CAN consider hex numerics as signed\r\n```powershell\r\n>0xFFFFFFFF\r\n\r\n-1\r\n\r\n>(0xFFFFFFFF).Gettype()\r\n\r\nIsPublic IsSerial Name                                     BaseType\r\n-------- -------- ----                                     --------\r\nTrue     True     Int32                                    System.ValueType\r\n```\r\n3. Current PowerShell behavior is to consider high bit as sign _because target type always is signed_ - int32/64/long/double/BigInteger.\r\n\r\n4. If target type is unsigned (ushort,uint,ulong and so on) PowerShell MUST to consider high bit as value not sign\r\nThe behavior is in CoreFX https://source.dot.net/#System.Private.CoreLib/shared/System/Number.Parsing.cs,890\r\n vs\r\nhttps://source.dot.net/#System.Runtime.Numerics/System/Numerics/BigNumber.cs,427\r\n\r\n5. Because we want add binary literals we should consider them here too. PowerShell must process binary literals in the same manner as hex literals.\r\n",
      "created_at": "2018-08-20T10:04:14Z",
      "updated_at": "2018-08-20T10:19:16Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@vexx32 The PR is very large (many comments and commits). I suggest split the PR to simplify.\r\n1. Make new PR with new prefixes and tests - it already was approved by PowerShell Committee and we can fast review and merge.\r\n2. Make new PR with NumberSuffixFlags in ScanNumberHelper (using switch) + replace `Convert.ChangeType` with new convert helper methods - the temporary PR _without_ any fuctional changes can be fast reviewed and merged.\r\n\r\nAfter that we can close current PR and open new one with cleaned commits based on PowerShell Committee conclusion - commits with new suffixes and perhaps changes related hex/binary sign.",
      "created_at": "2018-08-20T10:13:57Z",
      "updated_at": "2018-08-20T10:13:57Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "RE: the hex behaviour -- I have most of that working, though I can see I need to add a case for `Unsigned` types to *not* treat the largest bit as the signing bit. NBD there.\r\n\r\nAs for the PR suggestions, yeah, I'll get on that. Shouldn't be too hard to pull off. \ud83d\ude04 \r\n\r\nEDIT: as per #7575 I have split off the type suffix and accelerator changes.\r\n\r\nHowever, I'm not able to do the two-char type suffix without either converting `suffix` to `string` or the enum, so I opted to retain the changes that work with the enum specifically. Everything else remains the same.",
      "created_at": "2018-08-20T13:22:59Z",
      "updated_at": "2018-08-20T17:07:42Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "(renamed for clarity, I went a bit beyond the original intent here) ;)",
      "created_at": "2018-08-21T04:25:34Z",
      "updated_at": "2018-08-21T04:25:34Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "This seems like a REALLY good candidate for that feature flag testing that's been discussed before.\r\n\r\nNot on the sense that is simple to toggle, but in the sense that this big of a change ought to be tested ... a lot ... In such a way that people can initially opt in to the new parser, then eventually make it opt-out ... And if all goes well, remove the old code?",
      "created_at": "2018-08-23T06:31:17Z",
      "updated_at": "2018-08-23T06:31:17Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "FWIW; After submitting #7575 I've been toying with possible improvements and have a much cleaner and more polished version of this code at https://github.com/vexx32/PowerShell/tree/Tokenizer/Refactor\r\n\r\nIt's not yet a PR as it is a branch off of the code in #7575 and includes those changes already. ",
      "created_at": "2018-09-05T15:54:55Z",
      "updated_at": "2018-09-05T15:54:55Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee re-reviewed this and is fine with the proposal (this is not a PR review approval)",
      "created_at": "2018-09-05T22:38:32Z",
      "updated_at": "2018-09-05T22:38:32Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Closing this for now so we don't waste anymore time here. The base of the stuff that was meant to happen here is in #7575, and the rest needs a great deal of clean up that will be in an upcoming PR.",
      "created_at": "2018-09-06T00:34:07Z",
      "updated_at": "2018-09-06T00:34:07Z"
    }
  ],
  "created_at": "2018-08-13T04:09:51Z",
  "number": 7509,
  "state": "closed",
  "title": "Refactor the tokenizer",
  "updated_at": "2018-10-24T08:29:18Z"
}