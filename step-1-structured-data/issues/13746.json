{
  "_url": "https://github.com/PowerShell/PowerShell/issues/13746",
  "author": "iRon7",
  "body": "## Summary of the new feature/enhancement\r\n\r\nTo complement **Feature Idea: Revisiting and extending the ParameterSet Experience** #12818\r\nI would like to raise two dissenting ideas:\r\n\r\n### 1. Reverse the set/parameter containment\r\nPersonally, I think that the current parameter notation is inside out\r\nCurrently, **parameters contain parameters sets**  (each Parameter holds multiple attributes with a `ParametersSetName`)\r\nbut it should be visa versa: **a parameter [*set*](https://en.wikipedia.org/wiki/Set_theory) should contain parameters.**\r\nBy turning this around, you might also support (recursive) parameter [subsets](https://en.wikipedia.org/wiki/Subset).\r\nWith all respect, adding additional configuration items (like groups and [ParameterMutexName](https://github.com/PowerShell/PowerShell/issues/5175)) might help to reduce the redundancy but eventually adds up to the complicity when combining them with the existing configuration items.\r\nI even believe that *naming* parameters sets is inessential if using subsets.\r\n\r\n### 2. Use *PowerShell* to build parameter sets.\r\nDevelopers creating cmdlets are already quiet known with PowerShell and need to learn a complete different parameter syntax  to get them straight for their functions.\r\nApart from the fact that you might reduce the redundancy and complexity by using variables and subsets, there is also another advantage in moving to PowerShell scripting: I guess that changes to the current parameter notification (like e.g. groups) will require an update of the PowerShell engine therefor engineers who like to supply some backwards compatibility (with e.g. Windows PowerShell) for their cmdlets/functions might be reluctant to use any new parameter features provided through the current parameter notation. A PowerShell framework using the `DynamicParam` section, might only require installing a module to supply backwards compatibility in customer scripts.\r\n\r\n## Proposed technical implementation details\r\nLet's assume a `Draw-Shape`  cmdlet that requires the following parameter (set) constrains:\r\n\r\n* There are 3 possible shapes:\r\n  * **Circle** (which requires one `Radius` parameter)\r\n  * **Rectangle** (which requires a `Width` and a `Height` parameter)\r\n  * **Triangle** (which requires 3 - `Side1`, `Side2` and `Side3` - parameters)\r\n* Each shape requires either of the (*mutually exclusive*) parameters below:\r\n  * `Transparency`\r\n  * `Opacity`\r\n* And a optional color (default black) by either using\r\n  *  a **RGB** scheme\r\n      * `Red`\r\n      * `Green`\r\n      * `Blue`\r\n  * or a **HSL** scheme\r\n      * `Hue`\r\n      * `Sat`\r\n      * `Lum`\r\n\r\nUsing the current parameter notation, this requires:\r\n<details>\r\n  <summary>a lot of parameter definitions...</summary>\r\n\r\n``` PowerShell\r\nfunction Draw-Shape {\r\n    [CmdletBinding()] param(\r\n        [Parameter(Position = 0, ParameterSetName = 'CircleTransparencyRGB', Mandatory = $True)]\r\n        [Parameter(Position = 0, ParameterSetName = 'CircleTransparencyHSL', Mandatory = $True)]\r\n        [Parameter(Position = 0, ParameterSetName = 'CircleOpacityRGB', Mandatory = $True)]\r\n        [Parameter(Position = 0, ParameterSetName = 'CircleOpacityHSL', Mandatory = $True)]\r\n        [int]$Radius,\r\n        \r\n        [Parameter(Position = 0, ParameterSetName = 'SquareTransparencyRGB', Mandatory = $True)]\r\n        [Parameter(Position = 0, ParameterSetName = 'SquareTransparencyHSL', Mandatory = $True)]\r\n        [Parameter(Position = 0, ParameterSetName = 'SquareOpacityRGB', Mandatory = $True)]\r\n        [Parameter(Position = 0, ParameterSetName = 'SquareOpacityHSL', Mandatory = $True)]\r\n        [int]$Width,\r\n\r\n        [Parameter(Position = 1, ParameterSetName = 'SquareTransparencyRGB', Mandatory = $True)]\r\n        [Parameter(Position = 1, ParameterSetName = 'SquareTransparencyHSL', Mandatory = $True)]\r\n        [Parameter(Position = 1, ParameterSetName = 'SquareOpacityRGB', Mandatory = $True)]\r\n        [Parameter(Position = 1, ParameterSetName = 'SquareOpacityHSL', Mandatory = $True)]\r\n        [int]$Height,\r\n\r\n        [Parameter(Position = 0, ParameterSetName = 'TriangleTransparencyRGB', Mandatory = $True)]\r\n        [Parameter(Position = 0, ParameterSetName = 'TriangleTransparencyHSL', Mandatory = $True)]\r\n        [Parameter(Position = 0, ParameterSetName = 'TriangleOpacityRGB', Mandatory = $True)]\r\n        [Parameter(Position = 0, ParameterSetName = 'TriangleOpacityHSL', Mandatory = $True)]\r\n        [int]$Side1,\r\n\r\n        [Parameter(Position = 1, ParameterSetName = 'TriangleTransparencyRGB', Mandatory = $True)]\r\n        [Parameter(Position = 1, ParameterSetName = 'TriangleTransparencyHSL', Mandatory = $True)]\r\n        [Parameter(Position = 1, ParameterSetName = 'TriangleOpacityRGB', Mandatory = $True)]\r\n        [Parameter(Position = 1, ParameterSetName = 'TriangleOpacityHSL', Mandatory = $True)]\r\n        [int]$Side2,\r\n\r\n        [Parameter(Position = 2, ParameterSetName = 'TriangleTransparencyRGB', Mandatory = $True)]\r\n        [Parameter(Position = 2, ParameterSetName = 'TriangleTransparencyHSL', Mandatory = $True)]\r\n        [Parameter(Position = 2, ParameterSetName = 'TriangleOpacityRGB', Mandatory = $True)]\r\n        [Parameter(Position = 2, ParameterSetName = 'TriangleOpacityHSL', Mandatory = $True)]\r\n        [int]$Side3,\r\n        \r\n        [Parameter(ParameterSetName = 'CircleTransparencyRGB',   Mandatory = $True)]\r\n        [Parameter(ParameterSetName = 'SquareTransparencyRGB',   Mandatory = $True)]\r\n        [Parameter(ParameterSetName = 'TriangleTransparencyRGB', Mandatory = $True)]\r\n        [Parameter(ParameterSetName = 'CircleTransparencyHSL',   Mandatory = $True)]\r\n        [Parameter(ParameterSetName = 'SquareTransparencyHSL',   Mandatory = $True)]\r\n        [Parameter(ParameterSetName = 'TriangleTransparencyHSL', Mandatory = $True)]\r\n        [int]$Transparency,\r\n\r\n        [Parameter(ParameterSetName = 'CircleOpacityRGB',   Mandatory = $True)]\r\n        [Parameter(ParameterSetName = 'SquareOpacityRGB',   Mandatory = $True)]\r\n        [Parameter(ParameterSetName = 'TriangleOpacityRGB', Mandatory = $True)]\r\n        [Parameter(ParameterSetName = 'CircleOpacityHSL',   Mandatory = $True)]\r\n        [Parameter(ParameterSetName = 'SquareOpacityHSL',   Mandatory = $True)]\r\n        [Parameter(ParameterSetName = 'TriangleOpacityHSL', Mandatory = $True)]\r\n        [int]$Opacity,\r\n\r\n        [Parameter(ParameterSetName = 'CircleTransparencyRGB')]\r\n        [Parameter(ParameterSetName = 'SquareTransparencyRGB')]\r\n        [Parameter(ParameterSetName = 'TriangleTransparencyRGB')]\r\n        [Parameter(ParameterSetName = 'CircleOpacityRGB')]\r\n        [Parameter(ParameterSetName = 'SquareOpacityRGB')]\r\n        [Parameter(ParameterSetName = 'TriangleOpacityRGB')]\r\n        [int]$Red,\r\n\r\n        [Parameter(ParameterSetName = 'CircleTransparencyRGB')]\r\n        [Parameter(ParameterSetName = 'SquareTransparencyRGB')]\r\n        [Parameter(ParameterSetName = 'TriangleTransparencyRGB')]\r\n        [Parameter(ParameterSetName = 'CircleOpacityRGB')]\r\n        [Parameter(ParameterSetName = 'SquareOpacityRGB')]\r\n        [Parameter(ParameterSetName = 'TriangleOpacityRGB')]\r\n        [int]$Green,\r\n\r\n        [Parameter(ParameterSetName = 'CircleTransparencyRGB')]\r\n        [Parameter(ParameterSetName = 'SquareTransparencyRGB')]\r\n        [Parameter(ParameterSetName = 'TriangleTransparencyRGB')]\r\n        [Parameter(ParameterSetName = 'CircleOpacityRGB')]\r\n        [Parameter(ParameterSetName = 'SquareOpacityRGB')]\r\n        [Parameter(ParameterSetName = 'TriangleOpacityRGB')]\r\n        [int]$Blue,\r\n\r\n        [Parameter(ParameterSetName = 'CircleTransparencyHSL')]\r\n        [Parameter(ParameterSetName = 'SquareTransparencyHSL')]\r\n        [Parameter(ParameterSetName = 'TriangleTransparencyHSL')]\r\n        [Parameter(ParameterSetName = 'CircleOpacityHSL')]\r\n        [Parameter(ParameterSetName = 'SquareOpacityHSL')]\r\n        [Parameter(ParameterSetName = 'TriangleOpacityHSL')]\r\n        [int]$Hue,\r\n\r\n        [Parameter(ParameterSetName = 'CircleTransparencyHSL')]\r\n        [Parameter(ParameterSetName = 'SquareTransparencyHSL')]\r\n        [Parameter(ParameterSetName = 'TriangleTransparencyHSL')]\r\n        [Parameter(ParameterSetName = 'CircleOpacityHSL')]\r\n        [Parameter(ParameterSetName = 'SquareOpacityHSL')]\r\n        [Parameter(ParameterSetName = 'TriangleOpacityHSL')]\r\n        [int]$Sat,\r\n\r\n        [Parameter(ParameterSetName = 'CircleTransparencyHSL')]\r\n        [Parameter(ParameterSetName = 'SquareTransparencyHSL')]\r\n        [Parameter(ParameterSetName = 'TriangleTransparencyHSL')]\r\n        [Parameter(ParameterSetName = 'CircleOpacityHSL')]\r\n        [Parameter(ParameterSetName = 'SquareOpacityHSL')]\r\n        [Parameter(ParameterSetName = 'TriangleOpacityHSL')]\r\n        [int]$Lum\r\n    )\r\n}\r\n```\r\n\r\n</details>\r\n\r\nUsing this prototype [`ParameterFunctions`](https://github.com/iRon7/Hierarchical-Parameter-Scripting) module, it requires the following knowledge. Sorry, there is no readme yet, but you can use the `-?` option to get the syntax and the description below:\r\n\r\nThere are 2 functions included in the module to create parameters and parameter-sets:\r\n1. `New-Parameter` (alias `New-Param`, or `NPM`)\r\nThis function has 5 main parameters:\r\n  * `[int]$Position`\r\n  * `[type]$Type`\r\n  * `[string]$Name`\r\n  * `[object]$Default`\r\n  * `[switch]$Mandatory`\r\n\r\nBesides has a few parameters like `HelpMessage` to set certain parameter attributes.\r\nIt has **no `ParameterSetName`** option!\r\n\r\n2. `New-ParameterSet` (alias `New-ParamSet`, or `NPS`)\r\nWhich has two parameters:\r\n  * `[RuntimeDefinedParameterDictionary[]]$ParameterSets`\r\n  * `[String]$SetName` *(Optional)*\r\n\r\nThere can only be **one** root (default) parameter set (or a single parameter which is quiet pointless).\r\nEach set might contain multiple (optional or mandatory) parameters or multiple (recursive) parameter sets.\r\n\r\n## Syntax\r\nThe basic [syntax notation](https://docs.informatica.com/data-integration/powercenter/10-1/command-reference/using-the-command-line-programs/syntax-notation.html):\r\n\r\n### `[x]`\r\nOptional parameter. The command runs whether or not you enter optional parameters.\r\n\r\n```PowerShell\r\nfunction FMO {\r\n    [CmdletBinding()] param()\r\n    DynamicParam {\r\n        New-Param 0 ([string]) x\r\n    }\r\n}\r\n```\r\n\r\n### `[x|y]`\r\nSelect between optional parameters.\r\n\r\n```PowerShell\r\nfunction FMO {\r\n    [CmdletBinding()] param()\r\n    DynamicParam {\r\n        New-ParamSet @(\r\n            New-Param 0 ([string]) x\r\n            New-Param 1 ([string]) y\r\n        )\r\n    }\r\n}\r\n```\r\n\r\n### `<x>`\r\nRequired option. If you omit a required option, the command line program returns an error message.\r\n\r\n```PowerShell\r\nfunction Test {\r\n    [CmdletBinding()] param()\r\n    DynamicParam {\r\n        New-Param 0 ([string]) x -Mandatory\r\n    }\r\n}\r\n```\r\n\r\n### `<x|y>`\r\nSelect between required options. For the command to run, you must select from the listed options. If you omit a required option, the command line program returns an error message.\r\n\r\n```PowerShell\r\nfunction Test {\r\n    [CmdletBinding()] param()\r\n    DynamicParam {\r\n        New-ParamSet @(\r\n            New-ParamSet @(\r\n                New-Param ([string]) x -Mandatory\r\n            )\r\n            New-ParamSet @(\r\n                New-Param ([string]) y -Mandatory\r\n            )\r\n        )\r\n    }\r\n}\r\n```\r\n\r\nFurther steps to come to the final result below you can find in the [`Parameters.Test.ps1`](https://github.com/iRon7/Hierarchical-Parameter-Scripting/blob/main/Parameter.Tests.ps1):\r\n\r\n```PowerShell\r\nfunction Draw-Shape {\r\n    [CmdletBinding()] param()\r\n    DynamicParam {\r\n\r\n        # Define the optional  RGB and HSL subsets\r\n        $Color = @(\r\n            New-ParamSet @(\r\n                New-Param ([int]) Red\r\n                New-Param ([int]) Green\r\n                New-Param ([int]) Blue\r\n            )\r\n            New-ParamSet @(\r\n                New-Param ([int]) Hue\r\n                New-Param ([int]) Sat\r\n                New-Param ([int]) Lum\r\n            )\r\n        )\r\n\r\n        # Define the optional mutually exclusive Transparency/Opacity subsets\r\n        $Tint = @(\r\n            New-ParamSet @(\r\n                New-Param ([int]) Transparency -Mandatory\r\n                $Color\r\n            )\r\n            New-ParamSet @(\r\n                New-Param ([int]) Opacity -Mandatory\r\n                $Color\r\n            )\r\n        )\r\n\r\n        # Create a (single) main set\r\n        New-ParamSet @(\r\n            New-ParamSet @(\r\n                New-Param 0 ([int]) Radius -Mandatory\r\n                $Tint\r\n            )\r\n            New-ParamSet @(\r\n                New-Param 0 ([int]) Width  -Mandatory\r\n                New-Param 1 ([int]) Height -Mandatory\r\n                $Tint\r\n            )\r\n            New-ParamSet @(\r\n                New-Param 0 ([int]) Side1 -Mandatory\r\n                New-Param 1 ([int]) Side2 -Mandatory\r\n                New-Param 2 ([int]) Side3 -Mandatory\r\n                $Tint\r\n            )\r\n        )\r\n    }\r\n}\r\n```\r\n\r\n### Draw-Shape -?\r\n```PowerShell\r\nNAME\r\n    Draw-Shape\r\n\r\nSYNTAX\r\n    Draw-Shape [-Radius] <int> -Transparency <int> [-Red <int>] [-Green <int>] [-Blue <int>] [<CommonParameters>]\r\n\r\n    Draw-Shape [-Radius] <int> -Opacity <int> [-Red <int>] [-Green <int>] [-Blue <int>] [<CommonParameters>]\r\n\r\n    Draw-Shape [-Width] <int> [-Height] <int> -Transparency <int> [-Red <int>] [-Green <int>] [-Blue <int>] [<CommonParameters>]\r\n\r\n    Draw-Shape [-Width] <int> [-Height] <int> -Opacity <int> [-Red <int>] [-Green <int>] [-Blue <int>] [<CommonParameters>]\r\n\r\n    Draw-Shape [-Side1] <int> [-Side2] <int> [-Side3] <int> -Transparency <int> [-Red <int>] [-Green <int>] [-Blue <int>] [<CommonParameters>]\r\n\r\n    Draw-Shape [-Side1] <int> [-Side2] <int> [-Side3] <int> -Opacity <int> [-Red <int>] [-Green <int>] [-Blue <int>] [<CommonParameters>]\r\n\r\n    Draw-Shape [-Radius] <int> -Transparency <int> [-Hue <int>] [-Sat <int>] [-Lum <int>] [<CommonParameters>]\r\n\r\n    Draw-Shape [-Radius] <int> -Opacity <int> [-Hue <int>] [-Sat <int>] [-Lum <int>] [<CommonParameters>]\r\n\r\n    Draw-Shape [-Width] <int> [-Height] <int> -Transparency <int> [-Hue <int>] [-Sat <int>] [-Lum <int>] [<CommonParameters>]\r\n\r\n    Draw-Shape [-Width] <int> [-Height] <int> -Opacity <int> [-Hue <int>] [-Sat <int>] [-Lum <int>] [<CommonParameters>]\r\n\r\n    Draw-Shape [-Side1] <int> [-Side2] <int> [-Side3] <int> -Transparency <int> [-Hue <int>] [-Sat <int>] [-Lum <int>] [<CommonParameters>]\r\n\r\n    Draw-Shape [-Side1] <int> [-Side2] <int> [-Side3] <int> -Opacity <int> [-Hue <int>] [-Sat <int>] [-Lum <int>] [<CommonParameters>]\r\n```\r\n\r\n## Caveats\r\n* It concerns a prototype and there might be quiet some bugs a limitation but I think it might eventually replace the current parameter notation\r\n* Consider a (default) parameter [Provider](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_providers?view=powershell-7) (I am lacking the C# knowledge to set this up \ud83d\ude0c)\r\n* It might be slower than the current parameter notation (consider a `-Static` option which caches the `RuntimeDefinedParameterDictionary`)\r\n* Default value is not work (yet)\r\n* Dynamic parameters are not automatically put in variables, workaround:\r\n```PowerShell\r\nforeach ($Name in $PSBoundParameters.get_keys()) {\r\n    if (!(Test-Path variable:$Name)) { Set-Variable -Name $Name -Value $PSBoundParameters[$Name] }\r\n}\r\n```\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "In general I like the idea to enhance the parameter defining - \r\n\r\nWhat about additional level? I mean  an optional parameter could require some mandatory/optional subparameters.\r\nAnd what about C# notation?",
      "created_at": "2020-10-05T17:20:45Z",
      "updated_at": "2020-10-05T17:20:45Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "The main reason I'm unsure about this style of declaring params is that you have declare the same parameter multiple times if it happens to be in multiple sets. This creates a greater possibility of mistakes and more confusing UX if a parameter by the same name appears to behave multiple different ways depending on the other parameters specified with it.\r\n\r\nI would love to see a rework of parameter declaration, but I don't think this is the right direction to go. \ud83e\udd14 ",
      "created_at": "2020-10-05T18:02:16Z",
      "updated_at": "2020-10-05T18:02:16Z"
    },
    {
      "author": "ThomasNieto",
      "author_association": "CONTRIBUTOR",
      "body": "Looking at the command syntax it looks like this cmdlet is trying to do too much. A good rule of thumb that I've seen with PowerShell parameter set best practices is that if you're getting this many, maybe its time to create dedicated cmdlets. This many parameter sets is also confusing to the user as the syntax diagram is too complex.\r\n\r\nFor your example the cmdlet could be broken down into multiple cmdlets:\r\n\r\n`Draw-Shape` gets broken down into three cmdlets:\r\n\r\n* `Draw-Circle -Radius <int>`\r\n* `Draw-Rectangle -Height <int> -Width <int>`\r\n* `Draw-Triangle -Side1 <int> -Side2 <int> -Side3 <int>`\r\n\r\nDedicated color cmdlets can be created to define either of the two color schemes. Then a parameter set can be added to `Draw-*`  for the `-RGBColor` or `-HSLColor` or to be a common parameter. The same can be done with `-Transparency` and `-Opacity`.\r\n\r\n* `New-RGBColor -Red <int> -Blue <int> -Red <int>`\r\n* `New-HSLColor -Hue <int> -Sat <int> -Lum <int>`\r\n\r\nThis can take the 12 parameter sets down to just a couple by going this route. There was also an old [RFC](https://github.com/PowerShell/PowerShell-RFC/blob/master/X-Withdrawn/RFC0001-Mutual-Exclusion-Parameters-and-Properties.md) that defined mutually exclusive parameters without needing a new parameter set.",
      "created_at": "2020-10-05T23:42:41Z",
      "updated_at": "2020-10-05T23:46:10Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I added more info in #12818.",
      "created_at": "2020-10-06T07:54:59Z",
      "updated_at": "2020-10-06T07:54:59Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "@Vexx32 and @ThomasNieto, the 'Draw-Shape' is just an extreme example which two mutually exclusive parameter sets almost at the root of the main set.\r\n\r\n> The main reason I'm unsure about this style of declaring params is that you have declare the same parameter multiple times if it happens to be in multiple sets. This creates a greater possibility of mistakes and more confusing UX if a parameter by the same name appears to behave multiple different ways depending on the other parameters specified with it.\r\n\r\nYes, there are about **22 (sub)sets in the `Draw-Shape` example with a total of 58 parameters** (where the current parameters notation has **14 parameters with 72 parameters-sets**). As @iSazonov pointed out in #12818, my general objective is to use **a syntax diagram which is similar to the (expanded) syntax displayed by the help**. In the existing solution, you might limit some of the parameter-sets by using configuration items like `DefaultParameterSetName` but it is difficult to further reduce the redundancy of this rather flat design. This is mainly because the attributes that *usually* relate to the parameter (like `position` and `mandatory`) are contaminated with a `ParameterSetName` property that actually belongs to parameter-set. In the purposed design it is easy to script any redundancy using variables or loops:\r\n\r\nTaking the parameter-set of the current [`Where-Object`](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/where-object?view=powershell-7) cmdlet for another example:\r\n\r\n```PowerShell\r\nfunction WhereObject {\r\n    [CmdletBinding()] param()\r\n    DynamicParam {\r\n        $MandatoryOperators = @(\r\n            'CEQ', 'NE', 'CNE', 'GT', 'CGT', 'LT', 'CLT', 'GE', 'CGE', 'LE', 'CLE',\r\n            'Like', 'CLike', 'NotLike', 'CNotLike', 'Match', 'CMatch', 'NotMatch', 'CNotMatch',\r\n            'Contains', 'CContains', 'NotContains', 'CNotContains',\r\n            'In', 'CIn', 'NotIn', 'CNotIn', 'Is', 'IsNot'\r\n        )\r\n        New-ParamSet @(\r\n            New-ParamSet @(\r\n                New-ParamSet @(\r\n                    New-Param 0 ([scriptblock]) FilterScript -Mandatory\r\n                    New-Param ([psobject]) InputObject\r\n                )\r\n            )\r\n            New-ParamSet @(\r\n                New-Param 0 ([string]) Property -Mandatory\r\n                New-ParamSet @(\r\n                    New-Param 1 ([object]) Value\r\n                    New-Param ([switch]) EQ\r\n                    New-Param ([psobject]) InputObject\r\n                )\r\n                foreach ($Operator in $MandatoryOperators) {\r\n                    New-ParamSet @(\r\n                        New-Param 1 ([object]) Value\r\n                        New-Param ([switch]) $Operator -Mandatory\r\n                        New-Param ([psobject]) InputObject\r\n                    )\r\n                }\r\n            )\r\n            New-ParamSet @(\r\n                New-Param 0 ([string]) Property -Mandatory\r\n                New-ParamSet @(\r\n                    New-Param ([switch]) Not -Mandatory\r\n                    New-Param ([psobject]) InputObject\r\n                )\r\n            )\r\n        )\r\n    }\r\n}\r\n```\r\n\r\n",
      "created_at": "2020-10-06T08:46:07Z",
      "updated_at": "2020-10-06T09:12:09Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Yeah, you can do that with `dynamicparam` but you wouldn't likely be able to do anything remotely similar if we had builtin syntax for this (good luck parsing that; it'd be insanely complicated to try to make that work in anything like a `param` block).\r\n\r\nAlso... just in general, dynamicparam tends to cause more problems that it solves, so IMO any design _based_ on it is generally best avoided (even when prototyping other designs). YMMV I suppose, but I don't think this is an approachable angle for users.",
      "created_at": "2020-10-06T12:03:02Z",
      "updated_at": "2020-10-06T12:03:02Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "> What about additional level? I mean an optional parameter could require some mandatory/optional subparameters.\r\n\r\nI have updated the module (see also below the design definitions) which allows a for the intuitive `dynamicparameter` statement:\r\n\r\n```PowerShell\r\nfunction Test {\r\n    [CmdletBinding()] param()\r\n    DynamicParam {\r\n        New-ParamSet @(\r\n            New-Param ([string]) Opt1\r\n            New-ParamSet @(\r\n                New-Param ([string]) Man1 -Mandatory\r\n                New-Param ([string]) Opt2\r\n            )\r\n        )\r\n    }\r\n}\r\n```\r\n### `Test -?`\r\n```PowerShell\r\nSYNTAX\r\n    Test -Man1 <string> [-Opt2 <string>] [-Opt1 <string>] [<CommonParameters>]\r\n    Test [-Opt1 <string>] [<CommonParameters>]\r\n```\r\n\r\n> And what about C# notation?\r\n\r\nUnfortunately, I do not have enough C# experience to comment on this.",
      "created_at": "2020-10-06T12:35:30Z",
      "updated_at": "2020-10-09T10:57:40Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "@vexx32 \r\n\r\n> you can do that with `dynamicparam` but you wouldn't likely be able to do anything remotely similar if we had builtin syntax for this.\r\n\r\nAgree, it is not in the intention to align the current `Param()` notation with the purpose. Besides, as already noted, that would require an engine update where the `dynamicparam` purpose might only require a module which could even supply some downward compatibility with older (Windows) PowerShell versions.\r\n\r\n> `dynamicparam` tends to cause more problems that it solves\r\n\r\nI don't think you can make a fair comparison (yet) between using the the current `Param()` notation and  `dynamicparam` scripting because there are currently no functions, cmdlets, frameworks (or provider), type accelerators, guidance, etc. to support the developers in using the `dynamicparam` section. There are only a few .Net constructors (which you need to tie together) to work with. The issue is that the current parameter notation is far from [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself), very verbose and not as lean as you might expect. For this reason, I guess that there are a lot of developers (including myself) that often just lump all parameters together and throw an error from within input processing methods when comes to an incorrect parameter constrain.",
      "created_at": "2020-10-06T12:51:41Z",
      "updated_at": "2020-10-06T13:58:52Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> I was thinking of throwing an error if there is a mandatory parameter in the subset and not in the parent but didn't implement this yet\r\n\r\nI'd expect symmetric behavior for all levels.\r\n\r\n> And what about C# notation?\r\n> Unfortunately, I do not have enough C# experience to comment on this.\r\n\r\nScript and binary developers should get the same capabilities otherwise your work will be only partial research.",
      "created_at": "2020-10-06T14:32:07Z",
      "updated_at": "2020-10-06T14:32:07Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "> I'd expect symmetric behavior for all levels.\r\n\r\nThat depends on the actual implementation. In this purpose, I trying to follow the syntax diagram\u00b9, where subsets (`...[...][...[...][...]]`) are *not* just extensions of the parent set but **exclusive** optional sets or in case *all* subsets contain at least one mandatory parameter, they are considered ***mutually* exclusive** sets\u00b2.\r\n\r\n1) Which the exception where it concerns the definition of a single parameter:\r\n    * An optional parameter `[MyParam]` is created like: `New-Param MyParam`\r\n    * A mandatory parameter `MyParam` is created like: `New-Param MyParam -Mandatory`\r\n\r\n<strike>2) If it just concerns a single subset, all of the containing parameters are simply added to the parent parameters (unsure about this as you might as well put all the parameters simply in the parent set. I need to give this some more thoughts).</strike>\r\n\r\n2) If it just concerns a _single_ subset:\r\n    * if the parent set doesn't contain any mandatory parameters, both the parent and subset are optional (where all mandatory parameters in the subset are required if any of the other parameters in the subset is used)\r\n    * If the parent set contains one or more mandatory parameters, the usage will be the same as when all parameters in the subset were directly put in the parent set.\r\n\r\nSee also below the design definitions and above reworked \"_What about additional level? I mean an optional parameter could require some mandatory/optional subparameters._\" answer to @iSazonov.",
      "created_at": "2020-10-06T15:51:34Z",
      "updated_at": "2020-10-09T10:57:12Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "I have updated the [prototype module](https://github.com/iRon7/Hierarchical-Parameter-Scripting) to better support optional parameters (see the updated answer to @iSazonov \"_an optional parameter could require some mandatory/optional subparameters_\" comment) which also results in a more symmetric behavior (see the updated answer to @vex32 \"_I'd expect symmetric behavior for all levels_\" comment).\r\n\r\n## (Sub)set design\r\nBelow is the description how the `ParameterSetName` of each parameter is set with respect to their (sub)set containers.\r\n\r\n* If there is no `SetName` supplied, the `ParameterSetName`  is initially set to `'0'` (a string containing a zero).\r\n* The `SetName` is added to:\r\n    * the `ParameterSetName` attribute of each optional parameter\r\n    * the `ParameterSetName` attribute of each mandator parameter _unless the set also contains subsets_\r\n* In case of a subset, the `ParameterSetName` of the each attribute of each containing parameter is prefixed `SetName` (or `'0'`, if no setname is supplied) separated by a dot `'.'`.\r\n    * Any `ParameterSetName` parameter attribute in a subset that is already prefixed with a `'0'` (e.g. `'0.1'`) will get a new unique index prefix (e.g. `'1.1'`). In the case of a _named_ subset, the developer is responsible to supply unique names for each subset.\r\n\r\nNote that with each subset iteration, the whole parameter set (including the containing parameter attributes) is cloned. This is to support parameter sets supplied in variable (which eventually require an unique `ParameterSetName`).\r\n\r\n## (Sub)set usage:\r\nThe basic idea of this purpose is to follow the standard parameter syntax diagram similar to the Help (`-?`) syntax output..\r\n\r\n* There is one exception where it concerns the definition of a _single_ parameter:\r\n    * An optional parameter `[MyParam]`, is created like: `New-Param MyParam`\r\n    * A mandatory parameter `MyParam`, is created like: `New-Param MyParam -Mandatory`\r\n\r\n* Every parameter subset is **exclusive**\r\n  This means that a user can select a specific subset (and supply the contained mandatory parameters) but _can't_ choose parameters out of different subsets\r\n    * If the parent set and _all_ subsets contain at least one mandatory parameter, the parameter subset is **mutually exclusive**\r\n    This means that a user _must_ choose one specific subset\r\n    * If the parent set or one of the subsets contain _only_ optional parameters the parameter subset is an **exclusive choose**\r\n    This means that the user _might_ choose one subset (or none of the subsets)\r\n\r\n* The user is required to supply both mandatory parameters of the selected subset and the mandatory parameters of its parent set.\r\n",
      "created_at": "2020-10-09T10:57:06Z",
      "updated_at": "2020-10-13T10:46:37Z"
    }
  ],
  "created_at": "2020-10-05T15:43:11Z",
  "labels": [
    "Issue-Enhancement",
    "WG-Engine"
  ],
  "number": 13746,
  "state": "open",
  "title": "Hierarchical Parameter Scripting",
  "updated_at": "2021-09-02T16:43:31Z"
}