{
  "_url": "https://github.com/PowerShell/PowerShell/issues/17460",
  "author": "dkattan",
  "body": "<!-- Anything that looks like this is a comment and can't be seen after the Pull Request is created. -->\r\n\r\n# PR Summary\r\n\r\nImplements #8651\r\n\r\nAdds constructor to ValidateSetAttribute that accepts a ScriptBlock. \r\n\r\nAdds logic that evaluates the ScriptBlock when ValidValues is accessed\r\n\r\nAdds logic to Compiler.cs that detects the presence of a ScriptBlock and uses the new constructor\r\n\r\nAdds test to TabCompletion.Tests.ps1 to verify functionality\r\n\r\n## PR Context\r\n\r\nI would like to be able to have dynamic parameter values self-contained in a function definition.\r\n\r\n## PR Checklist\r\n\r\n- [x] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [x] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` or `[ WIP ]` to the beginning of the title (the `WIP` bot will keep its status check at `Pending` while the prefix is present) and remove the prefix when the PR is ready.\r\n- **[Breaking changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)**\r\n    - [x] None\r\n    - **OR**\r\n    - [ ] [Experimental feature(s) needed](https://github.com/MicrosoftDocs/PowerShell-Docs/blob/main/reference/7.3/Microsoft.PowerShell.Core/About/about_Experimental_Features.md)\r\n        - [ ] Experimental feature name(s): <!-- Experimental feature name(s) here -->\r\n- **User-facing changes**\r\n    - [ ] Not Applicable\r\n    - **OR**\r\n    - [x] [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n- **Testing - New and feature**\r\n    - [ ] N/A or can only be tested interactively\r\n    - **OR**\r\n    - [x] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n- **Tooling**\r\n    - [x] I have considered the user experience from a tooling perspective and don't believe tooling will be impacted.\r\n    - **OR**\r\n    - [ ] I have considered the user experience from a tooling perspective and opened an issue in the relevant tool repository. This may include:\r\n        - [ ] Impact on [PowerShell Editor Services](https://github.com/PowerShell/PowerShellEditorServices) which is used in the [PowerShell extension](https://github.com/PowerShell/vscode-powershell) for VSCode\r\n        (which runs in a different PS Host).\r\n            - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n        - [ ] Impact on Completions (both in the console and in editors) - one of PowerShell's most powerful features.\r\n            - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n        - [ ] Impact on [PSScriptAnalyzer](https://github.com/PowerShell/PSScriptAnalyzer) (which provides linting & formatting in the editor extensions).\r\n            - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n        - [ ] Impact on [EditorSyntax](https://github.com/PowerShell/EditorSyntax) (which provides syntax highlighting with in VSCode, GitHub, and many other editors).\r\n            - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n",
  "closed_at": "2022-06-24T19:41:19Z",
  "comments": [
    {
      "author": "dkattan",
      "author_association": "NONE",
      "body": "I'm thinking about this, and it appears that we don't get access to other parameters that may be specified which would be the next logical thing you would want to have in the script block. \r\n\r\n@iSazonov How would you feel about providing the ScriptBlock parameters similar to that of ArgumentCompleter?\r\n\r\nparam ( $commandName,\r\n                    $parameterName,\r\n                    $wordToComplete,\r\n                    $commandAst,\r\n                    $fakeBoundParameters )\r\n\r\n\r\n\r\n",
      "created_at": "2022-05-31T19:47:20Z",
      "updated_at": "2022-05-31T19:47:20Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@dkattan Could you please share demo script?",
      "created_at": "2022-06-01T03:23:59Z",
      "updated_at": "2022-06-01T03:23:59Z"
    },
    {
      "author": "dkattan",
      "author_association": "NONE",
      "body": "> @dkattan Could you please share demo script?\r\n\r\nInspired by the sample for ArgumentCompleters:\r\nhttps://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_argument_completion?view=powershell-7.2#argumentcompleter-script-block\r\n\r\n```powershell\r\nfunction Test-DynamicValidateSet {\r\n[CmdletBinding()]\r\n param (\r\n        [Parameter(Mandatory=$true)]\r\n        [ValidateSet('Fruits', 'Vegetables')]\r\n        $Type,\r\n\r\n        [Parameter(Mandatory=$true)]\r\n        [ValidateSet({ \r\n            param ( $commandName,\r\n            $parameterName,\r\n            $commandAst,\r\n            $fakeBoundParameters )\r\n\r\n            $possibleValues = @{\r\n                Fruits = @('Apple', 'Orange', 'Banana')\r\n                Vegetables = @('Tomato', 'Squash', 'Corn')\r\n            }\r\n\r\n            if ($fakeBoundParameters.ContainsKey('Type')) {\r\n                $possibleValues[$fakeBoundParameters.Type]\r\n            } else {\r\n                $possibleValues.Values | ForEach-Object {$_}\r\n            }\r\n        })]\r\n        $Value\r\n      )\r\n}\r\n\r\nTest-DynamicValidateSet -Type Fruits -Value \r\n````\n\n<blockquote><img src=\"https://docs.microsoft.com/media/logos/logo-powershell-social.png\" width=\"48\" align=\"right\"><div><strong><a href=\"https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_argument_completion\">About functions argument completion - PowerShell</a></strong></div><div>Explains the various argument completion options available for function parameters.</div></blockquote>",
      "created_at": "2022-06-01T13:21:46Z",
      "updated_at": "2022-06-01T13:21:49Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> @iSazonov How would you feel about providing the ScriptBlock parameters similar to that of ArgumentCompleter?\r\n\r\nValidation based on other parameters would rely on the order that parameters are bound in. I believe that order is currently documented as undefined (or maybe undocumented).\r\n",
      "created_at": "2022-06-01T17:04:57Z",
      "updated_at": "2022-06-01T17:04:57Z"
    },
    {
      "author": "dkattan",
      "author_association": "NONE",
      "body": "> > @iSazonov How would you feel about providing the ScriptBlock parameters similar to that of ArgumentCompleter?\r\n> \r\n> Validation based on other parameters would rely on the order that parameters are bound in. I believe that order is currently documented as undefined (or maybe undocumented).\r\n\r\nI think that's why they chose to call it \"fakeBoundParameters\" in the ArgumentCompleter implementation. It does a pseudo-binding that seems to be best effort, which is good enough for most cases.\r\n",
      "created_at": "2022-06-01T17:51:38Z",
      "updated_at": "2022-06-01T17:51:38Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> I think that's why they chose to call it \"fakeBoundParameters\" in the ArgumentCompleter implementation. It does a pseudo-binding that seems to be best effort, which is good enough for most cases.\r\n\r\nYeah it's called that because binding hasn't happened yet, it's all based on statically inferred values. Best effort makes perfect sense for argument completion, but for actual binding time validation I don't think we want to surface something that inconsistent.",
      "created_at": "2022-06-02T14:23:15Z",
      "updated_at": "2022-06-02T14:23:15Z"
    },
    {
      "author": "dkattan",
      "author_association": "NONE",
      "body": "> ```powershell\r\n> function Test-DynamicValidateSet {\r\n> [CmdletBinding()]\r\n>  param (\r\n>         [Parameter(Mandatory=$true)]\r\n>         [ValidateSet('Fruits', 'Vegetables')]\r\n>         $Type,\r\n> \r\n>         [Parameter(Mandatory=$true)]\r\n>         [ValidateSet({ \r\n>             param ( $commandName,\r\n>             $parameterName,\r\n>             $commandAst,\r\n>             $fakeBoundParameters )\r\n> \r\n>             $possibleValues = @{\r\n>                 Fruits = @('Apple', 'Orange', 'Banana')\r\n>                 Vegetables = @('Tomato', 'Squash', 'Corn')\r\n>             }\r\n> \r\n>             if ($fakeBoundParameters.ContainsKey('Type')) {\r\n>                 $possibleValues[$fakeBoundParameters.Type]\r\n>             } else {\r\n>                 $possibleValues.Values | ForEach-Object {$_}\r\n>             }\r\n>         })]\r\n>         $Value\r\n>       )\r\n> }\r\n> \r\n> Test-DynamicValidateSet -Type Fruits -Value \r\n> ```\r\n\r\nThis is beginning to make sense. In order for this to work the way I want it to work I'd need to introduce a \"DelayedValidation\" feature that waits for all the parameters to be bound and then passes in the bound parameters to the ScriptBlock.\r\n\r\nThen what happens if multiple parameters are awaiting validation? \r\n\r\nThis is getting deep fast.\r\n\r\nI'm going to revert the parameter change so we can at least get the basic functionality working.\r\n\r\nIf someone needs access to data in the runspace, they can always declare global variables that would be equally available to both ArgumentCompleters and ValidateSet. \r\n\r\n\r\n",
      "created_at": "2022-06-02T16:43:23Z",
      "updated_at": "2022-06-02T16:43:23Z"
    },
    {
      "author": "pull-request-quantifier[bot]",
      "author_association": "NONE",
      "body": "### ![](https://img.shields.io/static/v1?label=Quantified&message=Extra%20Small&color=green)\r\n\r\nThis PR has `27` quantified lines of changes. In general, a change size of upto `200` lines is ideal for the best PR experience!\r\n\r\n------\r\n\r\n<details >\r\n    <summary display=\"inline\"> <strong>Quantification details</strong></summary>\r\n    <p />\r\n\r\n```\r\nLabel      : Extra Small\r\nSize       : +26 -1\r\nPercentile : 10.8%\r\n\r\nTotal files changed: 3\r\n\r\nChange summary by file extension:\r\n.cs : +19 -1\r\n.ps1 : +7 -0\r\n```\r\n> Change counts above are quantified counts, based on the [PullRequestQuantifier customizations](https://github.com/microsoft/PullRequestQuantifier/blob/main/docs/prquantifier-yaml.md).\r\n    \r\n</details>\r\n\r\n\r\n<details>\r\n    <summary display=\"inline\"> <strong>Why proper sizing of changes matters</strong> </summary>\r\n    <p/>\r\n    <p/>\r\n\r\nOptimal pull request sizes drive a better predictable PR flow as they strike a\r\nbalance between between PR complexity and PR review overhead. PRs within the\r\noptimal size (typical small, or medium sized PRs) mean:\r\n\r\n- Fast and predictable releases to production:\r\n  - Optimal size changes are more likely to be reviewed faster with fewer\r\niterations.\r\n  - Similarity in low PR complexity drives similar review times.\r\n- Review quality is likely higher as complexity is lower:\r\n  - Bugs are more likely to be detected.\r\n  - Code inconsistencies are more likely to be detetcted.\r\n- Knowledge sharing is improved within the participants:\r\n  - Small portions can be assimilated better.\r\n- Better engineering practices are exercised:\r\n  - Solving big problems by dividing them in well contained, smaller problems.\r\n  - Exercising separation of concerns within the code changes.\r\n\r\n#### What can I do to optimize my changes\r\n\r\n- Use the PullRequestQuantifier to quantify your PR accurately\r\n  - Create a context profile for your repo using the [context generator](https://github.com/microsoft/PullRequestQuantifier/releases)\r\n  - Exclude files that are not necessary to be reviewed or do not increase the review complexity. Example: Autogenerated code, docs, project IDE setting files, binaries, etc. Check out the `Excluded` section from your `prquantifier.yaml` context profile. \r\n  - Understand your typical change complexity, drive towards the desired complexity by adjusting the label mapping in your `prquantifier.yaml` context profile.\r\n  - Only use the labels that matter to you, [see context specification](./docs/prquantifier-yaml.md) to customize your `prquantifier.yaml` context profile.\r\n- Change your engineering behaviors\r\n  - For PRs that fall outside of the desired spectrum, review the details and check if:\r\n    - Your PR could be split in smaller, self-contained PRs instead\r\n    - Your PR only solves one particular issue. (For example, don't refactor and code new features in the same PR).\r\n\r\n#### How to interpret the change counts in git diff output\r\n\r\n- One line was added: `+1 -0`\r\n- One line was deleted: `+0 -1`\r\n- One line was modified: `+1 -1` (git diff doesn't know about modified, it will\r\ninterpret that line like one addition plus one deletion)\r\n- Change percentiles: Change characteristics (addition, deletion, modification)\r\nof this PR in relation to all other PRs within the repository.\r\n\r\n</details>\r\n\r\n<p />\r\n\r\n------\r\n\r\nWas this comment helpful? <a href=\"https://pullrequestquantifierfeedback.azurewebsites.net/feedback?payload=eyJBdXRob3JOYW1lIjoiZGthdHRhbiIsIlJlcG9zaXRvcnlMaW5rIjoiaHR0cHM6Ly9naXRodWIuY29tL1Bvd2VyU2hlbGwvUG93ZXJTaGVsbCIsIlB1bGxSZXF1ZXN0TGluayI6Imh0dHBzOi8vZ2l0aHViLmNvbS9Qb3dlclNoZWxsL1Bvd2VyU2hlbGwvcHVsbC8xNzQ2MCIsIkV2ZW50VHlwZSI6IlRodW1ic1VwIn0=&amp;anonymous=True\" target=\"_blank\" title=\"Thumbs up\"><strong>:thumbsup:</strong></a> <a href=\"https://pullrequestquantifierfeedback.azurewebsites.net/feedback?payload=eyJBdXRob3JOYW1lIjoiZGthdHRhbiIsIlJlcG9zaXRvcnlMaW5rIjoiaHR0cHM6Ly9naXRodWIuY29tL1Bvd2VyU2hlbGwvUG93ZXJTaGVsbCIsIlB1bGxSZXF1ZXN0TGluayI6Imh0dHBzOi8vZ2l0aHViLmNvbS9Qb3dlclNoZWxsL1Bvd2VyU2hlbGwvcHVsbC8xNzQ2MCIsIkV2ZW50VHlwZSI6Ik5ldXRyYWwifQ==&amp;anonymous=True\" target=\"_blank\" title=\"Neutral\"><strong>&nbsp;:ok_hand:</strong></a> <a href=\"https://pullrequestquantifierfeedback.azurewebsites.net/feedback?payload=eyJBdXRob3JOYW1lIjoiZGthdHRhbiIsIlJlcG9zaXRvcnlMaW5rIjoiaHR0cHM6Ly9naXRodWIuY29tL1Bvd2VyU2hlbGwvUG93ZXJTaGVsbCIsIlB1bGxSZXF1ZXN0TGluayI6Imh0dHBzOi8vZ2l0aHViLmNvbS9Qb3dlclNoZWxsL1Bvd2VyU2hlbGwvcHVsbC8xNzQ2MCIsIkV2ZW50VHlwZSI6IlRodW1ic0Rvd24ifQ==&amp;anonymous=True\" target=\"_blank\" title=\"Thumbs down\"><strong>&nbsp;:thumbsdown:</strong></a> (<a href=\"MAILTO:prquantifier@microsoft.com\" title=\"Mail to prquantifier@microsoft.com\">Email</a>)\r\n[Customize PullRequestQuantifier](https://github.com/PowerShell/PowerShell/blob/master/.github/prquantifier.yaml) for this repository.\r\n\r\n",
      "created_at": "2022-06-02T16:48:55Z",
      "updated_at": "2022-06-02T16:48:55Z"
    },
    {
      "author": "dkattan",
      "author_association": "NONE",
      "body": "@SeeminglyScience  @iSazonov  I've reverted the change. How are you guys feeling about this PR?",
      "created_at": "2022-06-02T16:51:01Z",
      "updated_at": "2022-06-02T16:51:01Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> @SeeminglyScience @iSazonov I've reverted the change. How are you guys feeling about this PR?\r\n\r\nIt is question for WG. The PR is implementing initial proposal from #3744 but the discussion in #3744 was finished with the conclusion that we need a consistency with binary cmdlets and as result we implemented IValidateSetValuesGenerator in #3784. ( Clearly, this is not very convenient to use in scripts. We could discuss this in #8651)\r\nSo we need a review from WG-Engine before we can continue.",
      "created_at": "2022-06-02T17:42:07Z",
      "updated_at": "2022-06-02T17:42:07Z"
    },
    {
      "author": "dkattan",
      "author_association": "NONE",
      "body": "Dumb question, what\u2019s WG?",
      "created_at": "2022-06-02T22:40:13Z",
      "updated_at": "2022-06-02T22:40:13Z"
    },
    {
      "author": "dkattan",
      "author_association": "NONE",
      "body": "> Dumb question, what\u2019s WG?\r\n\r\nNevermind, I Googled it\r\n\r\nhttps://github.com/PowerShell/PowerShell/blob/master/docs/community/working-group-definitions.md\n\n<blockquote><img src=\"https://repository-images.githubusercontent.com/49609581/aad0ad80-cdec-11ea-8248-a37bc0571bfd\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/PowerShell/PowerShell\">PowerShell/working-group-definitions.md at master \u00b7 PowerShell/PowerShell</a></strong></div><div>PowerShell for every system! Contribute to PowerShell/PowerShell development by creating an account on GitHub.</div></blockquote>",
      "created_at": "2022-06-02T22:52:48Z",
      "updated_at": "2022-06-02T22:52:50Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@vexx32 Could you add this in WG plan?",
      "created_at": "2022-06-03T03:13:27Z",
      "updated_at": "2022-06-03T03:13:27Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as Review Needed because it has been there has not been any activity for **7 days**.\nMaintainer, please provide feedback and/or mark it as `Waiting on Author`",
      "created_at": "2022-06-10T14:01:14Z",
      "updated_at": "2022-06-10T14:01:14Z"
    },
    {
      "author": "dkattan",
      "author_association": "NONE",
      "body": "> @vexx32 Could you add this in WG plan?\r\n\r\nHey @vexx32 Any updates/eta?",
      "created_at": "2022-06-16T16:39:03Z",
      "updated_at": "2022-06-16T16:39:03Z"
    },
    {
      "author": "dkattan",
      "author_association": "NONE",
      "body": "@vexx32 @iSazonov Any updates?",
      "created_at": "2022-06-24T15:25:36Z",
      "updated_at": "2022-06-24T15:25:36Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "The Engine-WG discussed this yesterday and we've found a few issues with this concept that will not be easily solvable.\r\n\r\n1. Accepting a `ScriptBlock` here will imply the UX of generation based on supplied value, e.g. `$_`. I know your original draft did do something like this and it was changed based on feedback, but the implication will still be there.\r\n2. When this attribute is applied within a module, the `ScriptBlock` invoked will not be invoked in the correct session state. This is already a problem with `ArgumentCompleterAttribute`, but we do not want to add additional features with the same problem until we have a solution.\r\n\r\nWhen the latter issue is resolved, the language WG should revisit the former and determine if there is a feasible design.",
      "created_at": "2022-06-24T18:26:13Z",
      "updated_at": "2022-06-24T18:26:13Z"
    },
    {
      "author": "dkattan",
      "author_association": "NONE",
      "body": "@SeeminglyScience I\u2019d be happy to work on the module context issue. \r\n\r\nMy end game is to create a UX similar to Show-Command but for the web. My project (immy.bot) is very tightly integrated with PowerShell with custom PSHosts that push Write-Progress to progress bars in the interface, for example.\r\n\r\nWe already have static forms where you can create parameters for scripts, but it gets rather clunky when the need for parameter sets arise.\r\n\r\nRather than reinvent the dynamic forms wheel, my thought was to simply parse the params block of the script and save parameter values as a hashtable that can splatted on to the script in question and PowerShell can handle the binding.\r\n\r\nObviously this can be done without the feature in the PR, however the primary use case for me does require it, I\u2019ll elaborate.\r\n\r\nMy application installs software on computers based on the user you select. Users are dynamically retrieved from AzureAD. This is currently implemented in C#, but to offer maximum flexibility I\u2019d like to move this logic into PowerShell so users can define their own behavior.\r\n\r\nNow I suppose I could implement dynamic parameters, assuming that works with Show-Command/Get-Command the syntax is just very cumbersome.\r\n\r\nI\u2019d rather keep everything in a scriptblock and simply call Get-AzureADUser.\r\n\r\nANYWAY, if you wouldn\u2019t mind, can you elaborate on the issue with module context?  Is it related to how modules imported using InitialSessionState.ImportPSModuleFromPath are not bound by constrained language mode?",
      "created_at": "2022-06-25T12:59:40Z",
      "updated_at": "2022-06-25T13:00:19Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I think this requires the implementation of _stateless_ script block. Theoretically it is possible, but in fact it may be difficult to implement, and most importantly lead to negative consequences for PowerShell language as a whole.",
      "created_at": "2022-06-25T17:00:16Z",
      "updated_at": "2022-06-25T17:00:16Z"
    },
    {
      "author": "dkattan",
      "author_association": "NONE",
      "body": "> I think this requires the implementation of _stateless_ script block. Theoretically it is possible, but in fact it may be difficult to implement, and most importantly lead to negative consequences for PowerShell language as a whole.\r\n\r\nCan you give me an example on what sort of negative consequences this would have on the language as a whole? ",
      "created_at": "2022-06-25T17:38:09Z",
      "updated_at": "2022-06-25T17:38:09Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Today any scriptblock exists and run only in one runspace. This is how PowerShell works. \r\nIf this principle is abandoned completely, it will be a completely different language. If partially, it could lead to chaos.",
      "created_at": "2022-06-26T16:26:44Z",
      "updated_at": "2022-06-26T16:26:44Z"
    },
    {
      "author": "dkattan",
      "author_association": "NONE",
      "body": "It sounds like the concern is that the implementation of a stateless script block (which I\u2019m interpreting as being a purely functional/isolated script block similar to a static method in C#) would violate the one runspace paradigm of PowerShell. I could argue that by bringing up implicit remoting for Windows PowerShell compatibility or PS Remoting in general, but I\u2019d rather try to understand why you think a stateless scriptblock is necessary in the first place?\r\n\r\nIf not for me, for potential future readers who want to fully understand. \r\n\r\nAnd also, help me understand the existing problems with Modules\r\n\r\nI really am trying to understand this at a deeper level, not trying to be difficult. I appreciate the time you\u2019ve already put into this.",
      "created_at": "2022-06-26T17:05:03Z",
      "updated_at": "2022-06-26T17:05:03Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "In remoting PowerShell doesn't send scriptblock, it send _text_. Also there is 1-to-1 mapping local to remote runspace.\r\nI think the main problem is how users perceive it. On the one hand they would like to make the script code independent. On the other hand it is always required to run it in some context. PowerShell historically has a solution. For example, a module has its own context. This is what the module concept exists for. It's simple and it's understandable to users. If we allow an exception, there must be an idea behind it that everyone understands. What I mean by that is that the design of the language should change.\r\n\r\nI don't know what else to add. :-)",
      "created_at": "2022-06-26T17:51:57Z",
      "updated_at": "2022-06-26T17:52:13Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> I think this requires the implementation of _stateless_ script block.\r\n\r\nSorry I think there was a misunderstanding. It just needs the right state, it doesn't need to (and shouldn't) be stateless.\r\n\r\n@dkattan a quick way to demo what I'm talking about:\r\n\r\n```powershell\r\nNew-Module {\r\n    $ModuleScopedVar = 'one', 'two'\r\n\r\n    function Test-Command {\r\n        [CmdletBinding()]\r\n        param(\r\n            [ArgumentCompleter({ $script:ModuleScopedVar })]\r\n            [string] $Name\r\n        )\r\n    }\r\n} | Import-Module\r\n```\r\n\r\nThere are workarounds but this is already a huge UX issue that comes up often on the discord. Unfortunately it wasn't caught (or maybe the impact wasn't realized) for `ArgumentCompleter`, but until it's solved we should avoid adding more things with the same behavior.\r\n\r\n**Edit:**\r\n\r\n> ANYWAY, if you wouldn\u2019t mind, can you elaborate on the issue with module context? Is it related to how modules imported using InitialSessionState.ImportPSModuleFromPath are not bound by constrained language mode?\r\n\r\n^ that's also a good point, language mode is also unlikely to be propagated.",
      "created_at": "2022-06-26T18:03:19Z",
      "updated_at": "2022-06-26T18:06:33Z"
    },
    {
      "author": "dkattan",
      "author_association": "NONE",
      "body": "@SeeminglyScience that example helped tremendously. \r\n\r\nTo better illustrate the problem, I created a variable with the same name with value three, four and it tab completes three,four instead of one,two\r\n\r\nIt seems like the problem is that CompleteInput not taking into consideration that Test-Command is defined in a module and therefore shouldn\u2019t have access to variables in the script scope.\r\n\r\nIf I had to create an issue, it would be \u201cResults of CompleteInput in modules potentially affected by variables defined in parent runspace\u201d\r\n\r\nI understand now that if we allow ValidateSet to be dynamic and not a constant it would have the same problem.\r\n\r\nAlso, do DynamicParameters have the same problem? I\u2019ll test shortly.\r\n\r\nI have no issue using DynamicParameters for my use case, but I\u2019m afraid I won\u2019t be able to instantiate the required types in Constrained Language mode. (The scripts in my application all run in Constrained Language mode)\r\n\r\nI suppose I could inject custom Cmdlets that instantiate these objects from C# as a workaround.",
      "created_at": "2022-06-26T19:49:46Z",
      "updated_at": "2022-06-26T19:49:46Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Sorry I think there was a misunderstanding. It just needs the right state, it doesn't need to (and shouldn't) be stateless.\r\n\r\nYes, you mean rather \"scope,\" I mean \"sessionstate\".\r\nI suspect the problem with variable propagation like `$ErrorActionPreference` is of the same nature. This makes me think that the flexible solution could be rather related to \"sessionstate\" (which would certainly in turn be a means of manipulating scopes).\r\n",
      "created_at": "2022-06-27T06:47:53Z",
      "updated_at": "2022-06-27T06:47:53Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> It seems like the problem is that CompleteInput not taking into consideration that Test-Command is defined in a module and therefore shouldn\u2019t have access to variables in the script scope.\r\n\r\nIt's more that the `ScriptBlock` is created in a way that `ScriptBlock.SessionStateInternal` is not populated. When that is null, it implicitly takes on the state in `ExecutionContext.EngineSessionState` (whatever was last running at the time).\r\n\r\nCuriously, `ValidateScript` does not have this problem. I'm unsure if it's explicitly special cased, or if it *happens* to work based on when the script is invoked. Either way worth looking into.\r\n\r\n> Also, do DynamicParameters have the same problem? I\u2019ll test shortly.\r\n\r\nThey do not! Neither does `ValidateScript` or `Register-ArgumentCompleter` (the pair of them is what I'd recommend you use to implement this feature in the mean time).\r\n",
      "created_at": "2022-06-27T16:27:12Z",
      "updated_at": "2022-06-27T16:27:12Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> Yes, you mean rather \"scope,\" I mean \"sessionstate\". I suspect the problem with variable propagation like `$ErrorActionPreference` is of the same nature. This makes me think that the flexible solution could be rather related to \"sessionstate\" (which would certainly in turn be a means of manipulating scopes).\r\n\r\n`SessionState` is what I'm referring to when I say state, sorry if that was unclear.",
      "created_at": "2022-06-27T16:27:57Z",
      "updated_at": "2022-06-27T16:27:57Z"
    }
  ],
  "created_at": "2022-05-30T16:11:41Z",
  "number": 17460,
  "state": "closed",
  "title": "Implemented ScriptBlock support for ValidateSet",
  "updated_at": "2022-06-27T16:27:58Z"
}