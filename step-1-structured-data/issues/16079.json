{
  "_url": "https://github.com/PowerShell/PowerShell/issues/16079",
  "author": "aolszowka",
  "body": "### Summary of the new feature / enhancement\n\nI would like the ability to mark a function as a candidate for JIT prior to execution.\r\n\r\n## Use Case\r\nI have a tight loop that calls 5 different methods to perform various parsing functions, most of these involve some type of string manipulation.\r\n\r\nIn benchmarking these functions (using `Measure-Command`) it is found that on the first run each run of the loop takes approximately 2 milliseconds on my i7-9850H. That might not sound like a whole lot, but this loop is called approximately 30,000 times which results in a runtime of about a minute.\r\n\r\nOn a second run though (without any code changes) this code runs much faster, about .5 millseconds per loop which results in a runtime of about 15 seconds.\r\n\r\nUnfortunately I am unable to share the exact code, and I have had a difficult time creating a small reproducing test case that shows the drastic time differences.\r\n\r\n## Research\r\nIt is believed that the reason for the differences in runtime is due to the PowerShell Runtime JIT'ing the code in question. There doesn't appear to be any MSDN Documentation on this behavior, rather there are several posts on StackOverflow that describe this:\r\n\r\nhttps://stackoverflow.com/questions/34202462/does-powershell-compile-scripts\r\n\r\nhttps://stackoverflow.com/questions/54434601/powershell-functions-and-performance\r\n\r\nHowever none of these seem to describe any method to try and mark the function as hot to give a hint to the runtime to more eagerly attempt to JIT this.\r\n\r\nThe ask is two fold:\r\n\r\n1. A way to indicate that this function should be optimized as soon as possible\r\n2. Documentation on the JIT behavior\n\n### Proposed technical implementation details (optional)\n\n_No response_",
  "closed_at": null,
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> I would like the ability to mark a function as a candidate for JIT prior to execution.\r\n\r\nYou could try PowerShell classes.",
      "created_at": "2021-09-10T13:31:20Z",
      "updated_at": "2021-09-10T13:31:20Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "The Engine WG discussed this issue today. While there is a continuing desire to improve PowerShell performance, this scenario is not a priority for the team at the moment.  However, we believe there is existing infrastructure support e.g. `CompileInterpretChoice.AlwaysCompile` that \"might\" make this easy for the community to implement as an \"up-for-grabs\" experimental feature. \r\n\r\nWe would appreciate having a repeatable repro script to help evaluate this scenario in terms of such an experimental feature. And with a repro script, we may be able to profile it at a lower-level to determine the root of the perf issue.  \r\n\r\nThe issue you mention about lack of docs on JIT behavior, should be filed in the [PowerShell-Docs repo](https://github.com/MicrosoftDocs/PowerShell-Docs/issues).  BTW the experimental feature should provide some basic documentation on when the feature should and should not be used.",
      "created_at": "2021-09-17T00:35:34Z",
      "updated_at": "2021-09-17T00:36:28Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> However, we believe there is existing infrastructure support e.g. `CompileInterpretChoice.AlwaysCompile` that \"might\" make this easy for the community to implement as an \"up-for-grabs\" experimental feature.\r\n\r\nOh, currently there is a well perf balance in PowerShell with heuristics  when compile + internal caches vs interpret. It's non-trivial to keep that equilibrium.\r\nPerhaps we could benefit from the modern capabilities of the .Net jitting.",
      "created_at": "2021-09-17T03:24:54Z",
      "updated_at": "2021-09-17T03:26:52Z"
    },
    {
      "author": "aolszowka",
      "author_association": "NONE",
      "body": "Well if @rkeithhill is going to take the time to respond to me, then I got to deliver!\r\n\r\nHere's a sanitized version of the script that has been stripped of a bunch of extra stuff but still shows the issue pretty well.\r\n\r\nThe actual version actually plays a bunch of games with dumping each of those `# Calculate` sections into a private function declared in the `begin` block, but this version was an attempt of mine to \"inline\" as much of this while still keeping it somewhat readable:\r\n\r\n```powershell\r\nfunction Get-BusinessObject {\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateNotNullOrEmpty()]\r\n        [String]$INIPath,\r\n        [ValidateNotNullOrEmpty()]\r\n        [String]$Identifier\r\n    )\r\n    process {\r\n        [Hashtable]$List = $null\r\n        [Hashtable]$List = Get-INIContent -FilePath $INIPath\r\n\r\n        $List.Remove('General')\r\n        [String[]]$Keys = $List.Keys\r\n        [System.Collections.Generic.List[PSCustomObject]]$businessObjectRecords = @()\r\n\r\n        $shouldFilterByIdentifier = $false\r\n        if ( !([String]::IsNullOrEmpty($Identifier)) ) {\r\n            $shouldFilterByIdentifier = $true\r\n        }\r\n\r\n        foreach ($Key in $Keys) {\r\n            $clientId = $List.$Key.DatabaseName.Split('_')[1]\r\n            $shouldProcessRecord = $true\r\n\r\n            if ($shouldFilterByIdentifier -and $clientId -ne $Identifier) {\r\n                $shouldProcessRecord = $false\r\n            }\r\n\r\n            if ($shouldProcessRecord) {\r\n\r\n                ################################################################\r\n                # Calculate SQL Server\r\n                ################################################################\r\n                $SQLServer = $List.$Key.ServerName\r\n\r\n\r\n                if ($SQLServer -like '*SQL*') {\r\n                    $SQLServer = $SQLServer -replace 'SQL', 'DB'\r\n                }\r\n\r\n                if ($SQLServer.Contains('\\') -eq $true) {\r\n                    $SQLServer = $SQLServer.Split('\\')[0]\r\n                }\r\n\r\n                if ($SQLServer -like '*AGL*') {\r\n                    $SQLServer = $SQLServer -replace 'AGL', 'DBS'\r\n                }\r\n\r\n                if ($SQLServer.Contains(',') -eq $true) {\r\n                    $SQLServer = $SQLServer.Split(',')[0]\r\n                }\r\n\r\n                ################################################################\r\n                # Calculate Datacenter\r\n                ################################################################\r\n                [String]$Datacenter = 'UNKNOWN'\r\n\r\n                if ($SQLServer -like 'ABC03Z*' -or $SQLServer -like 'ABC3Z*') {\r\n                    [String]$Datacenter = 'ABC'\r\n                }\r\n                elseif ($SQLServer -like 'DEF02*' -or $SQLServer -like 'DEF2*') {\r\n                    [String]$Datacenter = 'DEF'\r\n                }\r\n                elseif ($SQLServer -like 'GHI05*' -or $SQLServer -like 'GHI5*') {\r\n                    [String]$Datacenter = 'GHI'\r\n                }\r\n                elseif ($SQLServer -like 'JKL4*') {\r\n                    [String]$Datacenter = 'JKL'\r\n                }\r\n                elseif ($SQLServer -like 'MNO07*') {\r\n                    [String]$Datacenter = 'MNO'\r\n                }\r\n                else {\r\n                    [String]$Datacenter = 'PQR'\r\n                }\r\n\r\n                ################################################################\r\n                # Calculate Database Display Name\r\n                ################################################################\r\n                $DatabaseDisplayName = $List.$Key.Description\r\n                if ($DatabaseDisplayName.Contains([char]0xFFFD)) {\r\n                    $replacementForS = \"$([char]0xFFFD)s\"\r\n                    $DatabaseDisplayName = $DatabaseDisplayName.Replace($replacementForS, \"'s\")\r\n                    $DatabaseDisplayName = $DatabaseDisplayName.Replace([char]0xFFFD, '-')\r\n                }\r\n\r\n                ################################################################\r\n                # Calculate Product\r\n                ################################################################\r\n                $Product = $List.$Key.DatabaseName.Split('_')[0]\r\n                if ($Product -eq 'AB8') {\r\n                    $Product = 'AB'\r\n                }\r\n\r\n                $currentBusinessObject = [PSCustomObject] @{\r\n                    ClientID            = $clientId\r\n                    SQLServer           = $SQLServer\r\n                    SQLInstance         = $List.$Key.ServerName\r\n                    DatabaseName        = $List.$Key.DatabaseName\r\n                    DatabaseDisplayName = $DatabaseDisplayName\r\n                    Product             = $Product\r\n                    Datacenter          = $Datacenter\r\n                    INIDisplayName      = $Key\r\n                    INIValue            = $Key.Split('e')[1]\r\n                }\r\n\r\n                $businessObjectRecords.Add($currentBusinessObject)\r\n            }\r\n        }\r\n\r\n        return [PSCustomObject[]]$businessObjectRecords\r\n    }\r\n}\r\n\r\n\r\nfunction Get-INIContent {\r\n    [CmdletBinding()]\r\n    Param(\r\n        [ValidateNotNullOrEmpty()]\r\n        [string]$FilePath\r\n    )\r\n    process {\r\n        [Hashtable]$ini = @{ }\r\n        [PSCustomObject]$section = $null\r\n        [PSCustomObject]$value = $null\r\n        [Int32]$CommentCount = $null\r\n        [String]$name = ''\r\n        switch -regex -file $FilePath {\r\n            \"^\\[(.+)\\]$\" { # Section\r\n                $section = $matches[1]\r\n                $ini[$section] = @{ }\r\n                $CommentCount = 0\r\n            }\r\n            \"^(;.*)$\" { # Comment\r\n                if ($null -eq $section) {\r\n                    $section = \"No-Section\"\r\n                    $ini[$section] = @{ }\r\n                }\r\n                $value = $matches[1]\r\n                $CommentCount = $CommentCount + 1\r\n                $name = \"Comment\" + $CommentCount\r\n                $ini[$section][$name] = $value\r\n            }\r\n            \"(.+?)\\s*=\\s*(.*)\" { # Key\r\n                if ($null -eq $section) {\r\n                    $section = \"No-Section\"\r\n                    $ini[$section] = @{ }\r\n                }\r\n                $name, $value = $matches[1..2]\r\n                $ini[$section][$name] = $value\r\n            }\r\n        }\r\n        $ini\r\n    }\r\n}\r\n\r\nMeasure-Command -Expression { Get-BusinessObject -INIPath \"$PSScriptRoot\\TestIt.ini\" }\r\nMeasure-Command -Expression { Get-BusinessObject -INIPath \"$PSScriptRoot\\TestIt.ini\" }\r\n\r\n```\r\n\r\nHowever what you really need is the input; I created this generator which should give you consistent results and allow you to adjust how many records you want to process this with (I started with 50,000; this generates a file about 10mb in size):\r\n\r\n```powershell\r\n$NUMBER_OF_RECORDS_TO_GENERATE = 50000\r\n\r\n$(\r\n    Write-Output \"[General]\"\r\n    Write-Output \"Key1=Yes\"\r\n    Write-Output \"Key2=No\"\r\n\r\n    for ($i = 0; $i -lt $NUMBER_OF_RECORDS_TO_GENERATE; $i++) {\r\n        Write-Output \"[Database$i]\"\r\n        $ServerName = 'MNO07'\r\n        if ($i % 2 -eq 0) {\r\n            $ServerName = 'ABC'\r\n            if ($i % 3 -eq 0) {\r\n                $ServerName += '03Z'\r\n            }\r\n            else {\r\n                $ServerName += '3Z'\r\n            }\r\n        }\r\n        elseif ($i % 3 -eq 0) {\r\n            $ServerName = 'DEF'\r\n            if ($i % 2 -eq 0) {\r\n                $ServerName += '02'\r\n            }\r\n            else {\r\n                $ServerName += '2'\r\n            }\r\n        }\r\n        elseif ($i % 5 -eq 0) {\r\n            $ServerName = 'GHI'\r\n            if ($i % 2 -eq 0) {\r\n                $ServerName += '05'\r\n            }\r\n            else {\r\n                $ServerName += '5'\r\n            }\r\n        }\r\n        elseif ($i % 7 -eq 0) {\r\n            $ServerName = 'JKL4'\r\n        }\r\n        else {\r\n            $ServerName = 'PQR'\r\n        }\r\n\r\n        if ($i % 2 -eq 0) {\r\n            $ServerName += 'SQL'\r\n        }\r\n        elseif ($i % 3 -eq 0) {\r\n            $ServerName += 'AGL'\r\n        }\r\n\r\n        if ($i % 13 -eq 0) {\r\n            $ServerName += \",$i\"\r\n        }\r\n        elseif ($i % 17 -eq 0) {\r\n            if ($i % 2 -eq 0) {\r\n                $ServerName += '\\A'\r\n            }\r\n            else {\r\n                $ServerName += '\\B'\r\n            }\r\n        }\r\n\r\n        Write-Output \"ServerName=$ServerName$i\"\r\n        $DBNamePrefix = 'AB'\r\n        if ($i % 8 -eq 0) {\r\n            $DBNamePrefix = 'AB8'\r\n        }\r\n        Write-Output \"DatabaseName=$DBNamePrefix`_$i\"\r\n        if ($i % 256 -eq 0) {\r\n            Write-Output \"Description=Business Object $([char]0xFFFD) $i\"\r\n        }\r\n        else {\r\n            Write-Output \"Description=Business Object - $i\"\r\n        }\r\n    }\r\n) | Out-File 'TestIt.ini'\r\n```\r\n\r\nOn my Core i7-9850H:\r\n\r\n```\r\nPS C:\\Users\\ace.olszowka> $PSVersionTable\r\n\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.1.3\r\nPSEdition                      Core\r\nGitCommitId                    7.1.3\r\nOS                             Microsoft Windows 10.0.18363\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n\r\nPS C:\\Users\\ace.olszowka> BenefitsFromJIT.ps1\r\n\r\nDays              : 0\r\nHours             : 0\r\nMinutes           : 0\r\nSeconds           : 58\r\nMilliseconds      : 630\r\nTicks             : 586309245\r\nTotalDays         : 0.000678598663194444\r\nTotalHours        : 0.0162863679166667\r\nTotalMinutes      : 0.977182075\r\nTotalSeconds      : 58.6309245\r\nTotalMilliseconds : 58630.9245\r\n\r\nDays              : 0\r\nHours             : 0\r\nMinutes           : 0\r\nSeconds           : 26\r\nMilliseconds      : 306\r\nTicks             : 263062944\r\nTotalDays         : 0.000304471\r\nTotalHours        : 0.007307304\r\nTotalMinutes      : 0.43843824\r\nTotalSeconds      : 26.3062944\r\nTotalMilliseconds : 26306.2944\r\n```",
      "created_at": "2021-09-17T03:25:16Z",
      "updated_at": "2021-09-17T03:25:16Z"
    },
    {
      "author": "IISResetMe",
      "author_association": "COLLABORATOR",
      "body": "The behavior you're observing stems from resolution of the `$List.$Key` expressions - it's sending PowerShell on a \"detour\" via the extended type system to resolve the appropriate hashtable entry. \r\n\r\nReplace all 6 occurrences of `$List.$Key` with `$List[$Key]` and you should see a much better and more consistent performance profile.",
      "created_at": "2021-11-26T00:31:56Z",
      "updated_at": "2021-11-26T00:31:56Z"
    }
  ],
  "created_at": "2021-09-10T12:53:58Z",
  "number": 16079,
  "state": "open",
  "title": "Ability to Mark a Function for JIT / Documentation of JIT",
  "updated_at": "2021-11-26T00:31:56Z"
}