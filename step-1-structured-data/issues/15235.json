{
  "_url": "https://github.com/PowerShell/PowerShell/issues/15235",
  "author": "MatejKafka",
  "body": "https://github.com/PowerShell/PowerShell/pull/12797#issuecomment-819889789\r\n\r\n## Intro & context\r\nSymlink target may be a relative path, which is then resolved by the filesystem as a relative path from parent directory of the symlink. Example:\r\nWe have the following 2 files:\r\n```\r\n    Directory: D:\\test\r\n\r\nMode                 LastWriteTime         Length Name\r\n----                 -------------         ------ ----\r\nla---          2021-04-15    00:41              0 file_link.txt -> .\\file.txt\r\n-a---          2021-04-15    00:41              0 file.txt\r\n```\r\n`file_link.txt` is a file symlink, which resolves to `D:\\test\\file.txt`. It might be created with `New-Item -Type SymbolicLink .\\file_link.txt -Target .\\file.txt`.\r\n\r\n\r\nThere's a difference between a symlink to a file and to a directory, and attempting to traverse a directory symlink pointing to a file does not work (and same for trying to read from a file symlink pointing to a directory).\r\n\r\nTo correctly create the symlink, PowerShell checks whether the target is a file or a directory. Originally, this check was broken for relative target paths, because the process-wide .NET working directory was used to resolve the target (so the above command would check for a target path like `C:\\Windows\\System32\\file.txt` - that path doesn't exist, so `pwsh` defaults to creating a file symlink). This was supposedly fixed in #12797.\r\n\r\nWith this \"fix\", working directory of PowerShell is now used instead of the .NET working directory. **This is however still incorrect**, because we don't want to resolve the target relative to CWD, but relative to the symlink itself.\r\n\r\n\r\n## Reproduction\r\n(I'll use `D:/test` as our testing directory to make it clear when I'm talking about absolute paths)\r\n\r\n### 1)\r\n```\r\nmkdir D:/test\r\nmkdir D:/test/dir\r\ncd D:/\r\nni -Type SymbolicLink D:/test/dir_link -Target ./dir\r\n```\r\nExpected: directory symlink to `D:/test/dir`, with target `./dir`\r\nGot: **file** symlink to `D:/test/dir`, with target `./dir`\r\nThe target type detection code checks the relative path `./dir` (`D:/dir`), which doesn't exist, so the symlink incorrectly defaults to **file symlink**.\r\n\r\n### 2)\r\n```\r\nmkdir D:/test\r\nmkdir D:/test/dir\r\ncd D:/test\r\nni -Type SymbolicLink D:/test/dir_link -Target ./dir\r\n```\r\nExpected: directory symlink to `D:/test/dir`, with target `./dir`\r\nGot: what I expected\r\nOnly difference from previous example is the `cd D:/test` on line 3. This correctly creates a directory symlink, because the code checks type of target for `./dir` (`D:/test/dir`), which now matches the real target.\r\n\r\n### 3)\r\n```\r\nmkdir D:/test/subdir\r\nmkdir D:/test/item # <-- directory\r\nni D:/test/subdir/item # <-- file\r\ncd D:/test\r\nni -Type SymbolicLink D:/test/subdir/item_link -Target ./item\r\n```\r\nExpected: file symlink to `D:/test/subdir/item`, with target `./item`\r\nGot: **directory** symlink `D:/test/subdir/item`, with target `./item`\r\nThe the file `D:/test/item` is used for target check, it's a directory, so a directory symlink is created (but the actual target is `D:/test/subdir/item`, which is a file).\r\n\r\n## Proposed fixes\r\nThere are 2 possible correct behaviors I see here:\r\n1) Always resolve symlink target to an absolute path in `New-Item`. This effectively prevents PowerShell from creating symlinks with relative paths to target. \r\n2) Allow relative paths, but when checking for target type (file/directory), use the path `Join-Path $Path $Target` internally, but still write `$Target` as provided by user (relative) into the symlink itself. This is imo the better solution, allows the user to create symlinks with relative paths, but still correctly detects the type.\r\n\r\n## Environment data\r\n```none\r\n\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.2.0-preview.4\r\nPSEdition                      Core\r\nGitCommitId                    7.2.0-preview.4\r\nOS                             Microsoft Windows 10.0.19042\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u0393\u00c7\u00aa}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for writing this up.\r\n\r\nRe behavior 1. (resolving to full paths before creating the symlink):\r\n\r\nWe do _not_ want this, because defining symlinks that reference their targets via _relative_ paths is an important feature, which enables moving such symlinks - along with their targets - to a different location without breaking things.\r\n\r\nTherefore - I agree with your preference - we want behavior 2.\r\n\r\nWith that in mind, we want:\r\n\r\n* preserving relative targets _as specified_ in the symlink's actual _definition_ (potentially after normalizing path separators to the platform-native form).\r\n\r\n* for the sake of _validating_ the target on creation, an _existence check_ relative to the _symlink_'s directory.\r\n\r\n  * Currently, such checks are _not_ performed (in terms of resulting in _errors_), except if the target is specified as a _full path_ AND that path starts with a nonexistent _drive_ specification or a nonexistent _UNC share_.\r\n\r\n   * Conversely, you may  want to - by way of _opt-in_ - create a symlink to a target that you _know not to exist yet_. \r\n     * For _technical_ reasons, _on Windows_ this additionally requires explicitly indicating the target's file-system _type_ (_file_ vs. _directory_).\r\n  * See https://github.com/PowerShell/PowerShell/issues/9067#issuecomment-470140963 for a discussion of these issues.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2021-04-15T01:34:22Z",
      "updated_at": "2021-04-15T01:56:13Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "If this gets fixed as suggested, the following is a moot point, but just to prevent additional confusion:  \r\n\r\n#12797, which, as you state, was conceptually the wrong fix, only _partially_ achieved what it tried to do: a target path such as `.\\foo` _is_ recognized as a relative path and resolved against `$PWD`, but the equivalent `foo` (no `.\\` prefix) is not, and is currently still resolved against the _process_' current directory (`[Environment]::CurrentDirectory`); see #15161 for a repro (since closed, because it will implicitly also be resolved by resolving _this_ issue).\r\n",
      "created_at": "2021-04-15T17:27:16Z",
      "updated_at": "2021-04-15T17:27:16Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "The Engine WG spent ~25 minutes discussing about this issue. We agreed that the proposed fix no.2 is reasonable (quoted below). Namely, a relative path specified for `-Target` should be resolved using the path to the symbolic link, instead of powershell's current working directory.\r\n\r\n> Allow relative paths, but when checking for target type (file/directory), use the path `Join-Path $Path $Target` internally, but still write `$Target` as provided by user (relative) into the symlink itself. This is imo the better solution, allows the user to create symlinks with relative paths, but still correctly detects the type.\r\n\r\nThis makes sense because when accessing a file/directory symbolic that is associated with a relative path, such as `Get-Content <symlink>`, the relative path is resolved using the symlink path. So, we should be consistent in resolving the target relative path when creating a symbolic link with `New-Item`.\r\n\r\nThis proposed fix would be a breaking change to PowerShell 7.1. It feels like the right thing to do, but we need to evaluate the impact before proceeding.\r\n\r\n----------------------------\r\n\r\nInterestingly, our discussion led to another idea when comparing `New-Item` with `mklink`, which we want to throw out here for more discussion.\r\n\r\nWhen creating a symbolic using [`mklink`](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/mklink), `mklink` doesn't check the existence of the specified `<target>` path. It creates a file symbolic by default, and creates a directory symbolic when `/d` is specified.\r\n\r\nAs is shown in the screenshot below, `myfolder` is an existing directory, but `mklink my-link c:\\arena\\tmp\\test-2\\myfolder` creates a file symbolic, even though the target path is an existing directory.\r\n\r\n![image](https://user-images.githubusercontent.com/127450/121633364-7df2ac80-ca37-11eb-84df-da09f53c5d20.png)\r\n\r\nSo, maybe `New-Item` should work similarly as `mklink` in creating a symbolic link?\r\n    - does not check on the existence of `target` path\r\n    - create file symbolic by default, and add a new `switch` parameter for creating directory symbolic\r\n\r\nThis would be a breaking change too, in that if target points to an existing directory, a directory symbolic will be create with the current behavior, but a file symbolic will be created if we change to the `mklink` behavior.\r\n",
      "created_at": "2021-06-11T05:45:46Z",
      "updated_at": "2021-06-11T05:47:36Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "If it is a bug why we would say \"breaking change\"? :-)",
      "created_at": "2021-06-11T19:12:50Z",
      "updated_at": "2021-06-11T19:12:50Z"
    },
    {
      "author": "dogancelik",
      "author_association": "NONE",
      "body": "I was going to comment on #15750 but it was closed.\r\n\r\n**New-Item Junction example:**\r\nPwsh version: `7.1.4`\r\n```pwsh\r\nNew-Item '.\\node_modules\\example-project-base\\' -ItemType Junction -Value '.\\example-project-base\\'\r\n# New-Item: Could not find item .\\example-project-base\\.\r\n```\r\n\r\nPowerShell version: `5.1.19041.1023`:\r\n```pwsh\r\nNew-Item '.\\node_modules\\example-project-base\\' -ItemType Junction -Value '.\\example-project-base\\'\r\n#    Directory: C:\\example-project\\node_modules\r\n# Mode                 LastWriteTime         Length Name\r\n# ----                 -------------         ------ ----\r\n# d----l        2021.08.23     23:27                example-project-base\r\n```\r\n",
      "created_at": "2021-08-23T20:37:53Z",
      "updated_at": "2021-08-23T21:03:47Z"
    },
    {
      "author": "Xiphoseer",
      "author_association": "NONE",
      "body": "I ran into this regression today and found it rather tricky to find this issue because a lot of parts just work until they don't. I hope the following points help others find it more easily and deal with it:\r\n\r\n1. Relative paths that start with `..\\` (or `../`) are not supported by the current PowerShell implementation, but happen to work in many cases, specifically, when the path exists relative to the directory PowerShell was started in. (`../<username>` is a good candidate to check that, in console windows started in the home directory).\r\n    - There is little reason for the following code to check for literal `./` or `.\\` at the start of the target path. Those are not the only valid relative paths. Instead, I'd argue that `!System.IO.Path.IsPathRooted(strTargetPath)` should be used. https://github.com/PowerShell/PowerShell/blob/7dc4587014bfa22919c933607bf564f0ba53db2e/src/System.Management.Automation/namespaces/FileSystemProvider.cs#L2408-L2413 Alternatively, `Path.Join` could be called unconditionally, because rooted paths just discard the first part of the join anyways.\r\n2. The *new* feature, which we'd like to keep is that only the relative path is stored on disk, while PWSH 5 made every path absolute first, then checked whether it exists and then set the absolute path into the reparse point. This would not work well with git repos.\r\n3. When a binary (e.g. PowerShell) calls [`CreateSymbolicLink`](https://docs.microsoft.com/de-de/windows/win32/api/winbase/nf-winbase-createsymboliclinka), there's a flag called `SYMBOLIC_LINK_FLAG_DIRECTORY`, whose only effect is to switch the result of `GetFileAttributesA` from `FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_REPARSE_POINT` to `FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_REPARSE_POINT`. That's the reason PowerShell needs to figure out why that target is a directory in the first place, which isn't something Linux needs.\r\n4. In fact, this matters so little, that you can `Get-ChildItem symlink/subfolder` through a symlink with the wrong attribute (adding to the confusion). The only thing that actually breaks is getting a handle to the target directory via `CreateFile`. This could be considered a bug inside of windows (and breaks the way flutter detects invalid links on windows, which is how I got here in the first place)\r\n5. Powershell also needs to take care of replacing `/` with `\\` because that causes different sets of errors if written to the repare point with un-normalized forward slashes.\r\n\r\nTo summarize: If you need to work around this bug right now, just prefix all relative paths with `.\\` even if they start with `..\\` already. This is both a regression in PowerShell from 5 to 7 (e.g. `New-Item -ItemType SymbolicLink -Path \"data\" -Target \"..\\data\"` no longer works reliably) and an area of the operating system that still breaks in mysterious and under-documented ways if not handled right (e.g. creating symlinks using the Win32 api with forward slashes or pointing to the wrong type of filesystem entry)",
      "created_at": "2022-06-27T19:00:09Z",
      "updated_at": "2022-06-27T19:00:09Z"
    },
    {
      "author": "ImportTaste",
      "author_association": "NONE",
      "body": "> To summarize: If you need to work around this bug right now, just prefix all relative paths with .\\ even if they start with ..\\ already. This is both a regression in PowerShell from 5 to 7 (e.g. New-Item -ItemType SymbolicLink -Path \"data\" -Target \"..\\data\" no longer works reliably) and an area of the operating system that still breaks in mysterious and under-documented ways if not handled right (e.g. creating symlinks using the Win32 api with forward slashes or pointing to the wrong type of filesystem entry)\r\n\r\nAdditionally, you need to be in the working directory you want to add the directory-based symbolic link to because PowerShell is currently detecting whether a path is a file or a folder based on your current working directory rather than relative to the new item's path.\r\n\r\nLastly, you have to use double-quotes, if the relative path is in single-quotes it won't work properly.\r\n\r\nThis is rather contrived, I wish there could just be a switch parameter to specify that it's a directory I want to make rather than a file, or maybe its own special type like 'SymbolicLinkDir'.",
      "created_at": "2022-08-20T14:39:37Z",
      "updated_at": "2022-08-20T14:39:37Z"
    }
  ],
  "created_at": "2021-04-14T22:56:37Z",
  "labels": [
    "Issue-Bug",
    "WG-Cmdlets-Management",
    "WG-Engine-Providers",
    "Area-FileSystem-Provider"
  ],
  "number": 15235,
  "state": "open",
  "title": "Target type detection (file/directory) for relative symlinks is still broken, even on Windows",
  "updated_at": "2022-08-20T14:39:37Z"
}