{
  "_url": "https://github.com/PowerShell/PowerShell/issues/17857",
  "author": "SeeminglyScience",
  "body": "Note that this is currently a proof of concept (albeit completely functional afaik). A lot of work is still needed in terms of polish and consistency. I'll try to outline what work still needs to be done below. Trying to get some feedback as early as possible for this change though so please feel free to review!\r\n\r\n<!-- Anything that looks like this is a comment and can't be seen after the Pull Request is created. -->\r\n\r\n# PR Summary\r\n\r\n<!-- Summarize your PR between here and the checklist. -->\r\n\r\n## PR Context\r\n\r\nLeft to do:\r\n\r\n- [x] Hook up provider path resolution and error handling\r\n- [ ] See if it's feasible to wrap as an experimental feature\r\n- [ ] Investigate `Stream.CopyToAsync` (thank you @daxian-dbw!)\r\n- [ ] Tests\r\n\r\n<!-- Provide a little reasoning as to why this Pull Request helps and why you have opened it. -->\r\n\r\n## PR Checklist\r\n\r\n- [ ] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [ ] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [ ] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [ ] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` or `[ WIP ]` to the beginning of the title (the `WIP` bot will keep its status check at `Pending` while the prefix is present) and remove the prefix when the PR is ready.\r\n- **[Breaking changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)**\r\n    - [ ] None\r\n    - **OR**\r\n    - [ ] [Experimental feature(s) needed](https://github.com/MicrosoftDocs/PowerShell-Docs/blob/main/reference/7.3/Microsoft.PowerShell.Core/About/about_Experimental_Features.md)\r\n        - [ ] Experimental feature name(s): <!-- Experimental feature name(s) here -->\r\n- **User-facing changes**\r\n    - [ ] Not Applicable\r\n    - **OR**\r\n    - [ ] [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n- **Testing - New and feature**\r\n    - [ ] N/A or can only be tested interactively\r\n    - **OR**\r\n    - [ ] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n- **Tooling**\r\n    - [ ] I have considered the user experience from a tooling perspective and don't believe tooling will be impacted.\r\n    - **OR**\r\n    - [ ] I have considered the user experience from a tooling perspective and opened an issue in the relevant tool repository. This may include:\r\n        - [ ] Impact on [PowerShell Editor Services](https://github.com/PowerShell/PowerShellEditorServices) which is used in the [PowerShell extension](https://github.com/PowerShell/vscode-powershell) for VSCode\r\n        (which runs in a different PS Host).\r\n            - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n        - [ ] Impact on Completions (both in the console and in editors) - one of PowerShell's most powerful features.\r\n            - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n        - [ ] Impact on [PSScriptAnalyzer](https://github.com/PowerShell/PSScriptAnalyzer) (which provides linting & formatting in the editor extensions).\r\n            - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n        - [ ] Impact on [EditorSyntax](https://github.com/PowerShell/EditorSyntax) (which provides syntax highlighting with in VSCode, GitHub, and many other editors).\r\n            - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "AE1020",
      "author_association": "NONE",
      "body": "Glad to see this being taken seriously!  It is important for generic shells--especially ones that aspire to work cross platform--to be able to pass data through agnostically.\r\n\r\n*(I cloned and built Powershell just to try this PR! \ud83d\ude03)*\r\n\r\nThe stdout redirection did appear to work on my tests (which require not introducing CR into LF-only streams).  That is good!  I was able to pipe | and redirect > successfully.\r\n\r\nHowever, the powershell I built seems to put the redirected native outputs wherever powershell was started up, not in the current directory.  So if run from some directory like:\r\n\r\n    C:\\projects\\> C:\\projects\\powershell\\src\\powershell-win-core\\bin\\Debug\\net7.0\\win7-x64\\publish\\pwsh\r\n    PowerShell 7.3.0-preview.3-267-g4faa5f99e3f6c7f959da35ce264959bb43017126\r\n    PS C:\\Projects> cd test\r\n    PS C:\\Projects\\test> git --version > gitver.txt\r\n    PS C:\\Projects\\test> cat gitver.txt\r\n    Get-Content: Cannot find path 'C:\\Projects\\test\\gitver.txt' because it does not exist.\r\n\r\nBut we find the file in the original directory:\r\n\r\n    PS C:\\Projects\\test> cat ..\\gitver.txt\r\n    git version 2.36.1.windows.1\r\n\r\nPiping commands that aren't native output, e.g. **`echo \"hello\" > echotest.txt`** act as expected, and go to the current directory.\r\n\r\nRedirecting 2> for errors is introducing CRs when CMD.EXE does not give them, and does not have the directory issue...so I assume it is not running the new handling.  (As per my post on the discussion thread, my vote is very much that stderr be covered by the same handling!)",
      "created_at": "2022-08-06T20:11:49Z",
      "updated_at": "2022-08-06T20:11:49Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> Glad to see this being taken seriously! It is important for generic shells--especially ones that aspire to work cross platform--to be able to pass data through agnostically.\r\n>\r\n> _(I cloned and built Powershell just to try this PR! \ud83d\ude03)_\r\n\r\n\u2764\ufe0f \r\n\r\n> However, the powershell I built seems to put the redirected native outputs wherever powershell was started up, not in the current directory. So if run from some directory like:\r\n\r\nAh yeah that makes sense. That'd be part of what gets fixed with my comment above about hooking up path resolution via `FileSystemProvider`.\r\n\r\n> Redirecting 2> for errors is introducing CRs when CMD.EXE does not give them, and does not have the directory issue...so I assume it is not running the new handling. (As per my post on the discussion thread, my vote is very much that stderr be covered by the same handling!)\r\n\r\nYeah I can definitely understand the desire, but the only real way to do that with consistency would be to rewrite the `Process` class from scratch with p/invoke code specific to every platform. While that does genuinely sound like a fun thing to write, that's a ton of extra code to maintain for the level of impact it would have. I asked in that thread because if there were show stoppers around reverting to current behavior for stderr, I'd likely have to scrap the idea entirely.\r\n\r\nMaybe in the future dotnet will add something to the `SD.Process` class to make it feasible, but for now this is an acceptable compromise imo.",
      "created_at": "2022-08-06T21:01:41Z",
      "updated_at": "2022-08-06T21:01:41Z"
    },
    {
      "author": "AE1020",
      "author_association": "NONE",
      "body": "> the only real way to do that with consistency would be to rewrite the Process class from scratch with p/invoke code specific to every platform\r\n\r\nCan you explain in more detail why this is significantly different from the stdout case?",
      "created_at": "2022-08-06T21:15:45Z",
      "updated_at": "2022-08-06T21:15:45Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> Can you explain in more detail why this is significantly different from the stdout case?\r\n\r\nThe biggest technical issue is around merging stderr into stdout. So the ideal way this would work (using Windows APIs as an example) is I would create a single pipe (or file for redirection) with `kernel32!CreatePipe` (or `kernel32!CreateFile`) that I could pass to `kernel32!CreateProcess` for both stdout and stderr. I don't have a generic way to do this without writing a lot of platform specific code so instead I'm reading from the `Stream` created by `System.Diagnostics.Process` for `stdout`.\r\n\r\nDoing the same for `stderr` and trying to flush them both into the downstream's stdin `Stream` leads to a significant amount of inconsistency in order. That inconsistency already exists in the current string reading behavior but it's made worse when dealing with bytes directly as you can end up writing half of a line (or even half of a unicode glyph) from stdout and then another half from stderr.\r\n\r\nThis doesn't directly exclude lighting up the `native 2> log.txt` scenario and reverting only for `native 2>&1`, but it does make it less clear cut. It's easy to understand that \"error is text, so it's treated like strings, and when you merge it makes stdout also like strings\". It's harder to understand \"neither are treated like strings unless you merge them together\" if that makes sense.\r\n\r\nIt's also not necessarily a simple switch I'd be flipping to enable it for stderr as well. There are a lot of places it needs to be special cased in pipeline creation similarly to how I'm doing it for stdout but subtly different. If/when this PR is merged I'll create a separate issue that is specifically for preserving bytes when redirecting stderr so the engine WG can discuss it. This PR will be for stdout specifically, but that doesn't necessarily mean another PR can't address it.",
      "created_at": "2022-08-06T22:01:28Z",
      "updated_at": "2022-08-06T22:01:28Z"
    },
    {
      "author": "AE1020",
      "author_association": "NONE",
      "body": "The stdout case probably would satisfy most people, whose concerns are more about binary preservation with things like curl/zip.  My issue with cross-platform consistency on CRLF is its own crusade, which is distinct from this if one is going to actually \"use\" PowerShell in a bigger sense.  But it happens to be measurably better with this change.\r\n\r\nI can see that interleaving the streams raises a lot of issues.  I'm not clear on how it *ever* works (are UNIX shells at risk of doing half-codepoints in UTF-8?  If not, how?  Would their guarantee be accomplished by line buffering vs. understanding UTF-8 encodings specifically?  If so, what happens when the line buffer size is exceeded?)  \ud83d\ude26  Sounds like something one would find a lot of inconvenient truths by reading up on...",
      "created_at": "2022-08-07T00:59:18Z",
      "updated_at": "2022-08-07T00:59:18Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> I can see that interleaving the streams raises a lot of issues. I'm not clear on how it _ever_ works (are UNIX shells at risk of doing half-codepoints in UTF-8? If not, how? Would their guarantee be accomplished by line buffering vs. understanding UTF-8 encodings specifically? If so, what happens when the line buffer size is exceeded?) \ud83d\ude26 Sounds like something one would find a lot of inconvenient truths by reading up on...\r\n\r\nThe trouble mostly comes from utilizing `System.Diagnostics.Process`. When you redirect a stream using that API, it creates a pipe for each stream you've redirected. Then I would be asynchronously reading from both of these separate streams and trying to merge the output after the fact. These streams will also have different buffer sizes and flush intervals.\r\n\r\nIt's much easier when you are synchronously reading from and writing to a single pipe, as most platform specific shells with less output processing will do.",
      "created_at": "2022-08-08T17:25:04Z",
      "updated_at": "2022-08-08T17:25:04Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as stale because it has been marked as requiring author feedback but has not had any activity for **15 days**. It will be closed if no further activity occurs **within 10 days of this comment**.",
      "created_at": "2022-08-26T20:01:15Z",
      "updated_at": "2022-08-26T20:01:15Z"
    },
    {
      "author": "AE1020",
      "author_association": "NONE",
      "body": "@adityapatwardhan What sort of feedback would be needed for PowerShell to prioritize reviewing this?\r\n\r\nIt is a rather popular request (see #1908, and touched upon by some other issues), where these seem like things people expect to work in a shell:\r\n\r\n    curl.exe http://whatever/a.png > a.png\r\n\r\n    node a.js | gzip -c > out.gz\r\n\r\nModulo the output directory I found when trying it, it seemed to work for that.",
      "created_at": "2022-08-29T13:05:07Z",
      "updated_at": "2022-08-29T13:05:07Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> What sort of feedback would be needed for PowerShell to prioritize reviewing this?\r\n\r\nIt's not finished yet, it's a work in progress PR. You can ignore the bot, if it closed it then I'd just reopen",
      "created_at": "2022-08-29T16:41:10Z",
      "updated_at": "2022-08-29T16:41:10Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as stale because it has been marked as requiring author feedback but has not had any activity for **15 days**. It will be closed if no further activity occurs **within 10 days of this comment**.",
      "created_at": "2022-09-17T02:01:23Z",
      "updated_at": "2022-09-17T02:01:23Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as stale because it has been marked as requiring author feedback but has not had any activity for **15 days**. It will be closed if no further activity occurs **within 10 days of this comment**.",
      "created_at": "2022-10-02T08:01:24Z",
      "updated_at": "2022-10-02T08:01:24Z"
    },
    {
      "author": "pull-request-quantifier[bot]",
      "author_association": "NONE",
      "body": "### ![](https://img.shields.io/static/v1?label=Quantified&message=Extra%20Large&color=red)\r\n\r\nThis PR has `412` quantified lines of changes. In general, a change size of upto `200` lines is ideal for the best PR experience!\r\n\r\n------\r\n\r\n<details >\r\n    <summary display=\"inline\"> <strong>Quantification details</strong></summary>\r\n    <p />\r\n\r\n```\r\nLabel      : Extra Large\r\nSize       : +367 -45\r\nPercentile : 80.4%\r\n\r\nTotal files changed: 5\r\n\r\nChange summary by file extension:\r\n.cs : +367 -45\r\n```\r\n> Change counts above are quantified counts, based on the [PullRequestQuantifier customizations](https://github.com/microsoft/PullRequestQuantifier/blob/main/docs/prquantifier-yaml.md).\r\n    \r\n</details>\r\n\r\n\r\n<details>\r\n    <summary display=\"inline\"> <strong>Why proper sizing of changes matters</strong> </summary>\r\n    <p/>\r\n    <p/>\r\n\r\nOptimal pull request sizes drive a better predictable PR flow as they strike a\r\nbalance between between PR complexity and PR review overhead. PRs within the\r\noptimal size (typical small, or medium sized PRs) mean:\r\n\r\n- Fast and predictable releases to production:\r\n  - Optimal size changes are more likely to be reviewed faster with fewer\r\niterations.\r\n  - Similarity in low PR complexity drives similar review times.\r\n- Review quality is likely higher as complexity is lower:\r\n  - Bugs are more likely to be detected.\r\n  - Code inconsistencies are more likely to be detected.\r\n- Knowledge sharing is improved within the participants:\r\n  - Small portions can be assimilated better.\r\n- Better engineering practices are exercised:\r\n  - Solving big problems by dividing them in well contained, smaller problems.\r\n  - Exercising separation of concerns within the code changes.\r\n\r\n#### What can I do to optimize my changes\r\n\r\n- Use the PullRequestQuantifier to quantify your PR accurately\r\n  - Create a context profile for your repo using the [context generator](https://github.com/microsoft/PullRequestQuantifier/releases)\r\n  - Exclude files that are not necessary to be reviewed or do not increase the review complexity. Example: Autogenerated code, docs, project IDE setting files, binaries, etc. Check out the `Excluded` section from your `prquantifier.yaml` context profile. \r\n  - Understand your typical change complexity, drive towards the desired complexity by adjusting the label mapping in your `prquantifier.yaml` context profile.\r\n  - Only use the labels that matter to you, [see context specification](./docs/prquantifier-yaml.md) to customize your `prquantifier.yaml` context profile.\r\n- Change your engineering behaviors\r\n  - For PRs that fall outside of the desired spectrum, review the details and check if:\r\n    - Your PR could be split in smaller, self-contained PRs instead\r\n    - Your PR only solves one particular issue. (For example, don't refactor and code new features in the same PR).\r\n\r\n#### How to interpret the change counts in git diff output\r\n\r\n- One line was added: `+1 -0`\r\n- One line was deleted: `+0 -1`\r\n- One line was modified: `+1 -1` (git diff doesn't know about modified, it will\r\ninterpret that line like one addition plus one deletion)\r\n- Change percentiles: Change characteristics (addition, deletion, modification)\r\nof this PR in relation to all other PRs within the repository.\r\n\r\n</details>\r\n\r\n<p />\r\n\r\n------\r\n\r\nWas this comment helpful? <a href=\"https://pullrequestquantifierfeedback.azurewebsites.net/feedback?payload=eyJBdXRob3JOYW1lIjoiU2VlbWluZ2x5U2NpZW5jZSIsIlJlcG9zaXRvcnlMaW5rIjoiaHR0cHM6Ly9naXRodWIuY29tL1Bvd2VyU2hlbGwvUG93ZXJTaGVsbCIsIlB1bGxSZXF1ZXN0TGluayI6Imh0dHBzOi8vZ2l0aHViLmNvbS9Qb3dlclNoZWxsL1Bvd2VyU2hlbGwvcHVsbC8xNzg1NyIsIkV2ZW50VHlwZSI6IlRodW1ic1VwIn0=&amp;anonymous=True\" target=\"_blank\" title=\"Thumbs up\"><strong>:thumbsup:</strong></a> <a href=\"https://pullrequestquantifierfeedback.azurewebsites.net/feedback?payload=eyJBdXRob3JOYW1lIjoiU2VlbWluZ2x5U2NpZW5jZSIsIlJlcG9zaXRvcnlMaW5rIjoiaHR0cHM6Ly9naXRodWIuY29tL1Bvd2VyU2hlbGwvUG93ZXJTaGVsbCIsIlB1bGxSZXF1ZXN0TGluayI6Imh0dHBzOi8vZ2l0aHViLmNvbS9Qb3dlclNoZWxsL1Bvd2VyU2hlbGwvcHVsbC8xNzg1NyIsIkV2ZW50VHlwZSI6Ik5ldXRyYWwifQ==&amp;anonymous=True\" target=\"_blank\" title=\"Neutral\"><strong>&nbsp;:ok_hand:</strong></a> <a href=\"https://pullrequestquantifierfeedback.azurewebsites.net/feedback?payload=eyJBdXRob3JOYW1lIjoiU2VlbWluZ2x5U2NpZW5jZSIsIlJlcG9zaXRvcnlMaW5rIjoiaHR0cHM6Ly9naXRodWIuY29tL1Bvd2VyU2hlbGwvUG93ZXJTaGVsbCIsIlB1bGxSZXF1ZXN0TGluayI6Imh0dHBzOi8vZ2l0aHViLmNvbS9Qb3dlclNoZWxsL1Bvd2VyU2hlbGwvcHVsbC8xNzg1NyIsIkV2ZW50VHlwZSI6IlRodW1ic0Rvd24ifQ==&amp;anonymous=True\" target=\"_blank\" title=\"Thumbs down\"><strong>&nbsp;:thumbsdown:</strong></a> (<a href=\"MAILTO:prquantifier@microsoft.com\" title=\"Mail to prquantifier@microsoft.com\">Email</a>)\r\n[Customize PullRequestQuantifier](https://github.com/PowerShell/PowerShell/blob/master/.github/prquantifier.yaml) for this repository.\r\n\r\n",
      "created_at": "2022-10-07T19:44:55Z",
      "updated_at": "2022-10-07T19:44:55Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Combine sequential native pipline elements and treat them as one pipeline element. Link them with IO redirection directly instead of powershell pipeline.\r\n\r\nThis was in https://github.com/PowerShell/PowerShell/issues/559#issuecomment-240957563\r\nIf I understand write it is that we want, but can not implement due to Process class limitations, so we would have to fall in low APIs?\r\n",
      "created_at": "2022-10-08T08:17:50Z",
      "updated_at": "2022-10-08T08:17:50Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> This was in [#559 (comment)](https://github.com/PowerShell/PowerShell/issues/559#issuecomment-240957563) If I understand write it is that we want, but can not implement due to Process class limitations, so we would have to fall in low APIs?\r\n\r\nSo it kind of depends how you interpret what @vors was saying there. In a sense, that's what I'm doing in this PR.\r\n\r\nIn another sense (which is what you're getting at) there is another route that would be a much bigger lift but would be closer to how other shells implement it.\r\n\r\nOn Windows that would be using `CreatePipe` to create a single pipe that we pass to `CreateProcess` for both the upstream's stdout and the downstream's stdin. And something somewhat similar on *nix with `pipe`.\r\n\r\nThat would require rewriting a significant chunk of the code as we wouldn't be able to use `System.Diagnostics.Process` at all really. I'm definitely interested to see if I can make that work, but not in this PR. Probably something I need to pursue on my own time, and tbh highly likely to be too great of an additional maintenance burden for the value add anyway.",
      "created_at": "2022-10-10T18:30:22Z",
      "updated_at": "2022-10-10T18:30:22Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as stale because it has been marked as requiring author feedback but has not had any activity for **15 days**. It will be closed if no further activity occurs **within 10 days of this comment**.",
      "created_at": "2022-10-28T20:01:23Z",
      "updated_at": "2022-10-28T20:01:23Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as stale because it has been marked as requiring author feedback but has not had any activity for **15 days**. It will be closed if no further activity occurs **within 10 days of this comment**.",
      "created_at": "2022-11-12T23:01:05Z",
      "updated_at": "2022-11-12T23:01:05Z"
    }
  ],
  "created_at": "2022-08-05T21:47:57Z",
  "number": 17857,
  "state": "open",
  "title": "WIP: Preserve stdout byte stream for native commands",
  "updated_at": "2022-11-12T23:01:05Z"
}