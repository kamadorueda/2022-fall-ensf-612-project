{
  "_url": "https://github.com/PowerShell/PowerShell/issues/4614",
  "author": "daxian-dbw",
  "body": "Fix #4607\r\n\r\nSummary\r\n----------\r\nGetMember/SetMember/InvokeMember operations on a COM object will generate code to unwrap the COM object if it's wrapped in PSObject. Due to a loose restriction, if you have a string wrapped to a PSObject with a ETS member of the the same name, then accessing that member will fail.\r\n\r\nFix\r\n---\r\nUse a more restricted rule by checking the base object type when it's necessary.",
  "closed_at": "2017-08-28T20:19:03Z",
  "comments": [
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "Are you sure this is the right fix?\r\n\r\nThe original ideal behind `DeferForPSObject` was to create a site that unwrapped the PSObject and did nothing else - we would have a new nested dynamic site that would add tests like you've added.",
      "created_at": "2017-08-21T21:32:20Z",
      "updated_at": "2017-08-21T21:32:20Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@lzybkr The restrictions originally used in `DeferForPSObject` will cause PSObject to be unwrapped when it shouldn't. For example, when it comes to `GetMember`, the PSObject should be unwrapped only if the base is a COM object, but the restriction used in `DeferForPSObject` is `'arg is PSObject and arg.Base != arg'`, which means upcoming PSObject will be unwrapped even if the base is not a COM object. This fix doesn't change the behavior of `DeferForPSObject` -- it still just creates a site that unwraps PSObject, but with a stricter restriction if needed.",
      "created_at": "2017-08-21T22:36:19Z",
      "updated_at": "2017-08-21T22:36:19Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "In that case, the fix is not correct, consider something like:\r\n\r\n```powershell\r\nforeach ($o in & { New-Object string \"a\",5; New-Object -ComObject Something }) {\r\n    $o.DoSomething()\r\n}\r\n```\r\n\r\nThe first time hitting the site invoking `DoSomething`, we'll have a PSObject wrapping a string and generate a rule without your additional restriction.\r\n\r\nThe second time hitting the site, the previous rule will succeed and you won't generate a new rule.\r\n\r\nI don't see how avoiding unwrapping fixes a bug - isn't it possible that a site might receive the COM object unwrapped - and assuming so, shouldn't it behave the same as if the same instance is wrapped? To be concrete, the following should work the same, right?\r\n\r\n```powershell\r\n$o = New-Object -COM Something\r\n($o, $o.psobject.BaseObject) | % { $_.DoSomething() }\r\n```\r\n",
      "created_at": "2017-08-21T22:53:06Z",
      "updated_at": "2017-08-21T22:53:06Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "### Example 1 from Jason's comment\r\n```powershell\r\nforeach ($o in & { New-Object string \"a\",5; New-Object -ComObject Something }) {\r\n    $o.DoSomething()\r\n}\r\n```\r\nFor the string wrapped in PSObject, the code path won't fall in `DeferForPSObject`, because we defer only if the base of `target` is a COM object. The code is as follows in `FallbackInvokeMember`:\r\n```CSharp\r\nif ((baseObject != null) && (baseObject.GetType().FullName.Equals(\"System.__ComObject\")))\r\n{\r\n    return this.DeferForPSObject(args.Prepend(target).ToArray()).WriteToDebugLog(this);\r\n}\r\n```\r\nSo when it's the second time hitting the site (the COM object), the previous rule won't succeed. This is what I get with the fix of this PR:\r\n```powershell\r\nPS:1> foreach ($o in & { New-Object string \"a\",5; New-Object -ComObject \"Shell.Application\" }) {\r\n>> $o.Windows()\r\n>> }\r\nMethod invocation failed because [System.String] does not contain a method named 'Windows'.\r\nAt line:2 char:1\r\n+ $o.Windows()\r\n+ ~~~~~~~~~~~~\r\n    + CategoryInfo          : InvalidOperation: (:) [], RuntimeException\r\n    + FullyQualifiedErrorId : MethodNotFound\r\n\r\n\r\nApplication          : System.__ComObject\r\nParent               : System.__ComObject\r\nContainer            :\r\nDocument             : System.__ComObject\r\nTopLevelContainer    : True\r\nType                 :\r\nLeft                 : 398\r\nTop                  : 316\r\nWidth                : 2034\r\nHeight               : 1158\r\nLocationName         : Quick access\r\nLocationURL          :\r\nBusy                 : False\r\nName                 : File Explorer\r\nHWND                 : 656452\r\nFullName             : C:\\windows\\Explorer.EXE\r\nPath                 : C:\\windows\\\r\n...\r\n```\r\n### Example 2 from Jason's comment\r\n> To be concrete, the following should work the same, right?\r\n\r\n```powershell\r\n$o = New-Object -COM Something\r\n($o, $o.psobject.BaseObject) | % { $_.DoSomething() }\r\n```\r\nWell, this example may not be ideal because object will be wrapped into PSObject when passed to `% {}`, so in this example it ends up with calling `DoSomething` on PSObject for both pipeline objects.\r\n\r\n```powershell\r\n$o = New-Object -COM Something\r\n$o.psobject.BaseObject.DoSomething\r\n$o | % { $_.DoSomething }\r\n```\r\nThis example might be what you meant to have, the first call happens on a COM object directly, and the the second happens on a PSObject. In the first time, rule A was generated with a check of `'$arg TypeEqual __COMobject'`. In the second time, rule A will fail due to this `'TypeEqual'` check, and thus it will fall back to `FallbackInvokeMember`, where the PSObject will be unwrapped and return a nested dynamic site, and when the nested dynamic site gets called, rule A will succeed.\r\n\r\n### My additional comments\r\n\r\nThe additional restriction is not added to all cases where we need to unwrap PSObject, but only when it's needed. More specifically, for GetMember/SetMember/InvokeMember binders, PSObject should be unwrapped only when the target's base is a COM object, not any other PSObject. Take the following code as an instance:\r\n```powershell\r\n$o = New-Object -COM \"Shell.Application\"\r\n$str = Add-Member -InputObject $str -MemberType ScriptMethod -Name Windows -Value { \"Windows\" } -PassThru\r\n$o | % { $_.Windows() }\r\n$str.Windows()\r\n```\r\nThe first call will fall into `DeferForPSObject` -- unwrap the PSObject and generate nested dynamic site with rule `'arg TypeEqual PSObject andalso arg.Base != arg'`. Then the second call comes and the previous rule will succeed, so the str will be unwrapped and we will lose the ETS instance method `Windows()`. This is the issue this PR tries to fix.\r\n",
      "created_at": "2017-08-22T00:15:13Z",
      "updated_at": "2017-08-22T00:22:16Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "I think I understand the issue now.\r\n\r\nWe unwrap PSObject wrapped com objects only - because the COM binding code from C# does not expect PSObject and we did not update that code to generate correct restrictions and unwrap as needed when seeing PSObject.\r\n\r\nThe restrictions created by DeferForPS were intentionally not checking the type because that would create too many dynamic methods.\r\n\r\nI believe the restrictions should mirror the test that sends us down the path of deferring - namely that the base object is a COM object. This is more general than what you have in the fix right now which is checking the exact type. So basically - call `PSEnumerableBinder.IsComObject` (though maybe move the method to somewhere more general.)",
      "created_at": "2017-08-22T01:52:01Z",
      "updated_at": "2017-08-22T01:52:01Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "I think checking `IsComObject` in the restriction is too specific. COM is not the only special condition that we need to unwrap a PSObject -- it also happens in `PSBinaryOperationBinder` in [`FallbackBinaryOperation`](https://github.com/PowerShell/PowerShell/blob/master/src/System.Management.Automation/engine/runtime/Binding/Binders.cs#L2128) (and might as well happen in future changes):\r\n```\r\nif ((target.Value is PSObject && PSObject.Base(target.Value) != target.Value) ||\r\n     (arg.Value is PSObject && PSObject.Base(arg.Value) != arg.Value))\r\n {\r\n     // When adding to an array, we don't want to unwrap the RHS - it's unnecessary,\r\n     // and in the case of strings, we actually lose instance members on the PSObject.\r\n     if (!(Operation == ExpressionType.Add && PSEnumerableBinder.IsEnumerable(target) != null))\r\n     {\r\n         // Defer when the object is wrapped, but not for empty objects.\r\n         return this.DeferForPSObject(target, arg).WriteToDebugLog(this);\r\n     }\r\n}\r\n```\r\nThe `Add` operation has its own call site, and we unwrap PSObject only if the `target` is not enumerable (`IsEnumerable(target) == null`). So potentially this will cause a problem -- target in first call is a PSObject of a scalar object; target in second call is a PSObject of a collection, and the previous rule will succeed. The reason I didn't change this in the PR is that I cannot reproduce the issue in real code (plus this PR focuses on the issue related to COM).\r\n\r\nAs for GetMember/SetMember/InvokeMember, since we will defer only if the base of target is COM object, checking the base object type in restriction won't result in multiple dynamic methods because the rule will be `'arg0.base TypeEquals __ComObject'`, and thus all PSObject's that wrap COM objects will fall in this rule.",
      "created_at": "2017-08-22T17:12:47Z",
      "updated_at": "2017-08-22T17:19:59Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "Strictly speaking, `DeferForPSObject` is never needed, but it is a convenient way to avoid writing a lot more code.\r\n\r\nIt is used in many of the binders because those binders see fewer instances of PSObject and it was a trade off between generating the best possible code and just getting things to work correctly.\r\n\r\nIn the case of Get/Set/Invoke Member - instances of PSObject are very common, so `DeferForPSObject` was undesirable, so I spent the extra effort to avoid the extra call site and generate more efficient code.\r\n\r\nIn hindsight, it might not be a ton of work to eliminate `DeferForPSObject` entirely, I think the tricky part is minimizing calls to `PSObject.Base(target)` when constructing a new `DynamicMetaObject` for target.\r\n\r\nIn general, there should be no difference between a wrapped object and an unwrapped object - we need to generate different code, but unwrapping shouldn't gives us a different result. I believe strings with instance members are the only common exception to this statement (it can be an issue for value types as well, but because of boxing and unboxing, it is not a common problem.)\r\n\r\nSo barring an example that proves otherwise, I think the other sites that call `DeferForPSObject` are not affected by this problem - they do not access instance members of a string.\r\n\r\n\r\nAs for the generated restrictions for COM objects - the code you have now will unnecessary test `PSObject.Base(obj) != obj` - that test could go away with the type test.\r\n\r\nAnd from my limited understanding of COM - I thought strongly typed wrappers are possible (commonly generated with `tlbexp`) - so not every COM object is an instance of `System.__ComObject`, but my recollection in this area is fuzzy.",
      "created_at": "2017-08-22T17:43:40Z",
      "updated_at": "2017-08-22T17:43:40Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> So barring an example that proves otherwise, I think the other sites that call DeferForPSObject are not affected by this problem - they do not access instance members of a string.\r\n\r\nUse the same example about `FallbackBinaryOperation` in PSBinaryOperationBinder:\r\n\r\n> target in the first call is a PSObject of a scalar object; target in the second call is a PSObject of a collection, and the previous rule will succeed.\r\n\r\nSince the previous rule succeeds for the second call, target and all args will be unwrapped. If one of the args is a PSObject that wraps a string with ETS instance members, then the members will be stripped after adding to the collection. So theoretically, this is affected, though I don't have real code to show this issue. **Do you think we should consider this case?**",
      "created_at": "2017-08-22T19:15:21Z",
      "updated_at": "2017-08-22T19:15:21Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> I thought strongly typed wrappers are possible (commonly generated with tlbexp) - so not every COM object is an instance of System.__ComObject, but my recollection in this area is fuzzy.\r\n\r\nYou are absolutely right about this! This is what I got when using the excel COM interop assembly:\r\n```\r\nobject type: Microsoft.Office.Interop.Excel.ApplicationClass\r\nIs __ComObject assignable from? True\r\n```\r\nSo yes, a simple TypeEqual is not sufficient. I will use `IsComObject`. And the checks for COM object in `GetMember/SetMember/InvokeMember` are not sufficient too and need to be changed to use `IsComObject`.",
      "created_at": "2017-08-22T19:15:24Z",
      "updated_at": "2017-08-22T19:15:24Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "> Since the previous rule succeeds for the second call, target and all args will be unwrapped. If one of the args is a PSObject that wraps a string with ETS instance members, then the members will be stripped after adding to the collection. So theoretically, this is affected, though I don't have real code to show this issue. Do you think we should consider this case?\r\n\r\nLike I said - I think it's a non-issue because the instance members don't matter when adding strings - we'll never attempt to access the instance members that we wouldn't find, and the unwrapped instance is not saved anywhere, so I think there is no bug there.",
      "created_at": "2017-08-22T19:31:05Z",
      "updated_at": "2017-08-22T19:31:05Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "> So yes, a simple TypeEqual is not sufficient. \r\n\r\nActually it probably is sufficient, but we would generate dynamic methods with the identical expressions and differing constraints - maybe fine if the constraint was expensive, but with the added cost of extra jit time and extra memory.",
      "created_at": "2017-08-22T19:39:26Z",
      "updated_at": "2017-08-22T19:39:26Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> So yes, a simple TypeEqual is not sufficient.\r\n\r\nIt would be sufficient if we don't change the [current COM checking code](https://github.com/PowerShell/PowerShell/blob/master/src/System.Management.Automation/engine/runtime/Binding/Binders.cs#L4978) in GetMember/SetMember/InvokeMember, because currently we don't even consider the strongly types RWCs.\r\n\r\nIf we update the COM checking code to use `IsComObject`, then it's sufficient to make the code correct, but it's not sufficient to avoid generating unnecessary dynamic methods. After updating the constraint to use `IsComObject()`, one dynamic method will cover all COM cases.",
      "created_at": "2017-08-22T19:45:40Z",
      "updated_at": "2017-08-22T19:45:40Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@lzybkr I think your comments are all addressed. Can you please take another look?",
      "created_at": "2017-08-23T16:36:06Z",
      "updated_at": "2017-08-23T16:36:06Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@lzybkr @iSazonov Your comments are addressed. Please take another look. Thanks!",
      "created_at": "2017-08-24T19:13:44Z",
      "updated_at": "2017-08-24T19:13:44Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@iSazonov Thanks for the review!\r\n@lzybkr I updated the code to make `IsComObject` a faster test (see https://github.com/PowerShell/PowerShell/pull/4614#discussion_r135279191). Could you please take another look? Thanks!",
      "created_at": "2017-08-26T01:11:16Z",
      "updated_at": "2017-08-26T01:11:16Z"
    }
  ],
  "created_at": "2017-08-18T17:40:11Z",
  "number": 4614,
  "state": "closed",
  "title": "Use stricter rule to avoid unnecessary unwrapping of PSObject when operating on a COM object",
  "updated_at": "2017-08-28T20:19:06Z"
}