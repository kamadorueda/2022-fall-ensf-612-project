{
  "_url": "https://github.com/PowerShell/PowerShell/issues/11171",
  "author": "renatfx",
  "body": "# Steps to reproduce\r\n\r\n```powershell\r\n# [string]\r\nPS > $str1 = 'abc' | Add-Member -NotePropertyMembers @{Test=1} -PassThru\r\nPS > $str1 | Get-Member -View Extended\r\n\r\n   TypeName: System.String\r\nName MemberType   Definition\r\n---- ----------   ----------\r\nTest NoteProperty int Test=1\r\n\r\nPS > [string]$str2 = 'abc' | Add-Member -NotePropertyMembers @{Test=1} -PassThru\r\nPS > $str2 | Get-Member -View Extended\r\nPS > $str3 = [string]('abc' | Add-Member -NotePropertyMembers @{Test=1} -PassThru)\r\nPS > $str3 | Get-Member -View Extended\r\nPS >\r\n\r\n# [int]\r\nPS > $num1 = 1 | Add-Member -NotePropertyMembers @{Test='abc'} -PassThru\r\nPS > $num1 | Get-Member -View Extended\r\n\r\n   TypeName: System.Int32\r\nName MemberType   Definition\r\n---- ----------   ----------\r\nTest NoteProperty string Test=abc\r\n\r\nPS > [int]$num2 = 2 | Add-Member -NotePropertyMembers @{Test='abc'} -PassThru\r\nPS > $num2 | Get-Member -View Extended\r\n\r\n   TypeName: System.Int32\r\nName MemberType   Definition\r\n---- ----------   ----------\r\nTest NoteProperty string Test=abc\r\n\r\nPS > $num3 = [int](3 | Add-Member -NotePropertyMembers @{Test='abc'} -PassThru)\r\nPS > $num3 | Get-Member -View Extended\r\nPS >\r\n```\r\n\r\n# Expected behavior\r\n\r\n```none\r\nType casting both implicit (by variable type) and explicit (by expression casting) should\r\neither drop extented object members in case of any type, including [string] and [int], or\r\nleave them as is and perform only type checks.\r\n```\r\n\r\n# Actual behavior\r\n\r\n```none\r\nIn case of [string] both implicit and explicit type casting drop extended object members,\r\nand case of [int] only explicit type casting does that.\r\n```\r\n\r\n# Environment data\r\n\r\n<!-- provide the output of $PSVersionTable -->\r\n\r\n```none\r\nPSVersion                      6.2.3\r\nPSEdition                      Core\r\nGitCommitId                    6.2.3\r\nOS                             Microsoft Windows 10.0.18362\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n",
  "closed_at": "2020-02-02T08:22:18Z",
  "comments": [
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "So all of this makes sense, not necessarily in a design sort of way but a side effect sort of way.  I'm not justifying any of this, just providing context for those confused by it.\r\n\r\nFirst it's important to note that all ETS is done by attaching objects to a `PSObject`.  Behind the scenes, most things are wrapped in `PSObject`'s at some point, often several points.  Due to the constant wrapping and unwrapping of `PSObject`'s, you need a way to persist any ETS members that were manually added *between* `PSObject` instances.\r\n\r\nThe way PowerShell does this is via \"Resurrection Tables\".  A static dictionary (well `ConditionalWeakTable`) stores all of the members for an instance.  With reference types this is easy to match on, the dictionary key is just the reference.  For value types, this is a little bit harder.  Since they aren't typically stored on the heap, it boxes the value as `object` as uses that reference.\r\n\r\n> ```powershell\r\n> # [string]\r\n> PS > $str1 = 'abc' | Add-Member -NotePropertyMembers @{Test=1} -PassThru\r\n> PS > $str1 | Get-Member -View Extended\r\n> \r\n>    TypeName: System.String\r\n> Name MemberType   Definition\r\n> ---- ----------   ----------\r\n> Test NoteProperty int Test=1\r\n> \r\n> PS > [string]$str2 = 'abc' | Add-Member -NotePropertyMembers @{Test=1} -PassThru\r\n> PS > $str2 | Get-Member -View Extended\r\n> PS > $str3 = [string]('abc' | Add-Member -NotePropertyMembers @{Test=1} -PassThru)\r\n> PS > $str3 | Get-Member -View Extended\r\n> ```\r\n\r\nStrings are special cased when determining the key for member resurrection tables. When a `PSObject` is wrapping a string, the `key` is the `PSObject`.  This means that it's more or less excluded from the resurrection tables.\r\n\r\n> ```powershell\r\n> # [int]\r\n> PS > $num1 = 1 | Add-Member -NotePropertyMembers @{Test='abc'} -PassThru\r\n> PS > $num1 | Get-Member -View Extended\r\n> \r\n>    TypeName: System.Int32\r\n> Name MemberType   Definition\r\n> ---- ----------   ----------\r\n> Test NoteProperty string Test=abc\r\n> ```\r\n\r\nThe constant `1` is wrapped in a `PSObject` as it moves through the pipeline and into `Add-Member`.  The cmdlet then acts as it does with any other `PSObject`, and returns the result.  Same instance throughout, including as it's saved to a variable.\r\n\r\n> ```powershell\r\n> PS > [int]$num2 = 2 | Add-Member -NotePropertyMembers @{Test='abc'} -PassThru\r\n> PS > $num2 | Get-Member -View Extended\r\n> \r\n>    TypeName: System.Int32\r\n> Name MemberType   Definition\r\n> ---- ----------   ----------\r\n> Test NoteProperty string Test=abc\r\n> ```\r\n\r\nSame thing happens here.  Strongly typed variables in PowerShell work mostly the same with some added validation.  This can also work as PowerShell's form of \"implicit\" conversion which is slightly less forced than \"explicit\" conversions.  The `PSObject` is not unwrapped as it's saved to `$num2` (or if it is unwrapped, it's still the same boxed value so the resurrection table will pick it up.\r\n\r\n> ```powershell\r\n> PS > $num3 = [int](3 | Add-Member -NotePropertyMembers @{Test='abc'} -PassThru)\r\n> PS > $num3 | Get-Member -View Extended\r\n> PS >\r\n> ```\r\n\r\nAn \"explicit\" conversion is a lot more forced.  This will actually unwrap the `PSObject` *and* unbox the `object` that wraps the `int`.  It is subsequently reboxed when saved as a variable (or immediately after since most PowerShell expressions from the compilers perspective are expected to return  `object`) which will yield a unique key for resurrection tables.\r\n\r\nNote that the `int` examples in particular are complicated further by the fact that the engine caches a decent number of `int`'s (up to `10,000` I think?) on initialization.  So a lot of the common `int`'s that would be literal constants in a script are actually the same boxed reference type.\r\n\r\nLast note, if you ever find a scenario where you need to defend against this for some reason, you can explicitly unwrap a `PSObject` with `$myVar.psobject.BaseObject`.\r\n",
      "created_at": "2019-11-25T13:59:40Z",
      "updated_at": "2019-11-25T14:00:37Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "Note that I consider `PSObject` a legacy artifact that might never have been introduced if the DLR existed before PowerShell v1. The key to the resurrection table is typically **not** a `PSObject` - this allows one to pass objects to strongly typed .Net methods and recover the instance members.\r\n\r\nInstance members + value types don't really work well together. Values are copied unpredictably and you can only access instance members on boxed instances. If I could revisit this - I would disallow adding instance members to value types and instead require a wrapper type `Box<T> where T: struct` to avoid apparent inconsistencies.\r\n\r\nTo make matters worse, for performance reasons, PowerShell interns some boxed value types, e.g. $true/$false and small constant integers. This leads to lots of surprising behavior:\r\n\r\n```powershell\r\n5 | Add-Member -NotePropertyName foo -NotePropertyValue \"what?\"\r\n($y = 5).foo     # Returns `what?`\r\n10005 | Add-Member -NotePropertyName foo -NotePropertyValue \"what?\"\r\n($y = 10005).foo # Returns nothing\r\n```\r\n\r\nStrings are always wrapped in PSObject as a special case because:\r\n* they are not value types\r\n* it seems reasonable to add instance members\r\n* the runtime (not PowerShell) interns them sometimes\r\n\r\n",
      "created_at": "2019-11-25T18:16:12Z",
      "updated_at": "2019-11-25T18:16:12Z"
    },
    {
      "author": "renatfx",
      "author_association": "NONE",
      "body": "@SeeminglyScience @lzybkr ok, got it\r\n\r\nI also found some other issues related to that (see #11167 and #11169)\r\n\r\nbtw, the original issue I came across was impossibility to add a `NoteProperty` (or `ScriptProperty`) to a `[string]`  class property so that consumers can benefit from this PowerShell feature while having strictly typed class members",
      "created_at": "2019-11-26T07:18:16Z",
      "updated_at": "2019-11-26T07:18:16Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> btw, the original issue I came across was impossibility to add a `NoteProperty` (or `ScriptProperty`) to a `[string]` class property so that consumers can benefit from this PowerShell feature while having strictly typed class members\r\n\r\nYou can, you just need to wrap it first:\r\n\r\n```powershell\r\n$myString = [psobject]'this is a string'\r\n$myString | Add-Member -NotePropertyName Test -NotePropertyValue 'some value'\r\n$myString.Test\r\n# some value\r\n```\r\n\r\nThe main difference between string and other reference types is that instance members won't be mirrored in other instances of `PSObject` that reference the same string.",
      "created_at": "2019-11-26T13:25:38Z",
      "updated_at": "2019-11-26T13:25:38Z"
    }
  ],
  "created_at": "2019-11-22T22:14:41Z",
  "labels": [
    "Issue-Question",
    "WG-Engine",
    "Resolution-Answered"
  ],
  "number": 11171,
  "state": "closed",
  "title": "Unobvious type casting effects on ETS",
  "updated_at": "2020-02-02T08:22:18Z"
}