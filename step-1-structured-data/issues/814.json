{
  "_url": "https://github.com/PowerShell/PowerShell/issues/814",
  "author": "andschwa",
  "body": "When an assembly that exists outside of the trusted platform assembly\nlist but in the GAC on Windows was loaded, the use of `Assembly.Load`\nbefore the `LoadFromAssemblyPath` caused a recursive loop to occur.\n\nBy attempting to load from the file path first, we avoid this loop.\nHowever, loading TPA assemblies by their path throws an exception, so\nnow we catch this particular exception and attempt the load through\n`Assembly.Load`.\n\n@daxian-dbw, I really don't like this solution, as it relies on catching the exception from the failed load-by-path. However, we do need to support the .NET CLI scenario with the PowerShell assemblies exist in the TPA. To do this properly I think means breaking the coupling of the type analysis and assembly loading, so that we can analyze SMA etc. for their cmdlets, without having to re-load them.\n\n<!-- Reviewable:start -->\n\n---\n\nThis change is [<img src=\"https://reviewable.io/review_button.svg\" height=\"35\" align=\"absmiddle\" alt=\"Reviewable\"/>](https://reviewable.io/reviews/powershell/powershell/814)\n\n<!-- Reviewable:end -->\n",
  "closed_at": "2016-04-13T20:54:39Z",
  "comments": [
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "@palladia Can you test that this didn't break trying to load PSReadline on Linux? It _shouldn't_ but this code has a lot of side-effects.\n",
      "created_at": "2016-04-12T00:16:58Z",
      "updated_at": "2016-04-12T00:16:58Z"
    },
    {
      "author": "palladia",
      "author_association": "CONTRIBUTOR",
      "body": "It loaded PSReadLine without any problem.\n",
      "created_at": "2016-04-12T15:05:54Z",
      "updated_at": "2016-04-12T15:05:54Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@andschwa I don't understand why \"Assembly.Load\" was added to \"Load\" and \"LoadFrom\" in the first place. AssemblyLoadContext.Load is the fallback of Assemly.Load -- CoreCLR runtime first try to resolve the assembly from TPA list, if that fails, it calls AssemblyLoadContext.Load where we take over the resolution. Calling \"Assembly.Load\" within ALC.Load is bound to cause infinite loop ...\n",
      "created_at": "2016-04-12T16:48:39Z",
      "updated_at": "2016-04-12T16:48:39Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@andschwa And one minor comment on your change: it's intentional to avoid foreach loop in PowerShellAssemblyLoadContext.cs. Foreach loop will generate new enumerator objects, which cause extra overhead to be garbage collected. It's assumed that the code in this file will be called frequently, and thus avoiding foreach loop is a minor optimization. \n",
      "created_at": "2016-04-12T16:55:42Z",
      "updated_at": "2016-04-12T16:55:42Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "@daxian-dbw You're right in that this is totally wonky. However, I'm going to merge it for now, with the intent of integrating your correct fix when it is available.\n",
      "created_at": "2016-04-13T20:54:36Z",
      "updated_at": "2016-04-13T20:54:36Z"
    }
  ],
  "created_at": "2016-04-12T00:04:27Z",
  "number": 814,
  "state": "closed",
  "title": "Fix stack overflow exception when loading assemblies",
  "updated_at": "2016-04-13T20:54:43Z"
}