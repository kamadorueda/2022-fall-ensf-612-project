{
  "_url": "https://github.com/PowerShell/PowerShell/issues/17492",
  "author": "albahari",
  "body": "### Prerequisites\n\n- [X] Write a descriptive title.\n- [X] Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\n- [X] Search the existing issues.\n- [X] Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\n- [X] Refer to [Differences between Windows PowerShell 5.1 and PowerShell](https://docs.microsoft.com/powershell/scripting/whats-new/differences-from-windows-powershell).\n\n### Steps to reproduce\n\nWhen Microsoft.PowerShell.SDK is run from a non-default ALC in .NET, Import-Module fails silently.\r\n\r\nYou can reproduce this with the following example (.NET 6 Console project). It works only if you comment out `#define USE_PLUGIN`.\r\n\r\n```\r\n#define USE_PLUGIN\r\n\r\nusing System.Collections.ObjectModel;\r\nusing System.Linq;\r\nusing System.Management.Automation;\r\nusing System.Reflection;\r\nusing System.Runtime.Loader;\r\n\r\n#if USE_PLUGIN\r\n    var pluginAlc = new PluginLoadContext(Assembly.GetExecutingAssembly().Location);\r\n    var pluginAssem = pluginAlc.LoadFromAssemblyName(Assembly.GetExecutingAssembly().GetName());\r\n    pluginAssem.GetType(nameof(Test)).GetMethod(nameof(Test.Run)).Invoke(null, null);\r\n#else\r\n    Test.Run();\r\n#endif\r\n\r\nConsole.ReadLine();\r\n\r\npublic class Test\r\n{\r\n\tpublic static void Run()\r\n\t{\r\n\t\tvar ps = PowerShell.Create();\r\n\t\tps.AddCommand(\"Import-Module\").AddArgument(@\"International\");\r\n\t\tps.AddScript(\"Get-WinHomeLocation\");\r\n\r\n\t\tCollection<PSObject> result = ps.Invoke();\r\n\r\n\t\tif (ps.HadErrors)\r\n\t\t\tConsole.WriteLine(ps.Streams.Error[0].ToString());\r\n\t\telse\r\n\t\t\tConsole.WriteLine(\"Success!\");\r\n\r\n\t\tforeach (PSObject element in result)\r\n\t\t{\r\n\t\t\tConsole.WriteLine(element);\r\n\t\t\tforeach (var prop in element.Properties.Take(10))\r\n\t\t\t\tConsole.WriteLine(\"    \" + prop.Name + \"=\" + prop.Value);\r\n\t\t}\r\n\t\tConsole.WriteLine();\r\n\t}\r\n}\r\n\r\n// Code from https://docs.microsoft.com/en-us/dotnet/core/tutorials/creating-app-with-plugin-support\r\nclass PluginLoadContext : AssemblyLoadContext\r\n{\r\n\tprivate AssemblyDependencyResolver _resolver;\r\n\r\n\tpublic PluginLoadContext(string pluginPath)\r\n\t{\r\n\t\t_resolver = new AssemblyDependencyResolver(pluginPath);\r\n\t}\r\n\r\n\tprotected override Assembly Load(AssemblyName assemblyName)\r\n\t{\r\n\t\tstring assemblyPath = _resolver.ResolveAssemblyToPath(assemblyName);\r\n\t\tif (assemblyPath != null)\r\n\t\t\treturn LoadFromAssemblyPath(assemblyPath);\r\n\t\treturn null;\r\n\t}\r\n\r\n\tprotected override IntPtr LoadUnmanagedDll(string unmanagedDllName)\r\n\t{\r\n\t\tstring libraryPath = _resolver.ResolveUnmanagedDllToPath(unmanagedDllName);\r\n\t\tif (libraryPath != null)\r\n\t\t\treturn LoadUnmanagedDllFromPath(libraryPath);\r\n\t\treturn IntPtr.Zero;\r\n\t}\r\n}\r\n```\n\n### Expected behavior\n\n```console\nThe program should print \"Success\" whether or not the USE_PLUGIN symbol is defined.\n```\n\n\n### Actual behavior\n\n```console\nWhen the USE_PLUGIN symbol is defined, the program displays the following error:\r\n\r\nThe term 'Get-WinHomeLocation' is not recognized as a name of a cmdlet, function, script file, or executable program.\r\nCheck the spelling of the name, or if a path was included, verify that the path is correct and try again.\r\n\r\nA possible reason for it misbehaving is that some of the same PowerShell assemblies end up being loaded into both the custom ALC and the default ALC. You can verify this with the following code:\r\n\r\n\r\nConsole.WriteLine(\"PowerShell assemblies loaded into plugin ALC:\");\r\nEnumeratePowerShellAssemblies(pluginAlc);\r\n\r\nConsole.WriteLine(\"PowerShell assemblies loaded into default ALC:\");\r\nEnumeratePowerShellAssemblies(AssemblyLoadContext.Default);\r\n\r\nvoid EnumeratePowerShellAssemblies (AssemblyLoadContext alc)\r\n{\r\n    foreach (var a in alc.Assemblies)\r\n        if (!a.IsDynamic && a.GetName().Name.StartsWith(\"Microsoft.PowerShell.\"))\r\n            Console.WriteLine(\"    \" + a.Location);\r\n}\r\n```\n```\n\n\n### Error details\n\n```console\nThe term 'Get-WinHomeLocation' is not recognized as a name of a cmdlet, function, script file, or executable program.\r\nCheck the spelling of the name, or if a path was included, verify that the path is correct and try again.\n```\n\n\n### Environment data\n\n```powershell\n[PSVerion] 7.2.4\r\n[OS] \"Microsoft Windows 10.0.22000\"\r\n[WSManStackVersion] 3.0\r\n[PSEdition] Core\r\n[SerializationVersion] 1.1.0.1\r\n[PSRemotingProtocolVersion] 2.3\r\n[GitCommitId] 7.2.4\n```\n\n\n### Visuals\n\n_No response_",
  "closed_at": null,
  "comments": [
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "Currently, hosting PowerShell in a custom ALC is not supported, because it tightly coupled with the default assembly load context in many places, for example, \r\n\r\n- module loading uses `Assembly.LoadFrom` which implicitly loads an assembly into the default assembly load context.\r\n- `Add-Type` also depends on `Assembly.LoadFrom`, as well as `AssemblyLoadContext.Default.LoadFromStream`.\r\n- PowerShell class also depends on default load context.\r\n- the helper resolver to load an assembly from GAC is registered with the default assembly load context.\r\n\r\nRegarding the `International` module used in this repro, its assembly resides in GAC, so the helper resolver is used and load the assembly into the default load context. That's why you see some PowerShell assemblies get loaded in the default load context.",
      "created_at": "2022-06-07T17:58:53Z",
      "updated_at": "2022-06-07T17:58:53Z"
    },
    {
      "author": "albahari",
      "author_association": "NONE",
      "body": "I appreciate your explanation, but would like something clarified. Are you saying that this is this an acceptable or recommended way for a library to load assemblies under .NET Core and .NET 5+? Or are you saying that fixing it would be too much work (or too potentially disruptive?)\r\n\r\nAs I understand, correct standard practice is to load assemblies into the same ALC as the requesting assembly:\r\n\r\n```\r\nvar myAlc = AssemblyLoadContext.GetLoadContext (typeof (<typeInMyAssembly>).Assembly);\r\nmyAlc.LoadFromAssemblyName(...)\r\n// or myAlc.LoadFromAssemblyPath(...) if you need to specify a path\r\n```\r\n\r\nThis mimics the behavior of how assemblies **implicitly** load in  .NET Core and .NET 5+.\r\n\r\nHard-coding to the default ALC saves a line of code, but is reliable only if the requesting assembly is also in the default ALC. Otherwise it introduces the possibility of the assembly loading into both the default ALC and requesting ALC. And that almost never ends well.",
      "created_at": "2022-06-08T05:51:59Z",
      "updated_at": "2022-06-08T05:51:59Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> Are you saying that this is this an acceptable or recommended way for a library to load assemblies under .NET Core and .NET 5+? Or are you saying that fixing it would be too much work (or too potentially disruptive?)\r\n\r\nIt's not recommended to load PowerShell in a custom assembly load context as of today.\r\nFixing it is possible but would require non-trivial work. It's not just how loading assembly is handled in PowerShell, but also how types are resolved.\r\n\r\nI renamed this issue and make it an enhancement request to track the ask for this scenario.",
      "created_at": "2022-06-08T16:11:44Z",
      "updated_at": "2022-06-08T16:14:28Z"
    }
  ],
  "created_at": "2022-06-07T02:42:57Z",
  "number": 17492,
  "state": "open",
  "title": "Make it possible to host PowerShell in a custom assembly load context",
  "updated_at": "2022-06-08T16:14:28Z"
}