{
  "_url": "https://github.com/PowerShell/PowerShell/issues/3240",
  "author": "mklement0",
  "body": "**Null-coalescing** and **null-conditonal access** (null-soaking) would be handy additions to the language.\r\n\r\n_Update_: @BrucePay  additionally suggests **null-conditional _assignment_**, with `?=` - see [comment below](https://github.com/PowerShell/PowerShell/issues/3240#issuecomment-417435164).\r\n\r\nFor instance, instead of writing:\r\n\r\n```powershell\r\nif ($null -ne $varThatMayBeNull) { $varThatMayBeNull } else { $fallbackValue }\r\n#\r\nif ($null -ne $varThatMayBeNull) { $varThatMayBeNull.Name } else { $null }\r\n```\r\n\r\none might be able to write:\r\n\r\n```powershell\r\n$varThatMayBeNull ?? $fallbackValue  # null-coalescing\r\n# \r\n$varThatMayBeNull?.Name   # null-conditional access, for Set-StrictMode -Version 2+\r\n$varThatMayBeNull?[42]  # ditto, with indexing\r\n```\r\n\r\nRe null-conditional access: With `Set-StrictMode` being OFF (the default), you can just use `$varThatMayBeNull.Name` - no special syntax needed; however, if `Set-StrictMode -Version 2` or higher is in effect, `$varThatMayBeNull.Name` would _break_ and that's where the null-conditional operator (`?.`) is helpful, to signal the explicit intent to ignore the `$null` in a concise manner.\r\n\r\n---\r\n\r\n**Open question**:\r\n\r\n`$varThatMayBeNull?[42]` handles the case where the variable is `$null`, but if it isn't, an array element with the specified index _must exist_.\r\n\r\nIt would therefore also be helpful to **make _indexing_ null-conditional** - something that C# does _not_ support, incidentally (you have to use `.ElementAtOrDefault()`).\r\n\r\nThe two basic choices are:\r\n\r\n* Come up with additional syntax that explicitly signal the intent to ignore a non-existent _index_:\r\n\r\n  * The question is what syntax to choose for this, given that `?[...]` and `[...]?` are not an option due to ambiguity. \r\n  * Perhaps `[...?]`, but that seems awkward .\r\n\r\n* Rely on the existing behavior with respect to accessing non-existent indices, as implied by the `Set-StrictMode` setting - see [table below](https://github.com/PowerShell/PowerShell/issues/3240#issuecomment-478599343).\r\n\r\n---\r\n\r\nRelated:  [implement ternary conditionals](https://github.com/PowerShell/PowerShell/issues/3239)",
  "closed_at": "2019-12-11T00:00:14Z",
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 It seems the second sample works by design without \"?\".\r\nMaybe change to `name()`?",
      "created_at": "2017-10-08T10:43:13Z",
      "updated_at": "2017-10-08T10:44:02Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov: Good point, but it only works without the `?` unless `Set-StrictMode -Version 2` or higher is _not_ in effect - I've updated the initial post to make that clear.",
      "created_at": "2017-10-08T13:27:32Z",
      "updated_at": "2017-10-08T13:27:32Z"
    },
    {
      "author": "Halkcyon",
      "author_association": "NONE",
      "body": "I think syntactic sugar is something powershell could use that other languages enjoy.  +1 on the proposal.",
      "created_at": "2018-07-24T23:32:33Z",
      "updated_at": "2018-07-24T23:32:33Z"
    },
    {
      "author": "kfsone",
      "author_association": "NONE",
      "body": "Consider the following samples from other languages:\r\n\r\n    a=\"${b:-$c}\"\r\n    a = b || c;\r\n    a = b or c\r\n    a := b ? c\r\n    a = b ? b : c;\r\n\r\neven\r\n\r\n    a = b if b else c\r\n\r\nis better than\r\n\r\n    if (b) { a = b } else { a = c }\r\n\r\nand often times you need to clarify with the additionally verbose\r\n\r\n   a=(if (b -ne $null) { b } else { c })\r\n\r\nMakes one feel all dirty and bashed.\r\n",
      "created_at": "2018-07-25T03:28:54Z",
      "updated_at": "2018-07-25T03:28:54Z"
    },
    {
      "author": "thezim",
      "author_association": "CONTRIBUTOR",
      "body": "Found myself doing this today as work around.\r\n\r\n```powershell\r\n$word = ($null, \"two\", \"three\").Where({$_ -ne $null}, \"First\")\r\n````",
      "created_at": "2018-08-17T16:20:46Z",
      "updated_at": "2018-08-17T16:20:46Z"
    },
    {
      "author": "bgshacklett",
      "author_association": "NONE",
      "body": "I use a similar pattern:\r\n```powershell\r\n$word = ($null, \"two\", \"three\" -ne $null)[0]\r\n```",
      "created_at": "2018-08-18T13:42:11Z",
      "updated_at": "2018-08-18T13:42:11Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "@kfsone There is a small error in your example `$a=(if ($b -ne $null) { $b } else { $c })`. It should be `$a=$(if ($b -ne $null) { $b } else { $c })` however the only version of PowerShell where `$( )` was required was version 1. From v2 on, you can simply do:\r\n```powershell\r\n$a = if ($b) { $b } else { $c }\r\n```",
      "created_at": "2018-08-19T01:40:53Z",
      "updated_at": "2018-08-19T01:40:53Z"
    },
    {
      "author": "Halkcyon",
      "author_association": "NONE",
      "body": "@bgshacklett Don't you mean `$word=($null,'two')[$null -ne 'three']`?\r\n\r\nIt's a bit unfortunate this has gone from 6.1 to 6.2 to \"Future\".",
      "created_at": "2018-08-21T04:05:43Z",
      "updated_at": "2018-08-21T04:07:05Z"
    },
    {
      "author": "bgshacklett",
      "author_association": "NONE",
      "body": "@TheIncorrigible1  No, if you copy and paste what I added above, you should see that the value of `$word` is set to \"two\". There's more detail in this Stack Overflow answer where I first saw the pattern:\r\nhttps://stackoverflow.com/a/17647824/180813",
      "created_at": "2018-08-21T11:46:19Z",
      "updated_at": "2018-08-21T11:46:19Z"
    },
    {
      "author": "kfsone",
      "author_association": "NONE",
      "body": "While perlesque hack-arounds appeal to the 20-year ago me that wrote a shebang that registered and/or queried a RIPE-DB user or organization record, what I'm hoping for from powershell is something that encourages my colleagues to use the language rather than instill fear in them. \r\n\r\nMy litmus test is this: Would I want to read this via my tablet at 3am New Years morning while hung over with the ceo on the phone crying at me how many millions of dollars we are losing a second.\r\n\r\n(Aside: this was only a loose exaggeration of an actual experience until I worked at Facebook and came back from an urgent quick leak to be told that, in the 2 minutes I was gone, more people than the population of Holland had gotten an empty news feed. It wasn't my code and the mistake was a minute change in the semantics of return x vs return (x) in the c++ standard for very specific template cases, and \"would you want to read this code with a 2 minute deadline, a full bladder and the fate of every clog wearing Dutch person's cat pictures on your shoulder???\" didn't sound as cool)",
      "created_at": "2018-08-21T20:15:46Z",
      "updated_at": "2018-08-21T20:16:17Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Yup. There are some neat tricks possible in PS that are great in a pinch or if you need a one-time shorthand.\r\n\r\nFor maintainable code, ideally we should have explicit null-coalescing operators like C#. The main trouble there for me is -- what do we use for those? `?` is already aliased to `Where-Object` (much as I'd love for that to be erased, it's in *very* common use). Mind you, `%` is aliased to `ForEach-Object` but that doesn't hinder modulus operations, so in theory at least having `?` be a null-coalescing operator as well would potentially be fine; it would only be interpreted as such in expressions, where `Where-Object` isn't really valid anyway.",
      "created_at": "2018-08-21T20:27:59Z",
      "updated_at": "2018-08-21T20:29:20Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@vexx32:\r\n\r\nAt least _syntactically_ `??` should be fine, because we're talking about _expression_ mode, whereas `?`, as a command [alias], is only recognized in _argument_ mode.\r\nNot sure if reuse of the symbol causes confusion, but it wouldn't be the first time that a symbol does double duty in different contexts.\r\n\r\nSurprisingly, using `?.` and `?[]` for null-soaking would technically be a breaking change, because PowerShell currently allows `?` as a non-initial character in a variable name.\r\n\r\n```powershell\r\nPS> $foo? = @{ bar = 1 }; $foo?.bar   # !! $foo? is a legal variable name\r\n1\r\n```\r\n\r\nHowever, I hope this would be considered a [Bucket 3: Unlikely Grey Area](https://github.com/PowerShell/PowerShell/blob/master/docs/dev-process/breaking-change-contract.md#bucket-3-unlikely-grey-area) change.",
      "created_at": "2018-08-21T21:26:33Z",
      "updated_at": "2018-08-21T21:26:33Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I can't say I've *ever* seen anyone use ? in a variable name... Nor would I, because chances are it would be misread. But yeah, hopefully that should be perfectly useable.",
      "created_at": "2018-08-21T21:35:24Z",
      "updated_at": "2018-08-21T21:35:24Z"
    },
    {
      "author": "bgshacklett",
      "author_association": "NONE",
      "body": "I suspect it's a bit late to bring this up, but Bash has handled this (and some other cases) with its Parameter Substitution features: https://www.tldp.org/LDP/abs/html/parameter-substitution.html.\r\n\r\nWhile it can be a bear to learn due to the sheer number of things that can be done with it, it's incredibly powerful. I understand that it would not be possible to use this exact notation due to the way PowerShell uses braces with variables, nor would it necessarily fit with the general feel of the language, but it seems like a useful data point.",
      "created_at": "2018-08-22T11:31:55Z",
      "updated_at": "2018-08-22T11:31:55Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@bgshacklett:\r\n\r\nYes, parameter substitution is powerful, but, unfortunately, it's not only a bear to _learn_, but also to _remember_.\r\n\r\nSo while Bash's _features_ are often interesting, their _syntactic form_ is often arcane, hard to remember, and not a good fit for PowerShell.\r\n\r\n_Brace expansion_ (e.g., `a{1,2,3}` in `bash` expanding to `a1 a2 a3`) is an example of an interesting feature whose expressiveness I'd love to see in PowerShell, but with PowerShell-appropriate syntax - see #4286 ",
      "created_at": "2018-08-23T20:19:20Z",
      "updated_at": "2018-08-23T20:19:49Z"
    },
    {
      "author": "bgshacklett",
      "author_association": "NONE",
      "body": "I completely agree. I brought it up more as an example of how this issue has been solved elsewhere than an exact solution.",
      "created_at": "2018-08-23T23:24:39Z",
      "updated_at": "2018-08-23T23:24:39Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "There's one other operator to possibly consider:\r\n```powershell\r\n$x ?= 12\r\n```\r\nwhich would set `$x` if it's not set (doesn't exist). This is part of the \"initializer pattern\" which is not common in conventional languages but for (dynamically scoped) languages like shells, make tools, etc. it's pretty common to have a script that sets a default if the user hasn't specified it. (Though in fact parameter initializers are pretty widespread.)\r\n\r\nExtending this to properties:\r\n```powershell\r\n$obj.SomeProperty ?= 13\r\n```\r\nwould add and initialize a note property `SomeProperty` on the object if it didn't exist.\r\n\r\nAnd - for fun - one more variation on initializing a variable using `-or`:\r\n```powershell\r\n$x -or ($x = 3.14) > $null\r\n```",
      "created_at": "2018-08-30T19:15:28Z",
      "updated_at": "2018-08-30T19:15:28Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "`$x ?= 12` sounds like a great idea.\r\n\r\nIt occurred to me that we probably should apply all of these operators not only if the LHS doesn't _exist_, but also if it _does exist but happens to contain_ `$null` (with `[System.Management.Automation.Internal.AutomationNull]::Value` treated like `$null` in this context).\r\n\r\n> add and initialize a note property SomeProperty\r\n\r\nIn that vein, `$obj.SomeProperty ?= 13` makes sense to me _only_ if  `.SomeProperty` exists and contains `$null`, given that you cannot implicitly create properties even with regular assignments (by contrast, for _hasthables_ the implicit entry creation makes sense).\r\n\r\nAll operators discussed will need to exempt the LHS from strict-mode existence checking.\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2018-09-01T16:46:45Z",
      "updated_at": "2018-09-01T22:52:54Z"
    },
    {
      "author": "HumanEquivalentUnit",
      "author_association": "CONTRIBUTOR",
      "body": "I'm wondering about the intent / reasoning behind *why* strictmode stops you from accessing a property which doesn't exist. Is the intent to catch typos like `$x.pretnd`? Is the intent to check assumptions like `assert(x != null)`? Is the intent to block accidentally propagating `$null` further on in your code?\r\n\r\n> the null-soaking (?.) is helpful, to signal the explicit intent to ignore the $null in a concise manner.\r\n\r\nIs that not what `.` signals already in nonstrict mode? If you had wanted to be strict, you could have checked for `.Name` existing first, by not checking first, you already signalled explicit intent that checking wasn't important to you.\r\n\r\nIf StrictMode has a purpose where accessing a non-existent property and returning `$null` is forbidden, then won't the same reasoning apply to `?.`, and that should throw the same exception for the same reason. If not, why not?\r\n\r\nWith null-coalescing, you could write:\r\n\r\n```powershell\r\n$result = Invoke-RestMethod -Uri 'https://example.org/api/test'\r\n$test = $result?.Name\r\n```\r\n\r\nWill it quickly become recommended or idiomatic to *always* use `?.` for every property reference, because it \"behaves like `.` does, and won't throw exceptions for people using strictmode\"?\r\n\r\nIs the real desire to have a configurable strictmode with variable settings, so that e.g. you could have a declaration at the top of your script `# StrictMode SkipMemberExistenceCheck`, or an escape hatch attribute for indicating a block of `unstrict code` generally? [I suspect the desire is terse C# style syntax, but you know what I mean]",
      "created_at": "2019-03-21T06:38:52Z",
      "updated_at": "2019-03-21T06:40:40Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for the thoughts, @HumanEquivalentUnit.\r\n\r\n> Is the intent to catch typos like `$x.pretnd`?\r\n\r\nI can't speak to the design intent, but that's what makes sense to me - analogous to what `Set-StrictMode -Version 1` does for _variables_ (only).\r\n\r\nWith variables it's about their _existence_, not whether the value happens to be `$null`, and checking for property existence follows the same pattern.\r\n\r\nI think of it as the closest a dynamic scripting language can get to finding errors that a statically typed compiled language would report at _compile time_.\r\n\r\n---\r\n\r\n> Is that not what . signals already in nonstrict mode? If you had wanted to be strict, you could have checked for .Name existing first\r\n\r\nYes, but in non-strict mode you forgo the aforementioned existence checks, and testing manually is obviously quite cumbersome - and invariably slower than a built-in feature.\r\n\r\n> by not checking first, you already signalled explicit intent that checking wasn't important to you.\r\n\r\nThe point is that, with `Set-StrictMode -Version 2` or higher, you get:\r\n\r\n* the benefit of member existence checking _by default_\r\n* the option to opt out, _on demand, concisely_ with  `.?` \r\n\r\n> you could have a declaration at the top of your script `# StrictMode SkipMemberExistenceCheck`, or an escape hatch attribute for indicating a block of `unstrict code` generally\r\n\r\nRelated: The current dynamic scoping of `Set-StrictMode` is problematic; see @lzybkr's RFC draft for implementing a _lexical_ strict mode: https://github.com/PowerShell/PowerShell-RFC/blob/master/1-Draft/RFC0003-Lexical-Strict-Mode.md\r\n",
      "created_at": "2019-03-21T17:44:17Z",
      "updated_at": "2019-03-21T17:44:32Z"
    },
    {
      "author": "HumanEquivalentUnit",
      "author_association": "CONTRIBUTOR",
      "body": "> the benefit of member existence checking by default\r\n\r\nPS contains code which does member checking, and returns $null when they don't exist. That's a benefit by default, which you can also avoid by writing your own member existence test with `$x.psobject.properties...` if you choose to. StrictMode takes away that benefit and leaves the *hinderence* of having to write existence tests. Then instead of giving a nice way to write exactly a member existence test, `?.` would give you a concise workaround to get what `.` always did. And if it matters that the member exists, you still have to code that separately.\r\n\r\nBut this does make me ask what about method calls:\r\n\r\n```powershell\r\n$x.pretend     -> $null\r\n$x.pretend()   -> Exception MethodNotFound\r\n$x?.pretend  -> $null\r\n$x?.pretend()   -> ____ what goes here? $null?\r\n\r\nset-strictmode -version 2\r\n$x.pretend -> Exception PropertyNotFoundStrict\r\n$x.pretend()  -> Exception MethodNotFound\r\n$x?.pretend  -> $null\r\n$x?.pretend()   -> ____  ?\r\n```\r\n\r\ni.e `?.` would behave the same as `.` for property lookups in non-strictmode, but would behave differently to `.` for method calls in non-strictmode, making it nuanced and not a drop-in replacement. Does that mean that when using `?.` you would have no way at all to tell whether a method was invoked, or nothing at all happened? Properties can be backed by getter methods, but I think it's convention in DotNet for getters not to mutate internal state, but normal for method calls to mutate state. With `?.` you would have no idea if you mutated an object's state?\r\n\r\nI wonder if you can get the desired benefits, and better, by making `??` able to handle PropertyNotFoundException and MethodNotFound Exceptions directly from the expression on the left (but not other Exceptions raised inside methods), as well as handling $nulls, and not have `?.` at all. e.g.\r\n\r\n```powershell\r\n$varThatMayBeNull ?? $fallbackValue # null-coalescing\r\n#\r\n$varThatMayBeNull.Name ?? $fallbackvalue    # catching PropertyNotFoundStrict exception\r\n$varThatMayBeNull.Name ??  # default fallback is $null\r\n$varThatMayBeNull.Method() ??  # catching MethodNotFound Exception\r\n\r\n# and potentially addressing the index case too\r\n$varThatMayBeNull.first.second[3].Method() ??  # catching MethodNotFound Exception, or index not found Exception\r\n```\r\n\r\nAnd then, instead of `?.` calling a member or accessing a property, it could be a concise way of asking if a member exists, returning a [bool]. \r\n\r\nWith the same syntax addition of `??` and `?.` you could handle more situations, with less confusing overlap.\r\n",
      "created_at": "2019-03-21T23:09:59Z",
      "updated_at": "2019-03-21T23:09:59Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> StrictMode takes away that benefit and leaves the hindrance of having to write existence tests\r\n\r\nOne person's hindrance is another person's benefit:\r\nIt all depends on what you want to have happen _by default_:\r\n\r\n* If you're confident that there are no _typos_ in your code - by all means, take advantage of the _default_ behavior (strict mode OFF) - and you'll have no need for `.?` (for _property_ access - see next comment re _method calls_ and _indexing_).\r\n\r\n  * On a _personal_ note: I tend to use `Set-StrictMode -Version 1` to avoid typos in _variable_ names, but I find `-Version 2` or higher too annoying, primarily due to #2798 (which is a bug that is independent of this proposal).\r\n\r\n* If you want to make sure that you (a) you haven't misspelled property names and/or (b) your code doesn't accidentally operate on data types other than you meant to operate on, set strict mode to version 2 or higher.\r\n\r\n  * Indeed, that _currently_ makes it cumbersome to _opt out_ of these checks _on demand_,\r\n  * which is precisely why introducing null-conditional access is being proposed here: to make it _easy_ to opt out on demand.\r\n\r\nExplicitly testing for the presence of a member is really a separate use case that can be a necessity irrespective of the strict mode in effect.\r\n\r\n",
      "created_at": "2019-03-22T02:00:15Z",
      "updated_at": "2019-03-22T02:35:02Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "As for _method calls_, which the OP doesn't cover:\r\n\r\n_Method calls_ (e.g., `$varThatMayBeNull.Method()`) and _indexing_ (e.g., `$varThatMayBeNull[$index]`) are two cases where even strict mode being off or at version 1 could benefit, given that both cases currently _invariably_ cause an error if the value being accessed is `$null`.\r\n\r\nThe syntax would be same as for properties for methods - `$varThatMayBeNull?.Method()` - and analogous for indexing - `$varThatMayBeNull?[$index]` - as in C#.\r\n\r\n_Update_: There is a second aspect to indexing, namely if the variable is non-null, but the element at the given index doesn't exist (e.g., `$arr = 0,1; $arr[2]`). With strict mode version 2 or below, this evaluates to `$null`, but in version 3 or higher it causes an error, and it would be nice to be able to opt out of this error as well. However, the syntax for this case presents a challenge - see the updated OP, which currently proposes the perhaps awkward `[...?]`.\r\n\r\nAnd, yes, I would make such access default to `$null` as well, even for methods - again, you're _explicitly_ signaling that it's fine to do nothing if the object being accessed is `$null` or if no such array element exists.\r\n\r\nNote that C# has no null-conditional indexing in the second sense.\r\n\r\n\r\n",
      "created_at": "2019-03-22T02:26:40Z",
      "updated_at": "2019-03-22T03:37:23Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "It has null-conditional indexing, just not quite like how you're proposing. C# allows (I'm pretty sure, at least...) `array?[0]` which bypasses the usual \"index into null array/collection\" issue and just returns null.\r\n\r\nBut yeah, I agree that this is a good idea. It saves us going through exception handling, and it keeps code pretty clear and concise.",
      "created_at": "2019-03-22T02:41:35Z",
      "updated_at": "2019-03-22T02:41:35Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@vexx32, that is _one_ aspect of null-conditional indexing: if `array` in `array?[0]` is `null`, the indexing operation is ignored - C# has that too, as you state.\r\n\r\nI was (update: _also_) talking about the _other_ aspect of null-conditional indexing: the case where `array` in `array?[0]` is _not_ `null` but it is _the element at index `0`_ that doesn't exist.\r\n\r\nIt is the latter that cannot be ignored in C#, to my knowledge, yet I think it would be useful too.\r\n\r\nCan you think of terminology to give these two aspects distinct names?",
      "created_at": "2019-03-22T02:50:07Z",
      "updated_at": "2019-03-22T03:43:16Z"
    },
    {
      "author": "HumanEquivalentUnit",
      "author_association": "CONTRIBUTOR",
      "body": "The code from another JavaScript issue would go from `$_.Description[0].Text` to `$_?.Description[0?]?.Text` which I think is not pretty; and my other suggestion for how `??` could behave would take it to `$_.Description[0].Text ??` which is subjectively nicer, and would - if possible to implement - handle failures at any lookup point in the chain all in one go, and still let you choose what you want to happen by default, and have a different fallback at will instead of being limited to only `$null`.\r\n\r\nAs an aside, would this `?.` syntax have an analogue for static properties and methods, i.e. `$t = [int]; $t::MaxValu; $t::Pars(\"1\")`, would that become `?:`  or `?::` ?\r\n\r\nWhat would be the desired behaviour for array indexing with more than one index specified? `$array[0,4?,1,2]` where each one can be allowed to fail, or `$array[0,4,1,2?]` with only the entire lot allowed to succeed or fail?",
      "created_at": "2019-03-22T03:45:56Z",
      "updated_at": "2019-03-22T03:47:23Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I first have to take a step back, because I realize that I've conflated aspects that are worth separating, at least conceptually:\r\n\r\n* _Null-value_-conditional member or index access, as in C#:\r\n  * If a value being accessed is `$null`, ignore attempts to access its members or index into it and evaluate to `$null`.\r\n\r\n* _Member-existence_-conditional member or index access, specific to PowerShell:\r\n  * If a value being accessed is _non-`$null`_, ignore attempts to access non-existing _members_ (properties, method calls, indexing) that don't exist.\r\n  \r\nNote: For brevity I'm using _member_ somewhat loosely here to also encompass _elements_ of objects that happen to be collections, which are accessed with _indexing_ rather than dot notation.",
      "created_at": "2019-03-22T04:01:20Z",
      "updated_at": "2019-04-01T14:00:28Z"
    },
    {
      "author": "HumanEquivalentUnit",
      "author_association": "CONTRIBUTOR",
      "body": "> If you're confident that there are no typos in your code - by all means, take advantage of the default behavior (strict mode OFF) - and you'll have no need for .? (for property access\r\n\r\n@mklement0 I think you're discussing from the view \"*one person using strict mode to improve their own code*\" and I from the view \"*someone else can run my code in strictmode, what changes would make my code work for them as well?*\" and that's leading me down different reasoning. With `?.` it would be so convenient to use it instead of `.` and make code also work in strictmode that I may as well use it everywhere habitually; I lose nothing and gain compatibility. I fear all PowerShell code will uglify in that way because it \"works\" in more cases.\r\n\r\nBut it isn't a drop-in replacement, because it silences failed method call lookup in non-strictmode, and silences failed property lookups in strictmode - it adds a fiddly nuance to member lookup, an incredibly common operation. It doesn't help anyone who wants to benefit from strictmode checks by making that boilerplate easier. It doesn't help enough people in enough situations, for the complexity it adds. And it's too convenient to make code more compatible, I don't think \"ignore it if you don't want it\" is strong enough to hold it at bay.\r\n\r\nPowerShell can do things C# doesn't, like setting automatic variables, or having a precedent for having exceptions be thrown and silenced behind the scenes. *There's got to be a better approach* which doesn't complexify member lookup at all, but simplifies strictmode safety check boilerplate so that people who do want to use the checks have easier lives and people who were annoyed by the checks have easier lives as well. \r\n\r\n",
      "created_at": "2019-03-22T21:46:45Z",
      "updated_at": "2019-03-22T21:48:46Z"
    },
    {
      "author": "Halkcyon",
      "author_association": "NONE",
      "body": "@HumanEquivalentUnit  How does it silence these things?  You would have to write a load of exception handling and null checks previously, instead:\r\n\r\n    $prop = $item?.Method().PropIwant ?? 'PropActionFailed'\r\n\r\nv.\r\n\r\n    $prop = if ($null -ne $item) {\r\n        $propIwant= $item.Method().PropIwant\r\n        if ($null -eq $propIwant) {\r\n            'PropActionFailed'\r\n        }\r\n        else {\r\n            $propIwant\r\n        }\r\n    }\r\n\r\nAnd this case isn't uncommon.  Or you just throw `$ErrorActionPreference = 'Stop'` and wrap the whole thing in `try/catch` to simplify the null checking which is *a bad pattern* (exception-driven logic).\r\n\r\nAlso, this is the future of the language, it's not like we're going back to 5.1 and changing things.  If you want more adopters, you need to make it *easier* to read code, which I feel this suggestion does.",
      "created_at": "2019-03-25T22:01:07Z",
      "updated_at": "2019-03-25T22:07:44Z"
    },
    {
      "author": "kfsone",
      "author_association": "NONE",
      "body": "> @mklement0 I think you're discussing from the view \"_one person using strict mode to improve their own code_\" and I from the view \"_someone else can run my code in strictmode, what changes would make my code work for them as well?_\"\r\n\r\nAre we talking about \"set -euo pipefail\" (bash strict mode) equivalent?\r\n\r\na- Limit to variable look-ups (although I don't see why you think a simple null check on member lookups would be a bad thing, the actual member lookup is way more expensive than `if (result is null)`)\r\nb- Use `[Strict]` on scopes/codeblocks to tell the parser to treat them as such,\r\nc- Strictness is based on scope: code that isn't marked strict isn't strict.\r\n\r\nIf I wrote strict code that fails when you use it, then one of us made a mistake. Either I referenced a missing variable in code I never tested or you've misunderstood my badly designed API that depends on the existence of variables that aren't passed in to my function and you failed to populate a variable I expect to be populated...\r\n\r\n```powershell\r\n# Their code\r\nFunction Log($Message) { Write-Host $Massege }  # not strict\r\n\r\n# My code\r\n[Strict]\r\nFunction DebugMsg\r\n{\r\n  Param([String] $Message)\r\n  if ($DEBUG) { Log Host $Message }\r\n}\r\n\r\n# Your code\r\nDebugMsg \"Hello\"  # you didn't define DEBUG, and by saying strict I expressed a contract whereby the variable MUST be defined.\r\n```\r\n\r\nThe \"Log\" function wasn't marked strict so it doesn't complain about the typo",
      "created_at": "2019-03-26T01:26:53Z",
      "updated_at": "2019-03-26T01:28:24Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "\ud83e\udd14 Now that you mention it, a `[Strict()]` attribute would be an _awesome_ way to implement strict mode in a scope-restricted way. That needs to be mentioned in that other issue thread on strict mode issues, I'll go dig that up and link back here...",
      "created_at": "2019-03-26T13:18:24Z",
      "updated_at": "2019-03-26T13:18:24Z"
    },
    {
      "author": "HumanEquivalentUnit",
      "author_association": "CONTRIBUTOR",
      "body": "@TheIncorrigible1 \"*How does it silence these things?*\" in non-strict mode `$null.x` is silent, `$null.x()` is an exception. With `?.` as discussed, `$null?.x` is silent, `$null?.x()` is silent. \r\n\r\nSo you'd have a `.` which works like C#'s `?.`, except in strict-mode where it throws exceptions. Then you'd have a `?.` which works in strict mode like C#'s `?.` and like PowerShell's `.` works in in non-strict mode, but which works differently to PowerShell's `.` in non-strict mode for method calls. What a horrible combination, (and a combination where `?.` is clearly better and more useful in more of those scenarios).\r\n\r\n> You would have to write a load of exception handling and null checks previously, instead: `$prop = $item?.Method().PropIwant ?? 'PropActionFailed'`\r\n\r\nYour method call might throw, or return $null and PropIWant might be missing, you'd still have to write:\r\n\r\n    $prop = try {\r\n        $item?.Method()?.PropIwant ?? 'PropActionFailed'  \r\n    } catch [someMethodException] {\r\n        'PropActionFailed'\r\n    }\r\n\r\nvs with my proposed `??` (if it was possible to build), and no need for `?.`, and it covers possible cases of Method exceptions in case all you care about is \"success or not\" and no detailed error handling.\r\n\r\n    $prop = $item.Method().PropIWant ?? 'AnythingFailed'\r\n\r\n>  If you want more adopters, you need to make it easier to read code, which I feel this suggestion does.\r\n\r\nHow often do you type `.` in PowerShell? How often do you want to explain to new users what the difference is between `.` and `?.` and tell them they have to consider the difference *every time they type a `.` forever*?\r\n\r\n\"Oh, how did that come about?\" \"Well in C# `.` threw an exception for missing members, so they invented `?.` which didn't. That was great, so they did that in PowerShell by default, the `.` doesn't throw. Then they invented strict-mode which makes `.` behave like C# and throw but only in that context, But the way to manually check members was really wordy and bothersome and nobody wanted to type it; instead of addressing that problem head-on and making that more convenient to benefit from the strictmode, they dodged that and aped C#'s `?.` instead to gain a sneaky way out of the strictness that you asked for, which is mildly convenient for you, but sucks for everyone else. And you still have no member existence test, and benefiting from strictmode is still wordy and bothersome, but at least you don't have to suffer that because 'strictmode' has a 'normalmode' escape hatch now\". Ick.\r\n\r\n> If I wrote strict code that fails when you use it, then one of us made a mistake.\r\n\r\n\r\n> although I don't see why you think a simple null check on member lookups would be a bad thing, the actual member lookup is way more expensive than if (result is null)\r\n\r\nI don't think that would be bad, PS non-strictmode already does that, and I think that would be a desirable alternative to the proposed `?.` - very different, useful in more situations.\r\n\r\nBut note that in PS you can do something C# cannot:\r\n\r\n    (1..3)[1kb..100kb]\r\n\r\nand no exceptions in non-strictmode. Change the numbers and see how long it takes; judging by the performance and how I think it must work behind the scenes to index into arbitrary objects, it seems there *actually are* ~100,000 exceptions being raised and silenced, for our convenience. PS doesn't always make the \"must be as fast as possible, push the inconvenience on the user\" choice, and I like that about it.\r\n",
      "created_at": "2019-03-27T01:25:56Z",
      "updated_at": "2019-03-27T01:27:33Z"
    },
    {
      "author": "Halkcyon",
      "author_association": "NONE",
      "body": "@HumanEquivalentUnit There are many features in every language you may never use in your career and if you don't like the style, that's fine, you don't need to use those features.  I don't see why you're writing strict mode off; it's a good practice in scripts so you're consciously dealing with problems rather than letting the language swallow them (and in essence, having implicit empty catch blocks everywhere).  Again, you're still welcome to *not* use the features (e.g. I've never used `Out-Default`).\r\n\r\nAlso, the operator is `?`, not `?.`; it  would work with index access as well.",
      "created_at": "2019-04-01T12:41:08Z",
      "updated_at": "2019-04-01T12:42:00Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "To continue to lay the groundwork for further discussion, **let me summarize how the existing strict modes affect null-value-conditional and member-existence-conditional access** (the terms introduced [above](https://github.com/PowerShell/PowerShell/issues/3240#issuecomment-475486530)):\r\n\r\nThe columns below represent the `Set-StrictMode` settings, and the column values indicate:\r\n* \ud83d\udc4d ... allowed\r\n* \ud83d\udeab ... prohibited (causes statement-terminating error)\r\n\r\nAs an aside: the fact the errors are only _statement-_, not _script_-terminating, relates to the larger discussion around PowerShell's error handling - see https://github.com/PowerShell/PowerShell-Docs/issues/1583.\r\n\r\n* **_Null-value_-conditional access** - `$obj` _itself_ is `$null`:\r\n\r\nConstruct              | -Off | -Version 1 | -Version 2 | -Version 3+\r\n----------              | ---- | ---------- | ---------- | ------------\r\n$obj                        | \ud83d\udc4d   | \ud83d\udeab             | \ud83d\udeab             | \ud83d\udeab\r\n$obj.Prop               | \ud83d\udc4d   | \ud83d\udc4d             | \ud83d\udeab             | \ud83d\udeab\r\n$obj[42]                  | \ud83d\udeab   | \ud83d\udeab             | \ud83d\udeab             | \ud83d\udeab\r\n$obj.Method()       | \ud83d\udeab   | \ud83d\udeab             | \ud83d\udeab             | \ud83d\udeab\r\n\r\nIt is curious that with `-Off` and `-Version 1`, `$obj.Prop` is allowed, whereas `$obj[42]` isn't.\r\n\r\n* **_Member-existence_-conditional access** - `$obj` is non-`$null`, but the member / element being accessed doesn't exist:\r\n\r\nConstruct                             | -Off | -Version 1 | -Version 2 | -Version 3+\r\n----------                             | ---- | ---------- | ---------- | ------------\r\n$obj.Prop                              | \ud83d\udc4d   | \ud83d\udc4d             | \ud83d\udeab             | \ud83d\udeab\r\n$obj[42] (indexable)            | \ud83d\udc4d   | \ud83d\udc4d             | \ud83d\udc4d             | \ud83d\udeab\r\n$obj[42] (non-indexable)    | \ud83d\udc4d   | \ud83d\udc4d             | \ud83d\udeab             | \ud83d\udeab\r\n$obj.Method()                      | \ud83d\udeab   | \ud83d\udeab             | \ud83d\udeab             | \ud83d\udeab\r\n\r\nIt is curious that inherently indexable objects (e.g., arrays) allow access to nonexistent elements even with `-Version 2`, whereas scalars - where PowerShell provides indexing capabilities for the sake of unified handling with collections - do not.\r\n\r\n\r\n",
      "created_at": "2019-04-01T14:20:25Z",
      "updated_at": "2019-04-01T14:20:25Z"
    },
    {
      "author": "IanKemp",
      "author_association": "NONE",
      "body": "The null-soaking ([null-conditional or Elvis in C#](https://docs.microsoft.com/en-gb/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-)) operator is almost mandatory when running in StrictMode Latest and trying to access a property that may or may not exist. Currently you have to resort to stupid tricks like this:\r\n\r\n```powershell\r\nfunction Get-OptionalPropertyValue($object, [string] $propertyName) {\r\n    if (-not ([bool] (Get-Member -InputObject $object -MemberType Properties -Name $propertyName))) {\r\n        return $null\r\n    }\r\n\r\n    $object.$propertyName\r\n}\r\n\r\n$value = Get-OptionalPropertyValue $foo \"bar\" # if $foo.bar exists, $value will contain its data; else $value will be $null\r\n```\r\n\r\nwhen you _really_ should just be able to write:\r\n\r\n```powershell\r\n$value = $foo?.bar # if $foo.bar exists, $value will contain its data; else $value will be $null\r\n```\r\n\r\nPlease guys, if you could get **only** null-conditional from this proposal implemented and **only** for properties, it would save so many people so much pain.",
      "created_at": "2019-07-25T11:19:04Z",
      "updated_at": "2019-07-25T11:20:32Z"
    },
    {
      "author": "adityapatwardhan",
      "author_association": "MEMBER",
      "body": "I started having a look at this and found a few problems.\r\n\r\nLets consider `??` and `?=`\r\n\r\n`$x ?= 1` and `$x ?? 1` seem to be straightforward. But, since they are operators we need to support `$x?=1` and `$x??1`. \r\n\r\nThe  problem with that is `$x?` and `$x??` both validate variable names in PowerShell. The only way to disambiguate would be `${x}?=1` and `${x}??1`.\r\n\r\nAnd more over for conditional member access `?.` and `?[]`, we would have to have `${x}?.name` and `${x}?[0]`.\r\nFor these, `$x ?.name` and `$x ?[0]` will not be supported.\r\n\r\nThe other option is to introduce a **breaking change** and not allow `?` in the variable name at all. \r\n\r\nWhat do you think? @mklement0 \r\n\r\n/cc @rjmholt @daxian-dbw @JamesWTruher ",
      "created_at": "2019-08-23T00:55:36Z",
      "updated_at": "2019-08-23T00:55:36Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I have never particularly _liked_ nor understood why `?` is a valid variable name. It opens the door for names like `$Safe?` which is generally more clear and less awkward when written as `$IsSafe` anyway.\r\n\r\nI think that change has probably been a long time coming.",
      "created_at": "2019-08-23T01:20:26Z",
      "updated_at": "2019-08-23T01:20:26Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> It opens the door for names like $Safe? which is generally more clear and less awkward when written as $IsSafe anyway\r\n\r\nInterestingly I expressed the opposite sentiment. It's a classic [Scheme](https://courses.cs.washington.edu/courses/cse341/05au/lectures/scheme-predicates.html)/[Ruby](http://ruby-for-beginners.rubymonstas.org/objects/predicates.html) tradition.\r\n\r\n```powershell\r\nif ($questionMark?)\r\n{\r\n    Write-Host \"That's silly!\"\r\n}\r\n```",
      "created_at": "2019-08-23T01:45:52Z",
      "updated_at": "2019-08-23T01:50:50Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "Didn't the ternary operator have this same problem, where the resolution was to require spaces around the operator or curly braces around the variable name in order for it to properly work with variables that end with `?`?\r\n\r\nI would expect that with these operators being introduced, PowerShell would prioritize recognizing the `?` as part of the operator in syntax such as `$x?[0]`, such that users who use variable names ending in `?` to store a collection would have to use this syntax instead (since spaces would be invalid in this case): `${x?}?[0]`. Ditto for `$x?.Name` and `${x?}?.Name`.",
      "created_at": "2019-08-23T01:59:58Z",
      "updated_at": "2019-08-23T02:03:57Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "> The other option is to introduce a breaking change and not allow ? in the variable name at all.\r\n\r\n\ud83d\udc4d  Given this is a major version change (6 to 7), I think it is worth a breaking change here.  I wish GitHub had better code search to see how many instances there are of PS variables that end with a `?`.   I suspect this wouldn't be that impactful but it would be nice to verify that against GitHub.  In 14 years of using PowerShell, I've never used a `?` in a variable name but maybe that's just me.  :-)",
      "created_at": "2019-08-23T02:03:47Z",
      "updated_at": "2019-08-23T02:15:11Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "That ship has sailed long ago, and I wouldn't be surprised to see variables ending with `?` in use in scripts today.\r\n\r\nAt this point if we simply prioritize parsing `?` as part of an operator rather than as part of a variable name when it comes to these new operators, folks who use variable names ending in `?` would need to use `{}` or spaces (where spaces are allowed) to use those variables with these operators.",
      "created_at": "2019-08-23T02:07:31Z",
      "updated_at": "2019-08-23T02:07:31Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "It's strange to hear the phrase \"that ship has sailed\" in this context. This is a _major version_ change. It's not unreasonable for this to change here, I think.",
      "created_at": "2019-08-23T02:22:43Z",
      "updated_at": "2019-08-23T02:22:43Z"
    },
    {
      "author": "Halkcyon",
      "author_association": "NONE",
      "body": "@rkeithhill I've used it in personal stuff, but thought it would be unclear to collaborative work since it's such an anti-intuitive thing to programmers to have symbols as part of variable names (similar to using emojis as variables)\r\n\r\n@KirkMunro having \"prioritizied parsing\" sounds like an open door for bugs.",
      "created_at": "2019-08-23T14:25:50Z",
      "updated_at": "2019-08-23T14:27:31Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@vexx32: It's not unreasonable for a breaking change since this is a major version change; however, the bar for such breaking changes should remain very high, and I don't think this comes close to passing that bar, since users could use variables ending in `?` just fine as long as they use the `{}` enclosures to identify the variable name.\r\n\r\nNote that you can have a property name that ends in `?` as well. Currently if you try to view such a property in PowerShell without wrapping the name in quotes, you'll get a parser error.\r\n\r\nFor example:\r\n\r\n```none\r\nPS C:\\> $o = [pscustomobject]@{\r\n    'DoesItBlend?' = $true\r\n}\r\nPS C:\\> $o.DoesItBlend?\r\nAt line:1 char:15\r\n+ $o.DoesItBlend?\r\n+               ~\r\nUnexpected token '?' in expression or statement.\r\n+ CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException\r\n+ FullyQualifiedErrorId : UnexpectedToken\r\n\r\nPS C:\\> $o.'DoesItBlend?'\r\nTrue\r\n```\r\n\r\nI'm a little surprised that doesn't parse today (why doesn't that parse?), but regardless, for such properties you need to enclose their name in quotes, in which case you could follow the quote with a ternary, null-coalescing, etc. operator without spaces and it would work just fine. I find this syntax very similar to `${x?}?.name`, and I'm ok with the stance that you can use such variable/property names if you want, but such names may require extra syntax or spacing to work with ternary or null-* operators.",
      "created_at": "2019-08-23T14:27:22Z",
      "updated_at": "2019-08-23T14:28:28Z"
    },
    {
      "author": "Halkcyon",
      "author_association": "NONE",
      "body": "@KirkMunro Nothing stops people from using variable-bounds going forward if they want esoteric variable names.  I do agree with the others in that I wonder what the current usage of that behavior is currently in use.\r\n\r\nPeople on PowerShell 7 are likely already enthusiasts and will be aware of the breaking changes.  People who are not, are still using <=v5.1 and will continue to for a long time; likely until msft removes it from Windows 10 (never).",
      "created_at": "2019-08-23T14:31:12Z",
      "updated_at": "2019-08-23T14:31:46Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@KirkMunro Sure, but removing it from the standard permissible variable characters doesn't prevent users from just doing `${Valid?}` as the variable name anyway. Since they'd have to do that with these operators regardless, I think it'd be better to just have it consistent, rather than have `?` become a character that's _only sometimes_ considered part of a variable name.\r\n\r\nThat already _is_ going to be a breaking change, and I'd think it best to at least be consistent about it and go all the way rather than introduce another level of ambiguity. \ud83d\ude42 ",
      "created_at": "2019-08-23T14:36:44Z",
      "updated_at": "2019-08-23T14:36:44Z"
    },
    {
      "author": "Halkcyon",
      "author_association": "NONE",
      "body": "@adityapatwardhan I think it would be better for the language to remove `?` as a valid variable character.  It would easily enable both null-soak/-coalesce and ternary operators in a familiar syntax which add a lot of ergonomics to the script authoring process.",
      "created_at": "2019-08-23T14:44:37Z",
      "updated_at": "2019-08-23T14:44:37Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "> @KirkMunro having \"prioritized parsing\" sounds like an open door for bugs.\r\n\r\n@TheIncorrigible1: Any code can open the door for bugs if it's not implemented properly. I'm just talking about a simple single-character lookahead to identify if PowerShell runs into a ternary or null-* operator when it parses a variable name that is not enclosed in variable bounds and encounters a `?` character. That's not complicated, and doesn't open the door for more bugs than any other code change does.\r\n\r\n> People on PowerShell 7 are likely already enthusiasts and will be aware of the breaking changes. People who are not, are still using <=v5.1 and will continue to for a long time; likely until msft removes it from Windows 10 (never).\r\n\r\n@TheIncorrigible1: What basis/evidence do you have of that statement? PowerShell 7 is in preview, so today it's only used by enthusiasts. That's a given. But beyond preview, if PowerShell 7 or later offer compelling features that companies need, while supporting the functionality they need, they'll use those versions. That is especially true if PowerShell 7 gets installed with the OS. The only point that enthusiasts comes into play is in organizations that don't have a business need for what PowerShell 7 brings to the table.\r\n\r\n> That already is going to be a breaking change, and I'd think it best to at least be consistent about it and go all the way rather than introduce another level of ambiguity. \ud83d\ude42\r\n\r\n@vexx32 That's stretching it. It would be a breaking change if you had `??` in a variable name, but the likelihood of that is much more remote than having a variable whose name ends in a single `?`. Other than that, how would the introduction of null-* operators while still supporting `?` as a standard permissible variable character break scripts today?\r\n\r\nIn my experience breaking changes for nice-to-haves (which is what this seems to be) are by far more often than not rejected, and the discussion/arguments around them only serve to slow down the process of getting things done dramatically, to the point where things just stall or miss getting into a release, etc. The slow down is often necessary, because if you're proposing a breaking change evidence is needed to be able to assess the impact and justify such a change. It's hard to gather that evidence today. I'm just saying this because I'll choose getting features done now over arguing about a nice-to-have breaking change any day.\r\n\r\nI never use `?` in variable names, nor would I. I expect some folks do, though, because it can read very well in a script, and putting up unnecessary barriers to entry for PowerShell 7 just slows down adoption, especially when many people working with PowerShell aren't developers who are more accustomed to working through breaking changes.\r\n\r\nAnyway, it is not my intent to slow down this process -- rather the opposite. But I've shared my thoughts and experience, so I won't comment further on whether or not we should push for a breaking change here.",
      "created_at": "2019-08-23T15:02:57Z",
      "updated_at": "2019-08-23T15:02:57Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Consider this contrived example:\r\n\r\n```powershell\r\n$ValueIsValid? = @( $true, $false, $false, $true )\r\n\r\n$ValueIsValid?[0]\r\n# old behaviour? gets `$true`\r\n# new behaviour? gets nothing, because the `?[0]` is interpreted as a null-conditional access.\r\n```\r\n\r\nThis behaviour would _already_ break with the proposed changes. I would prefer a consistent, clean break than a confusing break that needs a half-page explanation to list all the possible exceptions and when and where `?` suddenly isn't valid, and where it still is.",
      "created_at": "2019-08-23T15:13:49Z",
      "updated_at": "2019-08-23T15:14:42Z"
    },
    {
      "author": "Halkcyon",
      "author_association": "NONE",
      "body": "> @KirkMunro if PowerShell 7 or later offer compelling features that companies need, while supporting the functionality they need, they'll use those versions. That is especially true if PowerShell 7 gets installed with the OS.\r\n\r\nHaving worked in a few Fortune 50s with some employee bases being in the hundreds of thousands, even getting away from what was default on the OS was a challenge (i.e., moving to v5.x).  I have yet to see any place adopt *Core*; they'd rather just move to Python for cross-compatibility.  Enabling Windows optional features was also a pretty seldom task.\r\n\r\nI think companies work with what they have and the knowledge base of their employees over seeking out new technology or language versions to solve their problems.  Some would be perfectly content staying on v2 forever and never touching the Win10/Server16 cmdlets that make life dramatically easier.\r\n\r\nMy point with all of this, is that these features are not in a vacuum.  If you make a language more ergonomic, it will see greater adoption by people being interested in the tool to solve the problems they have faster.  (See: C# and the growth in popularity with more/better language features)",
      "created_at": "2019-08-23T15:30:27Z",
      "updated_at": "2019-08-23T15:30:27Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "Regarding variables ending in `?` - that could be a significant breaking change because of the automatic variable [$?](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables?view=powershell-6#section-1).",
      "created_at": "2019-08-23T16:43:11Z",
      "updated_at": "2019-08-23T16:43:11Z"
    },
    {
      "author": "Halkcyon",
      "author_association": "NONE",
      "body": "@lzybkr I suspect the best case for dealing with that is a special case like what *already* exists for `$^` and `$$`.",
      "created_at": "2019-08-23T16:52:21Z",
      "updated_at": "2019-08-23T16:52:21Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@lzybkr @TheIncorrigible1 As far as I remember, _all_ of those variables are explicitly special-cased in the tokenizer. `$^` _already_ isn't a valid variable name. The tokenizer has special cases for all of those before it starts looking for standard variable names.",
      "created_at": "2019-08-23T17:05:53Z",
      "updated_at": "2019-08-23T17:05:53Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "The only solution here is to use `\u00bf`:\r\n\r\n$silly?\u00bf=1\r\n",
      "created_at": "2019-08-23T19:07:46Z",
      "updated_at": "2019-08-23T19:07:46Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I dunno Steve, I'm firmly in the interrobang crowd on this one. \r\n```powershell\r\n$silly?\u203d=1\r\n```",
      "created_at": "2019-08-23T19:13:22Z",
      "updated_at": "2019-08-23T19:13:22Z"
    },
    {
      "author": "adityapatwardhan",
      "author_association": "MEMBER",
      "body": "@lzybkr - to my knowledge `$?` `$$` and `$^` are treated in a special way. \r\n\r\nhttps://github.com/PowerShell/PowerShell/blob/8b9f4124cea30cfcd52693cb21bcd8100d39a796/src/System.Management.Automation/engine/parser/tokenizer.cs#L3001-L3004\r\n\r\nTo summarize, we have these four options\r\n\r\n- Big breaking change - not allow `?` in the variable names.\r\n- Prefer `?.`  as an operator. This means variable names ending with `?` must use `${variablename}` syntax. Still a breaking change.\r\n- Prefer old behavior. This means to use `?.` and `?[]`, `${variablename}?.property` must be used. No breaking change, but makes using the new operators clumsy.\r\n- Do not implement the new operators.\r\n\r\nI personally, do not prefer the 1st and the last one.\r\n",
      "created_at": "2019-08-23T19:17:39Z",
      "updated_at": "2019-08-23T19:17:39Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> This is a major version change. It's not unreasonable for this to change here, I think.\r\n\r\nI think an important point to make is that the major version is being incremented to signal readiness to replace Windows PowerShell, which is to say it indicates compatibility, not breakage. From the [original announcement](https://devblogs.microsoft.com/powershell/the-next-release-of-powershell-powershell-7/):\r\n\r\n> Note that the major version does not imply that we will be making significant breaking changes.",
      "created_at": "2019-08-23T19:22:27Z",
      "updated_at": "2019-08-23T19:26:53Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Are options 1 and 2 not the same? Or would variables still be permitted to use `?` in the case that there is no null-coalescing or ternary operator following them?\r\n\r\nIf so, I think we may have a lot of trouble handling the tokenizing / parsing logic without a lot of backtracking. This might lead to performance degradations when variables end with `?`.\r\n\r\nGiven that from what I can see, option 2 seems to be the general preference, I'm not really sure I understand the reluctance to make the breaking change here. Doing it that way will actively discourage use of `?` in variable names anyway, simply by introducing scenarios that they aren't usable without enclosing the variable name. \r\n\r\nI think this is a fairly minor change as breaking changes go, and having a break in the consistency of what can and can't be used in a variable name is probably the worse option, in my opinion. \r\n\r\nThese things should have clear rules that apply in pretty much all situations. Currently, this is the case. We're proposing to muddy the waters here and make the behaviour _less_ clear. I can't see anything good coming from it, except perhaps that variable names containing `?` become less used simply because they're harder to use in some scenarios -- which (effectively) brings us right back to option 1 by default, almost... so I don't see any particular reason not to take the break now and just avoid the ambiguous behaviour.",
      "created_at": "2019-08-23T19:29:15Z",
      "updated_at": "2019-08-23T19:29:15Z"
    },
    {
      "author": "adityapatwardhan",
      "author_association": "MEMBER",
      "body": "@vexx32 There is a slight difference between 1 and 2. \r\n\r\nFor # 1 we disallow `?` to be used in variable names all together. This means `$x? = 1`, `$x?? = 1` `$x?x?x = 1`  will not parse.  \r\n\r\nFor # 2, `$x? = 1` is still valid but `$x?.name` is equivalent to `${x}?.name`. This only breaks variable names with `?` at the end, which are accessing members. So, `$x? = 1`, `$x?? = 1` `$x?x?x = 1` would still be valid.\r\n\r\n",
      "created_at": "2019-08-23T20:04:41Z",
      "updated_at": "2019-08-23T20:12:49Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Yeah, I'd be a little concerned about tokenizing overhead there. Might be worth implementing both possibilities and doing some benchmarks on a script that uses similar variables names reasonably heavily.\r\n\r\nMy preference is definitely option 1... a one-time breaking change is, to me at least, way more preferable to having to deal with the inconsistencies in how that can be parsed way into the future.",
      "created_at": "2019-08-23T20:32:38Z",
      "updated_at": "2019-08-23T20:32:38Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> If so, I think we may have a lot of trouble handling the tokenizing / parsing logic without a lot of backtracking. This might lead to performance degradations when variables end with ?.\r\n\r\nI share this concern about that possibility. Having `?` as a sometimes-token-separator feels like a jagged line in the language to me.",
      "created_at": "2019-08-23T22:10:45Z",
      "updated_at": "2019-08-23T22:10:45Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "> If so, I think we may have a lot of trouble handling the tokenizing / parsing logic without a lot of backtracking. This might lead to performance degradations when variables end with ?.\r\n\r\nIt depends on how you implement it. As long as you take a lookahead approach rather than a tokenize and then back-up approach, you should be fine. You can look ahead at what characters are next when you encounter a `?` in a variable name, and make a decision on how you want to \"wrap up\" the variable token based on what's next. That isn't a lot of trouble and shouldn't require backtracking or result in noticable performance degradations.",
      "created_at": "2019-08-24T21:30:55Z",
      "updated_at": "2019-08-24T21:30:55Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "@PowerShell/powershell-committee reviewed this one today, we have a couple thoughts:\r\n\r\n* No matter what we do, we're going to do some analysis of our corpus of scripts to see how often folks use `?` in variable names\r\n* Some of us have a hypothesis (that others would like to validate) that the users who are using `?` in their variable names may be less advanced users (as we agree in this room we'd stay away from it because of the potential problems that could arise). On the other hand, anyone using the functionality described here will be able to understand a slightly more complicated syntax (like `${foo}?.bar`). Therefore, we prefer [option 3](https://github.com/PowerShell/PowerShell/issues/3240#issuecomment-524431897) because it avoids breaking changes on these less experienced users. (But again, we will validate it per the first bullet.)\r\n* @daxian-dbw raised a good point about making it harder to find all variable references when scripters are mixing usage of `$foo` and `${foo}`. However, we agreed that this can be fixed in tooling (like the VS Code PowerShell extension), and users like @JamesWTruher who use editors like Vim can easily match on both with their search syntax. ",
      "created_at": "2019-08-26T19:06:08Z",
      "updated_at": "2019-08-26T19:06:08Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": ">  harder to find all variable references when scripters are mixing usage of $foo and ${foo}\r\n\r\nThat depends on whether the AST differentiates the variable name based on whether it saw the braces. I suspect that any tool that uses the PowerShell AST will have no trouble with braces here.",
      "created_at": "2019-08-29T03:02:35Z",
      "updated_at": "2019-08-29T03:02:35Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "But for regex, it certainly means you have to be more aware: `varname` -> `\\{?varname\\}?`",
      "created_at": "2019-08-29T03:03:46Z",
      "updated_at": "2019-08-29T03:03:46Z"
    },
    {
      "author": "Halkcyon",
      "author_association": "NONE",
      "body": "@rjmholt I did an analysis [over here](https://github.com/PowerShell/PowerShell-RFC/pull/223#discussion_r318848897).  A quick breakdown: Out of nearly 400,000 scripts with 22,000,000+ variable names (not unique), there were only ~70 unique variables that ended with `?`.",
      "created_at": "2019-08-29T13:14:43Z",
      "updated_at": "2019-08-29T13:15:07Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @mburszley - to me that makes it a [Bucket 3: Unlikely Grey Area](https://github.com/PowerShell/PowerShell/blob/master/docs/dev-process/breaking-change-contract.md#bucket-3-unlikely-grey-area) change, and burdening user with the need for `{...}` is highly unfortunate, paralleling [the unfortunate need for `$(...)` around `exit` / `return` / `throw` statements in the context of `&&` and `||`](https://github.com/PowerShell/PowerShell/issues/10967#issuecomment-550551624).\r\n\r\nTo borrow the reasoning from that issue:\r\n\r\nIf we force the use of `{...}` around variable names just so you can use `?.`:\r\n\r\n* New users will not expect the need for `{...}` and won't necessarily know that _it_ is what is required when the following fails (possibly _undetected_, unless `Set-StrictMode -Version 2` or higher is in effect): `$o = [pscustomobject] @{ one = 1 }; $o?.one`\r\n\r\n* Even once users _do_ know about the need for `{...}`:\r\n  * They will forget to use it on occasion, because of the counter-intuitive need for it.\r\n  * When they do remember, this seemingly artificial requirement will be an ongoing source of frustration, especially since `{...}` is hard to type.\r\n\r\n\r\n",
      "created_at": "2019-11-24T21:17:42Z",
      "updated_at": "2020-08-29T21:30:46Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This issue has been marked as fixed and has not had any activity for **1 day**. It has been closed for housekeeping purposes.",
      "created_at": "2019-12-11T00:00:13Z",
      "updated_at": "2019-12-11T00:00:13Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@rjmholt, quoting you  from https://github.com/PowerShell/PowerShell/issues/10967#issuecomment-561843650:\r\n\r\n> not breaking the way we parse existing valid syntax was the right way to go. Again, a change there isn't just a case of us making a decision to support a small number of wild programs out there \u2014 we've made numerous breaking changes in cases where we thought the pros outweighed the cons (not that I personally agree with all of them, or that those do or don't justify others). The issue is that changing some aspect of the tokenizer or parser means that two PowerShell versions will no longer generate the same AST for some scripts, so two PowerShells will \"see\" the same script differently. That means we can't even read the syntax the same way, so there's no PSScriptAnalyzer rule you can write to pick up possible issues around it; PSScriptAnalyzer will see a different syntax from one PowerShell version to the next.\r\n\r\n> Unlike C#, PowerShell can't pre-compile a different syntax to a compatible format for later execution, meaning that a syntactic change is tethered to the runtime. Once PowerShell makes a syntactic break, we reduce the number of scripts that can work against different versions, meaning users are forced to write two scripts, which is a serious issue for a shell and a scripting language. PowerShell is supposed to be dynamic enough to bend past all the differences with logic inside one script, but the syntax is the one non-negotiably static thing we have. And making a syntax change where both before and after are valid is especially pernicious, since there's no simple way to detect it, there's no warning for it and even after executing it in both environments, users might not know that a different behaviour occurred.\r\n\r\nIn general, I can appreciate that such changes can be very problematic and should only be made if the pros outweigh the cons, an important factor of which is how much existing code breaks.\r\n\r\n> we reduce the number of scripts that can work against different versions\r\n> meaning users are forced to write two scripts\r\n\r\nWe're talking about a _new_ syntactic feature here (`?.`), so by definition scripts that use it _cannot_ (meaningfully) run on older versions - unless you specifically add conditionals that provide legacy-version-compatible code paths, but that seems hardly worth it - you would then just stick with the legacy features.\r\n\r\nYes, the interpretation of `$var?.foo` in old scripts that used `$var?` as  a variable name would break, but:\r\n\r\n* `?` should never have been allowed as part of an identifier _without enclosing it in `{...}`_.\r\n\r\n* Since being able to do so is unexpected and probably even _unknown_ to many, such variable names are exceedingly rare in the wild, speaking from personal experience, but [@mburszley's analysis provides more tangible evidence](https://github.com/PowerShell/PowerShell/issues/3240#issuecomment-526179551).\r\n\r\n   * Even Ruby only allows `?` (and `!`) at the _end_ of identifiers, and there only of _method_ identifiers, and I suspect that most Ruby users are aware that they should _not_ assume that other languages support the same thing.\r\n\r\nSo, pragmatically speaking:\r\n\r\n* The vast majority of existing code will not be affected - a token such as `$var?.foo` will simply not be encountered.\r\n\r\n* If you write `$var?.foo` with the new semantics, then yes, running that on older versions could result in different behavior (rather than breaking in an obvious manner), depending on what strict mode is in effect - but _you should always enforce the minimum version required to run your code as intended anyway_ (`#requires -Version`, module-manifest keys).\r\n\r\nAll in all, to me this a clear case of a bucket 3 change: a technically breaking change that breaks very little existing code while offering real benefits (or, conversely, avoiding perennial headaches due to unexpected behavior).\r\n\r\n\r\n\r\n",
      "created_at": "2019-12-14T19:25:05Z",
      "updated_at": "2020-08-29T21:31:23Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@mklement0 we're keeping the Null-Conditional access experimental for PS7.0.  Perhaps you can open a new issue to continue this discussion for 7.1?",
      "created_at": "2019-12-16T22:07:10Z",
      "updated_at": "2019-12-16T22:07:10Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Sounds good, @SteveL-MSFT  - please see #11379.\r\n\r\nI encourage everyone here to again show support (or, gasp, non-support) there.",
      "created_at": "2019-12-17T16:27:31Z",
      "updated_at": "2019-12-17T16:27:31Z"
    }
  ],
  "created_at": "2017-03-02T20:28:43Z",
  "labels": [
    "Issue-Enhancement",
    "WG-Language",
    "Resolution-Fixed"
  ],
  "number": 3240,
  "state": "closed",
  "title": "Suggestion: implement null-coalescing, null-conditional access (null-soaking), null-conditional assignment",
  "updated_at": "2020-08-29T21:31:23Z"
}