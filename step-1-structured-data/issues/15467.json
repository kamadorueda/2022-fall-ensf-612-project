{
  "_url": "https://github.com/PowerShell/PowerShell/issues/15467",
  "author": "rjmholt",
  "body": "<!-- Anything that looks like this is a comment and can't be seen after the Pull Request is created. -->\r\n\r\n# PR Summary\r\n\r\nFixes https://github.com/PowerShell/PowerShell/issues/15466.\r\n\r\nAdds longpath support back for `Remove-Item` and tries to move the tests for OneDrive paths so that they don't cause side effects for existing tests.\r\n\r\n## PR Context\r\n\r\n<!-- Provide a little reasoning as to why this Pull Request helps and why you have opened it. -->\r\n\r\n## PR Checklist\r\n\r\n- [x] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [x] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` or `[ WIP ]` to the beginning of the title (the `WIP` bot will keep its status check at `Pending` while the prefix is present) and remove the prefix when the PR is ready.\r\n- **[Breaking changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)**\r\n    - [x] None\r\n    - **OR**\r\n    - [ ] [Experimental feature(s) needed](https://github.com/MicrosoftDocs/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/About/about_Experimental_Features.md)\r\n        - [ ] Experimental feature name(s): <!-- Experimental feature name(s) here -->\r\n- **User-facing changes**\r\n    - [x] Not Applicable\r\n    - **OR**\r\n    - [ ] [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n- **Testing - New and feature**\r\n    - [ ] N/A or can only be tested interactively\r\n    - **OR**\r\n    - [x] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n- **Tooling**\r\n    - [x] I have considered the user experience from a tooling perspective and don't believe tooling will be impacted.\r\n    - **OR**\r\n    - [ ] I have considered the user experience from a tooling perspective and opened an issue in the relevant tool repository. This may include:\r\n        - [ ] Impact on [PowerShell Editor Services](https://github.com/PowerShell/PowerShellEditorServices) which is used in the [PowerShell extension](https://github.com/PowerShell/vscode-powershell) for VSCode\r\n        (which runs in a different PS Host).\r\n            - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n        - [ ] Impact on Completions (both in the console and in editors) - one of PowerShell's most powerful features.\r\n            - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n        - [ ] Impact on [PSScriptAnalyzer](https://github.com/PowerShell/PSScriptAnalyzer) (which provides linting & formatting in the editor extensions).\r\n            - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n        - [ ] Impact on [EditorSyntax](https://github.com/PowerShell/EditorSyntax) (which provides syntax highlighting with in VSCode, GitHub, and many other editors).\r\n            - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n",
  "closed_at": "2021-06-08T21:31:59Z",
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> tries to move the tests for OneDrive paths so that they don't cause side effects for existing tests.\r\n\r\nAre there really side effects from the tests?",
      "created_at": "2021-05-27T06:39:02Z",
      "updated_at": "2021-05-27T06:39:02Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I think it is impossible to have reparse points for UNC paths (I mean source path, UNC path is possible as target for symbolic links). If it is true we can do:\r\n```c#\r\n        private const string ExtendedDevicePathPrefix = @\"\\\\?\\\";\r\n        private const string UncPathPrefix = @\"\\\\\";\r\n        private const string UncDevicePrefixToInsert = @\"?\\UNC\\\";\r\n        private const string UncExtendedPathPrefix = @\"\\\\?\\UNC\\\";\r\n        private const string DevicePathPrefix = @\"\\\\.\\\";\r\n\r\n        // \\\\?\\, \\\\.\\, \\??\\\r\n        private const int DevicePrefixLength = 4;\r\n\r\n        private static string EnsureExtendedPrefix(string path)\r\n        {\r\n            if (IsPartiallyQualified(path) || IsDevice(path))\r\n                return path;\r\n\r\n            // Given \\\\server\\share in longpath becomes \\\\?\\UNC\\server\\share\r\n            if (path.StartsWith(UncPathPrefix, StringComparison.OrdinalIgnoreCase))\r\n                return path.Insert(2, UncDevicePrefixToInsert);\r\n\r\n            return ExtendedDevicePathPrefix + path;\r\n        }\r\n\r\n        private static bool IsDevice(string path)\r\n        {\r\n            return IsExtended(path)\r\n                ||\r\n                (\r\n                    path.Length >= DevicePrefixLength\r\n                    && IsDirectorySeparator(path[0])\r\n                    && IsDirectorySeparator(path[1])\r\n                    && (path[2] == '.' || path[2] == '?')\r\n                    && IsDirectorySeparator(path[3])\r\n                );\r\n        }\r\n\r\n        private static bool IsExtended(string path)\r\n        {\r\n            return path.Length >= DevicePrefixLength\r\n                && path[0] == '\\\\'\r\n                && (path[1] == '\\\\' || path[1] == '?')\r\n                && path[2] == '?'\r\n                && path[3] == '\\\\';\r\n        }\r\n\r\n\r\n        internal static bool IsReparsePointLikeSymlink(FileSystemInfo fileInfo)\r\n        {\r\n#if UNIX\r\n            // Reparse point on Unix is a symlink.\r\n            return IsReparsePoint(fileInfo);\r\n#else\r\n            if (InternalTestHooks.OneDriveTestOn && fileInfo.Name == InternalTestHooks.OneDriveTestSymlinkName)\r\n            {\r\n                return !InternalTestHooks.OneDriveTestRecurseOn;\r\n            }\r\n\r\n            WIN32_FIND_DATA data = default;\r\n            string fullPath = Path.TrimEndingDirectorySeparator(fileInfo.FullName);\r\n\r\n            if (fullPath.Length > MAX_PATH)\r\n            {\r\n                fullPath = EnsureExtendedPrefix(fullPath);\r\n            }\r\n\r\n            using (var handle = FindFirstFileEx(fullPath, FINDEX_INFO_LEVELS.FindExInfoBasic, ref data, FINDEX_SEARCH_OPS.FindExSearchNameMatch, IntPtr.Zero, 0))\r\n            ...\r\n```\r\n\r\nIf there is a reparse point at the end of this long path - the scenario was never covered by tests. ",
      "created_at": "2021-05-27T07:34:46Z",
      "updated_at": "2021-05-30T14:01:36Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "> I think it is impossible to have reparse points for UNC paths\r\n\r\nIt's still possible to have a reparse point over a UNC path. How the client interprets a symlink does differ but that doesn't really matter in this case. The code is just checking to see whether it needs to go into the target and delete the contents or just the reparse point.\r\n\r\nBut by adding the `!IsReparsePoint(fileInfo)` check here you do avoid having to then make yet another Win32 call if it isn't a reparse point which is nice. The only time `FindFirstFileEx` is needed is if the dir has a reparse point and the code needs to clarify whether the reparse point is one drive or app exec link reparse point. It's a pity `System.IO.DirectoryInfo` doesn't expose the `dwReserved0` field publicly meaning all this code wouldn't be needed.",
      "created_at": "2021-05-30T02:08:40Z",
      "updated_at": "2021-05-30T02:08:40Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> It's still possible to have a reparse point over a UNC path.\r\n\r\nReparse point is a feature _local_ NTFS - we can have UNC as target but not as _source_. In the context we check the source.",
      "created_at": "2021-05-30T07:27:07Z",
      "updated_at": "2021-05-30T07:27:07Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "It might be a feature of local NTFS but the same attributes are exposed over SMB. So you can enumerate a network path over SMB that contains a OneDrive link which appear as a reparse point but still needs those further checks that the function does. My comment merely tries to confirm that the reparse check can still occur beforehand to reduce the extra Win32 call if the item isn\u2019t a reparse point.",
      "created_at": "2021-05-30T08:44:28Z",
      "updated_at": "2021-05-30T08:44:28Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "For history. I found PR where the test was added. https://github.com/PowerShell/PowerShell/commit/ce4c35b9ed42a582e0a00bdd90b410f6c23b788c#diff-08b9d853f19b7b63dfb6b0fa7b634db55f2a20aeed01ffb5855b3e5b0da3431b There we also added EnsureLongPathPrefixIfNeeded() with simple normalization. It is 6.0 Beta.3 time.\r\nLater in https://github.com/PowerShell/PowerShell/commit/81244fb9077847dda892c5eff621933354ff4212#diff-08b9d853f19b7b63dfb6b0fa7b634db55f2a20aeed01ffb5855b3e5b0da3431b we migrated to .Net API. It is v6.1.0-preview.4. So the simple normalization worked only in 6.0.\r\n\r\n----\r\n\r\nI played with mount points over network and this works as @jborean93 pointed (thanks!).\r\n\r\nSo I think we should use already tested .Net code\r\nhttps://github.com/dotnet/runtime/blob/95a4476b91827e6f707744fab6e9d87df870407a/src/libraries/Common/src/System/IO/PathInternal.Windows.cs#L77-L112.\r\n\r\nI updated my proposal above.\r\n\r\n----\r\n\r\nNow we have an issue in .Net Runtime repository where we are discussing new API for symbolic links and probably reparse points too. Perhaps we get this in .Net 6.0. I hope the new API allows us to remove all p/invokes in PowerShell (in the area).\r\n\n\n<blockquote><img src=\"https://opengraph.githubassets.com/f1f3306a3d0bc92eac578a58e8b405303f49878dfdcb7efb1b9c674ad61bee02/dotnet/runtime\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/dotnet/runtime\">dotnet/runtime</a></strong></div><div>.NET is a cross-platform runtime for cloud, mobile, desktop, and IoT apps. - dotnet/runtime</div></blockquote>",
      "created_at": "2021-05-30T14:10:31Z",
      "updated_at": "2021-05-30T14:10:34Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "Closing in favour of https://github.com/PowerShell/PowerShell/pull/15546.",
      "created_at": "2021-06-08T21:31:59Z",
      "updated_at": "2021-06-08T21:31:59Z"
    }
  ],
  "created_at": "2021-05-26T22:56:21Z",
  "number": 15467,
  "state": "closed",
  "title": "Fix longpath directory removal",
  "updated_at": "2022-06-07T19:49:32Z"
}