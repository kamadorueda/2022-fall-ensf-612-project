{
  "_url": "https://github.com/PowerShell/PowerShell/issues/16511",
  "author": "AE1020",
  "body": "### Summary of the new feature / enhancement\r\n\r\nI work with source code and files for cross-platform projects that are standardized to all UNIX line endings (LF) instead of \"historical Windows\" (CR LF) <sub>(Notepad.Exe supports LF only [since 2018](https://devblogs.microsoft.com/commandline/extended-eol-in-notepad/))</sub>\r\n\r\nMy files are kept on shared filesystems that are accessed simultaneously by Windows, Linux, and MacOS systems.\r\n\r\nWhere possible I use bash for Windows when scripting, falling back on CMD.EXE occasionally.  Yet increasingly PowerShell is needed, e.g. [deprecations of things like ODBCCONF.EXE](https://docs.microsoft.com/en-us/sql/odbc/odbcconf-exe) means I have to access \"cmdlets\" like `Add-OdbcDsn`.\r\n\r\nBut there appears to be no way to ask Powershell not to use CR LF line endings on Windows when doing redirects.  In piping it will translate incoming LF to CR LF, which also leads to binary file corruption (see #1908)\r\n\r\nPersonally I *never* want this on any platform.  I consider LF endings canon, and certainly prefer no-op pipes produce the same bytes they get in.\r\n\r\nHowever, I'd assume that a global setting asking for LF on Windows *always* would break expectations of some packaged functionality.  That functionality is why I'm using PowerShell in the first place, so no good.\r\n\r\n### Proposed technical implementation details\r\n\r\n**I propose an OPTIONAL mode of operation in which the LF / CR LF usage of *the source code of the running powershell script itself* dictate its behavior.**  If the script source is LF-only, then it thinks it lives in an LF-only world and likely wants to live by LF-only expectations for piping.  If the script is CR LF, then its redirection and piping favor that.\r\n\r\nThis would allow PowerShell's behavior to piggy-back on the existing [git setting for autocrlf translation](https://docs.github.com/en/get-started/getting-started-with-git/configuring-git-to-handle-line-endings) that cross-platform developers already use.  Windows users who turn it on *probably* want CR LF in redirects when they run a script.  Windows users who turn it off *probably* want just LF on their filesystem always.\r\n\r\nI don't know how something like `Add-OdbcDsn` works, but if it did piping on some .INI file that is CR LF based on Windows, my hope would be it would still work under this strategy...as a library script presumably is a CR LF file itself.  So I could use a packaged piece of functionality like that in a script which itself was written to use LF only.\r\n\r\nMaybe if it this option worked out well it could someday become a default.  It would mean less conditional code between the Unix and Windows versions.  As a first step I'd like it fine as something I could turn on globally and leave on.",
  "closed_at": "2021-12-07T16:40:16Z",
  "comments": [
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "Basing it on what the current script users isn't the greatest of ideas. What happens when one script calls another and one is unix-style LF and the other windows style CR-LF . \r\n Where are you going to set the option? Presumably in the script anyway, so an option which says \"look at my code and see if there are CR characters in it\" might as well just do the thing. \r\nA preference variable would make sense, similar to $OutputEncoding\r\n\r\n-  I think a lot of stuff looks at  `[system.enviroment]::newline` which is read only. The problem as described would equally well apply to someone running a script on Linux and wanting Windows-style output. \r\n- The > operator is really a wrapper for `out-file` (try `1,2,3 | out-file O:\\foo.txt` and the error comes from out-file) and a preference which sets it for `out-file` _should_ apply to the > operator (and probably more). . \r\n- `Out-File` and `Out-String` both support  a `-NoNewLineParameter` but not a \"Use the new line of the other OS\" parameter. \r\n- The workround of using `Out-String` and then doing a regex replace of \"\\r\\n\" with \"\\n\" is ugly (`Out-string` also put extra blank lines around the text) \r\n\r\n",
      "created_at": "2021-11-24T16:03:27Z",
      "updated_at": "2021-11-24T16:03:27Z"
    },
    {
      "author": "btjwork",
      "author_association": "NONE",
      "body": "I would like a global \"don't corrupt my text data without my express permission\" preference for PowerShell. It still confuses me that the current behavior isn't considered a bug.\r\n\r\nAll output should be treated as binary unless I _explicitly_ pipe it into a PowerShell command that expects its input to be objects rather than data. I.e., the behavior should be based on what is consuming the data, not based on having been invoked by PowerShell.\r\n\r\nIf the data is being consumed by the filesystem (i.e., `mycommand.exe >foo.txt`), then at an OS level the stdout of `mycommand.exe` should be directly connected to a filesystem file descriptor. It should be solely up to `mycommand.exe` to control encoding and line endings.",
      "created_at": "2021-11-24T18:58:17Z",
      "updated_at": "2021-11-24T18:58:17Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "There has been some discussion on this issue particularly when piping from one native app to another - PS should step out of the way.  However, the scenario that @btjwork brings up is a bit different.  The `> foo.txt` is just a syntax sugar for ` ... | Out-File foo.txt`.  So that isn't a `native` to `native` scenario.  For `Out-File` you have to either pick an encoding or Out-File will use its default (utf8NoBom) on PS >= 6.",
      "created_at": "2021-11-24T19:21:21Z",
      "updated_at": "2021-11-24T19:21:21Z"
    },
    {
      "author": "btjwork",
      "author_association": "NONE",
      "body": "Yes, I was aware. I was hinting that I wish I could override `>` being a synonym for piping to `Out-File`. But, I realize that's complicated because of PS's historical choices. But, that is more of a discussion for the original issue:\r\n\r\n#1908 \r\n\r\n(Note that the title of the original issue includes \"or file\".)",
      "created_at": "2021-11-24T19:50:40Z",
      "updated_at": "2021-11-24T19:50:40Z"
    },
    {
      "author": "AE1020",
      "author_association": "NONE",
      "body": "> Basing it on what the current script users isn't the greatest of ideas. What happens when one script calls another and one is unix-style LF and the other windows style CR-LF .\r\n\r\nBut this is exactly my point.\r\n\r\n**I only use PowerShell because I have to in order to use prepackaged functionality that requires it.**\r\n\r\nIf library scripts I am calling expect the piping behavior to be generating CR LF (let's say because an internal tool or function would croak if passed data with only LF) then I don't want those to break.\r\n\r\nBut I want *my* scripts to not be generating CR LF files, because I don't want them anywhere on the shared drives.\r\n\r\nThe proposal has the possibility of converging to a place where if there are no CR LF scripts on a system, there will be no CR LF piping.\r\n\r\nI'm not saying it's a strategy that would please everyone.  But in my world it allows for a way that people collaborating a project can make the decisions for themselves based on how a file is represented on their drive while using the same script code.  *If you choose to use this option* then you can collaborate with people who insist on CR LF while being able to maintain LF-only in your own world.",
      "created_at": "2021-11-24T23:01:02Z",
      "updated_at": "2021-11-24T23:01:27Z"
    },
    {
      "author": "AE1020",
      "author_association": "NONE",
      "body": "> I would like a global \"don't corrupt my text data without my express permission\" preference for PowerShell. It still confuses me that the current behavior isn't considered a bug.\r\n\r\nYes, though as mentioned some prepackaged functionality may depend on the corruption to operate.  :-/\r\n\r\nIt's in some sense a separate point from whether CR LF are generated from thin air.  *but* PowerShell itself isn't a neutral party if it generates any text with newlines at all which can be redirected.  (e.g. some kind of multi-line echo of material from within a script).  If it injects CR LF in that without any way to stop it...even if the source script was LF only...then that is undesirable.\r\n\r\nSo I'm proposing *\"Letting People Vote With Their Feet\"* ...e.g. how they represent line endings in their script on disk.  This even permits individuals working with the same code to make different choices, and I think the Git autocrlf setting dovetails nicely with this.\r\n\r\n(My true wish is that along with standardizing on UTF-8 with [no byte order mark (as it should be!)](https://stackoverflow.com/a/2223976), the cross-platform focus had taken that extra step to standardizing on LF only so the files could be exchanged between platforms without transformation.  That would have been ideal, and solving the binary corruption would be a nice bonus of that.  But I would guess that is a bridge too far, so this is a proposal that could let people inch stepwise toward that world.)",
      "created_at": "2021-11-24T23:13:38Z",
      "updated_at": "2021-11-24T23:52:22Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "**If** `Out-File` had a `-LineTerminator` parameter on it, then you could configure your scripts to use this:\r\n```powershell\r\n$PSDefaultParameterValues['Out-File:LineTerminator'] = 'Lf' # THIS PARAMETER DOES NOT EXIST ATM\r\n```\r\nThis would work with both `Out-File` and `>`.\r\n\r\nCurrently, Out-File is calling through to .NET's `TextWriter.WriteLine()` which uses .NET's value for `Environment.NewLine` for the platform.  With this new parameter, Out-File could be updated to use the `TextWriter.Write()` method and tack on the user-supplied line terminator sequence. \r\n\r\nCaveat - any other cmdlets that write to files e.g. `New-ModuleManifest`, etc are likely to use `Environment.NewLine` so ymmv.  ",
      "created_at": "2021-11-24T23:29:28Z",
      "updated_at": "2021-11-24T23:40:59Z"
    },
    {
      "author": "btjwork",
      "author_association": "NONE",
      "body": "I like the direction @rkeithhill is going for this particular scenario - I think this should be an explicit setting that the user and/or script writer can control. And @AE1020, this would be consistent with the git behavior you use as an example: it doesn't \"guess\" what line ending to use based on other files on the same filesystem, it instead makes an explicit consistent decision based on user preference settings.\r\n\r\nThis would also allow the top-level script to include the logic to \"look around\" and automatically initialize the setting based on whatever rules the developer chooses. For example, could literally look at the git settings, rather than trying to infer them.",
      "created_at": "2021-11-25T00:45:32Z",
      "updated_at": "2021-11-25T00:45:32Z"
    },
    {
      "author": "btjwork",
      "author_association": "NONE",
      "body": "BTW, sorry to all if my first responses were confusing - I got here from @AE1020's comment on #1908, where it seemed that this was being suggested as an alternative solution to that scenario. I personally think this is an unrelated (though valid) scenario. I've been waiting years for #1908 to be resolved and didn't want to see it get side-tracked by this proposal.",
      "created_at": "2021-11-25T00:46:26Z",
      "updated_at": "2021-11-25T00:46:26Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> > Basing it on what the current script users isn't the greatest of ideas. What happens when one script calls another and one is unix-style LF and the other windows style CR-LF .\r\n> \r\n> But this is exactly my point.\r\n\r\nIf you have a preference variable which is `$LineTerminatorMatchScript = True` and script A has cr/lf  and script B has lf termination if A calls B which script sets the preference ?\r\n\r\nAnd since you will need to set that preference in a script why ask PowerShell to examine the code and try to work out if what it is and why not just have    $LineTerminatorPreference = Unix / $LineTerminatorPreference = Windows.  \r\n\r\n> **I only use PowerShell because I have to in order to use prepackaged functionality that requires it.**\r\n> \r\n> If library scripts I am calling expect the piping behavior to be generating CR LF (let's say because an internal tool or function would croak if passed data with only LF) then I don't want those to break.\r\n\r\nThat isn't the behaviour. Windows files (like DOS files before them and CP/M files before that) use CR LF as a line separator.  PowerShell does have < to lash a file to std-in and \">\" is (as already said) syntactic sugar for `| out-File`  so the pipeline isn't merging  < and > to make writing (txt) to stdout become (pseudo keyboard)  input, it's designed for passing objects, and we get some behaviour differences.  One is is for input, it's not a long stream of text with LF or CR LF pairs in it. PowerShell treats it as multiple text strings. Try IPConfig | measure (or IFConfig | measure on linux) and you'll see it is multiple items. The same when you read a file. \r\n\r\nWhen you have a bunch of text strings and you want to send them to a non-Powershell program, or to a file, PowerShell inserts the local OS's new line (LF or CR LF). \r\n\r\n> \r\n> But I want _my_ scripts to not be generating CR LF files, because I don't want them anywhere on the shared drives.\r\n\r\nSo you have a quest to prevent Windows programs writing output in the way Windows programs naturally write.  If you work with a sufficiently small set you might be able to achieve that. PowerShell on Linux (or in WSL) would do what you want, but PowerShell on Windows thinks it is being helpful, and isn't doing what you want. \r\n\r\n> The proposal has the possibility of converging to a place where if there are no CR LF scripts on a system, there will be no CR LF piping.\r\nYeah.  Most modules you install will use CRLF so good luck with that. \r\n\r\n\r\n> I'm not saying it's a strategy that would please everyone. But in my world it allows for a way that people collaborating a project can make the decisions for themselves based on how a file is represented on their drive while using the same script code. _If you choose to use this option_ then you can collaborate with people who insist on CR LF while being able to maintain LF-only in your own world.\r\n\r\nLike I said it works both ways. If you come against someone who demands all LF and you're running on a Windows machine you should be able to please them, and if you're on a linux machine and the demand is for all CRLF that should be possible as well.  Right now if the default for the OS you're on isn't the desired one you're stuck. There are plenty of harder things to change.\r\n",
      "created_at": "2021-11-25T19:35:20Z",
      "updated_at": "2021-11-25T19:35:20Z"
    },
    {
      "author": "AE1020",
      "author_association": "NONE",
      "body": "> `$LineTerminatorMatchScript = True`\r\n\r\nI'm proposing a global setting for powershell.  (It doesn't make sense to put this in the scripts themselves.)\r\n\r\n> If you come against someone who demands all LF and you're running on a Windows machine you should be able to please them, and if you're on a linux machine and the demand is for all CRLF that should be possible as well.\r\n\r\nAs the problem statement says that's what I'd like to see.\r\n\r\nAnd I proposed an implementation path for this that doesn't require putting anything in the scripts themselves.  (Based on git crlf settings, the crlf setting isn't something considered \"in the script\" but an out-of-band characteristic that version control can manage invisibly.)\r\n\r\nIf there's another way to do it, great.  But I think my suggestion would work.",
      "created_at": "2021-11-25T22:20:11Z",
      "updated_at": "2021-11-25T22:22:11Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> > `$LineTerminatorMatchScript = True`\r\n> \r\n> I'm proposing a global setting for powershell. (It doesn't make sense to put this in the scripts themselves.)\r\n \r\nI was thinking it works two ways. I can put a setting in my profile to ensure I always use one form, or I can set it at the command line if I am outputting for a server which requires one way. But if I'm writing scripts I'm going to live by the mantra \"assumption is the mother of error\" and ensure option is set at the start of the script.  And when the option is on it wants to be on for everything, compiled cmdlets run from the prompt, 3rd party modules which use the other line ending etc. etc. \r\n\r\n\r\n\r\n\r\n",
      "created_at": "2021-11-25T23:32:17Z",
      "updated_at": "2021-11-25T23:32:17Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Line endings behavior comes from **OS fundamentals** - that is **how OS abstracts devices**.\r\n\r\nLine endings is one from many such abstractions. If somebody thinks about wrapping over fundamental OS abstractions the one should understand it is very, very expensive.\r\n\r\nFrom PowerShell design point of view, this would mean adding a _thick_ layer of abstraction of OS fundamentals.\r\nAnd users would see only new parameters (for that issue context example) in the New-Drive cmdlet (like `-ConvertCRLFtoLF`).\r\n\r\nWhile this looks tempting, I think it is unreasonably expensive to do this kind of thing in PowerShell.\r\nThe correct approach is to request improvements to the abstractions in the operating systems themselves to make the interaction between platforms better.\r\n\r\nFor that issue, this would mean that you should request improvements in NFS client from Windows team to support line endings translation.\r\nOtherwise, you can do the simplest thing - add additional steps to correct the behavior to an application (for example like git does) or your script. This is the best practice today.\r\n\r\n",
      "created_at": "2021-11-26T05:54:13Z",
      "updated_at": "2021-11-26T05:54:13Z"
    },
    {
      "author": "AE1020",
      "author_association": "NONE",
      "body": "> Line endings is one from many such abstractions. If somebody thinks about wrapping over fundamental OS abstractions the one should understand it is very, very expensive.\r\n\r\nI wouldn't ask PowerShell to be changing anything that would be costly.  I'm just asking it not to introduce any *new* CR LF sequences into the mix.\r\n\r\nCMD.EXE seems able to do this...if Program A emits LF and then you pipe it into Program B it will receive LF, not CR LF.\r\n\r\nSo nothing expensive is being asked for...if anything, I'm asking it to be *cheaper*.",
      "created_at": "2021-11-26T07:14:06Z",
      "updated_at": "2021-11-26T07:14:06Z"
    },
    {
      "author": "AE1020",
      "author_association": "NONE",
      "body": "While there have been negative responses to this, no one has proposed a solution to my issue:\r\n\r\n**How am I to ask PowerShell to not produce CR LF in *my scripts* on file shares that run on many different directories...while not disrupting existing packaged functionality (other peoples scripts) as part of the PowerShell distribution or otherwise (e.g. not on the shares, but relating to the Windows OS install)?**\r\n\r\nI do not see why there is such a negative reaction to the idea that I would encode my desire by virtue of the CR LF disposition of the script that is running.  *It is only an option, after all.*  But I would accept another approach so long as it solved the problem.\r\n\r\nFWIW, approaches that require any editing of script code to say what option you want to use explicitly do not really give the feature I seek.  (e.g. to share the identical script code among a Windows user who wants all their piped products to involve CR LF, and a user who is in a hybrid environment and wants to use that script on a share where things are always LF even on Windows).  The code being the same but only checked out via git using different translation settings is the point.\r\n\r\nAs I understand it, PowerShell made a shift away from UTF-16 encoding of its redirection (with Byte-Order Mark) to the much preferable UTF-8 with no Byte Order Mark.  This was done to be more cross-platform friendly.  But without going that extra mile of embracing LF-only, it really doesn't provide the desired ability of being able to use the same bytes on all platforms.",
      "created_at": "2021-12-05T15:55:23Z",
      "updated_at": "2021-12-05T16:11:46Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "Last point first. Windows tried to move to Unicode for everything and Windows PowerShell still defaults to a 2-byte character set with byte order marking by default. PowerShell 6 and 7 default to UTF 8.  \r\nMurphy's law says on Windows a script you count on producing one kind of output will run on the version of PowerShell which produces the other kind.  So either the script decides \"I will always output Unicode / UTF7 / UTF 8\"  or a PowerShell profile (single-user or all-user) says \"Any output  which doesn't specify an option should be encoded this way\". If what you are asking for is ever implemented, line break encoding would likely me managed the same way as output encoding. \r\n\r\n_Native_ Windows programs use CRLF line breaks. To be cross-platform .NET (not PowerShell itself, it is just is something built on .NET) - says \"On this OS, use this for line break\" - so CRLF on Windows, LF on Linux - and well behaved programs check this instead of inserting the combination for their author's OS.  In PowerShell's case objects (not text) come down the pipeline, and when they need to be converted to text `[system.Environment]::newLine` is inserted between each.   TBH I don't think the case where someone wants to NOT use the OS default was really on the radar for .NET.   The solution to this problem lies there because it should be possible to change what `[system.Environment]::newLine` , just as it is possible to tell .NET which file encoding is desired (and PowerShell does). \r\n\r\nYou are looking at this through the lens of the problem you have - \"I run  script.ps1 > file.txt , and I want a way to say to '>' should use a line separator which isn't the OS default. I don't want to run PowerShell on an OS (or OS subsystem) where that is the default. And I don't want to change the script but I think how the script is encoded might be a good idea for toggling it\". \r\n\r\nWhich (a) is a corner case so unlikely to get a change made and (b) isn't an optimal solution  > is syntactic sugar for | Out-File  so the solution would be Out-File has to check an option, looks down the pipeline ignoring where, sort or similar cmdlets and see if there is a script, then forms a view on the line breaks it uses, then change to a different line break  output that between objects and if the output of the object-to-text conversion has wrapped over lines replace any line breaks there as well . \r\nBut `script | out-file` would do one thing and `$x = $script; $x | out-file` does something else.  Very specific solutions to solve one problem tend to be introduce other issues when let out into the wider word.  \r\n\r\nYou can replace `Out-File` with a function which does `Out-String`, use a regex to replace `\\r\\n` with `\\n` and write _that_ to a file, and the function will intercept `>`  or anything else which calls `out-file`  Once loaded file output for the rest of the session will be modified.   If there is interest I can post a working sample as a gist.  \r\n\r\n Or you can even just follow  `script > file`  with \r\n```\r\nSet-Content file ( (get-content file -Raw) -replace '\\r\\n' ,\"`n\") -NoNewline\r\n```\r\n\r\n",
      "created_at": "2021-12-07T11:04:34Z",
      "updated_at": "2021-12-07T11:04:34Z"
    },
    {
      "author": "AE1020",
      "author_association": "NONE",
      "body": "> But `script | out-file` would do one thing and `$x = $script; $x | out-file` does something else.\r\n\r\nYou might think I am asking something more complicated than I am asking.\r\n\r\nMy concept was that the `|` knew what script it was in, and that was the sole deciding factor.  These two would thus behave identically if the code was in the same script.\r\n\r\nNothing would ever be sensing the wishes of some other script being piped into.\r\n\r\n> If what you are asking for is ever implemented, line break encoding would likely me managed the same way as output encoding.\r\n\r\nIndeed, to me a CRLF file and an LF file are fully distinct file formats.\r\n\r\nBecause of this I choose to treat CRLF files to be as foreign as if they were encoded in any random codepage, as CR LF is an empirically worse format.\r\n\r\nIt goes beyond just annoying Linux/Mac users.  The number of programming edge cases introduced by having a combo-character as an end of line marker are many.  You have to worry about what to do if you hit just a CR, or just an LF, among other things.  Every piece of code that deals with line breaks is simpler and less prone to failure with a single character end of line marker.\r\n\r\n> Native Windows programs use CRLF line breaks.\r\n\r\nThe Windows kernel does not hardcode CR LF.  CMD.EXE does not throw in CRLF in piping, and NOTEPAD.EXE can handle LF-only files.\r\n\r\nSo if you have ten .EXE programs that between them use no LF line endings, it seems sensible that a shell which ties them together could operate agnostically.  \ud83e\udd37 ",
      "created_at": "2021-12-07T13:17:29Z",
      "updated_at": "2021-12-07T13:17:29Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> > But `script | out-file` would do one thing and `$x = $script; $x | out-file` does something else.\r\n> \r\n> You might think I am asking something more complicated than I am asking.\r\n> \r\n> My concept was that the `|` knew what script it was in, and that was the sole deciding factor. These two would thus behave identically if the code was in the same script.\r\n\r\n|  doesn't know where it is, and it is the PowerShell to the right of the |  (out-file) which adds line breaks. When sending to a non-PowerShell program which doesn't understand date/user/process objects  there's a shim on the right of |  - objects go through the engine used when calling \"Out-string\" or \"Out file\" to reduce them to text and the lumps of text get OS standard line breaks between them. \r\n \r\n> Nothing would ever be sensing the wishes of some other script being piped into.\r\n\r\n I think that you were saying  `>` or `| Out-File` should know what to do from the _encoding of the script that sent their input_\r\nSo ` .\\script.ps1 | out-file foo.txt`  works. \r\nbut what about ` .\\script.ps1 | where length -gt 100 | out-file foo.txt` , because it isn't the last command before the `| Out-file`  whose encoding counts. \r\nOr   `script.ps1 | script2.ps1 | out-file`  - which wins if the two scripts have different encodings ? \r\nOr `$x = script.ps1  ;....; Set-Content foo.txt $x ` How is `Set-Content` meant to know what was intended. \r\n\r\n\r\n> Because of this I choose to treat CRLF files to be as foreign as if they were encoded in any random codepage, as CR LF is an empirically worse format.\r\n\r\nHaving dealt with this for over 40 years now I can tell you neither is \"empirically\" better or worse than the other. Some makers of printed paper terminals had separate operations for rolling the paper up a line and moving the print head all the way left and some merged them.  Like little-endian/bigendian byte ordering, or US / everywhere else date formats or , and . swapping their roles in numbers, we cope.  \r\n\r\n> It goes beyond just annoying Linux/Mac users. The number of programming edge cases introduced by having a combo-character as an end of line marker are many. You have to worry about what to do if you hit just a CR, or just an LF, among other things. Every piece of code that deals with line breaks is simpler and less prone to failure with a single character end of line marker.\r\n\r\n40 years dealing with two systems... So I know.  You need to go back and tell Gary Kildahl  the OS's which influenced him in designing CP/M, got it wrong. Tell the IBM execs who wanted a CP/M clone for the PC (or Gates and Co who were figuring out how to deliver it) that they needed to change it (though I *think* everything IBM used separate characters) . Tell them again when OS/2 was in the works, or get the Idea of Dave Cutler when Windows NT was growing of its ashes. Without the aid of a time machine - that boat has sailed. Every programmer is familiar with \"What idiot chose to use the *other* way\" and almost every programmer learns to handle it (and that handling is effort which could have been saved if the first Unix systems had been developed with a different kind of terminal, but like I said the boat has sailed). \r\n\r\n\r\n> \r\n> > Native Windows programs use CRLF line breaks.\r\n> \r\n> The Windows kernel does not hardcode CR LF. CMD.EXE does not throw in CRLF in piping, and NOTEPAD.EXE can handle LF-only files.\r\nNo, the kernel doesn't get involved. Non .NET programs written to win-32 APIS hard code CR-LF. \r\nIf you run ipconfig.exe > temp.txt , temp.txt will have chr(13) chr(10) throughout. Ipconfig.exe decided how to space things, how to format them and to put CRLF between the lines. If you do Get-NetAdapter  in PowerShell the _cmdlet_ doesn't know how things will be printed: it sends something with Name, MacAddress, Speed and other properties, and something says \"Oh a NetAdapter object, we format one of *those* like *this* if we want to print it \"\r\n\r\nNotepad will read LF-Only, (after years of lobbying) but creating one from scratch...  you can set the encoding on save, but maybe I've missed an option for selecting LF-Only. \r\n\r\n> So if you have ten .EXE programs that between them use no LF line endings, it seems sensible that a shell which ties them together could operate agnostically. \ud83e\udd37\r\n\r\nExcept that doesn't happen. A program which runs on Windows and takes input from std-in (keyboard < or | )  but can't take CR LF input is pretty useless, because for a start if you just run it in CMD, the return key will be presented with CR LF. If the output came from another Windows Program, it will be CR-LF  etc.\r\n\r\nPowerShell isn't exactly agnostic: it works the way the OS it finds itself on usually works.  If it finds itself running with programs which can't work with the OS defaults, things will go wrong.  The subtle difference between a file or program's output being one giant string with line break characters in it, and many strings with a line break marking the boundary between adjacent ones is more likely to  cause a problem than saying \"When I need to output many strings I mark the boundary between adjacent ones with the OS's line break\"  \r\n\r\n \r\n\r\n",
      "created_at": "2021-12-07T16:36:11Z",
      "updated_at": "2021-12-07T16:36:11Z"
    }
  ],
  "created_at": "2021-11-24T01:56:22Z",
  "labels": [
    "Issue-Enhancement",
    "WG-Engine",
    "Needs-Triage"
  ],
  "number": 16511,
  "state": "closed",
  "title": "Option for LF vs. CR LF Piping To Match Line Endings Of Running Script",
  "updated_at": "2021-12-07T16:40:16Z"
}