{
  "_url": "https://github.com/PowerShell/PowerShell/issues/3866",
  "author": "KirkMunro",
  "body": "Steps to reproduce\r\n------------------\r\n```PowerShell\r\nSet-Content -Value $null -Path .\\zero.txt -NoNewline -Encoding Ascii\r\n(get-item .\\zero.txt).Length -eq 0 # returns $true\r\n$content = gc .\\zero.txt -Raw -Encoding Ascii\r\n$content -eq $null # returns $true\r\n$null -eq $content # returns $true\r\n$content -match 'anything' # returns nothing, but should return $false\r\n[System.Management.Automation.Internal.AutomationNull]::Value -match 'anything' # ditto\r\n$null -match 'anything' # returns $false\r\n```\r\n\r\nExpected behavior\r\n-----------------\r\n```PowerShell\r\n$true\r\n$true\r\n$true\r\n$false\r\n$false\r\n$false\r\n```\r\n\r\nActual behavior\r\n---------------\r\n```PowerShell\r\n$true\r\n$true\r\n$true\r\n# returns nothing at all\r\n# returns nothing at all\r\n$false\r\n```\r\n\r\nImpact\r\n------\r\nThis makes it more difficult to write scripts that process content in files, because tests that should fail return nothing instead, so if you were checking for a failure and then jumping to the next iteration of the loop with continue, your continue does not get called and then unpredictable things can happen as a result.\r\n\r\nEnvironment data\r\n----------------\r\nReproduced in PowerShell 5.1 and 6.0.",
  "closed_at": null,
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@KirkMunro Thanks for your report! Do you plan to make the fix?",
      "created_at": "2017-05-26T04:52:49Z",
      "updated_at": "2017-05-26T04:52:49Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "Interesting issue.\r\n\r\n`AutomationNull.Value` is intended to convey \"no results\" which is different than `$null`. So I think this is by design.\r\n\r\nAnd indeed, [here](https://github.com/PowerShell/PowerShell/blob/e75cff662ab7295abb3b1e89ef45f045ecabcaa1/src/System.Management.Automation/engine/runtime/Binding/Binders.cs#L530) is the code that explicitly treats `AutomationNull.Value` as an empty collection when we are checking if an object is a collection.\r\n\r\nMaybe `AutomationNull.Value` could have been an empty collection in the first place (and hence not equal to `$null`), but that decision was made before I started.",
      "created_at": "2017-05-26T05:41:40Z",
      "updated_at": "2017-05-26T05:41:40Z"
    },
    {
      "author": "fMichaleczek",
      "author_association": "NONE",
      "body": "I hope someone will resolve this annoying bug.\r\n",
      "created_at": "2017-05-26T11:25:18Z",
      "updated_at": "2017-05-26T11:25:18Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "If the ```AutomationNull.Value``` behaviour is by design, maybe this is an issue with Get-Content in the FileSystem provider.\r\n\r\nMy expectation is that when I invoke Get-Content _filename_ on a text file, especially when I use the -Raw switch but I have this expectation even when I don't use -Raw, that I will get back either a string or an array of strings, depending on the content and whether or not I used -Raw. Certainly in a zero-byte text file, this should give me back an empty string. This expectation is not surprising given that the command metadata reports the OutputType as ```System.Byte``` or ```System.String```. Further evidence that supports my expectation is the following:\r\n\r\n```PowerShell\r\n# Create a zero-byte, empty ASCII file\r\nSet-Content -LiteralPath .\\empty.txt -Value '' -NoNewLine -Encoding Ascii\r\n# I created the content using an empty string, so when I Get-Content -Raw,\r\n# shouldn't I get back an empty string?\r\n$content = Get-Content -LiteralPath .\\empty.txt -Raw\r\n$content -is [string] # returns $false\r\n```\r\n\r\nThat script shows that you cannot round-trip empty content into a text file and back out again, because the command is returning ```AutomationNull.Value``` instead.\r\n\r\nFor this specific issue, given the questions about whether or not ```AutomationNull.Value``` should be treated as a collection, I think fixing Get-Content would be helpful; however, would that be a breaking change?\r\n\r\nMaybe this is going to force me into using strong typing for my variables, because forcing the results of Get-Content into a string makes this problem go away. I feel that force shouldn't be necessary though, especially because I asked for the -Raw string output from the file.",
      "created_at": "2017-05-26T13:40:42Z",
      "updated_at": "2017-05-26T13:41:14Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "From [docs ](https://msdn.microsoft.com/en-us/powershell/reference/5.0/microsoft.powershell.management/get-content):\r\n\r\n> This cmdlet returns strings or bytes. The output type depends upon the content that it gets.\r\n\r\nSo I expect:\r\n - Get-Content - return empty string\r\n - Get-Content -Raw - return empty string\r\n - Get-Content -Encoding Byte - return $null",
      "created_at": "2017-05-26T14:07:39Z",
      "updated_at": "2017-05-27T16:16:42Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "Why would you expect ```Get-Content -Raw``` to return $null? It always returns a string. Even for binary files. Unless the file is empty (in which case it makes sense for it to return an empty string, no?).\r\n\r\nFrom the FileSystem provider documentation:\r\n\r\n-Raw <SwitchParameter>\r\n    Ignores newline characters. Returns contents as a single item.",
      "created_at": "2017-05-26T14:47:33Z",
      "updated_at": "2017-05-26T14:47:33Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Yes, Get-Content always returns a string with `-Raw` and w/o. I agree that the cmdlet should returns an empty string for an empty file.",
      "created_at": "2017-05-26T14:54:52Z",
      "updated_at": "2017-05-26T14:54:52Z"
    },
    {
      "author": "oising",
      "author_association": "CONTRIBUTOR",
      "body": "\"Certainly in a zero-byte *text* file, this should give me back an empty *string.*\"\r\n\r\nHow does one know what the format of a zero byte file is? If PowerShell was required to maintain a mapping of all known file extensions/mime types based on extensions, and an associated \"empty\" result, that would be unmanageable. It would also be impossible on Linux, which has no hoots to give about file TLEs. :)\r\n\r\nUpdate: This isn't directed at you, Kirk. Just a general statement. I realize that the standard seems to be byte or string. I guess strings are seen as just more manageable than void or $null - even empty ones. ",
      "created_at": "2017-05-26T21:03:18Z",
      "updated_at": "2017-05-26T21:09:03Z"
    },
    {
      "author": "oising",
      "author_association": "CONTRIBUTOR",
      "body": "Also, isn't $null coerced to an empty string if required? I think the AutomationNull.Value idea was sound but it seems difficult to be consistent with. Argh... ",
      "created_at": "2017-05-26T21:05:18Z",
      "updated_at": "2017-05-26T21:05:18Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@oising But with Get-Content -Raw, in my testing it always returns string, regardless of the format of the file. PDF, BMP, ZIP, etc. So the file format has nothing to do with it. I may have seen this at one point, but right now I'm not sure when it returns bytes instead of strings, and since it returns strings for all files, that's why I think it makes sense to return an empty string for a zero-byte file.\r\n\r\nI think AutomationNull.Value when you invoke a command to get object data like services or processes and nothing comes back is sound. I'm not sold on AutomationNull.Value as a way to represent an empty file though, when all other file content comes back as string.\r\n\r\nI can work around this all sorts of ways (strong typing a variable as string and assigning the results of Get-Content to that variable, for example), but beyond the inconsistency, I think the potential to cause scripts to do unexpected (or maybe undesirable) things if a script encounters a zero-byte file warrants re-thinking the original design decision (while evaluating whether or not it's a breaking change that could break someone's code). The current behaviour is not intuitive enough to be considered in scripts, which is why I brought it here as a bug to discuss.",
      "created_at": "2017-05-26T23:46:49Z",
      "updated_at": "2017-05-26T23:48:07Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "`Get-Content` will return bytes if you specify `-Encoding Byte`.  If the file is empty, then you get a `$null`.  So the user can determine if the file is read as `text` (encoded as ascii, unicode. utf8) or `binary` by specifying the appropriate encoding.",
      "created_at": "2017-05-27T01:36:28Z",
      "updated_at": "2017-05-27T02:53:34Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks @rkeithhill. I knew I had seen it before, but it wasn't something I have used frequently.",
      "created_at": "2017-05-27T02:31:02Z",
      "updated_at": "2017-05-27T02:31:02Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "There are two distinct issues here:\r\n\r\n* (a) `Get-Content`'s behavior\r\n\r\n* (b) `[System.Management.Automation.Internal.AutomationNull]::Value` behavior as the LHS of array-aware operators.\r\n\r\n### (a) `Get-Content`'s behavior\r\n\r\nI agree that `Get-Content -Raw` when given an empty input file should return a _scalar_ rather than `[System.Management.Automation.Internal.AutomationNull]::Value`, the **latter signaling an empty _collection_.**\r\n\r\nBy contrast, it is appropriate - and consistent with current behavior - for `Get-Content` _without_ `-Raw` to return `[System.Management.Automation.Internal.AutomationNull]::Value`, because a _collection_ is expected - be that one of _lines_ or _bytes_ (with `-Encoding Byte`).\r\n\r\nArguably, with `-Raw` that scalar should be `''` (the empty string, which unambiguously implies an empty file), ~~but even a _bona fide_ `$null` is preferable to the current behavior.~~\r\n\r\n@PetSerAl has done [great sleuthing on SO](https://stackoverflow.com/a/30018601/45375) to come up with a way to inspect whether a given value is actually `$null` or `[System.Management.Automation.Internal.AutomationNull]::Value`:\r\n\r\n```powershell\r\nNew-Item -Type File zero.txt # create 0-byte file\r\n\r\n$refEquals=[Object].GetMethod('ReferenceEquals')\r\n\r\n# Should be and is $True\r\n$refEquals.Invoke($null, @((Get-Content zero.txt), [System.Management.Automation.Internal.AutomationNull]::Value))\r\n\r\n# Should be and is $True\r\n$refEquals.Invoke($null, @((Get-Content -Encoding Byte zero.txt), [System.Management.Automation.Internal.AutomationNull]::Value))\r\n\r\n# !! Should be $False, but is $True\r\n$refEquals.Invoke($null, @((Get-Content -Raw zero.txt), [System.Management.Automation.Internal.AutomationNull]::Value))\r\n```\r\n\r\n### (b) `[System.Management.Automation.Internal.AutomationNull]::Value` behavior as the LHS of array-aware operators.\r\n\r\nIn short: The treatment of `[System.Management.Automation.Internal.AutomationNull]::Value` is _inconsistent_:\r\n\r\n* `-match` interprets `[System.Management.Automation.Internal.AutomationNull]::Value` as an _array_ (collection)\r\n* while `-eq`, `-le`, `ge` and their variations treat it as (scalar) `$null` (haven't looked at others)\r\n\r\n`[System.Management.Automation.Internal.AutomationNull]::Value -match 'anything'` \r\n\r\nreturning \"nothing\" (an empty `[System.Object[]]` instance) is defensible: an empty _collection_ as the LHS to which a filtering operator is applied can only ever return that empty collection, albeit converted to an _empty array_ by PowerShell.\r\n\r\nBy contrast, here are some sample commands that demonstrate (scalar) `$null` treatment with `-eq`, `-le`, and `-ge`:\r\n\r\n```powershell\r\n> [System.Management.Automation.Internal.AutomationNull]::Value -eq  $null; $null -eq $null\r\nTrue\r\nTrue\r\n> [System.Management.Automation.Internal.AutomationNull]::Value -eq 0; $null -eq 0\r\nFalse\r\nFalse\r\n\r\n# Any negative value yields $False.\r\n> [System.Management.Automation.Internal.AutomationNull]::Value -le 0; $null -le 0\r\nTrue\r\nTrue\r\n\r\n# Any negative value yields $True\r\n> [System.Management.Automation.Internal.AutomationNull]::Value -ge 0; $null -ge 0\r\nFalse\r\nFalse\r\n```\r\n\r\nOn a side note, I find that comparing `$null` to anything other than `$null` returning `$true` baffling: for instance, why are `$null -lt 0` and `$null -gt -1` `$true`?\r\n",
      "created_at": "2017-05-30T03:04:55Z",
      "updated_at": "2017-05-30T20:55:27Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "You actually don't need to use reflection to identify automation null. For example:\r\n\r\n```PowerShell\r\n$x = $null\r\n$y = [System.Management.Automation.Internal.AutomationNull]::Value\r\nforeach ($item in 'x','y') {\r\n    $value = Get-Variable -Name $item -ValueOnly\r\n    if ($value -eq $null) {\r\n        if (@($value).Count -eq 0) {\r\n            \"`$${item} is [System.Management.Automation.Internal.AutomationNull]::Value\"\r\n        } else {\r\n            \"`$${item} is `$null\"\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nI just added a comment to @PetSerAl's post sharing the same information.\r\n\r\nFor Get-Content's behaviour, I still expect an empty string when invoking Get-Content with encoding set to anything other than Byte. If you invoke Get-Content against a file containing a single line of text, you get back a string, not an array. An empty string is a much better representation of an empty file than $null. Consider non-ASCII files (e.g. UTF-8). They have a byte order mark included in them, so would $null be a good representation of their content when retrieved using the proper encoding?\r\n\r\nAll of these details aside, before I spend more time on this and before I could consider looking at the code to apply a fix for this, my concern is that these changes, regardless of what form they would take, would be breaking changes and rejected accordingly, resulting in wasted time and effort. The more I think about it, the more I feel that is what would happen, because someone may very well have scripts written that look something like this:\r\n\r\n```PowerShell\r\nforeach ($filePath in Get-ChildItem -Recurse -Filter *.txt) {\r\n    $content = @(Get-Content $filePath)\r\n    # If the file is empty, skip it\r\n    if ($content.Count -eq 0) {\r\n        continue\r\n    }\r\n    # Other file processing goes here...\r\n}\r\n```\r\n\r\nOr, considering the use of -Raw, someone may have scripts that do this:\r\n\r\n```PowerShell\r\nforeach ($filePath in Get-ChildItem -Recurse -Filter *.txt) {\r\n    $content = Get-Content $filePath -Raw\r\n    # If the file is empty, skip it\r\n    if ($content -eq $null) {\r\n        continue\r\n    }\r\n    # Other file processing goes here...\r\n}\r\n```\r\n\r\nWith those possibilities in mind, the proposed changes to Get-Content should be rejected as breaking changes, regardless of whether or not we change the result when it is not invoked with -Raw, shouldn't they?\r\n\r\nThat brings me back to how AutomationNull.Value is treated like a collection when used with -match/-notmatch or -like/-notlike, but not -eq/-ne. If it looks like $null but doesn't act like $null, it must be AutomationNull.Value. Try explaining how AutomationNull.Value works, coupled with considerations you should take into account when you are scripting around AutomationNull.Value, to a classroom and see how well they understand it afterwards.",
      "created_at": "2017-05-30T20:38:52Z",
      "updated_at": "2017-05-30T20:40:26Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@KirkMunro: \r\n\r\nThanks for that handy alternative for detecting `[System.Management.Automation.Internal.AutomationNull]::Value`; to summarize:\r\n\r\n```powershell\r\n> $scalarNull = $null; $collectionNull = [System.Management.Automation.Internal.AutomationNull]::Value\r\n> @($scalarNull).Count\r\n1\r\n> @($collectionNull).Count\r\n0\r\n```\r\n",
      "created_at": "2017-05-30T21:08:32Z",
      "updated_at": "2017-05-30T22:24:10Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@KirkMunro:\r\n\r\n> For Get-Content's behaviour, I still expect an empty string when invoking Get-Content with encoding set to anything other than Byte\r\n\r\nI would expect that with `-Raw` _only_, but not otherwise. Without `-Raw`, `Get-Content` inherently retrieves a _collection_ of lines, and returning a value that signals \"no items in this collection\" seems appropriate.\r\n\r\n> Consider non-ASCII files (e.g. UTF-8). They have a byte order mark included in them, so would $null be a good representation of their content when retrieved using the proper encoding?\r\n\r\nWith `-Raw`, distinguishing between a true zero-byte file and one _solely_ comprising a BOM (Unicode signature) would be the only argument for using `$null` for a zero-byte file  and `''` for an Unicode-signature-only file.  \r\nBut my sense is that this distinction is not worth making.\r\n\r\n> would be breaking changes and rejected accordingly\r\n\r\nNote that a proposed change being breaking [_may_ be, but doesn't have to be a reason for rejection](https://github.com/PowerShell/PowerShell/blob/master/docs/dev-process/breaking-change-contract.md#bucket-3-unlikely-grey-area). \r\n\r\n> because someone may very well have scripts written that look something like this\r\n\r\n```powershell\r\n    $content = @(Get-Content $filePath)\r\n    # If the file is empty, skip it\r\n    if ($content.Count -eq 0) {\r\n```\r\n\r\nThat should continue to work fine, if a change is restricted to `-Raw`'s behavior.\r\n \r\n> Or, considering the use of -Raw, someone may have scripts that do this:\r\n\r\n```powershell\r\n    $content = Get-Content $filePath -Raw\r\n    if ($content -eq $null) {\r\n        continue\r\n    }\r\n```\r\n\r\nThat would indeed be a breaking change (unless we make `-Raw` return `$null` with zero-byte _and_ Unicode-signature-only files - which is still worth considering, given that `$null` behaves like `''` in most contexts).\r\n\r\n> That brings me back to how AutomationNull.Value is treated like a collection when used with -match/-notmatch or -like/-notlike, but not -eq/-ne. If it looks like $null but doesn't act like $null, it must be AutomationNull.Value. Try explaining how AutomationNull.Value works, coupled with considerations you should take into account when you are scripting around AutomationNull.Value, to a classroom and see how well they understand it afterwards.\r\n\r\nI agree that the current behavior is inconsistent and confusing.\r\n\r\nNo PowerShell user should ever have to learn about `[System.Management.Automation.Internal.AutomationNull]::Value` (unless they like that sorta thing), but if the fundamental scalar / collection distinction worked _consistently_, they wouldn't _need_ to.\r\n\r\n---\r\n\r\nTo summarize: **If backward compatibility _weren't_ an issue, the following _should_ be fixed**:\r\n\r\n* What `Get-Content -Raw` returns.\r\n\r\n* Ensuring consistent behavior of array-aware operators with `[System.Management.Automation.Internal.AutomationNull]::Value` as the LHS.\r\n\r\nAssuming we're in agreement there: **What do the powers that be think?**\r\n\r\n\r\n\r\n",
      "created_at": "2017-05-30T21:43:14Z",
      "updated_at": "2017-05-30T22:07:26Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "There's one point in your comment that I get stuck on.\r\n\r\n> Without -Raw, Get-Content inherently retrieves a collection of lines, and returning a value that signals \"no items in this collection\" seems appropriate.\r\n\r\nThat's actually not true. If a file contains one line, ```Get-Content``` does not return a collection of one item. It just returns the only line that is in the file (i.e. it returns a string). That's why I was leaning towards the behaviour of both ```Get-Content``` and ```Get-Content -Raw``` being consistent when the file is either empty or when there is one line.\r\n\r\nRegardless, I also want to hear from the PowerShell team because the point may be moot otherwise.\r\n",
      "created_at": "2017-05-31T00:10:34Z",
      "updated_at": "2017-05-31T00:10:34Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "> It just returns the only line that is in the file (i.e. it returns a string).\r\n\r\nAnd that is the `PowerShell way`, no?  I mean that is one reason we have `@()` to force an array when we get a scalar.  It is also why `foreach` will iterate a scalar (exactly once). ",
      "created_at": "2017-05-31T00:54:38Z",
      "updated_at": "2017-05-31T00:54:38Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "If you'll indulge me:\r\n\r\nThe arc of PowerShell history is long, but it bends toward collections.\r\n\r\nThe special-casing of one-element collections has always been a pain point - until PSv3, the Great Unifier, came along and allowed us to treat even scalars as if they're collections.\r\n\r\n> that is one reason we have @()\r\n\r\nIn that vein: and now _mostly do not need anymore_ (except if there's a chance that an element of the collection has `.Length` / `.Count` properties or itself supports indexing).\r\n\r\nIn short: The PowerShell Way, methinks, is: Everything's a collection, unless told otherwise (such as with `Get-Content -Raw`).\r\n\r\n\r\n\r\n",
      "created_at": "2017-05-31T01:16:30Z",
      "updated_at": "2017-05-31T01:20:22Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Based on the discussion above, and considering that `Get-Content` behavior can be simulated by other (third-party) cmdlets we should exclude `Get-Content` from the issue and consider only \"LHS of array-aware operators\" option.",
      "created_at": "2017-05-31T07:37:27Z",
      "updated_at": "2017-05-31T07:37:27Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Good idea to separate the two discussions:\r\n\r\n* The `Get-Content` issue, irrespective of its _specific_ significance, is worth considering separately, because I think **getting clarity on the underlying scalar-vs.-collection debate is important for the future** (as an aside: I don't think deciding whether or not to change `Get-Content` should be based solely on whether the issue _can be worked around_ ):\r\n\r\n    *  I've therefore created #3911, based on the following assertion:  \r\n**_None_ is a special case of _many_, not _one_.**\r\n\r\n---\r\n\r\nNow that the focus of this issue on the behavior of array-aware operators with `[System.Management.Automation.Internal.AutomationNull]::Value`  as the LHS, let me summarize:\r\n\r\nNote: For brevity, and to give the construct a more memorable name, I'll refer to `[System.Management.Automation.Internal.AutomationNull]::Value` as a _null collection_ from now on.\r\n\r\n* All array-aware operators should treat  _the same_, which is currently not the case: among the operators discussed so far, only `-match` treats a null collection as an _array_, whereas the others (`-eq`, `ge`, ...) treat it like (scalar) `$null`.\r\n\r\n* **If null collections should categorically be treated like _arrays_** (which makes sense to me), the secondary question is whether they should - _invariably, by definition_ - return:\r\n\r\n    * either: an _empty_ `[System.Object[]]` instance, as `-match` currently does.\r\n    * or: a null collection (`[System.Management.Automation.Internal.AutomationNull]::Value`) too.\r\n\r\n* The **alternative approach** is to categorically treat null collections **as `$null` in the context of expressions**, because, [according to the documentation](https://msdn.microsoft.com/en-us/library/system.management.automation.internal.automationnull.value(v=vs.85).aspx): \r\n\r\n> When received in an evaluation where a value is required, it should be replaced with null.\r\n\r\n---\r\n\r\nTo help with experimenting, I thought I'd provide convenience function `Test-Null` that makes it easier to distinguish between `$null` and `[System.Management.Automation.Internal.AutomationNull]::Value`:\r\n\r\nA few sample calls:\r\n\r\n```powershell\r\n> New-Item -Type File zero.txt\r\n\r\n> (Get-Content zero.txt) | Test-Null\r\n(null collection)\r\n\r\n> (Get-Content -Raw zero.txt) | Test-Null\r\n(null collection)\r\n\r\n> (Get-Content -Encoding Byte zero.txt) | Test-Null\r\n(null collection)\r\n\r\n> $null | Test-Null\r\n$null\r\n\r\n> Test-Null ((Get-Content -Raw zero.txt) -match 'anything')\r\n[System.Object[]]   # an empty array - null collection was treated like empty array\r\n\r\n> Test-Null ((Get-Content -Raw zero.txt) -gt 0)\r\n[System.Boolean]   # Boolean - null collection was treated like scalar $null\r\n\r\n> Test-Null ($null -gt 0)\r\n[System.Boolean]\r\n```\r\n\r\nImportant:\r\n\r\n* To distinguish a null collection from an empty collection object, use the (implied) `-InputObject` _parameter_.\r\n\r\n* To distinguish `$null` from a null collection (`[System.Management.Automation.Internal.AutomationNull]::Value`), use the _pipeline_.\r\n\r\n\r\n```powershell\r\n<#\r\n.SYNOPSIS\r\nTests if the (first) input object is non-$null, an explicit (scalar) $null, or \r\na null collection.\r\n\r\n.DESCRIPTION\r\n\r\nIMPORTANT: Choose between pipeline and parameter input depending on what cases\r\n           you need to distinguish:\r\n \r\n * To distinguish between $null and a null collection, use *pipeline* input.\r\n\r\n * To distinguish between a null collection and an empty collection object,\r\n   use the (implied) -InputObject *parameter*.\r\n     * Note: Any collection you specify is treated as a *single* input object.\r\n\r\nOutput is a string that indicates one of 3 conditions; if there is more than\r\n1 (non-null-collection) value in the pipeline, ' ...' is appended.\r\n\r\n* '$null' ... an explicit, scalar $null value \r\n\r\n* '(null collection)' ... the [System.Management.Automation.Internal.AutomationNull]::Value\r\n  singleton that is returned behind the scenes by cmdlet or function calls \r\n  that produce no output.\r\n\r\n* '[<type>]' ... the full type name of the (first) input object, which implies\r\n  an object that is neither $null nor the null collection.\r\n\r\n.NOTES\r\nCaveat re multiple pipeline input objects:\r\nThe type of the 1st object OTHER THAN \r\n[System.Management.Automation.Internal.AutomationNull]::Value is reported.\r\nHypothetically, you could send something like\r\n  [System.Management.Automation.Internal.AutomationNull]::Value, 'foo' |\r\n    Test-Null\r\nin which case it is \"foo\"'s type - [System.String] - that is reported.\r\n\r\n.EXAMPLE\r\n> $noSuchVar | Test-Null\r\n$null\r\n.EXAMPLE\r\n> Get-ChildItem noSuchFiles* | Test-Null \r\n(null collection)\r\n.EXAMPLE\r\n> Get-ChildItem / | Test-Null\r\n[System.IO.DirectoryInfo] ...\r\n.EXAMPLE\r\n> & { return } | Test-Null\r\n(null collection)\r\n.EXAMPLE\r\n> & { return $null } | Test-Null\r\n$null\r\n#>\r\nfunction Test-Null {\r\n  param(\r\n    [AllowEmptyCollection()]\r\n    [AllowEmptyString()]\r\n    [AllowNull()]\r\n    [Parameter(ValueFromPipeline)]\r\n    $InputObject\r\n  )\r\n\r\n  begin {\r\n   $havePipelineInput = $MyInvocation.ExpectingInput\r\n   $didEnumerate = $false\r\n   $multiplePipelineObjects = $False\r\n   $firstInputObj = $InputObject\r\n  }\r\n\r\n  process {\r\n    if ($didEnumerate) { $multiplePipelineObjects = $true; return }\r\n    $firstInputObj = $InputObject\r\n    $didEnumerate = $True\r\n  }\r\n\r\n  end {\r\n    if ($havePipelineInput -and -not $didEnumerate) {\r\n      '(null collection)'\r\n      # Issue a courtesy hint re inability to detect an *empty collection* object via the pipeline.\r\n      Write-Verbose -Verbose 'Hint: To distinguish a null collection from an empty collection object, use -InputObject.'\r\n    } elseif (-not $havePipelineInput -and -not $PSBoundParameters.ContainsKey('InputObject')) {\r\n      Throw \"Please provide input either via the pipeline or via the (implied) -InputObject parameter.\"\r\n    } else {\r\n      if ($null -eq $firstInputObj) {  # $null\r\n        '$null' + ' ...' * $multiplePipelineObjects\r\n        if (-not $havePipelineInput) { \r\n          # Issue a courtesy hint re inability to detect a null collection as a *parameter* value.\r\n          Write-Verbose -Verbose 'Hint: To distinguish $null from a null collection, use the pipeline.'\r\n        }\r\n      } else { # (at least 1) non-$null object\r\n        \"[$($firstInputObj.GetType().FullName)]\" + ' ...' * $multiplePipelineObjects\r\n      }\r\n    }\r\n  }\r\n}\r\n```",
      "created_at": "2017-06-01T22:55:38Z",
      "updated_at": "2017-06-05T13:13:10Z"
    }
  ],
  "created_at": "2017-05-25T21:42:59Z",
  "number": 3866,
  "state": "open",
  "title": "[S.M.A.Internal.AutomationNull]::Value is treated like a collection when used with -match, -notmatch, -like, -notlike",
  "updated_at": "2017-06-05T13:13:10Z"
}