{
  "_url": "https://github.com/PowerShell/PowerShell/issues/16295",
  "author": "iSazonov",
  "body": "<!-- Anything that looks like this is a comment and can't be seen after the Pull Request is created. -->\r\n\r\n# PR Summary\r\n\r\n~~Fix #16293 I tested manually and confirm the fix works for mounted ISOs.~~\r\n\r\n~~New test is based on ISO with FAT file system (no reparse point support).~~\r\n\r\nI prepared the PR as performance improvement a week before #16293 :-)\r\n\r\n``` ini\r\n\r\nBenchmarkDotNet=v0.12.1, OS=Windows 10.0.19041.1288 (2004/?/20H1)\r\nIntel Core i5-2410M CPU 2.30GHz (Sandy Bridge), 1 CPU, 4 logical and 2 physical cores\r\n.NET Core SDK=6.0.100-rc.2.21505.57\r\n  [Host]     : .NET Core 6.0.0 (CoreCLR 6.0.21.48005, CoreFX 6.0.21.48005), X64 RyuJIT\r\n  DefaultJob : .NET Core 6.0.0 (CoreCLR 6.0.21.48005, CoreFX 6.0.21.48005), X64 RyuJIT\r\n\r\n\r\n```\r\n|      Method |           TestString |      Mean |    Error |   StdDev | Ratio |\r\n|------------ |--------------------- |----------:|---------:|---------:|------:|\r\n|    IsWindowsApplication | C:\\Us(...)e.exe [60] | 145.86 us | 1.450 us | 1.286 us |  1.00 |\r\n| IsWindowsApplicationNew | C:\\Us(...)e.exe [60] |  82.41 us | 1.437 us | 1.345 us |  0.57 |\r\n\r\n\r\n## PR Context\r\n\r\n<!-- Provide a little reasoning as to why this Pull Request helps and why you have opened it. -->\r\n\r\n## PR Checklist\r\n\r\n- [x] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [x] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` or `[ WIP ]` to the beginning of the title (the `WIP` bot will keep its status check at `Pending` while the prefix is present) and remove the prefix when the PR is ready.\r\n- **[Breaking changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)**\r\n    - [x] None\r\n    - **OR**\r\n    - [ ] [Experimental feature(s) needed](https://github.com/MicrosoftDocs/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/About/about_Experimental_Features.md)\r\n        - [ ] Experimental feature name(s): <!-- Experimental feature name(s) here -->\r\n- **User-facing changes**\r\n    - [x] Not Applicable\r\n    - **OR**\r\n    - [ ] [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n- **Testing - New and feature**\r\n    - [x] N/A or can only be tested interactively\r\n    - **OR**\r\n    - [ ] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n- **Tooling**\r\n    - [ ] I have considered the user experience from a tooling perspective and don't believe tooling will be impacted.\r\n    - **OR**\r\n    - [ ] I have considered the user experience from a tooling perspective and opened an issue in the relevant tool repository. This may include:\r\n        - [ ] Impact on [PowerShell Editor Services](https://github.com/PowerShell/PowerShellEditorServices) which is used in the [PowerShell extension](https://github.com/PowerShell/vscode-powershell) for VSCode\r\n        (which runs in a different PS Host).\r\n            - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n        - [ ] Impact on Completions (both in the console and in editors) - one of PowerShell's most powerful features.\r\n            - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n        - [ ] Impact on [PSScriptAnalyzer](https://github.com/PowerShell/PSScriptAnalyzer) (which provides linting & formatting in the editor extensions).\r\n            - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n        - [ ] Impact on [EditorSyntax](https://github.com/PowerShell/EditorSyntax) (which provides syntax highlighting with in VSCode, GitHub, and many other editors).\r\n            - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n",
  "closed_at": "2021-11-03T18:45:44Z",
  "comments": [
    {
      "author": "adityapatwardhan",
      "author_association": "MEMBER",
      "body": "We are not taking this for 7.2 GA, we will review this for 7.3",
      "created_at": "2021-10-22T23:30:29Z",
      "updated_at": "2021-10-22T23:30:53Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@adityapatwardhan @daxian-dbw It is a regression after #16165 so please consider for 7.2. I think the issue block running exe-s from any file system that do not support reparse points (ISO, FAT, Wim(?), ...).",
      "created_at": "2021-10-23T14:37:01Z",
      "updated_at": "2021-10-23T17:52:26Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> It is a regression after #16165 so please consider for 7.2.\r\n\r\nWell, it's a regression from https://github.com/PowerShell/PowerShell/pull/16044, not #16165.\r\n\r\n@adityapatwardhan @TravisEz13 Looking this again, it turns out the regression is from 7.1. The `AppExeCLinks` support was originally added in 7.1. The original `IsWindowsApplication` change was done in https://github.com/PowerShell/PowerShell/pull/13481 in 7.1 to help determine if a Store application is GUI or CUI executable, based on the `AppExeCLinks` support. Now that the `AppExeCLinks` support is reverted (by design), the check on Store application is broken. So we should consider this for 7.2 GA, or consider backport it in a servicing release for 7.2 later on.",
      "created_at": "2021-10-23T16:11:36Z",
      "updated_at": "2021-10-23T16:11:36Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Well, it's a regression from #16044, not #16165.\r\n\r\nIn #16165 we replaced WinInternalGetTarget() (no exception) with IO.File.ResolveLinkTarget() (now throw).",
      "created_at": "2021-10-23T17:50:54Z",
      "updated_at": "2021-10-23T17:50:54Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> In #16165 we replaced WinInternalGetTarget() (no exception) with IO.File.ResolveLinkTarget() (now throw).\r\n\r\nIt throws only if something goes wrong when resolving a link. It doesn't throw when a link cannot be resolved, such the AppxExeLink files.",
      "created_at": "2021-10-25T22:19:55Z",
      "updated_at": "2021-10-25T22:19:55Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@TravisEz13 and @adityapatwardhan, I had been in the impression that this PR was to fix the `AppxExeLink` regression, but I was wrong. It's to fix a regression introduced by #16165 in 7.2.0-rc.1. Please review the PR and see if this should be taken for 7.2 GA.\r\n\r\nA simpler fix would be to wrap `File.ResolveLinkTarget` with a try/catch. demonstrated as follows:\r\n```c#\r\ntry\r\n{\r\n    string linkTarget = File.ResolveLinkTarget(fileName, returnFinalTarget: false)?.FullName;\r\n    if (linkTarget is not null)\r\n    {\r\n        fileName = linkTarget;\r\n    }\r\n}\r\ncatch\r\n{\r\n}\r\n```\r\n\r\n@iSazonov's fix could be better in performance, but it's comparatively a larger change than the above, which may introduce unknown side effects.\r\n\r\nWhat about we go with the conservative fix for GA? We can closely review @iSazonov's fix for 7.3.",
      "created_at": "2021-10-26T22:55:36Z",
      "updated_at": "2021-10-27T01:05:09Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@iSazonov Apologies for my earlier off-topic comments. I thought this was for fixing `AppxExeLink` regression somehow by mistake \ud83d\ude26\r\n\r\nI submitted the PR #16310 with the more conservative fix. That fix is safer to be included in 7.2 GA at this point. I borrowed your test though, thanks to you and @jborean93 for that!",
      "created_at": "2021-10-27T01:01:53Z",
      "updated_at": "2021-10-27T01:01:53Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> What about we go with the conservative fix for GA? We can closely review @iSazonov's fix for 7.3.\r\n\r\nI have no objections to get the PR in 7.3 if you see a risk for 7.2.\r\n\r\nOriginally I prepared this as performance fix and I have some more ideas for improving startup scenario but a bug in .Net was fixed too late and PerfView did not work with new traces until then. With .Net we already have ~20% perf win in startup scenario and if MSFT team want we could get another up to ~10%.",
      "created_at": "2021-10-27T06:47:07Z",
      "updated_at": "2021-10-27T06:47:07Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> With .Net we already have ~20% perf win in startup scenario and if MSFT team want we could get another up to ~10%.\r\n\r\n10% speed up in startup is of course what we would want. If that the use JSON .NET instead of NewtonSoft in configuration?",
      "created_at": "2021-10-27T16:40:04Z",
      "updated_at": "2021-10-27T16:40:04Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> > With .Net we already have ~20% perf win in startup scenario and if MSFT team want we could get another up to ~10%.\r\n> \r\n> 10% speed up in startup is of course what we would want. If that the use JSON .NET instead of NewtonSoft in configuration?\r\n\r\nYes, the PR is ready and you can measure. .And PSVersion with source generator, PR is ready too. Also I see in traces PSStyle too early and expensive initialization (in static InitialSessionState()), ~~but no PR have I~~ the PR is ready too.\r\nThere is System.Diagnostics.Tracing.EventSource expensive initialization. It seems .Net team has an issue for this but we could do something too although it is not trivial and it may require effort.",
      "created_at": "2021-10-27T16:53:52Z",
      "updated_at": "2021-10-28T06:53:40Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "I run benchmarks for both the current `SHGetFileInfo` and the `PEHeader` approaches, and the result shows that the `PEHeader` approach is not as performant as the existing `SHGetFileInfo` approach.\r\n\r\nAs is shown in the results, the `RunOld` is always faster than `RunNew`. `RunOld` uses `SHGetFileInfo` while `RunNew` uses `PEHeader`. Especially for `wt.exe` (store app) and `result.txt` (file with shell-associated app), it's way slower using the `PEHeader` approach for them. This is because\r\n- for store app, an exception is thrown to get the result when using `PEHeader`;\r\n- for files, the whole file will be read into memory when using `PEHeader`.\r\n\r\nGiven this, I don't think we should make changes to the existing code.\r\n\r\n```\r\nBenchmarkDotNet=v0.13.0, OS=Windows 10.0.19043.1288 (21H1/May2021Update)\r\nIntel Core i7-1065G7 CPU 1.30GHz, 1 CPU, 8 logical and 4 physical cores\r\n.NET SDK=6.0.100-rc.2.21505.57\r\n  [Host]   : .NET 6.0.0 (6.0.21.48005), X64 RyuJIT\r\n  .NET 6.0 : .NET 6.0.0 (6.0.21.48005), X64 RyuJIT\r\n\r\nJob=.NET 6.0  Runtime=.NET 6.0\r\n\r\n| Method |              ExePath |           Mean |        Error |       StdDev |         Median |\r\n|------- |--------------------- |---------------:|-------------:|-------------:|---------------:|\r\n| RunOld | C:\\Pr(...)h.exe [38] |    51,141.1 ns |    609.53 ns |    570.16 ns |    51,159.3 ns |\r\n| RunNew | C:\\Pr(...)h.exe [38] |    54,983.0 ns |    968.27 ns |    905.72 ns |    55,131.4 ns |\r\n| RunOld | C:\\Us(...)t.exe [57] |    18,302.6 ns |    386.74 ns |  1,128.13 ns |    18,002.8 ns |\r\n| RunNew | C:\\Us(...)t.exe [57] |    35,779.6 ns |    520.25 ns |    486.64 ns |    35,571.9 ns |\r\n| RunOld | C:\\WI(...)d.exe [31] |    60,472.8 ns |    954.44 ns |    846.08 ns |    60,254.5 ns |\r\n| RunNew | C:\\WI(...)d.exe [31] |    64,938.8 ns |  1,176.96 ns |  1,043.34 ns |    64,702.2 ns |\r\n| RunOld | C:\\ar(...)t.txt [23] |       179.8 ns |      2.97 ns |      2.48 ns |       179.5 ns |\r\n| RunNew | C:\\ar(...)t.txt [23] | 1,388,967.6 ns | 25,999.91 ns | 43,440.01 ns | 1,388,259.2 ns |\r\n\r\n** C:\\Pr(...)h.exe -- C:\\Program Files\\PowerShell\\7\\pwsh.exe  (console app)\r\n** C:\\Us(...)t.exe -- C:\\Users\\rocky\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe (store app)\r\n** C:\\WI(...)d.exe -- C:\\WINDOWS\\system32\\notepad.exe (gui app)\r\n** C:\\ar(...)t.txt -- C:\\arena\\tmp\\result.txt (file that has shell-associated app)\r\n```\r\n\r\n<details><summary>CLICK to see Benchmark source code</summary>\r\n<p>\r\n\r\n```c#\r\nusing System;\r\nusing System.IO;\r\nusing System.Collections.Generic;\r\nusing System.Runtime.InteropServices;\r\nusing System.Reflection.PortableExecutable;\r\n\r\nusing BenchmarkDotNet.Attributes;\r\nusing BenchmarkDotNet.Running;\r\nusing BenchmarkDotNet.Jobs;\r\n\r\nnamespace benchmark\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            var summary = BenchmarkRunner.Run<Benchmark_IsWindowsApplication>();\r\n        }\r\n    }\r\n\r\n    [SimpleJob(RuntimeMoniker.Net60)]\r\n    public class Benchmark_IsWindowsApplication\r\n    {\r\n        [ParamsSource(nameof(ValuesForPath))]\r\n        public string ExePath { get; set; }\r\n\r\n        public IEnumerable<string> ValuesForPath()\r\n        {\r\n            yield return @\"C:\\Program Files\\PowerShell\\7\\pwsh.exe\";\r\n            yield return @\"C:\\WINDOWS\\system32\\notepad.exe\";\r\n            yield return @\"C:\\arena\\tmp\\result.txt\";\r\n            yield return @\"C:\\Users\\rocky\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe\";\r\n        }\r\n\r\n        [Benchmark]\r\n        public bool RunOld()\r\n        {\r\n            return IsWindowsApplication_OLD(ExePath);\r\n        }\r\n\r\n        [Benchmark]\r\n        public bool RunNew()\r\n        {\r\n            return IsWindowsApplication_NEW(ExePath);\r\n        }\r\n\r\n        internal static bool IsWindowsApplication_NEW(string fileName)\r\n        {\r\n            try\r\n            {\r\n                using var stream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);\r\n                PEHeader peheader = (new PEHeaders(stream)).PEHeader;\r\n                return peheader is not null && peheader.Subsystem == Subsystem.WindowsGui;\r\n            }\r\n            catch\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        internal static bool IsWindowsApplication_OLD(string fileName)\r\n        {\r\n            SHFILEINFO shinfo = new SHFILEINFO();\r\n            IntPtr type = SHGetFileInfo(fileName, 0, ref shinfo, (uint)Marshal.SizeOf(shinfo), SHGFI_EXETYPE);\r\n\r\n            switch ((int)type)\r\n            {\r\n                case 0x0:\r\n                    // 0x0 = not an exe\r\n                    return false;\r\n                case 0x5a4d:\r\n                    // 0x5a4d - DOS .exe or .com file\r\n                    return false;\r\n                case 0x4550:\r\n                    // 0x4550 - windows console app or bat file\r\n                    return false;\r\n                default:\r\n                    // anything else - is a windows program...\r\n                    return true;\r\n            }\r\n        }\r\n\r\n        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\r\n        private struct SHFILEINFO\r\n        {\r\n            public IntPtr hIcon;\r\n            public int iIcon;\r\n            public uint dwAttributes;\r\n\r\n            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)]\r\n            public string szDisplayName;\r\n\r\n            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 80)]\r\n            public string szTypeName;\r\n        }\r\n\r\n        private const uint SHGFI_EXETYPE = 0x000002000; // flag used to ask to return exe type\r\n\r\n        [DllImport(\"shell32.dll\", CharSet = CharSet.Unicode)]\r\n        private static extern IntPtr SHGetFileInfo(string pszPath, uint dwFileAttributes,\r\n            ref SHFILEINFO psfi, uint cbSizeFileInfo, uint uFlags);\r\n    }\r\n}\r\n```\r\n\r\n</p>\r\n</details>",
      "created_at": "2021-11-02T22:57:31Z",
      "updated_at": "2021-11-02T22:58:35Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "What is the reason you are measuring the opposite scenario? This optimization is just for exe files, which is the most common use. Or do you think users prefer to run wt.exe in a loop 100 times per second? :-)\r\n\r\nAlso Windows team doesn't publish APIs for appx. So we can not detect whether it is a console or GUI and so on. Before we could do something useful for appx  MSFT must introduce public API for this.",
      "created_at": "2021-11-03T04:06:14Z",
      "updated_at": "2021-11-03T04:10:04Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> for files, the whole file will be read into memory when using PEHeader.\r\n\r\nI don't see this in PEHeader sources - it seek a offset only.",
      "created_at": "2021-11-03T04:31:50Z",
      "updated_at": "2021-11-03T04:31:50Z"
    },
    {
      "author": "pull-request-quantifier[bot]",
      "author_association": "NONE",
      "body": "### ![](https://img.shields.io/static/v1?label=Quantified&message=Extra%20Small&color=green)\r\n\r\nThis PR has `43` quantified lines of changes. In general, a change size of upto `200` lines is ideal for the best PR experience!\r\n\r\n------\r\n\r\n<details >\r\n    <summary display=\"inline\"> <strong>Quantification details</strong></summary>\r\n    <p />\r\n\r\n```\r\nLabel      : Extra Small\r\nSize       : +6 -37\r\nPercentile : 17.2%\r\n\r\nTotal files changed: 1\r\n\r\nChange summary by file extension:\r\n.cs : +6 -37\r\n```\r\n> Change counts above are quantified counts, based on the [PullRequestQuantifier customizations](https://github.com/microsoft/PullRequestQuantifier/blob/main/docs/prquantifier-yaml.md).\r\n    \r\n</details>\r\n\r\n\r\n<details>\r\n    <summary display=\"inline\"> <strong>Why proper sizing of changes matters</strong> </summary>\r\n    <p/>\r\n    <p/>\r\n\r\nOptimal pull request sizes drive a better predictable PR flow as they strike a\r\nbalance between between PR complexity and PR review overhead. PRs within the\r\noptimal size (typical small, or medium sized PRs) mean:\r\n\r\n- Fast and predictable releases to production:\r\n  - Optimal size changes are more likely to be reviewed faster with fewer\r\niterations.\r\n  - Similarity in low PR complexity drives similar review times.\r\n- Review quality is likely higher as complexity is lower:\r\n  - Bugs are more likely to be detected.\r\n  - Code inconsistencies are more likely to be detetcted.\r\n- Knowledge sharing is improved within the participants:\r\n  - Small portions can be assimilated better.\r\n- Better engineering practices are exercised:\r\n  - Solving big problems by dividing them in well contained, smaller problems.\r\n  - Exercising separation of concerns within the code changes.\r\n\r\n#### What can I do to optimize my changes\r\n\r\n- Use the PullRequestQuantifier to quantify your PR accurately\r\n  - Create a context profile for your repo using the [context generator](https://github.com/microsoft/PullRequestQuantifier/releases)\r\n  - Exclude files that are not necessary to be reviewed or do not increase the review complexity. Example: Autogenerated code, docs, project IDE setting files, binaries, etc. Check out the `Excluded` section from your `prquantifier.yaml` context profile. \r\n  - Understand your typical change complexity, drive towards the desired complexity by adjusting the label mapping in your `prquantifier.yaml` context profile.\r\n  - Only use the labels that matter to you, [see context specification](./docs/prquantifier-yaml.md) to customize your `prquantifier.yaml` context profile.\r\n- Change your engineering behaviors\r\n  - For PRs that fall outside of the desired spectrum, review the details and check if:\r\n    - Your PR could be split in smaller, self-contained PRs instead\r\n    - Your PR only solves one particular issue. (For example, don't refactor and code new features in the same PR).\r\n\r\n#### How to interpret the change counts in git diff output\r\n\r\n- One line was added: `+1 -0`\r\n- One line was deleted: `+0 -1`\r\n- One line was modified: `+1 -1` (git diff doesn't know about modified, it will\r\ninterpret that line like one addition plus one deletion)\r\n- Change percentiles: Change characteristics (addition, deletion, modification)\r\nof this PR in relation to all other PRs within the repository.\r\n\r\n</details>\r\n\r\n<p />\r\n\r\n------\r\n\r\nWas this comment helpful? <a href=\"https://pullrequestquantifierfeedback.azurewebsites.net/feedback?payload=eyJBdXRob3JOYW1lIjoiaVNhem9ub3YiLCJSZXBvc2l0b3J5TGluayI6Imh0dHBzOi8vZ2l0aHViLmNvbS9Qb3dlclNoZWxsL1Bvd2VyU2hlbGwiLCJQdWxsUmVxdWVzdExpbmsiOiJodHRwczovL2dpdGh1Yi5jb20vUG93ZXJTaGVsbC9Qb3dlclNoZWxsL3B1bGwvMTYyOTUiLCJFdmVudFR5cGUiOiJUaHVtYnNVcCJ9&amp;anonymous=True\" target=\"_blank\" title=\"Thumbs up\"><strong>:thumbsup:</strong></a> <a href=\"https://pullrequestquantifierfeedback.azurewebsites.net/feedback?payload=eyJBdXRob3JOYW1lIjoiaVNhem9ub3YiLCJSZXBvc2l0b3J5TGluayI6Imh0dHBzOi8vZ2l0aHViLmNvbS9Qb3dlclNoZWxsL1Bvd2VyU2hlbGwiLCJQdWxsUmVxdWVzdExpbmsiOiJodHRwczovL2dpdGh1Yi5jb20vUG93ZXJTaGVsbC9Qb3dlclNoZWxsL3B1bGwvMTYyOTUiLCJFdmVudFR5cGUiOiJOZXV0cmFsIn0=&amp;anonymous=True\" target=\"_blank\" title=\"Neutral\"><strong>&nbsp;:ok_hand:</strong></a> <a href=\"https://pullrequestquantifierfeedback.azurewebsites.net/feedback?payload=eyJBdXRob3JOYW1lIjoiaVNhem9ub3YiLCJSZXBvc2l0b3J5TGluayI6Imh0dHBzOi8vZ2l0aHViLmNvbS9Qb3dlclNoZWxsL1Bvd2VyU2hlbGwiLCJQdWxsUmVxdWVzdExpbmsiOiJodHRwczovL2dpdGh1Yi5jb20vUG93ZXJTaGVsbC9Qb3dlclNoZWxsL3B1bGwvMTYyOTUiLCJFdmVudFR5cGUiOiJUaHVtYnNEb3duIn0=&amp;anonymous=True\" target=\"_blank\" title=\"Thumbs down\"><strong>&nbsp;:thumbsdown:</strong></a> (<a href=\"MAILTO:prquantifier@microsoft.com\" title=\"Mail to prquantifier@microsoft.com\">Email</a>)\r\n[Customize PullRequestQuantifier](https://github.com/PowerShell/PowerShell/blob/master/.github/prquantifier.yaml) for this repository.\r\n\r\n",
      "created_at": "2021-11-03T04:49:45Z",
      "updated_at": "2021-11-03T04:49:45Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Why do you exclude File.ResolveLinkTarget from IsWindowsApplication_OLD? Sly! :-)",
      "created_at": "2021-11-03T05:00:59Z",
      "updated_at": "2021-11-03T05:00:59Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> Why do you exclude File.ResolveLinkTarget from IsWindowsApplication_OLD? Sly! :-)\r\n\r\nYeah, I missed that line of code :) But it also occurred to me that **we don't need that line of code today given that it doesn't work for Windows Store apps (`AppExeCLinks`).**\r\n\r\nThe whole reason that `InternalSymbolicLinkLinkCodeMethods.WinInternalGetTarget(fileName)` was originally [added here](https://github.com/PowerShell/PowerShell/pull/13481/files#diff-f4036ed1a5c3c9f35845bfd272e345992a55ee26e27bdf38446ab9c66e971aafR978-R986) was to fix for the Windows Store apps. You submitted the PR #13481, remember? :)\r\n\r\n`WinInternalGetTarget` was replaced by `File.ResolveLinkTarget` when deprecating `WinInternalGetTarget`, but since there is no documented API to retrieve the actual target of a Windows Store app, there is no point to keep `File.ResolveLinkTarget` anymore. **We can totally remove that for now, until the regarding API gets documented.**\r\n\r\n> What is the reason you are measuring the opposite scenario? This optimization is just for exe files, which is the most common use. Or do you think users prefer to run wt.exe in a loop 100 times per second? :-)\r\n\r\nThe `PEHeader` approach is generally slower than `SHGetFileInfo`, not just `wt.exe`. Directly executing a document to open it with the shell-associated application is also quite common, like an excel, an .txt file, or a word file.\r\n\r\n> Also Windows team doesn't publish APIs for appx. So we can not detect whether it is a console or GUI and so on. Before we could do something useful for appx MSFT must introduce public API for this.\r\n\r\nYeah, both approaches return `false` for Windows Store app, but the `PEHeader` one requires exception handling for that, so it's way slower. Yeah, this is not a common scenario, but like I said, the `PEHeader` is slower in general, for all 4 scenarios tested.\r\n\r\n> I don't see this in PEHeader sources - it seek a offset only.\r\n\r\nI didn't look into the `PEHeader` source, maybe that's caused by creating a `FileStream`.",
      "created_at": "2021-11-03T17:17:07Z",
      "updated_at": "2021-11-03T17:19:15Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "So I understand from your comment that negotiations with Windows team were fruitless and we will not get public appx API. In the case, yes, we should simply remove `File.ResolveLinkTarget` and obviously one p/invoke `SHGetFileInfo` will be faster than `PEHeader`.",
      "created_at": "2021-11-03T18:25:03Z",
      "updated_at": "2021-11-03T18:25:03Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "From the last conversation with the Windows Store team about this, they said it was by-design to not document that API, because they might change how the mapping goes behind the scene.\r\n\r\nI don't think anyone from our team has started the conversation again after we learnt about this regression in `NativeCommandProcessor`, and I don't know if that will change any of their decision. But if they documented the API, .NET team will update `ResolveLinkTarget` to support `AppExecLink`, so we can just add back `File.ResolveLinkTarget` when that day comes.\r\n\r\nCan you maybe update your PR to remove `File.ResolveLinkTarget` in this code path?",
      "created_at": "2021-11-03T18:37:40Z",
      "updated_at": "2021-11-03T22:10:40Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Can you maybe update your PR to remove File.ResolveLinkTarget in this code path?\r\n\r\nToo long path :-) Will do new PR.",
      "created_at": "2021-11-03T18:40:55Z",
      "updated_at": "2021-11-03T18:40:55Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "Yeah, a new PR is better, making the purpose clearer too.\r\nPlease make sure the new PR description captures the gist of https://github.com/PowerShell/PowerShell/pull/16295#issuecomment-959748719. Thanks!\r\n\r\nI will close this PR then.",
      "created_at": "2021-11-03T18:44:35Z",
      "updated_at": "2021-11-03T18:44:35Z"
    }
  ],
  "created_at": "2021-10-22T17:54:42Z",
  "number": 16295,
  "state": "closed",
  "title": "Rid of ResolveLinkTarget from IsWindowsApplication",
  "updated_at": "2021-11-12T04:58:26Z"
}