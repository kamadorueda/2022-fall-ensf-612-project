{
  "_url": "https://github.com/PowerShell/PowerShell/issues/13494",
  "author": "dolauli",
  "body": "<!--\r\n\r\nFor Windows PowerShell 5.1 issues, suggestions, or feature requests please use the following link instead:\r\nWindows PowerShell [UserVoice](https://windowsserver.uservoice.com/forums/301869-powershell)\r\n\r\nThis repository is **ONLY** for PowerShell Core 6 and PowerShell 7+ issues.\r\n\r\n- Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\r\n- Search the existing issues.\r\n- Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\r\n- Refer to the [known issues](https://docs.microsoft.com/powershell/scripting/whats-new/known-issues-ps6).\r\n\r\n-->\r\n\r\n## Steps to reproduce\r\n\r\n```powershell\r\n\r\nPS /home/xiaogang> [int]$timeInt = $(Get-Date -UFormat '%s')\r\nPS /home/xiaogang> $passwd = \"bl0ckCh@!n$timeInt)\" | ConvertTo-SecureString -AsPlainText -Force\r\nPS /home/xiaogang> $psTxt = [System.Runtime.InteropServices.marshal]::PtrToStringAuto([System.Runtime.InteropServices.marshal]::SecureStringToBSTR($passwd))\r\nPS /home/xiaogang> $psTxt\r\nb\r\n\r\n```\r\n\r\n## Expected behavior\r\n\r\n```none\r\nPS C:\\Users\\xidi> [int]$timeInt = $(Get-Date -UFormat '%s')\r\nPS C:\\Users\\xidi> $passwd = 'bl0ckCh@!n$timeInt)' | ConvertTo-SecureString -AsPlainText -Force\r\nPS C:\\Users\\xidi> $psTxt = [System.Runtime.InteropServices.marshal]::PtrToStringAuto([System.Runtime.InteropServices.marshal]::SecureStringToBSTR($passwd))\r\nPS C:\\Users\\xidi> $psTxt\r\nbl0ckCh@!n$timeInt)\r\n```\r\n\r\n## Actual behavior\r\n\r\n```none\r\nb is return instead of bl0ckCh@!n$timeInt)\r\n```\r\n\r\n## Environment data\r\nIssue only happens in PowerShell 7.0.3 in **CloudShell** and **Ubuntu 18.04**, But in PowerShell 7.0.3, 7.0.0, 6.2.4 and Windows PowerShell in my local Windows machine, it is OK.\r\n\r\n\r\n\r\n```none\r\n\r\n```\r\n",
  "closed_at": "2020-08-23T00:00:17Z",
  "comments": [
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "When you create a secure string on non-Windows hosts the actual secure string is simply the UTF-16-LE encoding of the text you've specified. In this example we will be using the password `caf\u00e9\ud834\udd1e` to test out some of the encoding edge cases.\r\n\r\n```powershell\r\n$pass = \"caf\u00e9$([Char]::ConvertFromUTF32(0x0001D11E))\" | ConvertTo-SecureString -AsPlainText -Force\r\n$pass | ConvertFrom-SecureString\r\n\r\n# 630061006600e90034d81edd\r\n\r\n$bstrPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($pass)\r\n$bstrBytes = [byte[]]::new(14)\r\n[System.Runtime.InteropServices.Marshal]::Copy($bstrPtr, $bstrBytes, 0, $bstrBytes.Length)\r\n$bstrBytes | Format-Hex\r\n\r\n#    Label: Byte (System.Byte) <095C5B21>\r\n#\r\n#           Offset Bytes                                           Ascii\r\n#                  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\r\n#           ------ ----------------------------------------------- -----\r\n# 0000000000000000 63 00 61 00 66 00 E9 00 34 D8 1E DD 00 00       c a f \u00e9 4\u00d8\ufffd\u00dd  \r\n\r\n$uniPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToGlobalAllocUnicode($pass)\r\n$uniBytes = [byte[]]::new(14)\r\n[System.Runtime.InteropServices.Marshal]::Copy($uniPtr, $uniBytes, 0, $uniBytes.Length)\r\n$uniBytes | Format-Hex\r\n\r\n#    Label: Byte (System.Byte) <3576ADA4>\r\n#\r\n#           Offset Bytes                                           Ascii\r\n#                  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\r\n#           ------ ----------------------------------------------- -----\r\n# 0000000000000000 63 00 61 00 66 00 E9 00 34 D8 1E DD 00 00       c a f \u00e9 4\u00d8\ufffd\u00dd \r\n\r\n# This will differ as the encoding used is based on [Text.Encoding]::Default\r\n# This example was on Linux where the default encoding is UTF-8\r\n$ansiPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToGlobalAllocAnsi($pass)\r\n$ansiBytes = [byte[]]::new(10)\r\n[System.Runtime.InteropServices.Marshal]::Copy($ansiPtr, $ansiBytes, 0, $ansiBytes.Length)\r\n$ansiBytes | Format-Hex\r\n\r\n#    Label: Byte (System.Byte) <75B70A19>\r\n#\r\n#           Offset Bytes                                           Ascii\r\n#                  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\r\n#           ------ ----------------------------------------------- -----\r\n# 0000000000000000 63 61 66 C3 A9 F0 9D 84 9E 00                   caf\u00c3\u00a9\u00f0\ufffd\ufffd\ufffd\r\n```\r\n\r\nSo we can see that the raw bytes when you use `SecureStringToBSTR` or `SecureStringToGlobalAllocUnicode` are the UTF-16-LE encoded bytes of your string. I personally don't know what the difference is between the 2 as the end result seems to be the same. The `SecureStringToGlobalAllocAnsi` method is dependent on the default encoding set for the system. You can get this value by running `[Text.Encoding]::Default` but this will definitely differ across Windows and non-Windows hosts. The key takeaway from this point is that the raw bytes in unmanaged memory is going to be your password encoded by UTF-16-LE.\r\n\r\nThere are 5 main functions that you can use to convert a ptr of unmanaged memory to a string\r\n\r\n* [PtrToStringAnsi](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.ptrtostringansi?view=netcore-3.1)\r\n* [PtrToStringAuto](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.ptrtostringauto?view=netcore-3.1)\r\n* [PtrToStringBSTR](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.ptrtostringbstr?view=netcore-3.1)\r\n* [PtrToStringUni](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.ptrtostringuni?view=netcore-3.1)\r\n* [PtrToStringUTF8](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.ptrtostringutf8?view=netcore-3.1) - Added in .NET Core\r\n\r\nWhen you call each of these functions without specifying the length it reads each byte until it comes across the first NULL char, i.e. `\\u0000` encoded to bytes. For example UTF-8 and other extended ASCII encodings would be `00`, whereas Unicode/UTF-16 will be `00 00`.\r\n\r\nOn Windows, [PtrToStringAuto](https://github.com/dotnet/runtime/blob/6072e4d3a7a2a1493f514cdf4be75a3d56580e84/src/libraries/System.Private.CoreLib/src/System/Runtime/InteropServices/Marshal.Windows.cs#L15) calls `PtrToStringUni` so it's reading all the bytes until it gets to `00 00`. This is why you can use your function and get the proper string back.\r\n\r\nOn other platforms, [PtrToStringAuto](https://github.com/dotnet/runtime/blob/6072e4d3a7a2a1493f514cdf4be75a3d56580e84/src/libraries/System.Private.CoreLib/src/System/Runtime/InteropServices/Marshal.Unix.cs#L16) calls `PtrToStringUTF8` so it's reading all the bytes until it gets to `00`. It's only returning the first char because the 2nd byte is `00` when the function thinks it's the end of the string.\r\n\r\nPowerShell can't really do anything about the change in behaviour on the different platforms. Ultimately what this means is that you should make sure you call `SecureStringToGlobalAllocUnicode` to get your pointer then `PtrToStringUni` to get the string from that pointer. This way you ensure you are always dealing with UTF-16-LE and don't need to deal with platform differences.\r\n\r\nAnother option is to avoid dealing with pointers altogether and use this method instead\r\n\r\n```powershell\r\n$pass = 'abc' | ConvertTo-SecureString -AsPlainText -Force\r\n\r\n[PSCredential]::new('dummy', $pass).GetNetworkCredential().Password\r\n```\r\n\r\nNo need to worry about clearing any unmanaged memory and personally I think it's simpler.",
      "created_at": "2020-08-21T09:52:24Z",
      "updated_at": "2020-08-21T09:52:24Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "Thanks to @SeeminglyScience I now know what the difference between `SecureStringToBSTR` and `SecureStringToGlobalAllocUnicode` is. The former encodes the length of the string in 4 bytes just before the pointer. This is important if your string contains a null character as any of the other methods would see that as the end of the string.\r\n\r\n```powershell\r\n$pass = \"pass`0word\" | ConvertTo-SecureString -AsPlainText -Force\r\n$pass | ConvertFrom-SecureString\r\n# 7000610073007300000077006f0072006400\r\n\r\n$bstrPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($pass)\r\n$bstrBytes = [byte[]]::new(24)\r\n[System.Runtime.InteropServices.Marshal]::Copy([IntPtr]::Add($bstrPtr, -4), $bstrBytes, 0, $bstrBytes.Length)\r\n\r\n$bstrBytes | Format-Hex\r\n\r\n#    Label: Byte (System.Byte) <630BBC81>\r\n#\r\n#           Offset Bytes                                           Ascii\r\n#                  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\r\n#           ------ ----------------------------------------------- -----\r\n# 0000000000000000 12 00 00 00 70 00 61 00 73 00 73 00 00 00 77 00 \ufffd   p a s s   w \r\n# 0000000000000010 6F 00 72 00 64 00 00 00                         o r d   \r\n\r\n$plaintext = [System.Runtime.InteropServices.Marshal]::PtrToStringBSTR($bstrPtr)\r\n$plaintext.Length\r\n# 9\r\n\r\n$plaintext\r\n# password\r\n\r\n$uniPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToGlobalAllocUnicode($pass)\r\n$uniBytes = [byte[]]::new(24)\r\n[System.Runtime.InteropServices.Marshal]::Copy([IntPtr]::Add($uniPtr, -4), $uniBytes, 0, $uniBytes.Length)\r\n\r\n$uniBytes | Format-Hex\r\n\r\n#    Label: Byte (System.Byte) <4552DC2C>\r\n#\r\n#           Offset Bytes                                           Ascii\r\n#                  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\r\n#           ------ ----------------------------------------------- -----\r\n# 0000000000000000 00 00 00 00 70 00 61 00 73 00 73 00 00 00 77 00     p a s s   w \r\n# 0000000000000010 6F 00 72 00 64 00 00 00                         o r d   \r\n\r\n$plaintext = [System.Runtime.InteropServices.Marshal]::PtrToStringUni($uniPtr)\r\n$plaintext.Length\r\n# 4\r\n\r\n$plaintext\r\n# pass\r\n```\r\n\r\nIt also turns out that the `GetNetworkCredential()` method also fails when dealing with null bytes in the string so I would take back my recommendation, even for such a rare edge case. Ultimately you should be using `SecureStringToBSTR` and `PtrToStringBSTR` like so\r\n\r\n```powershell\r\n$pass = \"pass`0word\" | ConvertTo-SecureString -AsPlainText -Force\r\n\r\n$ssPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($pass)\r\ntry {\r\n    $plaintext = [System.Runtime.InteropServices.Marshal]::PtrToStringBSTR($ssPtr)\r\n} finally {\r\n    [System.Runtime.InteropServices.Marshal]::ZeroFreeBSTR($ssPtr)\r\n}\r\n``` ",
      "created_at": "2020-08-21T11:36:57Z",
      "updated_at": "2020-08-21T11:36:57Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Yeah, there've been a few issues around this; fundamentally though, this apparent change was in the underlying API on .NET's end, so there's effectively nothing PowerShell could do. When working with the BSTR methods, the best bet is to use them all the way through, using `PtrToStringBSTR` rather than `PtrToStringAuto`.\r\n\r\nThat won't fix the _many_ blog posts recommending the latter, but it is a solution that works both in Windows PowerShell and pwsh; using `PtrToStringAuto` only works on Windows PowerShell (and even then may occasionally cause some issues, from what I've seen).",
      "created_at": "2020-08-21T12:04:49Z",
      "updated_at": "2020-08-21T12:05:47Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Good info here, but this has indeed come up several times.\r\nHere's the previous list of issues: https://github.com/PowerShell/PowerShell/issues?q=is%3Aissue+ptrtostringauto+is%3Aclosed+NOT+%2Fhome%2Fchythu%2Ftemp\r\n\r\n\n\n<blockquote><img src=\"https://repository-images.githubusercontent.com/49609581/aad0ad80-cdec-11ea-8248-a37bc0571bfd\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/PowerShell/PowerShell\">PowerShell/PowerShell</a></strong></div><div>PowerShell for every system! Contribute to PowerShell/PowerShell development by creating an account on GitHub.</div></blockquote>",
      "created_at": "2020-08-21T12:29:40Z",
      "updated_at": "2020-08-21T12:29:42Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This issue has been marked as answered and has not had any activity for **1 day**. It has been closed for housekeeping purposes.",
      "created_at": "2020-08-23T00:00:15Z",
      "updated_at": "2020-08-23T00:00:15Z"
    }
  ],
  "created_at": "2020-08-21T05:02:58Z",
  "number": 13494,
  "state": "closed",
  "title": "Can not decrypt correctly in PowerShell 7.0.3 in CloudShell and Linux",
  "updated_at": "2020-08-23T00:00:17Z"
}