{
  "_url": "https://github.com/PowerShell/PowerShell/issues/13425",
  "author": "xtqqczze",
  "body": "# PR Summary\r\n\r\n* Use string.Create instead of concatenation in method `ConnectToDataSource`\r\n* Use for loop instead of foreach to avoid allocating an enumerator\r\n\r\n## PR Context\r\n\r\nhttps://github.com/PowerShell/PowerShell/pull/13410#discussion_r469411428\r\n\r\n## PR Checklist\r\n\r\n- [x] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [x] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` or `[ WIP ]` to the beginning of the title (the `WIP` bot will keep its status check at `Pending` while the prefix is present) and remove the prefix when the PR is ready.\r\n- **[Breaking changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)**\r\n    - [x] None\r\n    - **OR**\r\n    - [NA] [Experimental feature(s) needed](https://github.com/MicrosoftDocs/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/About/about_Experimental_Features.md)\r\n        - [NA] Experimental feature name(s): <!-- Experimental feature name(s) here -->\r\n- **User-facing changes**\r\n    - [x] Not Applicable\r\n    - **OR**\r\n    - [NA] [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [NA] Issue filed: <!-- Number/link of that issue here -->\r\n- **Testing - New and feature**\r\n    - [x] N/A or can only be tested interactively\r\n    - **OR**\r\n    - [NA] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n- **Tooling**\r\n    - [x] I have considered the user experience from a tooling perspective and don't believe tooling will be impacted.\r\n    - **OR**\r\n    - [NA] I have considered the user experience from a tooling perspective and enumerated concerns in the summary. This may include:\r\n        - Impact on [PowerShell Editor Services](https://github.com/PowerShell/PowerShellEditorServices) which is used in the [PowerShell extension](https://github.com/PowerShell/vscode-powershell) for VSCode (which runs in a different PS Host).\r\n        - Impact on Completions (both in the console and in editors) - one of PowerShell's most powerful features.\r\n        - Impact on [PSScriptAnalyzer](https://github.com/PowerShell/PSScriptAnalyzer) (which provides linting & formatting in the editor extensions).\r\n        - Impact on [EditorSyntax](https://github.com/PowerShell/EditorSyntax) (which provides syntax highlighting with in VSCode, GitHub, and many other editors).\r\n",
  "closed_at": "2021-06-28T17:58:06Z",
  "comments": [
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "I was skeptical of the enumerator for arrays allocating, so I ran a profile:\r\n\r\n```csharp\r\n    [MemoryDiagnoser]\r\n    public class LoopAllocationTest\r\n    {\r\n        public static void RunProfile()\r\n        {\r\n            BenchmarkRunner.Run<LoopAllocationTest>();\r\n        }\r\n\r\n        private byte[] _nums;\r\n\r\n        [GlobalSetup]\r\n        public void Setup()\r\n        {\r\n            _nums = new byte[1000000];\r\n            new Random().NextBytes(_nums);\r\n        }\r\n\r\n        [Benchmark(Baseline = true)]\r\n        public void RunForLoop()\r\n        {\r\n            for (int i = 0; i < _nums.Length; i++)\r\n            {\r\n                int k = _nums[i];\r\n            }\r\n        }\r\n\r\n        [Benchmark]\r\n        public void RunForEachLoop()\r\n        {\r\n            foreach (int k in _nums)\r\n            {\r\n                ;\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\nResults:\r\n\r\n```\r\nBenchmarkDotNet=v0.12.1, OS=Windows 10.0.19041.450 (2004/?/20H1)\r\nIntel Core i7-8700K CPU 3.70GHz (Coffee Lake), 1 CPU, 12 logical and 6 physical cores\r\n.NET Core SDK=5.0.100-preview.4.20258.7\r\n  [Host]     : .NET Core 5.0.0 (CoreCLR 5.0.20.25106, CoreFX 5.0.20.25106), X64 RyuJIT\r\n  DefaultJob : .NET Core 5.0.0 (CoreCLR 5.0.20.25106, CoreFX 5.0.20.25106), X64 RyuJIT\r\n\r\n\r\n|         Method |     Mean |   Error |  StdDev | Ratio | RatioSD | Gen 0 | Gen 1 | Gen 2 | Allocated |\r\n|--------------- |---------:|--------:|--------:|------:|--------:|------:|------:|------:|----------:|\r\n|     RunForLoop | 228.3 us | 1.41 us | 1.25 us |  1.00 |    0.00 |     - |     - |     - |         - |\r\n| RunForEachLoop | 457.6 us | 4.10 us | 3.43 us |  2.00 |    0.02 |     - |     - |     - |         - |\r\n```\r\n\r\nSo while it looks like a `for` loop is faster, neither loop seems to allocate.",
      "created_at": "2020-08-13T00:01:34Z",
      "updated_at": "2020-08-13T00:51:54Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "Sorry, just realised I for some reason assumed the backing data structure was an array.\r\n\r\nHere's an updated benchmark:\r\n\r\n```csharp\r\nusing BenchmarkDotNet.Attributes;\r\nusing BenchmarkDotNet.Running;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Collections.Specialized;\r\n\r\nnamespace CSharpPlayground\r\n{\r\n    [MemoryDiagnoser]\r\n    public class LoopAllocationTest\r\n    {\r\n        public static void RunProfile()\r\n        {\r\n            BenchmarkRunner.Run<LoopAllocationTest>();\r\n        }\r\n\r\n        private const int Size = 1000000;\r\n\r\n        private string[] _stringArray;\r\n        private StringCollection _stringCollection;\r\n        private List<string> _stringList;\r\n\r\n        [GlobalSetup]\r\n        public void Setup()\r\n        {\r\n\r\n            _stringArray = new string[Size];\r\n            _stringCollection = new StringCollection();\r\n            _stringList = new List<string>();\r\n            var random = new Random();\r\n            for (int i = 0; i < Size; i++)\r\n            {\r\n                string s = random.NextDouble().ToString();\r\n                _stringArray[i] = s;\r\n                _stringCollection.Add(s);\r\n                _stringList.Add(s);\r\n            }\r\n        }\r\n\r\n        [Benchmark(Baseline = true)]\r\n        public void Run_For_Array()\r\n        {\r\n            for (int i = 0; i < _stringArray.Length; i++)\r\n            {\r\n                string s = _stringArray[i];\r\n            }\r\n        }\r\n\r\n        [Benchmark]\r\n        public void Run_ForEach_Array()\r\n        {\r\n            foreach (string s in _stringArray)\r\n            {\r\n                ;\r\n            }\r\n        }\r\n\r\n        [Benchmark]\r\n        public void Run_For_StrCollection()\r\n        {\r\n            for (int i = 0; i < _stringCollection.Count; i++)\r\n            {\r\n                string s = _stringCollection[i];\r\n            }\r\n        }\r\n\r\n        [Benchmark]\r\n        public void Run_ForEach_StrCollection()\r\n        {\r\n            foreach (string s in _stringCollection)\r\n            {\r\n                ;\r\n            }\r\n        }\r\n\r\n        [Benchmark]\r\n        public void Run_For_List()\r\n        {\r\n            for (int i = 0; i < _stringList.Count; i++)\r\n            {\r\n                string s = _stringList[i];\r\n            }\r\n        }\r\n\r\n        [Benchmark]\r\n        public void Run_ForEach_List()\r\n        {\r\n            foreach (string s in _stringList)\r\n            {\r\n                ;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nResults:\r\n```\r\n\r\nBenchmarkDotNet=v0.12.1, OS=Windows 10.0.19041.450 (2004/?/20H1)\r\nIntel Core i7-8700K CPU 3.70GHz (Coffee Lake), 1 CPU, 12 logical and 6 physical cores\r\n.NET Core SDK=5.0.100-preview.4.20258.7\r\n  [Host]     : .NET Core 5.0.0 (CoreCLR 5.0.20.25106, CoreFX 5.0.20.25106), X64 RyuJIT\r\n  DefaultJob : .NET Core 5.0.0 (CoreCLR 5.0.20.25106, CoreFX 5.0.20.25106), X64 RyuJIT\r\n\r\n\r\n|                    Method |       Mean |     Error |    StdDev | Ratio | RatioSD | Gen 0 | Gen 1 | Gen 2 | Allocated |\r\n|-------------------------- |-----------:|----------:|----------:|------:|--------:|------:|------:|------:|----------:|\r\n|             Run_For_Array |   232.6 us |   3.81 us |   3.38 us |  1.00 |    0.00 |     - |     - |     - |         - |\r\n|         Run_ForEach_Array |   231.3 us |   3.00 us |   2.81 us |  1.00 |    0.01 |     - |     - |     - |         - |\r\n|     Run_For_StrCollection | 3,917.4 us |  15.95 us |  12.45 us | 16.81 |    0.28 |     - |     - |     - |         - |\r\n| Run_ForEach_StrCollection | 5,395.3 us | 107.08 us | 131.50 us | 23.37 |    0.53 |     - |     - |     - |      80 B |\r\n|              Run_For_List |   687.9 us |   3.39 us |   3.00 us |  2.96 |    0.05 |     - |     - |     - |         - |\r\n|          Run_ForEach_List | 2,978.8 us |  15.77 us |  13.98 us | 12.81 |    0.22 |     - |     - |     - |         - |\r\n```\r\n\r\nSo it seems to be worth switching to `List<string>` and perhaps also keeping the `for` loop for such a dramatic speedup.",
      "created_at": "2020-08-13T00:37:36Z",
      "updated_at": "2020-08-13T00:45:26Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> So it seems to be worth switching to List<string> \r\n\r\nWe can not change public API. ",
      "created_at": "2020-08-13T13:06:32Z",
      "updated_at": "2020-08-13T18:01:18Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "And it is not hot path - I don't see a value from the PR.",
      "created_at": "2020-08-13T13:11:29Z",
      "updated_at": "2020-08-13T13:11:29Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> We can not change public API.\r\n\r\nIt's on an internal class, no? If it's exposed publicly, then best not to change it. But this being on a native helper class, it feels like we can make that change.",
      "created_at": "2020-08-13T16:09:51Z",
      "updated_at": "2020-08-13T16:09:51Z"
    },
    {
      "author": "xtqqczze",
      "author_association": "CONTRIBUTOR",
      "body": "> \r\n> \r\n> And it is not hot path - I don't see a value from the PR.\r\n\r\nI had assumed this method was a public API so I ignored the fact there are no references to `ConnectToDataSource(StringCollection blgFileNames)` in our codebase. \r\n",
      "created_at": "2020-08-13T22:51:16Z",
      "updated_at": "2020-08-13T23:02:29Z"
    },
    {
      "author": "xtqqczze",
      "author_association": "CONTRIBUTOR",
      "body": "> \r\n> So it seems to be worth switching to `List<string>` and perhaps also keeping the `for` loop for such a dramatic speedup.\r\n\r\n<strike>@rjmholt Given that this method appears to be unused, the performance I wouldn't think changing to `List<string>` justifies the hypothetical performance increase.</strike>\r\n\r\nThanks for your help with benchmarking though, it is good to confirm `StringCollection` performance is much worse then generic `List<T>`.",
      "created_at": "2020-08-13T23:26:57Z",
      "updated_at": "2020-08-14T00:42:41Z"
    },
    {
      "author": "xtqqczze",
      "author_association": "CONTRIBUTOR",
      "body": "@rjmholt I have written #13431 to replace `StringCollection` with generic List in general",
      "created_at": "2020-08-14T00:43:48Z",
      "updated_at": "2020-08-14T00:51:48Z"
    },
    {
      "author": "xtqqczze",
      "author_association": "CONTRIBUTOR",
      "body": "> \r\n> \r\n> > We can not change public API.\r\n> \r\n> It's on an internal class, no? If it's exposed publicly, then best not to change it. But this being on a native helper class, it feels like we can make that change.\r\n\r\n@rjmholt Would there be value in a general PR to change method visibility from `public` to `internal` on `internal` class to avoid confusion like this? <ins>I have draft PR with these changes: https://github.com/PowerShell/PowerShell/pull/13436</ins>",
      "created_at": "2020-08-14T13:12:24Z",
      "updated_at": "2020-08-14T13:56:21Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> Would there be value in a general PR to change method visibility from public to internal on internal class to avoid confusion like this? I have draft PR with these changes: #13436\r\n\r\nGenerally I personally prefer `public` methods on `internal` and `private` classes; a class/object has a public API and private methods, `internal` implies a secondary API and muddies thinking around the cohesion and contract around a class. However, in PowerShell there is a consideration that once you have an object, any public member on it is visible to PowerShell (even if the class itself is internal), which drives a lot of the other classes that have `internal` members on everything.",
      "created_at": "2020-08-14T15:54:35Z",
      "updated_at": "2020-08-14T15:54:35Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as Review Needed because it has been there has not been any activity for **7 days**.\nMaintainer, please provide feedback and/or mark it as `Waiting on Author`",
      "created_at": "2020-08-25T02:00:15Z",
      "updated_at": "2020-08-25T02:00:15Z"
    },
    {
      "author": "xtqqczze",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov Do you any suggestions for CodeFactor issues here?",
      "created_at": "2020-08-28T20:34:24Z",
      "updated_at": "2020-08-28T20:34:24Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@xtqqczze I like the formatting. Please ignore these CodeFactor warnings.",
      "created_at": "2020-08-29T07:01:43Z",
      "updated_at": "2020-08-29T07:01:43Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "Do we have a test for this code path? Want to make sure we would identify a regression",
      "created_at": "2020-08-29T19:09:19Z",
      "updated_at": "2020-08-29T19:09:19Z"
    },
    {
      "author": "xtqqczze",
      "author_association": "CONTRIBUTOR",
      "body": "There appear to be no references to `ConnectToDataSource(StringCollection blgFileNames)`. No tests either.\r\n\r\n",
      "created_at": "2020-08-29T21:56:32Z",
      "updated_at": "2020-08-29T21:56:32Z"
    },
    {
      "author": "xtqqczze",
      "author_association": "CONTRIBUTOR",
      "body": "@rjmholt Maybe we could add tests and refactor double null-terminated string generation code to a `NativeUtils` class. We could then reuse the code in `Microsoft.PowerShell.Commands.Management/commands/management/Service.cs`",
      "created_at": "2020-08-29T22:04:56Z",
      "updated_at": "2020-08-29T22:04:56Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as Review Needed because it has been there has not been any activity for **7 days**.\nMaintainer, please provide feedback and/or mark it as `Waiting on Author`",
      "created_at": "2020-09-06T02:00:15Z",
      "updated_at": "2020-09-06T02:00:15Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@xtqqczze Please resolve merge conflicts.",
      "created_at": "2021-01-09T07:33:40Z",
      "updated_at": "2021-01-09T07:33:40Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@xtqqczze Please resolve merge conflicts.",
      "created_at": "2021-01-10T13:07:20Z",
      "updated_at": "2021-01-10T13:07:20Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as Review Needed because it has been there has not been any activity for **7 days**.\nMaintainer, please provide feedback and/or mark it as `Waiting on Author`",
      "created_at": "2021-01-17T14:00:06Z",
      "updated_at": "2021-01-17T14:00:06Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "The PdhHelper.cs is not in the compile so we should close the PR.",
      "created_at": "2021-06-28T03:26:54Z",
      "updated_at": "2021-06-28T03:26:54Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> The PdhHelper.cs is not in the compile so we should close the PR.\r\n\r\nAssuming this is true, I'll close the PR. Let me know if there's something else we should be doing here.",
      "created_at": "2021-06-28T17:58:06Z",
      "updated_at": "2021-06-28T17:58:06Z"
    }
  ],
  "created_at": "2020-08-12T23:08:59Z",
  "number": 13425,
  "state": "closed",
  "title": "Use string.Create instead of concatenation in PdhHelper",
  "updated_at": "2021-06-28T17:58:06Z"
}