{
  "_url": "https://github.com/PowerShell/PowerShell/issues/12209",
  "author": "TobiasPSP",
  "body": "# Suggestion:\r\nI suggest PowerShell includes built-in attributes for self-learning autocompletion and safely storing credentials in personal hint lists.\r\n\r\n## Proposed technical implementation details\r\nA detailed proposal on technical implementation for self-learning autocompletion attributes can be found [here](https://powershell.one/powershell-internals/attributes/custom-attributes#self-learning-argument-completion).\r\nA detailed proposal on technical implementation for self-learning safe credential store attributes can be found [here](https://powershell.one/powershell-internals/attributes/custom-attributes#safe-secrets-store-for-parameters).\r\n\r\n## Source Code Example\r\nPlease see the mentioned articles for a deep technical discussion and detailed documentation of used techniques.\r\n\r\n### Example for self-learning attributes:\r\n```powershell\r\n# derive from ArgumentTransformationAttribute:\r\nclass AutoLearnAttribute : System.Management.Automation.ArgumentTransformationAttribute\r\n{\r\n    # define path to store hint lists\r\n    [string]$Path = \"$env:temp\\hints\"\r\n\r\n    # define id to manage multiple hint lists:\r\n    [string]$Id = 'default'\r\n\r\n    # define prefix character used to delete the hint list\r\n    [char]$ClearKey = '!'\r\n\r\n    # define parameterless constructor:\r\n    AutoLearnAttribute() : base()\r\n    {}\r\n\r\n    # define constructor with parameter for id:\r\n    AutoLearnAttribute([string]$Id) : base()\r\n    {\r\n        $this.Id = $Id\r\n    }\r\n    \r\n    # Transform() is called whenever there is a variable or parameter assignment, and returns the value\r\n    # that is actually assigned:\r\n    [object] Transform([System.Management.Automation.EngineIntrinsics]$engineIntrinsics, [object] $inputData)\r\n    {\r\n        # make sure the folder with hints exists\r\n        $exists = Test-Path -Path $this.Path\r\n        if (!$exists) { $null = New-Item -Path $this.Path -ItemType Directory }\r\n\r\n        # create filename for hint list\r\n        $filename = '{0}.hint' -f $this.Id\r\n        $hintPath = Join-Path -Path $this.Path -ChildPath $filename\r\n        \r\n        # use a hashtable to keep hint list\r\n        $hints = @{}\r\n\r\n        # read hint list if it exists\r\n        $exists = Test-Path -Path $hintPath\r\n        if ($exists) \r\n        {\r\n            Get-Content -Path $hintPath -Encoding Default |\r\n              # remove leading and trailing blanks\r\n              ForEach-Object { $_.Trim() } |\r\n              # remove empty lines\r\n              Where-Object { ![string]::IsNullOrEmpty($_) } |\r\n              # add to hashtable\r\n              ForEach-Object {\r\n                # value is not used, set it to $true:\r\n                $hints[$_] = $true\r\n              }\r\n        }\r\n\r\n        # does the user input start with the clearing key?\r\n        if ($inputData.StartsWith($this.ClearKey))\r\n        {\r\n            # remove the prefix:\r\n            $inputData = $inputData.SubString(1)\r\n\r\n            # clear the hint list:\r\n            $hints.Clear()\r\n        }\r\n\r\n        # add new value to hint list\r\n        if(![string]::IsNullOrWhiteSpace($inputData))\r\n        {\r\n            $hints[$inputData] = $true\r\n        }\r\n        # save hints list\r\n        $hints.Keys | Sort-Object | Set-Content -Path $hintPath -Encoding Default \r\n        \r\n        # return the user input (if there was a clearing key at its start,\r\n        # it is now stripped):\r\n        return $inputData\r\n    }\r\n}\r\n\r\nclass AutoCompleteAttribute : System.Management.Automation.ArgumentCompleterAttribute\r\n{\r\n    # define path to store hint lists\r\n    [string]$Path = \"$env:temp\\hints\"\r\n\r\n    # define id to manage multiple hint lists:\r\n    [string]$Id = 'default'\r\n  \r\n    # define parameterless constructor:\r\n    AutoCompleteAttribute() : base([AutoCompleteAttribute]::_createScriptBlock($this)) \r\n    {}\r\n\r\n    # define constructor with parameter for id:\r\n    AutoCompleteAttribute([string]$Id) : base([AutoCompleteAttribute]::_createScriptBlock($this))\r\n    {\r\n        $this.Id = $Id\r\n    }\r\n\r\n    # create a static helper method that creates the scriptblock that the base constructor needs\r\n    # this is necessary to be able to access the argument(s) submitted to the constructor\r\n    # the method needs a reference to the object instance to (later) access its optional parameters:\r\n    hidden static [ScriptBlock] _createScriptBlock([AutoCompleteAttribute] $instance)\r\n    {\r\n    $scriptblock = {\r\n        # receive information about current state:\r\n        param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)\r\n   \r\n        # create filename for hint list\r\n        $filename = '{0}.hint' -f $instance.Id\r\n        $hintPath = Join-Path -Path $instance.Path -ChildPath $filename\r\n        \r\n        # use a hashtable to keep hint list\r\n        $hints = @{}\r\n\r\n        # read hint list if it exists\r\n        $exists = Test-Path -Path $hintPath\r\n        if ($exists) \r\n        {\r\n            Get-Content -Path $hintPath -Encoding Default |\r\n              # remove leading and trailing blanks\r\n              ForEach-Object { $_.Trim() } |\r\n              # remove empty lines\r\n              Where-Object { ![string]::IsNullOrEmpty($_) } |\r\n              # filter completion items based on existing text:\r\n              Where-Object { $_.LogName -like \"$wordToComplete*\" } | \r\n              # create argument completion results\r\n              Foreach-Object { \r\n                  [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)\r\n              }\r\n        }\r\n    }.GetNewClosure()\r\n    return $scriptblock\r\n    }\r\n}\r\n\r\n# example use case:\r\nfunction Connect-MyServer\r\n{\r\n    param\r\n    (\r\n        [string]\r\n        [Parameter(Mandatory)]\r\n        # auto-learn user names to user.hint\r\n        [AutoLearn('user')]\r\n        # auto-complete user names from user.hint\r\n        [AutoComplete('user')]\r\n        $UserName,\r\n\r\n        [string]\r\n        [Parameter(Mandatory)]\r\n        # auto-learn computer names to server.hint\r\n        [AutoLearn('server')]\r\n        # auto-complete computer names from server.hint\r\n        [AutoComplete('server')]\r\n        $ComputerName\r\n    )\r\n\r\n    \"hello $Username, connecting you to $ComputerName\"\r\n}\r\n```\r\n\r\n### Code for self-learning safe credential store and auto completion:\r\n```powershell\r\n# attribute [CacheCredential()] transforms strings to creds and caches values:\r\nclass CacheCredentialAttribute : System.Management.Automation.ArgumentTransformationAttribute\r\n{\r\n    [string]$Path = \"$env:temp\\hints\"\r\n    [string]$Id = 'default'\r\n    [char]$ClearKey = '!'\r\n\r\n    CacheCredentialAttribute() : base()\r\n    {}\r\n\r\n    CacheCredentialAttribute([string]$Id) : base()\r\n    {\r\n        $this.Id = $Id\r\n    }\r\n    \r\n    [object] Transform([System.Management.Automation.EngineIntrinsics]$engineIntrinsics, [object] $inputData)\r\n    {\r\n        # make sure the folder with hints exists\r\n        $exists = Test-Path -Path $this.Path\r\n        if (!$exists) { $null = New-Item -Path $this.Path -ItemType Directory }\r\n\r\n        # create filename for hint list\r\n        $filename = '{0}.xmlhint' -f $this.Id\r\n        $hintPath = Join-Path -Path $this.Path -ChildPath $filename\r\n        \r\n        # use a hashtable to keep hint list\r\n        $hints = @{}\r\n\r\n        # read hint list if it exists\r\n        $exists = Test-Path -Path $hintPath\r\n        if ($exists) \r\n        {\r\n            # hint list is xml data\r\n            # it is a serialized hashtable and can be \r\n            # deserialized via Import-CliXml if it exists\r\n            # result is a hashtable:\r\n            [System.Collections.Hashtable]$hints = Import-Clixml -Path $hintPath\r\n        }\r\n\r\n        # if the argument is a string...\r\n        if ($inputData -is [string])\r\n        {\r\n            # does username start with \"!\"?\r\n            [bool]$promptAlways = $inputData.StartsWith($this.ClearKey)\r\n\r\n            # if not,...\r\n            if (!$promptAlways)\r\n            {\r\n                # ...check to see if the username has been used before,\r\n                # and re-use its credential (no need to enter password again)\r\n                if ($hints.ContainsKey($inputData))\r\n                {\r\n                    return $hints[$inputData]\r\n                }\r\n            }\r\n            else\r\n            {\r\n                # ...else, remove the \"!\" at the beginning and prompt\r\n                # again for the password (this way, passwords can be updated)\r\n                $inputData = $inputData.SubString(1)\r\n                # delete the cached credentials\r\n                $hints.Clear()\r\n            }\r\n            # ask for a credential:\r\n            $cred = $engineIntrinsics.Host.UI.PromptForCredential(\"Enter password\", \"Please enter user account and password\", $inputData, \"\")\r\n            # add the credential to the hashtable:\r\n            $hints[$cred.UserName] = $cred\r\n            # update the hashtable and write it to file\r\n            # passwords are automatically safely encrypted:\r\n            $hints | Export-Clixml -Path $hintPath\r\n            # return the credential:\r\n            return $cred\r\n        }\r\n        # if a credential was submitted...\r\n        elseif ($inputData -is [PSCredential])\r\n        {\r\n            # save it to the hashtable:\r\n            $hints[$inputData.UserName] = $inputData\r\n            # update the hashtable and write it to file:\r\n            $hints | Export-Clixml -Path $hintPath\r\n            # return the credential:\r\n            return $inputData\r\n        }\r\n        throw [System.InvalidOperationException]::new('Unexpected error.')\r\n    }\r\n}\r\n\r\n\r\n# attribute [SuggestCredential()] suggests cached credentials\r\nclass SuggestCredentialAttribute : System.Management.Automation.ArgumentCompleterAttribute\r\n{\r\n    [string]$Path = \"$env:temp\\hints\"\r\n    [string]$Id = 'default'\r\n  \r\n    SuggestCredentialAttribute() : base([SuggestCredentialAttribute]::_createScriptBlock($this)) \r\n    {}\r\n\r\n    SuggestCredentialAttribute([string]$Id) : base([SuggestCredentialAttribute]::_createScriptBlock($this))\r\n    {\r\n        $this.Id = $Id\r\n    }\r\n\r\n    hidden static [ScriptBlock] _createScriptBlock([SuggestCredentialAttribute] $instance)\r\n    {\r\n    $scriptblock = {\r\n        param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)\r\n   \r\n        $filename = '{0}.xmlhint' -f $instance.Id\r\n        $hintPath = Join-Path -Path $instance.Path -ChildPath $filename\r\n        \r\n        $exists = Test-Path -Path $hintPath\r\n        if ($exists) \r\n        {\r\n            # read serialized hint hashtable if it exists...\r\n            [System.Collections.Hashtable]$hints = Import-Clixml -Path $hintPath\r\n\r\n            # hint the sorted list of cached user names...\r\n            $hints.Keys |\r\n              Where-Object { $_ } |\r\n              # ...that still match the current user input:\r\n              Where-Object { $_.LogName -like \"$wordToComplete*\" } | \r\n              Sort-Object |\r\n              # return completion results:\r\n              Foreach-Object { \r\n                  [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)\r\n              }\r\n        }\r\n    }.GetNewClosure()\r\n    return $scriptblock\r\n    }\r\n}\r\n\r\n\r\n# function uses a parameter -Credential that accepts both\r\n# strings (username) and credentials. If the user submits a\r\n# string, a cached credential is returned if available.\r\n# only if there is no cached credential yet, the user gets\r\n# prompted for a password, and the string is transformed\r\n# into a credential.\r\n# when the user prefixes a username with \"!\", all cached\r\n# credentials are deleted:\r\nfunction New-Login\r\n{\r\n    param\r\n    (\r\n        [PSCredential]\r\n        [Parameter(Mandatory)]\r\n        # cache credentials to username.xmlhint\r\n        [CacheCredential('username')]\r\n        # auto-complete user names from username.xmlhint\r\n        [SuggestCredential('username')]\r\n        $Credential\r\n    )\r\n\r\n    $username = $Credential.UserName\r\n    \"hello $username!\"\r\n}\r\n```\r\n\r\n# Remarks\r\nThe suggested implementation uses two separate attributes, derived from transformation attribute and autocompleter attribute. I suggest PowerShell core code is changed in a way that ONE attribute is added that takes care of both the storage (caching) AND triggering argument completion.\r\n\r\nIt would be wise IMHO to adjust the PowerShell core code in a way that the *type* of variable/parameter is considered that the attribute is applied to, and if a variable/parameter is using the type *PSCredential*, the attribute automatically uses the approach outlined for safe credential store, else the approach for plain text. \r\n\r\nThis way, we would only have to add ONE single attribute, i.e. [CacheValue()] that takes care of everything: caching parameter values, optionally when parameter is of type *PSCredential* transforming string to credential and safely caching credential, plus general argument completion for parameters. \r\n\r\nThis would yield a super easy-to-use attribute and provide a tremendous usability enhancement for all PowerShell function parameters.\r\n\r\nTo add extra safety to the credential store, I suggest we do not serialize credentials to xml (leaving user names exposed) but instead serialize our own hashtable where the user name is also stored as a secure string. This way, attackers would not be able to harvest user names.",
  "closed_at": null,
  "comments": [
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "\ud83e\udd14 this is quite a fun idea! It bears some similarity to what @daxian-dbw was working on with fish-style completions in PSReadLine. Perhaps it could go in as a more generalised functionality improvement with PSReadLine as well, rather than requiring opt-in via attribute? ",
      "created_at": "2020-03-26T12:16:18Z",
      "updated_at": "2020-03-26T12:16:18Z"
    },
    {
      "author": "StevenBucher98",
      "author_association": "COLLABORATOR",
      "body": "Really cool suggestion! I want to point out that we recently created documentation that helps outline the creation process for predictor modules! it can also viewed [here](https://docs.microsoft.com/en-us/powershell/scripting/dev-cross-plat/create-cmdline-predictor?view=powershell-7.2). I also know [Az.Tools.Predictor](https://www.powershellgallery.com/packages/Az.Tools.Predictor/1.0.1) does something similar in order to fill in location/subscription/resource group for the predicted values, it is all done locally too. ",
      "created_at": "2022-06-06T18:39:20Z",
      "updated_at": "2022-06-06T18:39:20Z"
    }
  ],
  "created_at": "2020-03-26T06:51:02Z",
  "number": 12209,
  "state": "open",
  "title": "Feature Request: Adding Attributes for Self-Learning Autocompletion",
  "updated_at": "2022-06-06T18:41:11Z"
}