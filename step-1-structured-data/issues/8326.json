{
  "_url": "https://github.com/PowerShell/PowerShell/issues/8326",
  "author": "SteveL-MSFT",
  "body": "change ellipsis when truncating to single unicode character\r\nreset console output if previous column contains ESC\r\nupdate existing format-table tests\r\n\r\n## PR Summary\r\n\r\nIf content included a VT100 ESC sequence (like changing color), this affected all output after that cell in the table.  Fix is to detect that a cell contained ESC and reset the console after it.  Also, change the 3 character ellipsis `...` to use the single unicode character `\u2026` so that more text is available.\r\n\r\nFix https://github.com/PowerShell/PowerShell/issues/7767\r\n\r\n## PR Checklist\r\n\r\n- [x] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [x] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] [Change is not breaking](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)\r\n- [x] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` to the beginning of the title and remove the prefix when the PR is ready.\r\n- **User-facing changes**\r\n    - [x] Not Applicable\r\n    - **OR**\r\n    - [ ] User-facing [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [ ] Issue filed - Issue link:\r\n- **Testing - New and feature**\r\n    - [ ] Not Applicable or can only be tested interactively\r\n    - **OR**\r\n    - [x] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n        - [x] [Add `[feature]` if the change is significant or affects feature tests](https://github.com/PowerShell/PowerShell/blob/master/docs/testing-guidelines/testing-guidelines.md#requesting-additional-tests-for-a-pr)\r\n",
  "closed_at": "2018-12-11T21:56:47Z",
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@SteveL-MSFT Please look CodeFactor issues.",
      "created_at": "2018-11-21T05:29:42Z",
      "updated_at": "2018-11-21T05:29:42Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@SteveL-MSFT After thinking about this change, I think that the original issue leads us away. It comes from that we must take care of escape sequences. But why should we do this if we have not done it before? I think this is a misconception that comes from the fact that Microsoft now invests a lot in ConTTY. I believe that this investments is aimed, among other things, at ensuring compatibility with Unix vty and _existing_ software. And this does not mean that modern software should work according to protocols of 40 years old. \r\nI guess this is a wrong design.\r\nIf we fill our scripts with these escape sequences, what will we do with them if we will work with other consoles like Web? Now we are condemning ourselves to the development of additional intermediate non-standard adapters. But if we are forced to create adapters for different terminals, then it is better to do this through the standard abstract API, which will eliminate the intermediate layers, which are the source of numerous superimposed errors. And current Issue and PR clearly show this.\r\nIn fact, we already have this api. It allows us to colored output both to a Windows console and to an Unix console. We should only improve this api. \r\nThis also means that we must treat escape sequences literally. If we need something like that for formatting, then we should use PowerShell standard language features which will work _everywhere_ (with any console). We already have interpolated strings and we could enhance them to support output formatting.\r\nSuch design would allow PowerShell Core to cling to any console with minimal code addition without the imposition of transforming layers.\r\nI think your team should discuss this thoroughly.",
      "created_at": "2018-11-24T16:23:58Z",
      "updated_at": "2018-11-24T16:25:18Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@iSazonov I believe VT100 is already the de facto and de jure standard (at least in terms of the console).  Cloud Shell and the integrated terminal in VSCode are javascript based and support parsing VT100 escape codes already.  I would agree that we haven't thought through how this will work with something like `ConvertTo-Html`, but I would imagine ideally it would be some translation of VT100 to HTML.  \r\n\r\nEven if we support a PowerShell dialect for the equivalent of VT100 escape sequences, we would still need to handle VT100 escape sequences that could be emitted by any tool that runs in the console.",
      "created_at": "2018-11-25T03:10:17Z",
      "updated_at": "2018-11-25T03:10:17Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": ">I believe VT100 is already the de facto and de jure standard (at least in terms of the console). Cloud Shell and the integrated terminal in VSCode are javascript based and support parsing VT100 escape codes already.\r\n\r\nI wrote about this above:  I believe that this investments is aimed, among other things, at ensuring compatibility with Unix vty and _existing_ software. And this does not mean that modern software should work according to protocols of 40 years old.\r\nI guess this is a wrong design.\r\nAnd I can continue that PowerShell is high level language and have many _magic_ abstractions, for output formatting too.\r\nInitially, PowerShell _was not based_ on VT100. If the output should be based on VT100, then we definitely need to accept this as an RFC. And this is definitely a fundamental decision and fundamental change.\r\n\r\nI consider VT100 as a low-level assembler. It is not user-friendly.  Nobody uses Intel assembler - developers prefer absractions of high level languages. Why? Because they need to accomplish their goal quickly and simply. I\u2019m sure that PowerShell should also provide sufficient abstractions so that users _don\u2019t think_ about VT100 escape sequences. PowerShell style is using ` Write-Host -BackgroundColor Blue` but not using `Write-Host 0x1A ...`. _We should consider VT100 as one of the options for implementing high-level abstractions._\r\nWe should not lower to the lower level in the PowerShell language itself. The use of abstractions allows us to be comfortable, fast and reliable with any consoles. As PowerShell engine developer we are free to use vty or Windows console api (why we'd need reject the api if it allows us to make great-look a progress bar? and it is more multi-thread friendly). We can switch free to ncurses or Web (not only HTML, we can use any api over https!). At the same time, users should use simple and powerful abstractions to easily write scripts that work on any platform and with any terminal.\r\nAnother thing that worries me is that with the allowing of escapes, we bind to the vty but will not we format the table cells on the Web? The right design would be to delegate this to the conhost implementation. Escapes is and should be implementation details. So I am sure that these escapes are not what should be in PowerShell _language_.\r\n",
      "created_at": "2018-11-25T12:53:20Z",
      "updated_at": "2018-11-25T12:53:20Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Continuing to think this over, I recall our implementation of the Markdown. It is tied to vty. Again this is too much of a limitation.\r\nI suppose all types of rendering should be abstracted in engine and implemented in a conhost so that the engine works consistently with any console and we could switch on the fly.\r\nI am increasingly convinced that we should invest in an engine abstraction of a markup language. We don't even have to invent anything. This might be an RFC for a subset of HTML (to support format-table, Markdown and so on).\r\nIn this case, the output will be as simple as\r\n```powershell\r\nWrite-Host -HTML \"HTMLstring\" -Markdown \"markdownstring\" -SimpleString \"simplestring\"\r\n\"string\" | Format-Table [-HTML | -Markdown]\r\n```\r\nwhere default parameter is defined in current console type.\r\n",
      "created_at": "2018-11-26T03:55:32Z",
      "updated_at": "2018-11-26T03:55:32Z"
    },
    {
      "author": "DHowett-MSFT",
      "author_association": "NONE",
      "body": "> \r\n> \r\n> > I believe VT100 is already the de facto and de jure standard (at least in terms of the console). Cloud Shell and the integrated terminal in VSCode are javascript based and support parsing VT100 escape codes already.\r\n> \r\n> I wrote about this above: I believe that this investments is aimed, among other things, at ensuring compatibility with Unix vty and _existing_ software. And this does not mean that modern software should work according to protocols of 40 years old.\r\n\r\nUnfortunately, you're only half right on this point. We invested in ConPTY as a way of ensuring compatibility with existing _Windows_ software. We realized early on in Windows 10 that _everybody_ standardized on VT, and doubled down on supporting it.\r\n\r\nConPTY is an attempt to:\r\n* allow Windows applications to host Windows consoles, but exchange VT (and therefore be \"terminal emulators\")\r\n* allow applications using the ~73 Windows Console APIs to be run and have the effects of those APIs translated _into_ VT.\r\n\r\nFor the issue at hand, it seems like table formatting should be entirely Host-driven. In the case of the console, only the console host knows how many cells each character takes up, which escape sequences should count against the table cell width (for colors, none; for cursor movement, who knows?), and how to properly terminate a dangling sequence.\r\n\r\nUnfortunately, that may not be how PowerShell was designed.",
      "created_at": "2018-11-26T22:27:39Z",
      "updated_at": "2018-11-26T22:27:39Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@DHowett-MSFT Thanks for feedback! All you are talking about is _a low level_ of work with a console. This is a standard because we can hardly think of something simpler for this low level. The issue is about _high level_ - why we are starting to expose the low level to PowerShell language level and user level: (1) why PowerShell users should thinking about escapes and use its? why the users should remember the escapes? (2) Do we know high level languages which explicitly exposes the escapes to users rejecting absractions?\r\n\r\n> Unfortunately, that may not be how PowerShell was designed.\r\n\r\nPowerShell is designed to expose users high level and magic things. Low level should stay on low level. In the case _an implementing of rendering_ is the low level, high level is PowerShell language abstractions (like `Write-Host -BackgroundColor Blue` and perhaps interpalated strings as I metioned above).\r\nCurrently PowerShell conhost class has already needed abstractions to works (1) on windows (buffered console API), (2)  on Unix (vty). So my thoughts is (1) use/enhance PowerShell conhost class abstractions, (2) move rendering implementations to console adapters.\r\n\r\nI assume that this problem comes from the fact that PowerShell mainly works with a simple console. In fact, it should work with any console and any remote protocol (as I mentioned above).\r\n",
      "created_at": "2018-11-27T09:01:43Z",
      "updated_at": "2018-11-27T09:01:43Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@iSazonov I think it's fine to think of VT100 as an implementation detail and not something we want to expose to users although they can freely use it.  We should have something higher level to make it easier for non-developers to leverage a subset of VT100 for formatting.  Perhaps something like \"`e{green}\" but this needs a RFC and some thought.  I don't think providing a higher level abstraction precludes the changes in this PR.",
      "created_at": "2018-11-30T03:07:33Z",
      "updated_at": "2018-11-30T03:07:33Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": ">Perhaps something like \"`e{green}\" but this needs a RFC and some thought.\r\n\r\nIt's low level again. Currently we have Markdown implementation based solely on escapes. Why? If we would have a universal api we could not use the escapes and get rendering on any \"console\".\r\n\r\n> I don't think providing a higher level abstraction precludes the changes in this PR.\r\n\r\nWe can look at it from the other side. _Nothing prevents users from using escapes now._ Users can even make their own cmdlet to display tables. But why should we complicate our rendering? I am increasingly confident that this is not justified.\r\nI think that this change just shows that we doom ourselves to an _infinite number of bugs_ if we don\u2019t say now that keeping escapes out of our redering is \"by-design\".\r\nIf we started to implement Markdown we could do the same for other markup languages (what about HTML or YAML?). This means that we need a common power abstract API to support this uniformly. (That we already partially have)\r\n\r\n> Perhaps something like \"`e{green}\"\r\n\r\nYeah, what I'm trying to say here is that the following is better:\r\n```powershell\r\necho [html]\"<a><bold>Hello world!<\\a>\"\r\n```\r\nthat should works with any target (VT, ghost, web...)",
      "created_at": "2018-11-30T03:44:42Z",
      "updated_at": "2018-11-30T03:46:26Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@iSazonov I think you should open a new issue to discuss that.  It seem you are proposing we should prevent people from embedding VT100 escape sequences which seems too strict to me.",
      "created_at": "2018-11-30T04:07:04Z",
      "updated_at": "2018-11-30T04:07:04Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> I think you should open a new issue to discuss that\r\n\r\nWill do.\r\n\r\n> It seem you are proposing we should prevent people from embedding VT100 escape sequences which seems too strict to me.\r\n\r\nI propose to keep our engine and formatting _implementation-detail-independent_ and move rendering implementation to conhost.",
      "created_at": "2018-11-30T04:16:44Z",
      "updated_at": "2018-11-30T04:16:44Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@iSazonov are you ok with taking this change?  We can continue the higher level discussion separate from this.",
      "created_at": "2018-12-05T20:10:53Z",
      "updated_at": "2018-12-05T20:10:53Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@SteveL-MSFT Sorry that I still have not opened a new discussion. Will do. As for this PR, as I said above, I do not agree that this should be because we will have to parse and process __each__ line before outputting it (not partially like in this PR)  that unnecessarily complicates the output formatting system and complicates the addition of support for other consoles. I propose to postpone it as it is not a security change.  I delegate this to your team.",
      "created_at": "2018-12-06T03:51:56Z",
      "updated_at": "2018-12-06T03:51:56Z"
    }
  ],
  "created_at": "2018-11-20T22:36:58Z",
  "number": 8326,
  "state": "closed",
  "title": "Reset output attributes if column had ESC char when using `Format-Table`; Replace \"...\" with unicode ellipsis",
  "updated_at": "2019-05-13T15:22:45Z"
}