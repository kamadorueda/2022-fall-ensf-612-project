{
  "_url": "https://github.com/PowerShell/PowerShell/issues/16376",
  "author": "atanasa",
  "body": "### Steps to reproduce\r\n\r\nI am trying to use the AES algorithm in GCM mode for code that works on PowerShell Core. When I try to use the AesGcm class on Mac OS, the pwsh process crashes.\r\n\r\n\r\nSteps to reproduce:\r\nRun the following script on Mac OS (PowerShell version 7.1.5):\r\n\r\n```powershell\r\n$aes2 = [System.Security.Cryptography.AesGcm]::new([byte[]]::new(32))\r\n```\r\n\r\n### Expected behavior\r\n`$aes2` to contain an object that implements AES-GCM (or if it is not supported on this platform - report an error - not crash the process)\r\n\r\n\r\n\r\n### Actual behavior\r\nThe PowerShell process was terminated.\r\n\r\n```console\r\nNo usable version of libssl was found\r\nzsh: abort      pwsh\r\n```\r\n\r\n\r\n### Error details\r\n\r\n_No response_\r\n\r\n### Environment data\r\n\r\n```powershell\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.1.5\r\nPSEdition                      Core\r\nGitCommitId                    7.1.5\r\nOS                             Darwin 21.1.0 Darwin Kernel Version 21.1.0: Wed\u2026\r\nPlatform                       Unix\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n\r\nI have tried installing PowerShell using the direct download as well as homebrew - that does not seem to make a difference.\r\n\r\nI have tried to install OpenSSL, but either I didn\u2019t do it correctly or it does not have an effect on PowerShell.\r\n\r\nI have tested this on Mac OS version 10, 11, 12 (Intel-virtualised) - does not seem to make a difference.\u2028\r\n\r\nI have tested the `[System.Security.Cryptography.ECDiffieHellman]` type and that works as expected (which according to the [.Net documentation](https://docs.microsoft.com/en-us/dotnet/standard/security/cross-platform-cryptography) also require OpenSSL as far as I understand it).\r\n\r\n\r\n### Visuals\r\n\r\n_No response_",
  "closed_at": "2022-01-14T04:00:45Z",
  "comments": [
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "I'm not sure this is actually a problem in PowerShell but rather .NET and even then it's most likely a problem in your environment and how your mac is set up. All this code is handled in the dotnet/runtime repository and `libssl` is looked at dynamically at runtime and if nothing is found to match then it fails with the error you see. You stated you are running on \"Intel virtualised\", is this macOS running on arm64 and `pwsh` is running as under Rosetta 2 as `x86_64`? If so you need to make sure that you have either a universal or `x86_64` compatible OpenSSL version installed so that `pwsh` can load them. If using `pwsh` 7.2.0 or newer you can use the native `arm64` exe instead which requires either a universal or `arm64` OpenSSL library installed.\r\n\r\nYou can have a look at the logic .NET uses to find OpenSSL at https://github.com/dotnet/runtime/blob/2ccf1ab424f7f0aa01d12d238772e2795073c40f/src/libraries/Native/Unix/System.Security.Cryptography.Native/opensslshim.c#L54-L121 but essentially it will run `dlopen` using various version standards of `libssl` i.e. `libssl.3.dylib`, `libssl.1.1.dylib`, `libssl.1.0.2.dylib`, etc. `dlopen` has many ways to control the lookup behaviour but in your case there is not valid OpenSSL library found hence the error.\r\n\r\nSome ways you can control the behaviour of `dlopen`\r\n\r\n* Set one of the env vars `LD_LIBRARY_PATH`, `DYLD_LIBRARY_PATH`, `DYLD_FALLBACK_LIBRARY_PATH`\r\n  * These are a list of paths (separated by `:`) of where `dlopen` should look when trying to load a library\r\n  * These must be set before starting `pwsh` and cannot be set in the `pwsh` process itself\r\n  * Propbably best to avoid `DYLD_FALLBACK_LIBRARY_PATH` if you can as that has a default variable of `$HOME/lib:/usr/local/lib:/usr/lib`\r\n* Copy the `libssl` and `libcrypto` dylibs to `/usr/lib`, `/usr/local/lib`\r\n  * This is not recommended if you don't know what you are doing\r\n  * It's especially dangerous if you are dealing with macOS on `arm64` as the library should really be universal\r\n\r\nMore information on `dlopen` and it's behaviour on macOS can be found at https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dlopen.3.html.\r\n\r\n> I have tested the [System.Security.Cryptography.ECDiffieHellman] type and that works as expected (which according to the .Net documentation also require OpenSSL as far as I understand it).\r\n\r\nAccording to that same link it's only the AES ciphers that don't have support from the system libraries and use OpenSSL\r\n\r\n> On macOS, the system libraries don't support AES-CCM or AES-GCM for third-party code, so the AesCcm and AesGcm classes use OpenSSL for support\r\n\r\n> .NET exposes types to allow programs to interoperate with the OS libraries that .NET uses\r\n\r\n> * On macOS, ECDiffieHellmanOpenSsl works if OpenSSL is installed and an appropriate libcrypto dylib can be found via dynamic library loading. If an appropriate library can't be found, exceptions will be thrown.\r\n\r\nThis would explain why `ECDiffieHellman` works as it doesn't try and load OpenSSL. I would expect `ECDiffieHellmanOpenSsl` to fail in the same way the AES examples do as well as that always uses OpenSSL instead of the system libraries.\n\n<blockquote><img src=\"https://opengraph.githubassets.com/3cf40e1883a7b8ed142aefa14fba8d457a8e59720f8116a79ae430bad7298f2c/dotnet/runtime\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/dotnet/runtime\">runtime/opensslshim.c at 2ccf1ab424f7f0aa01d12d238772e2795073c40f \u00b7 dotnet/runtime</a></strong></div><div>.NET is a cross-platform runtime for cloud, mobile, desktop, and IoT apps. - runtime/opensslshim.c at 2ccf1ab424f7f0aa01d12d238772e2795073c40f \u00b7 dotnet/runtime</div></blockquote>\n<blockquote><div><strong><a href=\"https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dlopen.3.html\">Mac OS X\n Manual Page For dlopen(3)</a></strong></div><div>HTML versions of the iOS man pages.</div></blockquote>",
      "created_at": "2021-11-08T21:47:57Z",
      "updated_at": "2021-11-08T21:47:59Z"
    },
    {
      "author": "atanasa",
      "author_association": "NONE",
      "body": "This was tested on a virtual machine running the Intel architecture and there is no translation or anything involved - that is, it is not running on ARM.\r\nI suspected that it might be related to .Net, but since I don't put out an executable but a module, I can't have an installer to meet the requirements of .Net. As such I believe it is the PowerShell installer that need to meet the .Net Core requirements. \r\n\r\nTo me it looks like there might be some requirement missing or if PowerShell is patching the .Net in some way (e.g. patching certain dylibs within .Net) , it might have missed a few.\r\n\r\nSince I am not the only author running code in the PowerShell process, I can't mess with the dylib loading. Thus the solution with redirecting a library (if it is viable), should be done by the PowerShell process.\r\n\r\nTo sum it up - I believe if a dependency is the cause, that the PowerShell installer/process should meet that requirement and not module authors.",
      "created_at": "2021-11-09T10:02:32Z",
      "updated_at": "2021-11-09T10:02:32Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "> To me it looks like there might be some requirement missing or if PowerShell is patching the .Net in some way (e.g. patching certain dylibs within .Net) , it might have missed a few.\r\n\r\nIt doesn\u2019t and this is part of the system configuration rather than something PowerShell would do.\r\n\r\n> Thus the solution with redirecting a library (if it is viable), should be done by the PowerShell process.\r\n\r\nPersonally I disagree, it\u2019s up to the whoever sets up the environment to ensure that it meets the requirements (see my next comment for more).\r\n\r\n> I believe if a dependency is the cause, that the PowerShell installer/process should meet that requirement and not module authors.\r\n\r\nWhile I agree with this statement in general the code is what is calling the .NET functionality that requires OpenSSL to run. From what I can gather in your original post you have code that is using the .NET AES functionality which is where the dependency lies. It\u2019s not PowerShell that requires this but what the code that was written requires. You could write the code in C# with no dependency on PowerShell itself and it will still have the same problem.\r\n\r\nGranted this is a slippery slope but given the complex landscape of OpenSSL macOS I don\u2019t really believe PowerShell can 1. solve this universally and 2. is where this problem should be solved. The problem with point 1 is what tool should be used to install OpenSSL, should it be brew, port, a static lib. All have their own set of caveats and no one solution will solve this entirely.\r\n\r\nI\u2019m just one person with my own opinion and it will be up to the working group who picks this up to comment on it further.",
      "created_at": "2021-11-09T11:07:29Z",
      "updated_at": "2021-11-09T11:07:29Z"
    },
    {
      "author": "atanasa",
      "author_association": "NONE",
      "body": "If I'm writing an application with C# - then I am the master of its deployment, installation etc.\r\nWhen I'm writing a PowerShell binary module, I am limited to what a module package can do - and as far as I know a package cannot install additional native software to system folders.\r\nIn terms of writing PowerShell binary modules, I believe that the contract with PowerShell is that it provides the .Net Core libraries out of the box and all of those should work. If there is something the installer can't do, there should be additional documentation as part of the installation guide for Mac OS (as it was the case for early 6.0) that explains to the user how to set it up.",
      "created_at": "2021-11-09T11:20:23Z",
      "updated_at": "2021-11-09T11:20:23Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "The documentation about [\"Installing PowerShell on macOS\"](https://docs.microsoft.com/powershell/scripting/install/installing-powershell-on-macos) states that:\r\n> After installing PowerShell, you should install OpenSSL. OpenSSL is needed for PowerShell WSMan remoting.\r\n\r\nThis is a required action to be taken by a user when installing PowerShell on macOS. Also, it gives the instructions on how to install `OpenSSL` on macOS:\r\nhttps://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-macos?view=powershell-7.2#installing-dependencies.\r\n\r\nSo, I think this should be by-design, unless it continues to crash with the same error after installing OpenSSL following the instructions. Then that probably means the doc needs to be updated.",
      "created_at": "2021-11-11T22:24:54Z",
      "updated_at": "2021-11-11T22:28:41Z"
    },
    {
      "author": "JamesWTruher",
      "author_association": "MEMBER",
      "body": "\r\n\r\n> If I'm writing an application with C# - then I am the master of its deployment, installation etc. When I'm writing a PowerShell binary module, I am limited to what a module package can do - and as far as I know a package cannot install additional native software to system folders. In terms of writing PowerShell binary modules, I believe that the contract with PowerShell is that it provides the .Net Core libraries out of the box and all of those should work. If there is something the installer can't do, there should be additional documentation as part of the installation guide for Mac OS (as it was the case for early 6.0) that explains to the user how to set it up.\r\n\r\nin this case you _are_ writing an application in c#. If there was a cmdlet which returned this, it would include the needed dependencies (since they would be resolved in order to compile). However, you've plucked an API and want PS to provide the resolution, which is certainly not scalable (and not reasonable imo).\r\n",
      "created_at": "2021-11-11T22:38:53Z",
      "updated_at": "2021-11-11T22:38:53Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This issue has been marked as \"Waiting on Author\" and has not had any activity for **7 day**. It has been closed for housekeeping purposes.",
      "created_at": "2022-01-14T04:00:44Z",
      "updated_at": "2022-01-14T04:00:44Z"
    }
  ],
  "created_at": "2021-11-05T13:21:58Z",
  "number": 16376,
  "state": "closed",
  "title": "Using AES-GCM crashes the PowerShell process on Mac OS",
  "updated_at": "2022-01-14T04:00:45Z"
}