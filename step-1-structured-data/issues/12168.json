{
  "_url": "https://github.com/PowerShell/PowerShell/issues/12168",
  "author": "krishnayalavarthi",
  "body": "<!--\r\n\r\nFor Windows PowerShell 5.1 issues, suggestions, or feature requests please use the following link instead:\r\nWindows PowerShell [UserVoice](https://windowsserver.uservoice.com/forums/301869-powershell)\r\n\r\nThis repository is **ONLY** for PowerShell Core 6 and PowerShell 7+ issues.\r\n\r\n- Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\r\n- Search the existing issues.\r\n- Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\r\n- Refer to the [known issues](https://docs.microsoft.com/powershell/scripting/whats-new/known-issues-ps6?view=powershell-6).\r\n\r\n-->\r\n\r\n# Steps to reproduce\r\n\r\n```powershell\r\n$sess = New-PSSession -ComputerName localhost\r\nCopy-Item -Path E:\\test.txt -Destination 'e:\\[test\\' -ToSession $sess\r\n```\r\n\r\n# Expected behavior\r\n\r\n```\r\nShould copy the file E:\\test.txt to E:\\[test directory\r\n```\r\n\r\n# Actual behavior\r\n\r\n```\r\nFailed as '[' is seen as regex\r\n```\r\n\r\n# Environment data\r\n\r\n<!-- provide the output of $PSVersionTable -->\r\n\r\n```\r\nApplicable to all versions\r\n```\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "It looks like Path vs LiteralPath. If users types special char in path they should escape it or use LiteralPath. It is simple and predictable UX. If a path comes from file system it should be considered as literal.",
      "created_at": "2020-03-21T07:41:30Z",
      "updated_at": "2020-03-21T07:41:30Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov, note that the problematic path is passed to the `-Destination` parameter, where no distinction between literal and wildcard-based paths is offered.\r\n\r\nIn general, for _output_ paths, it only every makes sense to interpret them as _literal_ paths , so this is worth fixing - just as we're about to do for the  `-OutFile` parameter of `Invoke-WebRequest` / `Invoke-RestMethod` (see #11701 - incidentally, please change that PR's title).\r\n",
      "created_at": "2020-03-21T13:14:47Z",
      "updated_at": "2020-03-21T13:14:47Z"
    },
    {
      "author": "krishnayalavarthi",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov @mklement0 , agree that `-Destination` parameter should be treated as literal. Right now it doesn't work with `c:\\[test` directory, and hence needs to be fixed to make it work as literalpath.\r\n\r\nAlso, even if we consider regex scenario, having `[` alone in the directory is not a regex and should be seen as literal path. In both cases it makes sense fixing it.",
      "created_at": "2020-03-23T06:42:16Z",
      "updated_at": "2020-03-23T06:42:16Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "As an aside, @krishnayalavarthi, we're talking about _wildcard expressions_, not regexes.\r\n\r\nAgreed, given that when remoting isn't involved, something like `Copy-Item foo.txt [foo.txt` seems to quietly fall back to a literal interpretation of the path.\r\n\r\nIt's implied by your repro steps, but to spell it out: the problem only arises in the context of _remoting_ (even though background jobs use the same serialization infrastructure, I don't see it there).\r\n\r\nAlso note that remoting still targets _Windows PowerShell_ by default, so it's better to start investigating with a command that also targets PowerShell Core:\r\n\r\n```powershell\r\n$sess = New-PSSession -ComputerName localhost -ConfigurationName PowerShell.7\r\n```\r\n",
      "created_at": "2020-03-23T11:03:35Z",
      "updated_at": "2020-03-23T11:03:35Z"
    },
    {
      "author": "krishnayalavarthi",
      "author_association": "CONTRIBUTOR",
      "body": "All the below commands have issue with this invalid wildcard in the path parameter.\r\nPR #12170 solves the below failures.\r\n\r\n`PS C:\\WINDOWS\\system32> Test-Path E:\\[test`\r\n\r\n`Test-Path : Cannot retrieve the dynamic parameters for the cmdlet. The specified wildcard character pattern is not valid: [test\r\nAt line:1 char:1\r\n Test-Path E:\\[test`\r\n` ~~~~~~~~~~~~~~~~~~\r\n CategoryInfo          : InvalidArgument: (:) [Test-Path], ParameterBindingException\r\n FullyQualifiedErrorId : GetDynamicParametersException,Microsoft.PowerShell.Commands.TestPathCommand\r\n`\r\n\r\n\r\n`PS C:\\WINDOWS\\system32> Get-Item E:\\[test -ea SilentlyContinue`\r\n`Get-Item : Cannot retrieve the dynamic parameters for the cmdlet. The specified wildcard character pattern is not valid: [test\r\nAt line:1 char:1`\r\n\r\n` Get-Item E:\\[test -ea SilentlyContinue`\r\n` ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n CategoryInfo          : InvalidArgument: (:) [Get-Item], ParameterBindingException\r\n FullyQualifiedErrorId : GetDynamicParametersException,Microsoft.PowerShell.Commands.GetItemCommand`\r\n\r\n`PS C:\\WINDOWS\\system32> Remove-Item E:\\[test -Force -ea SilentlyContinue`\r\n`Remove-Item : Cannot retrieve the dynamic parameters for the cmdlet. The specified wildcard character pattern is not valid: [test\r\nAt line:1 char:1`\r\n\r\n` Remove-Item E:\\[test -Force -ea SilentlyContinue`\r\n` ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n CategoryInfo          : InvalidArgument: (:) [Remove-Item], ParameterBindingException\r\n FullyQualifiedErrorId : GetDynamicParametersException,Microsoft.PowerShell.Commands.RemoveItemCommand`\r\n\r\n`PS C:\\WINDOWS\\system32>`\r\n",
      "created_at": "2020-03-23T16:36:45Z",
      "updated_at": "2020-03-23T16:41:14Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@krishnayalavarthi, these are examples of _input_ paths, which by default bind to the `-Path` parameter, which _does_ expect wildcard expressions (and must continue to do so).\r\n\r\nTo pass literal paths, use the `-LiteralPath` parameter (its short alias in PS Core is `-lp`).\r\n\r\nThat said, I cannot reproduce your symptoms, neither in direct invocation nor via remoting.",
      "created_at": "2020-03-23T17:21:58Z",
      "updated_at": "2020-03-23T19:18:32Z"
    },
    {
      "author": "krishnayalavarthi",
      "author_association": "CONTRIBUTOR",
      "body": "I just installed Powershell 7. Below are repro steps.\r\n\r\nI agree that by-default if `-Path` is not given, the path binds to the `-Path` which should accept wildcard expressions.\r\n\r\nHere we have the scenario of \"invalid wildcard\". If just `[` is given in the path (in this case `E:\\[test` without completion bracket `]`), the path should be treated as literalpath and should continue, instead of failing with the below errors.\r\n\r\n`PS C:\\Program Files\\PowerShell\\7> Test-Path -Path 'e:\\[test' `\r\n`Test-Path: Cannot retrieve the dynamic parameters for the cmdlet. The specified wildcard character pattern is not valid: [test`\r\n\r\n\r\n`PS C:\\Program Files\\PowerShell\\7> Test-Path -LiteralPath 'e:\\[test'`\r\n`True`\r\n`PS C:\\Program Files\\PowerShell\\7>`",
      "created_at": "2020-03-23T17:38:51Z",
      "updated_at": "2020-03-23T17:40:47Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Good point, @krishnayalavarthi  - the reason I didn't see the symptom is that these commands behave differently _if no such file exists_; since I have no `E:` drive, I actually got a meaningful error message.\r\nIf the drive exists, but not the path as a whole, `Test-Path` works as expected, but `Get-Item` returns nothing and doesn't complain.\r\n\r\nThat it would fail _if the file actually exists_ is confusing and unhelpful.\r\n\r\nI agree that falling back to a literal path is the more sensible behavior.\r\n\r\nAs a minor side effect, something like `Get-Item C:\\[NoSuch` would start complaining (it currently doesn't), but I think that too is more sensible behavior.\r\n\r\n\r\n",
      "created_at": "2020-03-23T19:29:10Z",
      "updated_at": "2020-03-25T18:54:09Z"
    },
    {
      "author": "krishnayalavarthi",
      "author_association": "CONTRIBUTOR",
      "body": "@mklement0 I didn't notice this behavior earlier. Agree with you.\r\n\r\n`PS C:\\Users> test-path E:\\[test`\r\n`Test-Path: Cannot retrieve the dynamic parameters for the cmdlet. The specified wildcard character pattern is not valid: [test`\r\n\r\n`PS C:\\Users> test-path E:\\[nosuch`\r\n`False`\r\n\r\n`PS C:\\Users> Get-Item E:\\[test`\r\n`Get-Item: Cannot retrieve the dynamic parameters for the cmdlet. The specified wildcard character pattern is not valid: [test`\r\n\r\n`PS C:\\Users> Get-Item E:\\[nosuch`\r\n`PS C:\\Users>`\r\n \r\n@iSazonov / @mklement0  : Do you think I can use the #12170 for this issue? This PR will check if the path has invalid wild card (just `[`), in such case it will treat the path as literalpath and proceed. This will fix the above issue. Your comments pls. ",
      "created_at": "2020-03-25T01:10:07Z",
      "updated_at": "2020-03-25T01:15:32Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> This PR will check if the path has invalid wild card (just [), in such case it will treat the path as literalpath and proceed. \r\n\r\nWe already have follow fix in other places: check the path exists as literal, if no process as wildcard.",
      "created_at": "2020-03-25T03:28:50Z",
      "updated_at": "2020-03-25T03:28:50Z"
    },
    {
      "author": "krishnayalavarthi",
      "author_association": "CONTRIBUTOR",
      "body": "> We already have follow fix in other places: check the path exists as literal, if no process as wildcard.\r\n\r\nSorry, I didn't get the point. You are saying fix for \"check the path exists as literal, if no process as wildcard.\" .  In yes, we should not be seeing the below error... right?\r\n\r\n`PS C:\\Users> Get-Item E:\\[test`\r\n`Get-Item: Cannot retrieve the dynamic parameters for the cmdlet. The specified wildcard character pattern is not valid: [test`\r\n\r\nAs the path has invalid wildcard char `[` (just single `[` instead of `[]`), this should have been treated as literalpath and reported `True` as the path already exists in my file system.",
      "created_at": "2020-03-25T15:45:43Z",
      "updated_at": "2020-03-25T15:45:55Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "The fix I mentioned is for WorkingDirectory. There is still another scenario fixed in the same way.",
      "created_at": "2020-03-25T17:14:17Z",
      "updated_at": "2020-03-25T17:14:17Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov, the behavior that @krishnayalavarthi is proposing (if I understand correctly) makes for consistent behavior:\r\n\r\n* Something that _cannot be_ a wildcard expression, because it is _syntactically invalid_, should be treated as a _literal_ path.\r\n\r\nAs stated, that means that a command such as `Get-Item C:\\[NoSuch`, which currently fails silently, would then complain, because no file _literally_ named `C:\\[Nosuch` is then found, which would trigger the `Cannot find path '...' because it does not exist.` error.\r\n\r\n* Are you concerned about this aspect of the proposed fix for backward compatibility reasons?\r\n\r\n* Are you proposing that  `Get-Item C:\\[NoSuch` continue to fail silently (as opposed to successfully targeting a file `C:\\[DoesExist` literally even with (implied) `-Path`)?\r\n\r\nNote that the fixes you mention, if I understand correctly, sound like  a _deliberate inconsistency_ for when wildcard patterns - notably including syntactically _valid_ ones - happen to match an existing file _if interpreted as literals_. An inconsistency, I presume, that was intended to ease the pain of previously having to use `-LiteralPath` explicitly in order to unambiguously pass paths as literals.\r\n\r\nWe've run into this before: #6733 proposed that an invalid wildcard pattern _consistently_ be treated as an error, which would be another way to resolve this - but it is at odds with the fixes you mention.\r\n\r\nEither way, two fixes are required:\r\n\r\n*  Fix the always-inappropriate wildcard interpretation of _output_ file parameters such as `-Destination` - they should always be considered literal paths.\r\n\r\n* In line with the fixes you mention, make a wildcard pattern that _as a literal_ matches an _existing item_ fall back to a literal, for convenience (even though in the case of _valid_ wildcard patterns that amounts to an inconsistency).\r\n\r\n_Consistently_ falling back to literals is what makes the most sense to me, not least because that's how it has always worked with paths that contain no wildcard metacharacters at all: `Get-Item NoSuch` is effectively treated as _literal_ and therefore results in `Cannot find path '...' because it does not exist.` - even though it is _technically_ also a valid wildcard expression.\r\n\r\nOf course, the horribly treacherous combination with `Get-ChildItem -Recurse` is the regrettable exception: see #5699.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-03-25T19:50:35Z",
      "updated_at": "2020-03-25T19:50:35Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Are you concerned about this aspect of the proposed fix for backward compatibility reasons?\r\n\r\nYes, it looks like a breaking change.\r\n\r\n> Are you proposing that Get-Item C:\\[NoSuch continue to fail silently\r\n\r\nNo. Suggestion is to do (1) Get-Item -LiteralPath , then to do (2) Get-Item -Path\r\nThen I'd agree that `Get-Item C:\\[NoSuch` could return `Get-Item: Cannot find path 'C:\\[NoSuch' because it does not exist.` but I think we can do without complicating wildcard analyzes for this.\r\n\r\n> We've run into this before: #6733 proposed that an invalid wildcard pattern consistently be treated as an error\r\n\r\nIn general it is impossible to ensure by parsing that a path is valid - only underlying file system can return reliable result. So the proposed steps (Literal, then Path) is best that we can do.\r\n\r\nSince you mentioned #5699 I guess there is a common code that brings the behavior. In the case a fix should be common too and it will huge breaking change.",
      "created_at": "2020-03-26T05:02:57Z",
      "updated_at": "2020-03-26T05:02:57Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "For reference #4076",
      "created_at": "2020-03-26T07:43:36Z",
      "updated_at": "2020-03-26T07:43:36Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": ">  Suggestion is to do  (1) Get-Item -LiteralPath , then to do (2) Get-Item -Path\r\n\r\nThat's what @SteveL-MSFT also just proposed in https://github.com/PowerShell/PowerShell/issues/6733#issuecomment-604136181 (and @vexx32 agreed), and it makes sense, given the history of this problem and inconvenience of having to _know of_ and _explicitly use_ a separate parameter for literal paths (`-LiteralPath`).\r\n\r\n> Then I'd agree that Get-Item C:\\[NoSuch could return Get-Item: Cannot find path 'C:\\[NoSuch' because it does not exist. but I think we can do without complicating wildcard analyzes for this.\r\n\r\nGlad to hear it: As for complicating  the wildcard analyzer: All we need to know up front is whether a \r\n given input is a _syntactically valid_ wildcard pattern, and only a few edge case are _not_:\r\n\r\nIn short: Only patterns that either contain `[]` or have only a `[` without a closing `]` (but not vice versa) are invalid (e.g., `test[].txt`, `test[.txt`).\r\n\r\n`[WildcardPattern]::new('C:\\[test')` doesn't throw an exception _on construction_, but calling the `.IsMatch()` function does: `[WildcardPattern]::new('C:\\[test').IsMatch('foo')`\r\n\r\n> In general it is impossible to ensure by parsing that a path is valid \r\n\r\nThat is not the goal here.\r\n\r\n---\r\n\r\n> So the proposed steps (Literal, then Path) is best that we can do.\r\n\r\nAs stated, it's probably the best compromise under the circumstances, but let's be clear on the tradeoffs:\r\n\r\nIt means that passing something _intended_ to be a wildcard can situationally and unexpectedly be treated as a literal.\r\n\r\nFor instance, I'm getting the wrong match if  I'm looking for `-Path file[12].txt` to match files `file1.txt` and/or `file2.txt`, and a file _literally_ named `file[12].txt` happens to be present - and there is _no workaround_.\r\n\r\nTo only way to avoid this pitfall is to _consistently_ treat any `-Path` value as a wildcard - and complain if it's syntactically invalid - and to treat _only_ `-LiteralPath` values as literals.\r\n\r\nNeedless to say, that is inconvenient, and a perennial pitfall, especially to those who may not even be aware of the presence of the `-LiteralPath` parameter.\r\n\r\nPOSIX-like shells have solved this problem more succinctly: if the argument is _unquoted_, it is a wildcard; if it's _quoted_, it is a literal (that it is the shell itself rather than the target command that does the matching is a separate issue); e.g., `file[12].txt` asks for wildcard matching, `'file[12].txt'` asks for a literal.\r\n\r\nIn a manner of speaking: it is the _data type_ of the argument that unambiguously selects the desired behavior, akin to how `/..../` is a regex literal in JavaScript, distinct from `'...'` (strings).\r\n\r\nNote that the POSIX-shell approach _is_ already implemented, but only  when passing arguments to _external programs_ on _Unix_ (of necessity, for compatibility): `/bin/echo *.txt` expands `*.txt` and passes the resulting file names as individual arguments, whereas `/bin/echo '*.txt'` passes `*.txt` _verbatim_.\r\n\r\nAs a general solution, we've previously discussed [adopting the same distinction _generally_](https://github.com/PowerShell/PowerShell/issues/9308#issuecomment-480801997) or  [doing the _inverse_ ](https://github.com/PowerShell/PowerShell/issues/9308#issuecomment-491023897):\r\nGiven that we're stuck with the wildcard behavior as the _default_ (positional binding to `-Path`), we could provide a succinct way to signal the desire to _escape_ the pattern in order to treat it _literally_, which sigil sequence `` @` `` could do (with the `` ` `` suggesting _escaping_); e.g.,\r\n``Get-Item @`file[12].txt`` would ask that the pattern be _escaped_ and would effectively be the equivalent of `Get-Item -LiteralPath file[12].txt`.  \r\nThe same approach could be extended to _regex_ contexts, including in expression mode, so that you could write `` 'foo|bar' -replace @\\'foo|' `` as the succinct equivalent of `'foo|bar' -replace [regex]::Escape('foo|')`\r\n",
      "created_at": "2020-03-26T11:44:39Z",
      "updated_at": "2020-03-26T11:44:39Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> It means that passing something intended to be a wildcard can situationally and unexpectedly be treated as a literal.\r\n\r\n```PowerShell\r\nGet-Item -Path E:\\abc[test].txt\r\n```\r\nIf we will check literal and the file exists what is a priority: return a result for the literal or process wildcard? Taken into account `-Path` parameter I think we should process wildcard and if result is nothing then check the literal. If the literal does not exist too what is an error we should return? Path not found?\r\n\r\n> To only way to avoid this pitfall is to consistently treat any -Path value as a wildcard - and complain if it's syntactically invalid\r\n\r\nI still believe we have no need for wildcard complain. User will get \"Path not found\" and can review its input.",
      "created_at": "2020-03-26T14:54:33Z",
      "updated_at": "2020-03-26T14:57:47Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> Taken into account -Path parameter I think we should process wildcard and if result is nothing then check the literal.\r\n\r\nI agree.\r\n\r\n> If the literal does not exist too what is an error we should return? Path not found?\r\n\r\n* If it is a syntactically _valid_ wildcard expression, _nothing_ should be output, as before.\r\n\r\n* If it is a syntactically _invalid_ wildcard expression, there is no reason to even _attempt_ wildcard matching, and only literal matching should be attempted - and that will give you the \"Path not found\" error, if no such item is found.\r\n\r\n",
      "created_at": "2020-03-26T18:03:58Z",
      "updated_at": "2020-03-26T18:04:16Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee reviewed this, our recommendation:\r\n\r\n- if the wild card is invalid, treat as literal\r\n- if the path expects wild card matching, then wild card matching happens first and if nothing matches, then treat as literal\r\n- document that to escape wildcards, one needs to escape the escape character when using double quotes:\r\n\r\n```powershell\r\nwrite-host \"``[\"\r\n`[\r\n```\r\n\r\nor using single quotes\r\n\r\n```powershell\r\nwrite-host '`['\r\n`[\r\n```\r\n\r\n- for cmdlets that don't respect the single escaping (e.g. `set-location`), we should investigate a fix so that you don't need to escape it multiple times\r\n\r\n",
      "created_at": "2020-04-08T23:14:11Z",
      "updated_at": "2020-04-08T23:14:11Z"
    }
  ],
  "created_at": "2020-03-20T22:40:25Z",
  "number": 12168,
  "state": "open",
  "title": "Path is not parsed correctly if '[' is present in the path",
  "updated_at": "2021-11-29T17:19:54Z"
}