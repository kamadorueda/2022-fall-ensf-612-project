{
  "_url": "https://github.com/PowerShell/PowerShell/issues/14304",
  "author": "daxian-dbw",
  "body": "<!-- Anything that looks like this is a comment and can't be seen after the Pull Request is created. -->\r\n\r\n## PR Summary\r\n\r\nComparing with v7.1.0, the changes in this PR improves the startup of a stable version PowerShell by about 19% on a 8 logical core machine, by about 10% on a 4 logical core machine.\r\nStable version of PowerShell means: experimental features are disabled in the build by default, just like a GA version.\r\n\r\nMajor changes:\r\n\r\n1. Push the call to `InitialSessionState.CreateDefault2()` to a worker thread.\r\n1. Push the call to `GetConfigurationNameFromGroupPolicy()` to a worker thread.\r\n    The method `Utils.GetPolicySetting<T>(...)` is pretty expensive at startup time, including loading `system.collections.concurrent.dll`, `system.io.filesytem.dll`, `newtonsoft.json.dll`, the overhead of using `ConcurrentDictionary`, and the overhead of reading settings from the configuration file.\r\n1. Push the call to `SendPSCoreStartupTelemetry` to a worker thread.\r\n   This is also an expensive call at startup time, including loading `microsoft.applicationinsights.dll`, intializing the telemetry client and actually write out telemetry.\r\n\r\nBy pushing them to worker threads, the assembly loading and type initalization are all taken place on the worker thread, so as to have the main thread move forward until it has to block for any of the tasks to finish.\r\n\r\nImplementation-wise,\r\n\r\n1. `ConsoleHost.DefaultInitialSessionState` is changed to make its getter able to either return a previously set `InitialSessionState` value, or waiting for a task result and return the result.\r\n1. Similarly, `CommandLineParameterParser.ConfigurationName` is changed to have its getter wait for the 'GetConfigurationNameFromGroupPolicy' task to finish.\r\n1. Telemetry doesn't block anything, but we need to make sure the startup telemetry gets sent before the process exits. (we ignore the cases where the process is forcefully terminated, in which case we cannot guarantee the telemetry to be sent anyways)\r\n1. Remove `CreateRunspace(object runspaceCreationArgs)` and `RunspaceCreationEventArgs`. They add an intermediate layer of method call, which is not needed at all.\r\n\r\n## Startup time comparison\r\n\r\nThe following results are 3 continuous run of the benchmarck program, which compares v7.1.0, v7.2-wip (this pr), and Windows PS 5.1.\r\n\r\n**Notes:**\r\n1. since we are comparing with a stable version v7.1.0, v7.2-wip is built using `Start-PSBuild -Clean -ReleaseTag v7.2.0 -CrossGen -Configuration Release` to diable all experimental features (`-ReleaseTag v7.2.0` means building for a stable version).\r\n2. the module analysis cache file is already created for all those 3 versions of PowerShell.\r\n\r\n**Benchmark Run**\r\n\r\n```none\r\nBenchmarkDotNet=v0.12.1, OS=Windows 10.0.19042\r\nIntel Core i7-1065G7 CPU 1.30GHz, 1 CPU, 8 logical and 4 physical cores\r\n.NET Core SDK=5.0.100\r\n  [Host]     : .NET Core 5.0.0 (CoreCLR 5.0.20.51904, CoreFX 5.0.20.51904), X64 RyuJIT\r\n  DefaultJob : .NET Core 5.0.0 (CoreCLR 5.0.20.51904, CoreFX 5.0.20.51904), X64 RyuJIT\r\n```\r\n\r\n\r\n|            Method |     Mean |   Error |   StdDev | Ratio | RatioSD | Code Size |\r\n|------------------ |---------:|--------:|---------:|------:|--------:|----------:|\r\n|   V710StartupTime | 384.8 ms | 7.50 ms | 10.99 ms |  1.00 |    0.00 |     711 B |\r\n| V72WipStartupTime | 313.6 ms | 5.26 ms |  4.66 ms |  0.81 |    0.03 |     218 B |\r\n|  WinPSStartupTime | 211.2 ms | 3.48 ms |  2.91 ms |  0.55 |    0.02 |     711 B |\r\n\r\n\r\n|            Method |     Mean |   Error |   StdDev | Ratio | RatioSD | Code Size |\r\n|------------------ |---------:|--------:|---------:|------:|--------:|----------:|\r\n|   V710StartupTime | 391.4 ms | 7.81 ms | 10.16 ms |  1.00 |    0.00 |     711 B |\r\n| V72WipStartupTime | 317.2 ms | 6.10 ms |  6.78 ms |  0.81 |    0.03 |     218 B |\r\n|  WinPSStartupTime | 215.3 ms | 4.21 ms |  7.48 ms |  0.55 |    0.02 |      60 B |\r\n\r\n\r\n|            Method |     Mean |   Error |  StdDev | Ratio | RatioSD | Code Size |\r\n|------------------ |---------:|--------:|--------:|------:|--------:|----------:|\r\n|   V710StartupTime | 394.4 ms | 7.57 ms | 9.84 ms |  1.00 |    0.00 |      60 B |\r\n| V72WipStartupTime | 316.2 ms | 6.25 ms | 6.14 ms |  0.81 |    0.02 |     218 B |\r\n|  WinPSStartupTime | 217.8 ms | 3.87 ms | 5.29 ms |  0.55 |    0.02 |     711 B |\r\n\r\n## Benchmark program\r\n\r\n```c#\r\nusing System.Diagnostics;\r\n\r\nusing BenchmarkDotNet.Attributes;\r\nusing BenchmarkDotNet.Running;\r\n\r\nnamespace benchmark\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            var summary = BenchmarkRunner.Run<Benchmark_pwsh_startup>();\r\n        }\r\n    }\r\n\r\n    [DisassemblyDiagnoser(printSource: true)]\r\n    public class Benchmark_pwsh_startup\r\n    {\r\n        private ProcessStartInfo v710, v72wip, winps;\r\n\r\n        [GlobalSetup]\r\n        public void Setup()\r\n        {\r\n            v710 = new ProcessStartInfo(@\"C:\\Program Files\\PowerShell\\7\\pwsh.exe\", \"-noprofile -c echo 1\");\r\n            v72wip = new ProcessStartInfo(@\"C:\\arena\\repos\\PowerShell\\src\\powershell-win-core\\bin\\Release\\net5.0\\win7-x64\\publish\\pwsh.exe\", \"-noprofile -c echo 1\");\r\n            winps = new ProcessStartInfo(@\"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\", \"-noprofile -c echo 1\");\r\n        }\r\n\r\n        [Benchmark(Baseline = true)]\r\n        public void V710StartupTime()\r\n        {\r\n            Process.Start(v710).WaitForExit();\r\n        }\r\n\r\n        [Benchmark]\r\n        public void V72WipStartupTime()\r\n        {\r\n            Process.Start(v72wip).WaitForExit();\r\n        }\r\n\r\n        [Benchmark]\r\n        public void WinPSStartupTime()\r\n        {\r\n            Process.Start(winps).WaitForExit();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## PR Checklist\r\n\r\n- [x] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [x] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [ ] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [ ] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` or `[ WIP ]` to the beginning of the title (the `WIP` bot will keep its status check at `Pending` while the prefix is present) and remove the prefix when the PR is ready.\r\n- **[Breaking changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)**\r\n    - [x] None\r\n    - **OR**\r\n    - [ ] [Experimental feature(s) needed](https://github.com/MicrosoftDocs/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/About/about_Experimental_Features.md)\r\n        - [ ] Experimental feature name(s): <!-- Experimental feature name(s) here -->\r\n- **User-facing changes**\r\n    - [x] Not Applicable\r\n    - **OR**\r\n    - [ ] [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n- **Testing - New and feature**\r\n    - [x] N/A or can only be tested interactively\r\n    - **OR**\r\n    - [ ] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n- **Tooling**\r\n    - [x] I have considered the user experience from a tooling perspective and don't believe tooling will be impacted.\r\n    - **OR**\r\n    - [ ] I have considered the user experience from a tooling perspective and enumerated concerns in the summary. This may include:\r\n        - Impact on [PowerShell Editor Services](https://github.com/PowerShell/PowerShellEditorServices) which is used in the [PowerShell extension](https://github.com/PowerShell/vscode-powershell) for VSCode (which runs in a different PS Host).\r\n        - Impact on Completions (both in the console and in editors) - one of PowerShell's most powerful features.\r\n        - Impact on [PSScriptAnalyzer](https://github.com/PowerShell/PSScriptAnalyzer) (which provides linting & formatting in the editor extensions).\r\n        - Impact on [EditorSyntax](https://github.com/PowerShell/EditorSyntax) (which provides syntax highlighting with in VSCode, GitHub, and many other editors).\r\n",
  "closed_at": "2021-01-20T18:24:41Z",
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Eh, I've always said that MSFT developers shouldn't be given the latest hardware :-)\r\nWhen I started #14268 my first desire was to follow the EarlyStartup.Init() pattern and move slow operations to background threads but after testing on my old laptop, I did not see any performance gain.\r\nFrom this I concluded that this approach is not well applicable if we want to be fast on high-load systems and  low-power equipment (IoT, Wasm and so on).\r\n(We already create many _CPU-bound_ threads and adding new ones only makes sense for hardware with many cores - this is definitely not my laptop :-) )\r\nSo I did some PRs with _direct_ performance improvements. @daxian-dbw Could you please consider them first? Even if we decide to move some from them to background threads, it will make them also lighter and faster.\r\n\r\nI especially have doubts about GetPolicySetting(). It is slow totally because of newtonsoft.json. It would be more promising for us to migrate to .Net Json and see the result. It will _definitely_ be better. If we see problems we can ask the .Net team, which continues to actively work on it.\r\n\r\n(Perhaps we need take new look on EarlyStartup.Init().)\r\n",
      "created_at": "2020-12-02T17:08:57Z",
      "updated_at": "2020-12-02T17:14:43Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@iSazonov Thanks for raising your concerns. I run the benchmark on a 2017-year 4 logical core machine (so not a latest hardware \ud83d\ude04), and I still observe over 10% improvements in the startup.\r\nBelow are some of the results:\r\n```\r\nBenchmarkDotNet=v0.12.1, OS=Windows 10.0.19042\r\nIntel Core i5-7300U CPU 2.60GHz (Kaby Lake), 1 CPU, 4 logical and 2 physical cores\r\n.NET Core SDK=5.0.100\r\n  [Host]     : .NET Core 5.0.0 (CoreCLR 5.0.20.51904, CoreFX 5.0.20.51904), X64 RyuJIT\r\n  DefaultJob : .NET Core 5.0.0 (CoreCLR 5.0.20.51904, CoreFX 5.0.20.51904), X64 RyuJIT\r\n```\r\n\r\n|            Method |     Mean |   Error |  StdDev | Ratio | RatioSD | Code Size |\r\n|------------------ |---------:|--------:|--------:|------:|--------:|----------:|\r\n|   V710StartupTime | 429.1 ms | 5.67 ms | 5.30 ms |  1.00 |    0.00 |     218 B |\r\n| V72WipStartupTime | 372.6 ms | 5.68 ms | 5.03 ms |  0.87 |    0.02 |     218 B |\r\n|  WinPSStartupTime | 254.2 ms | 3.12 ms | 2.77 ms |  0.59 |    0.01 |      40 B |\r\n\r\n|            Method |     Mean |   Error |  StdDev | Ratio | RatioSD | Code Size |\r\n|------------------ |---------:|--------:|--------:|------:|--------:|----------:|\r\n|   V710StartupTime | 427.8 ms | 6.32 ms | 5.60 ms |  1.00 |    0.00 |     218 B |\r\n| V72WipStartupTime | 377.5 ms | 5.18 ms | 4.33 ms |  0.88 |    0.02 |      40 B |\r\n|  WinPSStartupTime | 252.5 ms | 2.90 ms | 2.57 ms |  0.59 |    0.01 |      40 B |\r\n\r\n|            Method |     Mean |   Error |  StdDev | Ratio | RatioSD | Code Size |\r\n|------------------ |---------:|--------:|--------:|------:|--------:|----------:|\r\n|   V710StartupTime | 431.0 ms | 6.08 ms | 5.69 ms |  1.00 |    0.00 |      40 B |\r\n| V72WipStartupTime | 373.3 ms | 5.20 ms | 4.61 ms |  0.87 |    0.01 |     160 B |\r\n|  WinPSStartupTime | 269.0 ms | 5.00 ms | 7.18 ms |  0.62 |    0.02 |     699 B |\r\n",
      "created_at": "2020-12-02T19:21:23Z",
      "updated_at": "2020-12-02T19:21:23Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> @iSazonov Thanks for raising your concerns. I run the benchmark on a 2017-year 4 logical core machine (so not a latest hardware \ud83d\ude04), and I still observe over 10% improvements in the startup.\r\n\r\n2017? :-) How would you classify my 2011 laptop? :-) Note that it is significantly newer than Windows 7 which still runs PowerShell 7. :-) \r\n\r\nSeriously, my suggestion is to first make direct corrections, open cases in .Net if necessary (they already shared plans to speed up runtime initialization in 6.0 milestone), and only before next RC to evaluate how much we need to do additional threads.\r\n\r\n",
      "created_at": "2020-12-02T19:50:18Z",
      "updated_at": "2020-12-02T19:50:18Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "I agree that leveraging worker thread for parallel processing won't result in much difference in high-load system or low-power/low-rank equipment. However, that's **not** a reason to not use it, because it's obvious that many more users, who are using the suitable equipments, will benefit from it.\r\n\r\nParallel processing is not the answer to everything ([Amdahl's law](https://en.wikipedia.org/wiki/Amdahl%27s_law)), but it surely is a good tool as long as you use it cautiously -- be careful about the number of threads you spin up and be careful about what work loads to process in parallel, so as to avoid contention/blocking as much as possible.\r\n\r\nAlso, **it doesn't contradict with the work you have been doing or the improvement that .NET 6 will bring to us, does it?**",
      "created_at": "2020-12-02T19:57:35Z",
      "updated_at": "2020-12-02T20:05:21Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> 2017? :-) How would you classify my 2011 laptop? :-) Note that it is significantly newer than Windows 7 which still runs PowerShell 7.\r\n\r\nI don't think the OS version matters too much. It's more about how many logical cores the machine has, and of course, how much work load the machine is having at the moment.\r\n\r\nBut can you please run the benchmark on your 2011 machine and share the results? I would like to see if there is any penalty from context switching on a low-power machine. Please make sure you build my branch with `Start-PSBuild -Clean -ReleaseTag v7.2.0 -CrossGen -Configuration Release`, and then make sure its module cache is populated before running the benchmark. That can be done by 1) start the generated `pwsh.exe`, 2) run a few commands, 3) wait for a minute or two, for safety.",
      "created_at": "2020-12-02T20:04:13Z",
      "updated_at": "2020-12-02T20:11:54Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> But can you please run the benchmark on your 2011 machine and share the results?\r\n``` ini\r\n\r\nBenchmarkDotNet=v0.12.1, OS=Windows 10.0.18363.1198 (1909/November2018Update/19H2)\r\nIntel Core i5-2410M CPU 2.30GHz (Sandy Bridge), 1 CPU, 4 logical and 2 physical cores\r\n.NET Core SDK=5.0.100\r\n  [Host]     : .NET Core 5.0.0 (CoreCLR 5.0.20.51904, CoreFX 5.0.20.51904), X64 RyuJIT\r\n  DefaultJob : .NET Core 5.0.0 (CoreCLR 5.0.20.51904, CoreFX 5.0.20.51904), X64 RyuJIT\r\n\r\n\r\n```\r\n|            Method |     Mean |    Error |  StdDev | Ratio | RatioSD | Code Size |\r\n|------------------ |---------:|---------:|--------:|------:|--------:|----------:|\r\n|   V710StartupTime | 686.8 ms |  7.93 ms | 6.19 ms |  1.00 |    0.00 |     218 B |\r\n| V72WipStartupTime | 682.2 ms | 10.90 ms | 9.66 ms |  0.99 |    0.02 |     218 B |\r\n|  WinPSStartupTime | 365.0 ms |  4.85 ms | 4.30 ms |  0.53 |    0.01 |     218 B |\r\n```\r\n```\r\nIt is stable result in some runs.\r\nThis seem to confirm that moving works in background threads is not so good for startup scenario.\r\nAs I said in my PR, it's much better to ask the ApplicationInsights owners to improve this scenario and do not create additional threads.\r\n",
      "created_at": "2020-12-03T11:54:37Z",
      "updated_at": "2020-12-03T12:01:18Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "Thanks for sharing the results!\r\n\r\n> This seem to confirm that moving works in background threads is not so good for startup scenario.\r\n\r\nNah, this is actually not bad at all, as it shows no penalty (context switching and etc.) on your 2011 laptop.\r\nAgain, leveraging parallel processing doesn't contradict with the work that improves individual code paths. If it's handled correctly, they amplify the final result.",
      "created_at": "2020-12-03T22:32:51Z",
      "updated_at": "2020-12-03T22:33:15Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> it shows no penalty (context switching and etc.)\r\n\r\nI say not about a penalty. From my experience Windows works well on 2 cores (including applications) and I guess we will see the same result for our test on more slow hardware.\r\nI say about (1) roadmap and (2) how many benefits we will get from parallelization in the startup scenario. \r\nIt is well known that replacing a bad algorithm with a better one can have the greatest effect. Also, direct fixes are generally more effective than workarounds. For example, in our case, we can get a benefit of 20% from direct fixes, and from the subsequent parallelization only 1%, even on fast equipment because the code is already fast.\r\nSo my suggestion for a roadmap is to work on direct fixes here and in other repositories before RC and then investigate parallelization.\r\nThis will simplify the final performance checks before 7.2 release.\r\n",
      "created_at": "2020-12-04T03:18:19Z",
      "updated_at": "2020-12-04T03:18:19Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "Don't think parallelization as a workaround, think it as a tool. There is no good or bad about a tool, but only right way or wrong way to use it. As I said [above](https://github.com/PowerShell/PowerShell/pull/14304#issuecomment-737460646), the right way is _\"be careful about the **number of threads** you spin up and be careful about what **work loads** to process in parallel, so as to avoid contention/blocking as much as possible.\"_\r\n\r\nAn example as to the **work load** aspect:\r\n\r\n1. Today, `DefaultInitialSessionState = CreateDefault2()` is called in `ManagedEntrance.Start`, but the created `InitialSessionState` instance is not used until in `DoCreateRunspace`. I did some measurement on my \"_latest_\" machine, `CreateDefault2()` taske ~36 ms, and then it takes ~40 ms for the code flow to reach the first use of `DefaultInitialSessionState` in `DoCreateRunspace`.\r\n\r\n 2. Meanwhile, the `CreateDefault2()` call is pretty selfcontained, no synchronization is needed when having it run on a worker thread. \r\n\r\nTogether, they make `CreateDefault2()` a good candidate work-load to run as a task, as of today.\r\n\r\n> For example, in our case, we can get a benefit of 20% from direct fixes, and from the subsequent parallelization only 1%, even on fast equipment because the code is already fast.\r\n\r\nThis sounds like a pretty extragerated hypothetical example :) But, if we cannot find the right workload for parallelization, then that just means we should not use that tool.\r\n\r\nI want to emphsize again, **parallelization doesn't contradict with the work that improves individual code paths. If it's handled correctly, they amplify the final result.**\r\n\r\n> So my suggestion for a roadmap is to work on direct fixes here and in other repositories before RC and then investigate parallelization.\r\n\r\nYeah, I agree to not rush in this PR. As I mentioned in our discussion at https://github.com/PowerShell/PowerShell/pull/14281#issuecomment-738449342, more work and testing is needed to _\"fine-tune the decisions like how many tasks to use, and what work load shall be done in tasks.\"_ And decisions will change as more perf work on our side and .NET side get in.\r\n\r\nBut I believe we cannot wait till the RC timeframe, as changes in this PR (or similar PRs) need sufficient bake time.",
      "created_at": "2020-12-04T06:31:45Z",
      "updated_at": "2020-12-04T06:31:45Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> But I believe we cannot wait till the RC timeframe, as changes in this PR (or similar PRs) need sufficient bake time.\r\n\r\nI mean last Preview before RC is good time to check, investigate and fix performance issues.",
      "created_at": "2020-12-04T06:41:05Z",
      "updated_at": "2020-12-04T06:41:05Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Today my test show regression up to 20% because ... slow DNS request from ApplicationInsights! I saw this previously. So any network issue delays PowerShell startup due to ApplicationInsights - good argument to move it in a different thread.",
      "created_at": "2020-12-04T08:00:41Z",
      "updated_at": "2020-12-04T08:00:41Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@iSazonov Are you sure it's due to ApplicationInsights? Did you try disabling the telemetry to prove that's the cause? As we discussed in https://github.com/PowerShell/PowerShell/pull/14281#issuecomment-738449342, ApplicationInsight doesn't send telemetry packets synchronously.\r\n\r\nWhat you saw looks to me more likely a variant of #10983 -- DNS issue may cause the certificate security check to block.",
      "created_at": "2020-12-05T01:45:46Z",
      "updated_at": "2020-12-05T01:45:46Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> @iSazonov Are you sure it's due to ApplicationInsights? Did you try disabling the telemetry to prove that's the cause? As we discussed in [#14281 (comment)](https://github.com/PowerShell/PowerShell/pull/14281#issuecomment-738449342), ApplicationInsight doesn't send telemetry packets synchronously.\r\n\r\nI saw DnsResolver in ApplicationInsights _constructor_.\r\nIt would be easier to investigate if the code was open source. :-)",
      "created_at": "2020-12-05T03:21:18Z",
      "updated_at": "2020-12-05T03:21:18Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "I'm pretty sure ApplicationInsight sends telemetries in an asynchronous way. We are using the default configuraiton with `InMemoryChannel`, whose behavior is (see [\"more telemetry channels\"](https://apmtips.com/posts/2015-09-03-more-telemetry-channels/) for details):\r\n> InMemory channel `Microsoft.ApplicationInsights.Channel.InMemoryChannel` is a lightweight loosy telemetry channel that is used by default. It will batch data and initiate sending every `SendingInterval` (default is 30 seconds) or when number of items exceeded `MaxTelemetryBufferCapacity` (default is 500). It also will not retry if it failed to send telemetry.\r\n\r\nWhen using in-memory channel, the `Flush` call is synchronous. It forces data to be sent immediately.\r\n\r\nBut, interestingly, this also indicates that today for the `pwsh -c xxx` scenario, PowerShell never actully send out telemetry packets if the execution takes less than 30 seconds. Need to discuss with @JamesWTruher about whether that's a bug and should be fixed by `.Flush`.",
      "created_at": "2020-12-06T06:47:46Z",
      "updated_at": "2020-12-06T17:54:40Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Sources https://github.com/microsoft/ApplicationInsights-dotnet :-)\n\n<blockquote><img src=\"https://avatars2.githubusercontent.com/u/6154722?s=400&v=4\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/microsoft/ApplicationInsights-dotnet\">microsoft/ApplicationInsights-dotnet</a></strong></div><div>ApplicationInsights-dotnet. Contribute to microsoft/ApplicationInsights-dotnet development by creating an account on GitHub.</div></blockquote>",
      "created_at": "2020-12-07T10:32:54Z",
      "updated_at": "2020-12-07T10:32:57Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "Open PRs should not be assigned to milestone, so they are not assigned to the wrong milestone after they are merged.  For backport consideration, use a `backport` label. ",
      "created_at": "2020-12-16T23:07:31Z",
      "updated_at": "2020-12-16T23:07:31Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as stale because it has been marked as requiring author feedback but has not had any activity for **15 days**. It will be closed if no further activity occurs **within 10 days of this comment**.",
      "created_at": "2021-01-01T02:00:06Z",
      "updated_at": "2021-01-01T02:00:06Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as stale because it has been marked as requiring author feedback but has not had any activity for **15 days**. It will be closed if no further activity occurs **within 10 days of this comment**.",
      "created_at": "2021-01-16T05:00:05Z",
      "updated_at": "2021-01-16T05:00:05Z"
    }
  ],
  "created_at": "2020-12-02T07:08:55Z",
  "number": 14304,
  "state": "closed",
  "title": "Improve startup time by pushing some work off the main thread to thread pool",
  "updated_at": "2021-09-15T18:33:48Z"
}