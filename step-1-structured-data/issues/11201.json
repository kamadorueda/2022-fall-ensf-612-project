{
  "_url": "https://github.com/PowerShell/PowerShell/issues/11201",
  "author": "mklement0",
  "body": "Note: In addition to the immediate bug, the current behavior of selecting the explicitly defined parameter set with its mandatory parameter in parameter-less invocations is questionable as a whole - see the [proposal below](https://github.com/PowerShell/PowerShell/issues/11201#issuecomment-559491980).\r\n\r\n# Steps to reproduce\r\n\r\n```powershell\r\nfunction foo {\r\n  [CmdletBinding()]   # No default parameter set.\r\n  param(\r\n\r\n    # Only one explicitly defined parameter set, comprising\r\n    # one mandatory and one optional parameter.\r\n    [Parameter(ParameterSetName='bar', Mandatory)]\r\n    $MandatoryInItsSetButOptionalOverall,\r\n    [Parameter(ParameterSetName='bar')]\r\n    $MustBeCombinedWithMandatory,\r\n\r\n    # An untagged (all-parameter-sets) parameter.\r\n    $UnrelatedAndOptional\r\n  )\r\n  # Echo the effective parameter set.\r\n  $PSCmdlet.ParameterSetName\r\n}\r\n\r\n# Note: This will (questionably) prompt for a -MandatoryInItsSetButOptionalOverall value.\r\n#       Submit any value or just press Enter.\r\nfoo | Should -Be 'bar'\r\n```\r\n\r\n# Expected behavior\r\n\r\nThe test should succeed.\r\n\r\n# Actual behavior\r\n\r\nThe test fails:\r\n\r\n```\r\nExpected strings to be the same, but they were different. \r\nExpected length: 3 Actual length:   18 Strings differ at index 0. \r\nExpected: 'bar' But was: '__AllParameterSets'\r\n```\r\n\r\nThat is, even though set `bar` was clearly selected - otherwise there would have been no prompt - `__AllParameterSets` was then reported as the effective parameter set.\r\n\r\nAs an aside regarding the fundamental behavior:\r\n\r\nAs the naming of the parameters suggests, `bar` _shouldn't_ have become the effective parameter set by default.\r\nWhile that can be worked around by naming an (otherwise unused) different _default_ parameter set in the `[CmdletBinding()]` attribute, doing so shouldn't be necessary - see the initial post of #11143 for an example, and the [proposal below](https://github.com/PowerShell/PowerShell/issues/11201#issuecomment-559491980) for a potential resolution.\r\n\r\n# Environment data\r\n\r\n```none\r\nPowerShell Core 7.0.0-preview.6\r\n```\r\n",
  "closed_at": "2019-12-02T14:39:10Z",
  "comments": [
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "This time (!) I think you are right and PowerShell is wrong. (Although \"It's a corner case\" and \"Don't write like that\" also apply to some extent) \r\n```\r\n  param(\r\n    # Only one explicitly defined parameter set, comprising\r\n    # one mandatory and one optional parameter.\r\n    [Parameter(ParameterSetName='bar', Mandatory)]\r\n    $MandatoryInItsSetButOptionalOverall,\r\n    [Parameter(ParameterSetName='bar')]\r\n    $MustBeCombinedWithMandatory,\r\n\r\n    # An untagged (all-parameter-sets) parameter.\r\n    $UnrelatedAndOptional\r\n  )\r\n```\r\n\r\nSays \"I am naming one parameter set\". With one set we expect PowerShell to create a second parameter set so you can have \"Not the 'bar' set\" and it names this '__AllParameterSets'  \r\n\r\nHere's the table of what it **should** do \r\n```\r\n$MandInSet    $MustbeComined   $unrelated   Result\r\n   -               -               -         Not Set \"bar\"\r\n   -               -               X         \"\r\n   -               X               -         Set bar, prompt for mand\r\n   -               X               X         \"\r\n   X               -               -         Set bar OK as is\r\n   X               -               X         \"\r\n   X               X               -         \"\r\n   X               X               X         \"\r\n```\r\nAnd it seems to use this logic to report the parameter set name, but it uses **different logic** to decide what to prompt for - there it says \"There is only one set and that has a mandatory parameter\". \r\n\r\nIf you declared two sets explicitly i.e\r\n```\r\n    [Parameter(ParameterSetName='bar')]\r\n    [Parameter(ParameterSetName='Fud')]\r\n    $UnrelatedAndOptional\r\n``` \r\n\r\nThe problem goes away.  But PowerShell should **either** say \"Error: you have defined only one parameter set\" **or**, if allows one set it should use the same logic for prompting and set name. \r\nTo avoid breaking existing scripts it can't throw an error, and can't stop prompting, so, as you say, the \"wrong\" part is the set name. \r\n",
      "created_at": "2019-11-27T11:19:19Z",
      "updated_at": "2019-11-27T11:19:19Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Good analysis. \r\n\r\nAs for \"it's a corner case\": only in the sense that it may not be _common_, but it is a legitimate scenario.\r\n\r\nAs for \"Don't write like that\": You _should_ be able to write like that, because all the information is there to infer the intended behavior; it is just a variant of the more general problem described in #11143: The need to _work around_ the questionable behavior by artificially introducing another parameter set designated as the default `[CmdletBinding(DefaultParameterSetName='Fud')]`; or, even more cumbersomely, using the workaround you suggest \r\n(`[Parameter(ParameterSetName='bar')] [Parameter(ParameterSetName='Fud')] $UnrelatedAndOptional)`).\r\n\r\n",
      "created_at": "2019-11-27T12:46:30Z",
      "updated_at": "2019-11-27T12:46:30Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "We can discuss can vs should vs must :-)  \r\nBut people _should not_ write functions / cmdlets which define a single parameter set, but it is _allowed_. Legitimacy is a matter of opinion ... and inferring intent which isn't written is potentially dangerous. \r\n\r\nDividing things into one set doesn't make any sense, so PS has to either make a second set or throw an error if someone does that.   But when the only declared set  has a mandatory parameter it goes the \"safe\" way . So this won't run without a name or ID \r\n```powershell\r\nFunction BadOne {\r\nparam (\r\n    [Parameter(ParameterSetName=\"ByID\",  Mandatory=$true)]$ID,\r\n    [Parameter(ParameterSetName=\"ByName\",Mandatory=$true)]$Name,\r\n    $waitForServer \r\n)\r\n    if ($ID) {runsql \"Delete from Foo where ID = $ID\"} \r\n    else     {runsql \"Delete from foo where name like '$name*'\"}\r\n    if ($waitForServer) {Start-Sleep $waitForServer}\r\n}\r\n```\r\nIf I'm lazy and don't write the `mandatory`, it still doesn't run with out a name or ID ,  PowerShell protects me from my own bad (but perfectly legal) code.  You and I have done that one to death :-) \r\n\r\nBut if I take out the ID parameter, PowerShell will decide I can't get into the function without the name parameter.  It's handling code I really should not write (but am allowed to write) in the safe way. It's not clear without naming a second set that I want things to proceed so PS so it requires me to be explicit (which good, usually) but that is also cumbersome (bad, usually).  **I'm fine with that side.**\r\n But if someone depends on the parameter set name (as they might if this is something from which a parameter has been removed)  things will break; it needs a single named parameter set, WITH a mandatory parameter AND relying on ParameterSetName to get the bug to occur, but it is a bug all the same. \r\n",
      "created_at": "2019-11-27T18:07:11Z",
      "updated_at": "2019-11-27T18:07:11Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> and inferring intent which isn't written is potentially dangerous.\r\n\r\nDo you consider writing `'foo' -replace 'o'` instead of `'foo' -replace 'o', ''` dangerous, because it doesn't explicitly specify a replacement operand?\r\n\r\nHaving _useful, well-documented_ default behavior is a great blessing, in any language, because it reduces noise.\r\n\r\n> But people should not write functions / cmdlets which define a single parameter set, but it is allowed.\r\n\r\nAll we know is that the current behavior is _inconsistent_, and there's no official documentation as to how it _should_ work.\r\n\r\n_Logically_ there is no reason for your \"should\"  and, more importantly, _not_ enforcing it avoids unnecessary code (having to come up with a name for a parameter set that is logically _implied_ and for which a default name exists).\r\n\r\nOmitting a `Mandatory` property has nothing to do with laziness - it has _different semantics_ that are already meaningfully supported: a group of related parameters belonging to the same parameter set may all be non-mandatory by themselves, yet I may want to know - by querying `$PSCmdlet.ParametersetName` -  if _at least one_ of them was specified. Tagging any of them as `Mandatory` would _break_ that behavior.\r\n\r\n> But if I take out the ID parameter, PowerShell will decide I can't get into the function without the name parameter.\r\n\r\nWhat you consider a protection, I consider a bug and a nuisance. The inference that `-Name` is then mandatory _overall_ and that it should become the _default_ parameter set is logically ill-founded.\r\n\r\n> It's not clear without naming a second set that I want things to proceed\r\n\r\nIf you go by the simple rules proposed in #11143, it _is_ clear: Since no default parameter set is designated, argument-less invocation is allowed (as is invocation with only all-parameter-sets arguments) and makes `__AllParameterSets` the effective parameter set.\r\n\r\nWhile that may not make much sense with _only_ a  single, mandatory parameter (`$Name`) in the then only explicit set (`ByName`), the example in the initial post shows a meaningful example with _multiple_ parameters.\r\n\r\nOf course, if you have just _one_ explicit parameter set whose parameter you want to be mandatory _unconditionally_, there is no good reason to use an explicit parameter set at all: simply replace `[Parameter(ParameterSetName=\"ByName\",Mandatory=$true)]$Name` with `[Parameter(Mandatory=$true)]$Name`\r\n\r\n\r\n",
      "created_at": "2019-11-27T19:03:39Z",
      "updated_at": "2019-11-27T19:03:39Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> > and inferring intent which isn't written is potentially dangerous.\r\n> \r\n> Do you consider writing `'foo' -replace 'o'` instead of `'foo' -replace 'o', ''` dangerous, because it doesn't explicitly specify a replacement operand?\r\n\r\nWould it delete information from my production database ?  \r\n`foo -replace `  doesn't parse (but I would have required replace to have the replacement string; however it is what it is now, and changing at this point would create more of a problem)   \r\nYou can't run `copy -destination \\stuff` it requires a path.  That's inconvenient, it could assume current directory (as it does for destination when path is specified). But since the same thing prevents del [enter] deleting all my files, I'm happy for copy to be consistent and not run without a path. \r\n\r\n> > But people should not write functions / cmdlets which define a single parameter set,  \r\n> _Logically_ there is no reason for your \"should\" and, more importantly, _not_ enforcing it avoids unnecessary code (having to come up with a name for a parameter set that is logically _implied_ and for which a default name exists).\r\n\r\nThe logic is  that parametersets divide the the parameters into groups. Dividing into one group makes no sense. It lets people cut a corner, and sometimes that's OK.. But when a parameter in the sole group is mandatory, you can't _not_ select the the group. \r\n \r\n> Omitting a `Mandatory` property has nothing to do with laziness \r\nIt may or may not be.  In that example the sets have only one member so they are de-facto mandatory, I want them to be mandatory but I don't need to write it (which is something you were asking to be changed in the other issue), not writing mandatory is cutting a corner in _that_ case,  but there are other cases...   \r\n> it has _different semantics_ that are already meaningfully supported: a group of related parameters belonging to the same parameter set may all be non-mandatory by themselves, yet I may want to know - by querying `$PSCmdlet.ParametersetName` - if _at least one_ of them was specified. Tagging any of them as `Mandatory` would _break_ that behavior.\r\n\r\nIf the set can exist without a parameter then that parameter is non-mandatory, I used export-Excel as an example, you can create a table by giving a TableName or TableSyle. That's a set with two optional members.  \r\nYou've given a clever use of a single set; though rather than writing` [Parameter(parameterSetName=\"a\")] `for each parameter and referring using if `($pscmdlet.parametersetname -eq a) {...}  `\r\nit's shorter to use \r\n`$PSBoundParameters.Keys -match \"^(Pone|Ptwo)$\"\r\n\r\n> > But if I take out the ID parameter, PowerShell will decide I can't get into the function without the name parameter.\r\n> \r\n> What you consider a protection, I consider a bug and a nuisance. The inference that `-Name` is then mandatory _overall_ and that it should become the _default_ parameter set is logically ill-founded.\r\n\r\nThe behaviour is protective, it's just a question of whether one values the protection.  If there bug is allowing a single parameter set which forces  PowerShell to make one of two inferences.  \r\n- Either the author wants the only set they have declared to be default set, therefore the Parameter must be provided \r\n- Or the author was splitting the parameters into two sets, and wants the one they have not referred to to be the default , so it is OK to continue without providing the parameter. \r\nThe one which doesn't run the code which deletes the data is the one it chooses. \r\n\r\n> > It's not clear without naming a second set that I want things to proceed\r\n> \r\n> If you go by the simple rules proposed in #11143, it _is_ clear: Since no default parameter set is designated, argument-less invocation is allowed (as is invocation with only all-parameter-sets arguments) and makes `__AllParameterSets` the effective parameter set.\r\n**You're asking for Del [enter] to delete all files.** \r\n\r\n \r\n> Of course, if you have just _one_ explicit parameter set whose parameter you want to be mandatory _unconditionally_, there is no good reason to use an explicit parameter set at all: simply replace `[Parameter(ParameterSetName=\"ByName\",Mandatory=$true)]$Name` with `[Parameter(Mandatory=$true)]$Name`\r\n\r\nYou're completely correct, that code should never get written. But in a world where people add bits and remove bits if \"orphaned\" bits like that do occur. If PowerShell is presented with it, is it certain that I have not ended up with one parameter set by deleting other things and so the parameter needs to be mandatory. If I wanted it _not_ to be mandatory I could remove \"mandatory\" if I wanted it to be unconditionally mandatory I could remove the set  When there is ambiguity it doesn't run the code. And  \r\n",
      "created_at": "2019-11-28T00:08:53Z",
      "updated_at": "2019-11-28T00:08:53Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> Would it delete information from my production database ?\r\n\r\nIt just might, depending on context.\r\n\r\nThe point is: There is no substitute for (a) understanding the language features you're working with and (b) testing thoroughly before performing potentially destructive actions.\r\n\r\n> `foo -replace` doesn't parse (but I would have required replace to have the replacement string;\r\n\r\nI, for one, greatly appreciate the convenience of _not_ having to specify the replacement string, because defaulting to `''` is a _sensible, time-saving, concision-promoting default_.\r\n\r\nIn other words: You can shoot yourself in the foot with _any_ language feature, but that shouldn't get in the way of implementing sensible default behavior.\r\n\r\n> Dividing into one group makes no sense.\r\n\r\nIt makes sense if there's an _implied_ other group, which there is is - sometimes: let's make it consistent. If you're not aware of this implied other group, you wouldn't have a reason to create the explicit group to begin with.\r\n\r\n> If the set can exist without a parameter\r\n> it's shorter to use `$PSBoundParameters.Keys -match \"^(Pone|Ptwo)$\"\r\n\r\nThat alternative is both obscure and fragile.\r\n\r\n> Either the author wants the only set they have declared to be default set\r\n\r\nThen they shouldn't have declared a n explicit set to begin with.\r\n\r\n> But in a world where people add bits and remove bits if \"orphaned\" bits like that do occur.\r\n\r\nAgain: you need to understand the feature you're working with, and you must test your use of them.\r\n\r\nAny feature allows you to use it in ways that don't make sense, and it's infeasible to guard against all possible unintended uses.\r\n",
      "created_at": "2019-11-28T02:15:31Z",
      "updated_at": "2019-11-28T02:15:47Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Another approach to resolving the current inconsistencies and obscure failures, namely one that favors the explicit expression of intent you prefer, would be the following:\r\n\r\nNote: This is a more fundamentally breaking than the proposal in #11143, but perhaps with opt-in features being considered to avoid breaking changes, this is an option:\r\n\r\n* Enforce the following _at parse time_ to signal that there's a fundamental problem with the function that needs resolving, as opposed to the current _situational_ failures that depend on the specifics of a given invocation. This also has the advantage of being able to provide a specific error messages with clear resolution directions.\r\n\r\n  * If an explicit parameter set is associated with at least one parameter, enforce designating the default parameter set in `[CmdletBinding()]` to avoid ambiguity and signal explicit intent.\r\n\r\n  * References to otherwise undefined parameter sets in `[CmdletBinding()]` won't be permitted.\r\n\r\n\r\n* `[CmdletBinding(DefaultParameterSetName='')]` will signal the explicit intent to allow invocations without parameters altogether, as well as invocations comprising all-parameter-sets parameters only.\r\n\r\n  * `$PSCmdlet.DefaultParameterSetName` will then reflect `''` (the empty string).\r\n\r\n* While we're at: Let's drop the unnecessary `Name` suffix from the `DefaultParameterSetName` and `ParameterSetName` properties.\r\n\r\n",
      "created_at": "2019-11-28T13:19:37Z",
      "updated_at": "2019-11-29T21:28:42Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> The point is: There is no substitute for (a) understanding the language features you're working with and (b) testing thoroughly before performing potentially destructive actions.\r\n\r\nI don't think anyone would disagree with that point. But if one tests a script to ensure that today it can't run without parameters, and then someone changes the language so that  it will run and do damaging things with no parameters, it puts the onus on the script author to go back and re-test every script for every release of the language.  They won't do that, and then the people who made the change are blamed for the result. \r\n\r\nI wrote `\"a\", \"b\", \"d\". \"e\", \"f\" | delete-something `  earlier in the year. and that . after d functions as an operator even with a space after it. So my line read, `\"a,\" \"b\", the 'e' property of the string \"d\" , \"f\"` and the script (not mine) deleted a*, b*, * and f* . I can bluster all I want that . should never  be \"member\" if followed by white space but there may be people whose code depends on being able to just that.  One can't break their scripts to wrap people who make an error like that one in cotton wool. \r\n\r\n\r\n> \r\n> > `foo -replace` doesn't parse (but I would have required replace to have the replacement string;\r\n> \r\n> I, for one, greatly appreciate the convenience of _not_ having to specify the replacement string, because defaulting to `''` is a _sensible, time-saving, concision-promoting default_.\r\n\r\nIts an allowed shortcut it might make it harder for someone who doesn't know that behaviour to read a script (because it is an undocumented feature) \r\nOne could make a case that -join or -split without parameter should join assume '' but that means the operator is sometimes unary and sometimes binary which makes it hard to implement.  \r\n**IF** things had be designed to require 2 values (my way and the way the [Regex] object works), there is a sound case to say \"allow the shortcut\", because no-one would have code out there which worked in a particular way with a single value.\r\nHowever now that things **don't** happen that way if I convinced people that it the second operand must error if it has 1 or 3 values that would break existing scripts. Worse, your scripts which relied on that behaviour to remove something would (1) give a non-terminating error, (2) not remove something and (3) blunder on to use the wrong string with who-knows-what consequences.  Sometimes the status-quo might not be \"best\" way but a **change causes adverse consequences** which outweigh the improvement..  Arguing for a sub-optimum status-quo isn't something many people like doing. But sometimes that's what you have to do to avoid doing harm. \r\n \r\n\r\n> In other words: You can shoot yourself in the foot \r\n\r\nDid you know \"Shooting oneself in the foot\" isn't about poor skills with a gun. Soldiers in WWI used did it to get out of fighting. Depending on who you say \"He shot himself in the foot\" to, they may think you're describing took one negative to because the feared something else.  \r\n\r\n \r\n> > Dividing into one group makes no sense.\r\n> \r\n> It makes sense if there's an _implied_ other group, which there is is - sometimes: let's make it consistent. If you're not aware of this implied other group, you wouldn't have a reason to create the explicit group to begin with.\r\n\r\nPowerShell creates the extra group instead of throwing an error - and doing so helps test code before it is complete. Expanding the scope of it would change the behaviour of scripts which run on PowerShell up to V6, in a way which is dangerous. \r\n\r\n> \r\n> > If the set can exist without a parameter\r\n> > it's shorter to use `$PSBoundParameters.Keys -match \"^(Pone|Ptwo)$\"\r\n> \r\n> That alternative is both obscure and fragile.\r\n\r\nNot at all . And I, for one, greatly appreciate the convenience of being able to use a simple regex rather than attach parameter attributes, and be able to see that condition applies to Parameter_one and _two at the point the conditional code executes and not scroll up to look at the attributes. \r\n\r\n> > Either the author wants the only set they have declared to be default set\r\n> \r\n> Then they shouldn't have declared a n explicit set to begin with.\r\n\r\nYou're right.   But after a painful series of edits by authors who didn't talk to each other the script ended up like that. Should a future version of PowerShell work like all past versions. Or should it assume the author wrote this script with this version of PowerShell in mind ?  It's a choice between making you declare a second parameter set and trashing other people's systems.  \r\n\r\n> > But in a world where people add bits and remove bits if \"orphaned\" bits like that do occur.\r\n> \r\n> Again: you need to understand the feature you're working with, and you must test your use of them. \r\n\r\nWhen a script was written by someone who understood how things worked at the time lives in production for years, and is supported by people with less knowledge, that because a laudable but unacheivable goal. \r\n\r\n> Any feature allows you to use it in ways that don't make sense, and it's infeasible to guard against all possible unintended uses.\r\n\r\nAll possible ? Probably.  Del doesn't delete all your files if you run it with no parameters. Why not ? We run del *.* more than any other version of the command it would be a huge time saver. \r\nMost  commands which need an input won't run without the input. **You're arguing that scripts and functions which don't run without input today, should start running without input in the future.**  It's the equivalent of saying next years version of a dangerous piece of machinery should have the safety guards removed, and if people who relied on them lose arms, they should have understood the machine wasn't the same as ones they used before. \r\n  \r\n",
      "created_at": "2019-11-28T13:59:16Z",
      "updated_at": "2019-11-28T14:02:12Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> You're arguing that scripts and functions which don't run without input today, should start running without input in the future.\r\n\r\nNo. As stated in my proposal in #11143 and the [alternative above](https://github.com/PowerShell/PowerShell/issues/11201#issuecomment-559491980), they are _breaking changes_, although in different ways: #11143 would make things more permissive, the alternative would make things stricter.\r\n\r\nI can see the appeal of the stricter approach, but in either case the breaking nature must be managed.\r\n\r\nNote that from your perspective the status quo has _insufficient_ safeguards, and fixing that would mean that existing scripts could break.\r\n",
      "created_at": "2019-11-28T15:16:25Z",
      "updated_at": "2019-11-28T15:16:25Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> > You're arguing that scripts and functions which don't run without input today, should start running without input in the future.\r\n> \r\n> No. As stated in my proposal in #11143 \r\n\r\nThat says \r\n\r\n> > If an advanced function or script doesn't explicitly declare a default parameter set via its [CmdletBinding()] attribute:\r\n> > \r\n> > * Always allow invocations without arguments  \r\n> > \r\n\r\nToday with no input this doesn't run. It has no cmdletbinding attribute and the *  line says it would always be allowed to run without arguments, deleting all data. \r\n\r\n```powershell \r\nFunction BadOne {\r\nparam (\r\n    [Parameter(ParameterSetName=\"ByID\")]$ID,\r\n    [Parameter(ParameterSetName=\"ByName\")]$Name,\r\n    $waitForServer \r\n)\r\n    if ($ID) {runsql \"Delete from Foo where ID = $ID\"} \r\n    else     {runsql \"Delete from foo where name like '$name*'\"}\r\n    if ($waitForServer) {Start-Sleep $waitForServer}\r\n}\r\n\r\n```\r\n\r\nYour second bullet point it that says:\r\n\r\n- Specifically, do not try to infer a default parameter set from among the explicit ones for parameter-less or only all-parameter-sets parameter invocations.\r\n\r\nWhich breaks this script. \r\n```PowerShell\r\nFunction OKOne {\r\nparam (\r\n    [Parameter(ParameterSetName=\"X\",Mandatory=$True)]$East,\r\n    [Parameter(ParameterSetName=\"Y\")]$North,\r\n    $waitForServer \r\n)\r\n    if ($PSCmdlet.ParameterSetName -eq \"Y\") {\r\n        \"Process North South\" \r\n    }\r\n}\r\n```\r\n\r\n Both types of script are common enough that I've encountered multiple clients with scripts which fit one or both patterns.  \r\n\r\n> Note that from your perspective the status quo has _insufficient_ safeguards, and fixing that would mean that existing scripts could break.\r\n\r\nWell yes, I tried to make the point that it is not about strictness or laxness - as I said, if existing things were made more to my taste (stricter languages - that's how I was taught, I'm stuck with that bias) it could be every bit as bad as making them more to your taste. In my view, very little is broken as things stand: current safeguards are adequate without being excessive; things tend to fail safely, and where shortcuts are denied the extra work is tolerable. \r\n\r\n\r\n**I had an idea.** If there were something named differently, let's call it a \"LooseSet\" , it could do \r\nanything you wanted and not break existing scripts. \r\n```\r\nParam (\r\n  [parameter(looseSet=A,Mandatory)]$x \r\n  [parameter(looseSet=A)]$y\r\n  $z \r\n)\r\n```\r\n\r\nWould not allow X without Y, but would allow just Z or nothing at all \r\n\r\n```\r\nParam (\r\n  [parameter(looseSet=one,)]$a\r\n  [parameter(looseSet=one)]$b\r\n  [parameter(looseSet=Two,)]$c\r\n  [parameter(looseSet=Two)]$d \r\n)\r\n```\r\n\r\nWould allow no parameters and support a check something to see if you had been passed a or b, or passed c or d without demanding one has a mandatory parameter, or [cmdletbinding] adds a set. \r\nThis could sit in parallel with what exists, **breaks nothing,** and any explanation would say why they were different from parameter sets and what steps need to be taken to ensure the body isn't dangerous. \r\n \r\n\r\n",
      "created_at": "2019-11-28T16:55:29Z",
      "updated_at": "2019-11-28T16:55:29Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "What would break is already spelled out in #11143. I understand that you think that is dangerous.\r\nReflecting on that is what made me propose [the alternative](https://github.com/PowerShell/PowerShell/issues/11201#issuecomment-559491980), which I am now leaning toward.\r\n\r\nIt would give you the strictness you desire while eliminating inconsistencies and providing clear failure cases with specific error messages.\r\n\r\nBut, of course, it is a breaking change that script authors would have to [_opt into_](https://github.com/PowerShell/PowerShell-RFC/pull/220)  or - God forbid / allow - the right approach for [a future PowerShell version not saddled with technical debt](https://github.com/PowerShell/PowerShell/issues/6745).\r\n\r\nPersonally, I'm not interested in fixing the current behavior _in a backward-compatible fashion_ (except for the obvious bug that prompted this issue), introducing a new property increases complexity and doesn't eliminate the existing inconsistencies and obscure failures.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2019-11-28T17:24:51Z",
      "updated_at": "2019-11-28T17:24:51Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "That's a misuse of \"Technical debt\". Things which are imperfect are not automatically technical debt;  things which have escalating cost (like interest), can't be avoided forever (like repayment) but are ducked to meet a deadline generally are. \r\n\r\n> Personally, I'm not interested in fixing the current behavior _in a backward-compatible fashion_\r\n\r\nWell that's the end of that discussion then.   Re-read of what Bruce said on that other thread.  He's smarter than both of us put together.  And I'll leave this here. Have a good life. \r\n\r\nhttps://github.com/PowerShell/PowerShell/issues/6745#issuecomment-483926648\r\n",
      "created_at": "2019-11-28T19:12:37Z",
      "updated_at": "2019-11-28T19:13:00Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> That's a misuse of \"Technical debt\"\r\n\r\nGood point, thank you for the correction. I've always used [_technical debt_](https://en.wikipedia.org/wiki/Technical_debt) loosely (but incorrectly) to mean \"accumulated broken behavior that can't be fixed without breaking backward-compatibility\", but I do hope it's clear from the _content_ of #6745 that the latter is what I actually _meant_.\r\n\r\n> Well that's the end of that discussion then\r\n\r\nIt's the end of my personal involvement in the specific debate of how to improve parameter-set handling _without breaking backward compatibility_, because:\r\n\r\n* (a) you can _work around_ the existing limitations by simply designating a made-up parameter set in the `[CmdletBinding()]` attribute - no need for introducing additional properties such as `looseSet`\r\n\r\n* (b) the _fundamental problems_ with the current behavior _cannot be fixed_ if maintaining backward compatibility is the premise.\r\n\r\nTherefore, my personal interest is limited to _exploring how to solve the problem fundamentally_, with two possible outcomes:\r\n\r\n* Ideally, a fundamental solution can be implemented and users can at least _opt in_ or, perhaps, some day, there will be a \"vNext\" in which a fundamental solution can be the _default_.\r\n\r\n* At the very least, it's important to have clarity on how things _should_ work, which helps guide future design decisions.\r\n\r\n> Re-read of what Bruce said on that other thread. \r\n\r\nYou're linking to a comment by @JayKul, which refers to a (perceived) _fiat_ decision by the powers that be. Contrast this with [this statement](https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-552533786), for instance.\r\n\r\n> He's smarter than both of us put together.\r\n\r\nThe merit of someone's argument is unrelated to your perception of their level of intelligence.\r\n\r\n> Have a good life.\r\n\r\nPlease refrain from making such comments. They add nothing to the discussion and serve only to antagonize.\r\n\r\n",
      "created_at": "2019-11-29T02:40:42Z",
      "updated_at": "2019-11-29T23:27:09Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov, can you please label this issue as a bug?\r\n\r\nThe surrounding discussion aside, the original problem described in the initial post is a clearly an easily verifiable bug in the context of the current behavior.\r\n\r\nIf you want a simpler repro:\r\n\r\n```powershell\r\n# Just press Enter when prompted; passing a -Foo argument makes the problem go away.\r\n& { [CmdletBinding()] param([Parameter(Mandatory, ParameterSetName='ByFoo')] $Foo) $PSCmdlet.ParameterSetName } | Should -Be ByFoo\r\n```\r\n\r\n",
      "created_at": "2019-11-29T14:17:02Z",
      "updated_at": "2019-11-29T19:22:40Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> > Have a good life.\r\n> \r\n> Please remain from making such comments. They add nothing to the discussion and serve only to antagonize.\r\n\r\nYou are too willing to be be antagonized without realizing that you antogoize others. For clarity, that was intended to mean **\"I will discuss maters with with you no further; but I bear you no ill will\"** . Since it is obvious that you're not especially concerned if a change renders the new product unadoptable, don't accept that (e.g) Bruce Payette is more likely to know what's good and bad than you or I, and seem to want to argue every point and the language used, you appear to want to test the second half, but the first half stands. I should, perhaps have known better than to expect you to take a wish of a good future in the spirit it was meant. I won't reply further.   ",
      "created_at": "2019-11-29T14:22:27Z",
      "updated_at": "2019-11-29T14:23:27Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@jhoneill I wonder why you throw an exception on good discussion? :-) Please be patient and follow [CoC](https://github.com/PowerShell/PowerShell/blob/master/CODE_OF_CONDUCT.md). @mklement0 too - please ignore personal comments - it is moderator's headache :-)\r\n\r\n@jhoneill As for your concern. Sometimes we change the mind to the opposite, even in global things. For example, for PowerShell 6 a main rule was \"To have only ported cmdlets\", all window-only cmdlets was removed (with one exception), But for PowerShell 7 the rule was changed to \"To have easy adoption for Windows users\". As result some Windows-only cmdlet was added back. This happened because Windows users do not want to use limited PowerShell version and stay on Windows PowerShell. We get this understanding only after collect statistics for 2 years. \r\nFor the discussion we want to collect all points, concerns and ideas so that get more full understanding the problem. Perhaps we reject this today but can accept 2-3 years later. Or forget at all :-) Be patient please.\r\n \r\n",
      "created_at": "2019-11-29T19:19:46Z",
      "updated_at": "2019-11-29T19:19:46Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "@iSazonov  My patience is finite, so is my time, and engaging with MK has proved to be excessively  demanding of both. \r\nPowerShell 6 has not displaced Windows PowerShell because too many things do not work. That's being addressed in 7: if people are persuaded that what they have worked for 10+ years moves to 7 safely and reliably we get progress; otherwise I'll be working on 5.1 until I retire.  I'll point you at Bruce's comment \r\n>even relatively small changes on a core path can seriously hinder adoption. Look at Python 3. It took 10 years to really catch on.\r\n\r\nIf someone wants to say they know better than Bruce, and proclaim  \r\n> I'm not interested in fixing the current behavior in a backward-compatible fashion\r\n\r\nthen it's better for me, and for the general tone if I leave them to it.  ",
      "created_at": "2019-11-29T22:45:57Z",
      "updated_at": "2019-11-29T22:45:57Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@jhoneill:\r\n\r\n> engaging with MK has proved to be excessively demanding of both.\r\n\r\nPlease refrain from making such comments. They add nothing to the discussion and serve only to antagonize.\r\n\r\n> If someone wants to say they know better than Bruce\r\n\r\nDeferring to whom you perceive to be an authority is your personal choice, but doing so has no place in a rational debate.\r\n\r\n@iSazonov:\r\n\r\n> please ignore personal comments - it is moderator's headache :-)\r\n\r\nI understand, and I will keep that in mind - I wasn't even aware that moderation of such matters was being performed. (Does what is described [here](https://opensource.microsoft.com/codeofconduct/faq/#howreport) happen routinely?)\r\n\r\nOn what - I promise - is a one-time explanation:\r\n\r\nWhile _ignoring_ personal comments is certainly an option, my personal preference is to:\r\n\r\n*  (a) hold people accountable for their actions, \r\n\r\n* _and_ (b) seek to instill an understanding as to _why_ ad hominem comments are uncalled for.\r\n\r\nI agree that, in the face of the apparent futility of (b) here, I should have stopped much earlier (though, except for the [original plea](https://github.com/PowerShell/PowerShell/issues/11143#issuecomment-557619954), all comments regarding the unwarranted personal dimension were addressed in the context of comments primarily focused on discussing the issue at hand).\r\n\r\n",
      "created_at": "2019-11-29T23:36:55Z",
      "updated_at": "2019-11-29T23:36:55Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> > engaging with MK has proved to be excessively demanding of both.\r\n> \r\n> Please refrain from making such comments. They add nothing to the discussion and serve only to antagonize.\r\n\r\nIt is interesting that you have used _It adds/they add nothing to the discussion and serve only to antagonize._  three times as if it is a common response: the bullet points sound like someone who has a prepared strategy when they choose to be antagonized. Others might wonder _why_ they attract that kind of comment.   \r\nHow I see the the consumption of my time, and how I feel the strain on my patience is as a valid a thing for me to express as any thought of yours.   To categorize that view as an ad hominem attack suggests you might be well advised to avoid Latin tags - I had to study Latin so even its correct use doesn't impress me; when people use it for \"he said something I don't like\" ...  describing the effect would, to coin a phrase, serve only to antagonize.\r\nMy view is that I have wasted too much time responding to postings which only the work of Dunning & Kruger can explain. Having recognized that, I won't you goad me into wasting any more.   \r\n",
      "created_at": "2019-11-30T01:37:29Z",
      "updated_at": "2019-11-30T01:37:29Z"
    }
  ],
  "created_at": "2019-11-26T18:03:55Z",
  "number": 11201,
  "state": "closed",
  "title": "A prompt for a mandatory parameter can cause $PSCmdlet.DefaultParameterSetName to reflect the wrong parameter set",
  "updated_at": "2019-12-02T14:39:10Z"
}