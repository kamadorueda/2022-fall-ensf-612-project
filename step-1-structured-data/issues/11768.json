{
  "_url": "https://github.com/PowerShell/PowerShell/issues/11768",
  "author": "SeeminglyScience",
  "body": "# Summary of the new feature/enhancement\r\n\r\nCurrently there isn't much you can do with `System.Memory<T>` other than create it, pass it to a method and allocate a new array from it.  Most of the functionality is actually attached to the property `Span` which PowerShell is unable to use.\r\n\r\nWhile this type might not be incredibly applicable to PowerShell users today, it is going to be utilized more and more by the framework itself and third party libs as time goes on. Some basic support for at least enumerating and accessing by index would go a long way.\r\n\r\n# Proposed technical implementation details (optional)\r\n\r\nSpecial casing in the binder should be added to enable either direct indexing of `System.Memory` \r\n\r\n```powershell\r\n$memory = [Memory[int]][int[]](0..10)\r\n\r\n# Should return 0\r\n$memory[0]\r\n\r\n# Should set index 0 to 1\r\n$memory[0] = 1\r\n\r\n# Should enumerate\r\nforeach ($i in $memory) {\r\n}\r\n```\r\n\r\n<details>\r\n\r\n<summary><sub>Alternate, more complicated proposal</sub></summary>\r\n\r\nOr specifically for indexing, enable the usage of `System.Span` *when accessed directly from `Memory`*.  This might be the most idea route for understandably (since `Memory` doesn't have an indexer) but might also be impossible with how the binder is set up.\r\n\r\n```powershell\r\n$memory = [Memory[int]][int[]](0..10)\r\n\r\n# Should return 0\r\n$memory.Span[0]\r\n\r\n# Should set index 0 to 1\r\n$memory.Span[0] = 1\r\n\r\n# This will still throw\r\nforeach ($i in $memory.Span) {\r\n}\r\n\r\n# This will still throw\r\n$i = $memory.Span\r\n$i[0]\r\n```\r\n\r\n</details>\r\n\r\n---\r\n\r\n<details>\r\n<summary>(Click to expand)\r\n\r\n## Indexing example implementation\r\n</summary>\r\n\r\nIndexing is complicated slightly by the fact that `System.Linq.Expressions.Expression` does not seem to support `ref` returns at all, and `Span.Item` is a ref indexer.  One way to get around this would be a proxy method:\r\n\r\n<sub>(Note: example not optimized)</sub>\r\n\r\n```csharp\r\nnamespace System.Management.Automation\r\n{\r\n    internal static class CompilerOps\r\n    {\r\n        public static T GetSpanIndex<T>(Span<T> span, int index) => span[index];\r\n\r\n        public static void SetSpanIndex<T>(Span<T> span, int index, T value)\r\n            => span[index] = value;\r\n    }\r\n\r\n    internal partial class Compiler\r\n    {\r\n        private static Expression GetMemoryIndex(\r\n            Expression expression,\r\n            Expression target)\r\n        {\r\n            return Expression.Call(\r\n                instance: null,\r\n                typeof(CompilerOps).GetMethod(nameof(CompilerOps.GetSpanIndex)),\r\n                Expression.Property(expression, nameof(Memory<int>.Span)),\r\n                target);\r\n        }\r\n\r\n        private static Expression SetMemoryIndex(\r\n            Expression expression,\r\n            Expression target,\r\n            Expression value)\r\n        {\r\n            return Expression.Call(\r\n                instance: null,\r\n                typeof(CompilerOps).GetMethod(nameof(CompilerOps.SetSpanIndex)),\r\n                Expression.Property(expression, nameof(Memory<int>.Span)),\r\n                target,\r\n                value);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n</details>\r\n\r\n<details>\r\n<summary>(Click to expand)\r\n\r\n## Enumerable example implementation\r\n</summary>\r\n\r\n<sub>(Note: example not optimized)</sub>\r\n\r\n```csharp\r\nnamespace System.Management.Automation\r\n{\r\n    internal class MemoryEnumerable<T> : IEnumerable<T>\r\n    {\r\n        private readonly ReadOnlyMemory<T> _memory;\r\n\r\n        internal MemoryEnumerable(ReadOnlyMemory<T> memory) => _memory = memory;\r\n\r\n        public IEnumerator<T> GetEnumerator() => new Enumerator(_memory);\r\n\r\n        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\r\n\r\n        private class Enumerator : IEnumerator<T>\r\n        {\r\n            private readonly ReadOnlyMemory<T> _memory;\r\n\r\n            private readonly int _length;\r\n\r\n            private int _index;\r\n\r\n            public Enumerator(ReadOnlyMemory<T> memory)\r\n            {\r\n                _memory = memory;\r\n                _index = -1;\r\n                _length = memory.Length;\r\n            }\r\n\r\n            public T Current\r\n            {\r\n                get\r\n                {\r\n                    if (_index < 0) throw new InvalidOperationException(\"Enumeration has not started. Call MoveNext.\");\r\n                    if (_index >= _length) throw new InvalidOperationException(\"Enumeration already finished.\");\r\n\r\n                    return _memory.Span[_index];\r\n                }\r\n            }\r\n\r\n            object IEnumerator.Current => Current;\r\n\r\n            public bool MoveNext() => _index < _length && (++_index) < _length;\r\n\r\n            public void Reset() => _index = -1;\r\n\r\n            public void Dispose()\r\n            {\r\n            }\r\n        }\r\n    }\r\n\r\n    internal partial class PSEnumerableBinder\r\n    {\r\n        public static DynamicMetaObject BindForMemory(DynamicMetaObject target, DynamicMetaObject[] args)\r\n        {\r\n            Type type = target.Value.GetType();\r\n            if (!type.IsGenericTypeDefinition)\r\n            {\r\n                return null;\r\n            }\r\n\r\n            Type openGeneric = type.GetGenericTypeDefinition();\r\n            if (!(openGeneric == typeof(ReadOnlyMemory<>) || openGeneric == typeof(Memory<>)))\r\n            {\r\n                return null;\r\n            }\r\n\r\n            Type memoryType = type.GetGenericArguments()[0];\r\n            Type enumerableType = typeof(MemoryEnumerable<>).MakeGenericType(memoryType);\r\n            return new DynamicMetaObject(\r\n                Expression.New(\r\n                    enumerableType.GetConstructor(\r\n                        BindingFlags.Instance | BindingFlags.NonPublic,\r\n                        binder: null,\r\n                        new[] { type },\r\n                        modifiers: null)),\r\n                PSEnumerableBinder.GetRestrictions(target));\r\n        }\r\n    }\r\n}\r\n```\r\n</details>",
  "closed_at": "2021-07-26T20:43:18Z",
  "comments": [
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "+1; just to tie this to the larger suggestion to support generics (more) comprehensively: #5146",
      "created_at": "2020-02-04T16:42:16Z",
      "updated_at": "2020-02-04T16:42:16Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "@daxian-dbw @vexx32 Could the work group discuss this? Specifically whether a PR would be accepted to make the following syntax work:\r\n\r\n```powershell\r\n$memory = [Memory[int]][int[]](0..10)\r\n\r\n# Should return 0\r\n$memory[0]\r\n\r\n# Should set index 0 to 1\r\n$memory[0] = 1\r\n```\r\n\r\nNote that you can't do this in C# either, in C# you need to access `memory.Span[0]`. Trying to fit that into PowerShell's binder would be very challenging though.  If it is deemed acceptable to fake this indexer, I can provide a PR.",
      "created_at": "2021-07-09T12:43:01Z",
      "updated_at": "2021-07-09T12:43:01Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "We discussed this in the Engine Working Group last week and had the following thoughts:\r\n\r\n- The request here is for language-level special casing/support for a very specific type\r\n- We don't really have any motivating scenarios described here and generally it's not clear how useful enhanced support of memory types would be for most PowerShell users, compared to just falling back to C#\r\n- There's some concern about handling stack-based value types safely in a language as heap-oriented as PowerShell\r\n- It would probably require significant effort to implement the proposed changes within PowerShell itself, so we'd want to be able to justify that with significant impact\r\n\r\nWith those thoughts in mind, we think handling of memory types is better done with a set of cmdlets in a standalone module than baked into PowerShell and that we should decline this PowerShell feature request.",
      "created_at": "2021-07-26T16:56:25Z",
      "updated_at": "2021-07-26T16:56:25Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "Fair enough.  One point of clarification:\r\n\r\n> There's some concern about handling stack-based value types safely in a language as heap-oriented as PowerShell\r\n\r\n`Memory<>` is the heap only version of `Span<>`.  The point of the proposed feature is because the intended way to use `Memory<>` is via the `Span` property which is not usable in PowerShell due to it's possibility of being stack based (when not returned from `Memory`).\r\n\r\n---\r\n\r\nIf anyone else wants this feature they will need to champion it, I will be accepting the WG's decision.",
      "created_at": "2021-07-26T20:43:17Z",
      "updated_at": "2021-07-26T20:43:17Z"
    }
  ],
  "created_at": "2020-02-04T13:34:17Z",
  "number": 11768,
  "state": "closed",
  "title": "Support accessing System.Memory",
  "updated_at": "2021-07-26T20:43:18Z"
}