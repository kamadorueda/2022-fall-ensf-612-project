{
  "_url": "https://github.com/PowerShell/PowerShell/issues/11198",
  "author": "iSazonov",
  "body": "<!-- Anything that looks like this is a comment and can't be seen after the Pull Request is created. -->\r\n\r\n# PR Summary\r\n\r\nAddress #8393\r\n\r\n1. Move to new .Net Core Json API. Detects and throws on cycles and depth.\r\n2. Add PSObject, DBNull, NullString, Enum64 Json converters\r\n3. Add JsonIgnoreAttribute support. Address #6847\r\n4. Set Depth default to 64 (.Net Core default). It is good compromise: still no hangs and exceptions for common scenarios but noticeable delays are if problems exist.\r\n5. Set MaxDepthAllowed = 1000. It is .Net Core limitation.\r\n6. Fix #9847 as side effect.\r\n7. Escaping based on new .Net Core Json API. 'Default' is nearly like previous. 'EscapeHtml' - more differences, 'EscapeNonAscii' now like 'Default' but could be improved but I did not found noticeable using EscapeHtml and EscapeNonAscii on GitHub.\r\n8. Cancellation doesn't work (I guess only hosted scenarios are affected). Underlying sync API don't support this. I did not found reasons to switch to async Json API. See https://github.com/dotnet/runtime/issues/611\r\n9. Depth parameter is renamed to MaxDepth to more accurately reflect the new semantics.\r\n\r\n## PR Context\r\n\r\n<!-- Provide a little reasoning as to why this Pull Request helps and why you have opened it. -->\r\nhttps://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to\r\n\r\n## PR Checklist\r\n\r\n- [x] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [x] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [ ] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` or `[ WIP ]` to the beginning of the title (the `WIP` bot will keep its status check at `Pending` while the prefix is present) and remove the prefix when the PR is ready.\r\n- **[Breaking changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)**\r\n    - [ ] None\r\n    - **OR**\r\n    - [ ] [Experimental feature(s) needed](https://github.com/MicrosoftDocs/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/About/about_Experimental_Features.md)\r\n        - [ ] Experimental feature name(s): <!-- Experimental feature name(s) here -->\r\n- **User-facing changes**\r\n    - [ ] Not Applicable\r\n    - **OR**\r\n    - [x] [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n- **Testing - New and feature**\r\n    - [ ] N/A or can only be tested interactively\r\n    - **OR**\r\n    - [ ] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n- **Tooling**\r\n    - [ ] I have considered the user experience from a tooling perspective and don't believe tooling will be impacted.\r\n    - **OR**\r\n    - [ ] I have considered the user experience from a tooling perspective and enumerated concerns in the summary. This may include:\r\n        - Impact on [PowerShell Editor Services](https://github.com/PowerShell/PowerShellEditorServices) which is used in the [PowerShell extension](https://github.com/PowerShell/vscode-powershell) for VSCode (which runs in a different PS Host).\r\n        - Impact on Completions (both in the console and in editors) - one of PowerShell's most powerful features.\r\n        - Impact on [PSScriptAnalyzer](https://github.com/PowerShell/PSScriptAnalyzer) (which provides linting & formatting in the editor extensions).\r\n        - Impact on [EditorSyntax](https://github.com/PowerShell/EditorSyntax) (which provides syntax highlighting with in VSCode, GitHub, and many other editors).\r\n",
  "closed_at": "2022-04-16T19:12:21Z",
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 @adamdriscoll  @rkeithhill @CollinChaffin @msftrncs @markekraus @vexx32 @SteveL-MSFT @daxian-dbw @iRon7 @mdalepiane \r\nWelcome to download compiled artifact and discuss. Please also look failed tests that can be useful for the discussion.",
      "created_at": "2019-11-26T05:50:37Z",
      "updated_at": "2019-11-26T05:50:37Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 Now new ConvertTo-Json is ready for your investigations.",
      "created_at": "2019-12-06T14:49:36Z",
      "updated_at": "2019-12-06T14:49:36Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee reviewed this, we ask that the new use of .NET Core APIs be an Experimental Feature so that users can disable it, if needed, and use the existing code paths.",
      "created_at": "2019-12-11T23:11:01Z",
      "updated_at": "2019-12-11T23:11:01Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@SteveL-MSFT One thing does still not clear for me - should we keep old behavior with a switch (-UseWindowsPowerShellConverter)?",
      "created_at": "2019-12-12T11:46:16Z",
      "updated_at": "2019-12-12T11:46:16Z"
    },
    {
      "author": "bpayette",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov Rather than using a fixed serialization depth for all types, can we leverage TypeData's `SerializationDepth` property to do smarter JSON serialization?",
      "created_at": "2019-12-12T18:21:21Z",
      "updated_at": "2019-12-12T18:21:21Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> smarter JSON serialization\r\n\r\n@bpayette What do you mean under \"smarter\"?\r\nCurrent behavior of ConvertTo-Json is dangerous - _we can lost data_. I believe this is unacceptable and the cmdlet should throw if conversion is impossible. \r\nAlso original implementation of the cmdlet uses Depth for protecting from cycles.\r\nNew Core API detects cycles and allows us to convert without data lost.\r\nIt is smarter JSON serialization for me.\r\n",
      "created_at": "2019-12-12T18:35:23Z",
      "updated_at": "2019-12-12T18:36:41Z"
    },
    {
      "author": "ThomasNieto",
      "author_association": "CONTRIBUTOR",
      "body": "Using PS Type Data for serialization configuration will make the user experience consistent between formats (json/clixml).",
      "created_at": "2019-12-12T19:22:40Z",
      "updated_at": "2019-12-12T19:22:40Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@ThomasNieto Can you share an example?",
      "created_at": "2019-12-12T19:28:38Z",
      "updated_at": "2019-12-12T19:28:38Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> One thing does still not clear for me - should we keep old behavior with a switch (-UseWindowsPowerShellConverter)?\r\n\r\n@iSazonov Do not change any of the existing `ConvertTo-Json` code. Instead, implement another `ConvertTo-Json` in a separate class, say`ConvertToJsonCommand2`. Then apply `ExperimentalFeatureAttribute` to both `ConvertToJsonCommand` and `ConvertToJsonCommand2` just like the following:\r\n\r\n```\r\n[ExperimentalFeature(\"NewConvertToJson\", ExperimentAction.Hide)]\r\n[Cmdlet(\"ConvertTo\", \"Json\", ....)]\r\npublic class ConvertToJsonCommand : PSCmdlet { ... }\r\n\r\n[ExperimentalFeature(\"NewConvertToJson\", ExperimentAction.Show)]\r\n[Cmdlet(\"ConvertTo\", \"Json\", ....)]\r\npublic class ConvertToJsonCommand2 : PSCmdlet { ... }\r\n```",
      "created_at": "2019-12-12T22:24:27Z",
      "updated_at": "2019-12-12T22:24:27Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@daxian-dbw Thanks! I will use the pattern. But my question was - do we need to keep old converter in the updated cmdlet?",
      "created_at": "2019-12-13T06:44:00Z",
      "updated_at": "2019-12-13T06:44:00Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "I don't know about the \"old converter\". You can start from implementing just what you need for the new implementation.",
      "created_at": "2019-12-13T17:19:58Z",
      "updated_at": "2019-12-14T01:22:52Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "(Sorry if you saw the lengthy comment I had posted briefly and then deleted.)\r\n\r\nLooking more at how the `System.Text.Json` API works and reflecting on the design goals of PowerShell remoting, I don't think there's value in aligning with the serialization performed there (as happens implicitly during remoting / in background jobs and as explicitly accessible via `Export-CliXml`), because the intent is fundamentally different:\r\n\r\n`-Depth` / the implicitly applied depth  in implicit remoting serialization / `Export-CliXml` (and, regrettably, also in the old `ConvertTo-Json`) means:\r\n\r\n* \"Quietly cut this object graph off at the specified depth, even if it goes deeper - loss of information is acceptable\".\r\n\r\nWhile this is appropriate behavior for the  potentially - unavoidably - _lossy_ serialization/deserialization that occurs in remoting (and background jobs);  it is _not_ appropriate for JSON communication: there you always want to serialize the input _in full, without loss of information_, and you need to be alerted _when that's not possible_.\r\n\r\nThe new API's `JsonSerializer.Serialize()` gives us this behavior by default:\r\n\r\n* Deliberately constructed DTOs (data-transfer objects)/ POCOs / anonymous types, serialize in full by default - unless they happen to be more than `64` levels deep, which should rarely happen in practice.\r\n\r\n* By contrast, instances of types that weren't _designed for serialization_ (e.g., `System.IO.DirectoryInfo`) either run into the `64` limit or, more likely, into the new API's circular-reference detection - but _such types shouldn't be used in JSON serialization to begin with_.\r\n\r\nIf we surface this behavior as-is in PowerShell, we get _sensible default behavior_ that requires _no extra effort_ in the majority of cases.\r\n\r\nWe lose the \"lazy\" use of `ConvertTo-Json`, which allowed something like `Get-Item / | ConvertTo-Json`, but that was never all that useful to begin with: attempting to use `ConvertTo-Json` for general serialization similar to `Export-CliXml` is ill-advised.\r\n\r\nIn order to support opting-in to depth levels beyond `64` - if ever needed - we could implement a <br>`-MaxDepth` parameter that mirrors the intent of the corresponding option in the new JSON API:\r\n\r\n* \"Don't let this object graph exceed this depth, or I'll throw an exception\" - a _safeguard_.\r\n\r\nBecause of the fundamental difference with how `-Depth` works in `Export-CliXml` (and, regrettably, the old `ConvertTo-Json`), I suggest _not_ naming it `-Depth`.\r\n\r\nIn the vast majority of cases, there will be no need for this parameter.",
      "created_at": "2019-12-13T23:31:37Z",
      "updated_at": "2019-12-13T23:31:37Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 We can add MaxDepth with Depth alias. Original design assumes often using of Depth parameter and removing it would be huge breaking change (I don't know how huge breaking change is after migrating to System.Text.Json - at first look on new tests it is not so huge, maybe large :-) in some scenarios).",
      "created_at": "2019-12-14T05:24:04Z",
      "updated_at": "2019-12-14T05:24:04Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Good point and good idea, @iSazonov.\r\n\r\nI forgot that there must be many commands out there that use `-Depth` of necessity with DTOs, to avoid the default truncation at level 2.\r\n\r\nTo be clear:\r\n\r\n* Newly written command using the new implementation will rarely, if ever, require `-MaxDepth` (`-Depth`)\r\n\r\n* \"Lazy\" use of `ConvertTo-Json` with types such as `System.IO.DirectoryInfo` will  _invariably break_ - even if `-Depth` is used explicitly.\r\n  * That is, even `Get-Item / | ConvertTo-Json -Depth 2` will not work, due to the built-in cycle detection of the new API; as stated, `-Depth` (the `MaxDepth` option) in the new implementation never _truncates_, but instead _enforces that the actual object graph isn't deeper than specified_.\r\n\r\n",
      "created_at": "2019-12-14T14:54:27Z",
      "updated_at": "2019-12-14T14:55:33Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> \"Lazy\" use of ConvertTo-Json with types such as System.IO.DirectoryInfo will invariably break\r\n\r\nGood news are that System.Text.Json allows to use custom converters. We could add new parameter in the cmdlet or/and enhance ETS to support assigning Json converters to types.\r\nAlso there is a possible workaround - converting an object to custom PSObject (with Select-Object) before converting to Json.",
      "created_at": "2019-12-14T17:24:06Z",
      "updated_at": "2019-12-14T17:24:06Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Good points, @iSazonov.\r\n\r\n> We could add new parameter in the cmdlet or/and enhance ETS to support assigning Json converters to types.\r\n\r\nPersonally, I'd hold off on that to see if there's a genuine need for it. \r\n\r\nMy hunch is that solutions based on `Select-Object` (as you say) or  `[pscustomobject]` / hashtable literals or custom PS classes constructed specifically for JSON serialization will suffice, but perhaps others who work routinely with JSON can weigh in.\r\n\r\n\r\n",
      "created_at": "2019-12-14T18:11:47Z",
      "updated_at": "2019-12-14T18:12:36Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@iSazonov Is there a discussion on why we should try re-implementing `ConvertTo-Json` using the .NET Core API? I'm not clear about the gains by doing that ...",
      "created_at": "2019-12-16T18:40:08Z",
      "updated_at": "2019-12-16T18:40:08Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@daxian-dbw #8393 is a discussion about _the behavior _we want. As for using .Net Core API, we could continue to invest in custom and Newtonsoft API but this makes no sense because MSFT announced System.Text.Json API as successor Newtonsoft. I started new implementation only for my education but result exceeded my expectations. New code is not only short and clear but does Json serialization in standard way, allows enhancements and customizations. I assume that we will be able to abandon Netwonsoft library soon.\r\n\r\n",
      "created_at": "2019-12-16T20:31:34Z",
      "updated_at": "2019-12-16T20:31:34Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> MSFT announced System.Text.Json API as successor Newtonsoft.\r\n\r\nDoes .NET team explicitly say `System.Text.Json` is a replacement of `Newtonsof.Json` **in general**?\r\nI double it as there is no equivalent of `JObject`, `JArray` and `JToken`, which makes randomly accessing a key/value pair difficult using `System.Text.Json`.\r\n\r\n> does Json serialization in standard way\r\n\r\nAre you implying the current implementation is serializing JSON in an non-standard way? And if you are talking about customization, `Newtonsoft.Json` has way richer features for you to customize the handling of JSON serialization/deserailization.\r\nI don't think we will be able to move away from `Newtonsoft.Json` soon.",
      "created_at": "2019-12-16T22:57:47Z",
      "updated_at": "2019-12-16T22:57:47Z"
    },
    {
      "author": "dragonwolf83",
      "author_association": "NONE",
      "body": "@daxian-dbw see https://devblogs.microsoft.com/dotnet/try-the-new-system-text-json-apis.\r\n\r\nThe key feature here is performance using Span<T>. Performance has been the biggest issue with the JSON cmdlets since the switch to NewtonSoft and a general problem with PowerShell overall. \r\n\r\nFor built-in cmdlets, it makes sense to have a fast parser with no external dependencies. The only issue is if it break compatibility with Windows PowerShell and maybe PowerShell Core. If it doesn't, then this is a major win as a new default so we get the gains in performance.\r\n\r\nA NetwonSoft version should be optional for advanced scenarios that need the full breadth of features it provides. That could be done via PS Gallery with a new namespace.\n\n<blockquote><img src=\"https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/02/swimlane-cross-platform.png\" width=\"48\" align=\"right\"><div><img src=\"https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2018/10/Microsoft-Favicon.png\" height=\"14\"> .NET Blog</div><div><strong><a href=\"https://devblogs.microsoft.com/dotnet/try-the-new-system-text-json-apis/\">Try the new System.Text.Json APIs | .NET Blog</a></strong></div><div>For .NET Core 3.0, we\u2019re shipping a brand new namespace called\u00a0System.Text.Json\u00a0with support for a reader/writer, a document object model (DOM), and a serializer. In this blog post, I\u2019m telling you why we built it, how it works, and how you can try it.</div></blockquote>",
      "created_at": "2019-12-17T01:24:19Z",
      "updated_at": "2019-12-17T01:24:25Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "[JsonObject](https://source.dot.net/#System.Text.Json/System/Text/Json/Node/JsonObject.cs) and [JsonArray](https://source.dot.net/#System.Text.Json/System/Text/Json/Node/JsonArray.cs) were already pulled in Core 5.0 branch. I guess we will get them in 3.x (back ported or in a package).\r\nThe cmdlet will get them OOB too.\r\n\r\n>  The only issue is if it break compatibility with Windows PowerShell and maybe PowerShell Core.\r\n\r\nWe can preserve old behavior with -UseWindowsPowerShellConverter switch although I don't see more value from this. ",
      "created_at": "2019-12-17T14:54:11Z",
      "updated_at": "2019-12-17T14:54:11Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "Failures in `NullConditionalOperator` tests were resolved in upstream.\r\n\r\n@dragonwolf83 @iSazonov Thanks for the pointers, I didn't know the addition of `JObject`, `JArray` and etc in the .NET Core 5 branch, that is great, making it a more viable replacement of `NewtonSoft.Json`. Now this porting work makes much more sense to me. Will wait to see how the backward compatibility would be for `ConvertTo-Json`.",
      "created_at": "2019-12-17T19:37:50Z",
      "updated_at": "2019-12-17T19:37:50Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 @jochenvanwylick @thedavecarroll @vexx32 The PR was moved to .Net Runtime 5.0 Preview1. Please play with compiled artifacts and feedback.",
      "created_at": "2020-03-29T07:34:55Z",
      "updated_at": "2020-03-29T07:34:55Z"
    },
    {
      "author": "adityapatwardhan",
      "author_association": "MEMBER",
      "body": "@iSazonov Please have a look at CI failures",
      "created_at": "2020-04-15T17:17:05Z",
      "updated_at": "2020-04-15T17:17:05Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@adityapatwardhan I ask in .Net Runtime repo about the issue.",
      "created_at": "2020-04-16T17:57:46Z",
      "updated_at": "2020-04-16T17:57:46Z"
    },
    {
      "author": "adityapatwardhan",
      "author_association": "MEMBER",
      "body": "@PoshChan please rebuild all",
      "created_at": "2020-04-18T00:24:01Z",
      "updated_at": "2020-04-18T00:24:01Z"
    },
    {
      "author": "PoshChan",
      "author_association": "COLLABORATOR",
      "body": "@adityapatwardhan, successfully started rebuild of `PowerShell-CI-static-analysis, PowerShell-CI-Windows, PowerShell-CI-macOS, PowerShell-CI-Linux`",
      "created_at": "2020-04-18T00:24:44Z",
      "updated_at": "2020-04-18T00:24:44Z"
    },
    {
      "author": "adityapatwardhan",
      "author_association": "MEMBER",
      "body": "@iSazonov master has been moved to .NET 5 preview 3, hence restarted the CI",
      "created_at": "2020-04-18T00:25:13Z",
      "updated_at": "2020-04-18T00:25:13Z"
    },
    {
      "author": "adityapatwardhan",
      "author_association": "MEMBER",
      "body": "@iSazonov are these the same errors are before?",
      "created_at": "2020-04-24T18:41:36Z",
      "updated_at": "2020-04-24T18:41:36Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@adityapatwardhan .Net addressed my request to make Json exceptions more useful and we get this.\r\n\r\nAs for \"null\" case it is still present. I will open new issue in .Net repo.",
      "created_at": "2020-04-24T19:22:43Z",
      "updated_at": "2020-04-24T19:22:43Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@adityapatwardhan Last issue was addressed and the PR is ready for review and merge.",
      "created_at": "2020-04-30T09:21:27Z",
      "updated_at": "2020-04-30T09:21:27Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@SteveL-MSFT Could your team review the PR? Now it is best time to make such breaking change. See also #11397.",
      "created_at": "2020-05-27T11:09:14Z",
      "updated_at": "2020-05-27T11:09:14Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as Review Needed because it has been there has not been any activity for **7 days**.\nMainainer, Please provide feedback and/or mark it as `Waiting on Author`",
      "created_at": "2020-06-10T14:00:28Z",
      "updated_at": "2020-06-10T14:00:28Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov Can we please move this forward as a new, standalone library that is compatible with Windows PowerShell 5.1 as well as PowerShell 7.x? The issues identified here are also issues in 5.x. There have been enhancements in the cross platform PowerShell such as `-EnumsAsStrings` and `-AsHashtable` and `-AsArray` and `-EscapeHandling` that are not available to Windows PowerShell 5.1. Yet there are scenarios where simply pointing users to PowerShell 7 as the solution forward is not viable. Plus there are discussions here about breaking changes. A standalone module that carries JSON conversion forward using the .NET Core JSON APIs while addressing the bulk of the issues with JSON in PowerShell today (including fully bi-directional conversion) would be a much better way to bring the Microsoft JSON.NET libraries into PowerShell than simply updating what we have as a built-in module that isn't available elsewhere.\r\n\r\nAlso this hasn't moved forward in some time. Is that partly due to concerns about these breaking changes? If so, again, a standalone optional module that supersedes what Windows PowerShell 5.1 and PowerShell 7.x have baked in today seems like a better solution.",
      "created_at": "2020-09-14T15:00:39Z",
      "updated_at": "2020-09-14T15:16:10Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "Looking at the code, I see you've implemented an entirely new set of classes, so hopefully it should be straightforward to move that into a standalone module that could work for Windows PowerShell 5.1 as well as PowerShell 7.x.\r\n\r\nAlso, while it seems like this is covered, a use case that I want to specifically call out is the need to access the conversion to/from JSON via an API, so that the same logic that is used within PowerShell can be used in products that leverage PowerShell without having to invoke PowerShell directly. Please make sure this use case is covered.\r\n\r\nIf the conversion logic was localized within a library that PowerShell 7.x used in cmdlets, and if that library was packaged up as a Nuget package, that would cover the needs of developers building solutions on top of PowerShell as well -- at least in my case it would.",
      "created_at": "2020-09-14T15:15:19Z",
      "updated_at": "2020-09-14T15:15:19Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "One more thing @iSazonov: I have immediate need for this in Windows PowerShell 5.1, or as a library, and I'm happy to assist with the development and testing. I don't want to simply create duplicate work in parallel though, so please let me know what the plans are to move this forward, whether or not you think creating this as a standalone module is feasible and something you agree with, and we'll go from there. If you're too busy and you'd like me to move this forward, I'm happy to do so.\r\n\r\n@SteveL-MSFT: Curious to hear your thoughts on the idea of this being broken out into a separate module and NuGet library (library necessary to consume/convert from JSON produced from PowerShell scripts in an environment that does not run PowerShell).",
      "created_at": "2020-09-14T15:23:01Z",
      "updated_at": "2020-09-14T15:23:01Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "Does this PR resolve #3705 such that the `-AsHashtable` workaround is not required? i.e. With a case insensitive JSON conversion logic, what happens when it is fed some json that contains case-sensitive property names? Hopefully it has an option to just write each value once, because in scenarios where you can get duplicate property names with the same values but a different case, it would be nice if you could just ignore those scenarios.\r\n\r\nAn example where such a scenario can occur is this:\r\n`Get-ADUser -Filter * -Properties * | ConvertTo-Json | ConvertFrom-Json`\r\n\r\nThat will generate JSON containing both `ObjectGuid` and `ObjectGUID`, both of which contain the same value.",
      "created_at": "2020-09-14T15:31:50Z",
      "updated_at": "2020-09-14T15:36:38Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I am fan .Net Runtime development model. I strongly sure we could benefit from the dev model too. They put all code dev process in one repository and greatly simplify it. As result they get huge community contributions.\r\nWith the model all you would need to do you would add publishing of a new nuget package.\r\n\r\nUnfortunately, PowerShell MSFT team cannot find a middle ground - many community PRs are frozen here and PowerShell/modules repository does not work at all.\r\nOf course, you can always develop your own project to meet your needs... I suspect that if you need quick results today, then you are destined for it (own project). :-(\r\n\r\n> Also this hasn't moved forward in some time. Is that partly due to concerns about these breaking changes?\r\n\r\nMy intentions were:\r\n- to create early implementation so that we can feedback to .Net team while they actively worked on .Net 5.0.\r\n- to avoid breaking changes as possible and pass all our current tests without changes\r\n- later to add new fixes in separate commits so that we explicitly see new breaking changes.\r\n\r\nAs for breaking changes, there are two places:\r\n- in .Net\r\nThey implemented new API with compatibility with NewtonSoft Json.Net and fix some bugs and inconsistences. As result the new API has many breaking changes compared with Json.Net ( and PowerShell too because PowerShell uses Json.Net)\r\n- in PowertShell\r\nPowerShell has bugs and inconsistences too. Fixing its will add breaking changes.\r\n\r\nIn the end, we come to the conclusion that in any case, when we switch to the new API, we will receive many breaking changes. I hoped that we get this in 7.1 as experimental feature for easy community adoption. But :-(\r\n\r\n> a use case that I want to specifically call out is the need to access the conversion to/from JSON via an API, so that the same logic that is used within PowerShell can be used in products that leverage PowerShell without having to invoke PowerShell directly.\r\n\r\nOnly specific convertor is created for PSObject. Do you ask to put it in nuget library and reference SMA (PowerShell SDK)?\r\n\r\n> I have immediate need for this in Windows PowerShell 5.1, or as a library, and I'm happy to assist with the development and testing. \r\n\r\nPress MSFT team :-) to follow .Net Runtime dev model. This is my strict belief. A good development environment is 80 percent of the effort. If we do this in one place, we will significantly speed up development.\r\n\r\n> Does this PR resolve #3705 such that the -AsHashtable workaround is not required?\r\n\r\nThis was not my goal. As I said, I wanted to avoid any breaking changes and bug fixes and make them explicitly later.\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-09-15T11:09:55Z",
      "updated_at": "2020-09-15T11:09:55Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov Thank you for the detailed reply.\r\n\r\n> Of course, you can always develop your own project to meet your needs... I suspect that if you need quick results today, then you are destined for it (own project). :-(\r\n\r\nThis is what we have now -- some proxy functions to override the ConvertTo-Json/ConvertFrom-Json cmdlets where needed. But ultimately I don't want to spend time on something that should come from PowerShell itself as a separate module, and I don't want to own the development of something that is so fundamental that it really should be managed by Microsoft. I'm doing it because I have to, but with bugs like #3705 plus performance benefits from switching to .NET Core JSON APIs, I'd rather converge on a PowerShell team-managed solution than roll my own, because I have much bigger things to focus on that are far more important than JSON conversion (which should be something people can simply take for granted as being there with a solid, performant implementation, in both Windows PowerShell and PowerShell).\r\n\r\n> In the end, we come to the conclusion that in any case, when we switch to the new API, we will receive many breaking changes. I hoped that we get this in 7.1 as experimental feature for easy community adoption. But :-(\r\n\r\nI think a standalone module and Nuget package would be far superior to an experimental feature in this case. But I suppose I already said that.\r\n\r\n> Only specific convertor is created for PSObject. Do you ask to put it in nuget library and reference SMA (PowerShell SDK)?\r\n\r\nThat would be fine. I have no problem needing the PowerShell SDK as a dependency. I'm already using it. I'm also only looking for conversion to/from PS entities such as PSObject, Hashtable, etc. I just want to avoid needing to call into PowerShell when I already have my object data that needs conversion in my C# code.",
      "created_at": "2020-09-15T17:42:18Z",
      "updated_at": "2020-09-15T17:42:18Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as Review Needed because it has been there has not been any activity for **7 days**.\nMaintainer, please provide feedback and/or mark it as `Waiting on Author`",
      "created_at": "2020-09-23T02:00:09Z",
      "updated_at": "2020-09-23T02:00:09Z"
    },
    {
      "author": "strawgate",
      "author_association": "CONTRIBUTOR",
      "body": "Any idea what is needed to get this PR ready to go? I see a couple of things but if you've got a list that would be super helpful",
      "created_at": "2021-07-02T05:34:11Z",
      "updated_at": "2021-07-02T05:34:11Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Any idea what is needed to get this PR ready to go? I see a couple of things but if you've got a list that would be super helpful\r\n\r\nI can not do all work - investigate, develop, review and merge :-) If you have an interest you could grab the PR. I guess we could get this working in one-two weeks and then switch to ConvertFrom-Json.",
      "created_at": "2021-07-02T06:29:07Z",
      "updated_at": "2021-07-02T06:29:07Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as Review Needed because it has been there has not been any activity for **7 days**.\nMaintainer, please provide feedback and/or mark it as `Waiting on Author`",
      "created_at": "2021-07-09T14:00:49Z",
      "updated_at": "2021-07-09T14:00:49Z"
    }
  ],
  "created_at": "2019-11-26T05:44:46Z",
  "number": 11198,
  "state": "closed",
  "title": "Port ConvertTo-Json to .Net Core Json API",
  "updated_at": "2022-04-16T19:12:24Z"
}