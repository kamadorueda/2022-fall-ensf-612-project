{
  "_url": "https://github.com/PowerShell/PowerShell/issues/13954",
  "author": "sba923",
  "body": "## Steps to reproduce\r\n\r\nTake this crude C# code (derived from [code in this StackOverflow thread](https://stackoverflow.com/questions/554010/how-to-get-the-actual-size-on-disk-of-a-file-from-powershell)):\r\n\r\n````\r\nusing System;\r\nusing System.Linq;\r\nusing System.Runtime.InteropServices;\r\n\r\nnamespace NTFS\r\n{\r\n    public class ExtendedFileInfo\r\n    {\r\n        [DllImport(\"kernel32.dll\", SetLastError = true, EntryPoint = \"GetCompressedFileSizeW\")]\r\n        static extern uint GetCompressedFileSizeAPI([MarshalAs(UnmanagedType.LPWStr)] string lpFileName, out uint lpFileSizeHigh);\r\n        public static ulong GetCompressedFileSize(string filename)\r\n        {\r\n            uint high;\r\n            uint low;\r\n            low = GetCompressedFileSizeAPI(filename, out high);\r\n            int error = Marshal.GetLastWin32Error();\r\n            if (high == 0 && low == 0xFFFFFFFF && error != 0)\r\n            {\r\n                throw new System.ComponentModel.Win32Exception(error);\r\n            }\r\n            else\r\n            {\r\n                return ((ulong)high << 32) + low;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nnamespace GetFileSizeOnDisk\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            bool verbose = false;\r\n            string fullname = \"foobar.txt\";\r\n            if (args.Length != 0)\r\n            {\r\n                fullname = args[0];\r\n                if (args.Length >= 2)\r\n                {\r\n                    if (args[1] == \"-v\")\r\n                    {\r\n                        verbose = true;\r\n                    }\r\n                }\r\n            }\r\n            if (verbose)\r\n            {\r\n                Console.WriteLine(\"FullName: '{0}'\", fullname);\r\n                int pathlen = fullname.Length;\r\n                Console.WriteLine(\"Path length: {0}\", pathlen);\r\n                var fi = new System.IO.FileInfo(fullname);\r\n                long size = fi.Length;\r\n                Console.WriteLine(\"Size: {0}\", size);\r\n\r\n            }\r\n            ulong sizeondisk = NTFS.ExtendedFileInfo.GetCompressedFileSize(fullname);\r\n            if (verbose)\r\n            {\r\n                Console.WriteLine(\"Size on disk: {0}\", sizeondisk);\r\n\r\n            }\r\n            else\r\n            {\r\n                Console.WriteLine(\"{0}\", sizeondisk);\r\n            }\r\n        }\r\n    }\r\n}\r\n````\r\n\r\nCompiled with an assembly manifest that includes\r\n\r\n````\r\n  <!-- application is long pathname aware -->\r\n  <application xmlns=\"urn:schemas-microsoft-com:asm.v3\">\r\n    <windowsSettings xmlns:ws2=\"http://schemas.microsoft.com/SMI/2016/WindowsSettings\">\r\n      <ws2:longPathAware>true</ws2:longPathAware>\r\n    </windowsSettings>\r\n  </application>\r\n````\r\n\r\nthis gives you an executable that is able to process files whose absolute pathname is longer than 256 characters:\r\n\r\n````\r\nPS> $p='C:\\Users\\steph\\OneDrive\\test\\test01\\test02\\test03\\test04\\test05\\test06\\test07\\test08\\test09\\test10\\test11\\test12\\test13\\test14\\test15\\test16\\test17\\test18\\test19\\test20\\test21\\test22\\test23\\test24\\test25\\test26\\test27\\test28\\test29\\test30\\test31\\test32\\test33\\test34\\test35\\test36\\test37\\test38\\test39\\test40\\test.txt'\r\n\r\nPS> .\\GetFileSizeOnDisk.exe $p -v\r\nFullName: 'C:\\Users\\steph\\OneDrive\\test\\test01\\test02\\test03\\test04\\test05\\test06\\test07\\test08\\test09\\test10\\test11\\test12\\test13\\test14\\test15\\test16\\test17\\test18\\test19\\test20\\test21\\test22\\test23\\test24\\test25\\test26\\test27\\test28\\test29\\test30\\test31\\test32\\test33\\test34\\test35\\test36\\test37\\test38\\test39\\test40\\test.txt'\r\nPath length: 317\r\nSize: 6\r\nSize on disk: 6\r\n````\r\n\r\nThis also gives you a DLL for an assembly that exposes a method that can be called from PowerShell:\r\n\r\n````\r\nPS> System.Reflection.Assembly]::LoadFile(\"....\\GetFileSizeOnDisk.dll\")\r\n\r\nGAC    Version        Location\r\n---    -------        --------\r\nFalse  v4.0.30319     ....\\GetFileSizeOnDisk.dll\r\n\r\n\r\nPS> [NTFS.ExtendedFileInfo]::GetCompressedFileSize(\"c:\\windows\\system32\\notepad.exe\")\r\n202240\r\n````\r\n\r\nBut invoking that method from PowerShell does not support pathnames longer than 256 characters:\r\n\r\n````\r\nPS> $p='C:\\Users\\steph\\OneDrive\\test\\test01\\test02\\test03\\test04\\test05\\test06\\test07\\test08\\test09\\test10\\test11\\test12\\test13\\test14\\test15\\test16\\test17\\test18\\test19\\test20\\test21\\test22\\test23\\test24\\test25\\test26\\test27\\test28\\test29\\test30\\test31\\test32\\test33\\test34\\test35\\test36\\test37\\test38\\test39\\test40\\test.txt'\r\n\r\nPS> [NTFS.ExtendedFileInfo]::GetCompressedFileSize($p)\r\nMethodInvocationException: Exception calling \"GetCompressedFileSize\" with \"1\" argument(s): \"The system cannot find the path specified.\"\r\n\r\n````\r\n\r\n## Expected behavior\r\n\r\nInvoking the method in the `longPathAware` assembly should be `longPathAware`.\r\n\r\n## Actual behavior\r\n\r\nInvoking the method is not `longPathAware`, resulting in \"path not found\" errors for arguments > 256 characters long.\r\n\r\n## Environment data\r\n```\r\n> $psversiontable\r\n\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.1.0-rc.2\r\nPSEdition                      Core\r\nGitCommitId                    7.1.0-rc.2\r\nOS                             Microsoft Windows 10.0.19042\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n\r\n```\r\n",
  "closed_at": "2021-01-18T12:59:25Z",
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Does `Get-Item $p` works for you?",
      "created_at": "2020-10-31T13:08:24Z",
      "updated_at": "2020-10-31T13:08:24Z"
    },
    {
      "author": "sba923",
      "author_association": "CONTRIBUTOR",
      "body": "Yes it does:\r\n\r\n````\r\nPS> $i=get-item $p\r\nPS> $i.FullName\r\nC:\\Users\\steph\\OneDrive\\test\\test01\\test02\\test03\\test04\\test05\\test06\\test07\\test08\\test09\\test10\\test11\\test12\\test13\\test14\\test15\\test16\\test17\\test18\\test19\\test20\\test21\\test22\\test23\\test24\\test25\\test26\\test27\\test28\\test29\\test30\\test31\\test32\\test33\\test34\\test35\\test36\\test37\\test38\\test39\\test40\\test.txt\r\nPS> $i\r\n\r\n    Directory:  C:\\Users\\steph\r\n\r\nMode                LastWriteTime     Length Name\r\n----                -------------     ------ ----\r\nla---        2020-10-31     08:44        6   test.txt\r\n````\r\n\r\nbut of course that's because I have set `HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem\\LongPathsEnabled` to 1\r\n",
      "created_at": "2020-10-31T17:10:31Z",
      "updated_at": "2020-10-31T17:10:31Z"
    },
    {
      "author": "fMichaleczek",
      "author_association": "NONE",
      "body": "@sba923 \r\n\r\nThis code failed because it depends on the \"longPathAware\" setting defined in the Win32 application manifest.\r\nhttps://docs.microsoft.com/en-us/windows/win32/sbscs/application-manifests\r\n\r\nThe RID of PowerShell for Windows is still Windows 7, and Long Path support is I believe a Windows 10 cleaning effort, so I don't know if it could apply for all windows release. If you want to ask the PowerShell team to activate longPathAware, it's something to take in consideration.\r\n\r\nI take this source code as an universal reproductible sample.\r\n```\r\n$filePath = \"$env:USERPROFILE\\test\\test01\\test02\\test03\\test04\\test05\\test06\\test07\\test08\\test09\\test10\\test11\\test12\\test13\\test14\\test15\\test16\\test17\\test18\\test19\\test20\\test21\\test22\\test23\\test24\\test25\\test26\\test27\\test28\\test29\\test30\\test31\\test32\\test33\\test34\\test35\\test36\\test37\\test38\\test39\\test40\\test.txt\"\r\n\r\nNew-Item -Path $filePath -Value \"1\" -Force\r\n\r\nAdd-Type -TypeDefinition @'\r\nusing System;\r\nusing System.Runtime.InteropServices;\r\nusing System.ComponentModel;\r\n\r\nnamespace NTFS\r\n{\r\n    public class ExtendedFileInfo\r\n    {\r\n        [DllImport(\"kernel32.dll\", SetLastError=true, EntryPoint=\"GetCompressedFileSize\")]\r\n        static extern uint GetCompressedFileSizeAPI(string lpFileName, out uint lpFileSizeHigh);\r\n\r\n        public static ulong GetCompressedFileSize(string filename)\r\n        {\r\n            uint high;\r\n            uint low;\r\n            low = GetCompressedFileSizeAPI(filename, out high);\r\n            int error = Marshal.GetLastWin32Error();\r\n            if (high == 0 && low == 0xFFFFFFFF && error != 0)\r\n\t\t\t\tthrow new Win32Exception(error);\r\n            else\r\n\t\t\t\treturn ((ulong)high << 32) + low;\r\n        }\r\n    }\r\n}\r\n'@\r\n\r\n[NTFS.ExtendedFileInfo]::GetCompressedFileSize($filePath)\r\n```\r\n\r\nFailed with \"**The system cannot find the path specified.**\"\r\n\r\nThis code activate the \"longPathAware\" in the current process, so the method GetCompressedFileSize works. ( See the link bellow for more details ).\r\nhttps://stackoverflow.com/questions/58563335/make-maf-addinprocess-exe-long-path-aware\r\n\r\n```\r\nAdd-Type -CompilerOptions \"/unsafe\" -TypeDefinition @'\r\nusing System;\r\nusing System.ComponentModel;\r\nusing System.Diagnostics;\r\nusing System.Runtime.InteropServices;\r\n\r\npublic class ApplicationHelper\r\n{\r\n\t// Adapted from https://www.pinvoke.net/default.aspx/ntdll.ntqueryinformationprocess\r\n\tpublic static void SetIsLongPathAwareProcess()\r\n\t{\r\n\t\tvar currentProcess = Process.GetCurrentProcess();\r\n\t\tIntPtr hProc = currentProcess.Handle;\r\n\r\n\t\tIntPtr pPbi = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(Native.PROCESS_BASIC_INFORMATION)));\r\n\t\tIntPtr outLong = Marshal.AllocHGlobal(sizeof(long));\r\n\r\n\t\tint status = Native.NtQueryInformationProcess(hProc, 0, pPbi, (uint)Marshal.SizeOf(typeof(Native.PROCESS_BASIC_INFORMATION)), outLong);\r\n\r\n\t\tMarshal.FreeHGlobal(outLong);\r\n\r\n\t\t//STATUS_SUCCESS = 0\r\n\t\tif (status == 0)\r\n\t\t{\r\n\t\t\tvar pbi = Marshal.PtrToStructure<Native.PROCESS_BASIC_INFORMATION>(pPbi);\r\n\t\t\tvar pPeb = pbi.PebBaseAddress;\r\n\r\n\t\t\tvar peb = Marshal.PtrToStructure<Native.PEB_Beginning>(pPeb);\r\n\r\n\t\t\tvar bitField1 = peb.BitField1;\r\n\t\t\tpeb.BitField1 = bitField1 | Native.PEBBitField1.IsLongPathAwareProcess;\r\n\t\t\tMarshal.StructureToPtr<Native.PEB_Beginning>(peb, pPeb, false);\r\n\t\t}\r\n\r\n\t\t//Free allocated space\r\n\t\tMarshal.FreeHGlobal(pPbi);\r\n\t}\r\n\r\n\tstatic class Native\r\n\t{\r\n\t\t// http://pinvoke.net/default.aspx/Structures/PROCESS_BASIC_INFORMATION.html\r\n\t\t[StructLayout(LayoutKind.Sequential, Pack = 1)]\r\n\t\tinternal struct PROCESS_BASIC_INFORMATION\r\n\t\t{\r\n\t\t\tpublic IntPtr ExitStatus;\r\n\t\t\tpublic IntPtr PebBaseAddress;\r\n\t\t\tpublic IntPtr AffinityMask;\r\n\t\t\tpublic IntPtr BasePriority;\r\n\t\t\tpublic UIntPtr UniqueProcessId;\r\n\t\t\tpublic IntPtr InheritedFromUniqueProcessId;\r\n\r\n\t\t\tpublic int Size\r\n\t\t\t{\r\n\t\t\t\tget { return (int)Marshal.SizeOf(typeof(PROCESS_BASIC_INFORMATION)); }\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t[Flags]\r\n\t\tinternal enum PEBBitField1 : byte\r\n\t\t{\r\n\t\t\tNone = 0,\r\n\t\t\tImageUsesLargePages = 1 << 0,\r\n\t\t\tIsProtectedProcess = 1 << 1,\r\n\t\t\tIsImageDynamicallyRelocated = 1 << 2,\r\n\t\t\tSkipPatchingUser32Forwarders = 1 << 3,\r\n\t\t\tIsPackagedProcess = 1 << 4,\r\n\t\t\tIsAppContainer = 1 << 5,\r\n\t\t\tIsProtectedProcessLight = 1 << 6,\r\n\t\t\tIsLongPathAwareProcess = 1 << 7\r\n\t\t}\r\n\r\n\t\t// Note: this only contains the \"beginning\" of the PEB structure\r\n\t\t// but that is all we need for access to the IsLongPathAwareProcess bit\r\n\t\t// Used as a guide: https://github.com/processhacker/processhacker/blob/master/phnt/include/ntpebteb.h#L75\r\n\t\t// Related: https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb\r\n\t\t[StructLayout(LayoutKind.Sequential, Pack = 1)]\r\n\t\tinternal struct PEB_Beginning\r\n\t\t{\r\n\t\t\tByte InheritedAddressSpace;\r\n\t\t\tByte ReadImageFileExecOptions;\r\n\t\t\tByte BeingDebugged;\r\n\t\t\tpublic PEBBitField1 BitField1;\r\n\t\t};\r\n\r\n\t\t// https://www.pinvoke.net/default.aspx/ntdll.ntqueryinformationprocess\r\n\t\t[DllImport(\"ntdll.dll\", SetLastError = true)]\r\n\t\tinternal static extern int NtQueryInformationProcess(IntPtr processHandle, int processInformationClass, IntPtr processInformation, uint processInformationLength, IntPtr returnLength);\r\n\r\n\t\t// The below is for test purposes only:\r\n\t\t// Include CreateDirectory for testing if the long path aware changes work or not.\r\n\t\t// Requires SECURITY_ATTRIBUTES\r\n\t\t// http://pinvoke.net/default.aspx/kernel32/CreateDirectory.html?diff=y\r\n\t\t[DllImport(\"kernel32.dll\", SetLastError = true, CharSet = CharSet.Auto, BestFitMapping = false)]\r\n\t\tinternal static extern bool CreateDirectory(String path, SECURITY_ATTRIBUTES lpSecurityAttributes);\r\n\r\n\r\n\t\t// https://www.pinvoke.net/default.aspx/Structures/SECURITY_ATTRIBUTES.html\r\n\t\t[StructLayout(LayoutKind.Sequential)]\r\n\t\tinternal class SECURITY_ATTRIBUTES\r\n\t\t{\r\n\t\t\tinternal int nLength = 0;\r\n\t\t\t// don't remove null, or this field will disappear in bcl.small\r\n\t\t\tinternal unsafe byte* pSecurityDescriptor = null;\r\n\t\t\tinternal int bInheritHandle = 0;\r\n\t\t}\r\n\t}\r\n}\r\n'@\r\n[ApplicationHelper]::SetIsLongPathAwareProcess()\r\n[NTFS.ExtendedFileInfo]::GetCompressedFileSize($filePath)\r\n```\r\nReturn 1\n\n<blockquote><img src=\"https://docs.microsoft.com/en-us/media/logos/logo-ms-social.png\" width=\"48\" align=\"right\"><div><strong><a href=\"https://docs.microsoft.com/en-us/windows/win32/sbscs/application-manifests\">Application Manifests - Win32 apps</a></strong></div><div>An application manifest is an XML file that describes and identifies the shared and private side-by-side assemblies that an application should bind to at run time.</div></blockquote>\n<blockquote><img src=\"https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded\" width=\"48\" align=\"right\"><div>Stack Overflow</div><div><strong><a href=\"https://stackoverflow.com/questions/58563335/make-maf-addinprocess-exe-long-path-aware\">Make MAF AddInProcess.exe \"Long Path Aware\"</a></strong></div><div>I'm trying to make my Addin's (using MAF) AddInProcess.exe (created by the AddInProcess class) \"long path aware\" for Windows 10.\n\nThe difficulty stems from the fact that I don't own the AddInProces...</div></blockquote>",
      "created_at": "2020-11-03T01:03:54Z",
      "updated_at": "2020-11-03T01:03:57Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Great example! But we cannot use this until it will be documented or used somewhere in Windows SDK.",
      "created_at": "2020-11-03T03:27:03Z",
      "updated_at": "2020-11-03T03:27:03Z"
    },
    {
      "author": "fMichaleczek",
      "author_association": "NONE",
      "body": "@iSazonov I don't understand what should be documented. \r\nI'm sorry, I only write a POC, see more advanced diagnostics bellow :\r\n\r\nA quick summary :\r\n- @sba923 want to use the Win32 function [_GetCompressedFileSizeW_](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getcompressedfilesizew) \r\n- On _Windows 10 1607 and more_, it's failed on long path because PowerShell doesn't have a _Win32 application manifest_ which include the [_longPathAware_](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getcompressedfilesizew)\r\n\r\nThe method _SetIsLongPathAwareProcess_ in my previous sample was a simple hack to test the dependency between _GetCompressedFileSizeW_ /_longPathAware_ and provide a workaround for @sba923 \r\n\r\nBecause the requirement of _longPathAware_ is Win10 1607+, I'm not sure how it should be enabled in netcore/Win32/msbuild component without separate Win7/Win10 projects.\r\n\r\nI hope I help to clarify, I don't think it's urgent because [net5.0 design](https://github.com/dotnet/designs/blob/main/accepted/2020/net5/net5.md#why-are-the-os-specific-flavors-not-versioned-by-the-os) about Windows and _Minimum OS API Level_ had changed, so net6.0 should be a better branch to cover these scenarios.\r\n\r\n\r\nSo, this issue should depend on a root issue which could be called \"_Manage Win32 Application Manifest abroad all Windows release in net6.0_\". I'm not sure but the change should be driven by [PowerShell/GraphicalTools/issues/101](https://github.com/PowerShell/GraphicalTools/issues/101)  /cc @TylerLeonhardt ",
      "created_at": "2020-11-03T13:18:45Z",
      "updated_at": "2020-11-03T13:18:45Z"
    },
    {
      "author": "sba923",
      "author_association": "CONTRIBUTOR",
      "body": "What's weird is that PowerShell **itself** (e.g. `Get-Item`) has no problem dealing with those long pathnames. The problem arose when I wanted to use code in a compiled assembly or code compiled dynamically via `Add-Type`.",
      "created_at": "2020-11-03T18:32:39Z",
      "updated_at": "2020-11-03T18:32:39Z"
    },
    {
      "author": "fMichaleczek",
      "author_association": "NONE",
      "body": "@sba923 no it's not weird, it's more a long story in the Microsoft area. This issue will not be closed in 5 minutes, so your workarounds are the one to activate the longPathAware at runtime or .. you have to deal with \\\\\\\\?\\ (see the docs \r\n  https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file?redirectedfrom=MSDN#win32-file-namespaces)\r\n",
      "created_at": "2020-11-04T10:14:07Z",
      "updated_at": "2020-11-04T10:15:00Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Close as stale issue. Feel free to continue discussion.",
      "created_at": "2021-01-18T12:59:25Z",
      "updated_at": "2021-01-18T12:59:25Z"
    }
  ],
  "created_at": "2020-10-31T08:06:30Z",
  "number": 13954,
  "state": "closed",
  "title": "Cannot use longPathAware assembly from PowerShell",
  "updated_at": "2021-01-18T12:59:25Z"
}