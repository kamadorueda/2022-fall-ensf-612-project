{
  "_url": "https://github.com/PowerShell/PowerShell/issues/14724",
  "author": "p0W3RH311",
  "body": "Hi guys !\r\n\r\nloops in powershell is various and its awesome but it missing an indexer for example:\r\n```\r\n\r\nforeach($index,$item in $list) {\r\n    \"$index = $item\"\r\n}\r\n```\r\n\r\nis more elegant and short:\r\n\r\n```\r\n$index =  0\r\nforeach($item in $list) {\r\n    \"$index = $item\"\r\n     $index++\r\n}\r\n\r\n\r\n```",
  "closed_at": "2021-05-13T18:04:14Z",
  "comments": [
    {
      "author": "doctordns",
      "author_association": "COLLABORATOR",
      "body": "What specific problems does this solve?\r\nWasn't this suggestion recently made and declined?",
      "created_at": "2021-02-07T11:13:49Z",
      "updated_at": "2021-02-07T11:13:49Z"
    },
    {
      "author": "p0W3RH311",
      "author_association": "NONE",
      "body": "> \r\n> \r\n> What specific problems does this solve?\r\n> Wasn't this suggestion recently made and declined?\r\n\r\n@doctordns \r\n\r\nWhat specific problems does this solve in many languages like python, ruby, perl, rust, javascript, Go, Scala, Php....etc",
      "created_at": "2021-02-07T13:38:36Z",
      "updated_at": "2021-02-07T13:38:36Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I like the idea; it complements @iRon7's proposal to introduce an automatic `$PSIndex` variable in the _pipeline_: #13772\r\n\r\n@doctordns, it's helpful syntactic sugar; just a couple of use cases off the top of my head; I'm sure there are more.\r\n\r\n<sup>Note: The original syntax was changed to reflect the later discussion; the index variable now comes _after_ the iteration expression, separate with `;`</sup>\r\n\r\n```powershell\r\n# Parellel array processing\r\n$a = 'foo', 'bar'\r\n$b = 'baz', 'qux'\r\n$c = 'and' 'so on'\r\nforeach ($aElem in $a; $i) { # WISHFUL THINKING\r\n  $bElem, $cElem = $b[$i], $c[$i]\r\n  # ...\r\n}\r\n\r\n# Get only every 2nd element\r\n$a = 'foo', 'bar', 'baz', 'quux'\r\nforeach ($aElem in $a; $i) { # WISHFUL THINKING\r\n  if ($i % 2) { continue }\r\n}\r\n```\r\n\r\nAs a largely moot aside: Quite some time ago, in #3830, I had proposed allowing syntax such as `foreach ($a) { ... }` - not having to specify an iteration variable explicitly and defaulting to `$_` / `$PSItem`; the proposal was rejected, but it would have allowed us a unified approach with respect to an automatic `$PSIndex` as well.\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2021-02-07T14:34:52Z",
      "updated_at": "2021-02-08T15:57:16Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "I'd move that indexer variable to **after** the condition and if it's optional you don't break existing code e.g.:\r\n```powershell\r\nforeach ($item in $items, $ndx) { ... }\r\n```\r\nFWIW it do not like the idea of an automatic variable like `$PSIndex`.  That falls apart in nested loops.  ",
      "created_at": "2021-02-07T16:29:27Z",
      "updated_at": "2021-02-07T16:29:27Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@rkeithhill, `foreach ($item in $items, $ndx) { ... }` is not an option due to ambiguity - such a statement already works, and loops over the _array_ `$items, $ndx`.\r\n\r\nHowever, `;` as the separator would work (currently a syntax error):  `foreach ($item in $items; $ndx) { ... }`\r\n\r\n> falls apart in nested loops.\r\n\r\nIn nested loops, `$PSIndex` could refer to the respective _enclosing_ loop.\r\nIf referencing indices across the loop hierarchy is needed, the explicit index-variable syntax proposed here can be used.\r\n",
      "created_at": "2021-02-07T16:45:10Z",
      "updated_at": "2021-02-07T16:45:10Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "Good point on the `,` versus `;`.  In nested loops, it is not uncommon at all to want to access the indexer of outer loops which is tricky with a single variable e.g.:\r\n```\r\nforeach ($item in $items; $ndx1) {\r\n     foreach ($child  in $item.Children; $ndx2) {\r\n         ....\r\n     }\r\n }",
      "created_at": "2021-02-07T16:52:52Z",
      "updated_at": "2021-02-07T16:52:52Z"
    },
    {
      "author": "p0W3RH311",
      "author_association": "NONE",
      "body": "`$psindex` in my opinion as _magic variable_ is better because:\r\n\r\nit's not break change and it not break the loop:\r\n\r\n```\r\nforeach($item in $list) {\r\n   \"$psindex => $item\"\r\n}\r\n```",
      "created_at": "2021-02-07T16:52:59Z",
      "updated_at": "2021-02-07T16:52:59Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "IMO PowerShell already has too many magic variables.  And to be clear, I do like the overall concept.  ",
      "created_at": "2021-02-07T16:53:40Z",
      "updated_at": "2021-02-07T16:55:30Z"
    },
    {
      "author": "p0W3RH311",
      "author_association": "NONE",
      "body": "@rkeithhill \r\n\r\nyes ps has many magic variable but it not has an _indexer magic variable_\r\n\r\n",
      "created_at": "2021-02-07T16:55:27Z",
      "updated_at": "2021-02-07T16:55:27Z"
    },
    {
      "author": "p0W3RH311",
      "author_association": "NONE",
      "body": "another idea is to implement an indexer in _$foreach_ enumerator\r\n\r\n```\r\nforeach($item in $list) {\r\n   $foreach.index\r\n}\r\n```",
      "created_at": "2021-02-07T16:57:16Z",
      "updated_at": "2021-02-07T16:57:16Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "I think you wouldn't get too far before folks demanded a way to access an outer loop's indexer.  At that point, I don't think you need (or want) two ways to access indexers.",
      "created_at": "2021-02-07T16:58:31Z",
      "updated_at": "2021-02-07T16:58:31Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Agreed, @rkeithhill, but my point was that you would have a _choice_, i.e. I was advocating for _both_ proposals to be implemented: if you _do_ need cross-hierarchy index access, use the _explicit_ syntax; otherwise, rely on `$PSIndex` for convenience. But, again: this is really a moot point, because `$PSIndex` should only be implemented _in tandem_ with allowing `foreach ($collection) { ... }` (implicit iterator variable `$_` / `$PSItem`), which, as stated, has been rejected.\r\n\r\nIn short: I think we can conclude this part of the discussion, unless enough people feel strongly enough to revisit this, in a _separate_ proposal.\r\n\r\n---\r\n\r\nCome to think of it: `foreach ($item in $items; $ndx) { ... }` (`;` as the separator, index variable specified _after_) is preferable due to avoiding potential conceptual confusion due to `$ndx, $item in $items` looking like a  _destructuring assignment_.\r\n\r\nAlso, it would leave the door open for a further, separate enhancement that could further simplify the parallel-collection enumeration use case by using a destructuring assignment as follows (which could still be combined with an explicit index variable):\r\n\r\n```powershell\r\n$a = 'foo', 'bar'\r\n$b = 'baz', 'qux'\r\n$c = 'and' 'so on'\r\nforeach ($aElem, $bElem, $cElem in $a, $b, $c) { # WISHFUL THINKING\r\n   # $aElem is $a[<ndx>]\r\n   # $bElem is $b[<ndx>]\r\n   # $cElem is $c[<ndx>]\r\n}\r\n```\r\n\r\nThe _largest_ among the RHS collections would drive the number of iterations, and the iterator variables would contain `$null` for those collections that have run out of items.\r\n\r\n_Update_: See #14732\r\n\r\n",
      "created_at": "2021-02-07T17:04:37Z",
      "updated_at": "2021-02-08T16:24:39Z"
    },
    {
      "author": "p0W3RH311",
      "author_association": "NONE",
      "body": "@rkeithhill \r\n\r\nI think the common point is that powershell lacks an indexer variable like many other languages \u200b\u200b... now how to implement this indexer ... there are several ways on the design side: \r\n\r\npowershell way \r\n\r\n```\r\nforeach($item in $list) {\r\n   $foreach.index # another property\r\n}\r\n```\r\n\r\nor\r\n```\r\nforeach($item in $list) {\r\n   $PSindex # magic variable\r\n}\r\n```\r\n\r\nthe traditional way\r\n\r\n```\r\nforeach($i, $item in $list) {\r\n   $foreach.index\r\n}\r\n```",
      "created_at": "2021-02-07T17:05:26Z",
      "updated_at": "2021-02-07T17:06:20Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "@p0W3RH311 I'm with you on the \"common point\".  I like the feature suggestion.  I'm just not a fan of using a magic variable for the indexer.  \ud83e\udd37\u200d\u2642\ufe0f",
      "created_at": "2021-02-07T17:11:46Z",
      "updated_at": "2021-02-07T17:11:46Z"
    },
    {
      "author": "237dmitry",
      "author_association": "NONE",
      "body": "> another idea is to implement an indexer in _$foreach_ enumerator\r\n> \r\n> ```\r\n> foreach($item in $list) {\r\n>    $foreach.index\r\n> }\r\n> ```\r\n\r\nIt probably won't work with `$foreach`. What will `$foreach.index` be in the case of `$foreach.Reset()`?\r\n\r\n```\r\n$ind = 0; foreach ($i in 'a','b','c')    \r\n {                                       \r\n     $foreach.Current                    \r\n     if ($ind -eq 1) { $foreach.Reset() }\r\n     $ind++                              \r\n }                                       \r\n```",
      "created_at": "2021-02-07T18:19:19Z",
      "updated_at": "2021-02-07T18:19:19Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> What specific problems does this solve in many languages like python, ruby, perl, rust, javascript, Go, Scala, Php....etc\r\n\r\nThis isn't a very compelling argument imo.  There are a lot of patterns in other languages that just don't make as much sense in PowerShell.\r\n\r\nIt's definitely useful occasionally to have an index in PowerShell, but with the way pipelines work it's significantly less important. Personally I worry that this would be used too infrequently to warrant language changes.",
      "created_at": "2021-02-08T14:43:48Z",
      "updated_at": "2021-02-08T14:43:48Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Agreed re the general point that not all patterns are a good fit for PowerShell, however:\r\n\r\n> the way pipelines work it's significantly less important.\r\n\r\nCan you elaborate on how the pipeline mechanism makes this feature less important? \r\n\r\n#13772 makes  a pretty good case for a an automatic `$PSIndex` variable in the _pipeline_; for symmetry alone it makes sense to provide an analogous feature in `foreach` statements (with an _explicit_ index variable, analogous to how you need an _explicit_ iterator variable).\r\n\r\nTo me, it's a useful enhancement, both in `ForEach-Object` / `Where-Object`-based pipelines (and, by extension, in the `.ForEach()` and `.Where()` methods) and `foreach` loops.\r\n\r\n* In the former case, implementing `$PSIndex` is trivial - no new syntax needed, just a new variable you're free to use or not.\r\n\r\n* In the latter case, explicit (opt-in) syntax is needed, but `foreach ($name in 'foo', 'bar'; $ndx) { ... }` strikes me as a perfectly reasonable extension to the current syntax (the `;` should already be familiar from `for` loops).\r\n\r\n\r\n",
      "created_at": "2021-02-08T15:13:05Z",
      "updated_at": "2021-02-08T15:13:05Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> Can you elaborate on how the pipeline mechanism makes this feature less important?\r\n\r\nIn other languages it's very common to allocate an array up front and then populate it.  Or mutate an array in place.  In PowerShell it's significantly easier to just let the pipeline make one for you.\r\n\r\n> #13772 makes a pretty good case for a an automatic `$PSIndex` variable in the _pipeline_;\r\n\r\nWith the exception of \"Combine single arrays into columns\" I don't really see any real world examples in that issue.  I think it's just as unlikely to see all that much usage.\r\n\r\n> for symmetry alone it makes sense to provide an analogous feature in `foreach` statements\r\n\r\nSymmetry is nice, but I disagree that it's a compelling enough reason on it's own.",
      "created_at": "2021-02-08T15:28:51Z",
      "updated_at": "2021-02-08T15:28:51Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "* An automatically maintained index provides utility irrespective of whether it is used in a streaming pipeline or during iteration of an in-memory array.\r\n\r\n* Because it is useful in both scenarios, it should be implemented in both (that is to say, the need for symmetry is driven by the feature's _utility_).\r\n\r\nThis comes down to whether one indeed sees the utility, which is ultimately a subjective assessment. Let's see how the community feels.",
      "created_at": "2021-02-08T15:38:27Z",
      "updated_at": "2021-02-08T15:55:57Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I've created a new issue for the separate `foreach ($aElem, $bElem, $cElem in $a, $b, $c) { ... }` proposal mentioned [above](https://github.com/PowerShell/PowerShell/issues/14724#issuecomment-774709735) (enumerating multiple collections in tandem): #14732\r\n\r\nAlso, to make it more obvious how people feel about _this_ issue, I encourage everyone who was commented so far to give the _initial_ post here a thumbs-up or -down.\r\n",
      "created_at": "2021-02-08T16:23:27Z",
      "updated_at": "2021-02-08T16:23:27Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> * An automatically maintained index provides utility irrespective of whether it is used in a streaming pipeline or during iteration of an in-memory array.\r\n\r\nSorry, to clarify, I was giving examples of some of the most common scenarios one would use an index in other languages. Scenarios that are significantly less common in PowerShell.",
      "created_at": "2021-02-08T16:37:24Z",
      "updated_at": "2021-02-08T16:37:24Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I see, but the fact there are _additional_ scenarios in other languages where indices are not only useful but _required_ as an _intrinsic part of the enumeration_ is ultimately a moot point. To put it differently: this argument doesn't preclude utility in PowerShell scenarios.\r\n\r\nThe relevant question is: Is the feature useful _in PowerShell_?\r\n\r\nIt is to me, and I have personally wished for it in the past; we'll see how the community feels over time.\r\n",
      "created_at": "2021-02-08T17:22:44Z",
      "updated_at": "2021-02-08T17:22:44Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> I see, but the fact there are _additional_ scenarios in other languages where indices are not only useful but _required_ as an _intrinsic part of the enumeration_ is ultimately a moot point. To put it differently: this argument doesn't preclude utility in PowerShell scenarios.\r\n\r\nThat's correct.  It was in response to your question asking why the pipeline makes it less important in PowerShell.\r\n\r\n> It is to me, and I have personally wished for it in the past; we'll see how the community feels over time.\r\n\r\nI think one of the best ways to show the utility would be to point to some examples of existing code that would greatly benefit from this.  Like some code in an already published module or script that would be simplified significantly.\r\n\r\nI don't doubt that it has uses.  I've wanted it myself a few times, but in all of those few times either a `for` loop, incrementing my own var or just a different pattern was perfectly suitable.  Remember that language changes need a pretty dramatic effect to be worth it.",
      "created_at": "2021-02-08T17:35:52Z",
      "updated_at": "2021-02-08T17:35:52Z"
    },
    {
      "author": "p0W3RH311",
      "author_association": "NONE",
      "body": "> \r\n> \r\n> > What specific problems does this solve in many languages like python, ruby, perl, rust, javascript, Go, Scala, Php....etc\r\n> \r\n> This isn't a very compelling argument imo. There are a lot of patterns in other languages that just don't make as much sense in PowerShell.\r\n> \r\n>  Personally I worry that this would be used too infrequently to warrant language changes.\r\n\r\nin PS there are many variable too infrequently  used like $^ and $$ but this variable exist...indexer is usefull and perphaps is more usefull in future....these variable` ($^ and $$...etc)` and others esoteric like `${c:\\hello.txt} = 'foo'`  exist but nobody said they are useless..",
      "created_at": "2021-02-08T17:53:22Z",
      "updated_at": "2021-02-08T18:01:26Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@SeeminglyScience:\r\n\r\nFair point, but I was confused by your mentioning the pipeline specifically, because enumeration of collections with `foreach ($element in $collection)` too obviates the need for indices (as it does in the equivalent C# statement, for instance), if (read-only) enumeration _alone_ is needed.\r\n\r\n_Optionally_ - if the business logic rather than the technical underpinnings requires it - having an automatically maintained index at one's disposal, without having to forgo the convenience of `foreach ($element in $collection)` seems beneficial to me.  \r\n\r\n>  need a pretty dramatic effect to be worth it.\r\n\r\nPoint taken, but even though we are undoubtedly talking about _syntactic sugar_ here, such sugar is often important for sweetening the developer experience, if you will.\r\n\r\nI'll see if I can come up with examples in published code and/or additional compelling examples.\r\nI'm hoping others will too.\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2021-02-08T18:09:33Z",
      "updated_at": "2021-02-08T18:09:33Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> Fair point, but I was confused by your mentioning the pipeline specifically, because enumeration of collections with `foreach ($element in $collection)` too obviates the need for indices (as it does in the equivalent C# statement, for instance), if (read-only) enumeration _alone_ is needed.\r\n\r\nAh yes sorry it wasn't obvious what I was referring to, but most things use the pipeline plumbing at some point.  For example:\r\n\r\n```powershell\r\n$a = foreach ($b in (0..30)) { $b }\r\n\r\n# or \r\n\r\n$a = gci\r\n\r\n# or \r\n\r\n$a = $(0; 1)\r\n```\r\n\r\nBehind the scenes that'll use a very *similar* code path to build `$a` even though there is no `PipelineAst` language wise (except in the `gci` example).  I guess it would be more accurate to refer to it as \"output semantics\" maybe?",
      "created_at": "2021-02-08T18:19:34Z",
      "updated_at": "2021-02-08T18:21:56Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Good point, @SeeminglyScience, and thanks for clarifying.\r\n\r\nEven though it's technically not entirely accurate, I generally suggest using  and interpreting the term \"pipeline\" as informal shorthand for \"connecting _commands_ with a _pipe symbol_\" (including the case where the first segment is an _expression_; e.g. `1..10 | ForEach-Object { \"[$_]\" }`),  as distinct from the world of _expressions_ (e.g. `1 + 1`) and _statements_\r\n(e.g. `foreach ($num in 1..10) { \"[$num]\" }`).\r\n\r\nHere, we have the contrast between the `ForEach-Object` _command_ with its (invariably) _implicit_ iterator variable, `$_` (`$PSItem`) and the `foreach` _statement_ with its (invariably) _explicit, user-chosen_ iterator variable.\r\n\r\nTherefore, in the pipeline (loosely speaking), the proposed automatic index variable must be implicit too, with a name such as `$PSIndex`, as proposed by @iRon7 in #13772.\r\n\r\n(As stated, it would make sense to me to _also_ allow _implicit_ iterator variables in `foreach` _statements_ too - \r\n`foreach (1..10) { \"[$_]\" }` - but only if `$_` / `$PSItem` were to be supported - which was rejected - would it make sense to me to also support `$PSIndex`)\r\n\r\n---\r\n\r\nThe following uses cases are more directly relevant to #13772, but since the unified discussion seems to be happening here, here goes:\r\n\r\nIn the pipeline, it isn't just `ForEach-Object` and `Where-Object` that would benefit from `$PSIndex`, but also:\r\n\r\n* delay-bind script blocks\r\n* calculated properties\r\n\r\nIn both cases the script blocks run in a _child_ scope - see #7157 - which makes maintaining a cross-invocation index variable via the _parent_ scope both obscure and cumbersome:\r\n\r\nConsider the scenario of renaming files to names that incorporate a sequence number via a _delay-bind script block_ (a real-world scenario that comes up repeatedly on Stack Overflow):\r\n\r\n```powershell\r\n# Delay-bind script block\r\n# Cumbersome and obscure, because you must refer to the $i variable in the *parent* scope.\r\n# Renames the input files to \"file1.txt\", \"file2.txt\", ...\r\n$i = 0\r\nGet-Item *.txt | Rename-Item -NewName { \"file\" + ++(Get-Variable -Scope 1 i).Value + \".txt\" } -WhatIf\r\n```\r\n\r\nWith `$PSIndex` this simplifies to:\r\n\r\n```powershell\r\n# WISHFUL THINKING.\r\nGet-Item *.txt | Rename-Item -NewName { \"file\" + (1 + $PSIndex) + \".txt\" } -WhatIf\r\n```\r\n\r\nThe same applies to a (script block-based) _calculated property_; consider the case of wanting to create sequence number-based identifiers via `Select-Object`:\r\n\r\n```powershell\r\n# WISHFUL THINKING.\r\nGet-Item *.txt | Select-Object @{ n='Id'; e={ 1 + $PSIndex } }, FullName\r\n```\r\n\r\nWhile the scoping problem doesn't arise with the `foreach` _statement_, an automatic indexer still makes for a nice, expressive simplification:\r\n\r\n```powershell\r\n# WISHFUL THINKING\r\nforeach ($file in Get-Item *.txt; $i) {\r\n  [pscustomobject] @{\r\n    Id = 1 + $i\r\n    FullName = $file.FullName\r\n  }\r\n}\r\n```",
      "created_at": "2021-02-10T14:56:51Z",
      "updated_at": "2021-02-10T16:19:36Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> Here, we have the contrast between the `ForEach-Object` _command_ with its (invariably) _implicit_ iterator variable, `$_` (`$PSItem`) and the `foreach` _statement_ with its (invariably) _explicit, user-chosen_ iterator variable.\r\n\r\nYeah it doesn't use the pipeline for enumeration, though it can emit to an output pipe still.\r\n\r\n\r\n> ```powershell\r\n> # Delay-bind script block\r\n> # Cumbersome and obscure, because you must refer to the $i variable in the *parent* scope.\r\n> # Renames the input files to \"file1.txt\", \"file2.txt\", ...\r\n> $i = 0\r\n> Get-Item *.txt | Rename-Item -NewName { \"file\" + ++(Get-Variable -Scope 1 i).Value + \".txt\" } -WhatIf\r\n> ```\r\n\r\nIf you're renaming files, aren't you going to want to keep the number of the existing name? Like if you're renaming `FileX.txt` to `SomethingX.txt` you probably don't want the index to be based on the order they're returned in most cases. The only time I can really think of that I've needed to do this is creating test files, where you typically do `0..10 | % { New-Item File$_.txt }` anyway.\r\n\r\nThe rest of the examples are similar in that while it **is** an example of how it could be used, it's not clear why you'd need to.",
      "created_at": "2021-02-10T15:36:06Z",
      "updated_at": "2021-02-10T15:36:06Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> though it can emit to an output pipe still.\r\n\r\nIf I understand correctly, _directly_ only stand-alone (possibly in the context of an assignment); in a pipeline (with `|`), only via `$()` / `@{)` (collecting all output up front) or via `& { ... }` / `. { ... }` (streaming), but I think we have clarity now on the syntactic scenarios we want to contrast.\r\n\r\n> If you're renaming files, aren't you going to want to keep the number of the existing name?\r\n> it's not clear why you'd need to.\r\n\r\n* There may be no numbers (lexical order), or the numbering may be different (e.g., start with an offset) and/or may have gaps.\r\n* Renaming files is just one example; needing to produce _sequence numbers_ is a common requirement in many different scenarios, as is _index-based filtering_.\r\n\r\n\r\n",
      "created_at": "2021-02-10T16:42:02Z",
      "updated_at": "2021-02-10T16:42:02Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> If I understand correctly, _directly_ only stand-alone (possibly in the context of an assignment); in a pipeline (with `|`), only via `$()` / `@{)` (collecting all output up front) or via `& { ... }` / `. { ... }` (streaming), but I think we have clarity now on the syntactic scenarios we want to contrast.\r\n\r\nAnything that isn't captured or in a class method is emitted to the pipeline.\r\n\r\nFor example:\r\n\r\n<details>\r\n\r\n<summary>This is what the script `0` compiles to</summary>\r\n\r\n```csharp\r\nprivate static void <ScriptBlock>(FunctionContext funcContext)\r\n{\r\n    try\r\n    {\r\n        context = funcContext._executionContext;\r\n        locals = ((MutableTuple<object, Object[], object, object, PSScriptCmdlet, PSBoundParametersDictionary, InvocationInfo, string, string, Null, Null, Null, Null, Null, Null, Null>)funcContext._localsTuple);\r\n        funcContext._functionName = @\"<ScriptBlock>\";\r\n        funcContext._currentSequencePointIndex = 0;\r\n\r\n        context._debugger.EnterScriptFunction(funcContext);\r\n        try\r\n        {\r\n            funcContext._currentSequencePointIndex = 1;\r\n            if (context._debuggingMode > 0)\r\n            {\r\n                context._debugger.OnSequencePointHit(funcContext)\r\n            }\r\n\r\n            funcContext._outputPipe.Add(((object)0));\r\n            context.QuestionMarkVariableValue = true;\r\n        }\r\n        catch (Exception exception)\r\n        {\r\n            ExceptionHandlingOps.CheckActionPreference(funcContext, exception);\r\n        }\r\n\r\n        funcContext._currentSequencePointIndex = 2;\r\n        if (context._debuggingMode > 0)\r\n        {\r\n            context._debugger.OnSequencePointHit(funcContext);\r\n        }\r\n    }\r\n    finally\r\n    {\r\n        context._debugger.ExitScriptFunction();\r\n    }\r\n}\r\n```\r\n\r\n</details>\r\n\r\nThe relevant line being:\r\n\r\n```csharp\r\nfuncContext._outputPipe.Add(((object)0));\r\n```\r\n\r\n> * There may be no numbers (lexical order), or the numbering may be different (e.g., start with an offset) and/or may have gaps.\r\n> * Renaming files is just one example; needing to produce _sequence numbers_ is a common requirement in many different scenarios, as is _index-based filtering_.\r\n\r\nMy suggestion if your aim is to convince someone to pick up this work (or convince someone that this should be brought up with the committee) would be to use real world examples.  Theoretical examples aren't as helpful for determining the level of impact a feature could provide.\r\n\r\n",
      "created_at": "2021-02-10T17:31:21Z",
      "updated_at": "2021-02-10T17:31:21Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> Anything that isn't captured or in a class method is emitted to the pipeline.\r\n\r\nYes, but my point was that you can't do `foreach ($i in 1..3) { $i } | Measure-Object`, for instance - you need `& { foreach ($i in 1..3) { $i } } | Measure-Object`, for instance; that is, you cannot use a _statement_ in a multi-segment pipeline - see https://github.com/PowerShell/PowerShell/issues/10967#issuecomment-561843650\r\n\r\n> My suggestion if your aim is to convince someone to pick up this work (or convince someone that this should be brought up with the committee) would be to use real world examples. \r\n\r\nHonestly, to me the examples given so far - both concrete and abstract - are so self-evidently compelling that I don't see value in spending more time on finding real-world examples.\r\n\r\nPerhaps others feel inspired to do so, and perhaps the count of thumbs-up on the issue will make a statement of its own over time.\r\n\r\nThe primary hurdle, I'd say, is to get this - and #13772 -  committee-reviewed; I wouldn't want anyone spending time on an implementation without knowing that the feature will be approved.\r\n@iSazonov, any thoughts?\r\n",
      "created_at": "2021-02-10T18:29:05Z",
      "updated_at": "2021-02-10T18:35:30Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Just yesterday, I thought PowerShell is at the same conceptual level as it was 20 years ago and is still at the foot of a magnificent tower - we haven't even climbed one floor in all this time. One must have limitless inspiration to develop primary ideas to these new heights.\r\nThinking so, I believe that it makes no sense to invest too much in traditional operators, but in PowerShell pipeline makes sense.",
      "created_at": "2021-02-11T14:53:56Z",
      "updated_at": "2021-02-11T14:53:56Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @iSazonov. I too value the conceptual elegance of PowerShell's OO pipeline and welcome improvements to it, but, as is often the case, this is not an _either-or_ proposition (more on that later).\r\n\r\nUnquestionable, what was initially proposed _here_ in the context of the `foreach` _statement_ and what is proposed with respect to the _pipeline_ (loosely speaking) in #13772 can be decided on _separately_ - even though I personally think that if it's worthwhile in one context, it is worthwhile in the other (see below).\r\n\r\nSo, if you already think #13772 is worthwhile, please tag it for committee review.\r\n\r\n(The generalization of #13772, which started with a focus on `ForEach-Object` and `Where-Object` is: provide an automatic index variable in any collection-processing script-block context where `$_` / `$PSItem` is defined, which also includes calculated properties and delay-bind script-block arguments, the `.ForEach()` and `.Where()` _methods_, the `switch` _statement_, and the `-replace` _operator_ (possibly more).)\r\n\r\n---\r\n\r\n>  it makes no sense to invest too much in traditional operators\r\n\r\nCmdlets such as `ForEach-Object` and language statements such as `foreach` loops  _complement_ each other and are appropriate for _different scenarios_.\r\n\r\nNeither is going away.\r\n\r\nBoth should provide an expressive developer experience _with (fundamental) feature parity_ (which, regrettably, already falls short in one case: the `.Where()` _method_ has useful features that `Where-Object` lacks: see #13834)\r\n\r\nA `foreach` loop far outperforms a `ForEach-Object`-based solution, and that alone makes it indispensable. This is especially pronounced with collections that are already in memory in full, but it even applies to `foreach ($obj in <command>)`; it also outperforms the `.ForEach()` _method_.\r\n\r\nIt comes down to a tradeoff between memory use and performance, and while in many cases you may be able to choose _any_ of these without too much real-world impact, there are cases where are _forced_ to choose one (`foreach` for performance) or the other (`ForEach-Object` to avoid running out of memory).\r\n\r\nAll three serve the same fundamental purpose: iterating over something enumerable (loosely speaking; strictly speaking, it is the _pipeline itself_ that does the enumeration in the case of `ForEach-Object`)\r\n\r\nAll three are _expressive_ in that you needn't worry about the _details_ of the enumeration: is it an index-based collection or a (potentially lazy) enumerable?\r\n\r\n`ForEach-Object` / `.ForEach()` do not even require you to _pick a variable name_ for the enumeration element at hand; the name is fixed in the form of the automatic `$_` / `$PSItem` variable.\r\n\r\nProviding an automatic index indicating the `0`-based position of the element at hand in the enumeration therefore similarly calls for such a variable, `$PSIndex`, as proposed in #13772 \r\n\r\nBy contrast, `foreach` _does_ require you to pick an iterator variable name - `$_` / `$PSItem` isn't supported.\r\nTherefore, it makes sense to also require picking an variable name for the automatic index - unlike with `$PSItem`, this necessitates an addition to the _syntax_, the proposed `foreach ($element in $enumerable; $index) { .. }`.\r\n\r\nIf such an automatically maintained index makes sense with `ForEach-Object` (among others), it also makes sense in a `foreach` loop - especially given that, as stated, sometime you have no choice but to use `foreach` over `ForEach-Object`.\r\n\r\n---\r\n\r\nI've said it before: the examples in #13772 and here to me amply demonstrate that such an automatic index is called for as _expressive syntactic sugar_ that serves real-world needs, which, as @p0W3RH311, has pointed out, several other languages have recognized too (notably [including the _systems_ programming language Rust](https://www.programming-idioms.org/idiom/7/iterate-over-list-indexes-and-values/415/rust))\r\n\r\nSyntactic sugar isn't a luxury; it's what makes a language enjoyable to use and boosts productivity.\r\n\r\nAnd here's a secret: `foreach ($element in $enumerable) { $element }` is _itself_ syntactic sugar:\r\n\r\n* In the case of an index-based enumerable, it is syntactic sugar for:\r\n `for ($i=0; $i -lt $enumerable.Count; ++$) { $enumerable[$i] }`\r\n\r\n* In the case of an enumeration-interface-based enumerable, it is syntactic sugar for:\r\n `while ($element = $enumerable.MoveNext()) { $element }`\r\n\r\nAnd with `foreach` you don't even have to worry which kind of enumerable you're dealing with.\r\n\r\nAlso note how the `for` loop _forces_ you to deal with indices - even though you may not actually need them.\r\nConversely, if you _do_ need them in the `.MoveNext()` `while` loop, you have to _add them manually_.\r\n\r\n* `foreach` already takes the drudgery out of the enumeration part.\r\n\r\n* Wouldn't it be nice if it also took out the drudgery of the _index_ part, _if and when_ you actually need an index, for _business-logic reasons_, not as a syntactic necessity?\r\n\r\n\r\n\r\n \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2021-02-11T21:24:12Z",
      "updated_at": "2021-02-11T22:19:08Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "I have to say that whenever I've needed something like this, I've just changed to a `for(){}` loop, or added a counter variable.\r\n\r\nI don't mind the idea of adding syntax to `foreach(){}` to define a counter variable to be incremented for me, but I'm not convinced the savings are worth it. I mean, is this:\r\n\r\n```PowerShell                                              \r\nforeach($item in @($List); $index) {           \r\n  $item | add-member Index $index -PassThru    \r\n}                                              \r\n```\r\n\r\nReally better than this:\r\n```PowerShell\r\n$index=0; foreach($item in @($List)) {         \r\n  $item | add-member Index ($index++) -PassThru\r\n}\r\n```\r\n\r\nRemember that it's not just about saving you a few keystrokes, it's also about clarity and readability ...\r\n\r\nTo make it clearer, we could add a parameter (there's precedent in `switch`):\r\n```PowerShell\r\nforeach($item in @($List)) -counter index {           \r\n  $item | add-member Index $index -PassThru    \r\n}\r\n```",
      "created_at": "2021-04-07T05:06:00Z",
      "updated_at": "2021-04-07T05:07:54Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> Really better than this\r\n\r\nTo me it is unequivocally better:\r\n\r\n* no need to declare a variable _outside_ the loop (even though based on PowerShell's scoping rules even the syntactic-sugar index variable would live on beyond the loop, as the iteration variable already does, but that's a separate issue)\r\n\r\n* no messing with `$index++` for incrementing, which is notoriously error-prone.\r\n\r\n> Remember that it's not just about saving you a few keystrokes, it's also about clarity and readability ...\r\n\r\nAgreed, but to me `foreach($item in @($List); $index)` fulfills that criterion (syntactically simple, easily documented and remembered) - even though it isn't as verbose as `-counter index`, but I am wary of this mixing of PowerShell's parsing worlds (argument vs. expression mode):\r\n\r\nYes, `switch` is the precedent, but the only one, and an awkward one at that; e.g., in `switch -File file.txt { ... }`, `file.txt` is parsed as an argument and may therefore - despite being a _string_ - be _unquoted_; by contrast, a direct input object must be supplied inside (`...`), which forces a new parsing context where a bareword string is _not_ supported, as it would be interpreted as a _command_; e.g., `switch (mystring) { ... }` looks for a _command_ named `mystring`. Similar confusion can arise in the branch conditions - see #3668.\r\n\r\n\r\n\r\n",
      "created_at": "2021-04-07T20:38:28Z",
      "updated_at": "2021-04-07T20:38:28Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "After discussing this with the Engine working group, we don't think this should be baked in at the language/syntax level. This is probably best accomplished with a function like Python's [enumerate](https://docs.python.org/3/library/functions.html#enumerate). This could be implemented in an external module and later evaluated for inclusion in PowerShell.",
      "created_at": "2021-05-13T18:04:14Z",
      "updated_at": "2021-05-13T18:08:19Z"
    }
  ],
  "created_at": "2021-02-07T11:09:47Z",
  "number": 14724,
  "state": "closed",
  "title": "implement indexer in loop",
  "updated_at": "2021-05-13T18:08:19Z"
}