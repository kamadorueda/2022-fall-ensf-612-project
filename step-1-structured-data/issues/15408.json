{
  "_url": "https://github.com/PowerShell/PowerShell/issues/15408",
  "author": "JamesWTruher",
  "body": "<!-- Anything that looks like this is a comment and can't be seen after the Pull Request is created. -->\r\n\r\n# PR Summary\r\n\r\nThis PR targets a _consistent_ default behavior between PowerShell 5 and PowerShell 7 on Windows for some executables and file types. The behavior is now update to use the legacy behavior for the following files:\r\n\r\n - cmd.exe\r\n- cscript.exe\r\n- wscript.exe\r\n- ending with .bat\r\n- ending with .cmd\r\n- ending with .vbs\r\n\r\nThis list is table driven, and can be easily altered. I have started with this list as I am familiar with real world issues with them.\r\n\r\nThe PSNativeArgumentPassing preference value has been expanded to include the new value `Windows`.  When the preference variable is set to `Windows` the above table will be in effect, meaning that invocations of those files will automatically use the `Legacy` style argument passing. If the PSNativeArgumentPassing is set to either `Legacy` or `Standard`, then the additional checks will _not_ take place.\r\n\r\nThe default behavior is now also platform specific. On Windows platforms, the default setting will be `Windows` and non-Windows platforms will be `Standard`.\r\n\r\n\r\n<!-- Summarize your PR between here and the checklist. -->\r\n\r\n## PR Context\r\n\r\n<!-- Provide a little reasoning as to why this Pull Request helps and why you have opened it. -->\r\n\r\n## PR Checklist\r\n\r\n- [x] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [x] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [ ] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` or `[ WIP ]` to the beginning of the title (the `WIP` bot will keep its status check at `Pending` while the prefix is present) and remove the prefix when the PR is ready.\r\n- **[Breaking changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)**\r\n    - [ ] None\r\n    - **OR**\r\n    - [ ] [Experimental feature(s) needed](https://github.com/MicrosoftDocs/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/About/about_Experimental_Features.md)\r\n        - [x] Experimental feature name(s): PSNativeCommandArgumentPassing\r\n- **User-facing changes**\r\n    - [ ] Not Applicable\r\n    - **OR**\r\n    - [x] [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n- **Testing - New and feature**\r\n    - [ ] N/A or can only be tested interactively\r\n    - **OR**\r\n    - [x] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n- **Tooling**\r\n    - [x] I have considered the user experience from a tooling perspective and don't believe tooling will be impacted.\r\n    - **OR**\r\n    - [ ] I have considered the user experience from a tooling perspective and opened an issue in the relevant tool repository. This may include:\r\n        - [ ] Impact on [PowerShell Editor Services](https://github.com/PowerShell/PowerShellEditorServices) which is used in the [PowerShell extension](https://github.com/PowerShell/vscode-powershell) for VSCode\r\n        (which runs in a different PS Host).\r\n            - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n        - [ ] Impact on Completions (both in the console and in editors) - one of PowerShell's most powerful features.\r\n            - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n        - [ ] Impact on [PSScriptAnalyzer](https://github.com/PowerShell/PSScriptAnalyzer) (which provides linting & formatting in the editor extensions).\r\n            - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n        - [ ] Impact on [EditorSyntax](https://github.com/PowerShell/EditorSyntax) (which provides syntax highlighting with in VSCode, GitHub, and many other editors).\r\n            - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n",
  "closed_at": "2021-07-20T23:10:04Z",
  "comments": [
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "I believe this PR addresses part of https://github.com/PowerShell/PowerShell/issues/15143",
      "created_at": "2021-05-21T01:34:06Z",
      "updated_at": "2021-05-21T01:34:06Z"
    },
    {
      "author": "JamesWTruher",
      "author_association": "MEMBER",
      "body": "@SteveL-MSFT - I think I've addressed your issues, please let me know",
      "created_at": "2021-05-28T19:24:16Z",
      "updated_at": "2021-05-28T19:24:16Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@JamesWTruher one comment was not addressed",
      "created_at": "2021-05-29T15:14:46Z",
      "updated_at": "2021-05-29T15:14:46Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "I'm not sure this is working completely for cmd.exe - ie excluding cmd.exe.  preview.6 breaks the `Invoke-BatchFile` command we have implemented in PSCX:\r\n```\r\nPS> invoke-batchfile 'C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Auxiliary\\Build\\vcvarsall.bat' amd64\r\n'\\\"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Auxiliary\\Build\\vcvarsall.bat\\\"' is not recognized as an internal or external command,\r\noperable program or batch file.\r\n```\r\nThis is basically Lee Holmes old function that we have implemented in PSCX:\r\n```powershell\r\nfunction Invoke-BatchFile\r\n{\r\n    param([string]$Path, [string]$Parameters)\r\n\r\n    $tempFile = [IO.Path]::GetTempFileName()\r\n\r\n    ## Store the output of cmd.exe.  We also ask cmd.exe to output\r\n    ## the environment table after the batch file completes\r\n    cmd.exe /c \" `\"$Path`\" $Parameters && set \" > $tempFile\r\n    ...\r\n}\r\n```\r\nReverting to `Legacy` makes this function work again but at this rate I suspect I'll be running `Legacy` on all my Windows installs.  :-(",
      "created_at": "2021-06-03T22:12:13Z",
      "updated_at": "2021-06-03T23:44:38Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as Review Needed because it has been there has not been any activity for **7 days**.\nMaintainer, please provide feedback and/or mark it as `Waiting on Author`",
      "created_at": "2021-06-11T02:00:08Z",
      "updated_at": "2021-06-11T02:00:08Z"
    },
    {
      "author": "JamesWTruher",
      "author_association": "MEMBER",
      "body": "@rkeithhill wrt the pscx issue that you mentioned. Have you tried running _this_ branch against your scenario? This PR is _supposed_ to automatically put the arg passing into legacy mode for cmd.exe invocations, so it should be fine (but I would really like confirmation on that). I've added validation for that very scenario, but I might have missed something.",
      "created_at": "2021-06-14T19:23:31Z",
      "updated_at": "2021-06-14T19:23:31Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "I built this branch and yes, that command works now while I still have the mode set to `Windows`:\r\n\r\n![image](https://user-images.githubusercontent.com/5177512/121964380-b42a7780-cd28-11eb-842c-47e2ce7a0c86.png)\r\n",
      "created_at": "2021-06-14T21:54:47Z",
      "updated_at": "2021-06-14T21:54:47Z"
    },
    {
      "author": "JamesWTruher",
      "author_association": "MEMBER",
      "body": "@rkeithhill - excellent - the default setting for windows will be \"Windows\", which is the hybrid model where certain commands will run as Legacy while others will use \"Standard\". This should hopefully be better and allow the wacky parsing that happens for batch files, but enable more modern apps to use the new style.",
      "created_at": "2021-06-15T17:18:41Z",
      "updated_at": "2021-06-15T17:18:41Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT \r\n\r\n> I believe this PR addresses part of #15143\r\n\r\nI haven't looked at the code, but judging by this PR's description, it doesn't:\r\n\r\n* `cmd /c $someCommandLine` (e.g., `cmd /c 'echo \"hi there\"'`) never needed fixing - _it is the only case that always worked correctly_ - serendipitously, because PowerShell's non-escaping of embedded `\"` happens to be canceled out by `cmd.exe`'s \"quirky\" parsing.\r\n  * Conversely, it mustn't be broken in _any_ mode (it currently is broken in `Standard` mode - see #15239).\r\n\r\n* Therefore, none of the truly new accommodations proposed in #15143 are seemingly addressed by this PR.\r\n\r\n  * Conversely, selectively reverting to the - hopelessly broken - _legacy_ behavior just means replacing an old mess with a new one (and a more confusing one at that).\r\n\r\n---\r\n\r\nThe only way to avoid a mess is to:\r\n\r\n* Stick with two modes: `Legacy` vs. `Standard`.\r\n\r\n* In `Standard` mode, implement all accommodations proposed in  #15143 - this should make the vast majority of calls that  (rightfully) rely on PowerShell syntax only just work; for the rest, `--%` or a (non-broken) `cmd /c $someCommandLine` allow full control over the command line passed on Windows - no need for `Legacy` ever, except for actual legacy code.\r\n\r\n---\r\n\r\nAnd as for the proposed _default_ values for `$PSNativeCommandArgumentPassing`: \r\n(I'm aware of the irony of saying this, given that I have often pushed for breaking changes.)\r\n\r\nWhile I'm personally fine with defaulting to the _new_ behavior (assuming it is sensibly implemented), which will undoubtedly make future users happy, existing users with legacy code should brace for a massively breaking change.\r\n\r\n",
      "created_at": "2021-06-17T18:17:16Z",
      "updated_at": "2021-06-17T18:18:37Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@mklement0 the purpose of this PR is to augment the `NativeCommandArgumentPassing` experimental feature so that `cmd` (and some others) are special cased when using `Windows` mode for argument passing which falls back to legacy behavior.  `Windows` mode will be default on Windows.\r\n\r\nThe big feedback we got from customers using a PS7 preview in production is that they can't simply move to a brand new arg passing model as they need to support both WinPS5.1 and PS7.  Since 5.1 will still be used quite a bit for a long time, AND we expect users of 5.1 have already worked out workarounds needed that they would expect to continue to work in 7.2, reverting to legacy when using `Windows` and the allow list (cmd, js, etc...) would be the most compatible.\r\n\r\nNote that because the modes are an enum, we could potentially have a `Custom` mode in the future where some configuration defines how to escape \"non-standard\" Windows executables so that the user doesn't have to know about them, but would probably break in other scenarios if too much \"magic\" happens.",
      "created_at": "2021-06-17T21:24:18Z",
      "updated_at": "2021-06-17T21:26:02Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT, i can see only 3 scenarios, and none of them are helped by what this PR proposes - on the contrary:\r\n\r\n* (a) Users who are unencumbered with respect to legacy code:\r\n  * They can use `Standard` mode - as modified by #15143 - and live happily ever after.\r\n\r\n* (b) Users who use legacy code they cannot update / don't want to spend time updating, but needn't worry about future code they write being backward-compatible with Windows PowerShell:\r\n  * They can selectively use `Legacy` mode - for the legacy code - and live happily ever after.\r\n  * That said, selectively applying a preference variable is hampered by cross-scope-domain code not honoring the caller's preference variables - see #4568 - but that's a separate debate; _temporarily_ setting  the _global_ copy of the preference variable so that modules see it may be necessary.\r\n  * Similarly, in the absence of lexical scoping accidental propagation of the preference to descendant scopes must be guarded against.\r\n  * See the discussion at https://github.com/PowerShell/PowerShell/issues/14747#issuecomment-784578379\r\n\r\n* (c) Users who must continue to author code that also runs in Windows PowerShell.\r\n\r\n  *  They can use `Legacy` mode consistently - which, as before, is cumbersome and requires obscure workarounds, but that's an unavoidable price to pay.\r\n  * The pain can be mitigated via a helper function that emulates the new `Standard` behavior (as modified by #15143), such as the `ie` function from the [`Native` module](https://github.com/mklement0/Native). (Believe me, this isn't about promoting _my_ module's function; it just so happens to be the least painful solution that I know of; in an ideal world there would never have been a need for such a function.)\r\n\r\nLet's be clear that the proposed `Windows` mode will still break a good deal of existing code based on legacy workarounds, namely all calls to executables / interpreters _not_ in the table of exceptions, such as Node.js, for instance.\r\n\r\nIn `Windows` mode, having to reason with respect to a given call whether the legacy or the new behavior applies only complicates matters - the example I've given before is the `az` CLI, which just so happens to be implemented as `az.cmd`, i.e. as  a _batch file_. But that is an _implementation detail_ that no user should have to pay attention to or should even need to be aware of.\r\n",
      "created_at": "2021-06-18T04:39:51Z",
      "updated_at": "2021-06-18T13:37:11Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "To flesh out my previous concern:\r\n\r\nMy _guess_ is that many existing workarounds on Windows  do _not_ relate to the executables in the fallback-to-legacy tables, and such workarounds will simply break with `Windows` in effect; e.g.:\r\n\r\n```powershell\r\n# *Workaround* that works up to v7.1, but breaks with a `$PSNativeCommandArgumentPassing` value\r\n#  other than 'Legacy'.\r\ncurl.exe https://httpbin.org/post -d '{ \\\"foo\\\": \\\"bar\\\" }' -H 'Content-Type: application/json'\r\n\r\n# Ditto.\r\nnode -e 'console.log(\\\"hi\\\")'\r\n``` \r\n\r\nAnd, of course, with `Standard` as the default on Unix, _all_ existing workarounds will break there - but the real concern is the confusing blending of correct and broken legacy behavior on Windows in the form of the ill-begotten `Windows` mode, depending on how the target executable happens to be implemented.\r\n\r\nAnd even if you _do_ know what behavior applies on Windows in a given call, that you selectively have to revert to workarounds for _broken_ behavior - even though PowerShell _could_ implement the correct behavior - sounds like a cruel joke.\r\n\r\nAgain: for someone who needs to continue to author code for both editions, sticking with `Legacy` and the known workarounds _consistently_ is by far the simpler solution.\r\n\r\nSomeone who needs to selectively run old code can activate `Legacy` selectively (or reverse the logic: activate `Standard` selectively).\r\n\r\nThat PowerShell lacks lexical scoping for preferences and, conversely, a cross-module mechanism for setting preferences, and therefore makes their selective application challenging is unfortunate, but not specific to the problem at hand.\r\n\r\nUltimately, I think, the only headache-free way out of this mess is via a _distinct call operator or function_ that selects either the legacy or the (consistently) correct behavior: then each call's behavior can easily reasoned about _by itself_, and doesn't depend on possibly hidden state through dynamically scoped preferences.\r\n\r\nOf course, the challenges are (a) what operator sigil or function name to come up with, and (b) the separate operator/function serving as a perennial reminder that the original implementation was broken.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2021-06-19T02:51:27Z",
      "updated_at": "2021-06-19T02:53:02Z"
    },
    {
      "author": "Luiz-Monad",
      "author_association": "NONE",
      "body": "This is such a dumpster fire, like I use powershell because I couldn't care less about `cmd`, I just wanted it to die. \r\n(who writes batch files ? they are all considered broken anyway, but I do understand they need to be supported, just not at the expense of the evolution of Powershell, otherwise I'll just plug my own `NativeCommandProcessor`, wait there's no way to extend custom command processors, fine, I will recompile my own `pwsh-core`, its going to be super fun for other people coming to my projects and seeing that not only I have a custom `CMake` (for other reasons, like C++/CLI hell) , but I also have a custom `Powershell` )\r\n(( perhaps it would be a neat feature for solving those nastiness, like create a `CmdCommandProcessor` or something, and keep it away from the rest of powershell ! ))\r\nPlease don't break `$PSNativeCommandArgumentPassing` by setting it to other than `Standard` or worse, making it do shenanigans other than passing all the arguments directly to Process-Start args collection. \r\n\r\n```\r\ncinst powershell-core\r\npwsh\r\n& something 'should just work'\r\n # the way user intended, all strings passed should end up on argv array of the process\r\n```\r\n\r\nAll I was doing was just trying to make my CMake powershell build script run multiplatform, with support for VT, and redirecting the error output with performance, but that's another problem, I made my own CmdLet for this on top of the start process, I was looking for something like `Native` to solve this nastiness.\r\n\r\nI guess, it would be easier to recompile CMake with a parameter like `EncodedCommand` that passes a single Base64 string.\r\nPerhaps this is the only way... \r\n\r\n",
      "created_at": "2021-06-22T17:36:10Z",
      "updated_at": "2021-06-22T17:40:27Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee discussed the feedback, we would be concerned about trying to abstract all known workarounds on Windows given the inconsistency of how native commands handle escaping.  The intent of this PR is to address a known impact raised by users of this experimental feature.  In the example of:\r\n\r\n```powershell\r\ncurl.exe https://httpbin.org/post -d '{ \\\"foo\\\": \\\"bar\\\" }' -H 'Content-Type: application/json'\r\nnode -e 'console.log(\\\"hi\\\")'\r\n```\r\n\r\nUsers who want to maintain known workarounds, they should use `Legacy`.  With `Windows` mode (or `Standard`) they would not need to escape the double quotes:\r\n\r\n```powershell\r\ncurl.exe https://httpbin.org/post -d '{ \"foo\": \"bar\" }' -H 'Content-Type: application/json'\r\nnode -e 'console.log(\"hi\")'\r\n```\r\n\r\nBased on real world user feedback, we agreed to address some well known and used legacy apps like wscript and cmd for `Windows` mode.  We will evaluate any new feedback as separate issues/discussion from using this experimental feature.\r\n",
      "created_at": "2021-06-30T22:45:08Z",
      "updated_at": "2021-06-30T22:45:08Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as Review Needed because it has been there has not been any activity for **7 days**.\nMaintainer, please provide feedback and/or mark it as `Waiting on Author`",
      "created_at": "2021-07-08T02:00:50Z",
      "updated_at": "2021-07-08T02:00:50Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "Reassigning to @rjmholt as @daxian-dbw is taking time off right now",
      "created_at": "2021-07-19T18:19:03Z",
      "updated_at": "2021-07-19T18:19:03Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "Opened https://github.com/JamesWTruher/PowerShell-1/pull/15 to add remaining suggested changes",
      "created_at": "2021-07-20T21:19:07Z",
      "updated_at": "2021-07-20T21:19:07Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "/azp run",
      "created_at": "2021-07-20T22:28:36Z",
      "updated_at": "2021-07-20T22:28:36Z"
    },
    {
      "author": "azure-pipelines[bot]",
      "author_association": "NONE",
      "body": "<samp>\nAzure Pipelines successfully started running 6 pipeline(s).<br>\r\n\n</samp>",
      "created_at": "2021-07-20T22:29:12Z",
      "updated_at": "2021-07-20T22:29:12Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": ":tada:`v7.2.0-preview.8` has been released which incorporates this pull request.:tada:\n\nHandy links:\n* [Release Notes](https://github.com/PowerShell/PowerShell/releases/tag/v7.2.0-preview.8)\n",
      "created_at": "2021-07-22T21:42:10Z",
      "updated_at": "2021-07-22T21:42:10Z"
    }
  ],
  "created_at": "2021-05-14T20:31:57Z",
  "number": 15408,
  "state": "closed",
  "title": "Add a Windows mode for native commands that allows some commands to use legacy argument passing",
  "updated_at": "2021-07-22T21:42:10Z"
}