{
  "_url": "https://github.com/PowerShell/PowerShell/issues/9308",
  "author": "bergmeister",
  "body": "This issue is relevant to the new PSSA bug https://github.com/PowerShell/PSScriptAnalyzer/issues/1209 and relates to probably any version of PowerShell\r\n\r\n# Steps to reproduce\r\n\r\n```powershell\r\n> Get-Command -Name '?'\r\n```\r\n\r\n# Expected behavior\r\n\r\n```powershell\r\n> Get-Command -Name '?'\r\n\r\nCommandType     Name                                               Version    Source\r\n-----------     ----                                               -------    ------\r\nAlias           ? -> Where-Object\r\n```\r\n\r\n# Actual behavior\r\n\r\n```powershell\r\n> Get-Command -Name '?'\r\n\r\nCommandType     Name                                               Version    Source\r\n-----------     ----                                               -------    ------\r\nAlias           % -> ForEach-Object\r\nAlias           ? -> Where-Object\r\nAlias           d -> dotnet.exe\r\nAlias           g -> git.exe\r\nAlias           h -> Get-History\r\nAlias           r -> Invoke-History\r\n```\r\n\r\n# Environment data\r\n\r\n- Windows 10 1809\r\n- Any version of PowerShell (6.2, 5.1, etc.)\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I'm assuming that's because `?` is being interpreted as the single-character wildcard when searching for commands.",
      "created_at": "2019-04-06T12:40:37Z",
      "updated_at": "2019-04-06T12:40:37Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "This seems related to some other things that @mklement0 has brought up in other wildcard-escaping issues. You actually have to escape the wildcard _twice_ to get it to register what you're looking for:\r\n\r\n```\r\nPS C:\\Users\\Joel> gcm ?\r\n\r\nCommandType     Name                                               Version    Source\r\n-----------     ----                                               -------    ------\r\nAlias           % -> ForEach-Object\r\nAlias           ? -> Where-Object\r\nAlias           h -> Get-History\r\nAlias           r -> Invoke-History\r\n\r\n\r\nPS C:\\Users\\Joel> gcm `?\r\n\r\nCommandType     Name                                               Version    Source\r\n-----------     ----                                               -------    ------\r\nAlias           % -> ForEach-Object\r\nAlias           ? -> Where-Object\r\nAlias           h -> Get-History\r\nAlias           r -> Invoke-History\r\n\r\n\r\nPS C:\\Users\\Joel> gcm ``?\r\n\r\nCommandType     Name                                               Version    Source\r\n-----------     ----                                               -------    ------\r\nAlias           ? -> Where-Object\r\n\r\n```",
      "created_at": "2019-04-06T14:37:36Z",
      "updated_at": "2019-04-06T14:37:36Z"
    },
    {
      "author": "mkht",
      "author_association": "NONE",
      "body": "FYI\r\n\r\n```PowerShell\r\nPS C:\\> gcm \"?\"\r\n\r\nCommandType     Name                                               Version    Source\r\n-----------     ----                                               -------    ------\r\nAlias           % -> ForEach-Object\r\nAlias           ? -> Where-Object\r\nAlias           h -> Get-History\r\nAlias           r -> Invoke-History\r\n\r\nPS C:\\> gcm \"`?\"\r\n\r\nCommandType     Name                                               Version    Source\r\n-----------     ----                                               -------    ------\r\nAlias           % -> ForEach-Object\r\nAlias           ? -> Where-Object\r\nAlias           h -> Get-History\r\nAlias           r -> Invoke-History\r\n\r\nPS C:\\> gcm \"``?\"\r\n\r\nCommandType     Name                                               Version    Source\r\n-----------     ----                                               -------    ------\r\nAlias           ? -> Where-Object\r\n\r\nPS C:\\> gcm '?'\r\n\r\nCommandType     Name                                               Version    Source\r\n-----------     ----                                               -------    ------\r\nAlias           % -> ForEach-Object\r\nAlias           ? -> Where-Object\r\nAlias           h -> Get-History\r\nAlias           r -> Invoke-History\r\n\r\nPS C:\\> gcm '`?'\r\n\r\nCommandType     Name                                               Version    Source\r\n-----------     ----                                               -------    ------\r\nAlias           ? -> Where-Object\r\n\r\nPS C:\\> gcm '``?'\r\n# No output\r\n```\r\n",
      "created_at": "2019-04-06T14:42:52Z",
      "updated_at": "2019-04-06T14:42:52Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for the input. You guys are probably right about it being the single character wildcard, I did not think of this. Unfortunately, as a consumer of `Get-Command` I do not want to write my own logic (especially since the escaping does not work if the `-Name` value is a cmdlet like `Install-Module` instead) depending on what comes in as a user input (which can be anything in PSSA). Maybe a `-LiteralName` would be better (and faster) for such cases. I can understand that PowerShell was designed to be as helpful as possible and tries to not have complicated cmdlet parameters but every once in a while this can create annoying issues of PowerShell trying to be too clever.\r\nFrom an architectural perspective, would it be helpful to have a `LiteralString` type that derives from `System.String` and means to PowerShell cmdlets that the string should be interpreted literally as-is? @SteveL-MSFT ",
      "created_at": "2019-04-06T16:06:36Z",
      "updated_at": "2019-04-06T18:05:37Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "That would be really nice. ",
      "created_at": "2019-04-06T17:18:44Z",
      "updated_at": "2019-04-06T17:18:44Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "Shall we close this issue after maintainers have seen this and possible create a new issue for the proposal of the `LiteralString` type or parameter?",
      "created_at": "2019-04-06T18:50:22Z",
      "updated_at": "2019-04-06T21:33:28Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Let me shed some more light on the current situation:\r\n\r\n* It's clear that we have a problem with treating wildcards consistently, as the sheer number of open issues related to them attests (title search only): https://github.com/PowerShell/PowerShell/issues?utf8=%E2%9C%93&q=is%3Aissue+is%3Aopen+in%3Atitle+wildcard\r\n\r\n* Also, it's not obvious:\r\n  *  what parameters support wildcards: \r\n       * #4715 asks for the syntax diagrams to reflect wildcard support.\r\n       * #4716 asks for reliable programmatic discoverability of parameters with wildcard support\r\n       * #2490 asks for auto-generated help / syntax diagrams to reflect wildcard support (and default values).\r\n  * how to use escaping in their arguments.\r\n\r\nCurrently, all wildcard-supporting parameters are `[string]`-typed.\r\n\r\nThe `[SupportsWildcards()]` attribute is purely informative - no behavior is enforced, no support is provided. Commands can implement wildcard support without indicating that fact via this attribute, which is problematic.\r\n\r\nBecause wildcard-supporting parameters are `[string]`-typed, the only way to opt out of interpretation of a value as a _pattern_ (i.e., to opt into treatment as a _literal_),  is to use escaping _embedded in the string value_, using _embedded_ `` ` `` as the escape character.\r\n\r\nTherefore, for escaping to be effective, the `` ` `` _must reach the target command_, i.e., must be _embedded in the string_.\r\n\r\nThe conceptually clearest expression of that is the use of single-quoting:\r\n\r\n```powershell\r\nGet-Command '`?' # use of '...' ensure that ` is passed through\r\n```\r\n\r\nWhat makes this confusing is that PowerShell's _expandable-string_ `` ` ``-escaping can get in the way:\r\n\r\n(In argument mode) `` `? `` and `` \"`?\" `` are both treated as expandable strings, and `` ` `` is the escape char. in expandable string that has _syntactic function_ and therefore gets _removed_ during parsing, and `Get-Command` see just `?`. In other words: passing `` `? `` or `` \"`?\" `` is no different than passing just `?`\r\n\r\nTo put it yet another way: lone `` ` `` instances in expandable strings are \"eaten\" during _string parsing_, and _do not become part of the string_.\r\n\r\nBy contrast, ``` `` ``` does effectively escape an `` ` `` in an expandable string, which then becomes part of the string, which is why the following work too:\r\n\r\n```powershell\r\nGet-Command ``?   # string parsing eats 1 ` and Get-Command sees literal `?\r\nGet-Command \"``?\"  # ditto\r\n```\r\n\r\nAs for ensuring the literal treatment of arguments provided _via expressions or variables_, you must use `[WildcardPattern]::Escape()`\r\n\r\n```powershell\r\n$name = '?'\r\nGet-Command ([WildcardPattern]::Escape($name)) # OK - the method call yields literal `?\r\n```\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2019-04-06T19:35:12Z",
      "updated_at": "2019-04-06T19:35:12Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "I think that 99% of the time, `Get-Command` is used with wildcards to search and resolve a command.  I'm not against adding a new parameter or switch for programmatic use.\r\n\r\nA side topic, in general, it would be nice if we have some custom types derived off `[string]` so we have more context of the intended use.  For example, `[wildcardedString]` or `[filesystemPath]` so we can have more intelligent tab completion and self documentation.  In the latter case, if we ensure all appropriate parameters have the `[SupportsWildCards()]` attribute, we could do something with PSReadLine to show that the parameter supports wild cards (for example).",
      "created_at": "2019-04-08T01:02:20Z",
      "updated_at": "2019-04-08T01:02:20Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT: indeed, with `Get-Command` the confusion between a literal and a wildcard pattern is an edge case, and the ability to use wildcards without jumping through syntax hoops is generally a benefit.\r\n\r\nWith _file paths_, however, it is a recurring pain point, and it has led to the deplorable `-Path` / `-LiteralPath` schism.\r\n\r\nThe problem hasn't come up often in other contexts - such as with `Get-Command` here - but it's a generic problem.\r\n\r\nImplementing a `-<name>` / `Literal<name>` parameter pair _everywhere_ wildcards are supported is not practical.\r\n\r\n**What is needed is a concise, obvious way to _opt out_ of treating an argument as a wildcard for a _single_ parameter that can accept _either_ a wildcard or a literal**, namely for both:\r\n\r\n* _literal_ use (currently required: _embedded_ `` ` ``-escaping, e.g.,   `` '`?' ``)\r\n* _variable/expression_-based used (currently required: `([WildcardPattern]::Escape($name))`)\r\n\r\n**Let me suggest the following way forward, which would only require changes to the parameter binder; however, it would be a breaking change:**\r\n\r\nIn POSIX-like shells such as Bash, it is **_explicit quoting_ that disambiguates wildcard patterns from string literals** (leaving aside that wildcard handling is fundamentally different there and that unquoted use implies others so-called shell expansions).\r\n\r\nApplied to PowerShell:\r\n\r\n```powershell\r\n# WISHFUL THINKING\r\n\r\n# Literal syntax\r\nGet-Command ?   # wildcard\r\nGet-Command '?'  # literal\r\nGet-Command \"?\"  # literal\r\n\r\n# Variable/expression-based syntax\r\n$name = '?'\r\nGet-Command $name    # wildcard\r\nGet-Command \"$name\"  # literal\r\n\r\n# Pipeline use\r\nWrite-Output ? | Get-Command  # literal - pipeline input is always literal\r\nWrite-Output ? | % { Get-Command $_ } # wildcard - if really needed\r\n```\r\n\r\nThe parameter binder could then act as follows:\r\n\r\n*  On binding _arguments_:\r\n\r\n    * If the target parameter has the `SupportsWildcards` attribute:\r\n      * If the argument is _unquoted_, pass it / its evaluated value through _as-is_.\r\n      * If the argument is _quoted_, apply `[WildcardPattern]::Escape()` to it / its evaluated value and bind that.\r\n\r\n    * Otherwise, no distinction is made between quoted and unquoted use.\r\n\r\n* On binding _from the pipeline_:\r\n  * As implied by the examples above, pipeline inputs would always be treated as _literals_.\r\n\r\nFrom an implementing cmdlet / function's perspective, all that is needed is to consistently decorate wildcard-supporting parameters with the `SupportsWildcards` attribute, and the parameter binder would do the rest: literal inputs would arrive automatically escaped.\r\n\r\nA potential new hybrid parameter type such as `[wildcardedstring]` could also tie into this: instead of _escaping_ a literal value, the parameter binder could simply construct the `[wildcardedstring]` in a way that indicates that the string is a _literal_, which would make performant implementations simpler: the implementer will easily know whether the argument is a literal, and can skip matching operations (you can currently do the same thing manually with `[WildcardPattern]::ContainsWildcardCharacters()`)\r\n\r\nAdditionally, parsing of compound tokens as arguments would have to change to allow direct concatenation of quoted and unquoted tokens:\r\n\r\n```powershell\r\n# WISHFUL THINKING\r\n\r\n# Quote only the literal parts of a path - those parts that need it.\r\n# The wildcard char. must be unquoted in order to be recognized as such.\r\nGet-ChildItem \"/foo/name with spaces\"/*\r\n```\r\n\r\nCurrently, such a compound token results in _two_ arguments - which, honestly, never made much sense - see #6467):\r\n\r\n```powershell\r\n# CURRENT BEHAVIOR\r\n\r\n# Quoted string first:\r\n# !! 2 arguments\r\nPS> Write-Output \"foo bar\"baz\r\nfoo bar\r\nbaz\r\n\r\n# Unquoted string first:\r\n# !! 1 argument\r\nPS> Write-Output baz\"foo bar\"\r\nbazfoo bar\r\n```\r\n\r\n----\r\n\r\nAs for **what would break**:\r\n\r\n* The big issue: wildcard-based paths with explicit quoting would no longer work; e.g., `Get-ChildItem \"*.txt\"`\r\n* Unlikely to be a problem: Code that relied on compound strings such as `\"foo\"bar` getting broken into multiple arguments.\r\n\r\n---\r\n\r\nAs for **what we would gain**:\r\n\r\n* The continued convenience of being able to use wildcards without special syntax - e.g., `Get-Command *-Csv`, `Get-ChildItem *.txt`\r\n\r\n* A simple, consistent opt-out-of-wildcard-matching mechanism - if needed - to ensure literal use.\r\n",
      "created_at": "2019-04-08T11:59:29Z",
      "updated_at": "2019-04-08T11:59:29Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I agree that some syntactical difference between wildcarded and literal strings is a good idea. I _don't_ think that just forbidding all wildcard patterns in enclosed strings is the answer, however... Rather, I think that this is an opportunity to make a meaningful distinction between the two string parsing modes.\r\n\r\nSingle-quoted strings are _already widely understood_ to be **literal strings**, in that they don't expand variables and subexpressions, etc. \r\n\r\nWhy not simply expand that already-understood behaviour and make single-quoted strings the de facto standard for non-wildcard parameter input?\r\n\r\nIn other words, in your brief example:\r\n\r\n```\r\nPS> Get-Command ? # wildcard\r\nPS> Get-Command \"?\" # wildcard\r\nPS> Get-Command '?' # literal\r\n```\r\n\r\nAlternately, we could make use of a different enclosing character(s) entirely? Some possible suggestions:\r\n\r\n* `//?//`\r\n* `<?>`\r\n* `\\\\?\\\\`\r\n\r\nAlso, your suggestion @mklement0 would result in being _fundamentally unable_ to pass wildcard patterns via variable, which I think is very silly. \ud83d\ude04 ",
      "created_at": "2019-04-08T12:29:08Z",
      "updated_at": "2019-04-08T12:45:19Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@vexx32 \r\n\r\n> Also, your suggestion @mklement0 would result in being fundamentally unable to pass wildcard patterns via variable\r\n\r\nTo quote from my proposal above:\r\n\r\n```powershell\r\n# Variable/expression-based syntax\r\n$name = '?'\r\nGet-Command $name    # wildcard\r\n```\r\n\r\nThat is, the suggestion was to interpret the values of variables or expressions _that aren't enclosed in `\"...\"` as _wildcards_ and, conversely, only treat them as literals when `\"...\"`-enclosed.\r\n\r\nConversely, your single-quotes-as-literals-only proposal prevents use of variables / expressions as _literals_,  which I think is very silly. \ud83d\ude04 \r\n\r\n---\r\n\r\nRe new sigils / enclosing delimiters such as `//...//`:\r\n\r\nI intentionally tried to _avoid_ introducing those, because PowerShell already has a problem with additional sigils such as `@` and `{` at the start of unquoted arguments having special meaning compared to other shells.\r\n\r\nAny additional exceptions to literal parsing are problematic (not just from a backward-compatibility perspective), as you'll always have to be on guard as to whether your unquoted argument will be taken as a literal or as an expression.\r\n\r\nAlso note that we want to retain _wildcard_ interpretation as the default, which means that the new syntax would have to express opt-in to _string-literal_ interpretation.\r\n\r\nBuilding on your suggestion to leverage the well-established semantics of `'...'` to mean _literal_, perhaps the following could work:\r\n\r\n```powershell\r\n$name = \"?\"\r\nGet-Command ''$name\r\n```\r\n\r\nThat is, `''` preceding a variable name or expression would signal the intent to use its value _literally_.\r\n\r\n(Currently, this results in _two_ arguments: the empty string, followed by the value of `$name` - again, it's unlikely that existing code relies on this behavior.)\r\n\r\nThis would then allow use to also treat `\"...\"`-enclosed tokens as wildcards, as you suggest.\r\n\r\n",
      "created_at": "2019-04-08T13:44:41Z",
      "updated_at": "2019-04-08T13:50:32Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": ">Conversely, your single-quotes-as-literals-only proposal prevents use of variables / expressions as literals, which I think is very silly. \ud83d\ude04\r\n\r\nYou can have the parser assign a _different type_ (`[literalstring]` perhaps?) to the string, or an attribute to the variable that stores it, which flags it explicitly as a literal string. \ud83d\ude04 ",
      "created_at": "2019-04-08T13:52:12Z",
      "updated_at": "2019-04-08T13:52:28Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@vexx32: Assign a different type _based on what_? What signals the distinction between wanting to use `$var`'s value in `Get-Command $var` / `Get-Command \"$var\"` as a wildcard vs. a literal? \r\n",
      "created_at": "2019-04-08T13:58:32Z",
      "updated_at": "2019-04-08T13:59:08Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "```\r\n$literal = 'literal'\r\n$nonliteral = \"nonliteral\"\r\n```\r\n\r\nIf, instead, you did as you mention:\r\n\r\n```\r\nGet-Command $literal # literal\r\nGet-Command \"$literal\" # converted to non-literal\r\nGet-Command $nonliteral # nonliteral\r\nGet-Command \"$nonliteral\" # nonliteral\r\n```",
      "created_at": "2019-04-08T14:01:17Z",
      "updated_at": "2019-04-08T14:01:17Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "How about making `hashtable` and `string` implicitly convertible to `WildcardPattern`?\r\n\r\nThen you could set it up so the parameter binder (indirectly I suppose, through type conversions) can handle these:\r\n\r\n```powershell\r\nGet-Command ImplicitlySupportsWildcard*\r\nGet-Command @{ Value = 'Does not support wildcards'; IsLiteral = $true }\r\n\r\n# Or with extras in the parser. Picture some better form of syntax here instead.\r\nGet-Command \"No wildcards\"/@\r\n```\r\n\r\nSo then cmdlets could type the parameter as `WildcardPattern` and handle both literals and wildcards with `pattern.IsMatch(string)`. `WildcardPattern` already creates a delegate to use for matching, so you could have it create one like `(input) => pattern.Equals(input, StringComparison.InvariantCultureIgnoreCase)` for literals.\r\n\r\nMaybe also add properties `Pattern` and `IsLiteral` to `WildcardPattern` so the cmdlet author can use them directly if needed.\r\n\r\n**Edit:** Fixed culture in example delegate, ty @mklement0 ",
      "created_at": "2019-04-08T14:14:39Z",
      "updated_at": "2019-04-08T16:41:03Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@vexx32: \r\n\r\nWhat you're proposing is highly obscure and I strongly recommend against it.\r\n\r\nOnce a string has been created, its content is by definition a _literal_, and we don't want to create implicit string subtypes that carry information that is entirely unrelated to strings per se.\r\n\r\nInstead, we're looking for a syntax form that _in the context of wildcard matching only_ conveys the distinction between something meant to be a pattern and something to be used as-is - because wildcard patterns currently happen to be implemented as strings.\r\n\r\nIn other words: we're trying to convey information that is unrelated to strings per se, and only matters if strings happen to be used as - potential - wildcard patterns.\r\n\r\nPiggybacking on _string_-quoting semantics is only an option in the context of _argument parsing_, where use of _unquoted_ strings is permitted and can thus serve as a distinction, but it's important to understand that string-literal parsing and interpretation of a string's _content_ as a wildcard expression are unrelated things.\r\n\r\nMy own proposal is guilty of blurring these lines too, but only in said constrained scenario - nowhere else, notably not in expression mode.\r\n\r\nIn short, what we want to express is: \"Whatever this _string_ expands to (or not), treat its _resulting content_ either as _pattern_ or use it _as-is_.\"\r\n\r\n---\r\n\r\n@SeeminglyScience: \r\n\r\nGreat idea to adapt the existing `[WildcardPattern]` type and to give it an `IsLiteral` property (for consistency with `-eq`, the string-comparison mode should be `InvariantCultureIgnoreCase`, though)   - doing so obviates the need for a potential `[wildcardedstring]` type.\r\n\r\nAs for the literal argument syntax:\r\n\r\n* `@{ Value = 'Does not support wildcards'; IsLiteral = $true }` works unambiguously and introduces no new syntax, but it is obviously very verbose.\r\n\r\n* `\"No wildcards\"/@` strikes me as obscure and would be the first case of a _postpositional_ sigil.\r\n\r\nHowever, conceivably we could take a page out of C#'s book:\r\n\r\n```powershell\r\n# All literal uses\r\nGet-Command @'?'\r\nGet-Command @\"?\"\r\n$name = '?'; Get-Command @$name\r\n$name = '?'; Get-Command @$($name)\r\n\r\n# Note that the following would NOT work:\r\nGet-Command @?  #  reserved for splatting.\r\nGet-Command @($name) #  array subexpression operator\r\n```\r\n\r\nThe problem is that `@` already has multiple unrelated or only loosely related meanings (splatting, here-strings, array-subexpression operator).\r\n\r\nWhile a separate sigil - `@`  - potentially makes it clearer that a dimension that is independent of string quoting is being expressed, the fact that the same sigil is used for here-strings again muddies the waters.\r\n\r\nAnother problem is that `@` cannot be followed by an _unquoted_ token (because it would then be the _splatting_ syntax), and the ability to use unquoted tokens is an important convenience in a shell.\r\n\r\nAs for backward compatibility:\r\n\r\n* `@'` and `@\"` are currently interpreted as the start here-strings, whose content must start on the _next_ line, so there'd be no problem there.\r\n\r\n* `@$name` is currently the same as `\"@$name\"`, however, so it's conceivable that existing code relies on that.\r\n\r\n_[Doesn't work, because something like `'''name'` is syntactically a regular single-quoted string with an escaped `'`]_ ~~At the end of the day I like @vexx32's suggestion in the abstract: to piggyback on `'...'` semantics, but perhaps _only_ with a special argument-parsing-mode only `''` _prefix_ to  a string, irrespective of the latter's own quoting style~~:\r\n\r\n```powershell\r\n# Pattern - irrespective of string-quoting style\r\nGet-Command name\r\nGet-Command 'name'\r\nGet-Command \"name\"\r\nGet-Command $name\r\nGet-Command $('name' + '?')\r\n\r\n# [DOES NOT WORK]\r\n# Literal - only with '' prefix\r\nGet-Command ''name \r\nGet-Command '''name'\r\nGet-Command ''\"name\"\r\nGet-Command ''$name\r\nGet-Command ''$($name + '?')\r\n```\r\n\r\n",
      "created_at": "2019-04-08T15:44:12Z",
      "updated_at": "2019-04-09T13:41:32Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 \r\n\r\n> \"No wildcards\"/@ strikes me as obscure and would be the first case of a postpositional sigil.\r\n\r\nOh, to be honest I misread part of one of your comments.  I hastily included that as an example because I thought you proposed it.  I don't actually have any thoughts on what the syntax should be or even whether or not there should be one at all.  That's what I get for skimming \ud83d\ude42 ",
      "created_at": "2019-04-08T15:51:17Z",
      "updated_at": "2019-04-08T15:51:17Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@SeeminglyScience:\r\n\r\n> even whether or not there should be one at all.\r\n\r\nIndeed we don't _need_ a syntax for that; even with the current behavior, you can always disambiguate with:\r\n\r\n```powershell\r\nGet-Command '`?'  # string-literal: embedded escaping of metachars.\r\n$name = '?'; Get-Command ([WildcardPattern]::Escape($name)) # escape programmatically\r\n```\r\n\r\nBased on what prompted creation of this issue and that the subsequent discussion it's clear that these options are obscure in the former case, and additionally cumbersome in the latter.\r\n\r\nIn the case of `-Path` / `-LiteralPath`, you can sidestep the issue by choosing `-LiteralPath` for literal input paths, forgoing the convenience of _positional_ argument binding.\r\n\r\nIn the majority of cases you don't have that option.\r\n\r\nPerhaps the need to force literal interpretation rarely arises (I've tripped over `Get-Command ?` myself, for instance), but when it does, it's currently far from obvious how to handle it, because:\r\n\r\n* [about_Wildcards](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_wildcards) doesn't talk discuss escaping at all.\r\n\r\n* Similarly, the [`[WildcardPattern]`](https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.wildcardpattern) class isn't part of the end-user documentation.\r\n\r\n* As stated, discovering which parameters support wildcards is quite cumbersome at the moment (see #4715, #4716, and #2490).\r\n\r\n_At the least_, these issues should be addressed - even if nothing else changes.\r\n\r\nAdditionally, I think that a concise syntax that works with both literals and variables/expressions for on-demand treat-as-literal semantics is a worthwhile addition for convenience.\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2019-04-08T16:17:03Z",
      "updated_at": "2019-04-08T16:20:34Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "A quick meta note, @vexx32:\r\n\r\n> which I think is very silly. \ud83d\ude04\r\n\r\nRegrettably, I echoed that phrase of yours in my response, but what I should have said is this:\r\n\r\nSticking a \ud83d\ude04 at the end of an insult doesn't nullify it.\r\n(Again, it would be the first instance of a _postpositional_ sigil.)\r\n\r\nPerhaps you meant to be playful, but we don't have a personal relationship, and intent is hard to read in its absence and with written communication in general.\r\n\r\nI value your helpful contributions to this community and the constructive discussions you and I generally have; please don't sour that with flippant responses such as the above.  \r\n\r\nTo be clear: if there is a problem with a proposal or argument, I absolutely want to hear about it - just not packaged that way (leaving aside the fact that this particular objection was unfounded).\r\n\r\n\r\n",
      "created_at": "2019-04-08T16:28:12Z",
      "updated_at": "2020-03-26T11:35:39Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Understood. I'll make an effort to be more clear and steer away from the flippant. \ud83d\ude42 ",
      "created_at": "2019-04-08T17:04:27Z",
      "updated_at": "2019-04-08T17:05:08Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "```\r\n# Or with extras in the parser. Picture some better form of syntax here instead.\r\nGet-Command \"No wildcards\"/@\r\n```\r\n\r\nInteresting idea.  I have really disliked the whole `Path` vs `LiteralPath` schism from day one.  And what, looks like we'd need a `-LiteralCommand` to solve this the \"PowerShell\" way.\r\n\r\nI'd love to see the need for a `LiteralPath` parameter go away in PS 7.  But you'd need a way to indicate to a command that wildcard chars should not be interpreted as wildcards for a parameter.  Perhaps the above suggestion (or one like it) is the way to go but it would need to be able to handle expressions in general:\r\n\r\n```\r\nGet-Command $name/@\r\nGet-ChildItem (Join-Path $PSScriptRoot \"foo[bar]\")/@  # < Hmm that syntax is problematic I think\r\n```\r\n\r\nI'd venture a guess that there are a ton of latent bugs in PowerShell scripts out in the wild because folks write script like this `Test-Path $path` not ever thinking that the user might supply a path with `[]` in it.\r\n\r\nSo I'm not sure how you solve this exactly but yeah, it would be so nice to be able to write a command for PS7 that doesn't require a LiteralPath parameter.  That would also reduce parameterset complexity by eliminating one parameterset completely.   \r\n\r\n\r\n ",
      "created_at": "2019-04-08T17:24:19Z",
      "updated_at": "2019-04-08T17:24:19Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Agreed on all points, @rkeithhill, except the details of the new syntax (see bottom).\r\n\r\n> folks write script like this `Test-Path $path` not ever thinking that the user might supply a path with [] in it.\r\n\r\nYes, it's unfortunate that `-Path` is the default, but, conversely, if `-LiteralPath` were, the convenience of `Test-path *.txt` would go away, because, at least with positional use you would then have to explicitly signal the desire to treat the argument as a pattern.\r\n\r\nAt least we now have alias `-lp` to make use of `-LiteralPath` less verbose.\r\n\r\nBut I agree that ditching the `-Path` / `-LiteralPath` schism and promoting a dedicated treat-this-potential-pattern-as-a-literal syntax is the way forward, not least because it can then be applied to _any_ (existing) wildcard-supporting parameter - such as `Get-Command`'s `-Name` in the case at hand, without burdening implementers and end users with separate parameter sets.\r\n\r\n---\r\n\r\nOn to bikeshedding:\r\n\r\nAs stated, I think that introducing a postpositional sigil is problematic - it differs from all other sigils, and you have to visually scan to the _end_ of the token to discern intent.\r\n\r\n_[Doesn't work, because something like `'''name'` is syntactically a regular single-quoted string with an escaped `'`]_ ~~Using `''` as a prefix is not the prettiest but~~:\r\n* ~~it's unlikely to break existing usage~~\r\n* ~~conveys the notion of literalness better~~\r\n* ~~works equally with string literals (wether with literal or expandable content) and variables / expressions:~~\r\n\r\n```powershell\r\nGet-Command ''name\r\nGet-Command ''$name\r\nGet-ChildItem ''$(Join-Path $PSScriptRoot \"foo[bar]\") # perhaps just ''(...) too.\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2019-04-08T17:41:40Z",
      "updated_at": "2019-04-09T13:38:05Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "P.S.: \r\n\r\nI suggest combining the new syntax with @SeeminglyScience's proposed enhancement to the `[WildcardPattern]` class.\r\n\r\nFuture cmdlets can then ditch the current combo of `[string]`-typed parameters with informational-only `[SupportsWildcards()]` attribute for a `[WildcardPattern]`-typed parameter that is both self-documenting and provides useful functionality.\r\n\r\nThe parameter binder would then have to do extra work in both cases when encountering the new syntax:\r\n\r\n* When binding to `[string]`-typed parameters with `[SupportsWildcards()]`, bind the result of `[WildcardPattern]::Escape()`\r\n\r\n* When binding to `[WildcardPattern]` parameters, construct an instance appropriately.\r\n",
      "created_at": "2019-04-08T18:00:53Z",
      "updated_at": "2019-04-08T18:00:53Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "A small implementation recommendation:\r\n\r\nIt's likely that existing cmdlets would be reworked to accept `WildcardPattern` instead, if this is the case then compatibility with existing scripts could still be kept by implementing `LiteralPath` parameters like this\r\n\r\n```csharp\r\npublic string LiteralPath\r\n{\r\n    get => Path != null && Path.IsLiteral ? Path.Pattern : null; // or string.Empty\r\n    set => Path = new WildcardPattern(value, isLiteral: true);\r\n}\r\n```",
      "created_at": "2019-04-08T18:18:34Z",
      "updated_at": "2019-04-08T18:18:34Z"
    },
    {
      "author": "mkht",
      "author_association": "NONE",
      "body": "I generally support @mklement0 proposal, but against that using `''` as prefix.\r\nBecause `''` is widely recognized by users as expression of literal strings, the following expressions look very *weird* to me and may cause confusion.\r\n\r\n```PowerShell\r\n# Literal - only with '' prefix\r\nGet-Command ''name \r\nGet-Command '''name'\r\nGet-Command ''\"name\"\r\n```\r\n\r\nIf anything, it might be better to use the `@` as a prefix.\r\nThe `@` is also used in C# as a prefix for escape, and I think that we will be familiar with it.\r\n```PowerShell\r\n# Literal - only with @ prefix\r\nGet-Command @'?'\r\nGet-Command @\"?\"\r\n```\r\n\r\nHowever, it may be a problem in the following situations. It will need to be discussed.\r\n```PowerShell\r\n$names = '?', 'gci', '*Firewall*'\r\nGet-Command $names  # All elements as non-literal\r\n\r\n# How to express $names as literal?\r\nGet-Command @($names)           # array subexpression\r\nGet-Command @$names             # best way?\r\n$names | % { Get-Command @$_}   # not bad but a bit verbose\r\n$names | % { Get-Command ([WildcardPattern]::Escape($_))}   # current solution\r\n```\r\n",
      "created_at": "2019-04-09T02:02:16Z",
      "updated_at": "2019-04-09T02:02:16Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I agree that `''` is ugly, @mkht, but more importantly, I've just realized that it won't work: something like `'''name'` is a valid regular single-quoted string with literal content `'name`.\r\n\r\nThe problem I see with `@` is its that it already has several distinct uses and, in the context of _strings_, it is used for _here-strings_, which in PowerShell do not imply literalness the way they do in C# (though perhaps the association with C# would be strong enough to suggest it in single-line use).\r\nAlso, an important convenience on the command line is the ability to use _unquoted_ tokens, which is _not_ an option with `@`, because `@name` is the syntax for _splatting_.\r\nAnd it also means continued conflation of string literalness with pattern literalness.\r\n\r\nThe problem is that I don't think it's an option to introduce another sigil in argument-parsing mode, so we're stuck with the set of characters that are special at the start of a token: `$ @ { ' \" (`\r\n\r\nAt the end of the day, whatever form we agree on that technically works and is concise enough should be fine, but I've since realized that there are more _conceptual_ issues, discussed below.\r\n\r\nIn light of them, I'm again leaning toward using the quoted / unquoted distinction as used in POSIX-like shells, but it's clearly not an ideal solution.\r\n\r\n### Splatting with wildcard parameters:\r\n\r\nMy hope was that we'd get away with a special syntax in _argument mode only_ (which, on second thought, is probably not a good idea in and of itself - though argument mode does have unique features), but due to _splatting_ we have to deal with _expression mode_ too.\r\n\r\nThe fundamental problem is the coupling of wildcard patterns with strings we cannot escape (anymore):\r\n\r\n* Strings moonlight as pattern literals in PowerShell (for _regex_ patterns too, but it's less problematic there), which is conceptually backwards: In JavaScript, for instance, you use explicit syntax `/.../` for pattern literals (regexes, in this case), and using strings instead signals the intent to use a string's content literally; e.g., `'f.1'.replace('.', '@') // literal` vs. `'f1'.replace(/./, '@') // pattern (regex)`\r\n\r\n* As stated, however, we don't want to give up the convenience of using _unquoted_ pattern literals on the command line, as in `Get-ChildItem *.txt`.\r\n  * POSIX-like shells (such as Bash) use _unquoted_ use of arguments - even as _part_ of compound strings that also have _quoted_ parts - to disambiguate patterns from a strings; in other words: the special syntax for creating a pattern is _not to quote_.  \r\n     * However, it is _the shell itself_ that expands patterns (globs, which are limited to filesystem paths), and the target command only ever sees the _results_ - which is not how PowerShell does it.\r\n     * My original proposal suggested using the unquoted / quoted distinction as well, which would work in _argument mode_, but not in expression mode with splatting: since quoting strings is a syntactic necessity in expression mode, the desire to create a pattern would have to be indicated explicitly _by way of a cast_ (in the absence of special syntax):\r\n\r\n```powershell\r\n# Literal use\r\n$htArgs = @{\r\n  Path = 'ab[]'    # literal - consistent with proposed argument mode behavior\r\n}\r\n\r\n# Pattern use\r\n$htArgs = @{\r\n  Path = [WildcardPattern] 'ab[]'  # pattern - clumsy, and still involves a string\r\n}\r\n```\r\n\r\nAlso, while unquoted arguments in POSIX-like shells _consistently_ have special meaning, in PowerShell they'd only be special if they happen to bind to wildcard parameters.\r\n\r\nFurther, the need to enclose _variable references_ and _expressions_ in `\"...\"` in order to opt out of pattern matching _situationally_ would be obscure:\r\n\r\n```powershell\r\nGet-ChildItem \"$name\"  # force literal use with quoting\r\nGet-ChildItem \"$($PSScriptRoot + '/name')\"  # ditto\r\n```\r\n\r\nWhen binding to non-wildcard string parameters, just `$name` and `($PSScriptRoot + '/name')` are enough.\r\n\r\n### Pipeline binding with wildcard parameters:\r\n\r\nEarlier I proposed treating inputs from the pipeline as literals, but that's not how things currently work:\r\n\r\n```powershell\r\n'ab[]' > paths.txt\r\nGet-Content paths.txt | Get-ChildItem # FAILS, because the paths are treated as wildcards.\r\n``` \r\n\r\n<sup>If you're wondering about the awkward sample filename: it was specifically chosen so that it results in an error when interpreted as a pattern, which not all invalid-as-a-pattern strings currently do - see #6733.</sup>\r\n\r\nWith pipeline input we have no way of indicating the intent - pattern vs. literal - and while defaulting to pattern interpretation is consistent, it's also the less common use case: my sense is that _typically_ you'll want to feed _literal_ paths from a file. That is, to robustly process paths stored in a file - even now - you have to use `Get-Content paths.txt | ForEach-Object { Get-ChildItem -lp $_ }` rather than just `Get-Content paths.txt | Get-ChildItem`. I'm unsure what the right solution is here.\r\n\r\nAlso, when piping `Get-ChildItem` / `Get-Item` output, we definitely want to ensure _literal_ use, which could be done by making `PSPath` an alias name for parameter `Path` (as is currently the case with `LiteralPath`) and in the simplest form by providing an `ArgumentTransformationAttribute` that turns the path into a literal pattern, similar to what is shown in https://github.com/PowerShell/PowerShell/issues/6057#issuecomment-400107991.\r\n\r\nA couple of asides re wildcard handling with file paths - but _only_ file paths:\r\n* @rkeithhill has suggested a higher-level `PathParameter` attribute that would let PowerShell handle the wildcard expansion - though the proposal is still framed in the context of the `-Path` / `-LiteralPath` bifurcation: https://github.com/PowerShell/PowerShell/issues/8819#issuecomment-460102241\r\n   * @Jaykul has experimented with a similar approach in https://github.com/Jaykul/Path\r\n* also, cmdlets that accept filesystem paths should arguably accept them _directly as `System.IO.FileSystemInfo` objects_, as output by `Get-ChildItem` / `Get-Item` or similar commands, to avoid the need for reparsing path strings - see https://github.com/PowerShell/PowerShell/issues/6057#issuecomment-399286074\r\n\r\n\r\n",
      "created_at": "2019-04-09T13:36:29Z",
      "updated_at": "2019-04-09T13:36:29Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "To help with the discussion, let me clear up some potential terminology confusion:\r\n\r\n_Literal_ can mean two things:\r\n\r\n* Literal _notation_: `\"Honey, I'm $HOME.\"` and `'This is not a pipe.'` are both _string literals_.\r\n\r\n* Literal _content_: Only the content of `'This is not a pipe.'` - a single-quoted string literal - is taken literally, or, to take a page out of C#'s terminology book, is used _verbatim_.\r\n\r\nTherefore, what we're looking for here is a new, concise, bareword-friendly (not requiring quoting) notation for _verbatim patterns_ - i.e., something that when passed to a wildcard-supporting parameter is interpreted not as a pattern, but verbatim.\r\n\r\n\r\n\r\n",
      "created_at": "2019-04-15T05:17:21Z",
      "updated_at": "2019-04-15T05:18:20Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "I think you would need to enhance WildcardPattern dramatically such that:\r\n\r\n1. WildcardPattern would need to store the \"OriginalString\" somewhere (like URLs do) so it can implement `ToString()` usefully so that functions or cmdlets using [WildCardPattern] as a parameter can still use it as a string internally when necessary.\r\n2. This means WildcardPattern would need to store whether it was literal so you could tell the difference between escaped and literal text -- which probably means the WildcardOptions enum needs a `IsLiteral` value so you can construct a real WildcardPattern\r\n3. WildcardPattern would need to support casting hashtables (looks for `Value` and `Literal` or `IsLiteral`)\r\n4. WildcardPattern would need to cast non-string objects with respect for a `Literal` or `IsLiteral` property...",
      "created_at": "2019-04-17T04:55:31Z",
      "updated_at": "2019-04-17T04:56:07Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Good suggestions, @Jaykul; such enhancements could help prevent bugs such as #9475.\r\n\r\nReturning to the idea of a syntax for verbatim (escaped) patterns (which the parameter binder could translate into (enhanced) `[WildcardPattern]` instances for parameters declared with that type):\r\n\r\nAs an aside: The unquoted (glob) / quoted (verbatim) distinction already _is_ implemented, namely when _calling external programs_ on Unix, to emulate POSIX-like shell behavior; e.g., `/bin/echo *.txt` results in expansion to all matching filenames, whereas `/bin/echo '*.txt'` prints `*.txt` verbatim.\r\n\r\nGiven that `@` already serves many different purposes, we can stick with it as follows and embrace the logic of conceiving of verbatim strings as _escaped patterns_:\r\n\r\n* ``@`... `` to create escaped wildcard expressions \r\n* ``@\\... `` to create escaped regexes (obviates the need for `[regex]::Escape()` calls.\r\n\r\nNote the prettiest, but concise, and I think the syntax hints at the  intent.\r\n\r\nExamples:\r\n\r\n```powershell\r\n# Wishful thinking\r\n\r\n# With a bareword (wouldn't be supported in expression mode)\r\nGet-Command @`?\r\nGet-Item @`file[1].txt\r\n\r\n# With a variable\r\n$file = 'file[1].txt'; Get-Item @`$file\r\n\r\n# With a (sub)-expression\r\n$ndx = 1; Get-Item @`('file[{0}].txt' -f $ndx)\r\n\r\n# With -replace, in expression mode\r\n'a * is born' -replace @\\'*', 'star'\r\n$replace = '*'; 'a * is born' -replace @\\$replace, 'star'\r\n```\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2019-05-09T18:53:27Z",
      "updated_at": "2020-07-12T18:54:27Z"
    },
    {
      "author": "TravisEz13",
      "author_association": "MEMBER",
      "body": "This should be easy enough to implement with the code I added for the execution path.  Where we prefer literal matches before wildcard matches.",
      "created_at": "2019-05-29T22:18:16Z",
      "updated_at": "2019-05-29T22:18:16Z"
    }
  ],
  "created_at": "2019-04-06T11:20:01Z",
  "labels": [
    "Issue-Question",
    "Up-for-Grabs",
    "WG-Cmdlets-Core"
  ],
  "number": 9308,
  "state": "open",
  "title": " 'Get-Command ?' returns % (ForEach-Object alias) and other unrelated CommandInfo objects",
  "updated_at": "2021-01-15T09:49:45Z"
}