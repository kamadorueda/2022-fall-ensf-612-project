{
  "_url": "https://github.com/PowerShell/PowerShell/issues/16473",
  "author": "Odland",
  "body": "### Prerequisites\r\n\r\n- [X] Write a descriptive title.\r\n- [x] Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\r\n- [X] Search the existing issues.\r\n- [X] Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\r\n- [X] Refer to [Differences between Windows PowerShell 5.1 and PowerShell](https://docs.microsoft.com/powershell/scripting/whats-new/differences-from-windows-powershell).\r\n\r\n### Steps to reproduce\r\n\r\n- I can only be used for a variety of reasons 7.2.0 - preview. 5 version, but I think it is nothing too big relations with version\r\n- I wrote powershell functions that pipe the return value of the first command as an input parameter to the second command\r\n- But the arguments to the second command all receive the return value of the first command\r\n- The first command\r\n```\r\nPS>$data = Get-Datastore\r\nPS>$data\r\n\r\nCapacityGb FreeSpaceGb Id                                             IsAccessible        MaxReadRate              MaxWriteRate \r\n---------- ----------- --                                                         ------------    -----------    ------------     ----            \r\n1443       1374        986137d8_vs_vol_rep3                           True         0           0            0                        0\r\n\r\nPS>$data[0] | Get-Member\r\n     \r\n   TypeName: Test.Models.StorageResource\r\n\r\nName         MemberType Definition\r\n----         ---------- ----------\r\nEquals       Method     bool Equals(System.Object obj)\r\nGetHashCode  Method     int GetHashCode()\r\nGetType      Method     type GetType()\r\nToJsonString Method     string ToJsonString()\r\nToString     Method     string ToString()\r\nCapacityGb   Property   System.Nullable[long] CapacityGb {get;set;}\r\nFreeSpaceGb  Property   System.Nullable[long] FreeSpaceGb {get;set;}\r\nId           Property   string Id {get;set;}\r\nIsAccessible Property   System.Nullable[bool] IsAccessible {get;set;}\r\nMaxReadRate  Property   System.Nullable[long] MaxReadRate {get;set;}\r\nMaxWriteRate Property   System.Nullable[long] MaxWriteRate {get;set;}\r\nName         Property   string Name {get;set;}\r\nType         Property   string Type {get;set;}\r\n\r\n```\r\n- The second command\r\n```\r\nPS>get-help new-vm -full\r\n....\r\nPARAMETERS\r\n    -Name <String>\r\n        Required?                    true\r\n        Position?                    named\r\n        Default value\r\n        Accept pipeline input?       false\r\n        Accept wildcard characters?  false\r\n-Datastore <StorageResource>\r\n\r\n        To construct, see NOTES section for DATASTORE properties and create a hash table.\r\n\r\n        Required?                    false\r\n        Position?                    named\r\n        Default value\r\n        Accept pipeline input?       true (ByValue)\r\n        Accept wildcard characters?  false\r\n-VMHost <IVMHost>\r\n        To construct, see NOTES section for VMHOST properties and create a hash table.\r\n\r\n        Required?                    false\r\n        Position?                    named\r\n        Default value\r\n        Accept pipeline input?       true (ByValue)\r\n        Accept wildcard characters?  false\r\n...\r\n```\r\n- I set byValue in the second command\r\n```\r\n[Parameter(ValueFromPipeline)]\r\n    [ValidateNotNull()]\r\n    [Test.Category('Query')]\r\n    [Test.Models.StorageResource]\r\n    # To construct, see NOTES section for DATASTORE properties and create a hash table.\r\n    ${Datastore},\r\n```\r\n- When I pass the datastore object to the second command, the second VMhost parameter is also assigned\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Expected behavior\r\n\r\n```console\r\nPS>$data[0] | new-vm -name test123456 -debug \r\n{\r\n  \"query\": \"mutation CREATEVM { \r\n         createVM(\r\n             input:{\r\n                  name: \"test123456\", \r\n                  datastoreID: \"986137d8_vs_vol_rep3\" \r\n             }) \r\n         { taskID targetID message }\r\n }\"\r\n}\r\n```\r\n```\r\n\r\n\r\n### Actual behavior\r\n\r\n```\r\nconsole\r\n- I just want the Datastore parameter of the second command to get the value,But other parameters of the second command are also assigned values\r\n\r\n```\r\nPS>$data[0] | new-vm -name test123456 -debug \r\n{\r\n  \"query\": \"mutation CREATEVM {\r\n         deriveVirtualMachine(\r\n         input:{  \r\n               name: \"test123456\",\r\n               hostID: \"986137d8_vs_vol_rep3\",  \r\n               storageID: \"986137d8_vs_vol_rep3\"\r\n         })\r\n         { taskID targetID message } \r\n   }\"\r\n}\r\n```\r\n\r\n\r\n\r\n### Error details\r\n\r\n_No response_\r\n\r\n### Environment data\r\n\r\n```\r\npowershell\r\nPS>$PSVersionTable\r\n\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.2.0-preview.5\r\nPSEdition                      Core\r\nGitCommitId                    7.2.0-preview.5\r\nOS                             Microsoft Windows 6.1.7601 Service Pack 1\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n```\r\n\r\n\r\n### Visuals\r\n\r\n_No response_",
  "closed_at": "2021-11-19T00:00:42Z",
  "comments": [
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "your help output shows \r\n\r\n```\r\n-Datastore <StorageResource>\r\n        Accept pipeline input?       true (ByValue)\r\n-VMHost <IVMHost>\r\n        Accept pipeline input?       true (ByValue)\r\n```\r\n\r\nSo PowerShell will try to assign the object in the pipeline to both of them. \r\nParameter typing is \"Attempt to cast to\" not \"Must already be\", so it looks like the piped object  can be converted to an IVMHost.     \r\n\r\nWhat does [Test.Models.IVMHost]$Data[0] give ?  \r\n\r\n\r\n\r\n \r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2021-11-15T13:00:32Z",
      "updated_at": "2021-11-15T13:00:32Z"
    },
    {
      "author": "Odland",
      "author_association": "NONE",
      "body": "> your help output shows\r\n> \r\n> ```\r\n> -Datastore <StorageResource>\r\n>         Accept pipeline input?       true (ByValue)\r\n> -VMHost <IVMHost>\r\n>         Accept pipeline input?       true (ByValue)\r\n> ```\r\n> \r\n> So PowerShell will try to assign the object in the pipeline to both of them. Parameter typing is \"Attempt to cast to\" not \"Must already be\", so it looks like the piped object can be converted to an IVMHost.\r\n> \r\n> What does [Test.Models.IVMHost]$Data[0] give ?\r\n\r\n- The [Test.Models.IVMHost]$Data[0] command cannot be executed\r\n- Datastore and VMHost are c# objects. I used the [autorest](https://github.com/Azure/autorest.powershell/blob/main/docs/readme.md) framework to generate c# code to make powershell commands.\r\n- Datastore object properties include Id, Name, CapacityGb, and FreeSpaceGb\r\n- VMHost object contains attributes Id, Name, ManagementIP, and Description\r\n- My hope is in the execution $data | new - vm command, after new - vm only receive corresponding Datastore object without receiving VMhost object. I looked at the documentation and set byValue to match the type the pipe passed in. \r\n- Is powershell always trying to match a type, rather than having to match a type?\r\n\r\n",
      "created_at": "2021-11-16T02:31:39Z",
      "updated_at": "2021-11-16T02:33:43Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "Ah. Autorest claims another victim. \r\n\r\nLast point first. PowerShell as an interpreted scripting language tries to flatten out types as far as it possibly can, so a lot of places where C# would want you explicitly do \"tostring\" or process an expression to get a boolean PowerShell will just sort it  out: e.g. in PowerShell `2 * '5' ` is 10 but `'2' * 5` is 22222, and if you expect rigid typing everywhere that can be a culture shock.\r\n\r\nWhen you decorate a PowerShell parameter with a type it is saying \"cast whatever you get here as type X\".  You can code validation for parameters which says \"throw an error if it is not a...\" but that won't help for the pipeline case. \r\n\r\nNow autorest...  IIRC it makes an API call with `Invoke-RestMethod` , which returns a `PSCustomObject` with a bunch of properties. It defines types for the responses, and converts the PSCustomObjects to those \r\nso it will build you something like  this \r\n```\r\nFunction Get-VMhost  {\r\nparam ($whatever_api_takes)\r\n$customObject =    invoke-restmethod -url  blah/vmhost?params\r\n$VMhostobject =  [vmhost]::new($customobject)\r\nreturn $vmhostobject  \r\n}\r\n```\r\nThe constructor for VM host does something like this\r\n```\r\nforeach ($property in $DestinationObject.psobject.properties)  {\r\n   if ($SourceObject.psobject.properties -contains $property) {$DestinationObject.$property = $SourceObject.$property}\r\n} \r\n```\r\nIt ignores anything returned by the API which wasn't part of the object definition but it also means if you ask for \r\n`[vmhost]::new($Anything_with_an_id)` \r\nYou'll get a VM host object with a nonsensical ID.  **I think that is what is happening to you**\r\n\r\nThe way around this is to avoid\r\n```\r\nparam (\r\n  [parameter(valueFromPipeline)]\r\n  [type-X] $X,\r\n\r\n  [parameter(valueFromPipeline)]\r\n  [type-Y] $Y\r\n)\r\n```\r\nWhen a `type-X` can be cast to a `type-Y` instead,  have \r\n```\r\nParam (\r\n $X ,\r\n\r\n $Y,\r\n\r\n[param(valueFromPipeline)]\r\n$InputObject\r\n)\r\nif     ($InputObject -is [type x]) {$x = $InputObject}\r\nelseIf ($InputObject -is [type y]) {$y = $InputObject}\r\n\r\nif     ($x {looks like a name}) {$x = (Get-TypeX-ByName $x).id}\r\nelseif ($x -is [Type-X]}) {$x = $x.id}\r\nelseif ($x {doesn't look like an ID} )  {Error}\r\netc.\r\n```\r\nDo not type X and Y because (a) you'll get things cast when it is stupid to do so and (b) it forces people to provide input in a way which was the shortest way for you to code, not in the form they want. The last bit ensures whether X was piped, was passed as a variable holding an object, or a string holding a name it always becomes the ID of what you want it to be.  Don't make people write  \r\n```\r\nProcess-Widget -widget (Get-Widget -name \"Mine\").id\r\n```\r\nInstead of\r\n```\r\nProcess-Widget $w\r\n``` \r\nor \r\n```\r\nProcess-Widget mine\r\n```",
      "created_at": "2021-11-16T12:37:12Z",
      "updated_at": "2021-11-16T12:37:12Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This issue has been marked as answered and has not had any activity for **1 day**. It has been closed for housekeeping purposes.",
      "created_at": "2021-11-19T00:00:41Z",
      "updated_at": "2021-11-19T00:00:41Z"
    }
  ],
  "created_at": "2021-11-15T12:10:31Z",
  "number": 16473,
  "state": "closed",
  "title": "Pipeline binding parameter, setting byValue does not take effect",
  "updated_at": "2021-11-19T00:00:42Z"
}