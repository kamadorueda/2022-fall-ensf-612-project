{
  "_url": "https://github.com/PowerShell/PowerShell/issues/3241",
  "author": "mklement0",
  "body": "Bash-style `&&` and `||` control operators would be handy additions to the language.\r\n\r\nFor instance, instead of writing (the examples are contrived, but hopefully illustrate the point):\r\n\r\n```powershell\r\n# If command A succeeds, execute command B too.\r\ncsc /nologo file.cs\r\nif (0 -eq $LASTEXITCODE) { git commit -m 'ok' }\r\n\r\n# if command A fails, execute command B.\r\ncsc /nologo file.cs\r\nif (0 -ne $LASTEXITCODE) { git commit -m 'failed'  }\r\n```\r\n\r\none might be able to write:\r\n\r\n```powershell\r\n# If command A succeeds, execute command B too.\r\ncsc /nologo file.cs && git commit -m 'ok'\r\n\r\n# if command A fails, execute command B.\r\ncsc /nologo file.cs || git commit -m 'failed'\r\n```\r\n\r\nThe examples use external utilities, but these operators would be equally handy for PowerShell-native commands (where `$?` rather than `$LASTEXITCODE` would have to be examined).\r\n\r\n---\r\n\r\n* There was [talk about adding `&&` and `||` in 2009](http://stackoverflow.com/a/573295/45375), but it seemingly never made the top of the list. Notably, @jpsnover  himself said:\r\n\r\n> && and || were on the list of things to implement (still are) but did not pop up as the next most useful thing to add.\r\n \r\n* There is a [feature request on windowsserver.uservoice.com](https://windowsserver.uservoice.com/forums/301869-powershell/suggestions/11087898-implement-the-and-operators-that-bash-has) that seems to be languishing.\r\n\r\nThere are several other questions on Stack Overflow asking for this feature and I've tried to summarize the state of affairs in [this answer](http://stackoverflow.com/a/41816341/45375).\r\n",
  "closed_at": "2019-10-17T21:43:47Z",
  "comments": [
    {
      "author": "i-give-up",
      "author_association": "NONE",
      "body": "I believe the proper term for `&&` and `||` is \"short-circuit operator\".",
      "created_at": "2017-10-03T08:10:02Z",
      "updated_at": "2017-10-03T08:10:02Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@i-give-up: While short-circuiting is an important aspect of these operators' behavior, both Bash and [POSIX call them _control operators_](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_09_03_06).\r\n\r\nIf you wanted to get as descriptive as possible, I guess you could call them _short-circuiting Boolean execution-flow control operators_.\r\n\r\nSo as to make this issue more easily discoverable, I've appended that term to the issue's title.\r\n\r\n",
      "created_at": "2017-10-03T13:07:38Z",
      "updated_at": "2017-10-03T13:07:38Z"
    },
    {
      "author": "lenkite",
      "author_association": "NONE",
      "body": "Short circuit operators are such a **fundamental** part of the daily shell use at the command line  and it is a massive burden to work without them. And the `-and`/`-or` operators are _not_ a replacement since they simply output the boolean result of the operation making them useless for interactive use.",
      "created_at": "2017-10-18T03:49:10Z",
      "updated_at": "2017-10-18T03:49:10Z"
    },
    {
      "author": "stofte",
      "author_association": "NONE",
      "body": "I dont understand what the -and operator actually does (and presumably the -or as well). \r\n\r\nIt's simply baffling to have the following code and see \"True\" come out when you run it\r\n\r\n    function Foo { return $True }\r\n    function Bar { return Foo -and $False }\r\n    Write-Host \"Bar: $(Bar)\"\r\n\r\nThe OPs stackoverflow really shows everything that is fubared about this design.\r\n",
      "created_at": "2017-11-09T15:37:52Z",
      "updated_at": "2017-11-09T15:37:52Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@stofte: PowerShell has 2 personalities (fundamental syntax forms): _argument mode_ (like a shell) and _expression mode_ (like a programming language) - see `Get-Help about_Parsing`.\r\n\r\n`-and` and `-or`  belong to the expression-mode world and operate on (often inferred) Boolean values.\r\nThey have no equivalent in argument mode, and that's the crux of the problem.\r\n\r\nYour example, ` Foo -and $False` is parsed in _argument_ mode, because the statement's _first token_ is a _command_. Therefore, you're passing tokens `-and` and `-$False` as _arguments_ (parameter values) to function `Foo` - where, in your case, they're _ignored_ and the output is simply `$True`.\r\n\r\nIf you want to use a _command_ (argument mode) as _part of an expression_ (expression mode; e.g., with `-and`), you must enclose it in parentheses:\r\n\r\n    return (Foo) -and $False\r\n\r\n\r\n",
      "created_at": "2017-11-09T18:21:11Z",
      "updated_at": "2017-11-10T10:55:19Z"
    },
    {
      "author": "stofte",
      "author_association": "NONE",
      "body": "@mklement0  Thanks for the explanation. It's still not entirely clear how argument modes relates and interacts with outcome vs output parsing/interpretation however.\r\n\r\nPS is probably the most confusing language I've come across in my years. It seems to assemble a hodge-podge of ideas in order to be everything for everyone (anyway, ranting over!)",
      "created_at": "2017-11-10T10:33:05Z",
      "updated_at": "2017-11-10T10:33:05Z"
    },
    {
      "author": "dragonwolf83",
      "author_association": "NONE",
      "body": "@stofte  You pass parameters to functions via the `-` character so any `-` characters after the function are going to be assumed to be parameters. So `Foo -and $false` is really trying to pass `-and` as the parameter name with `$false` as the value but since `Foo `doesn't define any parameters, it just ignores it. \r\n\r\nLet's change your script a bit to add parameters and see how it works. \r\n\r\n```PowerShell\r\nfunction Foo \r\n{ \r\n    Param($and) \r\n    Write-Host \"And = $and\"\r\n    \r\n    return $True \r\n\r\n}\r\nfunction Bar { Foo -and $False }\r\nWrite-Host \"Bar: $(Bar)\"\r\n```\r\n\r\nNow, `Foo `will accept the parameter and pass `$false` into the function. However, it still returns `$true` since that is what the function outputs. \r\n\r\nSo for PowerShell to know if it shouldn't be trying to pass `-and` as a parameter, you need to use parenthesis to control order of operations. `(Foo) -and $false` now will run `Foo` first, then evaluate the remaining statement `$true -and -$false`.\r\n\r\nBTW, PowerShell ISE and Visual Studio Code is smart enough to tell you all of this via Intellisense. It knows that the `-and` operator can't be used in your original code and won't give it as an option. I highly recommend using Intellisense to make sure keywords are usable in the right context.\r\n\r\nNow for why functions are using `-` to pass parameters is because the idea behind PowerShell is to create command-line applications through functions instead of having to compile an application. So a Function mimics much of the command-line experience to make it happen.",
      "created_at": "2017-11-10T19:42:17Z",
      "updated_at": "2017-11-10T19:42:17Z"
    },
    {
      "author": "jurriaanr",
      "author_association": "NONE",
      "body": "I can't believe I still have to start up cmd for this functionality, my bash using colleagues are making fun of me ",
      "created_at": "2018-04-13T12:55:38Z",
      "updated_at": "2018-04-13T12:55:38Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "I've been thinking about this a bit.\r\n\r\nA thought I have is that if `&&` and `||` only look at `$LASTEXITCODE` it makes them pretty specific -- two new operators that only work in the context of native commands. And without good knowledge of that fact, something like\r\n```powershell\r\ncsc.exe program.cs\r\n\r\nFoo && Bar\r\n```\r\ncould prove very confusing, since it either uses the `$LASTEXITCODE` value, in which case `Bar` being executed depends on the success of the `csc.exe` line. OR, if just assumes that a non-native command succeeds (or whatever) that is just as confusing. *OR*, we throw an error because `Foo` isn't a native command...\r\n\r\nSo I was thinking about something more like JavaScript's (please, hear me out...) [short circuit operator implementation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Description). That way you could do:\r\n```powershell\r\n> \"\" && \"Hello\"\r\n\r\n> \"Hi\" && \"Hello\"\r\nHello\r\n\r\n>\"Hi\" || \"Hello\"\r\nHi\r\n\r\n> \"\" || \"Hello\"\r\nHello\r\n```\r\nSpecifically, `Foo && Bar` evaluates `Foo` and if the result coerces to `$false`, it returns that (pre-coercion) value, otherwise it returns the result of `Bar`. With `Foo || Bar`, `Foo` is evaluated and if the result coerces to `$true` it returns that (pre-coercion) result, otherwise we evaluate and return the result of `Bar`. The operators would have equal precedence and be left-associative, so you can chain them like so:\r\n```powershell\r\n> \"\" || \"Hello\" && \"Goodbye\"\r\nGoodbye\r\n```\r\nThat last thing is pretty confusing, but would be useful for chains of only one operator (`Step1 && Step2 && Step3`, `Try1 || Failover1 || Failover2`) and I see no particular reason not to support a mixed chain.\r\n\r\nNotice that this also gives us a [null-coalescing functionality](https://github.com/PowerShell/PowerShell/issues/3240) like so: `$x = $v || \"default\"`. With a mixed chain you'd even get a (rather confusing) [ternary operator](https://github.com/PowerShell/PowerShell/issues/3239): `$condition && $ifTrue || $ifFalse`.\r\n\r\n**However**, the problem is that this wouldn't scratch the itch of wanting a way to chain native commands. So, we could make it that when one of these operators evaluates a native command as an argument, it proceeds based on the `$LASTEXITCODE` value, so that the following work:\r\n```powershell\r\n> csc.exe badprogram.cs && RunProgram\r\n# error output from csc.exe, RunProgram not evaluated\r\n\r\n> SetupProject && csc.exe goodprogram.cs\r\n# output from csc.exe, SetupProject evaluated\r\n```\r\nI think that's a bit complex, but unfortunately it seems to be most sensible and useful option I can see.\r\n\r\nAnyway, please let me know your thoughts on this -- I'm just spitballing ideas here (although I'm always in favour of consistency). After some initial thoughts/comments here, I'd like to write up an [RFC](https://github.com/PowerShell/PowerShell-RFC) with a more concrete proposal and then implement a prototype.",
      "created_at": "2018-04-21T03:06:12Z",
      "updated_at": "2018-04-21T03:36:02Z"
    },
    {
      "author": "saschanaz",
      "author_association": "NONE",
      "body": ">So I was thinking about something more like JavaScript's (please, hear me out...) short circuit operator implementation\r\n\r\nI still think we need to use $LASTEXITCODE. For example, think about `npm run build && npm run deploy`. `npm run build` can emit some text even when it fails, and I want to prevent `npm run deploy` from running after a failed build.",
      "created_at": "2018-04-21T04:33:14Z",
      "updated_at": "2018-04-21T04:34:08Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "Yes, but *exclusively* `$LASTEXITCODE`? Or in the way I describe at end where non-native commands work by falsey/truthy-ness and native commands use `$LASTEXITCODE`?\r\n\r\nMy concern with *exclusively* using `$LASTEXITCODE` is as I say above: if you run a native command and then use `&&` later, like:\r\n```powershell\r\nnpm run build\r\n\r\nDoSomething && DoAnotherThing\r\n```\r\nwhat should `&&` do?",
      "created_at": "2018-04-21T04:39:45Z",
      "updated_at": "2018-04-21T04:39:45Z"
    },
    {
      "author": "saschanaz",
      "author_association": "NONE",
      "body": ">So, we could make it that when one of these operators evaluates a native command as an argument, it proceeds based on the $LASTEXITCODE value, so that the following work\r\n\r\n>if you run a native command and then use && later, like:\r\n\r\nThrowing when when something *is* ~~not (edit)~~ a native command may look simpler. The suggested behavior looks inconsistent for me when:\r\n\r\n```powershell\r\n> npm --version && \"Hello\"\r\n5.6.0\r\nHello\r\n> $v = npm --version; $v && \"Hello\"\r\nHello\r\n",
      "created_at": "2018-04-21T04:53:31Z",
      "updated_at": "2018-04-21T04:57:47Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Please note that `&&` and `||` in Bash are _control_(-only) operators: \r\n * they only decide what commands get executed in principle, based on the commands' exit codes\r\n *  but **do not interfere with the commands' output streams** \r\n * and **what the commands do or do not _output_ (send to the output streams) is _irrelevant_ for the determination of execution success.**\r\n\r\n```sh\r\n#!/bin/bash\r\necho one && echo two  # prints *both* 'one' and 'two'\r\n```\r\n\r\nIn other words: It's a way of conditionally chaining commands with their usual output behavior, _if_ they get to execute.\r\n\r\nBy analogy, in PowerShell their detection of _successful_ execution should be based on:\r\n\r\n* `$LASTEXITCODE -eq 0` for external utilities (native commands)\r\n\r\n*  `$? -eq $True` for PowerShell commands (cmdlets / functions / scripts)\r\n\r\n**`&&` and `||` primary belong to the realm of _commands_** (something called by a name, with arguments parsed in argument mode) and has limited applicability to _expressions_:\r\n\r\n```powershell\r\n\"a\" && \"b\"  # should output *both*  'a' and 'b'\r\n```\r\n\r\nIn a simple expression such as `\"a\"`, there's nothing that can _fail_, so use of `&&` makes little sense.\r\n\r\nWhat's worse, **because `&&` / `||` only act on _execution success_, even falsy expressions are \"true\" from their perspective**, because it isn't their _value_ (output) that matters:\r\n\r\n```powershell\r\n$False && \"hi\"  # !! should output *both*  'False' and 'hi' - both expressions \"ran\" without error\r\n```\r\n\r\nSo, **one way to bypass potential confusion is to restrict use of `&&` and `||` to _pipelines_ only**; in other words: all **operands must be either simple commands or pipelines.**\r\n\r\nThere are several **problems** with this approach, however:\r\n\r\n* Pipelines can _start_ with an expression, which could be confusing. E.g.,  \r\n`'foo' | Write-Output && ...` would be allowed, but `'foo'  && ...` would not.\r\n\r\n* Arguably, using an expression as the _RHS_ of `&&` and `||` would be useful; e.g.,  \r\n`Get-ChildItem -ea Ignore -Name *.log || 'log1.log'`\r\n\r\n* More generally, _wrapping_ commands in expressions can be useful; e.g.,  \r\n`(Get-ChildItem -ea ignore *.log).LastWriteTime || [datetime] 0`\r\n\r\n* There are pure expressions that _can_ fail, generating a _statement-terminating_ error in the case of (implicitly) calling a .NET framework method that throws an exception; e.g.:\r\n  * `[int]::parse('hi')`\r\n  * `$div = 0; 1 / $div`\r\n\r\n---\r\n\r\n**If we do allow expressions**, the **problems** are:\r\n\r\n* Sowing confusion among users that come from the C# / JavaScript, ... world who are used to `&&` and `||` having the semantics of what `-and` and `-or` do in PowerShell (such languages have no counterpart to what Bash's `&&` and `||` do).\r\n\r\n* Similarly, pointless constructs such as `1 && 2` are enabled (applying the operators to expressions that never fail); the example is equivalent to `1; 2`, i.e., simple _serial_ execution.\r\n\r\n* `$?` currently also reflects _expression_ success, which wipes out the `$?` value from any _wrapped command_, which happens with something as simple as enclosing a command in `(...)`; e.g.,  \r\n`Get-Item NoSuchFile; $?` outputs `$False` whereas  \r\n`(Get-Item NoSuchFile); $?` outputs `$True`  \r\nThe current `$?` behavior is summarized [here](https://github.com/PowerShell/PowerShell/issues/3359#issuecomment-287842045), with clarifications by @BrucePay [here](https://github.com/PowerShell/PowerShell/issues/3359#issuecomment-372493987).\r\n\r\n   * This severely limits `$?`'s usefulness in general, but especially in the context of implementing `&&` and `||`\r\n\r\n   * **The solution would be to make only _commands_ (outside conditionals) set `$?`**, not _expressions_, with the exception of a .NET operation causing a _statement_-terminating error, such as `[int]::Parse('hi')`.",
      "created_at": "2018-04-21T13:41:05Z",
      "updated_at": "2018-04-21T13:41:05Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "Yes I see what you mean.\r\n\r\nIn my mind then, `&&` and `||` must always write the result of an evaluation to the relevant stream as you  say and proceed based on the value of `$?` (assuming that always accords with `$LASTEXITCODE` in the case of native commands, and if not, we check `$LASTEXITCODE -eq 0` in those cases).\r\n\r\nI'm motivated by @stofte's sentiment earlier:\r\n>PS is probably the most confusing language I've come across in my years. It seems to assemble a hodge-podge of ideas in order to be everything for everyone\r\n\r\nPowerShell contains a lot of concepts that Bash doesn't, and for `&&` and `||` to be worthy first-class language-level operators, they need to find holistic application in the language. Since commands can be native or non-native and expressions can have side effects, it still makes sense to use control operators with all of them (to some extent).\r\n\r\nTo that end, I think that allowing `&&` and `||` only in pipelines or only with native commands is not the way to go.\r\n\r\nInstead I think `&&` and `||` should be usable wherever `;` is usable, but where `<x>;<y>` evaluates `<x>` and then `<y>`, `<x> && <y>` evaluates `<x>` and if `$?` is true evaluates `<y>`, while `<x> || <y>` evaluates `<x>` and if `$?` is false evaluates `<y>`. `&&` and `||`  should be success-conditional sequencing operators.\r\n\r\nThat leaves us with the issue of how the `$?` value is set. But I feel like it makes sense to implement `&&` and `||` with respect to `$?` and then make sure that `$?` has a straightforward meaning and contract as a [separate issue](https://github.com/PowerShell/PowerShell/issues/3359).",
      "created_at": "2018-04-23T17:35:09Z",
      "updated_at": "2018-04-23T17:35:09Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "@rjmholt Lexically, `&&` and `||` are statement separators and therefore should work with any simple statements including expressions. \r\n\r\nThey should operate off of `$?` and there is no need to check `$LASTEXITCODE` since this is taken care of automatically (i.e. if a native command exits with a non-zero exit code, then `$?` will be false.). For example:\r\n```\r\nPS[1] (140) > true.exe ; $?\r\nTrue\r\nPS[1] (141) > false.exe ; $?\r\nFalse\r\n```\r\nAnd expressions do set `$?`:\r\n```\r\nPS[1] (135) > 1/1 ; $?\r\n1\r\nTrue\r\nPS[1] (136) > 1/0 ; $?\r\nAttempted to divide by zero.\r\nAt line:1 char:1\r\n+ 1/0 ; $?\r\n+ ~~~\r\n    + CategoryInfo          : NotSpecified: (:) [], RuntimeException\r\n    + FullyQualifiedErrorId : RuntimeException\r\n\r\nFalse\r\n```\r\nso they will work fine with `&&` and `||`. \r\n\r\nOne difference between `;` and `&&` is that the flow control operators should throw an `IncompleteParse` exception if the RHS is missing so we can handle the interactive experience. And the code will have to be formatted multiline like:\r\n```\r\ncommand1 &&\r\n    command2 &&\r\n        command3 \r\n```\r\nas is the case with pipelines (which is prompting _much_ discussion in #3020)\r\n\r\nWe might also spend a little bit of time thinking about exceptions to see if they should be involved in any way...",
      "created_at": "2018-04-23T22:28:25Z",
      "updated_at": "2018-04-23T22:28:25Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "@BrucePay ok, that's what I was imagining should be the case.\r\n\r\nCan you expand on the exceptions part?\r\n\r\nI'm personally not sure whether it's better to have:\r\n```powershell\r\nthrow \"Bad\" || CleanupThings\r\n```\r\ncontinue to `CleanupThings` (especially since `throw` sets `$? = $false`), or if we consider exceptions to not be caught by control operators.\r\n\r\nThe problem I see with the first case is that if `||` continues after an exception, we either rethrow the exception at the end of the statement sequence (which is probably not helpful at that stage), or we absorb the exception, which means statement control implicitly catches all exceptions and users won't get warned about possibly bad failures.\r\n\r\nBut in the second case, `||` works fine unless you throw an exception, at which point it no longer \"executes the RHS after the LHS fails\". So any sequence of statements that could fail or throw an exception would have to use `||` inside a `try`/`catch` block.",
      "created_at": "2018-04-23T22:44:17Z",
      "updated_at": "2018-04-23T22:44:17Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Good point about `$?` already reflecting `$LASTEXITCODE -eq 0` immediately after calling a \"native\" command (I wish we'd stop calling them that, given that there's nothing native about, say, calling `node` - something like _external programs_ seems more apt).\r\n\r\n> And expressions do set $?:\r\n\r\nIndeed they do, and that they do so is unhelpful, as I've tried to argue.\r\n\r\nGiven a statement such as:\r\n\r\n```powershell\r\n(Get-Content nosuchfile) -notmatch '^\\s*#' || ...\r\n```\r\n\r\nDon't you think users are more likely to expect the `||` to act on `Get-Content`'s success rather than the wrapping _expression's_ \"success\", which has little meaning other than when involving a .NET exception?\r\n\r\n\r\n",
      "created_at": "2018-04-24T02:09:34Z",
      "updated_at": "2018-04-24T02:20:40Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@rjmholt:\r\n\r\n[This comment by @BrucePay](https://github.com/PowerShell/PowerShell/issues/3798#issuecomment-383779216) tells me that `Throw` terminates the current thread of execution, which in your example would _not_ give the the RHS of `||` a chance to execute.\r\n\r\nInteractively, you can verify this as follows, using `;` instead of the (not-yet-extant) `||`:\r\n\r\n```powershell\r\nPS> Throw \"bad\"; 'after'\r\n```\r\n\r\nIn the example above, `'after'` never gets to execute, because the entire command line is terminated (which can be conceived of as an ad-hoc script).\r\n\r\nWe still don't have an official term for the kind of error `Throw` generates (see https://github.com/PowerShell/PowerShell/issues/3798#issuecomment-383783407), but for now I'm calling them _fatal errors_.\r\n\r\nMy vote is for not changing this behavior, i.e., for `&&` and `||` only to act on _non-fatal_ errors (which by default are _non-terminating_ errors and _statement-terminating_ errors).\r\n\r\n",
      "created_at": "2018-04-24T02:40:17Z",
      "updated_at": "2018-04-24T02:40:17Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "I find that behaviour very interesting, given this comparison:\r\n\r\n```powershell\r\n> 1/0; \"Hello\"\r\nAttempted to divide by zero.\r\nAt line:1 char:1\r\n+ 1/0; \"Hello\"\r\n+ ~~~\r\n+ CategoryInfo          : NotSpecified: (:) [], RuntimeException\r\n+ FullyQualifiedErrorId : RuntimeException\r\n\r\nHello\r\n```\r\n\r\n```powershell\r\n> throw \"Bad\"; \"Hello\"\r\nBad\r\nAt line:1 char:1\r\n+ throw \"Bad\"; \"Hello\"\r\n+ ~~~~~~~~~~~\r\n+ CategoryInfo          : OperationStopped: (Bad:String) [], RuntimeException\r\n+ FullyQualifiedErrorId : Bad\r\n```\r\n\r\n```powershell\r\n> try { 1/0; \"Hello\" } catch { \"Exception\" }\r\nException\r\n```\r\n\r\n```powershell\r\n> try { throw \"Bad\"; \"Hello\" } catch { \"Exception\" }\r\nException\r\n```\r\n\r\nBut yes, I agree.",
      "created_at": "2018-04-24T16:20:05Z",
      "updated_at": "2018-04-24T16:21:53Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@rjmholt:\r\n\r\nYes:\r\n\r\n *  `1 / 0` is a _statement_-terminating error, which is why `\"Hello\"`, as the _next_ statement, still executes.\r\n\r\n  * `throw \"Bad\"` is a _script_-terminating error (fatal error), which means that the current thread of execution is terminated by default, so `\"Hello\"` never gets to execute.\r\n\r\nOn the other hand, `try` / `catch` (and also `trap`) can trap _either_ kind of error (but _not_ _non-terminating_ ones such as `Get-Item /NoSuch`).\r\n\r\nI've tried to document the bewildering complexity and inconsistency of PowerShell's current error handling in [this doc issue](https://github.com/PowerShell/PowerShell-Docs/issues/1583).\r\n\r\n---\r\n\r\nIn a technology-debt-free world, `1 / 0` would ideally be a script-terminating error as well, but changing this behavior now would be a massively breaking change.\r\n\r\nBy contrast, what we _can_ do - given that `$?` is currently virtually useless with non-statement-error-throwing expressions - is:\r\n\r\n* Nothing needs to change with respect to _statement_-terminating errors, be they generated by a _command_ or by an exception produced by an operator or direct .NET method call: The statement as a whole is terminated and `$?` is set to `$False`.\r\n\r\n* Otherwise - if there are _no_ errors or only _non-terminating_ errors:\r\n\r\n  * Make expressions _not_ set `$?`,\r\n\r\n  * ... which then allows the overall expression to reflect an embedded _command_'s success .\r\n\r\nIn other words: unless a statement-terminating error occurs, an expression by itself wouldn't even _touch_ `$?`.\r\n\r\n---\r\n\r\nWith `$?` relegated to the world of commands, the question then becomes how to handle _multiple_ commands embedded in an expression:\r\n\r\nAssuming we don't want to go as far as to provide the success status of _all_ commands involved (analogous to Bash's automatic `$PIPESTATUS` array variable):\r\n\r\nThe precedent set by the _pipeline_ is to have `$?` reflect `$False` if _any_ command involved generated a non-terminating error.\r\nIn other words: unlike in Bash, it is not the _last_ command's status that is reflected. E.g.:\r\n\r\n```powershell\r\nGet-Item /, /NoSuch | % { 'hi' }; $?\r\nhi\r\n...       # error output\r\nFalse     # A reflection of Get-Item's non-terminating error.\r\n```\r\n\r\nTherefore I suggest exhibiting analogous behavior in the case of multiple commands being embedded in an expression.\r\n\r\n\r\n",
      "created_at": "2018-04-25T14:16:18Z",
      "updated_at": "2018-04-25T14:16:18Z"
    },
    {
      "author": "felixfbecker",
      "author_association": "CONTRIBUTOR",
      "body": "This proposal seems to resolve mostly around native commands, where failure is indicated by a non-zero exit code vs cmdlets, where failure is indicated through an exception. As some have pointed out, I believe there is bad potential here for inconsistency. If I run `ls || \"hi\"` it shouldn't work any different than `Get-ChildItem || \"hi\"`, otherwise external programs become less \"integrated\" into PowerShell, not more, and I believe seemless integration of native commands should be an important goal in PS.\r\n\r\nI would like to understand the actual use case of this proposal a bit more as it seems related to #3415 (see https://github.com/PowerShell/PowerShell/issues/3996#issuecomment-384775097). I.e. in what scenerio is this operator needed and what problem does it actually solve.\r\n\r\nAs seen in the OP it is really just a shorter one-line syntax for something that can already be done with an `if` statement. As such it seems like the primary use case for this is in the REPL, because I believe in scripts it is more readable if you write out the `if` (or `try`/`catch` with linked proposal) and not put multiple commands in one line. But in the REPL, I wonder why you wouldn't just run the commands manually and only run the second if the first failed.\r\n\r\nI think the more readable alternative to chaining native commands with `&&` is having the proposed `set -e` equivalent, which would just allow `$CommandErrorActionPreference='Stop'` to turn any non-zero exit code into an exception, with the possibility to catch it (the equivalent to `||`) with a normal `try`/`catch` (like it works for cmdlets, so it's consistent). Concrete example of the OP:\r\n\r\n```powershell\r\n# If command A succeeds, execute command B too.\r\n$CommandErrorActionPreference = 'Stop'\r\ncsc /nologo file.cs\r\ngit commit -m 'ok'\r\n\r\n# if command A fails, execute command B.\r\ntry {\r\n  csc /nologo file.cs\r\n} catch {\r\n  git commit -m 'failed'\r\n}\r\n```\r\n\r\nWhat do the proponents of this proposal think about this? In a world where we had this capability, would you still want `&&` and `||` as much? If yes, for what reason?",
      "created_at": "2018-04-26T21:15:58Z",
      "updated_at": "2018-04-26T21:15:58Z"
    },
    {
      "author": "saschanaz",
      "author_association": "NONE",
      "body": "try-catch would work, but what about multiple commands more than 2? `npm run fetch && npm run build && npm run baseline-accept` becomes `try { npm run fetch } catch { try { npm run build } catch { npm run baseline-accept } }` and this is much more verbose.\r\n\r\nEdit: Or right, I confused `&&` and `||` \ud83d\ude05",
      "created_at": "2018-04-26T21:46:47Z",
      "updated_at": "2018-04-26T22:22:36Z"
    },
    {
      "author": "felixfbecker",
      "author_association": "CONTRIBUTOR",
      "body": "@saschanaz I think you are confusing `&&` and `||`.\r\n`npm run fetch && npm run build && npm run baseline-accept` would become\r\n```powershell\r\n$CommandErrorActionPreference='Stop'\r\nnpm run fetch\r\nnpm run build\r\nnpm run baseline-accept\r\n```\r\nor\r\n```powershell\r\n$CommandErrorActionPreference='Stop'; npm run fetch; npm run build; npm run baseline-accept\r\n```\r\nThis line in bash does the same thing:\r\n```bash\r\nset -e; npm run fetch; npm run build; npm run baseline-accept\r\n```",
      "created_at": "2018-04-26T21:55:12Z",
      "updated_at": "2018-04-26T21:55:12Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "Personally, while I try to resist the \"add the kitchen sink\" approach to PowerShell, this is a feature common to most other shells. It's handy, and as a user of other shells as well, in my muscle memory.\r\n\r\nPowerShell tries to differentiate itself on its interactive experience, and having to type out a `try`/`catch` block doesn't feel as one-liner interactive as just chaining things with an operator. And with PSCore being cross-platform, there's more native utility interaction experience to handle than ever, and we want to minimise friction for new users who want to do things like `apt update && apt upgrade`.\r\n\r\n@saschanaz also makes a good point that `try`/`catch` is much harder to compose than the left-to-right operator execution.\r\n\r\nI share exactly your concern about inconsistency between native utilities and PowerShell commands being exacerbated, but I think that's why we need to discuss this feature carefully. If we make the rule for `&&` and `||` simple and base it on existing concepts (like that `&&` proceeds when `$?` is true and `||` proceeds when `$?` is false -- and neither catch a fatal/pipeline-terminating error), then all we have to do is make sure those existing concepts work and make sense (i.e. make sense of PowerShell's error handling -- no small task, but easier than having to do that while also explaining complicated workaround rules for these operators).\r\n\r\nIn terms of `set -e`, I think having an explicit, composable operator is still desired. Even though you can use `set -e` in an interactive context, it relies on an implicit state in execution. So it's arguably harder to read (especially for the uninitiated) and also harder to analyse. The other problem is that it doesn't provide `||` functionality. I think `set -e` is also useful, but in my mind it's more designed to indicate fast-fail behaviour in larger scripts, rather than for chaining one-liners.",
      "created_at": "2018-04-26T22:05:09Z",
      "updated_at": "2018-04-26T22:05:35Z"
    },
    {
      "author": "felixfbecker",
      "author_association": "CONTRIBUTOR",
      "body": "> If we make the rule for && and || simple and base it on existing concepts (like that && proceeds when $? is true and || proceeds when $? is false -- and neither catch a fatal/pipeline-terminating error), then all we have to do is make sure those existing concepts work and make sense (i.e. make sense of PowerShell's error handling -- no small task, but easier than having to do that while also explaining complicated workaround rules for these operators).\r\n\r\nOkay, so just to be clear, `||` and `&&` would only be effective for cmdlets if `$ErrorActionPreference -ne 'Stop'` and for external commands if `$CommandErrorActionPreference -ne 'Stop'`. Otherwise there would be an exception just like if you didn't use those operators.\r\nI think this makes sense because in an REPL context `$ErrorActionPreference` is usually `Continue`, whereas in a script where you might want to set it to `Stop` you also would want the readability of having one command per line, so the operators are not as appropiate. \ud83d\udc4d ",
      "created_at": "2018-04-26T22:14:37Z",
      "updated_at": "2018-04-26T22:14:37Z"
    },
    {
      "author": "felixfbecker",
      "author_association": "CONTRIBUTOR",
      "body": "So I think the coupling between the two proposal is solved. For me the only question left is whether it should be `&&` and `||` or `-and`/`-or` (or maybe new operators), since PowerShell usually breaks legacy conventions in favor of readability. But I guess anything starting with `-` doesn't work well with native commands and output redirection already uses special characters inspired by other shells for its operators. ",
      "created_at": "2018-04-26T22:17:17Z",
      "updated_at": "2018-04-26T22:17:17Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "@felixfbecker You make a very good point about `$[Command]ErrorActionPreference = 'Stop'` but I think your proposed behaviour is probably the right one. Others may want to add their insights there. But it makes sense to me that setting those variables means throwing a fatal error, which means there's no continuing over `||`.\r\n\r\nBecause of the parser's \"modes\", an operator like `-and` won't work after a command due to ambiguity (`DoSomething -or CleanUp` makes `-or` look like a parameter passing `CleanUp` as a bareword string). It's theoretically possible to implement, but it would break a number of things, is less efficient and would be a lot of work, so is pretty squarely ruled out. The other thing is that `-and` and `-or` already have functionality, so changing that would be a breaking change, which again is ruled out by the PowerShell [breaking change contract](https://github.com/PowerShell/PowerShell/blob/master/docs/dev-process/breaking-change-contract.md).\r\n\r\nMy inclination is that `&&` and `||` have good recognition and have been on the list of things to add in that verbatim form for some time. But there's no reason to rule out alternatives. They just can't start with `-`.",
      "created_at": "2018-04-26T22:30:25Z",
      "updated_at": "2018-04-26T22:30:25Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> This proposal seems to resolve mostly around native commands, where failure is indicated by a non-zero exit code\r\n\r\n**No, the proposal is to apply the operators equally to PowerShell commands and external programs, based on `$?`** (though the operators are patterned after POSIX-like shells).\r\n\r\n---\r\n\r\n> vs cmdlets, where failure is indicated through an exception\r\n\r\n**While .NET exceptions _underlie_ PowerShell's error handling, it's not useful to discuss it in those terms - they are an implementation detail.**\r\n\r\nIn fact, cmdlets (as opposed to advanced functions) _never_ create fatal errors, they only create two kinds of errors:\r\n\r\n* _non-terminating_: the statement that the error-reporting cmdlet is part of keeps executing, if there are more input objects to process.\r\n\r\n* _statement-terminating_: the statement the error-reporting cmdlet is part of is terminated, but execution continues with the _next_ statement.\r\n\r\n_Script_-terminating errors (fatal-by-default errors) can only arise in two situations:\r\n\r\n* `$ErrorActionPreference = 'Stop'`\r\n\r\n* `-ErrorAction Stop`, but, confusingly, only when encountering _non-terminating_ errors.\r\n\r\n**In short: by default, the typical case is for execution to _continue_, either intra-statement (non-terminating error), or with the next statement (statement-terminating).**\r\n\r\n---\r\n\r\n> I think the more readable alternative to chaining native commands with && is having the proposed set -e equivalent\r\n\r\n**`set -e` and `&&` / `||` are _separate_ features**, each useful in their own right, and problematic in combination (see below)\r\n\r\nIn POSIX-like shells, users often forgo `set -e` and its complex rules in favor of explicit error handling with `||`.\r\n\r\n---\r\n\r\n> The other thing is that -and and -or already have functionality\r\n\r\nIndeed, they do; furthermore, **`-and` and `-or` belong to the world of _expressions_, based on _return values_ / _outputs_** - and that obviously shouldn't change.\r\n\r\n**`&&` and `||` belong to the world of _commands_ - be they cmdlets or external programs - and they act on _success vs. failure_ via `$?`, without interfering with outputs.**\r\n\r\nThis distinction is somewhat tricky, given that `&&` / `||` have  the same semantics as PS's `-and` / `-or`  in C-inspired \"real\" programming languages, but it's just one of the challenges that comes with PS's hybrid nature, and we just need to make sure that the difference is well-documented.\r\n\r\n---\r\n\r\n> $CommandErrorActionPreference='Stop'\r\n\r\nThe word _Command_ in your proposed variable name is problematic, because _command_ is PowerShell's umbrella term for _anything_ invoked by name / filesystem path - whether PowerShell-internal or external.\r\n\r\nThus, `$ExternalErrorActionPreference` makes more sense to me, to highlight that the preference refers to _external programs_ (\"native\" is a confusing term, and I suggest we avoid it).\r\nI'll use this name in the remainder of this comment.\r\n\r\n---\r\n\r\n> I believe in scripts it is more readable if you write out the if (or try/catch with linked proposal)\r\n\r\n**To me, `&&` and `||` are concise and expressive constructs that beat the \"noise\" of `if` statements and `try` / `catch` handlers - on the command line as well as in scripts.**\r\n\r\n> Okay, so just to be clear, || and && would only be effective for cmdlets if $ErrorActionPreference -ne 'Stop' and for external commands if $CommandErrorActionPreference -ne 'Stop'. Otherwise there would be an exception just like if you didn't use those operators.\r\n\r\n* **`&&` and `||` should operate on `$?` only** - the combination with `$ExternalErrorActionPreference` needs to be discussed separately (see below).\r\n\r\n* as stated, cmdlet errors _continue_ execution by default - intra-statement with non-terminating errors, next-statement with statement-terminating errors.\r\n\r\n---\r\n\r\nThat leaves the question: **how should `&&` and `||` act in the presence of `$ExternalErrorActionPreference = 'Stop'`**?\r\n\r\nAs I've argued at https://github.com/PowerShell/PowerShell/issues/3996#issuecomment-384775097, it's worth borrowing _one_ exception from the `set -e` exceptions in POSIX-like shells:\r\n\r\n**Any command (statement) _except the last_ in a `&&` / `||` chain should _not_ trigger a fatal error while `$ExternalErrorActionPreference = 'Stop'` is in effect, given that the use of `&&` and `||` clearly signals an anticipation of potential failure.**\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2018-04-27T02:56:14Z",
      "updated_at": "2018-04-27T02:56:14Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 I think we are almost entirely agreeing with you here. I definitely appreciate your ability to dissect a problem too. I'm not sure I share your fully taxonomised conceptual model of PowerShell's semantics, but I think we are generally on the same wavelength. (The concern about being native-command-only I think was because that was floated earlier in the thread).\r\n\r\nThe only part I'm not sure about is the `$ExternalErrorActionPreference = 'Stop'` behaviour. On one hand, you make a good point that bash does it and our inspiration for these operators is bash. But on the other hand, it also makes sense that `$ExternalErrorActionPreference = 'Stop'` means if any external command has an error, we stop. Having to explain to users that \"well, actually, if you use `||` we keep going even though you specified **Stop**\" is one of those things I don't look forward to, but it might be a matter of naming the variable. As often, the UNIX world gets away with it because `set -e` doesn't promise much in the name.\r\n\r\nOn the name of the variable:\r\n> Thus, $ExternalErrorActionPreference makes more sense to me, to highlight that the preference refers to external programs (\"native\" is a confusing term, and I suggest we avoid it).\r\nI'll use this name in the remainder of this comment.\r\n\r\nFor better or worse, PowerShell refers to external utilities as \"native\" everywhere I've seen. I think the horse has bolted on that vocabulary and trying to change it will just result in two competing terms that confuse more people.",
      "created_at": "2018-04-27T03:50:22Z",
      "updated_at": "2018-04-27T03:50:22Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@rjmholt:  \r\n\r\nThanks; I'm glad we're mostly in agreement.\r\n\r\n>  I'm not sure I share your fully taxonomised conceptual model of PowerShell's semantics\r\n\r\nPlease tell me where you disagree; it'll help future conversations.\r\n\r\n---\r\n\r\n> if you use || we keep going even though you specified Stop\" is one of those things I don't look forward to\r\n\r\n**I do get the appeal of avoiding exceptions in general, but this particular one makes sense to me.**\r\n\r\nTo recap: The sole reason to use `||` is to deal with anticipated failures.\r\n\r\nTo borrow my example from https://github.com/PowerShell/PowerShell/issues/3996#issuecomment-384775097:\r\n\r\n```powershell\r\n# Get files from /dir1, if available, otherwise from /dir2\r\n$files = ls /dir1 2>$null || ls /dir2\r\n```\r\n\r\nThe use of `||` here signals an anticipation of a failure of the 1st command.\r\n\r\nYou can think of `||` as an _ad hoc override_ of any `$ExternalErrorActionPreference = 'Stop'`, similar to overriding `$ErrorActionPreference = 'Stop'` with, say, `-ErrorAction Ignore`.\r\n\r\nHowever, `$ExternalErrorActionPreference = 'Stop'` _would_ kick in if the _2nd_ `ls` command failed, since its failure is not anticipated.\r\n\r\nBy contrast, with `&&` the case is less clear-cut: in POSIX-like shells, it is often used to prevent execution of subsequent commands if earlier ones failed.\r\n\r\nSo if the intent is simply to prevent follow-on failures, an exception is perhaps _not_ needed, and `$ExternalErrorActionPreference = 'Stop'` could treat a failure as fatal even if it is the first `&&` operand - but that would need to be overruled if a `||` is present _later_.\r\n\r\nIn POSIX-like shells `&&` is granted the same exception as `||`, and perhaps modifying that exception to only apply to `||` is too confusing (and perhaps even impractical to implement - I can't speak to that), both in itself and for users coming from POSIX-like shells.\r\n\r\nI'm not sure what the right answer is.\r\n\r\n---\r\n\r\n**If we make _no_ exception:**\r\n\r\nEffectively, we're then forcing users to _choose_ between use of `$ExternalErrorActionPreference = 'Stop'`  and `&&`/`||` use, because having to locally `try` / `catch` potential failures negates the concision and expressiveness of `&&`/`||`:\r\n\r\n```powershell\r\n# Need try / catch to guard against $ExternalErrorActionPreference = 'Stop'\r\n$files = try { ls /dir1 2>$null } catch {} || ls /dir2\r\n```\r\n\r\nThis could be somewhat mitigated by a yet-to-be-introduced new syntax that provides the analog of \r\n `-ErrorAction` to external-program invocations.  \r\nIt is tricky to come up with the right syntax, however, since it would either have to be a meta-parameter similar to `--%` or perhaps a modified version of the `&` operator, and keeping it concise risks its being arcane:\r\n\r\n```powershell\r\n$files = &(i) ls /dir1 2>$null || ls /dir2  # &(i) is the hypothetical analog to -ErrorAction Ignore\r\n```\r\n\r\n\r\n---\r\n\r\nAs for the term \"native\":\r\n\r\nAt the end of the day, what matters is that people know what a term stands for.\r\nAnd human language in general is full of misnomers that no one thinks twice about, if they've been around long enough.\r\n\r\nSo I don't think this is the most important issue, but please bear with me:\r\n\r\n> For better or worse, PowerShell refers to external utilities as \"native\" everywhere I've seen.\r\n\r\n* Naming should be as precise as possible when it comes to _code elements_.\r\n\r\n* \"Native\" _is_ an established term, but it's not really used in the official documentation, as far as I can tell, so the documentation could lead the way here (e.g., [`about_Parsing`](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_parsing?view=powershell-6) currently refers to \"executable programs\" in the context of discussing `--%`).\r\n\r\n* In the specific case at hand, the term \"external program\" (perhaps \"utility\" is too \"Unix-y\") or more broadly \"external\" to refer to functionality _outside of_ PowerShell avoids the ambiguity of \"native\" while still being concise and \"self-documenting\", so even those used to the term \"native\" should be able to infer its meaning.  \r\n(And perhaps some day \"external\" will become the predominantly used term - a guy can dream, can't he?)\r\n\r\n\r\n\r\n",
      "created_at": "2018-04-27T13:12:27Z",
      "updated_at": "2018-04-27T13:13:45Z"
    },
    {
      "author": "mikemaccana",
      "author_association": "NONE",
      "body": "@SteveL-MSFT Since there won't be a 6.3 - consider it for 7?",
      "created_at": "2019-04-06T21:59:32Z",
      "updated_at": "2019-04-06T21:59:32Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@mikemaccana I've renamed the 6.3-Consider milestone to 7.0-Consider",
      "created_at": "2019-04-07T01:48:43Z",
      "updated_at": "2019-04-07T01:48:43Z"
    },
    {
      "author": "vladimiry",
      "author_association": "NONE",
      "body": "Seems to be related information https://community.dynamics.com/nav/b/stefanodemiliani/archive/2018/02/28/running-microsoft-dynamics-nav-tasks-in-parallel-with-powershell (parallel / sequential commands execution).",
      "created_at": "2019-04-27T14:44:13Z",
      "updated_at": "2019-04-27T14:44:13Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@vladimiry Thanks, but this issue is about a concise, _success-conditional_ idiom for _sequencing_ commands; by contrast, your link is (primarily) about unconditional parallel execution via PowerShell workflows, which aren't supported in PowerShell Core.",
      "created_at": "2019-04-27T14:55:22Z",
      "updated_at": "2019-04-27T14:55:22Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "Please see https://github.com/PowerShell/PowerShell-RFC/pull/192",
      "created_at": "2019-06-12T20:47:54Z",
      "updated_at": "2019-06-12T20:47:54Z"
    },
    {
      "author": "Raffaello",
      "author_association": "NONE",
      "body": "in powershell ver 5.1 are still not present, which version of Powershell include these operators?",
      "created_at": "2022-01-15T11:06:35Z",
      "updated_at": "2022-01-15T11:06:35Z"
    },
    {
      "author": "kilasuit",
      "author_association": "COLLABORATOR",
      "body": "@Raffaello If you checked the PR that closed this you'd have seen it was added in for 7.0.0-preview5 - so it is in Powershell since the GA of v7.0.0",
      "created_at": "2022-01-15T11:11:05Z",
      "updated_at": "2022-01-15T11:11:05Z"
    }
  ],
  "created_at": "2017-03-02T21:01:00Z",
  "number": 3241,
  "state": "closed",
  "title": "Suggestion: implement Bash-style && and || control operators for chaining commands based on success / failure - short-circuiting Boolean execution-flow control operators",
  "updated_at": "2022-01-15T11:11:05Z"
}