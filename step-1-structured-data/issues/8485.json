{
  "_url": "https://github.com/PowerShell/PowerShell/issues/8485",
  "author": "markekraus",
  "body": "<!--\r\n\r\nFor Windows PowerShell 5.1 issues, suggestions, or feature requests please use the following link instead:\r\nWindows PowerShell [UserVoice](https://windowsserver.uservoice.com/forums/301869-powershell)\r\n\r\nThis repository is **ONLY** for PowerShell Core 6 issues.\r\n\r\n- Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\r\n- Search the existing issues.\r\n- Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\r\n- Refer to the [known issues](https://docs.microsoft.com/powershell/scripting/whats-new/known-issues-ps6?view=powershell-6).\r\n\r\n-->\r\n\r\nIt appears that when Set-Content sets a Newline at the end of the file, the new line is not also included in the content of -PassThru or in the content of `-OutVariable`.\r\n\r\nIMO, the output should be an exact match for the content actually placed in the file, including the appended newline.\r\n\r\n# Steps to reproduce\r\n\r\n```powershell\r\n$Path = 'c:\\temp\\testfile.txt'\r\n$Result = \"a\" | Set-Content -Encoding UTF8 -PassThru -OutVariable SetContent -Path $Path\r\n$FileContent = Get-Content -Raw -Path $Path\r\ndescribe \"Newline Parity\" {\r\n    It 'OutVariable should be the same as File Content' {\r\n        $SetContent[0] | Should -BeExactly $FileContent\r\n    }\r\n    It 'PassThru should be the same as FileContent' {\r\n        $Result | Should -BeExactly $FileContent\r\n    }\r\n}\r\n```\r\n\r\n# Expected behavior\r\n\r\n```none\r\nDescribing Newline Parity\r\n  [+] OutVariable should be the same as File Content 49ms\r\n  [+] PassThru should be the same as FileContent 46ms\r\n```\r\n\r\n# Actual behavior\r\n\r\n```none\r\n  [-] OutVariable should be the same as File Content 378ms\r\n    Expected strings to be the same, but they were different.\r\n    Expected length: 3\r\n    Actual length:   1\r\n    Strings differ at index 1.\r\n    Expected: 'a\\r\r\n    '\r\n    But was:  'a'\r\n    ------------^\r\n    3:         $SetContent[0] | Should -BeExactly $FileContent\r\n  [-] PassThru should be the same as FileContent 172ms\r\n    Expected strings to be the same, but they were different.\r\n    Expected length: 3\r\n    Actual length:   1\r\n    Strings differ at index 1.\r\n    Expected: 'a\\r\r\n    '\r\n    But was:  'a'\r\n    ------------^\r\n    6:         $Result | Should -BeExactly $FileContent\r\n```\r\n\r\n# Environment data\r\n\r\n<!-- provide the output of $PSVersionTable -->\r\n\r\n```none\r\nName                           Value\r\n----                           -----\r\nPSVersion                      6.1.0\r\nPSEdition                      Core\r\nGitCommitId                    6.1.0\r\nOS                             Microsoft Windows 10.0.16299\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Just to state what `-PassThru` is _currently_ doing:\r\n\r\nIt is  the _input objects_ that are being passed through, not the derived string representation sent to the output file:\r\n\r\n```powershell\r\nPS> (1..2 | Set-Content -PassThru t.txt).GetType().Name\r\nObject[]\r\n```\r\n\r\nI agree that it makes more sense for `-PassThru` to pass out the derived string representation, mirroring what is sent to the file.\r\n\r\n~~Ditto for `-OutVariable`, which currently seems to always produce an _empty_ `ArrayList`~~.\r\n`OutVariable` fills the specified variable only if `-PassThru` is also specified, thereby consistently reflecting the cmdlet's true output behavior - albeit always in the form of an `ArrayList`, unlike the direct output  (see #3154).\r\n",
      "created_at": "2018-12-19T03:16:51Z",
      "updated_at": "2018-12-20T04:09:36Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Taking a step back and looking at the use of `-PassThru` across cmdlets, via `gcm -ParameterName passthru  -type Cmdlet | % name`, tells me that only the following save-to-a-typically-new-file cmdlets support `-PassThru`:\r\n\r\n```none\r\nAdd-Content\r\nSet-Content\r\nExport-Alias\r\nNew-ModuleManifest\r\n```\r\n\r\nAmong these, only `New-ModuleManifest` - as a cmdlet that doesn't accept pipeline input - actually passes through the _file contents_ that is saved to the target file.\r\n\r\nThe others - surprisingly - essentially pass the _input_ through.\r\n\r\nArguably, however, it should be a `[System.IO.FileInfo]` object representing the target file _as a whole_ that should be passed through by these cmdlets, not the - transformed-to-text - _content_; after all, the file-info object is arguably the more interesting implicit output that these cmdlets produce.\r\n\r\n(By contrast, if you wanted to capture the _input_ to these cmdlets in a variable, use `[-PassThru] -OutVariable` in the _previous_ pipeline segment).\r\n\r\nThat said, this would be a bigger breaking change than the one proposed by this issue.\r\n\r\n\r\n",
      "created_at": "2018-12-20T04:23:25Z",
      "updated_at": "2018-12-20T04:23:25Z"
    },
    {
      "author": "UberKluger",
      "author_association": "NONE",
      "body": "(This comment was a KDR, i.e Knock Down Rebuild, check the edit history. Comment research can be a rabbit warren.)\r\n#### Observation\r\n(All testing on 5.1.18362.145)\r\n\r\nThe parameter name `-PassThru` would imply to me that a received object is \"passed through\" unaltered and this is indeed the case, despite being \"stringified\" for output to the file, if necessary. This means that the description in the documentation is actually misleading (wrong?). The passed through object does not \"represent\" the (stringified) content (written to the file). There is, however, some difference between an input object and the passed object. The passed object is actually a box (single element `[Object[]]`) containing the original input object. The apparent reason for this is that this box is used to provide several added NoteProperty members, without altering the passed object. They are:\r\n```\r\nPSChildName    NoteProperty          string PSChildName=<name of file>\r\nPSDrive        NoteProperty          PSDriveInfo PSDrive=<drive containing file>\r\nPSParentPath   NoteProperty          string PSParentPath=<full path of containing directory>\r\nPSPath         NoteProperty          string PSPath=<full path of file>\r\nPSProvider     NoteProperty          ProviderInfo PSProvider=Microsoft.PowerShell.Core\\FileSystem\r\nReadCount      NoteProperty          long ReadCount=1 # possibly counting objects in this array. always 1?\r\n```\r\nThis is not quite the [FileInfo] object that @mklement0 was suggesting but might still be useful, particularly if these object arrays are collected from several invocations of `Set-Content`, perhaps in `-OutVariable` (see below).\r\n\r\n#### Tests to demonstrate\r\n```\r\nPS > $pass123 = 1,2,3 | Set-Content test123.txt -PassThru -OutVariable out123\r\nPS > $pass123\r\n1\r\n2\r\n3\r\nPS > $pass123.GetType()\r\n\r\nIsPublic IsSerial Name                                     BaseType\r\n-------- -------- ----                                     --------\r\nTrue     True     Object[]                                 System.Array\r\n\r\nPS > $pass123.Length\r\n3\r\nPS > $pass123[0].GetType()\r\n\r\nIsPublic IsSerial Name                                     BaseType\r\n-------- -------- ----                                     --------\r\nTrue     True     Object[]                                 System.Array\r\n\r\nPS > $pass123[0].Length\r\n1\r\nPS > $pass123[0][0].GetType()\r\n\r\nIsPublic IsSerial Name                                     BaseType\r\n-------- -------- ----                                     --------\r\nTrue     True     Int32                                    System.ValueType\r\n\r\nPS > $pass123[0][0]\r\n1\r\nPS > $pass123[1][0]\r\n2\r\nPS > $out123.GetType()\r\n\r\nIsPublic IsSerial Name                                     BaseType\r\n-------- -------- ----                                     --------\r\nTrue     True     ArrayList                                System.Object\r\n\r\nPS > $out123.Count\r\n3\r\nPS > $out123[0].GetType()\r\n\r\nIsPublic IsSerial Name                                     BaseType\r\n-------- -------- ----                                     --------\r\nTrue     True     Object[]                                 System.Array\r\n\r\nPS > $out123[0].Length\r\n1\r\nPS > $out123[0][0].GetType()\r\n\r\nIsPublic IsSerial Name                                     BaseType\r\n-------- -------- ----                                     --------\r\nTrue     True     Int32                                    System.ValueType\r\n\r\nPS > $out123[0][0]\r\n1\r\nPS > $out123[1][0]\r\n2\r\nPS > Get-Member -InputObject $out123[0]\r\n# ... standard Object[] members up to and including ToString()\r\nToString       Method                string ToString()\r\nPSChildName    NoteProperty          string PSChildName=test123.txt\r\nPSDrive        NoteProperty          PSDriveInfo PSDrive=C\r\nPSParentPath   NoteProperty          string PSParentPath=C:\\Users\\XXXX\\xxxx\\yyy\r\nPSPath         NoteProperty          string PSPath=C:\\Users\\XXXX\\xxxx\\yyy\\test123.txt\r\nPSProvider     NoteProperty          ProviderInfo PSProvider=Microsoft.PowerShell.Core\\FileSystem\r\nReadCount      NoteProperty          long ReadCount=1\r\nItem           ParameterizedProperty System.Object IList.Item(int index) {get;set;}\r\n# ... standard Object[] members resume at Item()\r\n```\r\n\r\nIt would appear, however, that the passed (boxed) object is not the piped input object (as such) but whatever is bound to the `-Value` parameter. However, this is where (IMO) a bug manifests. Consider,\r\n```\r\nPS > Get-Content listoffiles.txt\r\ninitial.ini\r\nrunning.cfg\r\nresults.log\r\nerrors.lst\r\nPS > $scpass = Get-Content listoffiles.txt | ForEach { [PSCustomObject]@{ Path = $_ } } |\r\n>> Set-Content -PassThru -Value ([DateTime]::Now)\r\nPS > $scpass\r\n21/01/2022 11:15:14 AM\r\n21/01/2022 11:15:14 AM\r\n21/01/2022 11:15:14 AM\r\n21/01/2022 11:15:14 AM\r\n\r\nPS > $scpass[0][0].GetType().Name `\r\n# Multiple output so have pipeline output array containing single element boxing arrays of\r\nDateTime\r\nPS > Get-ChildItem\r\n\r\nMode                LastWriteTime         Length Name\r\n----                -------------         ------ ----\r\n-a----       21/01/2022  11:15 AM             24 errors.lst\r\n-a----       21/01/2022  11:15 AM             24 initial.ini\r\n-a----       21/01/2022  10:42 AM             51 listoffiles.txt\r\n-a----       21/01/2022  11:15 AM             24 results.log\r\n-a----       21/01/2022  11:15 AM             24 running.cfg\r\n\r\nPS > Get-Content * -Exclude listoffiles.txt\r\n21/01/2022 11:15:14 AM\r\n21/01/2022 11:15:14 AM\r\n21/01/2022 11:15:14 AM\r\n21/01/2022 11:15:14 AM\r\nPS > $scpass.PSPath # using member enumeration, expect different value for each output file \r\nC:\\Users\\XXXX\\xxxx\\yyy\\errors.lst\r\nC:\\Users\\XXXX\\xxxx\\yyy\\errors.lst\r\nC:\\Users\\XXXX\\xxxx\\yyy\\errors.lst\r\nC:\\Users\\XXXX\\xxxx\\yyy\\errors.lst\r\n```\r\nThis is probably due to `-Value` being evaluated only once but why is it the last piped object?\r\n```\r\nPS > [Object]::ReferenceEquals($scpass[0], $scpass[1])\r\nTrue\r\n```\r\nBecause there is only one `-Value` boxing array which is continually updated, the added members are the same objects in **ALL** the output objects and thus contain the *last* value assigned. This is the \"bug\". Even if the `-Value` boxed object is the same, a new box should be created whenever a new file is written. That way the relevant file information is not corrupted. When `-Value` is evaluated separately for each piped object, the expected result is obtained.\r\n```\r\nPS > $scpass = Get-Content listoffiles.txt | ForEach { Sleep 5; [PSCustomObject]@{ Value = [DateTime]::Now; Path = $_ } } | Set-Content -pass\r\nPS > $scpass | ForEach { \"{0,-40} {1} {2}\" -f $_.PSPath, $_[0].Value, $_[0].Path }\r\n\r\nC:\\Users\\XXXX\\xxxx\\yyy\\initial.ini       21/01/2022 11:35:24 AM initial.ini\r\nC:\\Users\\XXXX\\xxxx\\yyy\\running.cfg       21/01/2022 11:35:29 AM running.cfg\r\nC:\\Users\\XXXX\\xxxx\\yyy\\results.log       21/01/2022 11:35:34 AM results.log\r\nC:\\Users\\XXXX\\xxxx\\yyy\\errors.lst        21/01/2022 11:35:39 AM errors.lst\r\n```\r\nNote: for those trying these tests for themselves, you will notice that the contents of the files in the last example are not the stringified `DateTime` objects but the entire `[PSCutomObject]` or rather the stringified hash table representaion of it. This is due to another issue (not necessarily related to `Set-Content`) covered in  [SO70779930](https://stackoverflow.com/questions/70779930/set-content-value-parameter-treats-piped-object-as-valuefrompipeline-and-conve).\r\n#### Educational segment\r\nSome might be wondering about the OP testing when the `-OutVariable` and `$Result` contain an array of the passed object (the string \"a\"). In the first test, `$SetContent[0]` (possibly assumed to be the string itself) is a one element array containing the passed in string. It is enumerated by the pipeline, thereby passing the expected string. `$Result` is also the one element array since the `Set-Content` pipeline produced only one item (the array) and so did not return a result collection, just the one (single element array) item. Another question might be, \"If `$pass123` is an array of arrays, why did it enumerate as individual `Int32`?\" This is because\r\n```\r\nPS > $pass123\r\n```\r\nhas an implied `Out-Default` appended, so is actually\r\n```\r\nPS > $pass123 | Out-Default\r\n```\r\nThe pipeline first enumerates `$pass123` into 3 single element `Object[]`s which are passed to `Out-Default` which then itself enumerates the single element arrays producing the resultant `Int32`s. Note the difference with the following where there is no pipeline to perform the first enumeration, resulting in the 3 single element arrays being displayed,\r\n```\r\nPS > Out-Default -InputObject $pass123\r\n\r\nPSPath         : C:\\Users\\XXXX\\xxxx\\yyy\\test123.txt\r\nPSParentPath   : C:\\Users\\XXXX\\xxxx\\yyy\r\nPSChildName    : test123.txt\r\nPSDrive        : C\r\nPSProvider     : Microsoft.PowerShell.Core\\FileSystem\r\nReadCount      : 1\r\nLength         : 1\r\nLongLength     : 1\r\nRank           : 1\r\nSyncRoot       : {1}\r\nIsReadOnly     : False\r\nIsFixedSize    : True\r\nIsSynchronized : False\r\nCount          : 1\r\n# repeated 2 times with the only differences being\r\n\r\nSyncRoot       : {2}\r\n \r\nSyncRoot       : {3}\r\n```\r\n#### Mea culpa (with silver lining?)\r\nDespite making a fool of myself in another issue (#16733 actually raised by me), it did result in a workaround idea that might \"solve\" the problem mentioned here (wanting the pass through and `-OutVariable` to ***exactly*** match the written characters). To ensure that the passed object matches the saved content, the input object should also be a match for the saved content. By preformatting the input to `Set-Content` and then specifying `-NoNewline`, the passed through string would exactly match the file (albeit boxed in an `[Object[]]`). This would involve deliberately appending a new-line to the input string(s) or pre-stringified versions of the piped objects. This adds complexity but has the benefit of being able to choose between `\\n`, `\\r\\n` and `[System.Environment]::NewLine` as the line terminator. Thus the output could be either consistent with or independent of the underlying OS, whichever is desired. Note that this also leads to the realisation that changing `Set-Content` to pass through the actual contents written to the file would, beyond being a possible breaking change, mean that the passed objects could vary depending upon the underlying OS. Whether this is considered to be a bug or a feature would depend upon the intended use of the passed object.\r\n",
      "created_at": "2022-01-19T15:05:03Z",
      "updated_at": "2022-01-21T06:19:09Z"
    }
  ],
  "created_at": "2018-12-18T15:27:57Z",
  "labels": [
    "Issue-Bug",
    "WG-Cmdlets-Management"
  ],
  "number": 8485,
  "state": "open",
  "title": "Set-Content -PassThru and -OutVariable lack parity with file contents",
  "updated_at": "2022-01-21T06:19:09Z"
}