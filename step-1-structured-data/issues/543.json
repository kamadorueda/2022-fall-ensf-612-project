{
  "_url": "https://github.com/PowerShell/PowerShell/issues/543",
  "author": "vors",
  "body": "## BVT/DRT\n\nI made a run of our BVT/DRT tests with FullCLR bits built from GitHub sources.\nBVT/DRT are our P0 tests.\n\nResults\n\n```\nBVT: total=500 Pass=496 Fail=4 Error=0 Skip=0 Unspecified=0 Blocked=0 \nDRT: total=3248 Pass=3165 Fail=57 Error=8 Skip=4 Unspecified=14 Blocked=0 \nP0: total=5891 Pass=5715 Fail=90 Error=0 Skip=72 Unspecified=0 Blocked=14 \n\nStart time 2/12/2016 1:48:03 PM\nEnd time 2/12/2016 2:44:31 PM\nElapsed, 00:56:28.5847284\n```\n\nWe take a look to a couple of failures with @JamesWTruher and we observe legitimate problems so far.\n## Action plan\n-  **Goal**: get a parity in the test results with official windows build\n-  We should continue to analyse the rest of results and will provide a simple repro (in form of pester test) where possible. (see example below)\n-  We need to incorporate this regression suite in CI process and fix issues.\n-  At the same time, we should start to aligning our tests suites (FullPS, LinuxPS, CorePS). This regression test suite is a good starting point for it.\n-  Tests should contain info about their origin: a pointer to the original file in a comment.\n## Example\n\n``` powershell\nDescribe \"BVT/DRT Regression Suite\" {\n    # original test\n    # \\monad\\tests\\mae\\PowerShell\\tests\\Provider\\Providers\\Lite.Providers.FileSystemProvider.AlternateDataStreams.ps1\n    It 'can use alternate AlternateDataStreams with : syntax' {\n        $file = [IO.Path]::GetTempFilename()\n        Set-Content $file -Stream Stream1 \"World\"\n        cat \"${file}:Stream1\" | Should Be \"World\"\n    }\n}\n```\n",
  "closed_at": "2016-07-29T17:39:46Z",
  "comments": [
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "Would it make sense to create 'BVT/DRT' label for issues that have been found that way?\n",
      "created_at": "2016-02-13T03:15:20Z",
      "updated_at": "2016-02-13T03:15:20Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "Yes, I think so.\n\nCan I ask, what is the difference between \"failed\" and \"errored\"?\n\nAlso, would it be possible to get the test logs? I know the code changes made to monad better than anyone at this point, and could be of some use determining what caused some of the failures.\n",
      "created_at": "2016-02-13T03:17:13Z",
      "updated_at": "2016-02-13T03:17:13Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "Not quite sure about the difference.\n\nSo the problem is... it's not that easy :)\nHere are 90 errors that I was able to extract with @JamesWTruher \nhttps://github.com/PowerShell/Internal-PowerShellTeam-Tools/blob/master/WTT/Get-WttErrorFromLog.ps1\n\nThere could be errors that script cannot parse out and can be found only thru UI. On the other hand, some of the tests are reported more then once, so overall it's a good start.\n\n```\n\n\nTitle     : Error occurred in test script 'C:\\PowerShellTests\\PowerShell\\tests\\Commands\\Cmdlets\\Clipboard.Tests.ps1'-0\nRepro     : Invoke-Pester C:\\PowerShellTests\\PowerShell\\tests\\Commands\\Cmdlets\\Clipboard.Tests.ps1\nErrorText : This command cannot be run due to the error: The system cannot find the file specified. Error occurred in test script 'C:\\PowerShellTests\\PowerShell\\tests\\Commands\\Cmdlets\\Clipboard.Tests.ps1' \n            Failed at <ScriptBlock>, C:\\PowerShellTests\\PowerShell\\tests\\Commands\\Cmdlets\\Clipboard.Tests.ps1: line 184\n\nTitle     : MeasureTextCombinationTest\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : Microsoft.VS.TTest.TestFailureException: Test Failed: 'Flags: TestCharacter.Command returned 0.'    at Microsoft.VS.TTest.Validate.ThrowTestFailureException(String format, Object[] args)    at \n            Microsoft.Test.Management.Automation.MeasureObjectTests.MeasureTextHelper(TestMeasureText flags, String propertyName, Boolean testNoPropertyFound)    at \n            Microsoft.Test.Management.Automation.MeasureObjectTests.MeasureTextCombinationTest()\n\nTitle     : TestGetFormatDataAndExportFormatData\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : Microsoft.VS.TTest.TestFailureException: There were error records output from the script. Id: Microsoft.PowerShell.Commands.WriteErrorException,Assert, Id: ScriptHalted  ---> \n            Microsoft.PowerShell.Commands.WriteErrorException: System.Diagnostics.Process should have four controls '2' does not equal '4'    --- End of inner exception stack trace ---    at \n            Microsoft.Test.Management.Automation.ScriptTestFixture.ExecuteScriptFile(String scriptPath) Parameter 0: C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\utscripts\\Commands\\TestGetFormatDataAndExportFormatData.ps1 \n            Running script: C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\utscripts\\Commands\\TestGetFormatDataAndExportFormatData.ps1\n\nTitle     : ExposeBug1011549\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : System.Management.Automation.CmdletInvocationException: Cannot process argument because the value of argument \"name\" is not valid. Change the value of the \"name\" argument and run the operation again. ---> \n            System.Management.Automation.PSArgumentException: Cannot process argument because the value of argument \"name\" is not valid. Change the value of the \"name\" argument and run the operation again.    at \n            System.Management.Automation.CmdletInfo..ctor(String name, Type implementingType, String helpFile, PSSnapInInfo PSSnapin, ExecutionContext context)    at \n            System.Management.Automation.Internal.ModuleUtils.<GetMatchingCommands>d__7.MoveNext()    at Microsoft.PowerShell.Commands.GetCommandCommand.AccumulateMatchingCommands(IEnumerable`1 commandNames)    at \n            Microsoft.PowerShell.Commands.GetCommandCommand.AccumulateMatchingCmdlets()    at Microsoft.PowerShell.Commands.GetCommandCommand.ProcessRecord()    at System.Management.Automation.Cmdlet.DoProcessRecord()    at \n            System.Management.Automation.CommandProcessor.ProcessRecord()    --- End of inner exception stack trace ---    at System.Management.Automation.Runspaces.PipelineBase.Invoke(IEnumerable input)    at \n            Microsoft.Test.Management.Automation.MonadTestHelper.ExecutePipeline(Pipeline pipe, Object[] input, PSObject[]& output, PSObject[]& error)    at \n            Microsoft.Test.Management.Automation.CommandDiscoverySingleShellTest.ExposeBug1011549()\n\nTitle     : ExposeBug1018233\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : System.Management.Automation.CmdletInvocationException: Cannot process argument because the value of argument \"name\" is not valid. Change the value of the \"name\" argument and run the operation again. ---> \n            System.Management.Automation.PSArgumentException: Cannot process argument because the value of argument \"name\" is not valid. Change the value of the \"name\" argument and run the operation again.    at \n            System.Management.Automation.CmdletInfo..ctor(String name, Type implementingType, String helpFile, PSSnapInInfo PSSnapin, ExecutionContext context)    at \n            System.Management.Automation.Internal.ModuleUtils.<GetMatchingCommands>d__7.MoveNext()    at Microsoft.PowerShell.Commands.GetCommandCommand.AccumulateMatchingCommands(IEnumerable`1 commandNames)    at \n            Microsoft.PowerShell.Commands.GetCommandCommand.AccumulateMatchingCommands()    at Microsoft.PowerShell.Commands.GetCommandCommand.ProcessRecord()    at System.Management.Automation.Cmdlet.DoProcessRecord()    at \n            System.Management.Automation.CommandProcessor.ProcessRecord()    --- End of inner exception stack trace ---    at System.Management.Automation.Runspaces.PipelineBase.Invoke(IEnumerable input)    at \n            Microsoft.Test.Management.Automation.MonadTestHelper.ExecutePipeline(Pipeline pipe, Object[] input, PSObject[]& output, PSObject[]& error)    at \n            Microsoft.Test.Management.Automation.CommandDiscoverySingleShellTest.ExposeBug1018233()\n\nTitle     : ExposeLookupAliasBug1015822\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : System.Management.Automation.CmdletInvocationException: Cannot process argument because the value of argument \"name\" is not valid. Change the value of the \"name\" argument and run the operation again. ---> \n            System.Management.Automation.PSArgumentException: Cannot process argument because the value of argument \"name\" is not valid. Change the value of the \"name\" argument and run the operation again.    at \n            System.Management.Automation.CmdletInfo..ctor(String name, Type implementingType, String helpFile, PSSnapInInfo PSSnapin, ExecutionContext context)    at \n            System.Management.Automation.Internal.ModuleUtils.<GetMatchingCommands>d__7.MoveNext()    at Microsoft.PowerShell.Commands.GetCommandCommand.AccumulateMatchingCommands(IEnumerable`1 commandNames)    at \n            Microsoft.PowerShell.Commands.GetCommandCommand.AccumulateMatchingCommands()    at Microsoft.PowerShell.Commands.GetCommandCommand.ProcessRecord()    at System.Management.Automation.Cmdlet.DoProcessRecord()    at \n            System.Management.Automation.CommandProcessor.ProcessRecord()    --- End of inner exception stack trace ---    at System.Management.Automation.Runspaces.PipelineBase.Invoke(IEnumerable input)    at \n            Microsoft.Test.Management.Automation.MonadTestHelper.ExecutePipeline(Pipeline pipe, Object[] input, PSObject[]& output, PSObject[]& error)    at \n            Microsoft.Test.Management.Automation.CommandDiscoverySingleShellTest.ExposeLookupAliasBug1015822()\n\nTitle     : ExposeLookupScriptBug1015822\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : System.Management.Automation.CmdletInvocationException: Cannot process argument because the value of argument \"name\" is not valid. Change the value of the \"name\" argument and run the operation again. ---> \n            System.Management.Automation.PSArgumentException: Cannot process argument because the value of argument \"name\" is not valid. Change the value of the \"name\" argument and run the operation again.    at \n            System.Management.Automation.CmdletInfo..ctor(String name, Type implementingType, String helpFile, PSSnapInInfo PSSnapin, ExecutionContext context)    at \n            System.Management.Automation.Internal.ModuleUtils.<GetMatchingCommands>d__7.MoveNext()    at Microsoft.PowerShell.Commands.GetCommandCommand.AccumulateMatchingCommands(IEnumerable`1 commandNames)    at \n            Microsoft.PowerShell.Commands.GetCommandCommand.AccumulateMatchingCommands()    at Microsoft.PowerShell.Commands.GetCommandCommand.ProcessRecord()    at System.Management.Automation.Cmdlet.DoProcessRecord()    at \n            System.Management.Automation.CommandProcessor.ProcessRecord()    --- End of inner exception stack trace ---    at System.Management.Automation.Runspaces.PipelineBase.Invoke(IEnumerable input)    at \n            Microsoft.Test.Management.Automation.MonadTestHelper.ExecutePipeline(Pipeline pipe, Object[] input, PSObject[]& output, PSObject[]& error)    at \n            Microsoft.Test.Management.Automation.CommandDiscoverySingleShellTest.ExposeLookupScriptBug1015822()\n\nTitle     : Bug259687\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : Microsoft.VS.TTest.TestFailureException: There were error records output from the script. Id: Argument,Microsoft.PowerShell.Commands.GetCommandCommand  ---> System.Management.Automation.PSArgumentException: Cannot process \n            argument because the value of argument \"name\" is not valid. Change the value of the \"name\" argument and run the operation again.    at System.Management.Automation.CmdletInfo..ctor(String name, Type implementingType, String \n            helpFile, PSSnapInInfo PSSnapin, ExecutionContext context)    at System.Management.Automation.Internal.ModuleUtils.<GetMatchingCommands>d__7.MoveNext()    at \n            Microsoft.PowerShell.Commands.GetCommandCommand.AccumulateMatchingCommands(IEnumerable`1 commandNames)    at Microsoft.PowerShell.Commands.GetCommandCommand.AccumulateMatchingCommands()    at \n            Microsoft.PowerShell.Commands.GetCommandCommand.ProcessRecord()    at System.Management.Automation.Cmdlet.DoProcessRecord()    at System.Management.Automation.CommandProcessor.ProcessRecord()    --- End of inner exception \n            stack trace ---    at Microsoft.Test.Management.Automation.ScriptTestFixture.ExecuteScriptFile(String scriptPath) Parameter 0: C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\utscripts\\InitialSessionState\\Bug259687.ps1 \n            Running script: C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\utscripts\\InitialSessionState\\Bug259687.ps1\n\nTitle     : ClearHistoryWithValidID\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : System.Management.Automation.CmdletInvocationException: Cannot process argument because the value of argument \"name\" is not valid. Change the value of the \"name\" argument and run the operation again. ---> \n            System.Management.Automation.PSArgumentException: Cannot process argument because the value of argument \"name\" is not valid. Change the value of the \"name\" argument and run the operation again.    at \n            System.Management.Automation.CmdletInfo..ctor(String name, Type implementingType, String helpFile, PSSnapInInfo PSSnapin, ExecutionContext context)    at \n            System.Management.Automation.Internal.ModuleUtils.<GetMatchingCommands>d__7.MoveNext()    at Microsoft.PowerShell.Commands.GetCommandCommand.AccumulateMatchingCommands(IEnumerable`1 commandNames)    at \n            Microsoft.PowerShell.Commands.GetCommandCommand.AccumulateMatchingCmdlets()    at Microsoft.PowerShell.Commands.GetCommandCommand.ProcessRecord()    at System.Management.Automation.Cmdlet.DoProcessRecord()    at \n            System.Management.Automation.CommandProcessor.ProcessRecord()    --- End of inner exception stack trace ---    at System.Management.Automation.Runspaces.PipelineBase.Invoke(IEnumerable input)    at \n            Microsoft.PowerShell.Test.SDK.SdkRunspace.ExecuteScript(String cmd, Object[] pipelineInput, Boolean addToHistory)    at Microsoft.Test.Management.Automation.ClearHistoryDRTTests.RunMultipleCommands()    at \n            Microsoft.Test.Management.Automation.ClearHistoryDRTTests.ClearHistoryWithValidID()\n\nTitle     : ClearHistoryWithValidCount\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : System.Management.Automation.CmdletInvocationException: Cannot process argument because the value of argument \"name\" is not valid. Change the value of the \"name\" argument and run the operation again. ---> \n            System.Management.Automation.PSArgumentException: Cannot process argument because the value of argument \"name\" is not valid. Change the value of the \"name\" argument and run the operation again.    at \n            System.Management.Automation.CmdletInfo..ctor(String name, Type implementingType, String helpFile, PSSnapInInfo PSSnapin, ExecutionContext context)    at \n            System.Management.Automation.Internal.ModuleUtils.<GetMatchingCommands>d__7.MoveNext()    at Microsoft.PowerShell.Commands.GetCommandCommand.AccumulateMatchingCommands(IEnumerable`1 commandNames)    at \n            Microsoft.PowerShell.Commands.GetCommandCommand.AccumulateMatchingCmdlets()    at Microsoft.PowerShell.Commands.GetCommandCommand.ProcessRecord()    at System.Management.Automation.Cmdlet.DoProcessRecord()    at \n            System.Management.Automation.CommandProcessor.ProcessRecord()    --- End of inner exception stack trace ---    at System.Management.Automation.Runspaces.PipelineBase.Invoke(IEnumerable input)    at \n            Microsoft.PowerShell.Test.SDK.SdkRunspace.ExecuteScript(String cmd, Object[] pipelineInput, Boolean addToHistory)    at Microsoft.Test.Management.Automation.ClearHistoryDRTTests.RunMultipleCommands()    at \n            Microsoft.Test.Management.Automation.ClearHistoryDRTTests.ClearHistoryWithValidCount()\n\nTitle     : ClearHistoryWithValidCommandLine\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : System.Management.Automation.CmdletInvocationException: Cannot process argument because the value of argument \"name\" is not valid. Change the value of the \"name\" argument and run the operation again. ---> \n            System.Management.Automation.PSArgumentException: Cannot process argument because the value of argument \"name\" is not valid. Change the value of the \"name\" argument and run the operation again.    at \n            System.Management.Automation.CmdletInfo..ctor(String name, Type implementingType, String helpFile, PSSnapInInfo PSSnapin, ExecutionContext context)    at \n            System.Management.Automation.Internal.ModuleUtils.<GetMatchingCommands>d__7.MoveNext()    at Microsoft.PowerShell.Commands.GetCommandCommand.AccumulateMatchingCommands(IEnumerable`1 commandNames)    at \n            Microsoft.PowerShell.Commands.GetCommandCommand.AccumulateMatchingCmdlets()    at Microsoft.PowerShell.Commands.GetCommandCommand.ProcessRecord()    at System.Management.Automation.Cmdlet.DoProcessRecord()    at \n            System.Management.Automation.CommandProcessor.ProcessRecord()    --- End of inner exception stack trace ---    at System.Management.Automation.Runspaces.PipelineBase.Invoke(IEnumerable input)    at \n            Microsoft.PowerShell.Test.SDK.SdkRunspace.ExecuteScript(String cmd, Object[] pipelineInput, Boolean addToHistory)    at Microsoft.Test.Management.Automation.ClearHistoryDRTTests.RunMultipleCommands()    at \n            Microsoft.Test.Management.Automation.ClearHistoryDRTTests.ClearHistoryWithValidCommandLine()\n\nTitle     : Error occurred in Describe block-0\nRepro     : Invoke-Pester C:\\PowerShellTests\\PowerShell\\tests\\Engine\\ExtensibleTypeSystem\\COM.Tests.ps1\nErrorText : {Retrieving the COM class factory for component with CLSID {795A1D7E-950A-4740-BD3D-5447A4A36606} failed due to the following error: 80040154 Class not registered (Exception from HRESULT: 0x80040154 (REGDB_E_CLASSNOTREG)). \n            Error occurred in Describe block \n            Failed at C:\\PowerShellTests\\PowerShell\\tests\\Engine\\ExtensibleTypeSystem\\COM.Tests.ps1:177 char:16, Retrieving the COM class factory for component with CLSID {E7F913FE-F9B9-45E0-9045-97F7C9FCFCB0} failed due to the \n            following error: 80040154 Class not registered (Exception from HRESULT: 0x80040154 (REGDB_E_CLASSNOTREG)). Error occurred in Describe block \n            Failed at C:\\PowerShellTests\\PowerShell\\tests\\Engine\\ExtensibleTypeSystem\\COM.Tests.ps1:255 char:16, Retrieving the COM class factory for component with CLSID {A8F62558-D730-42F5-9F8C-5B63BAB8D62C} failed due to the \n            following error: 80040154 Class not registered (Exception from HRESULT: 0x80040154 (REGDB_E_CLASSNOTREG)). Error occurred in Describe block \n            Failed at C:\\PowerShellTests\\PowerShell\\tests\\Engine\\ExtensibleTypeSystem\\COM.Tests.ps1:489 char:14}\n\nTitle     : Error occurred in Describe block-0\nRepro     : Invoke-Pester C:\\PowerShellTests\\PowerShell\\tests\\Engine\\ExtensibleTypeSystem\\COM.Tests.ps1\nErrorText : {Retrieving the COM class factory for component with CLSID {795A1D7E-950A-4740-BD3D-5447A4A36606} failed due to the following error: 80040154 Class not registered (Exception from HRESULT: 0x80040154 (REGDB_E_CLASSNOTREG)). \n            Error occurred in Describe block \n            Failed at C:\\PowerShellTests\\PowerShell\\tests\\Engine\\ExtensibleTypeSystem\\COM.Tests.ps1:177 char:16, Retrieving the COM class factory for component with CLSID {E7F913FE-F9B9-45E0-9045-97F7C9FCFCB0} failed due to the \n            following error: 80040154 Class not registered (Exception from HRESULT: 0x80040154 (REGDB_E_CLASSNOTREG)). Error occurred in Describe block \n            Failed at C:\\PowerShellTests\\PowerShell\\tests\\Engine\\ExtensibleTypeSystem\\COM.Tests.ps1:255 char:16, Retrieving the COM class factory for component with CLSID {A8F62558-D730-42F5-9F8C-5B63BAB8D62C} failed due to the \n            following error: 80040154 Class not registered (Exception from HRESULT: 0x80040154 (REGDB_E_CLASSNOTREG)). Error occurred in Describe block \n            Failed at C:\\PowerShellTests\\PowerShell\\tests\\Engine\\ExtensibleTypeSystem\\COM.Tests.ps1:489 char:14}\n\nTitle     : Error occurred in Describe block-0\nRepro     : Invoke-Pester C:\\PowerShellTests\\PowerShell\\tests\\Engine\\ExtensibleTypeSystem\\COM.Tests.ps1\nErrorText : {Retrieving the COM class factory for component with CLSID {795A1D7E-950A-4740-BD3D-5447A4A36606} failed due to the following error: 80040154 Class not registered (Exception from HRESULT: 0x80040154 (REGDB_E_CLASSNOTREG)). \n            Error occurred in Describe block \n            Failed at C:\\PowerShellTests\\PowerShell\\tests\\Engine\\ExtensibleTypeSystem\\COM.Tests.ps1:177 char:16, Retrieving the COM class factory for component with CLSID {E7F913FE-F9B9-45E0-9045-97F7C9FCFCB0} failed due to the \n            following error: 80040154 Class not registered (Exception from HRESULT: 0x80040154 (REGDB_E_CLASSNOTREG)). Error occurred in Describe block \n            Failed at C:\\PowerShellTests\\PowerShell\\tests\\Engine\\ExtensibleTypeSystem\\COM.Tests.ps1:255 char:16, Retrieving the COM class factory for component with CLSID {A8F62558-D730-42F5-9F8C-5B63BAB8D62C} failed due to the \n            following error: 80040154 Class not registered (Exception from HRESULT: 0x80040154 (REGDB_E_CLASSNOTREG)). Error occurred in Describe block \n            Failed at C:\\PowerShellTests\\PowerShell\\tests\\Engine\\ExtensibleTypeSystem\\COM.Tests.ps1:489 char:14}\n\nTitle     : CmsMessageCommandsCore\nRepro     : .\\runlite -suite Instrumentation.Logging.ProtectedEventLogging -pri  -test CmsMessageCommandsCore\nErrorText : Exception calling \"Invoke\" with \"0\" argument(s): \"The term 'Protect-CmsMessage' is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was \n            included, verify that the path is correct and try again.\" System.Management.Automation.MethodInvocationException: Exception calling \"Invoke\" with \"0\" argument(s): \"The term 'Protect-CmsMessage' is not recognized as the name \n            of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again.\" ---> System.Management.Automation.CommandNotFoundException: \n            The term 'Protect-CmsMessage' is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again.  \n              at System.Management.Automation.Runspaces.PipelineBase.Invoke(IEnumerable input)    at System.Management.Automation.Runspaces.Pipeline.Invoke()    at CallSite.Target(Closure , CallSite , Object )    --- End of inner \n            exception stack trace ---    at System.Management.Automation.ExceptionHandlingOps.CheckActionPreference(FunctionContext funcContext, Exception exception)    at \n            System.Management.Automation.Interpreter.ActionCallInstruction`2.Run(InterpretedFrame frame)    at System.Management.Automation.Interpreter.EnterTryCatchFinallyInstruction.Run(InterpretedFrame frame)    at \n            System.Management.Automation.Interpreter.EnterTryCatchFinallyInstruction.Run(InterpretedFrame frame)\n\nTitle     : MessageRecipientByCert\nRepro     : .\\runlite -suite Instrumentation.Logging.ProtectedEventLogging -pri  -test MessageRecipientByCert\nErrorText : Exception calling \"Invoke\" with \"0\" argument(s): \"The term 'Get-PfxCertificate' is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was \n            included, verify that the path is correct and try again.\" System.Management.Automation.MethodInvocationException: Exception calling \"Invoke\" with \"0\" argument(s): \"The term 'Get-PfxCertificate' is not recognized as the name \n            of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again.\" ---> System.Management.Automation.CommandNotFoundException: \n            The term 'Get-PfxCertificate' is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again.  \n              at System.Management.Automation.Runspaces.PipelineBase.Invoke(IEnumerable input)    at System.Management.Automation.Runspaces.Pipeline.Invoke()    at CallSite.Target(Closure , CallSite , Object )    --- End of inner \n            exception stack trace ---    at System.Management.Automation.ExceptionHandlingOps.CheckActionPreference(FunctionContext funcContext, Exception exception)    at \n            System.Management.Automation.Interpreter.ActionCallInstruction`2.Run(InterpretedFrame frame)    at System.Management.Automation.Interpreter.EnterTryCatchFinallyInstruction.Run(InterpretedFrame frame)    at \n            System.Management.Automation.Interpreter.EnterTryCatchFinallyInstruction.Run(InterpretedFrame frame)\n\nTitle     : InvokeScriptWithRequiresModule-0\nRepro     : Invoke-Pester C:\\PowerShellTests\\PowerShell\\tests\\Engine\\Modules\\Engine.Modules.Enhancements.Tests.ps1\nErrorText : Module enhancement expect no error displayed. See failure information:  InvokeScriptWithRequiresModule \n            Failed at line: 801 in C:\\PowerShellTests\\PowerShell\\tests\\Engine\\Modules\\Engine.Modules.Enhancements.Tests.ps1\n\nTitle     : AliasAttributeTestForCmdletAdvFnAndWorkflow-0\nRepro     : Invoke-Pester C:\\PowerShellTests\\PowerShell\\tests\\Engine\\Modules\\Engine.Modules.Enhancements.Tests.ps1\nErrorText : \n            Expected value was {}, but should not have been the same AliasAttributeTestForCmdletAdvFnAndWorkflow \n            Failed at line: 1300 in C:\\PowerShellTests\\PowerShell\\tests\\Engine\\Modules\\Engine.Modules.Enhancements.Tests.ps1 1300:         $gmoResult | should not be $null\n\nTitle     : Error occurred in test script 'C:\\PowerShellTests\\PowerShell\\tests\\Engine\\Modules\\Followup.Tests.ps1'-0\nRepro     : Invoke-Pester C:\\PowerShellTests\\PowerShell\\tests\\Engine\\Modules\\Followup.Tests.ps1\nErrorText : Cannot bind argument to parameter 'Path' because it is null. Error occurred in test script 'C:\\PowerShellTests\\PowerShell\\tests\\Engine\\Modules\\Followup.Tests.ps1' \n            Failed at <ScriptBlock>, C:\\PowerShellTests\\PowerShell\\tests\\Engine\\Modules\\Followup.Tests.ps1: line 17\n\nTitle     : Blue91339GetAllCommandsFailsWithWFAsRootmodule\nRepro     : .\\runlite -suite Engine.Modules.TestFollowup -pri  -test Blue91339GetAllCommandsFailsWithWFAsRootmodule\nErrorText : Windows PowerShell Workflow is not supported in a Windows PowerShell x86-based console. Open a Windows PowerShell x64-based console, and then try again. System.NotSupportedException: Windows PowerShell Workflow is not \n            supported in a Windows PowerShell x86-based console. Open a Windows PowerShell x64-based console, and then try again.    at \n            System.Management.Automation.Utils.GetAstToWorkflowConverterAndEnsureWorkflowModuleLoaded(ExecutionContext context)    at System.Management.Automation.FunctionOps.DefineWorkflows(ExecutionContext context, ScriptBlockAst \n            scriptBlockAst)\n\nTitle     : Verifies Information stream on workflow-0\nRepro     : Invoke-Pester C:\\PowerShellTests\\PowerShell\\tests\\Engine\\Other\\Pester.Engine.Other.InformationStream.Tests.ps1\nErrorText : Windows PowerShell Workflow is not supported in a Windows PowerShell x86-based console. Open a Windows PowerShell x64-based console, and then try again. Verifies Information stream on workflow \n            Failed at line: 53 in C:\\PowerShellTests\\PowerShell\\tests\\Engine\\Other\\Pester.Engine.Other.InformationStream.Tests.ps1\n\nTitle     : Verifies InformationVariable in workflow compilation-0\nRepro     : Invoke-Pester C:\\PowerShellTests\\PowerShell\\tests\\Engine\\Other\\Pester.Engine.Other.InformationStream.Tests.ps1\nErrorText : Windows PowerShell Workflow is not supported in a Windows PowerShell x86-based console. Open a Windows PowerShell x64-based console, and then try again. Verifies InformationVariable in workflow compilation \n            Failed at line: 69 in C:\\PowerShellTests\\PowerShell\\tests\\Engine\\Other\\Pester.Engine.Other.InformationStream.Tests.ps1\n\nTitle     : LoadFromHomeDirDefault\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : Microsoft.VS.TTest.TestFailureException: did not load module Test Failed: '1' expected, '0' actual.    at Microsoft.VS.TTest.Validate.ThrowTestFailureException(Object actual, Object expected, String message, Object[] args)  \n              at Microsoft.VS.TTest.Validate.AssertEquals[T](T actual, T expected, String format, Object[] args)    at Microsoft.Test.Management.Automation.ModulesAndPackagesTests.LoadFromHomeDirDefault()\n\nTitle     : CreateRunspaceValidHostValidConfigurationSuccess\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : Microsoft.VS.TTest.TestFailureException: get-command get-PfxCertificate -Type Cmdlet should return exactly 1 result! Test Failed: '1' expected, '0' actual.    at Microsoft.VS.TTest.Validate.ThrowTestFailureException(Object \n            actual, Object expected, String message, Object[] args)    at Microsoft.VS.TTest.Validate.AssertEquals[T](T actual, T expected, String format, Object[] args)    at \n            Microsoft.Test.Management.Automation.RunspaceFactoryTests.VerifyCmdletsForRunspace(RunspaceInvoke rspInvoke, ReadOnlyCollection`1 cmdlets)    at \n            Microsoft.Test.Management.Automation.RunspaceFactoryTests.VerifySingleShellRunspaceBeforeOpen(Runspace rsp)    at Microsoft.Test.Management.Automation.RunspaceFactoryTests.CreateRunspaceValidHostValidConfigurationSuccess()\n\nTitle     : ObjectParameters\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : Microsoft.VS.TTest.TestFailureException: There were error records output from the script. Id: NoCOMClassIdentified,Microsoft.PowerShell.Commands.NewObjectCommand, Id: NullArray  ---> \n            System.Management.Automation.RemoteException: Retrieving the COM class factory for component with CLSID {795A1D7E-950A-4740-BD3D-5447A4A36606} failed due to the following error: 80040154 Class not registered (Exception from \n            HRESULT: 0x80040154 (REGDB_E_CLASSNOTREG)).    --- End of inner exception stack trace ---    at Microsoft.Test.Management.Automation.ScriptTestFixture.ExecuteScriptFile(String scriptPath) Parameter 0: \n            C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\utscripts\\COM\\ObjectParameters.ps1 Running script: C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\utscripts\\COM\\ObjectParameters.ps1\n\nTitle     : winblue_191746_DSCModulePath\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : Microsoft.VS.TTest.TestFailureException: There were error records output from the script. Id: Microsoft.PowerShell.Commands.WriteErrorException,Assert, Id: ScriptHalted  ---> \n            Microsoft.PowerShell.Commands.WriteErrorException: The PSModulePath should contain '%ProgramFiles%\\WindowsPowerShell\\Modules' unless the user explicitly changes the value    --- End of inner exception stack trace ---    at \n            Microsoft.Test.Management.Automation.ScriptTestFixture.ExecuteScriptFile(String scriptPath) Parameter 0: C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\utscripts\\Modules\\winblue_191746_DSCModulePath.ps1 Running \n            script: C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\utscripts\\Modules\\winblue_191746_DSCModulePath.ps1\n\nTitle     : winblue_71908_HelpInfoUriForRemoteModule\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : Microsoft.VS.TTest.TestFailureException: There were error records output from the script. Id: CommandNotFoundException,Microsoft.PowerShell.Commands.ImportModuleCommand, Id: \n            Microsoft.PowerShell.Commands.WriteErrorException,Assert, Id: ScriptHalted  ---> System.InvalidOperationException: Failed to generate proxies for remote module 'w1tpshys.wzy'.  The term 'Export-PSSession' is not recognized \n            as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again. ---> \n            System.Management.Automation.CommandNotFoundException: The term 'Export-PSSession' is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was \n            included, verify that the path is correct and try again.    at System.Management.Automation.Runspaces.PipelineBase.Invoke(IEnumerable input)    at System.Management.Automation.Runspaces.Pipeline.Invoke()    at \n            System.Management.Automation.PowerShell.Worker.ConstructPipelineAndDoWork(Runspace rs, Boolean performSyncInvoke)    at System.Management.Automation.PowerShell.CoreInvokeHelper[TInput,TOutput](PSDataCollection`1 input, \n            PSDataCollection`1 output, PSInvocationSettings settings)    at System.Management.Automation.PowerShell.CoreInvoke[TInput,TOutput](PSDataCollection`1 input, PSDataCollection`1 output, PSInvocationSettings settings)    at \n            System.Management.Automation.PowerShell.CoreInvoke[TOutput](IEnumerable input, PSDataCollection`1 output, PSInvocationSettings settings)    at System.Management.Automation.PowerShell.Invoke[T](IEnumerable input, IList`1 \n            output, PSInvocationSettings settings)    at System.Management.Automation.PowerShell.Invoke[T](IEnumerable input, PSInvocationSettings settings)    at \n            System.Management.Automation.RemoteDiscoveryHelper.<InvokeNestedPowerShell>d__5.MoveNext()    at System.Management.Automation.RemoteDiscoveryHelper.<EnumerateWithCatch>d__12`1.MoveNext()    --- End of inner exception stack \n            trace ---    --- End of inner exception stack trace ---    at Microsoft.Test.Management.Automation.ScriptTestFixture.ExecuteScriptFile(String scriptPath) Parameter 0: \n            C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\utscripts\\Modules\\winblue_71908_HelpInfoUriForRemoteModule.ps1 Running script: \n            C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\utscripts\\Modules\\winblue_71908_HelpInfoUriForRemoteModule.ps1\n\nTitle     : remoteDiscovery-psSession-cimModule\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : Microsoft.VS.TTest.TestFailureException: There were error records output from the script. Id: CommandNotFoundException,Microsoft.PowerShell.Commands.ImportModuleCommand, Id: \n            Microsoft.PowerShell.Commands.WriteErrorException,Assert, Id: ScriptHalted  ---> System.InvalidOperationException: Failed to generate proxies for remote module 'remoteDiscoveryTest_CimModule'.  The term 'Export-PSSession' \n            is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again. ---> \n            System.Management.Automation.CommandNotFoundException: The term 'Export-PSSession' is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was \n            included, verify that the path is correct and try again.    at System.Management.Automation.Runspaces.PipelineBase.Invoke(IEnumerable input)    at System.Management.Automation.Runspaces.Pipeline.Invoke()    at \n            System.Management.Automation.PowerShell.Worker.ConstructPipelineAndDoWork(Runspace rs, Boolean performSyncInvoke)    at System.Management.Automation.PowerShell.CoreInvokeHelper[TInput,TOutput](PSDataCollection`1 input, \n            PSDataCollection`1 output, PSInvocationSettings settings)    at System.Management.Automation.PowerShell.CoreInvoke[TInput,TOutput](PSDataCollection`1 input, PSDataCollection`1 output, PSInvocationSettings settings)    at \n            System.Management.Automation.PowerShell.CoreInvoke[TOutput](IEnumerable input, PSDataCollection`1 output, PSInvocationSettings settings)    at System.Management.Automation.PowerShell.Invoke[T](IEnumerable input, IList`1 \n            output, PSInvocationSettings settings)    at System.Management.Automation.PowerShell.Invoke[T](IEnumerable input, PSInvocationSettings settings)    at \n            System.Management.Automation.RemoteDiscoveryHelper.<InvokeNestedPowerShell>d__5.MoveNext()    at System.Management.Automation.RemoteDiscoveryHelper.<EnumerateWithCatch>d__12`1.MoveNext()    --- End of inner exception stack \n            trace ---    --- End of inner exception stack trace ---    at Microsoft.Test.Management.Automation.ScriptTestFixture.ExecuteScriptFile(String scriptPath) Parameter 0: \n            C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\utscripts\\RemoteDiscovery\\remoteDiscovery-psSession-cimModule.ps1 Running script: \n            C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\utscripts\\RemoteDiscovery\\remoteDiscovery-psSession-cimModule.ps1\n\nTitle     : remoteDiscovery-psSession-psModule\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : Microsoft.VS.TTest.TestFailureException: There were error records output from the script. Id: CommandNotFoundException,Microsoft.PowerShell.Commands.ImportModuleCommand, Id: \n            Microsoft.PowerShell.Commands.WriteErrorException,Assert, Id: ScriptHalted  ---> System.InvalidOperationException: Failed to generate proxies for remote module 'remoteDiscoveryTest_PSModule'.  The term 'Export-PSSession' is \n            not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again. ---> \n            System.Management.Automation.CommandNotFoundException: The term 'Export-PSSession' is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was \n            included, verify that the path is correct and try again.    at System.Management.Automation.Runspaces.PipelineBase.Invoke(IEnumerable input)    at System.Management.Automation.Runspaces.Pipeline.Invoke()    at \n            System.Management.Automation.PowerShell.Worker.ConstructPipelineAndDoWork(Runspace rs, Boolean performSyncInvoke)    at System.Management.Automation.PowerShell.CoreInvokeHelper[TInput,TOutput](PSDataCollection`1 input, \n            PSDataCollection`1 output, PSInvocationSettings settings)    at System.Management.Automation.PowerShell.CoreInvoke[TInput,TOutput](PSDataCollection`1 input, PSDataCollection`1 output, PSInvocationSettings settings)    at \n            System.Management.Automation.PowerShell.CoreInvoke[TOutput](IEnumerable input, PSDataCollection`1 output, PSInvocationSettings settings)    at System.Management.Automation.PowerShell.Invoke[T](IEnumerable input, IList`1 \n            output, PSInvocationSettings settings)    at System.Management.Automation.PowerShell.Invoke[T](IEnumerable input, PSInvocationSettings settings)    at \n            System.Management.Automation.RemoteDiscoveryHelper.<InvokeNestedPowerShell>d__5.MoveNext()    at System.Management.Automation.RemoteDiscoveryHelper.<EnumerateWithCatch>d__12`1.MoveNext()    --- End of inner exception stack \n            trace ---    --- End of inner exception stack trace ---    at Microsoft.Test.Management.Automation.ScriptTestFixture.ExecuteScriptFile(String scriptPath) Parameter 0: \n            C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\utscripts\\RemoteDiscovery\\remoteDiscovery-psSession-psModule.ps1 Running script: \n            C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\utscripts\\RemoteDiscovery\\remoteDiscovery-psSession-psModule.ps1\n\nTitle     : TestNewPSDriveWithCredential\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : Microsoft.VS.TTest.TestFailureException: There were error records output from the script. Id: DriveRootError,Microsoft.PowerShell.Commands.NewPSDriveCommand, Id: Microsoft.PowerShell.Commands.WriteErrorException,Assert, Id: \n            DriveNotFound,Microsoft.PowerShell.Commands.RemovePSDriveCommand  ---> System.IO.IOException: The specified drive root \"\\\\DEV-14257-72A\\TestNetworkPSDrive\" either does not exist, or it is not a folder.    --- End of inner \n            exception stack trace ---    at Microsoft.Test.Management.Automation.ScriptTestFixture.ExecuteScriptFile(String scriptPath) Parameter 0: \n            C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\utscripts\\Security\\TestNewPSDriveWithCredential.ps1 Running script: \n            C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\utscripts\\Security\\TestNewPSDriveWithCredential.ps1\n\nTitle     : ExposeBug920253\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : Microsoft.VS.TTest.TestFailureException: Test Failed: 'powershell.exe exit code is FFFA0000, expected FFFB0000'    at Microsoft.VS.TTest.Validate.ThrowTestFailureException(String format, Object[] args)    at \n            Microsoft.VS.TTest.Validate.Assert(Boolean condition, String format, Object[] args)    at System.Management.Automation.Test.StartupTests.RedirectedStartupTestHelper(String arg, UInt32 expectedExitCode, String \n            expectedOutput, DoStringCompare stringCompareOutput, String expectedError, DoStringCompare stringCompareError, Boolean useUnicode)    at System.Management.Automation.Test.StartupTests.RedirectedStartupTestHelper(String arg, \n            UInt32 expectedExitCode, String expectedOutput, String expectedError, DoStringCompare stringCompareError)    at System.Management.Automation.Test.StartupTests.RedirectedStartupTestHelper(String arg, UInt32 expectedExitCode, \n            String expectedOutput, String expectedError)    at System.Management.Automation.Test.StartupTests.ExposeBug920253()\n\nTitle     : NonexistingConsoleFileTest\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : Microsoft.VS.TTest.TestFailureException: Test Failed: 'actual error is , expected Failed to load Windows PowerShell console file \"2:24:57PM.psc1\". WIN 32 error:'    at \n            Microsoft.VS.TTest.Validate.ThrowTestFailureException(String format, Object[] args)    at Microsoft.VS.TTest.Validate.Assert(Boolean condition, String format, Object[] args)    at \n            System.Management.Automation.Test.StartupTests.RedirectedStartupTestHelper(String arg, UInt32 expectedExitCode, String expectedOutput, DoStringCompare stringCompareOutput, String expectedError, DoStringCompare \n            stringCompareError, Boolean useUnicode)    at System.Management.Automation.Test.StartupTests.RedirectedStartupTestHelper(String arg, UInt32 expectedExitCode, String expectedOutput, String expectedError, DoStringCompare \n            stringCompareError)    at System.Management.Automation.Test.StartupTests.NonexistingConsoleFileTest()\n\nTitle     : InvalidConsoleSchemaVersionConsoleFileTest\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : Microsoft.VS.TTest.TestFailureException: Test Failed: 'actual error is , expected A required element ConsoleSchemaVersion in Windows PowerShell console file \"StartupTestsConsoleFile.psc1\" is invalid.'    at \n            Microsoft.VS.TTest.Validate.ThrowTestFailureException(String format, Object[] args)    at Microsoft.VS.TTest.Validate.Assert(Boolean condition, String format, Object[] args)    at \n            System.Management.Automation.Test.StartupTests.RedirectedStartupTestHelper(String arg, UInt32 expectedExitCode, String expectedOutput, DoStringCompare stringCompareOutput, String expectedError, DoStringCompare \n            stringCompareError, Boolean useUnicode)    at System.Management.Automation.Test.StartupTests.RedirectedStartupTestHelper(String arg, UInt32 expectedExitCode, String expectedOutput, String expectedError, DoStringCompare \n            stringCompareError)    at System.Management.Automation.Test.StartupTests.RedirectedStartupTestHelper(String arg, UInt32 expectedExitCode, String expectedOutput, String expectedError)\n\nTitle     : IncompatibleMonadVersionConsoleFileTest\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : Microsoft.VS.TTest.TestFailureException: Test Failed: 'actual error is , expected Windows PowerShell terminated with the following error:   Incorrect Windows PowerShell version 9999.99.'    at \n            Microsoft.VS.TTest.Validate.ThrowTestFailureException(String format, Object[] args)    at Microsoft.VS.TTest.Validate.Assert(Boolean condition, String format, Object[] args)    at \n            System.Management.Automation.Test.StartupTests.RedirectedStartupTestHelper(String arg, UInt32 expectedExitCode, String expectedOutput, DoStringCompare stringCompareOutput, String expectedError, DoStringCompare \n            stringCompareError, Boolean useUnicode)    at System.Management.Automation.Test.StartupTests.IncompatibleMonadVersionConsoleFileTest()\n\nTitle     : IncorrectMSHConsoleExtensionTest\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : Microsoft.VS.TTest.TestFailureException: Test Failed: 'actual error is , expected Windows PowerShell console file \"cf.mshc1\" extension is not psc1. Windows PowerShell console file extension must be psc1.'    at \n            Microsoft.VS.TTest.Validate.ThrowTestFailureException(String format, Object[] args)    at Microsoft.VS.TTest.Validate.Assert(Boolean condition, String format, Object[] args)    at \n            System.Management.Automation.Test.StartupTests.RedirectedStartupTestHelper(String arg, UInt32 expectedExitCode, String expectedOutput, DoStringCompare stringCompareOutput, String expectedError, DoStringCompare \n            stringCompareError, Boolean useUnicode)    at System.Management.Automation.Test.StartupTests.RedirectedStartupTestHelper(String arg, UInt32 expectedExitCode, String expectedOutput, String expectedError, DoStringCompare \n            stringCompareError)    at System.Management.Automation.Test.StartupTests.RedirectedStartupTestHelper(String arg, UInt32 expectedExitCode, String expectedOutput, String expectedError)\n\nTitle     : ExposeBug934299NoPSVersionTag\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : Microsoft.VS.TTest.TestFailureException: Test Failed: 'actual error is , expected Cannot read the Windows PowerShell version from Windows PowerShell console file \"StartupTestsConsoleFile.psc1\".'    at \n            Microsoft.VS.TTest.Validate.ThrowTestFailureException(String format, Object[] args)    at Microsoft.VS.TTest.Validate.Assert(Boolean condition, String format, Object[] args)    at \n            System.Management.Automation.Test.StartupTests.RedirectedStartupTestHelper(String arg, UInt32 expectedExitCode, String expectedOutput, DoStringCompare stringCompareOutput, String expectedError, DoStringCompare \n            stringCompareError, Boolean useUnicode)    at System.Management.Automation.Test.StartupTests.RedirectedStartupTestHelper(String arg, UInt32 expectedExitCode, String expectedOutput, String expectedError, DoStringCompare \n            stringCompareError)    at System.Management.Automation.Test.StartupTests.RedirectedStartupTestHelper(String arg, UInt32 expectedExitCode, String expectedOutput, String expectedError)\n\nTitle     : ExposeBug934299EmptyConsoleSchemaVersion\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : Microsoft.VS.TTest.TestFailureException: Test Failed: 'actual error is , expected A required element ConsoleSchemaVersion in Windows PowerShell console file \"StartupTestsConsoleFile.psc1\" is invalid.'    at \n            Microsoft.VS.TTest.Validate.ThrowTestFailureException(String format, Object[] args)    at Microsoft.VS.TTest.Validate.Assert(Boolean condition, String format, Object[] args)    at \n            System.Management.Automation.Test.StartupTests.RedirectedStartupTestHelper(String arg, UInt32 expectedExitCode, String expectedOutput, DoStringCompare stringCompareOutput, String expectedError, DoStringCompare \n            stringCompareError, Boolean useUnicode)    at System.Management.Automation.Test.StartupTests.RedirectedStartupTestHelper(String arg, UInt32 expectedExitCode, String expectedOutput, String expectedError, DoStringCompare \n            stringCompareError)    at System.Management.Automation.Test.StartupTests.RedirectedStartupTestHelper(String arg, UInt32 expectedExitCode, String expectedOutput, String expectedError)\n\nTitle     : ExposeBug934299WrongPSConsoleFileTag\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : Microsoft.VS.TTest.TestFailureException: Test Failed: 'actual error is , expected Cannot locate the required element PSConsoleFile in the Windows PowerShell console file \"StartupTestsConsoleFile.psc1\".'    at \n            Microsoft.VS.TTest.Validate.ThrowTestFailureException(String format, Object[] args)    at Microsoft.VS.TTest.Validate.Assert(Boolean condition, String format, Object[] args)    at \n            System.Management.Automation.Test.StartupTests.RedirectedStartupTestHelper(String arg, UInt32 expectedExitCode, String expectedOutput, DoStringCompare stringCompareOutput, String expectedError, DoStringCompare \n            stringCompareError, Boolean useUnicode)    at System.Management.Automation.Test.StartupTests.RedirectedStartupTestHelper(String arg, UInt32 expectedExitCode, String expectedOutput, String expectedError, DoStringCompare \n            stringCompareError)    at System.Management.Automation.Test.StartupTests.RedirectedStartupTestHelper(String arg, UInt32 expectedExitCode, String expectedOutput, String expectedError)\n\nTitle     : GetPSDriveDetectsNetworkMappedDrive\nRepro     : .\\runlite -suite Providers.FileSystemProvider.Misc -pri  -test GetPSDriveDetectsNetworkMappedDrive\nErrorText : Multiple connections to a server or shared resource by the same user, using more than one user name, are not allowed. Disconnect all previous connections to the server or shared resource and try again \n            System.ComponentModel.Win32Exception (0x80004005): Multiple connections to a server or shared resource by the same user, using more than one user name, are not allowed. Disconnect all previous connections to the server or \n            shared resource and try again\n\nTitle     : RemoveNetworkMappedDrive\nRepro     : .\\runlite -suite Providers.FileSystemProvider.Misc -pri  -test RemoveNetworkMappedDrive\nErrorText : Multiple connections to a server or shared resource by the same user, using more than one user name, are not allowed. Disconnect all previous connections to the server or shared resource and try again \n            System.ComponentModel.Win32Exception (0x80004005): Multiple connections to a server or shared resource by the same user, using more than one user name, are not allowed. Disconnect all previous connections to the server or \n            shared resource and try again\n\nTitle     : ExposeSetLocationUNCProviderQualifiedPathBug\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : Microsoft.VS.TTest.TestFailureException: Test Failed: 'get-location should return a path of \"Microsoft.PowerShell.Core\\FileSystem::\\\\DEV-14257-72A\\testtemp\" but returned \"Microsoft.PowerShell.Core\\FileSystem::C:\\\"'    at \n            Microsoft.VS.TTest.Validate.ThrowTestFailureException(String format, Object[] args)    at System.Management.Automation.Test.FileSystemProviderTest.ExposeSetLocationUNCProviderQualifiedPathBug()\n\nTitle     : ExposeSetLocationUNCDirectPathBug\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : Microsoft.VS.TTest.TestFailureException: Test Failed: 'get-location should return a path of \"Microsoft.PowerShell.Core\\FileSystem::\\\\DEV-14257-72A\\testtemp\" but returned \"Microsoft.PowerShell.Core\\FileSystem::C:\\\"'    at \n            Microsoft.VS.TTest.Validate.ThrowTestFailureException(String format, Object[] args)    at System.Management.Automation.Test.FileSystemProviderTest.ExposeSetLocationUNCDirectPathBug()\n\nTitle     : ClearContent\nRepro     : .\\runlite -suite Providers.FileSystemProvider.AlternateDataStreams -pri  -test ClearContent\nErrorText : Cannot find path 'C:\\Users\\sevoroby\\AppData\\Local\\Temp\\tmp9A11.tmp:Stream2' because it does not exist. System.Management.Automation.ItemNotFoundException: Cannot find path \n            'C:\\Users\\sevoroby\\AppData\\Local\\Temp\\tmp9A11.tmp:Stream2' because it does not exist.    at System.Management.Automation.LocationGlobber.ResolveProviderPathFromProviderPath(String providerPath, String providerId, Boolean \n            allowNonexistingPaths, CmdletProviderContext context, CmdletProvider& providerInstance)    at System.Management.Automation.LocationGlobber.ResolvePSPathFromProviderPath(String path, CmdletProviderContext context, Boolean \n            allowNonexistingPaths, Boolean isProviderDirectPath, Boolean isProviderQualifiedPath, CmdletProvider& providerInstance)    at System.Management.Automation.LocationGlobber.GetGlobbedMonadPathsFromMonadPath(String path, \n            Boolean allowNonexistingPaths, CmdletProviderContext context, CmdletProvider& providerInstance)    at System.Management.Automation.LocationGlobber.GetGlobbedProviderPathsFromMonadPath(String path, Boolean \n            allowNonexistingPaths, CmdletProviderContext context, ProviderInfo& provider, CmdletProvider& providerInstance)    at System.Management.Automation.SessionStateInternal.ClearContent(String[] paths, CmdletProviderContext \n            context)    at System.Management.Automation.ContentCmdletProviderIntrinsics.Clear(String path, CmdletProviderContext context)    at Microsoft.PowerShell.Commands.ClearContentCommand.ProcessRecord()\n\nTitle     : GetContent\nRepro     : .\\runlite -suite Providers.FileSystemProvider.AlternateDataStreams -pri  -test GetContent\nErrorText : Cannot find path 'C:\\Users\\sevoroby\\AppData\\Local\\Temp\\tmp9BD8.tmp::$DATA' because it does not exist. System.Management.Automation.ItemNotFoundException: Cannot find path \n            'C:\\Users\\sevoroby\\AppData\\Local\\Temp\\tmp9BD8.tmp::$DATA' because it does not exist.    at System.Management.Automation.LocationGlobber.ResolveProviderPathFromProviderPath(String providerPath, String providerId, Boolean \n            allowNonexistingPaths, CmdletProviderContext context, CmdletProvider& providerInstance)    at System.Management.Automation.LocationGlobber.ResolvePSPathFromProviderPath(String path, CmdletProviderContext context, Boolean \n            allowNonexistingPaths, Boolean isProviderDirectPath, Boolean isProviderQualifiedPath, CmdletProvider& providerInstance)    at System.Management.Automation.LocationGlobber.GetGlobbedMonadPathsFromMonadPath(String path, \n            Boolean allowNonexistingPaths, CmdletProviderContext context, CmdletProvider& providerInstance)    at System.Management.Automation.PathIntrinsics.GetResolvedPSPathFromPSPath(String path, CmdletProviderContext context)    at \n            Microsoft.PowerShell.Commands.ContentCommandBase.ResolvePaths(String[] pathsToResolve, Boolean allowNonexistingPaths, Boolean allowEmptyResult, CmdletProviderContext currentCommandContext)\n\nTitle     : GetItem\nRepro     : .\\runlite -suite Providers.FileSystemProvider.AlternateDataStreams -pri  -test GetItem\nErrorText : Cannot find path 'C:\\Users\\sevoroby\\AppData\\Local\\Temp\\tmp9D30.tmp::$DATA' because it does not exist. System.Management.Automation.ItemNotFoundException: Cannot find path \n            'C:\\Users\\sevoroby\\AppData\\Local\\Temp\\tmp9D30.tmp::$DATA' because it does not exist.    at System.Management.Automation.LocationGlobber.ExpandMshGlobPath(String path, Boolean allowNonexistingPaths, PSDriveInfo drive, \n            ContainerCmdletProvider provider, CmdletProviderContext context)    at System.Management.Automation.LocationGlobber.ResolveDriveQualifiedPath(String path, CmdletProviderContext context, Boolean allowNonexistingPaths, \n            CmdletProvider& providerInstance)    at System.Management.Automation.LocationGlobber.GetGlobbedMonadPathsFromMonadPath(String path, Boolean allowNonexistingPaths, CmdletProviderContext context, CmdletProvider& \n            providerInstance)    at System.Management.Automation.LocationGlobber.GetGlobbedProviderPathsFromMonadPath(String path, Boolean allowNonexistingPaths, CmdletProviderContext context, ProviderInfo& provider, CmdletProvider& \n            providerInstance)    at System.Management.Automation.SessionStateInternal.GetItem(String[] paths, CmdletProviderContext context)    at System.Management.Automation.ItemCmdletProviderIntrinsics.Get(String path, \n            CmdletProviderContext context)    at Microsoft.PowerShell.Commands.GetItemCommand.ProcessRecord()\n\nTitle     : GetItemMultipleStreams\nRepro     : .\\runlite -suite Providers.FileSystemProvider.AlternateDataStreams -pri  -test GetItemMultipleStreams\nErrorText : Cannot find path 'C:\\Users\\sevoroby\\AppData\\Local\\Temp\\tmp9E1C.tmp:Stream1' because it does not exist. System.Management.Automation.ItemNotFoundException: Cannot find path \n            'C:\\Users\\sevoroby\\AppData\\Local\\Temp\\tmp9E1C.tmp:Stream1' because it does not exist.    at System.Management.Automation.LocationGlobber.ExpandMshGlobPath(String path, Boolean allowNonexistingPaths, PSDriveInfo drive, \n            ContainerCmdletProvider provider, CmdletProviderContext context)    at System.Management.Automation.LocationGlobber.ResolveDriveQualifiedPath(String path, CmdletProviderContext context, Boolean allowNonexistingPaths, \n            CmdletProvider& providerInstance)    at System.Management.Automation.LocationGlobber.GetGlobbedMonadPathsFromMonadPath(String path, Boolean allowNonexistingPaths, CmdletProviderContext context, CmdletProvider& \n            providerInstance)    at System.Management.Automation.LocationGlobber.GetGlobbedProviderPathsFromMonadPath(String path, Boolean allowNonexistingPaths, CmdletProviderContext context, ProviderInfo& provider, CmdletProvider& \n            providerInstance)    at System.Management.Automation.SessionStateInternal.GetItem(String[] paths, CmdletProviderContext context)    at System.Management.Automation.ItemCmdletProviderIntrinsics.Get(String path, \n            CmdletProviderContext context)    at Microsoft.PowerShell.Commands.GetItemCommand.ProcessRecord()\n\nTitle     : RemoveItem\nRepro     : .\\runlite -suite Providers.FileSystemProvider.AlternateDataStreams -pri  -test RemoveItem\nErrorText : Cannot find path 'C:\\Users\\sevoroby\\AppData\\Local\\Temp\\tmp9F07.tmp:Stream2' because it does not exist. System.Management.Automation.ItemNotFoundException: Cannot find path \n            'C:\\Users\\sevoroby\\AppData\\Local\\Temp\\tmp9F07.tmp:Stream2' because it does not exist.    at System.Management.Automation.LocationGlobber.ResolveProviderPathFromProviderPath(String providerPath, String providerId, Boolean \n            allowNonexistingPaths, CmdletProviderContext context, CmdletProvider& providerInstance)    at System.Management.Automation.LocationGlobber.ResolvePSPathFromProviderPath(String path, CmdletProviderContext context, Boolean \n            allowNonexistingPaths, Boolean isProviderDirectPath, Boolean isProviderQualifiedPath, CmdletProvider& providerInstance)    at System.Management.Automation.LocationGlobber.GetGlobbedMonadPathsFromMonadPath(String path, \n            Boolean allowNonexistingPaths, CmdletProviderContext context, CmdletProvider& providerInstance)    at System.Management.Automation.PathIntrinsics.GetResolvedPSPathFromPSPath(String path, CmdletProviderContext context)    at \n            Microsoft.PowerShell.Commands.RemoveItemCommand.ProcessRecord()\n\nTitle     : SetContent\nRepro     : .\\runlite -suite Providers.FileSystemProvider.AlternateDataStreams -pri  -test SetContent\nErrorText : Exception calling \"Invoke\" with \"0\" argument(s): \"Should have first content result: 'Updated' does not equal 'World Updated' CallStack: Asserts.ps1: line 87 <- Asserts.ps1: line 219 <- \n            Lite.Providers.FileSystemProvider.AlternateDataStreams.ps1: line 162\" System.Management.Automation.MethodInvocationException: Exception calling \"Invoke\" with \"0\" argument(s): \"Should have first content result: 'Updated' \n            does not equal 'World Updated' CallStack: Asserts.ps1: line 87 <- Asserts.ps1: line 219 <- Lite.Providers.FileSystemProvider.AlternateDataStreams.ps1: line 162\" ---> System.Management.Automation.RuntimeException: Should \n            have first content result: 'Updated' does not equal 'World Updated' CallStack: Asserts.ps1: line 87 <- Asserts.ps1: line 219 <- Lite.Providers.FileSystemProvider.AlternateDataStreams.ps1: line 162    at \n            System.Management.Automation.Runspaces.PipelineBase.Invoke(IEnumerable input)    at System.Management.Automation.Runspaces.Pipeline.Invoke()    at CallSite.Target(Closure , CallSite , Object )    --- End of inner exception \n            stack trace ---    at System.Management.Automation.ExceptionHandlingOps.CheckActionPreference(FunctionContext funcContext, Exception exception)    at \n            System.Management.Automation.Interpreter.ActionCallInstruction`2.Run(InterpretedFrame frame)    at System.Management.Automation.Interpreter.EnterTryCatchFinallyInstruction.Run(InterpretedFrame frame)    at \n            System.Management.Automation.Interpreter.EnterTryCatchFinallyInstruction.Run(InterpretedFrame frame)\n\nTitle     : System.Management.Automation.Remoting.UnitTests.WSManPluginEntryDelegatesUnitTests.ConstructionCreatesDelegates\nRepro     : \nErrorText : {System.MethodAccessException: Attempt by method 'System.Management.Automation.Remoting.UnitTests.WSManPluginEntryDelegatesUnitTests.ConstructionCreatesDelegates()' to access method \n            'System.Management.Automation.Remoting.WSManPluginEntryDelegates..ctor()' failed.    at System.Management.Automation.Remoting.UnitTests.WSManPluginEntryDelegatesUnitTests.ConstructionCreatesDelegates(), [HRESULT: \n            0x80131604]. Test operation failed: 'ConstructionCreatesDelegates'.}\n\nTitle     : System.Management.Automation.Remoting.UnitTests.WSManPluginEntryDelegatesUnitTests.InitPluginAssignsWorkerPtrs\nRepro     : \nErrorText : {System.MethodAccessException: Attempt by method 'System.Management.Automation.Remoting.UnitTests.WSManPluginEntryDelegatesUnitTests.InitPluginAssignsWorkerPtrs()' to access method \n            'System.Management.Automation.Remoting.WSManPluginEntryDelegates+WSManPluginEntryDelegatesInternal..ctor()' failed.    at \n            System.Management.Automation.Remoting.UnitTests.WSManPluginEntryDelegatesUnitTests.InitPluginAssignsWorkerPtrs(), [HRESULT: 0x80131604]. Test operation failed: 'InitPluginAssignsWorkerPtrs'.}\n\nTitle     : System.Management.Automation.Remoting.UnitTests.WSManPluginEntryDelegatesUnitTests.NullInputIsNoOp\nRepro     : \nErrorText : {System.TypeLoadException: Type 'System.Management.Automation.Remoting.UnitTests.SavesErrorCodeWSManPluginFacade' from assembly 'TAEF.WSManPlugin.UnitTests, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35' \n            is attempting to implement an inaccessible interface.    at System.Management.Automation.Remoting.UnitTests.WSManPluginEntryDelegatesUnitTests.NullInputIsNoOp(), [HRESULT: 0x80131604]. Test operation failed: \n            'NullInputIsNoOp'.}\n\nTitle     : System.Management.Automation.Remoting.UnitTests.WSManPluginShellSessionUnitTests.CloseCommandOperationDoesNothingIfUnmatchedContext\nRepro     : \nErrorText : {System.MethodAccessException: Attempt by method 'System.Management.Automation.Remoting.UnitTests.WSManPluginShellSessionUnitTests.CloseCommandOperationDoesNothingIfUnmatchedContext()' to access method \n            'System.Management.Automation.Remoting.Client.WSManNativeApi+WSManPluginRequest..ctor()' failed.    at \n            System.Management.Automation.Remoting.UnitTests.WSManPluginShellSessionUnitTests.CloseCommandOperationDoesNothingIfUnmatchedContext(), [HRESULT: 0x80131604]. Test operation failed: \n            'CloseCommandOperationDoesNothingIfUnmatchedContext'.}\n\nTitle     : System.Management.Automation.Remoting.UnitTests.WSManPluginShellSessionUnitTests.GetCommandSessionReturnsNullIfNoCommandSession\nRepro     : \nErrorText : {System.MethodAccessException: Attempt by method 'System.Management.Automation.Remoting.UnitTests.WSManPluginShellSessionUnitTests.GetCommandSessionReturnsNullIfNoCommandSession()' to access method \n            'System.Management.Automation.Remoting.Client.WSManNativeApi+WSManPluginRequest..ctor()' failed.    at \n            System.Management.Automation.Remoting.UnitTests.WSManPluginShellSessionUnitTests.GetCommandSessionReturnsNullIfNoCommandSession(), [HRESULT: 0x80131604]. Test operation failed: \n            'GetCommandSessionReturnsNullIfNoCommandSession'.}\n\nTitle     : DRT - TestCreateProcessPipeName-0\nRepro     : \nErrorText : \n\nTitle     : DRT - TestCreateNamedPipeServer-0\nRepro     : \nErrorText : \n\nTitle     : DRT - TestCreateNamedPipeClient-0\nRepro     : \nErrorText : \n\nTitle     : DRT - TestCreateContainerNamedPipeClient-0\nRepro     : \nErrorText : \n\nTitle     : DRT - TestClientServerConnect-0\nRepro     : \nErrorText : \n\nTitle     : DRT - TestNamedPipeDuplicateServerPipe-0\nRepro     : \nErrorText : \n\nTitle     : DRT - TestNamedPipeClientSessionTransportManager-0\nRepro     : \nErrorText : \n\nTitle     : TestCreateProcessPipeName-0\nRepro     : .\\runlite -suite PowerShellNamedPipeTests.PowerShellNamedPipeTests -pri  -test TestCreateProcessPipeName-0\nErrorText : Test method PowerShellNamedPipeTests.PowerShellNamedPipeTests.TestCreateProcessPipeName threw exception:  System.MethodAccessException: Attempt by method \n            'PowerShellNamedPipeTests.PowerShellNamedPipeTests.TestCreateProcessPipeName()' to access method 'System.Management.Automation.Remoting.NamedPipeUtils.CreateProcessPipeName(System.Diagnostics.Process)' failed.     at \n            PowerShellNamedPipeTests.PowerShellNamedPipeTests.TestCreateProcessPipeName()       at PowerShellNamedPipeTests.PowerShellNamedPipeTests.TestCreateProcessPipeName()\n\nTitle     : TestCreateNamedPipeServer-0\nRepro     : .\\runlite -suite PowerShellNamedPipeTests.PowerShellNamedPipeTests -pri  -test TestCreateNamedPipeServer-0\nErrorText : Test method PowerShellNamedPipeTests.PowerShellNamedPipeTests.TestCreateNamedPipeServer threw exception:  System.MethodAccessException: Attempt by method \n            'PowerShellNamedPipeTests.PowerShellNamedPipeTests.TestCreateNamedPipeServer()' to access method 'System.Management.Automation.Remoting.RemoteSessionNamedPipeServer..ctor(System.String)' failed.     at \n            PowerShellNamedPipeTests.PowerShellNamedPipeTests.TestCreateNamedPipeServer()       at PowerShellNamedPipeTests.PowerShellNamedPipeTests.TestCreateNamedPipeServer()\n\nTitle     : TestCreateNamedPipeClient-0\nRepro     : .\\runlite -suite PowerShellNamedPipeTests.PowerShellNamedPipeTests -pri  -test TestCreateNamedPipeClient-0\nErrorText : Test method PowerShellNamedPipeTests.PowerShellNamedPipeTests.TestCreateNamedPipeClient threw exception:  System.MethodAccessException: Attempt by method \n            'PowerShellNamedPipeTests.PowerShellNamedPipeTests.TestCreateNamedPipeClient()' to access method 'System.Management.Automation.Remoting.RemoteSessionNamedPipeClient..ctor(System.Diagnostics.Process, System.String)' failed.  \n               at PowerShellNamedPipeTests.PowerShellNamedPipeTests.TestCreateNamedPipeClient()       at PowerShellNamedPipeTests.PowerShellNamedPipeTests.TestCreateNamedPipeClient()\n\nTitle     : TestCreateContainerNamedPipeClient-0\nRepro     : .\\runlite -suite PowerShellNamedPipeTests.PowerShellNamedPipeTests -pri  -test TestCreateContainerNamedPipeClient-0\nErrorText : Test method PowerShellNamedPipeTests.PowerShellNamedPipeTests.TestCreateContainerNamedPipeClient threw exception:  System.MethodAccessException: Attempt by method \n            'PowerShellNamedPipeTests.PowerShellNamedPipeTests.TestCreateContainerNamedPipeClient()' to access method 'System.Management.Automation.Remoting.ContainerSessionNamedPipeClient..ctor(Int32, System.String, System.String)' \n            failed.     at PowerShellNamedPipeTests.PowerShellNamedPipeTests.TestCreateContainerNamedPipeClient()       at PowerShellNamedPipeTests.PowerShellNamedPipeTests.TestCreateContainerNamedPipeClient()\n\nTitle     : TestClientServerConnect-0\nRepro     : .\\runlite -suite PowerShellNamedPipeTests.PowerShellNamedPipeTests -pri  -test TestClientServerConnect-0\nErrorText : Test method PowerShellNamedPipeTests.PowerShellNamedPipeTests.TestClientServerConnect threw exception:  System.MethodAccessException: Attempt by method \n            'PowerShellNamedPipeTests.PowerShellNamedPipeTests.TestClientServerConnect()' to access method 'System.Management.Automation.Remoting.RemoteSessionNamedPipeServer..ctor(System.String)' failed.     at \n            PowerShellNamedPipeTests.PowerShellNamedPipeTests.TestClientServerConnect()       at PowerShellNamedPipeTests.PowerShellNamedPipeTests.TestClientServerConnect()\n\nTitle     : TestNamedPipeDuplicateServerPipe-0\nRepro     : .\\runlite -suite PowerShellNamedPipeTests.PowerShellNamedPipeTests -pri  -test TestNamedPipeDuplicateServerPipe-0\nErrorText : Test method PowerShellNamedPipeTests.PowerShellNamedPipeTests.TestNamedPipeDuplicateServerPipe threw exception:  System.MethodAccessException: Attempt by method \n            'PowerShellNamedPipeTests.PowerShellNamedPipeTests.TestNamedPipeDuplicateServerPipe()' to access method 'System.Management.Automation.Remoting.RemoteSessionNamedPipeServer..ctor(System.String)' failed.     at \n            PowerShellNamedPipeTests.PowerShellNamedPipeTests.TestNamedPipeDuplicateServerPipe()       at PowerShellNamedPipeTests.PowerShellNamedPipeTests.TestNamedPipeDuplicateServerPipe()\n\nTitle     : TestNamedPipeClientSessionTransportManager-0\nRepro     : .\\runlite -suite PowerShellNamedPipeTransportTests.PowerShellNamedPipeTransportTests -pri  -test TestNamedPipeClientSessionTransportManager-0\nErrorText : Test method PowerShellNamedPipeTransportTests.PowerShellNamedPipeTransportTests.TestNamedPipeClientSessionTransportManager threw exception:  System.MethodAccessException: Attempt by method \n            'PowerShellNamedPipeTransportTests.PowerShellNamedPipeTransportTests.TestNamedPipeClientSessionTransportManager()' to access method \n            'System.Management.Automation.Remoting.Client.NamedPipeClientSessionTransportManager..ctor(System.Management.Automation.Runspaces.NamedPipeConnectionInfo, System.Guid, \n            System.Management.Automation.Internal.PSRemotingCryptoHelper)' failed.     at PowerShellNamedPipeTransportTests.PowerShellNamedPipeTransportTests.TestNamedPipeClientSessionTransportManager()       at \n            PowerShellNamedPipeTransportTests.PowerShellNamedPipeTransportTests.TestNamedPipeClientSessionTransportManager()\n\nTitle     : GetCommandProxyTest\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : System.Management.Automation.CmdletInvocationException: Cannot process argument because the value of argument \"name\" is not valid. Change the value of the \"name\" argument and run the operation again. ---> \n            System.Management.Automation.PSArgumentException: Cannot process argument because the value of argument \"name\" is not valid. Change the value of the \"name\" argument and run the operation again.    at \n            System.Management.Automation.CmdletInfo..ctor(String name, Type implementingType, String helpFile, PSSnapInInfo PSSnapin, ExecutionContext context)    at \n            System.Management.Automation.Internal.ModuleUtils.<GetMatchingCommands>d__7.MoveNext()    at Microsoft.PowerShell.Commands.GetCommandCommand.AccumulateMatchingCommands(IEnumerable`1 commandNames)    at \n            Microsoft.PowerShell.Commands.GetCommandCommand.AccumulateMatchingCmdlets()    at Microsoft.PowerShell.Commands.GetCommandCommand.ProcessRecord()    at System.Management.Automation.Cmdlet.DoProcessRecord()    at \n            System.Management.Automation.CommandProcessor.ProcessRecord()    --- End of inner exception stack trace ---    at System.Management.Automation.Runspaces.PipelineBase.Invoke(IEnumerable input)    at \n            Microsoft.Test.Management.Automation.MonadTestHelper.ExecutePipeline(Pipeline pipe, Object[] input, PSObject[]& output, PSObject[]& error)    at \n            Microsoft.Test.Management.Automation.ProxyCommandTests.CommonProxyCommandTest(Type commandType)\n\nTitle     : ActivityWithScriptBlock\nRepro     : .\\runlite -suite Scripting.CoreLanguage.CoreFunctionality -pri  -test ActivityWithScriptBlock\nErrorText : Exception calling \"Invoke\" with \"0\" argument(s): \"Windows PowerShell Workflow is not supported in a Windows PowerShell x86-based console. Open a Windows PowerShell x64-based console, and then try again.\" \n            System.Management.Automation.MethodInvocationException: Exception calling \"Invoke\" with \"0\" argument(s): \"Windows PowerShell Workflow is not supported in a Windows PowerShell x86-based console. Open a Windows PowerShell \n            x64-based console, and then try again.\" ---> System.Management.Automation.RuntimeException: Windows PowerShell Workflow is not supported in a Windows PowerShell x86-based console. Open a Windows PowerShell x64-based \n            console, and then try again. ---> System.NotSupportedException: Windows PowerShell Workflow is not supported in a Windows PowerShell x86-based console. Open a Windows PowerShell x64-based console, and then try again.    at \n            System.Management.Automation.Utils.GetAstToWorkflowConverterAndEnsureWorkflowModuleLoaded(ExecutionContext context)    at System.Management.Automation.FunctionOps.DefineWorkflows(ExecutionContext context, ScriptBlockAst \n            scriptBlockAst)    --- End of inner exception stack trace ---    at System.Management.Automation.Runspaces.PipelineBase.Invoke(IEnumerable input)    at System.Management.Automation.Runspaces.Pipeline.Invoke()    at \n            CallSite.Target(Closure , CallSite , Object )    --- End of inner exception stack trace ---    at System.Management.Automation.ExceptionHandlingOps.CheckActionPreference(FunctionContext funcContext, Exception exception)    \n            at ExecuteInRunspace(Closure , FunctionContext )\n\nTitle     : InlineXamlBlocked\nRepro     : .\\runlite -suite Scripting.CoreLanguage.CoreFunctionality -pri  -test InlineXamlBlocked\nErrorText : Exception calling \"Invoke\" with \"0\" argument(s): \"Should not have supported inline XAML: 'InlineXamlNotSupported,Microsoft.PowerShell.Commands.InvokeExpressionCommand' does not equal \n            'System.NotSupportedException,Microsoft.PowerShell.Commands.InvokeExpressionCommand' CallStack: Asserts.ps1: line 87 <- Asserts.ps1: line 219 <- Lite.Scripting.CoreLanguage.CoreFunctionality.ps1: line 259\" \n            System.Management.Automation.MethodInvocationException: Exception calling \"Invoke\" with \"0\" argument(s): \"Should not have supported inline XAML: 'InlineXamlNotSupported,Microsoft.PowerShell.Commands.InvokeExpressionCommand' \n            does not equal 'System.NotSupportedException,Microsoft.PowerShell.Commands.InvokeExpressionCommand' CallStack: Asserts.ps1: line 87 <- Asserts.ps1: line 219 <- Lite.Scripting.CoreLanguage.CoreFunctionality.ps1: line 259\" \n            ---> System.Management.Automation.RuntimeException: Should not have supported inline XAML: 'InlineXamlNotSupported,Microsoft.PowerShell.Commands.InvokeExpressionCommand' does not equal \n            'System.NotSupportedException,Microsoft.PowerShell.Commands.InvokeExpressionCommand' CallStack: Asserts.ps1: line 87 <- Asserts.ps1: line 219 <- Lite.Scripting.CoreLanguage.CoreFunctionality.ps1: line 259    at \n            System.Management.Automation.Runspaces.PipelineBase.Invoke(IEnumerable input)    at System.Management.Automation.Runspaces.Pipeline.Invoke()    at CallSite.Target(Closure , CallSite , Object )    --- End of inner exception \n            stack trace ---    at System.Management.Automation.ExceptionHandlingOps.CheckActionPreference(FunctionContext funcContext, Exception exception)    at ExecuteInRunspace(Closure , FunctionContext )\n\nTitle     : OverwriteWorkflow\nRepro     : .\\runlite -suite Scripting.CoreLanguage.CoreFunctionality -pri  -test OverwriteWorkflow\nErrorText : Exception calling \"Invoke\" with \"0\" argument(s): \"Windows PowerShell Workflow is not supported in a Windows PowerShell x86-based console. Open a Windows PowerShell x64-based console, and then try again.\" \n            System.Management.Automation.MethodInvocationException: Exception calling \"Invoke\" with \"0\" argument(s): \"Windows PowerShell Workflow is not supported in a Windows PowerShell x86-based console. Open a Windows PowerShell \n            x64-based console, and then try again.\" ---> System.Management.Automation.RuntimeException: Windows PowerShell Workflow is not supported in a Windows PowerShell x86-based console. Open a Windows PowerShell x64-based \n            console, and then try again. ---> System.NotSupportedException: Windows PowerShell Workflow is not supported in a Windows PowerShell x86-based console. Open a Windows PowerShell x64-based console, and then try again.    at \n            System.Management.Automation.Utils.GetAstToWorkflowConverterAndEnsureWorkflowModuleLoaded(ExecutionContext context)    at System.Management.Automation.FunctionOps.DefineWorkflows(ExecutionContext context, ScriptBlockAst \n            scriptBlockAst)    --- End of inner exception stack trace ---    at System.Management.Automation.Runspaces.PipelineBase.Invoke(IEnumerable input)    at System.Management.Automation.Runspaces.Pipeline.Invoke()    at \n            CallSite.Target(Closure , CallSite , Object )    --- End of inner exception stack trace ---    at System.Management.Automation.ExceptionHandlingOps.CheckActionPreference(FunctionContext funcContext, Exception exception)    \n            at ExecuteInRunspace(Closure , FunctionContext )\n\nTitle     : PowerShellValue\nRepro     : .\\runlite -suite Scripting.CoreLanguage.CoreFunctionality -pri  -test PowerShellValue\nErrorText : Exception calling \"Invoke\" with \"0\" argument(s): \"Windows PowerShell Workflow is not supported in a Windows PowerShell x86-based console. Open a Windows PowerShell x64-based console, and then try again.\" \n            System.Management.Automation.MethodInvocationException: Exception calling \"Invoke\" with \"0\" argument(s): \"Windows PowerShell Workflow is not supported in a Windows PowerShell x86-based console. Open a Windows PowerShell \n            x64-based console, and then try again.\" ---> System.Management.Automation.RuntimeException: Windows PowerShell Workflow is not supported in a Windows PowerShell x86-based console. Open a Windows PowerShell x64-based \n            console, and then try again. ---> System.NotSupportedException: Windows PowerShell Workflow is not supported in a Windows PowerShell x86-based console. Open a Windows PowerShell x64-based console, and then try again.    at \n            System.Management.Automation.Utils.GetAstToWorkflowConverterAndEnsureWorkflowModuleLoaded(ExecutionContext context)    at System.Management.Automation.FunctionOps.DefineWorkflows(ExecutionContext context, ScriptBlockAst \n            scriptBlockAst)    --- End of inner exception stack trace ---    at System.Management.Automation.Runspaces.PipelineBase.Invoke(IEnumerable input)    at System.Management.Automation.Runspaces.Pipeline.Invoke()    at \n            CallSite.Target(Closure , CallSite , Object )    --- End of inner exception stack trace ---    at System.Management.Automation.ExceptionHandlingOps.CheckActionPreference(FunctionContext funcContext, Exception exception)    \n            at ExecuteInRunspace(Closure , FunctionContext )\n\nTitle     : StartDebuggingInconsistentState\nRepro     : .\\runlite -suite Scripting.CoreLanguage.CoreFunctionality -pri  -test StartDebuggingInconsistentState\nErrorText : Exception calling \"Invoke\" with \"0\" argument(s): \"Should not have been able to start job with inconsistent state: 'CannotSetBreakpointInconsistentLanguageMode,Microsoft.PowerShell.Commands.SetPSBreakpointCommand' does not \n            equal '' CallStack: Asserts.ps1: line 87 <- Asserts.ps1: line 219 <- Lite.Scripting.CoreLanguage.CoreFunctionality.ps1: line 486\" System.Management.Automation.MethodInvocationException: Exception calling \"Invoke\" with \"0\" \n            argument(s): \"Should not have been able to start job with inconsistent state: 'CannotSetBreakpointInconsistentLanguageMode,Microsoft.PowerShell.Commands.SetPSBreakpointCommand' does not equal '' CallStack: Asserts.ps1: line \n            87 <- Asserts.ps1: line 219 <- Lite.Scripting.CoreLanguage.CoreFunctionality.ps1: line 486\" ---> System.Management.Automation.RuntimeException: Should not have been able to start job with inconsistent state: \n            'CannotSetBreakpointInconsistentLanguageMode,Microsoft.PowerShell.Commands.SetPSBreakpointCommand' does not equal '' CallStack: Asserts.ps1: line 87 <- Asserts.ps1: line 219 <- \n            Lite.Scripting.CoreLanguage.CoreFunctionality.ps1: line 486    at System.Management.Automation.Runspaces.PipelineBase.Invoke(IEnumerable input)    at System.Management.Automation.Runspaces.Pipeline.Invoke()    at \n            CallSite.Target(Closure , CallSite , Object )    --- End of inner exception stack trace ---    at System.Management.Automation.ExceptionHandlingOps.CheckActionPreference(FunctionContext funcContext, Exception exception)    \n            at ExecuteInRunspace(Closure , FunctionContext )\n\nTitle     : WorkflowFullLanguage\nRepro     : .\\runlite -suite Scripting.CoreLanguage.CoreFunctionality -pri  -test WorkflowFullLanguage\nErrorText : Exception calling \"Invoke\" with \"0\" argument(s): \"Windows PowerShell Workflow is not supported in a Windows PowerShell x86-based console. Open a Windows PowerShell x64-based console, and then try again.\" \n            System.Management.Automation.MethodInvocationException: Exception calling \"Invoke\" with \"0\" argument(s): \"Windows PowerShell Workflow is not supported in a Windows PowerShell x86-based console. Open a Windows PowerShell \n            x64-based console, and then try again.\" ---> System.Management.Automation.RuntimeException: Windows PowerShell Workflow is not supported in a Windows PowerShell x86-based console. Open a Windows PowerShell x64-based \n            console, and then try again. ---> System.NotSupportedException: Windows PowerShell Workflow is not supported in a Windows PowerShell x86-based console. Open a Windows PowerShell x64-based console, and then try again.    at \n            System.Management.Automation.Utils.GetAstToWorkflowConverterAndEnsureWorkflowModuleLoaded(ExecutionContext context)    at System.Management.Automation.FunctionOps.DefineWorkflows(ExecutionContext context, ScriptBlockAst \n            scriptBlockAst)    --- End of inner exception stack trace ---    at System.Management.Automation.Runspaces.PipelineBase.Invoke(IEnumerable input)    at System.Management.Automation.Runspaces.Pipeline.Invoke()    at \n            CallSite.Target(Closure , CallSite , Object )    --- End of inner exception stack trace ---    at System.Management.Automation.ExceptionHandlingOps.CheckActionPreference(FunctionContext funcContext, Exception exception)    \n            at ExecuteInRunspace(Closure , FunctionContext )\n\nTitle     : WorkflowInlineScript\nRepro     : .\\runlite -suite Scripting.CoreLanguage.CoreFunctionality -pri  -test WorkflowInlineScript\nErrorText : Exception calling \"Invoke\" with \"0\" argument(s): \"Windows PowerShell Workflow is not supported in a Windows PowerShell x86-based console. Open a Windows PowerShell x64-based console, and then try again.\" \n            System.Management.Automation.MethodInvocationException: Exception calling \"Invoke\" with \"0\" argument(s): \"Windows PowerShell Workflow is not supported in a Windows PowerShell x86-based console. Open a Windows PowerShell \n            x64-based console, and then try again.\" ---> System.Management.Automation.RuntimeException: Windows PowerShell Workflow is not supported in a Windows PowerShell x86-based console. Open a Windows PowerShell x64-based \n            console, and then try again. ---> System.NotSupportedException: Windows PowerShell Workflow is not supported in a Windows PowerShell x86-based console. Open a Windows PowerShell x64-based console, and then try again.    at \n            System.Management.Automation.Utils.GetAstToWorkflowConverterAndEnsureWorkflowModuleLoaded(ExecutionContext context)    at System.Management.Automation.FunctionOps.DefineWorkflows(ExecutionContext context, ScriptBlockAst \n            scriptBlockAst)    --- End of inner exception stack trace ---    at System.Management.Automation.Runspaces.PipelineBase.Invoke(IEnumerable input)    at System.Management.Automation.Runspaces.Pipeline.Invoke()    at \n            CallSite.Target(Closure , CallSite , Object )    --- End of inner exception stack trace ---    at System.Management.Automation.ExceptionHandlingOps.CheckActionPreference(FunctionContext funcContext, Exception exception)    \n            at ExecuteInRunspace(Closure , FunctionContext )\n\nTitle     : WorkflowNativeActivityNotSupported\nRepro     : .\\runlite -suite Scripting.CoreLanguage.CoreFunctionality -pri  -test WorkflowNativeActivityNotSupported\nErrorText : Exception calling \"Invoke\" with \"0\" argument(s): \"Should have received an error from excluded activity: 'CommandNotFound,Microsoft.PowerShell.Commands.InvokeExpressionCommand' does not equal \n            'System.NotSupportedException,Microsoft.PowerShell.Commands.InvokeExpressionCommand' CallStack: Asserts.ps1: line 87 <- Asserts.ps1: line 219 <- Lite.Scripting.CoreLanguage.CoreFunctionality.ps1: line 238\" \n            System.Management.Automation.MethodInvocationException: Exception calling \"Invoke\" with \"0\" argument(s): \"Should have received an error from excluded activity: \n            'CommandNotFound,Microsoft.PowerShell.Commands.InvokeExpressionCommand' does not equal 'System.NotSupportedException,Microsoft.PowerShell.Commands.InvokeExpressionCommand' CallStack: Asserts.ps1: line 87 <- Asserts.ps1: \n            line 219 <- Lite.Scripting.CoreLanguage.CoreFunctionality.ps1: line 238\" ---> System.Management.Automation.RuntimeException: Should have received an error from excluded activity: \n            'CommandNotFound,Microsoft.PowerShell.Commands.InvokeExpressionCommand' does not equal 'System.NotSupportedException,Microsoft.PowerShell.Commands.InvokeExpressionCommand' CallStack: Asserts.ps1: line 87 <- Asserts.ps1: \n            line 219 <- Lite.Scripting.CoreLanguage.CoreFunctionality.ps1: line 238    at System.Management.Automation.Runspaces.PipelineBase.Invoke(IEnumerable input)    at System.Management.Automation.Runspaces.Pipeline.Invoke()    \n            at CallSite.Target(Closure , CallSite , Object )    --- End of inner exception stack trace ---    at System.Management.Automation.ExceptionHandlingOps.CheckActionPreference(FunctionContext funcContext, Exception exception)  \n              at ExecuteInRunspace(Closure , FunctionContext )\n\nTitle     : ScriptCmdletUnderConstrainedLanguageFailing\nRepro     : .\\runlite -suite Scripting.CoreLanguage.CoreLanguageTest -pri  -test ScriptCmdletUnderConstrainedLanguageFailing\nErrorText : Exception calling \"Invoke\" with \"0\" argument(s): \"The term 'Invoke-AsWorkflow' is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was \n            included, verify that the path is correct and try again.\" System.Management.Automation.MethodInvocationException: Exception calling \"Invoke\" with \"0\" argument(s): \"The term 'Invoke-AsWorkflow' is not recognized as the name \n            of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again.\" ---> System.Management.Automation.CommandNotFoundException: \n            The term 'Invoke-AsWorkflow' is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again.   \n             at System.Management.Automation.Runspaces.PipelineBase.Invoke(IEnumerable input)    at System.Management.Automation.Runspaces.Pipeline.Invoke()    at CallSite.Target(Closure , CallSite , Object )    --- End of inner \n            exception stack trace ---    at System.Management.Automation.ExceptionHandlingOps.CheckActionPreference(FunctionContext funcContext, Exception exception)    at ExecuteInRunspace(Closure , FunctionContext )\n\nTitle     : ScriptCmdletUnderConstrainedLanguagePassing\nRepro     : .\\runlite -suite Scripting.CoreLanguage.CoreLanguageTest -pri  -test ScriptCmdletUnderConstrainedLanguagePassing\nErrorText : Exception calling \"Invoke\" with \"0\" argument(s): \"The term 'Invoke-AsWorkflow' is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was \n            included, verify that the path is correct and try again.\" System.Management.Automation.MethodInvocationException: Exception calling \"Invoke\" with \"0\" argument(s): \"The term 'Invoke-AsWorkflow' is not recognized as the name \n            of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again.\" ---> System.Management.Automation.CommandNotFoundException: \n            The term 'Invoke-AsWorkflow' is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again.   \n             at System.Management.Automation.Runspaces.PipelineBase.Invoke(IEnumerable input)    at System.Management.Automation.Runspaces.Pipeline.Invoke()    at CallSite.Target(Closure , CallSite , Object )    --- End of inner \n            exception stack trace ---    at System.Management.Automation.ExceptionHandlingOps.CheckActionPreference(FunctionContext funcContext, Exception exception)    at ExecuteInRunspace(Closure , FunctionContext )\n\nTitle     : DRT - TestMonitorRunspaceInfo-0\nRepro     : \nErrorText : \n\nTitle     : DRT - TestNestedDebuggerAPIs-0\nRepro     : \nErrorText : \n\nTitle     : DRT - TestNestedStandaloneDebugger-0\nRepro     : \nErrorText : \n\nTitle     : DRT - TestNestedEmbeddedDebugger-0\nRepro     : \nErrorText : \n\nTitle     : DRT - TestRunspaceCollection-0\nRepro     : \nErrorText : \n\nTitle     : TestMonitorRunspaceInfo-0\nRepro     : .\\runlite -suite PowerShellDebuggerUnitTests.RunspaceDebuggingTests -pri  -test TestMonitorRunspaceInfo-0\nErrorText : Test method PowerShellDebuggerUnitTests.RunspaceDebuggingTests.TestMonitorRunspaceInfo threw exception:  System.MethodAccessException: Attempt by method \n            'PowerShellDebuggerUnitTests.RunspaceDebuggingTests.TestMonitorRunspaceInfo()' to access method 'System.Management.Automation.Internal.PSMonitorRunspaceInfo.get_NestedDebugger()' failed.     at \n            PowerShellDebuggerUnitTests.RunspaceDebuggingTests.TestMonitorRunspaceInfo()       at PowerShellDebuggerUnitTests.RunspaceDebuggingTests.TestMonitorRunspaceInfo()\n\nTitle     : TestNestedDebuggerAPIs-0\nRepro     : .\\runlite -suite PowerShellDebuggerUnitTests.RunspaceDebuggingTests -pri  -test TestNestedDebuggerAPIs-0\nErrorText : Test method PowerShellDebuggerUnitTests.RunspaceDebuggingTests.TestNestedDebuggerAPIs threw exception:  System.MethodAccessException: Attempt by method \n            'PowerShellDebuggerUnitTests.RunspaceDebuggingTests.TestNestedDebuggerAPIs()' to access method 'System.Management.Automation.StandaloneRunspaceDebugger..ctor(System.Management.Automation.Runspaces.Runspace)' failed.     at \n            PowerShellDebuggerUnitTests.RunspaceDebuggingTests.TestNestedDebuggerAPIs()       at PowerShellDebuggerUnitTests.RunspaceDebuggingTests.TestNestedDebuggerAPIs()\n\nTitle     : TestNestedStandaloneDebugger-0\nRepro     : .\\runlite -suite PowerShellDebuggerUnitTests.RunspaceDebuggingTests -pri  -test TestNestedStandaloneDebugger-0\nErrorText : Test method PowerShellDebuggerUnitTests.RunspaceDebuggingTests.TestNestedStandaloneDebugger threw exception:  System.MethodAccessException: Attempt by method \n            'PowerShellDebuggerUnitTests.RunspaceDebuggingTests.TestNestedStandaloneDebugger()' to access method 'System.Management.Automation.Debugger.get_IsPushed()' failed.     at \n            PowerShellDebuggerUnitTests.RunspaceDebuggingTests.TestNestedStandaloneDebugger()       at PowerShellDebuggerUnitTests.RunspaceDebuggingTests.TestNestedStandaloneDebugger()\n\nTitle     : TestNestedEmbeddedDebugger-0\nRepro     : .\\runlite -suite PowerShellDebuggerUnitTests.RunspaceDebuggingTests -pri  -test TestNestedEmbeddedDebugger-0\nErrorText : Assert.IsTrue failed. FAIL: TestNestedEmbeddedDebugger: Expected nested debugger break all event to be received.    at PowerShellDebuggerUnitTests.RunspaceDebuggingTests.TestNestedEmbeddedDebugger()      at \n            PowerShellDebuggerUnitTests.RunspaceDebuggingTests.TestNestedEmbeddedDebugger()\n\nTitle     : TestRunspaceCollection-0\nRepro     : .\\runlite -suite PowerShellDebuggerUnitTests.RunspaceDebuggingTests -pri  -test TestRunspaceCollection-0\nErrorText : Test method PowerShellDebuggerUnitTests.RunspaceDebuggingTests.TestRunspaceCollection threw exception:  System.MethodAccessException: Attempt by method \n            'PowerShellDebuggerUnitTests.RunspaceDebuggingTests.TestRunspaceCollection()' to access method 'System.Management.Automation.Runspaces.Runspace.get_RunspaceDictionary()' failed.     at \n            PowerShellDebuggerUnitTests.RunspaceDebuggingTests.TestRunspaceCollection()       at PowerShellDebuggerUnitTests.RunspaceDebuggingTests.TestRunspaceCollection()\n\nTitle     : versioning\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : Microsoft.VS.TTest.TestFailureException: There were error records output from the script. Id: Microsoft.PowerShell.Commands.WriteErrorException,Assert, Id: ScriptHalted  ---> \n            Microsoft.PowerShell.Commands.WriteErrorException: Major build version of PowerShell should be 10    --- End of inner exception stack trace ---    at \n            Microsoft.Test.Management.Automation.ScriptTestFixture.ExecuteScriptFile(String scriptPath) Parameter 0: C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\utscripts\\Language\\versioning.ps1 Running script: \n            C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\utscripts\\Language\\versioning.ps1\n\nTitle     : TestFileSystemUNCPath\nRepro     : C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\TTest.exe /log\nErrorText : Microsoft.VS.TTest.TestFailureException: There were error records output from the script. Id: NativeCommandError, Id: NativeCommandErrorMessage, Id: PathNotFound,Microsoft.PowerShell.Commands.SetLocationCommand, Id: \n            Microsoft.PowerShell.Commands.WriteErrorException,Assert, Id: ScriptHalted  ---> System.Management.Automation.RemoteException: This shared resource does not exist.    --- End of inner exception stack trace ---    at \n            Microsoft.Test.Management.Automation.ScriptTestFixture.ExecuteScriptFile(String scriptPath) Parameter 0: C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\utscripts\\Namespaces\\TestFileSystemUNCPath.ps1 Running script: \n            C:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\utscripts\\Namespaces\\TestFileSystemUNCPath.ps1\n```\n",
      "created_at": "2016-02-13T03:28:53Z",
      "updated_at": "2016-02-13T03:28:53Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "## Name\n\nTestGetFormatDataAndExportFormatData\n\n## File\n\nC:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\utscripts\\Commands\\TestGetFormatDataAndExportFormatData.ps1\n\n## Repro\n\n```\n(Get-FormatData System.Diagnostics.Process).FormatViewDefinition.Count\n```\n\n## Expected\n\n4\n\n## Actual\n\n2\n\n**Issue file for failure:** #1278\n",
      "created_at": "2016-02-13T03:54:37Z",
      "updated_at": "2016-07-05T17:47:30Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "## Name\n- winblue_71908_HelpInfoUriForRemoteModule\n- remoteDiscovery-psSession-cimModule\n- remoteDiscovery-psSession-psModule\n\n## Missing cmdlets\n\nCmdlets `Import-PSSession` and `Export-PSSession` are missing, it's a known issue (ImplicitRemotingCommands.cs)\n",
      "created_at": "2016-02-13T04:03:18Z",
      "updated_at": "2016-02-18T02:09:13Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "## CmsMessageCommandsCore\n\nCmdlet `Protect-CmsMessage` is missing from **Microsoft.PowerShell.Security**\n\n## MessageRecipientByCert\n\nCmdlet `Get-PfxCertificate` is missing from **Microsoft.PowerShell.Security**\n",
      "created_at": "2016-02-13T04:08:59Z",
      "updated_at": "2016-02-13T04:10:03Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "## all workflow\n\nIncluding\n-  InvokeScriptWithRequiresModule \n- AliasAttributeTestForCmdletAdvFnAndWorkflow\n\nI messed up with install script and removed psworkflow module, please **ignore** these errors\n",
      "created_at": "2016-02-13T04:13:30Z",
      "updated_at": "2016-02-13T04:15:11Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "## Followup.Tests\n\nit's a problem with tests caused by CL 677290 and fixed in CL 679824\n",
      "created_at": "2016-02-13T04:26:19Z",
      "updated_at": "2016-02-13T04:26:19Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "## Name\n\nwinblue_191746_DSCModulePath\n\n## File\n\nC:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\utscripts\\Modules\\winblue_191746_DSCModulePath.ps1\n\n## Repro\n- It would not work if you run powershell side-by-side with `Start-DevPSGithub`, because process inherits`$env:PSModulePath`\n\n``` powershell\n$env:PSModulePath -match \"Program Files\\\\WindowsPowerShell\\\\Modules\"\n```\n\n## Expected\n\nTrue\n\n## Actual\n\nFalse\n",
      "created_at": "2016-02-13T04:31:57Z",
      "updated_at": "2016-02-13T09:00:40Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "## Name\n\nTestNewPSDriveWithCredential\n\n## File\n\nC:\\PowerShellTests\\PowerShell\\Win8\\PowerShell\\legacy\\utscripts\\Security\\TestNewPSDriveWithCredential.ps1\n\n## Repro\n\nSorry, repro is quite big, but I could not make it significantly smaller.\n\nSave this is a script and run it in an elevated powershell\n\n``` powershell\ntry\n{\n\n    # Create a new temporary user account and add it to the list of administrators.\n    # This account would be deleted as part of the cleanup process.\n    net user /add fileShareUser C1~eeFileShare | Out-NUll\n\n    # Fetch localized name for administrators group.\n    $identifier = new-object System.Security.Principal.SecurityIdentifier([System.Security.Principal.WellKnownSidType]\"BuiltinAdministratorsSid\", $null)  \n    $ntAccountWithDomain = $identifier.Translate([System.Security.Principal.NTAccount])  \n    $localizedGroupName = $ntAccountWithDomain.Value.split(\"\\\\\")[1]\n    net localgroup $localizedGroupName fileShareUser /add  | Out-NUll\n\n\n    $computerName = $env:Computername\n    $username2 = \"$computerName\\fileShareUser2\"\n    $password2 = ConvertTo-SecureString -AsPlainText \"C1~eeFile\" -Force\n    $cred2 = New-Object System.Management.Automation.PSCredential $username2,$password2\n    net user /add fileShareUser2 C1~eeFile  | Out-NUll\n\n    $tempDir = $env:SystemDrive\n\n    $share = \"\\\\$computerName\\TestNetworkPSDrive\"\n\n    New-Item $tempDir\\TestNetworkPSDrive -Type Directory | Out-Null\n    net share TestNetworkPSDrive=$tempDir\\TestNetworkPSDrive /grant:'fileShareUser,full' | Out-NUll\n\n    New-Item $tempDir\\TestNetworkPSDrive\\Source -Type Directory | Out-Null\n    New-Item $tempDir\\TestNetworkPSDrive\\Source\\TestFile.txt -Type File | Out-Null\n\n\n    $newDrive2 = New-PSDrive -Name TestDriveForFileSystemCredentials2 -Root $share -PSProvider FileSystem -Credential $cred2 \n    if ($newDrive2)\n    {\n        Write-Host \"Success\"\n    }\n    else\n    {\n        Write-Host \"Failed to create PSDrive\"\n    }\n\n    # The PSDrive \"TestDriveForFileSystemCredentials2\" is created with \"fileShareUser2\" user credentials which does not have access to the share.\n    # Hence when ever an attempt is made to access this \"TestDriveForFileSystemCredentials2\" PSDrive, an \"Access Denied exception woudl be thrown.\n    # This is a negative test case to make sure that if a PSDrive is created on a local share with user credentials that dont have access to the share, \n    # and operation on such a drive would result in \"Acccess Denied\" error.\n    Get-ChildItem TestDriveForFileSystemCredentials2:\\  -ErrorAction SilentlyContinue -ErrorVariable ev\n\n    # Deleting the PSDrive \"TestDriveForFileSystemCredentials2\" as its no longer required.\n    # This will delete the connection established to PSDrive \"TestDriveForFileSystemCredentials2\"\n    Remove-PSDrive -Name TestDriveForFileSystemCredentials2  | Out-NUll\n\n}\nfinally \n{\n    # Clean Up activity.\n    net share TestNetworkPSDrive \\\\$computerName /DELETE /Y | Out-NUll\n    Remove-Item -Path $tempDir\\TestNetworkPSDrive -Force -Recurse -ErrorAction SilentlyContinue | Out-NUll\n    net user /delete fileShareUser | Out-NUll\n    net user /delete fileShareUser2 | Out-NUll\n}\n\n\n```\n\n## Expected\n\nSuccess\n\n## Actual\n\n```\nNew-PSDrive : The specified drive root \"\\\\VSBOX\\TestNetworkPSDrive\" either\ndoes not exist, or it is not a folder.\nAt D:\\junk\\psdrive.ps1:32 char:18\n+ ... newDrive2 = New-PSDrive -Name TestDriveForFileSystemCredentials2 -Roo ...\n+                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    + CategoryInfo          : ReadError: (TestDriveForFileSystemCredentials2:P\n   SDriveInfo) [New-PSDrive], IOException\n    + FullyQualifiedErrorId : DriveRootError,Microsoft.PowerShell.Commands.New\n   PSDriveCommand\n\nFailed to create PSDrive\nRemove-PSDrive : Cannot find drive. A drive with the name\n'TestDriveForFileSystemCredentials2' does not exist.\nAt D:\\junk\\psdrive.ps1:50 char:5\n+     Remove-PSDrive -Name TestDriveForFileSystemCredentials2  | Out-NU ...\n+     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    + CategoryInfo          : ObjectNotFound: (TestDriveForFileSystemCredentia\n   ls2:String) [Remove-PSDrive], DriveNotFoundException\n    + FullyQualifiedErrorId : DriveNotFound,Microsoft.PowerShell.Commands.Remo\n   vePSDriveCommand\n```\n",
      "created_at": "2016-02-13T09:24:32Z",
      "updated_at": "2016-02-13T09:24:32Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "Update: I did a run with changes from #554 and result is little bit better.\nStill cannot figure what part of `Update-PSCore.cmd` removes psworkflow module\n\n```\nBVT: total=500 Pass=497 Fail=3 Error=0 Skip=0 Unspecified=0 Blocked=0 \nDRT: total=3238 Pass=3164 Fail=53 Error=1 Skip=6 Unspecified=14 Blocked=0 \nP0: total=5881 Pass=5717 Fail=78 Error=0 Skip=72 Unspecified=0 Blocked=14 \n```\n",
      "created_at": "2016-02-18T01:58:51Z",
      "updated_at": "2016-02-18T02:11:34Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "Awesome to see :smile: \n",
      "created_at": "2016-02-18T02:04:41Z",
      "updated_at": "2016-02-18T02:04:41Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "Made another run with the right version of `Update-PSCore.cmd` (which doesn't replace powershell.exe and doesn't remove psworkflow module). Got even better results :dancers: \n\n```\nBVT: total=500 Pass=500 Fail=0 Skip=0 Unspecified=0 Blocked=0 \nDRT: total=3238 Pass=3186 Fail=32 Skip=6 Unspecified=14 Blocked=0 \nP0: total=6244 Pass=6112 Fail=46 Skip=72 Unspecified=0 Blocked=14 \n```\n",
      "created_at": "2016-02-20T04:08:41Z",
      "updated_at": "2016-02-20T04:08:41Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "Sweet!\n",
      "created_at": "2016-02-20T04:22:55Z",
      "updated_at": "2016-02-20T04:22:55Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "/cc @paulcallen \n",
      "created_at": "2016-02-22T18:49:02Z",
      "updated_at": "2016-02-22T18:49:02Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "@vors What do we need to do to move forward now?\n",
      "created_at": "2016-03-01T22:36:11Z",
      "updated_at": "2016-03-01T22:36:11Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "1. Address issues that I already identified (probably create separate bugs for them)\n2. After that, make a new run. Instruction is available here https://github.com/PowerShell/Internal-PowerShellTeam-Tools/blob/master/PowerShellDevelopersWiki/Workflow.md#testing\n\nYou should be able to work on it without my help. but I'm happy to assist if needed.\n",
      "created_at": "2016-03-01T23:09:02Z",
      "updated_at": "2016-03-01T23:09:02Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "Use matching versions of VMQuick (or vhd, if you don't like VMQuick) and tests that you are deploying. Also, I always run tests on two machines: one clean, one with my changes. The first one helps to ignore some failures, that not caused by your changes.\n\n@andschwa also, do you want me to update `source-depot` branch?\n",
      "created_at": "2016-03-01T23:11:21Z",
      "updated_at": "2016-03-01T23:11:21Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "How do I know what version of VMQuick and tests to use?\n",
      "created_at": "2016-03-01T23:17:48Z",
      "updated_at": "2016-03-01T23:17:48Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "Go to VMQuick, get the last available one from nebula from `rs1_srv_ps_dev` branch.\nI.e. `14272.1000.amd64fre.rs1_srv_ps_dev.160226-1500_server_serverdatacenter_en-us.vhd` the important part is **160226**\n\nThen find a corresponding build folder on `\\\\winbuilds\\release\\rs1_srv_ps_dev`, in this case it's `14272.1000.160226-1500`. This is the `$build` from\n\n``` powershell\n$build = '14257.1000.160201-1500'\n$admin = \"\\\\winbuilds\\release\\rs1_srv_ps_dev\\$build\\amd64fre\\bin\\admin\"\n& $admin\\admintest\\ci\\InstallProject.ps1 -ProjectFilePath \"$admin\\admintest\\ci\\Project.PowerShell.xml\" -targetDirectory \"c:\\PowerShellTests\\\"\n```\n\nUPD: You can get the same string with concatenating two substrings from vhd name as well. (I just never did it for some reason)\n",
      "created_at": "2016-03-01T23:25:06Z",
      "updated_at": "2016-03-01T23:28:56Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "Thanks, I will start this tomorrow and see where I get :smile: \n",
      "created_at": "2016-03-01T23:38:19Z",
      "updated_at": "2016-03-01T23:38:19Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "@andschwa please take care about this PR https://github.com/PowerShell/psl-monad/pull/27\n",
      "created_at": "2016-03-02T01:42:27Z",
      "updated_at": "2016-03-02T01:42:27Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "We've got the source depot changes merged, I will take care of this right after v0.2.0 (which I want for Tuesday's demo). I should be able to plow through quite a few M/T/W, but will be OOF T/F due to multiple wisdom teeth getting removed :wrench:.\n",
      "created_at": "2016-03-05T00:54:01Z",
      "updated_at": "2016-03-05T00:54:01Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "UPD: I checked-in psl-monad source from master (on 3/7) to **rs1_srv_oob** branch today. We should get some STEX runs (or build breaks) soon.\n",
      "created_at": "2016-03-09T00:58:10Z",
      "updated_at": "2016-03-09T00:58:10Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "I'm going to do a new run with `14282.1000.amd64fre.rs1_srv_ps_dev.160306-1500` as it's the most recent build with a baseline pass.\n",
      "created_at": "2016-03-14T21:53:40Z",
      "updated_at": "2016-03-14T21:53:40Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "I got a test VM and the tests themselves deployed. Now I need to get a development copy of PS deployed to it.\n",
      "created_at": "2016-03-15T00:17:29Z",
      "updated_at": "2016-03-15T00:17:29Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "Yeah new test run is happening. Sweet.\n",
      "created_at": "2016-03-15T23:34:34Z",
      "updated_at": "2016-03-15T23:34:34Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "~~I just had a grand total of 3 BVT/DRT failures.~~\n",
      "created_at": "2016-03-15T23:58:38Z",
      "updated_at": "2016-03-16T17:35:49Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "@andschwa WUUUT NO WAY\n",
      "created_at": "2016-03-16T00:07:45Z",
      "updated_at": "2016-03-16T00:07:45Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "How about all the above analysed problems, can you verify that they are gone? Are you sure you deployed github bits? \n",
      "created_at": "2016-03-16T00:09:16Z",
      "updated_at": "2016-03-16T00:09:16Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "I.e. `start-process rdpclip` still doesn't work\n",
      "created_at": "2016-03-16T00:13:39Z",
      "updated_at": "2016-03-16T00:13:39Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "`Update-PSCore` doesn't error very nicely :smile: doing a new run now.\n",
      "created_at": "2016-03-16T17:36:16Z",
      "updated_at": "2016-03-16T17:36:16Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "Can you post a summary of new results?\n",
      "created_at": "2016-03-17T01:48:20Z",
      "updated_at": "2016-03-17T01:48:20Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "Well crap. I can't copy from the VM. It'll have to wait until I don't have nested RDP sessions.\n",
      "created_at": "2016-03-18T02:00:56Z",
      "updated_at": "2016-03-18T02:00:56Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "@andschwa you cannot copy because one of the tests kills `rdpclip.exe` and then it failed to start it (see above for details). Just start the process by hands, and you will copy it just fine.\n",
      "created_at": "2016-03-18T02:02:56Z",
      "updated_at": "2016-03-18T02:02:56Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "I mean through the browser plugin, it doesn't let my copy text back to my desktop.\n",
      "created_at": "2016-03-18T02:09:26Z",
      "updated_at": "2016-03-18T02:09:26Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "I have to rerun tests with new SD changes.\n",
      "created_at": "2016-03-18T22:22:08Z",
      "updated_at": "2016-03-18T22:22:08Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "Update on this:\n\nSince @JumpingYang001, @TingLiu6, and @brycem are porting the BVT/DRT tests to Open PowerShell, it's going to be much easier to fix the BVT/DRTs as failures are found during porting, since they're immediately reproducible with local tests and CI (in contrast to spinning up a separate test VM and having to deploy new bits for every attempted repro).\n\nSo our current plan is to do that until the test porting is done, and then afterward re-run it through the old system to ensure nothing was missed.\n\n/cc @paulcallen \n",
      "created_at": "2016-04-14T19:22:39Z",
      "updated_at": "2016-04-14T19:22:39Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "Today's results\n\n```\nBVT: total=493 Pass=487 Fail=6 Error=0 Skip=0 Unspecified=0 Blocked=0 \nDRT: total=2745 Pass=2598 Fail=116 Error=11 Skip=6 Unspecified=14 Blocked=0 \nP0: total=5895 Pass=5595 Fail=206 Error=9 Skip=71 Unspecified=0 Blocked=14\n```\n\n:(\n",
      "created_at": "2016-05-13T02:44:51Z",
      "updated_at": "2016-05-13T02:44:51Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "What are the failures?\n",
      "created_at": "2016-05-13T03:07:08Z",
      "updated_at": "2016-05-13T03:07:08Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "Here is the list, I send more detailed log in an email, becasue it's too big\n\nNewFileCatalogFolder-0\nNewFileCatalogFolderWithSubFolders-0\nNewFileCatalogWithSingleFile-0\nNewFileCatalogForFilesThatDoNotSupportEmbeddedSignatures-0\nNewFileCatalogMultipleFilesSameRoot-0\nNewFileCatalogWithMutipleFoldersAndFiles-0\nNewFileCatalogVersion2WithMutipleFoldersAndFiles-0\nNewAndTestFileSignedCatalog-0\nNewFileCatalogFolderWhenCatlogFileIsCreatedInsideSameFolder-0\nNewFileCatalogWithUnicodeCharactersInFileNames-0\nTestCatalogWhenNewFileAddedtoFolderBeforeValidation-0\nTestCatalogWhenNewFileDeletedFromFolderBeforeValidation-0\nTestCatalogWhenFileContentModifiedBeforeValidation-0\nTestCatalogWhenFileRenamedBeforeValidation-0\nTestCatalogWhenFolderRenamedBeforeValidation-0\nTestCatalogWhenFileRelativePathChangedBeforeValidation-0\nNewFileCatalogDuplicateRelativePaths-0\nTestFileCatalogDuplicateRelativePaths-0\nNewFileCatalogUnknownVersion-0\nTestCatalogSkipSingleFileDuringValidation-0\nTestCatalogSkipCertainFileTypeDuringValidation-0\nTestCatalogSkipWildCardPatternDuringValidation-0\nTestCatalogSkipMuitplePattensDuringValidation-0\nChanges first and last name with one Example-0\nChanges first and last name with one Example, and three inputs-0\nChanges first and last name with two Examples-0\nChanges first and last name with one dictionary example-0\nChanges first and last name with two dictionary example-0\nReplace by empty-0\nverifies automatic property generation-0\nverifies property overflow generation-0\nverifies property renaming-0\nverifies property typing of numbers-0\nverifies property typing of TimeSpan-0\nverifies property typing of DateTime-0\nverifies property typing of Char-0\nverifies empty strings don't turn into INTs-0\nverifies property typing of String-0\nverifies the ability to change the delimiter-0\nverifies that only matching text gets parsed-0\nverifies that a good error message is returned from an invalid regular expression-0\nTests Invoke-History on a cmdlet that generates output on all streams-0\nShouldNotHaveV2\nValue1AndValue2NotBothNull\nMeasureTextCombinationTest\nTestGetFormatDataAndExportFormatData\nTestCase1\nInvokeHistoryLastEntry\nSuiteSetupOrCleanUpFailure\nTest-ISS-CreateDefault2\nGetResourceStringTest\nUpdateHelpWhatIf\nLoggerUnfoldArray-0\nModuleEnhancementForOperateCoreModule-0\nAliasAttributeTestForCmdletAdvFnAndWorkflow-0\nVerifies Information stream on workflow-0\nVerifies InformationVariable in workflow compilation-0\nGenericExceptionTest1\nSuiteSetupOrCleanUpFailure\nGetMshSnapinBlankNoParameterTestNoMshSnapinsLoaded\nSuiteSetupOrCleanUpFailure\nSuiteSetupOrCleanUpFailure\nSuiteSetupOrCleanUpFailure\nSuiteSetupOrCleanUpFailure\nSuiteSetupOrCleanUpFailure\nwinblue_121450\nPassingRefToNonRef\nPassingNonRefToRefandOut\nremoteDiscovery-cimSession-bug769014\nremoteDiscovery-cimSession-cimModule\nremoteDiscovery-cimSession-mixedModule\nremoteDiscovery-psSession-cimModule\nTestCmdletDefinitionSigning\nTestNewPSDriveWithCredential\nbug-win8-134523-tooMuchPositionalBinding\nbug-win8-138600-createInstanceAndKeys\nbug-win8-144782-modifyInstanceAndNewValuesFromInputObject\nbug-win8-145006-duplicateClientSideVerboseMsg\nbug-win8-145681-switchParametrerAsMethodParameter\nbug-win8-162870-childJobsHaveResults\nbug-win8-164685-caseInsensitivityOfCharAndString\nbug-win8-167425-blockingEnumerator\nbug-win8-169347-errorWhenAssociationQueryDoesntReturnAnything\nbug-win8-169371-invocationInfoInErrors\nbug-win8-201853-errorsFromEnumRelatedAddType\nbug-win8-225318-suppressingOfPassThruProcessing\nbug-win8-232409-crashWhenErrorInOnNext\nbug-win8-239206-arrayOfEnums\nbug-win8-241907-specialCharactersInEnumIdentifiers\nbug-win8-265424-opopt-vs-paramsets\nbug-win8-274981-streaming-vs-regularResult\nbug-win8-387140-enumerateInsteadOfWql\nbug-win8-413565-cdxmlFlagToControlNotFoundErrors\nbug-win8-453462-nestedModulesVSrootCdxmlModule\nbug-win8-456908-parameterSetsForSameMethod\nbug-win8-483744-workflowCompilationWithRequiredCimModule\nbug-win8-489202-noSupportForShouldProcessInRemoteDcom\nbug-win8-528933-etsTypeStampingDoesntIntroduceDuplicates\nbug-win8-528933-stampingEtsTypeOnCmdletOutput\nbug-win8-538441-psshowcomputername\nbug-win8-60920-createModifyPassThru\nbug-win8-625700-interop-resourceUri\nbug-win8-645771-objNotFound-intVsEnum\nbug-win8-713939-noRtti-vs-intQueryableProperty\nbug-winblue-119609-secureString\ne2e-assoc\ne2e-extSem-debug\ne2e-extSem-error\ne2e-extSem-progress\ne2e-extSem-shouldProces\ne2e-extSem-verbose\ne2e-extSem-warning\ne2e-help\ne2e-inst-deleteInstance\ne2e-inst\ne2e-operationOptions\ne2e-outParameterStreaming\ne2e-passthru\ne2e-query-notFound\ne2e-query\ne2e-serialization\ne2e-session-stickyness\ne2e-shouldProcess-clientSide-deleteInstance\ne2e-shouldProcess-clientSide-inst\ne2e-stat\nxsd-cmdletmetadata\nxsd-cmdletparams-positionOrder\nxsd-cmdletparams-pscredential\nxsd-cmdletparams-pstypename\nxsd-cmdletparams\nxsd-empty\nxsd-enums\nxsd-inst-1param2psets\nxsd-inst-defpset\nxsd-inst-getcmdletoverride\nxsd-inst-getparamsoverride\nxsd-inst-queryTypes\nxsd-inst\nxsd-outparams\nxsd-outputTypeAttribute\nxsd-outputTypeAttribute2\nxsd-passthru\nxsd-privatedata\nxsd-stat-1param2psets\nxsd-stat-defpset\nxsd-stat\nxsd-validation\nDefaultPromptingExceptionCtorTest\nExposeBug921858\nGetPSDriveDetectsNetworkMappedDrive\nRemoveNetworkMappedDrive\nSuiteSetupOrCleanUpFailure\nPowerShellTranscriptionCapturesNativeExes\nExposeSetLocationUNCProviderQualifiedPathBug\nExposeSetLocationUNCDirectPathBug\nClearContent\nGetContent\nGetItem\nGetItemMultipleStreams\nRemoveItem\nSetContent\nSystem.Management.Automation.Remoting.UnitTests.WSManPluginEntryDelegatesUnitTests.ConstructionCreatesDelegates\nSystem.Management.Automation.Remoting.UnitTests.WSManPluginEntryDelegatesUnitTests.InitPluginAssignsWorkerPtrs\nSystem.Management.Automation.Remoting.UnitTests.WSManPluginEntryDelegatesUnitTests.NullInputIsNoOp\nSystem.Management.Automation.Remoting.UnitTests.WSManPluginShellSessionUnitTests.CloseCommandOperationDoesNothingIfUnmatchedContext\nSystem.Management.Automation.Remoting.UnitTests.WSManPluginShellSessionUnitTests.GetCommandSessionReturnsNullIfNoCommandSession\nDRT - TestCreateProcessPipeName-0\nDRT - TestCreateNamedPipeServer-0\nDRT - TestCreateNamedPipeClient-0\nDRT - TestCreateContainerNamedPipeClient-0\nDRT - TestClientServerConnect-0\nDRT - TestNamedPipeDuplicateServerPipe-0\nDRT - TestNamedPipeClientSessionTransportManager-0\nTestCreateProcessPipeName-0\nTestCreateNamedPipeServer-0\nTestCreateNamedPipeClient-0\nTestCreateContainerNamedPipeClient-0\nTestClientServerConnect-0\nTestNamedPipeDuplicateServerPipe-0\nTestNamedPipeClientSessionTransportManager-0\nActivityWithScriptBlock\nWorkflowFullLanguage\nCIMCmdletUnderConstrainedLanguage\nDefaultExecutionContextSessionStateLanguageModeInRemoteSession\nScriptCmdletUnderConstrainedLanguageFailing\nScriptCmdletUnderConstrainedLanguagePassing\nDRT - TestMonitorRunspaceInfo-0\nDRT - TestNestedDebuggerAPIs-0\nDRT - TestNestedStandaloneDebugger-0\nDRT - TestNestedEmbeddedDebugger-0\nDRT - TestRunspaceCollection-0\nTestMonitorRunspaceInfo-0\nTestNestedDebuggerAPIs-0\nTestNestedStandaloneDebugger-0\nTestNestedEmbeddedDebugger-0\nTestRunspaceCollection-0\nactionpreference\nversioning\nSuiteSetupOrCleanUpFailure\nTestFileSystemUNCPath\n",
      "created_at": "2016-05-13T03:10:40Z",
      "updated_at": "2016-05-13T03:10:40Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "I see a couple themes here:\n\nMissing cmdlets, at least one which I'm sure comes from the file that hasn't been compiled into SMA yet.\n\nUnfound resources, since the names of the resources are different in PS with CLI than with Razzle, and the FullCLR build doesn't have all the assemblies the tests use. Thus it shares with assemblies built by Razzle, and so look for resources under a different name.\n\nTo eliminate build differences (which will exist until the rest of PS for FullCLR is ported), the tests need to be run on a build where our changes and additional file are applied to SD. I don't think mixing assemblies will yield accurate results. This would probably get us back to our February results.\n\nAlso I assumed this was for the FullCLR build. We need to see a CoreCLR set as well, with the same build caveats.\n",
      "created_at": "2016-05-13T03:31:20Z",
      "updated_at": "2016-05-13T03:31:20Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "Applying source can help in eliminating noise, but it doesn't bring us closer to the end goal, since we don't plan to checking OpenPS code into sd.\n\nI think it's more valuable to start building all the necessary assemblies to bridge the gap.\n",
      "created_at": "2016-05-13T03:45:18Z",
      "updated_at": "2016-05-13T03:45:18Z"
    },
    {
      "author": "andschwa",
      "author_association": "MEMBER",
      "body": "I agree completely, that's the best solution. We'll have a lot of test noise until then, and that's probably okay.\n\nGetting everything built wil also codify the differences among the flavors' dependencies, which is information we need anyway.\n",
      "created_at": "2016-05-13T05:49:48Z",
      "updated_at": "2016-05-13T05:49:48Z"
    },
    {
      "author": "adityapatwardhan",
      "author_association": "MEMBER",
      "body": "Individual issues have been filed for BVT/DRT failures.\n",
      "created_at": "2016-07-29T17:39:46Z",
      "updated_at": "2016-07-29T17:39:46Z"
    }
  ],
  "created_at": "2016-02-12T23:20:38Z",
  "labels": [
    "BVT/DRT"
  ],
  "number": 543,
  "state": "closed",
  "title": "BVT/DRT Regressions",
  "updated_at": "2016-07-29T17:39:51Z"
}