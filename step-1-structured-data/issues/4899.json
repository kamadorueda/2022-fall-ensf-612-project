{
  "_url": "https://github.com/PowerShell/PowerShell/issues/4899",
  "author": "markekraus",
  "body": "# Problem\r\n\r\nCurrently users only have 2 options for dealing with Server SSL/TLS Certificates with `Invoke-WebRequest` and `Invoke-RestMethod`: the default validation and to skip validation. Some scenarios warrant tighter security on web requests where a certificate is not fully trusted by the host environment but is known to be trusted by the user. This could include internal web APIs that use a self signed certificate with a specific thumbprint or from a known CA that is not trusted by the host. Or if a user wishes to ensure a certain CA/Thumbprint/Subject is blocked (a known bad actor).\r\n\r\nAlso `[System.Net.ServicePointManager]::ServerCertificateValidationCallback` has no effect in Core and `HttpClient` only uses the settings provided by `HttpClientHandler`.\r\n\r\n# Proposal\r\n\r\nAdd a parameter of type `Func<HttpRequestMessage,X509Certificate2,X509Chain,SslPolicyErrors,Boolean>` that accepts a ScriptBlock to both Web Cmdlets. This is to be set on `HttpClientHandler.ServerCertificateCustomValidationCallback`. The `-SkipCertificateCheck` would have priority, meaning if both were supplied either a parameter exception is thrown or `-SkipCertificateCheck` would be applied and the callback ignored. \r\n\r\nThe Parameter will be named `CertificateValidationScript`\r\n\r\n# For consideration\r\n\r\n* What to name this parameter?\r\n* Throw or no throw on clash with `-SkipCertificateCheck`?",
  "closed_at": null,
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "For name of the parameter we could start discussion with `ServerCertificateCustomValidationCallback`.\r\n\r\nAs for ScriptBlock we need remember about binary cmdlets too.",
      "created_at": "2017-09-23T19:03:41Z",
      "updated_at": "2017-09-23T19:03:41Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "I don't think `Callback` fits well into the PowerShell user's domain.  Also, `Custom` is a bit redundant IMO.  \r\n\r\nHow about `ServerCertificateValidationAction`?  Or may since the other parameter is just `-SkipCertificateCheck` (not SkipServerCertificateCheck), maybe the parameter should be just `CertificateValidationAction`?",
      "created_at": "2017-09-23T19:35:49Z",
      "updated_at": "2017-09-23T19:35:49Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov I believe there is a way to accept both binary and shell friendly callbacks. I need to find an example to borrow from, but I'm sure I have seen that done somewhere before. I just can't remember where. But before I go down that rabit hole, is this something that really needs considering? The Web Cmdlets inherit from `PSCmdLet`, not `Cmdlet` there is a bit of an understanding there that it will be running inside a PowerShell runspace, a ScriptBlock in that scenario is probably no more or less cumbersome than `Func<HttpRequestMessage,X509Certificate2,X509Chain,SslPolicyErrors,Boolean>`\r\n\r\n\r\n@rkeithhill  `Action` hmm. I don't think that is a PowerShell friendly name either. `Script` maybe. `CertificateValidationScript`, `CertificateValidationOverride` hmm. \r\n\r\n",
      "created_at": "2017-09-23T21:07:55Z",
      "updated_at": "2017-09-23T21:07:55Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "`Action` is used in a number of commands including `Set-PSBreakpoint` and `Register-ObjectEvent`.  Fortunately, this sort of thing is easy to analyze in PowerShell e.g.:\r\n```powershell\r\n15:10ms> (gcm -CommandType Cmdlet).ParameterSets.Parameters.Where({$_.ParameterType -match 'ScriptBlock'}) | Group Name\r\n| Sort Count -Descending\r\n\r\nCount Name                      Group\r\n----- ----                      -----\r\n   15 ScriptBlock               {System.Management.Automation.CommandParameterInfo, System.Management.Automation.Com...\r\n    7 Action                    {System.Management.Automation.CommandParameterInfo, System.Management.Automation.Com...\r\n    3 InitializationScript      {System.Management.Automation.CommandParameterInfo, System.Management.Automation.Com...\r\n    3 Expression                {System.Management.Automation.CommandParameterInfo, System.Management.Automation.Com...\r\n    1 TransactedScript          {System.Management.Automation.CommandParameterInfo}\r\n    1 FilterScript              {System.Management.Automation.CommandParameterInfo}\r\n    1 End                       {System.Management.Automation.CommandParameterInfo}\r\n    1 Process                   {System.Management.Automation.CommandParameterInfo}\r\n    1 Begin                     {System.Management.Automation.CommandParameterInfo}\r\n    1 RemainingScripts          {System.Management.Automation.CommandParameterInfo}\r\n```\r\nHowever, both `Action` and `ScriptBlock` are used as the entire parameter name.  OTOH `Script` is used as a common suffix.  So your suggestion of `CertificateValidationScript` is probably the best parameter name.",
      "created_at": "2017-09-23T23:09:25Z",
      "updated_at": "2017-09-23T23:09:59Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "> As for ScriptBlock we need remember about binary cmdlets too.\r\n\r\nYou can always expose a public property that is not marked with `[Parameter]` that is a delegate type.\r\n",
      "created_at": "2017-09-23T23:13:08Z",
      "updated_at": "2017-09-23T23:13:08Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "Since I don't deal with binaries that talk directly to PowerShell, what exactly is the problem?\r\n\r\nFrom what I can tell, if I type the parameter as a `Func<HttpRequestMessage,X509Certificate2,X509Chain,SslPolicyErrors,Boolean>` which is the same type as `HttpClientHandler.ServerCertificateCustomValidationCallback`, PowerShell script users will be able to pass a `ScriptBlock` to it. \r\n\r\nWill this some how cause problems for Binary users?\r\n\r\n",
      "created_at": "2017-09-24T00:06:11Z",
      "updated_at": "2017-09-24T00:06:11Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "When you are writing a binary cmdlet you can [invoke other binary cmdlets](https://msdn.microsoft.com/en-us/library/ms714876(v=vs.85).aspx).  While you can create ScriptBlocks in C#, I guess it might be a little clunky to use that instead of a delegate.  OTOH I'm not sure how common this scenario is.  I've done this before but pretty rarely and never with something that took a delegate/ScriptBlock.  OTOH if your parameter type is already a delegate then problem solved.  :-)\r\n",
      "created_at": "2017-09-24T01:07:05Z",
      "updated_at": "2017-09-24T01:07:05Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "All good then, that was the plan all along. I just wasn't clear in my proposal. \ud83d\ude04 \r\n\r\nSide note: The Web Cmdlets derive from `PSCmdlet` and not `Cmdlet` and cannot be invoked that way. They can only be invoked using `PowerShell.Create()`, `AddCommand()`, and `AddParameter()`. I guess a ScriptBlock would still be problematic that way.",
      "created_at": "2017-09-24T09:49:21Z",
      "updated_at": "2017-09-24T10:04:04Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "OK, I have a working example [here](https://github.com/markekraus/PowerShell/tree/WebCmdletsCertificateValidationScript).\r\n\r\n1 Problem: since the callback is run async the runspace is not available in that thread. To work around this, I am wrapping the provided delegate with code that creates the runspace, calls the delegate, then cleans up the runspace. This works fine. However, this means that there is no access to the current session state (variables, modules, functions, etc). \r\n\r\nI'm not sure it needs to. If this is properly documented that the code in the script runs in its own context, it should be fine.  I don't want to make an overcomplicated feature for something that has a limited target audience.\r\n\r\nThoughts and Feedback welcome.\r\n\r\n```powershell\r\n# emulate -SkipCertificateCheck\r\n$script = { return $True }\r\nInvoke-RestMethod https://expired.badssl.com/ -CertificateValidationScript $Script\r\n\r\n# Block all Certs\r\n$script = { return $False }\r\nInvoke-RestMethod https://google.com/ -CertificateValidationScript $Script\r\n\r\n# -SkipCertificateCheck overrides -CertificateValidationScript\r\n$script = { return $False }\r\nInvoke-RestMethod https://expired.badssl.com/ -CertificateValidationScript $Script -SkipCertificateCheck\r\n\r\n# Accept a .NET Delegate:\r\nInvoke-RestMethod https://expired.badssl.com/ -CertificateValidationScript ([System.Net.Http.HttpClientHandler]::DangerousAcceptAnyServerCertificateValidator)\r\n```",
      "created_at": "2017-09-24T13:51:45Z",
      "updated_at": "2017-09-29T20:47:43Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@lzybkr Could you please comment - what is right way to implement the callback parameter?",
      "created_at": "2017-09-25T11:00:36Z",
      "updated_at": "2017-09-25T11:00:36Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "I'm not sure how important it is to support delegate callbacks - I'd imagine these cmdlets are mostly called from PowerShell scripts, so I would just take a scriptblock.\r\n\r\nThis mostly solves the problem of invoking the scriptblock without a runspace because PowerShell marshals the scriptblock.invoke() call back to the runspace creating the scriptblock - though this can cause a hang if that runspace is blocked in a .Net method.",
      "created_at": "2017-09-25T17:52:15Z",
      "updated_at": "2017-09-25T17:52:15Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@lzybkr so if I set `handler.ServerCertificateCustomValidationCallback` with the supplied script block, and that callback is called async, it will work with the current scope and without needing to initialize a runspace?",
      "created_at": "2017-09-25T19:10:34Z",
      "updated_at": "2017-09-25T19:10:34Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "It depends on what is happening on the cmdlet's thread.\r\n\r\nFirst, you will need to convert the scriptblock to the appropriate delegate type with `LanguagePrimitives.ConvertTo<DelegateType>(scriptblock)`.\r\n\r\nBut as I mentioned - if the cmdlet's thread is stuck in code outside of PowerShell, there is no way for that thread to invoke the scriptblock - it will instead hang waiting until PowerShell gets control of the thread again.\r\n\r\nIn an ideal case, you have:\r\n\r\n* Pipeline thread (cmdlet's thread):\r\nStarts some async code.\r\nReceive and **write** some output.\r\n\r\n* Background thread\r\nscriptblock.Invoke() - sends event to Runspace thread, blocking until event is processed\r\n\r\nThe important thing is to reach this [code](https://github.com/PowerShell/PowerShell/blob/fb286e6cf8480fe6df8a5a96311d6758e5c2b9f3/src/System.Management.Automation/engine/EventManager.cs#L1121) on the pipeline thread. This happens naturally if you execute some PowerShell script or write to the pipeline.\r\n\r\nIf neither of those things are happening, you need to do something like [this](https://github.com/PowerShell/PowerShell/blob/4c29f5768de7a3c5baec932c697d8281adfd3735/src/System.Management.Automation/engine/runtime/Operations/MiscOps.cs#L780) assuming you can regain control after calling into some non-PowerShell code. Async methods normally give you control, so hopefully you can make this work.\r\n\r\n",
      "created_at": "2017-09-25T19:59:18Z",
      "updated_at": "2017-09-25T19:59:18Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "https://github.com/markekraus/PowerShell/blob/7c8e5dd83d5c1c78fc67c288e28e5c956d0ecb88/src/Microsoft.PowerShell.Commands.Utility/commands/utility/WebCmdlet/CoreCLR/WebRequestPSCmdlet.CoreClr.cs#L180\r\n\r\nSo this ended up working for me:\r\n\r\n```csharp\r\nFunc<HttpRequestMessage,X509Certificate2,X509Chain,SslPolicyErrors,bool> certificateValidationDelegate = LanguagePrimitives.ConvertTo<Func<HttpRequestMessage,X509Certificate2,X509Chain,SslPolicyErrors,bool>>(CertificateValidationScript);\r\n\r\n// This wraps the supplied CertificateValidationScript and sets the PowerShell runspace in the async callback.\r\n// This allows for script users to supply a ScriptBlock and have it properly execute in the async thread.\r\nRunspace defaultRunspace = Runspace.DefaultRunspace;\r\nFunc<HttpRequestMessage,X509Certificate2,X509Chain,SslPolicyErrors,bool> validationCallBackWrapper = \r\n    delegate(HttpRequestMessage httpRequestMessage, X509Certificate2 x509Certificate2, X509Chain x509Chain, SslPolicyErrors sslPolicyErrors)\r\n    {\r\n        Runspace.DefaultRunspace = defaultRunspace;\r\n        Boolean result = certificateValidationDelegate.Invoke(httpRequestMessage, x509Certificate2, x509Chain, sslPolicyErrors);\r\n        return result;\r\n    };\r\n\r\nhandler.ServerCertificateCustomValidationCallback = validationCallBackWrapper;\r\n```\r\n\r\nI thought maybe there would be some kind of hang or crash, but it appears to work without issue and the ScriptBlock runs with access to the calling RunSpace. \r\n\r\n@iSazonov and @lzybkr Do you see anything wrong with this implementation? If not, I will clean it up, add tests, and do a PR.\r\n",
      "created_at": "2017-09-29T23:12:22Z",
      "updated_at": "2017-09-29T23:12:22Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Does \"using:variable\" work?",
      "created_at": "2017-09-30T18:07:07Z",
      "updated_at": "2017-09-30T18:07:07Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "I don't think so, but it's not needed.\r\n\r\n```powershell\r\n$Script = { return $condition }\r\n\r\n# will accept any cert\r\n$condition = $true\r\nInvoke-RestMethod https://expired.badssl.com/ -CertificateValidationScript $Script\r\n\r\n# will block any cert\r\n$condition = $false\r\nInvoke-RestMethod https://google.com/ -CertificateValidationScript $Script\r\n\r\n# Set a value ion calling scope\r\n$resulthash = @{}\r\n$Script = { $resulthash['thumbprint'] = $args[1].Thumbprint; return $true }\r\nInvoke-RestMethod https://google.com/ -CertificateValidationScript $Script\r\n$resulthash['thumbprint']\r\n```\r\n\r\nThese all work as would be expected., The first one bypasses the bad cert. the second one blocks the good cert, and the third one populates `$resulthash['thumbprint']` with the cert thumbprint. \r\n\r\nAs far as I can tell, the `using:` implementation only works in certain special ScriptBlock scenarios (such as those used in remote sessions). and is not a standard feature. It also doesn't look simple to implement.",
      "created_at": "2017-09-30T20:31:00Z",
      "updated_at": "2017-09-30T20:31:00Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov Actually, this made me realize something. \r\n\r\n```powershell\r\n$condition = $true\r\n$Script = { return $using:condition }\r\nInvoke-RestMethod https://expired.badssl.com/ -CertificateValidationScript $Script\r\n```\r\n\r\nThis hangs the thread. I'm guessing it's because the ScriptBlock throws a `UsingWithoutInvokeCommand` exception and never returns `true` or `false` from the delegate. A the very least I need to do some exception handling in the wrapper delegate.",
      "created_at": "2017-09-30T20:39:30Z",
      "updated_at": "2017-09-30T20:39:30Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "My concern is that users will expect that \"using:\" will work. Although if the script block is in the same context it don't make sense - silently ignore by exception handling?\r\n",
      "created_at": "2017-10-01T04:03:23Z",
      "updated_at": "2017-10-01T04:03:23Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov I don't think users should have that expectation, and if they do, then we would need to add it as a standard feature to all ScriptBlocks. `$using:` only works in very limited use cases (`Invoke-Command` and  DSC). The documentation about `$using:` is `about_Remote_Variables` and in this case, the variables are all local.\r\n\r\nWe could at least call it out in documentation that it is not supported in this instance. But, my opinion is that users should assume it is *not* available unless the documentation explicitly says that it is.\r\n\r\nThe plan is to treat all exceptions from the ScriptBlock as a failure. It would err on the side of caution and allow for `throw` be used.  Since `$using:` creates an exception in most cases, it would result in an ssl fail:\r\n\r\n```powershell\r\n$condition = $true\r\n$Script = { return $using:condition }\r\nInvoke-RestMethod https://expired.badssl.com/ -CertificateValidationScript $Script\r\n```\r\nThat would fail. To understand why, a user would only need to run `$Script.Invoke()` to find out that it is causing an exception.\r\n\r\n",
      "created_at": "2017-10-01T10:09:46Z",
      "updated_at": "2017-10-01T10:09:46Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I agree that if we document the parameter properly the behavior is good.\r\nThe same about `param()`.",
      "created_at": "2017-10-01T18:02:51Z",
      "updated_at": "2017-10-01T18:03:47Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "`param()` works\r\n\r\n```powershell\r\n$Script = {\r\n     param(\r\n        [System.Net.Http.HttpRequestMessage]\r\n        $HttpRequestMessage,\r\n\r\n        [System.Security.Cryptography.X509Certificates.X509Certificate2]\r\n        $X509Certificate2,\r\n\r\n        [System.Security.Cryptography.X509Certificates.X509Chain]\r\n        $X509Chain,\r\n\r\n        [System.Net.Security.SslPolicyErrors]\r\n        $SslPolicyErrors\r\n    )\r\n    Return (\r\n        $HttpRequestMessage.RequestUri.AbsoluteUri -eq 'https://www.google.com/' -and\r\n        $X509Certificate2.Subject -eq 'CN=www.google.com, O=Google Inc, L=Mountain View, S=California, C=US' -and\r\n        $X509Chain.ChainElements[2].Certificate.Thumbprint -eq 'DE28F4A4FFE5B92FA3C503D1A349A7F9962A8212' -and\r\n        $SslPolicyErrors -eq 'None'\r\n    )\r\n}\r\nInvoke-RestMethod https://www.google.com/ -CertificateValidationScript $Script\r\n```\r\n",
      "created_at": "2017-10-01T18:10:56Z",
      "updated_at": "2017-10-01T18:10:56Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "pr: #4970",
      "created_at": "2017-10-01T21:17:12Z",
      "updated_at": "2017-10-01T21:17:12Z"
    },
    {
      "author": "alx9r",
      "author_association": "NONE",
      "body": "@markekraus Is the intent that the usual certificate checks are omitted when the `-CertificateValidateScript` is provided?  If so, is there some way to invoke those checks from the user scriptblock?\r\n\r\nThe reason I am asking is that `Invoke-WebRequest` is currently very permissive of bad certificates (you can run [this test](https://raw.githubusercontent.com/alx9r/BootstraPS/master/Riders/badsslTests.ps1) for details) compared with browsers.\r\n\r\nI like the idea of using `-CertificateValidateScript` to perform _additional_ certificate verification to compensate for its current permissiveness but I wouldn't want to give up the checks that `Invoke-WebRequest` already performs.  \r\n\r\nIt seems like being able to enable and disable the built-in certificate check independently of `-CertificateValidateScript` would be the most flexible, but #4970 includes a test called \"Verifies Invoke-WebRequest -CertificateValidationScript is ignored when -SkipCertificateCheck is present\" which seems to imply that's not how it's intended to work.",
      "created_at": "2017-10-06T18:45:05Z",
      "updated_at": "2017-10-06T18:47:57Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@alx9r The intent is that the `ScriptBlock` completely replaces the usual logic associated with certificates with that of the logic supplied in the block.  \r\n\r\nHowever, you have access to the `SslPolicyErrors` object. The default check is to ensure that it is `None`\r\n\r\nThis is the equivalent PowerShell ScriptBlock implementation through my proposed PR\r\n\r\n```powershell\r\n$Script = { $SslPolicyErrors -eq 'None' }\r\nInvoke-RestMethod -Uri https://contoso.com -CertificateValidationScript $Script\r\n```\r\n\r\nUsing that, the behavior would not change from normal operation. That means you can use the `$SslPolicyErrors` as a fallback like this:\r\n\r\n```powershell\r\n$Script = {\r\n    if ($X509Certificate2.Subject -match 'Contoso') {\r\n        return $true\r\n    }\r\n    else {\r\n        return ($SslPolicyErrors -eq 'None')\r\n    }\r\n}\r\nInvoke-RestMethod -CertificateValidationScript $Script -Uri https://contoso.com/\r\n```\r\n\r\nThat would accept any certificate with `Contoso` in the subject and for any other certificate it would be processed as normal.",
      "created_at": "2017-10-06T19:01:01Z",
      "updated_at": "2017-10-06T19:22:04Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Using `SslPolicyErrors`  object is not obvious. Does it make sense to put it into parameters?",
      "created_at": "2017-10-06T19:08:49Z",
      "updated_at": "2017-10-06T19:08:49Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@alx9r Regarding the `-SkipCertificateCheck`, that has precedence. meaning, that if it is supplied all validation is ignored and any certificate will be accepted. \r\n\r\nPowerShell Core uses `HttpClient` and the current implementation of the Web Cmdlets creates a one-time-use `HttpClientHandler` for each call to the Web Cmdlets. The `HttpClientHandler` is the mechanism through which the certificate validation callback is implimented. That means that we have the option of implementing validation on a per-call basis. \r\n\r\nIn Windows PowerShell this was done through `[System.NetServicePointManager]::ServerCertificateValidationCallback` and that callback persisted through all calls to the Web Cmdlets. To emulate the behavior in core you would use the following:\r\n\r\n```powershell\r\n$Script = { <# whatever validation code #> }\r\n$PSDefaultParameterValues['*:ServerCertificateValidationCallback'] = $Script\r\n```\r\n\r\nTo allow for a one off command override the default, `-SkipCertificateCheck` is used.",
      "created_at": "2017-10-06T19:15:41Z",
      "updated_at": "2017-10-06T19:15:41Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov Parameters for what? the `SslPolicyErrors` object is passed to the user supplied callback by the `HttpClientHandler` during SSL key exchange. In my PR it is already being passed as `$SslPolicyErrors` \r\n\r\nhttps://github.com/markekraus/PowerShell/blob/06ae9e2219b900e80f7fec20a0e52d28e55a7256/src/Microsoft.PowerShell.Commands.Utility/commands/utility/WebCmdlet/CoreCLR/WebRequestPSCmdlet.CoreClr.cs#L198\r\n\r\nand as `$args[3]` here\r\n\r\nhttps://github.com/markekraus/PowerShell/blob/06ae9e2219b900e80f7fec20a0e52d28e55a7256/src/Microsoft.PowerShell.Commands.Utility/commands/utility/WebCmdlet/CoreCLR/WebRequestPSCmdlet.CoreClr.cs#L209\r\n\r\nand the user can accept it in `param()`\r\n\r\n```powershell\r\n$Script = {\r\n    param(\r\n       [System.Net.Http.HttpRequestMessage]\r\n       $Message,\r\n\r\n       [System.Security.Cryptography.X509Certificates.X509Certificate2]\r\n       $Cert,\r\n\r\n       [System.Security.Cryptography.X509Certificates.X509Chain]\r\n       $Chain,\r\n\r\n       [System.Net.Security.SslPolicyErrors]\r\n       $PolicyErrors\r\n   )\r\n   <# Validation code #>\r\n}\r\n```\r\n\r\nThe user can even mix and match in the same script if they want.\r\n\r\n```powershell\r\n$Script = {\r\n    param(\r\n       [System.Net.Http.HttpRequestMessage]\r\n       $Message,\r\n\r\n       [System.Security.Cryptography.X509Certificates.X509Certificate2]\r\n       $Cert,\r\n\r\n       [System.Security.Cryptography.X509Certificates.X509Chain]\r\n       $Chain,\r\n\r\n       [System.Net.Security.SslPolicyErrors]\r\n       $PolicyErrors\r\n   )\r\n   if ($args[3] -eq 'None' -and $SslPolicyErrors -eq 'None' -and $PolicyErrors -eq 'None') {\r\n       return $true\r\n   }\r\n   else {\r\n    return $false\r\n   }\r\n}\r\n```\r\n\r\nThere is nothing obvious about any of this. Certificate validation callbacks are an advanced concept. Users will be required to learn about the 4 objects and draw from examples in the C# world. We can fix some of this with documentation, but most users who will use this feature are already advanced in knowing the dangers of `-SkipCertificateCheck` or may be familiar with them from C# or with `[System.NetServicePointManager]::ServerCertificateValidationCallback` in Windows PowerShell.",
      "created_at": "2017-10-06T19:30:25Z",
      "updated_at": "2017-10-06T19:30:25Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "PowerShell allow do complex things easily. We should thing how make the callback easy to use.\r\n`-AfterCertificateValidateScript` - validate after standard checks.\r\n`-ReplaceCertificateValidateScript` - validate instead of standard checks.\r\n",
      "created_at": "2017-10-06T19:53:00Z",
      "updated_at": "2017-10-06T19:53:00Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov I don't think we should over-complicate these cmdlets with more parameters for a feature that has a limited user scope that is already advanced. If I'm new to the language and I see the 2 primary web cmdlets have some these  parameters:\r\n\r\n```\r\n-Certificate\r\n-CertificateThumbprint\r\n-SkipCertificateCheck\r\n-AfterCertificateValidateScript\r\n-BeforeCertificateValidateScript\r\n-ReplaceCertificateValidateScript\r\n```\r\n\r\nI'm going to be very overwhelmed. \r\n\r\nI was going to suggest an `about_` topic that would include how to implement around `$SslPolicyErrors`. I personally think a singe replacement callback is all that's needed so long as it's documented.",
      "created_at": "2017-10-06T20:04:32Z",
      "updated_at": "2017-10-06T20:04:32Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "Can you just add examples to the help to show what scriptblock is needed for these particular cases?  That would be more useful than an `about` topic unless it requires a lot of supporting text.  Honestly, the issue with `about` topics is that folks don't find them that often compared to the help for the command.",
      "created_at": "2017-10-06T20:13:42Z",
      "updated_at": "2017-10-06T20:13:42Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "It, unfortunately, requires a bunch of supporting text, more than is acceptable for a parameter. The idea I had was to add the `about_` topic and have that listed in the parameter help which would also have some small examples and details.  \"For more examples and details see get-help about_CertificateValidationScript\". \r\n\r\nIf the web cmdlets didn't already have a heroic epics worth of text in their help, maybe this could all be in the parameter help.\r\n\r\nMaybe adding another auto-variable like an `$isValidCertificate` bool could help. a little? It at least eases the `SslPolicyErrors` burden.\r\n\r\nedit: I meant to say that i planed to include the before and after scenarios as Examples in the help.",
      "created_at": "2017-10-06T20:23:26Z",
      "updated_at": "2017-10-06T20:24:44Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@markekraus perhaps you can submit PR to https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Utility/Invoke-RestMethod.md and add some examples?",
      "created_at": "2017-10-07T02:58:43Z",
      "updated_at": "2017-10-07T02:58:43Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "The best traditional approach to creating documentation is to have three guides - a description of the syntax (fast discover features, syntax and short examples), a user guide (full feature description), and a description of the scenarios (HowTo).",
      "created_at": "2017-10-07T06:28:14Z",
      "updated_at": "2017-10-07T06:28:14Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT I was planning to do that after the PR here was merged. But I guess there is no harm in doing it beforehand.\r\n\r\n@iSazonov This was my planned approach:\r\n\r\n* Example section would include the before/permissive and after/restrictive scenarios. \r\n* Parameter section would provide a description, include details about the auto-variables, another small example, and a link/mention to the about_ topic\r\n* about_ topic would go more in depth about the objects (links to .NET docs), How and when the callback is called, more examples, and a troubleshooting guide.\r\n\r\nIt seems in alignment with what you suggested.",
      "created_at": "2017-10-07T11:00:06Z",
      "updated_at": "2017-10-07T11:00:06Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "Here is a draft of the `Invoke-RestMethod` documentation.\r\n\r\nhttps://github.com/PowerShell/PowerShell-Docs/compare/staging...markekraus:CertificatevalidationScriptDraft",
      "created_at": "2017-10-08T20:08:02Z",
      "updated_at": "2017-10-08T20:08:02Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@markekraus, awesome!  Looks good enough to submit as PR.  One thing I noticed is the capitalization of the word `Four`",
      "created_at": "2017-10-08T21:01:24Z",
      "updated_at": "2017-10-08T21:01:24Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT Should I wait for #4970 to be approved first before making the PR to PowerShell-Docs? \r\n\r\n(I made some fixes including the `Four` capitalization and added the equivalent Invoke-WebRequest documentation`). \r\n",
      "created_at": "2017-10-08T21:29:59Z",
      "updated_at": "2017-10-08T21:29:59Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Better wait merge - we can get useful feedback.",
      "created_at": "2017-10-09T05:06:05Z",
      "updated_at": "2017-10-09T05:06:05Z"
    },
    {
      "author": "alx9r",
      "author_association": "NONE",
      "body": "FWIW, I have implemented `ServerCertificateValidationCallback` calling into a user-supplied PowerShell scriptblock for [this other project](https://github.com/alx9r/BootstraPS).  There were a few things that weren't obvious at first that I had to overcome, so I will note them here in case it helps someone.\r\n\r\n### Callback Thread, `Runspace`, and `PowerShell` Instance\r\n\r\n`ServerCertificateValidationCallback` can be called on a different thread from the one that initiated the connection to the server.  The remarks in the [`Runspace.DefaultRunspace` documentation](https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.runspaces.runspace.defaultrunspace?view=powershellsdk-1.1.0#System_Management_Automation_Runspaces_Runspace_DefaultRunspace) include the following statement:\r\n\r\n> The Runspace used to set this property should not be shared between different threads.\r\n\r\nClearly the callback needs its own runspace which suggests the solution might be as simple as calling\r\n\r\n```C#\r\nRunspace.DefaultRunspace = RunspaceFactory.CreateRunspace()\r\nscriptBlock.Invoke()\r\n```\r\n\r\nin the callback.  The solution is not quite that simple and doing this in the callback causes PowerShell to do strange things or crash in many scenarios.  I _think_ this is the result of the same state being accessed by the two threads in a non-threadsafe manner.  In any case, @proxb [seems to have multithreading working reliably in PowerShell](https://github.com/proxb/PoshRSJob) and his examples use one `PowerShell` instance from `PowerShell.Create()` for each thread.  I used those principles to create [a C# scriptblock invoker class](https://github.com/alx9r/BootstraPS/blob/3bbb0769fbc0cc7f0c69fba1c1826b7ca27dd227/BootstraPS.psm1#L328-L483) whose [invoke method](https://github.com/alx9r/BootstraPS/blob/3bbb0769fbc0cc7f0c69fba1c1826b7ca27dd227/BootstraPS.psm1#L412-L461) does something like this:\r\n\r\n```C#\r\n    public void Invoke()\r\n    {\r\n       // ...\r\n        var iss = InitialSessionState.CreateDefault()\r\n        // define variables and functions, import modules\r\n        using (var rs = RunspaceFactory.CreateRunspace(iss))\r\n        using (var ps = PowerShell.Create())\r\n        {\r\n            ps.Runspace = rs;\r\n            rs.Open();\r\n            ps.AddScript(ScriptBlock.ToString());\r\n            // add arguments and parameters to scriptblock\r\n            ReturnValue = ps.Invoke();\r\n        }\r\n        // ...\r\n    }\r\n```\r\n\r\n[Another method on that object is the callback](https://github.com/alx9r/BootstraPS/blob/3bbb0769fbc0cc7f0c69fba1c1826b7ca27dd227/BootstraPS.psm1#L509-L544) which looks something like this:\r\n\r\n```C#\r\n    public bool CertValidationCallback(\r\n        object sender,\r\n        X509Certificate certificate,\r\n        X509Chain chain,\r\n        SslPolicyErrors sslPolicyErrors)\r\n    {\r\n         // prepare the parameters for the scriptblock\r\n         Invoke()\r\n         // interpret the output from the scriptblock and return a bool\r\n    }\r\n```\r\n\r\nThis all seems to work rather reliably under testing including [a race condition test](https://github.com/alx9r/BootstraPS/blob/3bbb0769fbc0cc7f0c69fba1c1826b7ca27dd227/UnitTests/scriptBlockInvoker.Tests.ps1#L237-L258) similar to [the one suggested by @lzybkr](https://github.com/PowerShell/PowerShell/pull/4970#discussion_r143785852).\r\n\r\n### Interpreting the Output from the Scriptblock\r\n\r\nThe stakes are fairly high here so I tried to use conservative interpretations of the scriptblock's output to reduce the chance of falsely interpreting a bad certificate as good.  I settled on interpreting any of the following as a bad certificate:\r\n\r\n* any non-boolean output from the scriptblock\r\n* any false value output from the scriptblock\r\n* any exception not caught inside the scriptblock\r\n* any error in the scriptblock\r\n\r\n### Exception Propagation\r\n\r\nAn exception thrown in the callback is interpreted as a bad certificate and eventually appears in some deeply-nested exception on the caller's thread.  When that exception originates in the scriptblock, it provides valuable diagnostic information.  Exceptions thrown by the scriptblock should not be caught in the callback because doing so hides valuable information from the user about what's happening in their scriptblock.\r\n\r\n### Interacting with the Callback Arguments\r\n\r\nAt first I found it extremely difficult to write a acceptable certificate validation scriptblocks.  Even the rather straightforward [sha1-intermediate check](https://github.com/alx9r/BootstraPS/blob/3bbb0769fbc0cc7f0c69fba1c1826b7ca27dd227/IntegrationTests/certificateValidation.Tests.ps1#L12-L20) was difficult because I didn't have access to the objects passed to the callback in a debugger or interactive session.  I ended up [writing a function that copies those objects](https://github.com/alx9r/BootstraPS/blob/3bbb0769fbc0cc7f0c69fba1c1826b7ca27dd227/BootstraPS.psm1#L887-L956) to the degree I was able to and brings them into the caller's context.  This capability seems rather important to write good certificate validation scriptblocks.\r\n\r\n### Certificate Analysis Helpers\r\n\r\nI'm fairly certain that meaningful certificate validation will rely on calling some sort of helper functions inside the scriptblock.  Because the callback is in a different context from the caller, such helper functions have to be deliberately made available in the scriptblock.  Injecting functions into the scriptblock by way of [adding `SessionStateFunctionEntry`s to `InitialSessionState.Command` in the callback](https://github.com/alx9r/BootstraPS/blob/3bbb0769fbc0cc7f0c69fba1c1826b7ca27dd227/BootstraPS.psm1#L433) seems to work fine for this purpose.\r\n\r\n-----------\r\n\r\nBTW, thank you @lzybkr for the advice you gave in the #4970 review -- it probably saved me a few days of research.",
      "created_at": "2017-10-19T02:35:53Z",
      "updated_at": "2017-10-19T02:35:53Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@alx9r Thanks! I will have to look at what you provided this weekend. Have you tested any of this with the `HttpClientHandler.ServerCertificateCustomValidationCallback`? It appears to be a slightly different beast in CoreFX than what was on the `ServicePointManager` in full CLR.",
      "created_at": "2017-10-19T10:02:23Z",
      "updated_at": "2017-10-19T10:02:23Z"
    },
    {
      "author": "alx9r",
      "author_association": "NONE",
      "body": "@markekraus I did do a bit of testing of `HttpClientHandler.ServerCertificateCustomValidationCallback` using one of the v6.0.0-beta.8.  I didn't notice any obvious differences in behavior.\r\n\r\n> It appears to be a slightly different beast in CoreFX than what was on the ServicePointManager in full CLR.\r\n\r\nI haven't worked with `ServicePointManager` so I can't really speak to that.  The work I talked about in my last post is all with [full 4.7 `WebRequestHandler.ServerCertificateValidationCallback`](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.webrequesthandler.servercertificatevalidationcallback?view=netframework-4.7#System_Net_Http_WebRequestHandler_ServerCertificateValidationCallback) (see [here](https://github.com/alx9r/BootstraPS/blob/3bbb0769fbc0cc7f0c69fba1c1826b7ca27dd227/BootstraPS.psm1#L617-L621)) which looks rather similar to [core 2.0 `HttpClientHandler.ServerCertificateCustomValidationCallback`](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclienthandler.servercertificatecustomvalidationcallback?view=netcore-2.0#System_Net_Http_HttpClientHandler_ServerCertificateCustomValidationCallback).  I would have used `HttpClientHandler` instead of `WebRequestHandler`, but it didn't expose `ServerCertificateCustomValidationCallback` until 4.7.1 which was only released a couple of days ago.",
      "created_at": "2017-10-20T01:05:08Z",
      "updated_at": "2017-10-20T01:05:08Z"
    },
    {
      "author": "atanasa",
      "author_association": "NONE",
      "body": "Just to let you know, the callback currently (as of .Net Core 2.0) does not work on all platforms (e.g. OSX). The two modes that you are referring to (default validation and skip validation) are the only consistent modes currently supported by .Net Core. There is hope for this to get fixed with the next version of .Net Core.\r\nI am trying to get this documented: https://github.com/dotnet/corefx/issues/24774\r\nIt might be ok to handle the PlatformNotSupported exception and inform the user that the parameter(s) are not supported on your platform.\r\n",
      "created_at": "2017-10-24T12:04:20Z",
      "updated_at": "2017-10-24T12:04:20Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@atanasa Yup, I'm aware. Though in some instances it seems to work and in others it doesn't. It was passing our macOS tests for awhile and then stopped. I finally got a loaner mac to troubleshoot, but I just haven't had time (real job getting in the way \u2639\ufe0f ). We have a similar issues with `-Certificate` and certificate based authentication with the web cmdlets. ",
      "created_at": "2017-10-24T12:18:18Z",
      "updated_at": "2017-10-24T12:18:18Z"
    },
    {
      "author": "Viajaz",
      "author_association": "NONE",
      "body": "I have a PowerShell 5.1 Module that implements a custom class from `ICertificatePolicy` to be used with `[System.Net.ServicePointManager]::CertificatePolicy` to allow for normal Certificate Validation with support for overriding the Common Name validation by providing a custom whitelist of acceptable Common Names which is useful when connecting to HTTPS via IP address rather than FQDN but you still wish to validate the server certificate.\r\n\r\nIt would be useful to have this capability again across the Web Cmdlets without having to make my own replica Cmdlets, based around `HttpClient`, just to support this, or, having to use `SkipCertificateCheck` and lose all protection.",
      "created_at": "2022-04-06T06:19:16Z",
      "updated_at": "2022-04-06T06:19:16Z"
    }
  ],
  "created_at": "2017-09-22T17:47:13Z",
  "number": 4899,
  "state": "open",
  "title": "Add User Supplied ServerCertificateCustomValidationCallback Support to Web Cmdlets",
  "updated_at": "2022-04-06T06:19:16Z"
}