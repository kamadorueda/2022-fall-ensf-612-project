{
  "_url": "https://github.com/PowerShell/PowerShell/issues/16926",
  "author": "MatejKafka",
  "body": "### Prerequisites\r\n\r\n- [X] Write a descriptive title.\r\n- [X] Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\r\n- [X] Search the existing issues.\r\n- [X] Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\r\n- [X] Refer to [Differences between Windows PowerShell 5.1 and PowerShell](https://docs.microsoft.com/powershell/scripting/whats-new/differences-from-windows-powershell).\r\n\r\n### Steps to reproduce\r\n\r\nThe following function creates a new shortcut (.lnk) using a Shell COM object, and then attempts to set the working directory property (without saving the shortcut).\r\n```\r\nfunction fn([switch]$Resolve) {\r\n    $WorkingDirectory = if ($Resolve) {Resolve-Path \".\"} else {\".\"}\r\n    $Shell = (New-Object -ComObject \"WScript.Shell\")\r\n    # the shortcut is not actually created\r\n    $Shortcut = $Shell.CreateShortcut(\"C:\\shortcut.lnk\")\r\n    $Shortcut.WorkingDirectory = $WorkingDirectory\r\n}\r\n```\r\n\r\nIf you add this function **into a fresh `pwsh` session**, and then run the following 2 invocations, everything works correctly:\r\n```\r\n> fn -Resolve\r\n> fn\r\n```\r\n\r\nHowever, if you run the commands in the opposite order (**again in a fresh `pwsh` session**), a type error is thrown:\r\n```\r\n> fn\r\n> fn -Resolve\r\nOperationStopped:\r\nLine |\r\n   6 |      $Shortcut.WorkingDirectory = $WorkingDirectory\r\n     |      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n     | Unable to cast object of type 'System.Management.Automation.PathInfo' to type 'System.String'.\r\n```\r\n\r\nMy hypothesis: PowerShell somehow remembers the first type that is assigned into a property of a COM object, and then refuses any other type (even if the second type can be normally implicitly casted to the first type). However, this only works in one direction (when the first type is a String, which matches the expected type of the property), but not in the other (when the first type is something that can be implicitly casted to the correct type (String in this case)). No idea why, quite curious. :)\r\n\r\n### Expected behavior\r\n\r\nBoth invocations should succeed, independent of the order.\r\n\r\n\r\n### Actual behavior\r\n\r\nA type error is thrown if the first assignment assigns a String, and the second assignment assigns a different type, even if has an implicit cast to String.\r\n\r\n\r\n### Error details\r\n```console\r\nException             :\r\n    Type       : System.InvalidCastException\r\n    TargetSite :\r\n        Name          : ChkCast_Helper\r\n        DeclaringType : System.Runtime.CompilerServices.CastHelpers, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e\r\n        MemberType    : Method\r\n        Module        : System.Private.CoreLib.dll\r\n    Message    : Unable to cast object of type 'System.Management.Automation.PathInfo' to type 'System.String'.\r\n    Data       : System.Collections.ListDictionaryInternal\r\n    Source     : System.Private.CoreLib\r\n    HResult    : -2147467262\r\n    StackTrace :\r\n   at CallSite.Target(Closure , CallSite , ComObject , Object )\r\n   at System.Dynamic.UpdateDelegates.UpdateAndExecute2[T0,T1,TRet](CallSite site, T0 arg0, T1 arg1)\r\n   at System.Dynamic.UpdateDelegates.UpdateAndExecute2[T0,T1,TRet](CallSite site, T0 arg0, T1 arg1)\r\n   at System.Dynamic.UpdateDelegates.UpdateAndExecute2[T0,T1,TRet](CallSite site, T0 arg0, T1 arg1)\r\n   at System.Management.Automation.Interpreter.DynamicInstruction`3.Run(InterpretedFrame frame)\r\n   at System.Management.Automation.Interpreter.EnterTryCatchFinallyInstruction.Run(InterpretedFrame frame)\r\nCategoryInfo          : OperationStopped: (:) [], InvalidCastException\r\nFullyQualifiedErrorId : System.InvalidCastException\r\nInvocationInfo        :\r\n    ScriptLineNumber : 6\r\n    OffsetInLine     : 5\r\n    HistoryId        : -1\r\n    Line             :     $Shortcut.WorkingDirectory = $WorkingDirectory\r\n\r\n    PositionMessage  : At line:6 char:5\r\n                       +     $Shortcut.WorkingDirectory = $WorkingDirectory\r\n                       +     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n    CommandOrigin    : Internal\r\nScriptStackTrace      : at fn, <No file>: line 6\r\n                        at <ScriptBlock>, <No file>: line 1\r\n```\r\n\r\n\r\n### Environment data\r\n\r\n```powershell\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.3.0-preview.1\r\nPSEdition                      Core\r\nGitCommitId                    7.3.0-preview.1\r\nOS                             Microsoft Windows 10.0.19044\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n\r\n\r\n### Visuals\r\n\r\n![image](https://user-images.githubusercontent.com/6414091/155817280-6ec885bd-c243-45e4-8cc0-ff16e73ab42f.png)\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Perhaps it is a side effect of script compile cache. /cc @vexx32 @SeeminglyScience ",
      "created_at": "2022-02-26T07:59:31Z",
      "updated_at": "2022-02-26T07:59:31Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "Yeah seems like an issue with the COM binder. It's probably not setting a binding restriction based on argument type. /cc @daxian-dbw ",
      "created_at": "2022-02-26T21:35:58Z",
      "updated_at": "2022-02-26T21:35:58Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "PowerShell uses the same COM binder from C#, so this is likely an issue with the C# COM binder. It would be nice to reproduce the issue in C# with `dynamic` keyword, and then open an issue in dotnet/runtime repo.\r\n\r\nFWIW, it's not a regression -- Windows PowerShell 5.1 has the same failure because it also uses the C# COM binder.\r\nPowerShell's COM adapter seems working fine in this case:\r\n```\r\nfunction fn([switch]$Resolve) {\r\n    $WorkingDirectory = if ($Resolve) {Resolve-Path \".\"} else {\".\"}\r\n    $Shell = (New-Object -ComObject \"WScript.Shell\")\r\n    # the shortcut is not actually created\r\n    $Shortcut = $Shell.CreateShortcut(\"C:\\shortcut.lnk\")\r\n\r\n    ## setting the property through COM adapter.\r\n    $Shortcut.psobject.properties[\"WorkingDirectory\"].Value = $WorkingDirectory\r\n}\r\n```",
      "created_at": "2022-02-27T15:30:08Z",
      "updated_at": "2022-02-27T15:30:08Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Set Issue-Bug so that we don't lost this.",
      "created_at": "2022-02-27T18:12:44Z",
      "updated_at": "2022-02-27T18:12:44Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "@daxian-dbw I think we just need to add the argument type to binding restrictions. Here's the code generated by the binder for when the argument is string. Note, the `if` statement around it is the binding restrictions:\r\n\r\n```csharp\r\nif ((instance is IDispatchComObject) &&\r\n    (((IDispatchComObject)instance).ComTypeDesc == Fake.Const<ComTypeDesc>(\"_defaultToString<ComTypeDesc>\")))\r\n{\r\n    return \r\n    {\r\n        int dispId = DispId;\r\n        dispParams.rgvarg = UnsafeMethods.ConvertVariantByrefToPtr(ref paramVariants.Element0);\r\n        dispParams.cArgs = 1;\r\n        dispParams.cNamedArgs = 1;\r\n        int propertyPutDispId = -3;\r\n        dispParams.rgdispidNamedArgs = UnsafeMethods.ConvertInt32ByrefToPtr(ref propertyPutDispId);\r\n        IDispatch dispatchObject = ((IDispatchComObject)instance).DispatchObject;\r\n        IntPtr dispatchPointer = Marshal.GetIDispatchForObject(dispatchObject);\r\n        try\r\n        {\r\n            ExcepInfo excepInfo;\r\n            uint argErr;\r\n            paramVariants.Element0.AsBstr = (string)value;\r\n            int hresult = UnsafeMethods.IDispatchInvoke(\r\n                dispatchPointer,\r\n                dispId,\r\n                INVOKEKIND.INVOKE_PROPERTYPUT,\r\n                ref dispParams,\r\n                out invokeResult,\r\n                out excepInfo,\r\n                out argErr);\r\n            ComRuntimeHelpers.CheckThrowException(\r\n                hresult,\r\n                ref excepInfo,\r\n                Fake.Const<ComMethodDesc>(\"_defaultToString<ComMethodDesc>\"),\r\n                new object[]\r\n                {\r\n                    ((IDispatchComObject)instance).DispatchObject as object,\r\n                    value as object\r\n                },\r\n                argErr);\r\n            returnValue = invokeResult.ToObject();\r\n        }\r\n        finally\r\n        {\r\n            UnsafeMethods.IUnknownRelease(dispatchPointer);\r\n            paramVariants.Element0.Clear();\r\n            invokeResult.Clear();\r\n        }\r\n\r\n        return AutomationNull.Value;\r\n\r\n        return (object)value;\r\n    };\r\n}\r\n```\r\n\r\nIf the binding restrictions included the property value type we'd it would trigger an update at the call site. I'm not 100% sure this would be considered an issue in C# as even in dynamic they require their casts to be a little bit more explicit. Hmm it might be though, I'll see if I can whip up a repro in a console app.\r\n\r\nAlso for completion, here's what the binder generates if `PathInfo` is the first binding for the call site:\r\n\r\n```csharp\r\nif ((instance is IDispatchComObject) &&\r\n    (((IDispatchComObject)instance).ComTypeDesc == Fake.Const<ComTypeDesc>(\"_defaultToString<ComTypeDesc>\")))\r\n{\r\n    return \r\n    {\r\n        int dispId = DispId;\r\n        dispParams.rgvarg = UnsafeMethods.ConvertVariantByrefToPtr(ref paramVariants.Element0);\r\n        dispParams.cArgs = 1;\r\n        dispParams.cNamedArgs = 1;\r\n        int propertyPutDispId = -3;\r\n        dispParams.rgdispidNamedArgs = UnsafeMethods.ConvertInt32ByrefToPtr(ref propertyPutDispId);\r\n        IDispatch dispatchObject = ((IDispatchComObject)instance).DispatchObject;\r\n        IntPtr dispatchPointer = Marshal.GetIDispatchForObject(dispatchObject);\r\n        try\r\n        {\r\n            ExcepInfo excepInfo;\r\n            uint argErr;\r\n            paramVariants.Element0.AsVariant = value;\r\n            int hresult = UnsafeMethods.IDispatchInvoke(\r\n                dispatchPointer,\r\n                dispId,\r\n                INVOKEKIND.INVOKE_PROPERTYPUT,\r\n                ref dispParams,\r\n                out invokeResult,\r\n                out excepInfo,\r\n                out argErr);\r\n            ComRuntimeHelpers.CheckThrowException(\r\n                hresult,\r\n                ref excepInfo,\r\n                Fake.Const<ComMethodDesc>(\"_defaultToString<ComMethodDesc>\"),\r\n                new object[]\r\n                {\r\n                    ((IDispatchComObject)instance).DispatchObject as object,\r\n                    value as object\r\n                },\r\n                argErr);\r\n            returnValue = invokeResult.ToObject();\r\n        }\r\n        finally\r\n        {\r\n            UnsafeMethods.IUnknownRelease(dispatchPointer);\r\n            paramVariants.Element0.Clear();\r\n            invokeResult.Clear();\r\n        }\r\n\r\n        return AutomationNull.Value;\r\n\r\n        return (object)value;\r\n    };\r\n}\r\n```",
      "created_at": "2022-02-28T14:40:52Z",
      "updated_at": "2022-02-28T14:40:52Z"
    }
  ],
  "created_at": "2022-02-25T23:45:58Z",
  "labels": [
    "Issue-Bug",
    "WG-Engine"
  ],
  "number": 16926,
  "state": "open",
  "title": "\"Unable to cast PathInfo to String\" when assigning to shell shortcut property",
  "updated_at": "2022-06-09T20:39:03Z"
}