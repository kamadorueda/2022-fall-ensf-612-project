{
  "_url": "https://github.com/PowerShell/PowerShell/issues/11797",
  "author": "SteveL-MSFT",
  "body": "This was encountered by a MS Partner team.  When calling a cmdlet that outputs lots of objects, the [SmartToString()](https://github.com/PowerShell/PowerShell/blob/bd6fdae73520931f0d27a29d6290e18761772141/src/System.Management.Automation/FormatAndOutput/common/Utilities/MshObjectUtil.cs#L205) helper throws the exception \"InvalidOperationException: Collection was modified after the enumerator was instantiated\" as the PSObject is modified before the conversion completes.  There is already code to catch an ExtendedTypeSystemException and we could extend that for any exception and just return string.empty.  Or alternatively, we could make a copy of the object but that would impact perf.\r\n\r\nIn the repro, it was explicitly going through the `Format-List` code, although `Format-Table` may also use this helper.",
  "closed_at": "2021-01-28T00:37:37Z",
  "comments": [
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "This may not be _technically_ related, but it reminded me of #6163",
      "created_at": "2020-02-07T03:58:58Z",
      "updated_at": "2020-02-07T03:58:58Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "If the PSObject is changed while it is enumerated it looks like a race condition in user code (how do they change it? from another runspace?) - why should we hide the exception?",
      "created_at": "2020-02-07T07:49:28Z",
      "updated_at": "2020-02-07T07:50:31Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@iSazonov in this specific repro, they were enumerating a large collection of AD objects and it only repro'd for them when transcription was enabled although I'm not sure that is directly related.  Transcription may have just slowed it down to make the race condition happen more easily.",
      "created_at": "2020-02-19T22:37:56Z",
      "updated_at": "2020-02-19T22:37:56Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "It looks as fundamental problem. I caught the same with AccountManagement API. It depends on a `context` and every call to the object causes a \"remote\" call to ensure that the object is live. So if such check presents in enumerator we can not resolve this exception naturally.",
      "created_at": "2020-02-20T03:53:09Z",
      "updated_at": "2020-02-20T03:53:09Z"
    },
    {
      "author": "HerbertMauerer",
      "author_association": "NONE",
      "body": "Hello,\r\n**Redacted by @joeyaiello** \r\n\r\n\r\nThe problem happens in the Active Directory Admin Center (ADAC) when there are many objects in a container. I have a customer waiting for a resolution on this. And I have the worry that additional customers run into this as they switch from the older toolset to ADAC. \r\n\r\nI'm aware you have other deliverables. I would appreciate if you could share an ETA when you think you can start working on this  problem.\r\n\r\nThanks\r\n\r\nHerbert Mauerer",
      "created_at": "2020-07-14T14:28:26Z",
      "updated_at": "2020-08-05T22:14:28Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "If what @iSazonov is saying is correct, I suspect the issue can only really be resolved in the ActiveDirectory module itself.\r\n\r\nPowerShell can attempt to _mitigate_ the eventual effect of it, but it can't change the way the ActiveDirectory module is choosing to operate. The best we could hope for from the PowerShell end would probably be that some objects would end up quietly skipped and maybe a less intrusive error would be recorded after enumeration completes.\r\n\r\nBut even then, I'm not sure it's something PowerShell will be able to account for.",
      "created_at": "2020-07-14T15:03:34Z",
      "updated_at": "2020-07-14T15:03:34Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@HerbertMauerer Because ADAC is not OSS we need a simple repro like a script or GitHub shared C# project. We need to understand what API to investigate.\r\nPerhaps you could share more information about the broken scenario. As I know ADAC limits to 20000 objects by default and max limit is 100000. Perhaps it is not right things to build so large PSObject and convert it to string.",
      "created_at": "2020-07-14T19:43:27Z",
      "updated_at": "2020-07-14T19:43:27Z"
    },
    {
      "author": "HerbertMauerer",
      "author_association": "NONE",
      "body": "It is tough to rebuild what  ADAC does. When I capture the command it sends and run the same get-adobject query, it succeeds.\r\n\r\nAddtl. consideration:\r\nWe had a past issue where only ADAC was failing with PS transscripting enabled,:\r\n3196545 ADDS: Admin: Active Directory Administrative Center does not work with PowerShell Transcripting \r\n**Redacted by @joeyaiello** \r\n\r\nThis is the case here as well. When you turn off transscripting, it works.\r\n\r\n<blockquote><img src=\"//www.microsoft.com/favicon.ico?v2\" width=\"48\" align=\"right\"></blockquote>",
      "created_at": "2020-07-20T13:57:27Z",
      "updated_at": "2020-08-05T22:13:38Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I guess ADAC implements custom transcription and you could look the code - I wonder if it changes an object in the enumerator.",
      "created_at": "2020-07-20T17:32:24Z",
      "updated_at": "2020-07-20T17:32:24Z"
    },
    {
      "author": "HerbertMauerer",
      "author_association": "NONE",
      "body": "Hello,\r\n\r\ndo you have Windows source access?\r\nI could also hook you up with the DEV Owner of ADAC.\r\n\r\nHerbert",
      "created_at": "2020-07-27T08:05:21Z",
      "updated_at": "2020-07-27T08:05:21Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "No, I haven't the access.",
      "created_at": "2020-07-27T11:58:29Z",
      "updated_at": "2020-07-27T11:58:29Z"
    },
    {
      "author": "HerbertMauerer",
      "author_association": "NONE",
      "body": "**Redacted by @joeyaiello** ",
      "created_at": "2020-07-28T05:12:04Z",
      "updated_at": "2020-08-05T22:14:14Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@HerbertMauerer that information won't help anyone here in the community.",
      "created_at": "2020-07-29T20:59:40Z",
      "updated_at": "2020-07-29T20:59:40Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "For @PowerShell/powershell-committee, a couple of options:\r\n\r\n- do nothing\r\n- add warning/non-terminating error and return empty string allowing pipeline to continue\r\n- copy collection before enumerating\r\n",
      "created_at": "2020-08-05T19:48:47Z",
      "updated_at": "2020-08-05T19:48:47Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee reviewed this, we agreed for 7.1 we should have a warning message saying \"Object skipped: <exception message>\" returning an empty string.",
      "created_at": "2020-08-05T22:13:58Z",
      "updated_at": "2020-08-05T22:13:58Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> If the PSObject is changed while it is enumerated it looks like a race condition in user code (how do they change it? from another runspace?) - why should we hide the exception?\r\n\r\nThis happens in some contexts with PowerShell APIs when they are called off the pipeline thread. If your module does something like get a value from PowerShell, store it, allow the pipeline to continue and later tries to use or manipulate the variable, issues like this may occur. As someone who's hit issues like this in many places, it's painful, but it represents a race condition in your code.\r\n\r\nIt's also worth noting that formatters contain script, so they need a runspace/thread to work on.\r\n\r\nSo to resolve this properly in your code you must:\r\n\r\n- Ensure you do not yield the pipeline before you have finished processing PowerShell objects. In a cmdlet this is simple; you just ensure that you have fully processed all PowerShell objects before returning from the cmdlet methods. If you are obtaining PowerShell objects without a pipeline (e.g. by API traversal or reflection) you should be very careful about how and when you do so. In all cases, the object's safe lifetime is tethered to the pipeline thread's state.\r\n- Fall back to `Out-String` if needed. `Out-String` is the best mechanism for rendering PowerShell formatting to a string object. Similarly, `Out-File` is best for printing to a file. These can be run like this:\r\n\r\n```csharp\r\nstring strRepr;\r\nusing (var pwsh = PowerShell.Create(RunspaceMode.CurrentRunspace))\r\n{\r\n    strRepr = pwsh.AddCommand(\"Out-String\").Invoke(inputObjectCollection);\r\n}\r\n```\r\n\r\nI'll also note that if you're in a hosted context rather than in a PowerShell module, there are other ways to ensure that your code is always run on the pipeline thread. However, they require effort to implement, so you should make sure you have good reason to make the investment.",
      "created_at": "2020-08-06T00:57:16Z",
      "updated_at": "2020-08-06T01:03:47Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> we should have a warning message saying \"Object skipped: \" returning an empty string.\r\n\r\nIt looks like hiding a race condition in customer code. :-( It can be dangerous.\r\n",
      "created_at": "2020-08-06T03:45:47Z",
      "updated_at": "2020-08-06T03:45:47Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "From the original description, it sounds like the issue was occurring in the actual call of `Format-List`. If it's being called as we expect, it just sounds like there's some kind of race condition or over-aggressive optimisation in our code.",
      "created_at": "2020-08-06T16:12:00Z",
      "updated_at": "2020-08-06T16:12:00Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@rjmholt From the comment https://github.com/PowerShell/PowerShell/issues/11797#issuecomment-661056380 the issue is with transcripting or in transcripting.",
      "created_at": "2020-08-06T16:33:35Z",
      "updated_at": "2020-08-06T16:33:35Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "Original public info from @HerbertMauerer:\r\n\r\nAD Admin Center (DSAC.EXE) is switching to a container with 20000 or more objects.\r\nThis works fine without powershell transscripting. When it is enabled, you get an error dialog saying:\r\n\"Collection was modified after the enumerator was instantiated\"\r\n\r\nAnd you don\u2019t get the list of objects in the container. The customer encounters this for the \u201cDeleted Objects\u201d container when he wants to restore AD objects, but I can also reproduce it with a OU with 20000 objects.\r\nWhen you run the Get-ADObject query DSAC uses under the hood in Powershell, the query is successful. So you can\u2019t really rebuild what DSAC is doing in plain PS.\r\n\r\nI worked it to the point where we see an invalid result set size variable within .Net runtime.",
      "created_at": "2020-08-10T16:21:19Z",
      "updated_at": "2020-08-10T16:21:19Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@iSazonov I've looked through the transcription code and don't see anything that would modify the object.  I think transcription is misleading and likely just making the race condition more apparent as it changes the timing.",
      "created_at": "2020-12-16T05:57:50Z",
      "updated_at": "2020-12-16T05:57:50Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Perhaps transcription slows down the code and increases the likelihood the race condition.\r\n\r\nI think ADAC should be re-implemented with best practice as ADUC module does - map native objects to custom ones and don't use wrapping in PSObject. This approach helps to resolve the race condition issue and to get great perf win.",
      "created_at": "2020-12-16T06:13:23Z",
      "updated_at": "2020-12-16T06:13:23Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": ":tada:This issue was addressed in #14438, which has now been successfully released as `v7.2.0-preview.3`.:tada:\n\nHandy links:\n* [Release Notes](https://github.com/PowerShell/PowerShell/releases/tag/v7.2.0-preview.3)\n",
      "created_at": "2021-02-12T02:07:07Z",
      "updated_at": "2021-02-12T02:07:07Z"
    }
  ],
  "created_at": "2020-02-07T01:18:47Z",
  "number": 11797,
  "state": "closed",
  "title": "Helper method converting PSObject to string may fail",
  "updated_at": "2021-02-12T02:07:08Z"
}