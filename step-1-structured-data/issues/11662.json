{
  "_url": "https://github.com/PowerShell/PowerShell/issues/11662",
  "author": "sdwheeler",
  "body": "# Summary of the new feature/enhancement\r\n\r\n<!-- \r\nA clear and concise description of what the problem is that the new feature would solve.\r\nTry formulating it in user story style (if applicable):\r\n'As a user I want X so that Y.' with X being the being the action and Y being the value of the action.\r\n-->\r\nOpening issue to get feedback per our shiproom conversation.\r\n\r\nWe have publicly stated that `Invoke-Expression` should be avoided. There are too many inherent security risks built into it. We continue to get questions in the Docs repo about how and why it should be used, and asks for useful examples.\r\n\r\nWe have the ability, in code, to set an attribute on the cmdlet that marks it as deprecated. Should this change be made? Are there compelling cases for the use of this cmdlet?",
  "closed_at": "2022-05-13T09:00:45Z",
  "comments": [
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "In the linked issue @sdwheeler states:\r\n\r\n> Invoke-Expression is maintained for historical purposes but is effectively deprecated\r\n\r\nFrom @rjmholt's response ibidem:\r\n\r\n> My personal feeling (worth also talking to @SteveL-MSFT, @joeyaiello, @JamesWTruher and @BrucePay) is that it\u2019s not so much historical as an important part of an interpreted language. It\u2019s dangerous, and shouldn\u2019t be used in production, but all scripting languages have an eval() equivalent.\r\n\r\nAlso of interest: his comment with specific invocation scenarios, https://github.com/MicrosoftDocs/PowerShell-Docs/issues/4897#issuecomment-548141117, where he concludes:\r\n\r\n> I think the uses are quite obscure and Invoke-Expression needs no encouragement. We should just warn against it..\r\n\r\n",
      "created_at": "2020-01-23T03:10:14Z",
      "updated_at": "2020-01-23T03:10:14Z"
    },
    {
      "author": "lukeb1961",
      "author_association": "NONE",
      "body": "As someone who does use Invoke-Expression for good reason, in a small number of scripts, I'm damned if I can see why you want to take away this functionality. It exists in Powershell and exists in some form in every other scripting language.  There are plenty of compatibility  and performance issues with PS core that need to be addressed before you start breaking my existing scripts.",
      "created_at": "2020-01-23T04:20:43Z",
      "updated_at": "2020-01-23T04:20:43Z"
    },
    {
      "author": "doctordns",
      "author_association": "COLLABORATOR",
      "body": "I feel deprecating like this is not all that helpful. There are, as @lukeb1961 and others point out, useful reasons for using IEX. Not many, but some are certainly 'valid'. \r\n\r\nI feel that to document the issue and warn against it is probably enough.  \r\n",
      "created_at": "2020-01-23T10:49:19Z",
      "updated_at": "2020-01-23T10:49:19Z"
    },
    {
      "author": "danijeljw",
      "author_association": "NONE",
      "body": "I do not see the use in removing this, when I use it in so many scripts, and have been taught how to use this effectively in so many scripts for API calls too. Please don't remove it.",
      "created_at": "2020-01-23T12:49:49Z",
      "updated_at": "2020-01-23T12:49:49Z"
    },
    {
      "author": "sdwheeler",
      "author_association": "COLLABORATOR",
      "body": "To be clear, we are not talking about removing `Invoke-Expression`. We are talking about marking it as \"deprecated\" and more emphatically warning against its use.\r\n\r\nIf you have compelling use cases, please share them so we can see WHY it is needed.",
      "created_at": "2020-01-23T15:43:22Z",
      "updated_at": "2020-01-23T15:43:22Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> I'm damned if I can see why you want to take away this functionality\r\n\r\nNobody is talking about removing `Invoke-Expression`. It\u2019s an important primitive in PowerShell (as in any scripting language).\r\n\r\nHere and in a few other places there has been some confusion about the meaning of the term `deprecate`. It simply means to *express disapproval of*, to disrecommend. Obsolescence is one reason to do so, but another is unnecessary danger. `Invoke-Expression` lies in the second category; it\u2019s not going anywhere but it\u2019s [dangerous](https://devblogs.microsoft.com/powershell/invoke-expression-considered-harmful/) to use non-interactively, both from a [security standpoint](https://community.idera.com/database-tools/powershell/powertips/b/tips/posts/why-invoke-expression-is-evil) and an efficiency one (the whole parser/compiler toolchain has to be run again at execution time).\r\n\r\nWhat we mean, on a technical level, by deprecation in this case is still not clear to me (just in documentation, or with code attributes as well?), but you\u2019ll always be able to use `Invoke-Expression` (even though you shouldn\u2019t).\r\n\r\n> As someone who does use Invoke-Expression for good reason, in a small number of scripts\r\n\r\nWould you be able to share those scenarios/usages or adaptations of them? I think @sdwheeler in particular is looking for examples of `iex` usage.",
      "created_at": "2020-01-23T18:45:16Z",
      "updated_at": "2020-01-23T20:19:59Z"
    },
    {
      "author": "sdwheeler",
      "author_association": "COLLABORATOR",
      "body": "@rjmholt Thanks. Well said. The purpose of this issue was to discuss whether we should add the \"deprecated\" attribute to the code to enhance the warning about use of the cmdlet. This is separate from the question of how should this be documented.\r\n\r\nI am also looking for good example for how and why you are using IEX instead of the the &-operator. If someone can provide a useful example then we can add that to the documentation. Otherwise, I will just update the documentation with a more direct recommendation for not using the cmdlet.",
      "created_at": "2020-01-23T19:27:20Z",
      "updated_at": "2020-01-23T19:27:39Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> Here and in a few other places there has been some confusion about the meaning of the term `deprecate`. It simply means to _express disapproval of_, to disrecommend.\r\n\r\nYeah literally every time the term is used.  Y'all may want to adopt a template for using the term in a public space, something like:\r\n\r\n> **IMPORTANT NOTE:** *This is not about **removing** ___. ([Link to doc on what deprecation means]())*\r\n>\r\n> The actual post content.\r\n\r\nActually I don't know if anyone would read that.  Maybe a different term with less connotation needs to be used instead.\r\n\r\n> @rjmholt Thanks. Well said. The purpose of this issue was to discuss whether we should add the \"deprecated\" attribute to the code to enhance the warning about use of the cmdlet. This is separate from the question of how should this be documented.\r\n\r\nDo you mean `ObsoleteAttribute`? If so, the runtime warnings would get *really* annoying.  A PSSA rule is where this would need to live imo.\r\n",
      "created_at": "2020-01-23T19:55:52Z",
      "updated_at": "2020-01-23T19:55:52Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": ">  whether we should add the \"deprecated\" attribute to the code to enhance the warning about use of the cmdlet. This is separate from the question of how should this be documented.\r\n\r\nThanks for that clarification, @sdwheeler; the distinction wasn't obvious to me, and it seems that these aspects have already been conflated here, which is just as well, because I think discussing them in tandem makes sense.\r\n\r\n---\r\n\r\nAs for the _attribute_: I agree with @SeeminglyScience  that a PSSA rule is the right place to warn programmatically, if desired; certainly not at runtime, as that amounts to a quasi-breaking change.\r\n\r\n---\r\n\r\nAs for _documentation_ and use cases:\r\n\r\nIn the `Invoke-Expression` help topic, I think a general warning is sufficient, as @rjmholt proposes, along the following lines (adapted from the original https://github.com/MicrosoftDocs/PowerShell-Docs/issues/2679 issue):\r\n\r\n---\r\n\r\n> As a matter of habit, avoid use of `Invoke-Expression`, because there are usually more secure and robust alternatives.\r\n\r\n> If you do find that `Invoke-Expression` is your only choice, _carefully consider the security implications_: if a string from an (untrusted) outside source (e.g., user input) is passed directly to `Invoke-Expression`, _arbitrary commands may be executed_.\r\n\r\n---\r\n\r\nI think that is sufficient for this particular help topic, but _separately_, perhaps in a new `about_Invoke-Expression` conceptual help topic, we could focus on when _not_ to use `Invoke-Expression`.\r\n\r\nSpecifically, we could take widespread current and historical (mis)uses of `Invoke-Expression` and show _superior, safer alternatives_.\r\n\r\nIf we do end up agreeing on legitimate _public_ uses worth advertising (other than during PowerShell tests, as described by @rjmholt in https://github.com/MicrosoftDocs/PowerShell-Docs/issues/4897#issuecomment-548141117), we can add them there as well.\r\n\r\nEven in the perhaps most seductive use case - direct execution of script text downloaded from the web (e.g,  `iwr https://aka.ms/install-powershell.ps1 | iex`) - `Invoke-Expression` is ultimately ill-advised, and enhancing `Invoke-Command` to operate on `Invoke-WebRequest` output should be favored - see https://github.com/PowerShell/PowerShell/issues/5909#issuecomment-461192202\r\n\r\n\r\n\r\n",
      "created_at": "2020-01-23T20:20:50Z",
      "updated_at": "2020-01-23T20:24:37Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "In fact [PSSA has had a rule to disrecommend `Invoke-Expression`](https://github.com/PowerShell/PSScriptAnalyzer/blob/master/RuleDocumentation/AvoidUsingInvokeExpression.md) for a few years now",
      "created_at": "2020-01-23T20:23:19Z",
      "updated_at": "2020-01-23T20:23:19Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> certainly not at runtime, as that amounts to a quasi-breaking change\r\n\r\nWhile I agree that adding an `ObsoleteAttribute` would be annoying and probably not what we want here, I strongly disagree that it would be a breaking change.\r\n\r\nIf adding `ObsoleteAttribute` to anything is a breaking change, then that attribute is pointless. The whole idea of attributes is that they behave as additive metadata.\r\n\r\nAnyway, that\u2019s a tangent.",
      "created_at": "2020-01-23T20:26:58Z",
      "updated_at": "2020-01-23T20:26:58Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> Specifically, we could take widespread current and historical (mis)uses of Invoke-Expression and show superior, safer alternatives.\r\n\r\nAbsolutely agreed.\r\n\r\nI\u2019d like to build a library of `Invoke-Expression` use-cases and document alternatives.\r\n\r\nUnfortunately in the three issues we\u2019ve been discussing this, we haven\u2019t managed to record any of those uses. Hopefully we can collect some here so we can write or enhance documentation around them.",
      "created_at": "2020-01-23T20:29:31Z",
      "updated_at": "2020-01-23T20:29:31Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "To close the tangent: I called it a _quasi_-breaking change in that it would be confusing if existing code suddenly triggered warnings that weren't there before (this is what happened to the `Send-MailMessage` cmdlet, for instance).",
      "created_at": "2020-01-23T20:33:35Z",
      "updated_at": "2020-01-23T20:33:35Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> To close the tangent\r\n\r\nUnfortunately that just extends the tangent (I also had Send-MailMessage in mind).\r\n\r\nIt might be best for us to open a new issue to discuss how we implement deprecation in PowerShell.",
      "created_at": "2020-01-23T20:42:21Z",
      "updated_at": "2020-01-23T20:42:21Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "There have been only two instances where I had to use `Invoke-Expression`.  One is the short one-liner to install PowerShell:\r\n\r\n```powershell\r\niex \"& { $(irm https://aka.ms/install-powershell.ps1) } -UseMSI -Preview\"\r\n```\r\n\r\nThe other is in negative Pester test cases where I need the test script to be parsed correctly, but want the test case to fail:\r\n\r\n```powershell\r\n            try {\r\n                $ErrorView = 'ConciseView'\r\n                Invoke-Expression '1/d'\r\n            }\r\n            catch {\r\n                $e = $_\r\n            }\r\n            finally {\r\n                $ErrorView = $oldErrorView\r\n            }\r\n```\r\n\r\nNether of these are mainstream cases.  The latter could be converted to:\r\n\r\n```powershell\r\n                [scriptblock]::Create('1/d').Invoke()\r\n```\r\n",
      "created_at": "2020-01-23T21:45:36Z",
      "updated_at": "2020-01-23T21:45:36Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT, the first case is the one I wish we could eliminate by the suggested [enhancement to `Invoke-Command`](https://github.com/PowerShell/PowerShell/issues/5909#issuecomment-461192202), because the `iex` solution is (a) awkward (need to use embedded `& { ... }` to avoid running directly in the caller's scope), but, more importantly, (b) _brittle_, because the presence of an `exit` statement in the downloaded script content would exit the PowerShell process as a whole.\r\n",
      "created_at": "2020-01-23T22:05:54Z",
      "updated_at": "2020-01-23T22:05:54Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Good point about the existing PSSA rule, @rjmholt: I just realized that you can see it in action with `Invoke-ScriptAnalyzer -ScriptDefinition 'Invoke-Expression \"1+1\"'`, but it's not enabled by default in Visual Studio Code - I've opened https://github.com/PowerShell/PowerShellEditorServices/issues/1166 to suggest changing that.",
      "created_at": "2020-01-23T22:40:20Z",
      "updated_at": "2020-01-23T22:40:20Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> While I agree that adding an `ObsoleteAttribute` would be annoying and probably not what we want here, I strongly disagree that it would be a breaking change.\r\n> \r\n> If adding `ObsoleteAttribute` to anything is a breaking change, then that attribute is pointless. \r\n\r\nIt definitely *can* break things (I know there is a difference between something breaking the change contract and a change technically breaking a thing, but bear with me):\r\n\r\n```powershell\r\nfunction Test-Something {\r\n    [CmdletBinding()]\r\n    param()\r\n    end {\r\n        if ($theWorldIsEnding) {\r\n            $PSCmdlet.WriteWarning('some bad stuff is happening')\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThis is part of why I don't really like the warning system at all.  Most of the things I would want to warn about are better off as a non-terminating error anyway.\r\n\r\nIf something is writing a warning, I'm either silencing it, or throwing on it.  If I'm throwing on it with `-WarningAction Stop`, then adding `ObsoleteAttribute` will cause my script to always throw.\r\n\r\nI know that if it's considered a breaking change than that makes the attribute useless, but that's how it feels currently. Personally I think `ObsoleteAttribute` should be moved to a design time warning only, *maybe* with `error: true` being the exception.  That's how C# works as well, anything already built keeps on chugging but you're gonna know about it if you try to use it in something new.\r\n\r\n> The whole idea of attributes is that they behave as additive metadata.\r\n\r\nThat's true up until the point where something reads that metadata and changes behavior based on it. Adding `Mandatory` to a `ParameterAttribute` for example is for sure a breaking change.\r\n\r\n**Edit:** ~~Sorry this is pretty off topic.  Probably should have saved it for the new issue @rjmholt referred to.~~ I've marked this as off-topic and copied the issue into the new thread.",
      "created_at": "2020-01-24T02:08:22Z",
      "updated_at": "2020-01-24T17:10:44Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Such a strapping young tangent deserves a proper home: #11674 (a new issue to discuss how we implement deprecation in PowerShell, as suggested by @rjmholt ).",
      "created_at": "2020-01-24T16:12:32Z",
      "updated_at": "2020-01-24T17:02:24Z"
    },
    {
      "author": "xtqqczze",
      "author_association": "CONTRIBUTOR",
      "body": "`Invoke-Expression` is used extensively in our build module. #9459 is stale PR to remove.",
      "created_at": "2020-01-31T00:33:38Z",
      "updated_at": "2020-01-31T00:33:38Z"
    },
    {
      "author": "JrrRomeroJose",
      "author_association": "NONE",
      "body": "Hello i was looking for best practices when running cmd on powershell and somehow reached this issue.\r\nhere i let you my example of use for invoke-Expression. I'd like to hear any different approach.\r\n\r\n\r\n\r\n```Powershell\r\n    $command = \"C:\\\"\"Program Files\"\"\\MongoDB\\Server\\4.2\\bin\\mongoimport.exe --db=$($db) --collection=$($Collection) --file=$($_.FullName)\"\r\n    Write-Host \"Importing file $($_.Name)\" -ForegroundColor Green\r\n    Invoke-Expression $command\r\n```\r\n\r\nThanks.\r\n",
      "created_at": "2020-02-01T12:42:21Z",
      "updated_at": "2020-02-01T12:42:21Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Always invoke external programs _directly_; if they're given with a quoted path / path in a variable, prepend `&`, the [call (execute) operator](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_Operators#call-operator-). If you need to define a command for _later_ execution, put it in a script block (`{ ...}`) rather than a string variable, and call the script block on demand with `&`\r\n\r\n```\r\n& \"C:\\Program Files\\MongoDB\\Server\\4.2\\bin\\mongoimport.exe\" --db=$($db) --collection=$($Collection) --file=$($_.FullName)\r\n```\r\n\r\nFor more information see [this SO answer](https://stackoverflow.com/a/57966347/45375).",
      "created_at": "2020-02-01T12:49:25Z",
      "updated_at": "2020-02-01T19:23:18Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> Invoke-Expression is used extensively in our build module. #9459 is stale PR to remove.\r\n\r\nHmmmm. It looks like all those invocations could be replaced with a `&` and passing the arguments as literals. But the `[scriptblock]::Create()` method does exactly the same thing as `Invoke-Expression`. Perhaps we should write that into the rule?\r\n\r\n@JrrRomeroJose In your case @mklement0 is spot on. One point that comes up there sometimes is that `Invoke-Expression` on a string makes it easier to record exactly what the command executed was. However, that's exactly what [transcription](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.host/start-transcript?view=powershell-7) is intended to do.",
      "created_at": "2020-02-01T19:27:04Z",
      "updated_at": "2020-02-01T19:27:04Z"
    },
    {
      "author": "fedorbirjukov",
      "author_association": "NONE",
      "body": "I am using Invoke-Expression to stop on non-zero exit code because $ErrorActionPreference = 'Stop' does not stop in that case.\r\n\r\nHelper function\r\n```\r\nfunction Invoke-ExpressionWithExitCode($Command) {\r\n    Invoke-Expression \"& $Command\"\r\n    if ($LastExitCode) {\r\n        throw \"Error: non-zero exit code ($($LastExitCode)) for command: $Command\"\r\n    }\r\n}\r\nNew-Alias -Name iex0 -Value Invoke-ExpressionWithExitCode\r\n```\r\n\r\nExample (execution stops only after the second clone)\r\n```\r\nPS> $ErrorActionPreference = 'Stop'\r\nPS> git clone wrongurl; iex0 \"git clone wrongurl\"; git clone wrongurl\r\nfatal: repository 'wrongurl' does not exist\r\nfatal: repository 'wrongurl' does not exist\r\nError: non-zero exit code (128) for command: git clone wrongurl\r\nAt line:4 char:9\r\n+         throw \"Error: non-zero exit code ($($LastExitCode)) for comma ...\r\n+         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n    + CategoryInfo          : OperationStopped: (Error: non-zero... clone wrongurl:String) [], RuntimeException\r\n    + FullyQualifiedErrorId : Error: non-zero exit code (128) for command: git clone wrongurl\r\n```",
      "created_at": "2020-02-07T12:41:01Z",
      "updated_at": "2020-02-07T12:41:01Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@fedorbirjukov, here's how to do it without  `Invoke-Expression`, which has the added advantage of being able to use regular invocation syntax and avoiding headaches related to embedded quoting.\r\n\r\n```powershell\r\nfunction Invoke-Utility {\r\n  $exe, $argsForExe = $Args\r\n  $ErrorActionPreference = 'Continue' # to prevent 2> redirections from triggering a terminating error.\r\n  try { & $exe $argsForExe } catch { Throw } # catch is triggered ONLY if $exe can't be found, never for errors reported by $exe itself\r\n  if ($LASTEXITCODE) { Throw \"$exe indicated failure (exit code $LASTEXITCODE; full command: $Args).\" }\r\n}\r\nSet-Alias iu Invoke-Utility\r\n\r\n# Invoke as you would normally, just prepend \"iu \"\r\niu git clone wrongurl\r\n```",
      "created_at": "2020-02-07T13:03:10Z",
      "updated_at": "2020-02-09T22:14:29Z"
    },
    {
      "author": "fedorbirjukov",
      "author_association": "NONE",
      "body": "@mklement0 \r\nThanks for replying. I've seen this snippet before. But only now am I seeing why iex0 is worse than iu. Mostly because it does more than one call... I even uncovered a bug in my script thanks to this.",
      "created_at": "2020-02-08T15:00:31Z",
      "updated_at": "2020-02-08T15:00:31Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "PowerShell's own build actually defines a function for this too:\r\n\r\nhttps://github.com/PowerShell/PowerShell/blob/aefb82a3087a6e2fec859fe657337b1a9985e886/test/tools/Modules/HelpersCommon/HelpersCommon.psm1#L267-L312",
      "created_at": "2020-02-08T18:07:14Z",
      "updated_at": "2020-02-08T18:07:14Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@fedorbirjukov, I've had to update the `Invoke-UtilityFunction` above to work around the bug described in #4002, which causes `2>` stderr redirections while `$ErrorActionPreference = 'Stop'` is in effect to trigger script-terminating errors; with the update, you can now call `iu git clone 2>$null` to silence stderr output without ill effects (while still enforcing a nonzero exit code).\r\n\r\nTangent alert:\r\n\r\n* All current problems with `2>` stderr redirections are summarized in [this SO answer](https://stackoverflow.com/a/60115289/45375).\r\n* A _synchronous_ function such as `Start-NativeExecution` shouldn't use the `Start` verb, which is for _asynchronous_ operations (the `Start-Sleep` cmdlet, which sleeps _synchronously_ is an unfortunate, very public exception).\r\n* One shouldn't have to write wrapper functions at all, given that calling external (native) programs with proper error handling should be a shell's core mandate - see [this RFC draft](https://github.com/PowerShell/PowerShell-RFC/pull/88/files).\r\n* For a wrapper function that compensates for PowerShell's broken handling of quoting of embedded `\"` chars. / empty arguments when calling external programs, see https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-562334606\r\n</sup>\r\n\r\n",
      "created_at": "2020-02-09T22:33:15Z",
      "updated_at": "2020-02-09T22:33:15Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> Here and in a few other places there has been some confusion about the meaning of the term `deprecate`. It simply means to _express disapproval of_, to disrecommend. Obsolescence is one reason to do so, but another is unnecessary danger. `Invoke-Expression` lies in the second category; it\u2019s not going anywhere but it\u2019s [dangerous](https://devblogs.microsoft.com/powershell/invoke-expression-considered-harmful/) to use non-interactively, both from a [security standpoint](https://community.idera.com/database-tools/powershell/powertips/b/tips/posts/why-invoke-expression-is-evil) and an efficiency one (the whole parser/compiler toolchain has to be run again at execution time).\r\n\r\nIf `Invoke-Expression` gets deprecated, there is an easy workaround: put the script into a temporary file and execute that one.  Write a function that does this for you and you are all set.  Deprecating does not make any sense to me.",
      "created_at": "2020-07-13T14:24:29Z",
      "updated_at": "2020-07-13T14:55:48Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "Say you marked the command with `[ObsoleteAttribute(\"This command is dangerous in non-interactive scenarios and its use is not recommended.\")]`.  Where would we see that?  Personally, I do not want to see that at runtime.  I suppose the help system could detect and show this attribute:\r\n```powershell\r\nPS> help Invoke-Expression\r\n\r\n\r\nOBSOLETE: This command has been marked as obsolete. This command is dangerous in non-interactive scenarios \r\nand its use is not recommended.\r\n\r\nNAME\r\n    Invoke-Expression\r\n\r\nSYNOPSIS\r\n    Runs commands or expressions on the local computer.\r\n\r\n...\r\n```\r\nAnd I suppose PSSA could detect this attribute and use it to flag usage of obsolete commands.  Is there anywhere else this would be surfaced?\r\n",
      "created_at": "2020-07-15T18:05:31Z",
      "updated_at": "2020-07-15T21:34:13Z"
    },
    {
      "author": "JrrRomeroJose",
      "author_association": "NONE",
      "body": "Maybe a one time Warning. Just like Windows Powershell has his own message 'Try the new cross-platform....' but instead of being there always you should only see it one time. moreover, You could add a link to a good post that explain why using it and why not and the workaround that you have.\r\n\r\n![imagen](https://user-images.githubusercontent.com/42807262/87651092-e5827800-c752-11ea-9873-5a1a0cec81b4.png)\r\n",
      "created_at": "2020-07-16T09:00:56Z",
      "updated_at": "2020-07-16T09:00:56Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I don't think a warning in the shell is particularly useful. Quite possibly a lot of folks may end up seeing it from code that isn't even theirs and have no real recourse, so completely ignore it.\r\n\r\nA PSSA rule is a much more effective strategy in my mind.",
      "created_at": "2020-07-16T14:15:29Z",
      "updated_at": "2020-07-16T14:15:29Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Given the length of this thread, let me try to summarize:\r\n\r\nUsing `[Obsolete()]` would indeed currently surface the warning _at runtime_ (as you currently get with `1 | Format-Hex -Raw`, for instance), which I agree is undesirable.\r\n   * The general deprecation discussion in #11674 also touches on whether even uses of `[ObsoleteAttribute()]` should ever surface _at runtime_, or whether they should surface at runtime only _on demand_ and/or possibly by default only in direct, interactive calls.\r\n   * Surfacing them categorically (also) via PSSA is also suggested there (but there are limits to recognizing the use of deprecated features through static analysis alone.)\r\n\r\nAssuming that there's agreement that runtime warnings should be avoided at least in this case (which is what it sounds like), the pieces to the puzzle are mostly already in place:\r\n\r\n * A PSSA rule for `Invoke-Expression` (specifically, with no `ObsoleteAttribute` involved) [_already exists_](https://github.com/PowerShell/PSScriptAnalyzer/blob/master/RuleDocumentation/AvoidUsingInvokeExpression.md), it just needs to be [_turned on by default_](https://github.com/PowerShell/PowerShellEditorServices/issues/1166) (there has been no activity since this suggestion was posted on 23 January 2020).\r\n\r\n * `Get-Help Invoke-Expression` already [shows a warning](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/invoke-expression?view=powershell-7.1), which in the console (somewhat awkwardly) surfaces as follows:\r\n\r\n```none\r\n > [!CAUTION] > Take reasonable precautions when using the `Invoke-Expression` cmdlet in scripts. When using >\r\n`Invoke-Expression` to run a command that the user enters, verify that the command is safe to run > before\r\nrunning it. In general, it is best to design your script with predefined input options, > rather than allowing\r\nfreeform input.\r\n```\r\n\r\n * As for further guidance: There's currently only a _Wiki_ article in the docs repo that is an unpolished collection of background information, scenarios to avoid, and also legitimate uses: https://github.com/MicrosoftDocs/PowerShell-Docs/wiki/The-case-for-and-against-Invoke-Expression\r\n     * Presumably because of its unpolished state, it isn't linked to from the `Invoke-Expression` help topic, which makes it hard to discover.\r\n\r\n\r\n\r\n\r\n<blockquote><img src=\"https://repository-images.githubusercontent.com/44411511/850abe80-7ca6-11e9-886f-a1b13b275ae0\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/MicrosoftDocs/PowerShell-Docs\">MicrosoftDocs/PowerShell-Docs</a></strong></div><div>The official PowerShell documentation sources. Contribute to MicrosoftDocs/PowerShell-Docs development by creating an account on GitHub.</div></blockquote>",
      "created_at": "2020-07-17T14:25:52Z",
      "updated_at": "2020-07-17T14:31:24Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "You asked for reasons why we use it:\r\n\r\n## 1. Testability.\r\n\r\nShow me a way to **mock** the & call operator in Pester tests, and I could remove the vast majority of `Invoke-Expression` from my production code.\r\n\r\n## 2. Testing.\r\n\r\nIn our tests (and, incidentally, in the tests for Microsoft's DSC), there are frequent uses of Invoke-Expression to dynamically generate larger suites of tests without copy/pasting ... \r\n\r\n## 3. Importing metadata that aren't module manifests\r\n\r\nPeople who are not using my `Configuration` module or something like it, frequently use `Invoke-Expression (Get-Content...)` instead of Import-LocalizedData because:\r\n1. Import-LocalizedData is overly complicated to use for miscellaneous files because it has no -Path parameter\r\n2. Import-LocalizedData was too restrictive on the commands **and variables** it considered \"safe\" in metadata files (not even allowing all the same ones as module manifests). \r\n3. `Parser.ParseInput` or `Parser.ParseFile` combined with `ScriptBlock.CheckRestrictedLanguage` are complicated to use (especially since they've changed across PS versions)\r\n\r\n**BIG NOTE:** All we really need is for `Import-LocalizedData` to have a `-Path` parameter set in addition to the parameter set it has now, and a `-AllowedVariable` parameter to match `-AllowedCommand` it already has. Maybe alias it as `Import-Metadata` too ;-)\r\n\r\n## 4. Invoking code someone else gives us.\r\n\r\nYeah, this obviously includes a lot of at-the-commandline-only unsafe things like:\r\n```PowerShell\r\nInvoke-Expression (Invoke-RestMethod 'https://chocolatey.org/install.ps1')\r\n```\r\n\r\nBut it also includes _really valid_ things like loading tab-completers from third party utilities:\r\n```PowerShell\r\nconda \"shell.powershell\" \"hook\" | Out-String | Invoke-Expression\r\n```\r\n```PowerShell\r\nchezmoi completion powershell | Out-String | Invoke-Expression\r\n```\r\n\r\n\r\n## My Conclusion\r\n\r\nObviously a lot of people will be very upset (as we always are when you break things) if you make our existing production code start producing warnings just because you've decided something you wrote a decade ago was a bad idea.\r\n\r\nScriptAnalyzer rules are a more polite way to coerce people to do things differently\r\n\r\nThis item has been open for way too long. There needs to be an automatic time-out on issues opened for the purpose of discussion.",
      "created_at": "2020-09-23T16:13:32Z",
      "updated_at": "2021-01-20T19:54:54Z"
    },
    {
      "author": "sdwheeler",
      "author_association": "COLLABORATOR",
      "body": "@Jaykul Thanks, these are good examples.",
      "created_at": "2020-09-23T16:53:29Z",
      "updated_at": "2020-09-23T16:53:29Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@sdwheeler, probably worth adding to https://github.com/MicrosoftDocs/PowerShell-Docs/wiki/The-case-for-and-against-Invoke-Expression.\r\n\r\n@Jaykul, an aside re the `Invoke-Expression` /  `Invoke-RestMethod` combo for executing downloaded script contents: leaving aside that an `exit` in the dowloaded script text exits the entire session when evaluated with `Invoke-Expression`, the need for this idiom would go away:\r\n\r\n*  if we had support for `Invoke-WebRequest` output in `Invoke-Command` (e.g.,\r\n`iwr https://aka.ms/install-powershell.ps1 | icm`), as proposed in https://github.com/PowerShell/PowerShell/issues/5909#issuecomment-461192202, and things would get even simpler if #8835 gets implemented.\r\n\r\n* or, as an out-of-process alternative, if `pwsh -` worked properly with code piped to it (e.g.,\r\n`irm https://aka.ms/install-powershell.ps1 | pwsh`)  - see #3223.\r\n\r\n<blockquote><img src=\"https://repository-images.githubusercontent.com/44411511/850abe80-7ca6-11e9-886f-a1b13b275ae0\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/MicrosoftDocs/PowerShell-Docs\">MicrosoftDocs/PowerShell-Docs</a></strong></div><div>The official PowerShell documentation sources. Contribute to MicrosoftDocs/PowerShell-Docs development by creating an account on GitHub.</div></blockquote>",
      "created_at": "2020-09-23T17:21:34Z",
      "updated_at": "2020-09-23T17:30:35Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "For point #1, you could just wrap the code that invokes via `&` in a function and mock that. But yes, it's less convenient, for sure.\r\n\r\nI wonder if it will be really needed for #2 with Pester's new -ForEach functionality to generate tests a bit more dynamically, but yeah there are definitely some cases where things are much neater with code gen than other methods.\r\n\r\nFor #3 I think we may have other issues around that, but I agree it would be _very_ nice to make it easier to import files like that natively without invoke-expression.\r\n\r\nAnd heck, half the time I won't even really bother with Invoke-Expression for downloaded scripts like that, I'll just construct a scriptblock and use `&` to invoke it.\r\n\r\n---\r\n\r\nBut yeah, I don't think deprecating it is really the right move. There are better alternatives for _some_ of its use cases, but not all, at least at the moment.\r\n",
      "created_at": "2020-09-23T17:22:58Z",
      "updated_at": "2020-09-23T17:22:58Z"
    },
    {
      "author": "sdwheeler",
      "author_association": "COLLABORATOR",
      "body": "I plan to incorporate the feedback from here and move the wiki article to the 'Deep Dives' section of the docs. ",
      "created_at": "2020-09-23T17:36:27Z",
      "updated_at": "2020-09-23T17:36:27Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> Show me a way to mock the & call operator in Pester tests, and I could remove the vast majority of Invoke-Expression from my production code.\r\n\r\nCould you expand on the scenario here, or give an example of the mocking for a test (i.e. where the mocking steps in for testing)?",
      "created_at": "2020-09-23T17:47:45Z",
      "updated_at": "2020-09-23T17:47:45Z"
    },
    {
      "author": "StewartRyanSony",
      "author_association": "NONE",
      "body": "@Jaykul touched on this, but I don't know of another way to setup tab completion of a parameter there the possible values exist outside of the script. Here's an example.\r\n\r\n```powershell\r\nparam(\r\n    [Parameter(Mandatory=$false, Position=0, ParameterSetName='Environment')]\r\n    [ArgumentCompleter(\r\n        {\r\n            param ($Command, $Parameter, $WordToComplete, $CommandAst, $FakeBoundParams)\r\n            $ParamPath = \"$($PSScriptRoot ? $PSScriptRoot : $(Get-Location))\\Environments.json\"\r\n            if (!(Test-Path $ParamPath)) {\"Environments.json file not found. Please be sure this file is in the same directory as this script. Otherwise, please use the other parameters\"}\r\n            else {\r\n                Get-Content $ParamPath | ConvertFrom-Json | Select-Object -ExpandProperty Name | Where-Object {$_ -like \"$WordToComplete*\"}\r\n            }\r\n        }\r\n    )]\r\n    [ValidateScript(\r\n        {\r\n            $_ -in (Invoke-Command {\r\n                $ParamPath = \"$($PSScriptRoot ? $PSScriptRoot : $(Get-Location))\\Environments.json\"\r\n                Get-Content $ParamPath | ConvertFrom-Json | Select-Object -ExpandProperty Name\r\n            })\r\n        }\r\n    )]\r\n    [Alias('Environment')]\r\n    [String]$Environment = \"Dev\",\r\n...\r\n```",
      "created_at": "2020-11-17T19:44:29Z",
      "updated_at": "2020-11-17T19:44:56Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> Here's an example.\r\n\r\nI can't see `Invoke-Expression` used in the example. You could probably also remove `Invoke-Command` too:\r\n\r\n```powershell\r\n[ValidateScript(\r\n    {\r\n        $valuesPath = Join-Path ($PSScriptRoot ? $PSScriptRoot : Get-Location) 'Environments.json'\r\n        $validValues = Get-Content -Raw -LiteralPath $valuesPath | ConvertFrom-Json | Select-Object -ExpandProperty Name\r\n        return $_ -in $validValues\r\n    }\r\n)]\r\n```",
      "created_at": "2020-11-17T22:17:57Z",
      "updated_at": "2020-11-17T22:17:57Z"
    },
    {
      "author": "StewartRyanSony",
      "author_association": "NONE",
      "body": "oh, you're right. I used Invoke-Command. I think I changed that and forgot about it. Never mind\r\nThat is a bit cleaner without Invoke-Command too. Thanks",
      "created_at": "2020-11-17T22:38:35Z",
      "updated_at": "2020-11-17T22:41:40Z"
    },
    {
      "author": "aescolastico",
      "author_association": "NONE",
      "body": "Is using '&' a suitable replacement for running exes, or are they the same thing? I use Start-Process sometimes, but that doesn't cleanly handle sdtout, sdtin and sdterr streams",
      "created_at": "2020-12-13T00:13:31Z",
      "updated_at": "2020-12-13T00:13:54Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> Is using '&' a suitable replacement for running exes, or are they the same thing? I use Start-Process sometimes, but that doesn't cleanly handle sdtout, sdtin and sdterr streams\r\n\r\nNo and no.  And RTM.",
      "created_at": "2020-12-14T10:17:10Z",
      "updated_at": "2020-12-14T10:17:59Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@aescolastico: The `&` operator does _not_ evaluate PowerShell source code stored in a string the way that `Invoke-Expression` does. \r\n\r\nIt only accepts a _command name or path_ as its operand (or, alternatively a script block), so for running external programs the arguments must still be passed separately. \r\n\r\nIn fact, the only reason `&` is ever needed when calling external programs is a _syntactic_ one: So that PowerShell knows you're executing a command, `&` must be used if the executable file path is specified in quotes and/or contains variable references / subexpressions (`& \"C:\\Program Files\\Acme\\foo.exe\" bar` or `& $HOME\\bin\\foo.exe bar`); otherwise, just invoke the executable directly (`C:\\Users\\jdoe\\bin\\foo.exe bar`).\r\n\r\nIf you need to construct arguments programmatically, it is much cleaner to create them as elements of an array first, which you can then pass as a whole (`$arguments = 'bar', 'baz'; foo.exe $arguments`) - beware the issues around passing empty-string arguments and arguments with embedded `\"` chars., however - see #1995.\r\n\r\n`Start-Process`, which allows you to pass the list of arguments for an external executable as a single string, is the wrong tool for synchronously invoking external programs that are console applications - as you've observed, you lose integration with PowerShell's streams, even if you run the process synchronously (`-Wait`) in the same console window (`-NoNewWindow`, implied on Unix-like platforms).\r\n",
      "created_at": "2020-12-14T13:15:00Z",
      "updated_at": "2020-12-14T13:19:20Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> In fact, the only reason `&` is ever needed when calling external programs is a _syntactic_ one: So that PowerShell knows you're executing a command, `&` must be used if the executable file path ~is specified in quotes and/or~ contains variable references / subexpressions (`& \"C:\\Program Files\\Acme\\foo.exe\" bar` or `& $HOME\\bin\\foo.exe bar`); otherwise, just invoke the executable directly (`C:\\Users\\jdoe\\bin\\foo.exe bar`).\r\n\r\n`C:\\\"Program Files\\Acme\\foo.exe\" bar` should work too.",
      "created_at": "2020-12-15T15:57:48Z",
      "updated_at": "2020-12-15T15:57:48Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Yes, what matters is whether the _first character_ is a quote - because that determines the [parsing mode](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_Parsing) - so technically the rule is \"specified in quotes _as a whole_ or _starts with a quoted token_ and/or contains variable references / subexpressions\".\r\n\r\nPragmatically speaking, since `&` _always_ works and partial quoting isn't common, the simplified rule \"specified in quotes and/or contains variable references / subexpressions\" is easier to remember and should suffice.",
      "created_at": "2020-12-15T16:17:22Z",
      "updated_at": "2020-12-15T16:20:49Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> @sdwheeler, probably worth adding to https://github.com/MicrosoftDocs/PowerShell-Docs/wiki/The-case-for-and-against-Invoke-Expression.\r\n\r\n####  The-case-for-and-against-Invoke-Expression.md \r\n```patch\r\nindex e01a666..44f0936 100644\r\n@@ -49,7 +49,7 @@ There are probably a few layers of \"I want to use Invoke-Expression\":\r\n     - To [parse a string with embedded quoting](https://stackoverflow.com/a/51229037/45375), _with extra precautions_\r\n     - To [parse command lines stored in a file](https://stackoverflow.com/a/60328737/45375), _if trusted_\r\n \r\n-Despite the legitimacy of some use cases, I think they're as rare as hens' teeth and we shouldn't\r\n+Despite the legitimacy of some use cases, I think they're as rare as hen&rsquo;s teeth and we shouldn't\r\n list them; dynamically creating classes or executing output from a command are, even without\r\n `Invoke-Expression`, things users should only be doing as a last resort.\r\n```\n\n<blockquote><img src=\"https://repository-images.githubusercontent.com/44411511/850abe80-7ca6-11e9-886f-a1b13b275ae0\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/MicrosoftDocs/PowerShell-Docs\">MicrosoftDocs/PowerShell-Docs</a></strong></div><div>The official PowerShell documentation sources. Contribute to MicrosoftDocs/PowerShell-Docs development by creating an account on GitHub.</div></blockquote>",
      "created_at": "2020-12-16T00:05:20Z",
      "updated_at": "2020-12-16T00:05:23Z"
    },
    {
      "author": "aescolastico",
      "author_association": "NONE",
      "body": "> @aescolastico: The `&` operator does _not_ evaluate PowerShell source code stored in a string the way that `Invoke-Expression` does.\r\n> \r\n> It only accepts a _command name or path_ as its operand (or, alternatively a script block), so for running external programs the arguments must still be passed separately.\r\n> \r\n> In fact, the only reason `&` is ever needed when calling external programs is a _syntactic_ one: So that PowerShell knows you're executing a command, `&` must be used if the executable file path is specified in quotes and/or contains variable references / subexpressions (`& \"C:\\Program Files\\Acme\\foo.exe\" bar` or `& $HOME\\bin\\foo.exe bar`); otherwise, just invoke the executable directly (`C:\\Users\\jdoe\\bin\\foo.exe bar`).\r\n> \r\n> If you need to construct arguments programmatically, it is much cleaner to create them as elements of an array first, which you can then pass as a whole (`$arguments = 'bar', 'baz'; foo.exe $arguments`) - beware the issues around passing empty-string arguments and arguments with embedded `\"` chars., however - see #1995.\r\n> \r\n> `Start-Process`, which allows you to pass the list of arguments for an external executable as a single string, is the wrong tool for synchronously invoking external programs that are console applications - as you've observed, you lose integration with PowerShell's streams, even if you run the process synchronously (`-Wait`) in the same console window (`-NoNewWindow`, implied on Unix-like platforms).\r\n\r\n@mklement0 \r\nThis is a very clear and succinct explanation. Thank you.\r\n\r\nDo you know if there are ways of invoking scripts hosted online without using iex?\r\nie \r\nDownloadString or BITs $scriptURL | Invoke-Expression\r\n\r\nI guess you could download the script to a temp ps1 file, call that, then delete it. But I'm curious if there's a way to do it entirely in memory. ",
      "created_at": "2020-12-16T00:12:05Z",
      "updated_at": "2020-12-16T00:12:39Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> I guess you could download the script to a temp ps1 file, call that, then delete it. But I'm curious if there's a way to do it entirely in memory.\r\n\r\nExecuting a script saved to a temporary file does it entirely in memory.\r\n",
      "created_at": "2020-12-16T00:14:41Z",
      "updated_at": "2020-12-16T00:14:41Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "@mklement0 wrote: \r\n>The `&` operator does _not_ evaluate PowerShell source code stored in a string the way that `Invoke-Expression` does.\r\n> \r\n> It only accepts a _command name or path_ as its operand (or, alternatively a script block), so for running external programs the arguments must still be passed separately.\r\n\r\nOr any of the command *Info objects, or a module object and _then_ a scriptblock, or  ... well, you get the drift, there's actually a lot of things, but in all cases, the thing `&` applies to an an object treated literally, not parsed...\r\n\r\n@yecril71pl writes:\r\n> Executing a script saved to a temporary file does it entirely in memory.\r\n\r\nHuh? Are we being super pedantic here for a reason? \r\nYes, it _executes_ in memory, _because that's what execution means_.\r\nBut the point he's making is that _downloading it to file_ creates a file _on disk_ which needs cleaning up ... \r\n\r\n@mklement0 also wrote, much earlier: \r\n> the need for this idiom would go away:\r\n> \r\n>     * if we had support for `Invoke-WebRequest` output in `Invoke-Command` (e.g.,\r\n>       `iwr https://aka.ms/install-powershell.ps1 | icm`), as proposed in [#5909 (comment)](https://github.com/PowerShell/PowerShell/issues/5909#issuecomment-461192202), and things would get even simpler if #8835 gets implemented.\r\n>     * or, as an out-of-process alternative, if `pwsh -` worked properly with code piped to it (e.g.,\r\n>       `irm https://aka.ms/install-powershell.ps1 | pwsh`)  - see #3223.\r\n\r\nYes, obviously if we did either of those things, we would certainly remove the need for `Invoke-Expression` -- but what would be the point? If we did that, we would have simply transferred all the \"inherent security risks\" the OP reffered to into new places which would be **much** harder to flag in a code review or static analyzer.\r\n\r\nP.S. @sdwheeler none of the examples I gave you made it into that \"wiki\" page. Note that I use \"wiki\" in quotes here, because those things are less editable than the source code in this repo...",
      "created_at": "2020-12-17T22:00:08Z",
      "updated_at": "2020-12-17T22:04:19Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> Yes, obviously if we did either of those things, we would certainly remove the need for `Invoke-Expression`\r\n\r\nThe primary reason for not using `Invoke-Expression` (`iex`) is that is is _inadequate_ for running the content of script files directly from the web:\r\n\r\n* The code runs directly in the caller's scope - a pollution of that scope that is likely unwanted.\r\n* If the downloaded code contains an `exit` statement, the session exits as a whole.\r\n* Passing _arguments_ isn't supported.\r\n* (There are also 2 bugs, though they obviously could and should be fixed:  #8778 and #8815)\r\n\r\nRather than extend `Invoke-Expression`, it makes more sense to enhance `Invoke-Command`, [as proposed](https://github.com/PowerShell/PowerShell/issues/5909#issuecomment-461192202).\r\n\r\n* `Invoke-Command` (`icm`) runs code in a child scope by default, while allowing running directly in the caller's scope as an opt-in via `-NoNewScope`.\r\n\r\n* With an `Invoke-WebRequest` (`iwr`) output object as input, it would have to treat `exit` as simply exiting the child scope, i.e. it would have to treat the code as if it were a script _file_.\r\n\r\n* It already supports passing arguments via `-ArgumentList` / `-Args`.\r\n  * However, since this is an _array_ parameter, the syntax for multiple arguments is somewhat awkward, so making `-ArgumentList` a `ValueFromRemainingParameters` parameter should help. \r\n\r\n```powershell\r\n# WISHFUL THINKING\r\niwr https://aka.ms/install-powershell.ps1 | icm -- -Preview\"\r\n```\r\n\r\n---\r\n\r\nAlso, to recap @SteveL-MSFT's workaround for use of `Invoke-Expression` (in combination with `Invoke-RestMethod` / `irm`), which works around the argument-passing issue and the _scope_ issue, but not the `exit` issue:\r\n\r\n```powershell\r\niex \"& { $(irm https://aka.ms/install-powershell.ps1) } -Preview\"\r\n```\r\n\r\nNeedless to say, even if that fully worked as intended, it would neither be obvious nor convenient.",
      "created_at": "2020-12-17T22:21:20Z",
      "updated_at": "2020-12-18T17:15:07Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I forgot to spell out another important limitation of `Invoke-Expression` with respect to direct execution of an online script: the inability to pass _arguments_ (which, again, `Invoke-Command` already supports); I've amended the previous comment.",
      "created_at": "2020-12-18T17:11:41Z",
      "updated_at": "2020-12-18T19:56:44Z"
    },
    {
      "author": "yecril71pl",
      "author_association": "CONTRIBUTOR",
      "body": "> > Executing a script saved to a temporary file does it entirely in memory.\r\n> \r\n> Huh? Are we being super pedantic here for a reason?\r\n> Yes, it _executes_ in memory, _because that's what execution means_.\r\n> But the point he's making is that _downloading it to file_ creates a file _on disk_ which needs cleaning up ...\r\n\r\nThe storage for (small) temporary files is in RAM.\r\n\r\n> those things are less editable than the source code in this repo\r\n\r\nThe wiki is easier to edit when you are a member of the project.",
      "created_at": "2020-12-20T20:44:21Z",
      "updated_at": "2020-12-20T21:11:49Z"
    },
    {
      "author": "JamesWTruher",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee reviewed this 5/11/2022\r\nWe definitely do not want to deprecate `Invoke-Expression` - when you _need_ it, you really _need_ it. We also have _no_ plans to remove it from the product, so marking it as deprecated which implies that it won't always be there is misleading. However, we do agree that we could possibly provide more guidance and information as to why it's such a dangerous tool.",
      "created_at": "2022-05-12T00:40:39Z",
      "updated_at": "2022-05-12T01:17:32Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This issue has been marked as by-design and has not had any activity for **1 day**. It has been closed for housekeeping purposes.",
      "created_at": "2022-05-13T09:00:44Z",
      "updated_at": "2022-05-13T09:00:44Z"
    }
  ],
  "created_at": "2020-01-22T22:28:54Z",
  "labels": [
    "Issue-Enhancement",
    "Resolution-By Design",
    "Issue-Discussion",
    "WG-Cmdlets-Utility"
  ],
  "number": 11662,
  "state": "closed",
  "title": "Should we officially \"deprecate\" Invoke-Expression?",
  "updated_at": "2022-05-13T09:00:45Z"
}