{
  "_url": "https://github.com/PowerShell/PowerShell/issues/3327",
  "author": "daxian-dbw",
  "body": "Our assembly cache contains assemblies that are explicitly loaded by powershell engine, such as via module loading or the assembly entries from InitialSessionState. We should search it before searching all loaded assemblies to give preference to resolve a type against the assemblies contained in the cache, so that in case there is a conflict, we might have a preferred assembly to use for a type resolution.\r\n\r\nChanges:\r\n1. Search from `context.AssemblyCache.Values` before search from all loaded assemblies.\r\n2. Skip assemblies that we already searched and found no matching type.\r\n3. Skip checking PS types kept in the scope and type accelerators when it's not necessary.",
  "closed_at": "2017-03-17T20:19:32Z",
  "comments": [
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "CoreCLR doesn't have multiple load contexts, but I think I can add a test to validate the assembly cache preference.",
      "created_at": "2017-03-13T23:59:42Z",
      "updated_at": "2017-03-13T23:59:42Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "I should add - I've always thought our type resolution is messed up in that we don't build a symbol table ever.\r\n\r\nWhen I introduced this bug, I was moving in the direction of a more traditional symbol table, at least by simplifying the lookup some. This change moves in the wrong direction.\r\n\r\n@powercode is looking at adding support for extension methods, which also requires a symbol table. It would be nice if we could combine those efforts.",
      "created_at": "2017-03-14T21:15:52Z",
      "updated_at": "2017-03-14T21:15:52Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "I'm interested in the symbol table idea and would like to understand more about it. Do you mind opening an issue that captures your thoughts?\r\n\r\nAs for this PR, it's merely fixing a regression by bringing back the search against `ExecutionContext.AssemblyCache`, and it's likely that we need to port this fix back to windows powershell. We certainly should explore the symbol table as the ultimate solution for resolving types in powershell at the same time.",
      "created_at": "2017-03-14T23:08:13Z",
      "updated_at": "2017-03-14T23:09:02Z"
    },
    {
      "author": "PaulHigin",
      "author_association": "COLLABORATOR",
      "body": "LGTM",
      "created_at": "2017-03-15T16:35:33Z",
      "updated_at": "2017-03-15T16:35:33Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@lzybkr I updated the change with `HashSet<Assembly>` instead. The change in `CallResolveTypeNameWorkerHelper` in fact just wraps the main logic into a `try/final` block, but the comparison from git makes it look more complex. If you can open the change in code flow, you will get a cleaner view.",
      "created_at": "2017-03-15T19:38:36Z",
      "updated_at": "2017-03-15T19:38:36Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@lzybkr could you please take another look when you have time? Thanks!",
      "created_at": "2017-03-17T19:08:11Z",
      "updated_at": "2017-03-17T19:08:11Z"
    }
  ],
  "created_at": "2017-03-13T23:57:57Z",
  "number": 3327,
  "state": "closed",
  "title": "Search the assembly cache kept by ExecutionContext for type resolution.",
  "updated_at": "2017-03-21T17:33:28Z"
}