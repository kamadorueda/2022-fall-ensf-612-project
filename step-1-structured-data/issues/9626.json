{
  "_url": "https://github.com/PowerShell/PowerShell/issues/9626",
  "author": "SeeminglyScience",
  "body": "# Summary of the new feature/enhancement\r\n\r\nThe `nameof` keyword would be very useful for the same reasons it's useful in C#.  It may not necessarily be required in basic automation, but when writing highly resilient/portable tooling it becomes significantly more desirable.\r\n\r\nThere are two main scenarios I have in mind as motivation:\r\n\r\n1. Ensuring a parameter variable is populated by parameter binding (and not by a previous scope) with `$PSBoundParameters.ContainsKey`.\r\n    ```powershell\r\n        function Test-Parameter {\r\n        [CmdletBinding()]\r\n        param(\r\n            [Parameter()]\r\n            [string] $FileName\r\n        )\r\n        end {\r\n            if ($null -ne $FileName) {\r\n                # This may be true, but doesn't necessarily mean the parameter was passed.\r\n                'FileName isn''t null!'\r\n            }\r\n\r\n\r\n            # Currently you need to write:\r\n            # if ($PSBoundParameters.ContainsKey('FileName')) {\r\n            if ($PSBoundParameters.ContainsKey(nameof($FileName))) {\r\n                'FileName was actually specified!'\r\n            }\r\n        }\r\n    }\r\n\r\n    Test-Parameter -FileName 'test'\r\n\r\n    # returns\r\n    # FileName isn't null!\r\n    # FileName was actually specified!\r\n\r\n    $FileName = 'something else'\r\n    Test-Parameter\r\n\r\n    # returns\r\n    # FileName isn't null!\r\n    ```\r\n1. Argument related error reporting, especially in classes.\r\n    ```powershell\r\n    class Utils {\r\n        static [void] DeleteFile([string] $fileName) {\r\n            if ([string]::IsNullOrEmpty($fileName)) {\r\n                # Current you need to write:\r\n                # throw [ArgumentNullException]::new('fileName')\r\n                throw [ArgumentNullException]::new(nameof($fileName))\r\n            }\r\n        }\r\n    }\r\n    ```\r\n\r\nGranted there is a lack of symbol rename support in most editors (including PSES) but that won't be the case forever, and it's still typically easier to notice a variable name vs the contents of a string.\r\n\r\n# Proposed technical implementation details (optional)\r\n\r\n## Syntax\r\n\r\n```antlr\r\nnameof_expression\r\n    : 'nameof' body\r\n    ;\r\n\r\nbody\r\n    : start_tag target end_tag\r\n    ;\r\n\r\nstart_tag\r\n    : '{'\r\n    | '('\r\n    ;\r\n\r\nend_tag\r\n    : '}'\r\n    | ')'\r\n    ;\r\n\r\ntarget\r\n    : variable_expression_ast\r\n    | member_expression_ast\r\n    | type_expression_ast\r\n    | command_ast\r\n    ;\r\n```\r\n\r\nI suggest allowing `{}` as an enclosure because the only way to get similar functionality today is to write a function like this:\r\n\r\n```powershell\r\nfunction nameof {\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Position=0, Mandatory)]\r\n        [ValidateNotNull()]\r\n        [ScriptBlock] $Expression\r\n    )\r\n    end {\r\n        $firstElement = $Expression.Ast.EndBlock.Statements[0].PipelineElements[0]\r\n        if ($firstElement.Expression.VariablePath.UserPath) {\r\n            return $firstElement.Expression.VariablePath.UserPath\r\n        }\r\n\r\n        if ($firstElement.Expression.Member) {\r\n            return $firstElement.Expression.Member.SafeGetValue()\r\n        }\r\n\r\n        if ($firstElement.GetCommandName) {\r\n            return $firstElement.GetCommandName()\r\n        }\r\n\r\n        if ($firstElement.Expression.TypeName.FullName) {\r\n            return $firstElement.Expression.TypeName.FullName\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nAllowing `{}` would keep compatibility with code using that pattern today (assuming anyone else does that)\r\n\r\n## AST\r\n\r\n```csharp\r\npublic class NameOfExpressionAst : ExpressionAst\r\n{\r\n    public CommandBaseAst Target { get; }\r\n\r\n    public NameOfExpressionAst(IScriptExtent extent, CommandBaseAst target);\r\n}\r\n```\r\n\r\nTyping the `Target` as a `CommandBaseAst` conveys that the contents should be a single command or expression.\r\n\r\nSemantic checks should be used to assert:\r\n\r\n1. A `CommandAst` has only one element, which is a bare word `StringConstantExpressionAst`\r\n1. A `CommandExpressionAst` has an expression of type `MemberExpressionAst`, `VariableExpressionAst`, or `TypeExpressionAst`\r\n1. If the underlying target is a `MemberExpressionAst`, the `Member` property is a `StringConstantExpressionAst`\r\n\r\nI picked the base `ExpressionAst` because it would be ideal if the keyword could be parsed in all parsing modes (except command argument mode)\r\n\r\n## Implementation\r\n\r\nThe `Compiler` could emit a string `ConstantExpression` based on `Target` when visiting `NameOfExpressionAst`.\r\n\r\n|Type|Value Path|\r\n|---|---|\r\n|CommandAst|target.GetCommandName()|\r\n|MemberExpressionAst|((StringConstantExpressionAst)target.Member).Value|\r\n|VariableExpressionAst|target.VariablePath.UserPath|\r\n|TypeExpressionAst|target.TypeName.FullName|\r\n\r\n## Impact\r\n\r\nThis would technically be a breaking change, but impact could be minimized by requiring no whitespace between the `nameof` keyword and the opening tag.",
  "closed_at": null,
  "comments": [
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "Hi @SeeminglyScience - just a thought. As near as I can tell, nowhere in this issue have you actually included any examples showing how and why this feature would be used in PowerShell. Saying that it's like C# isn't helpful for people who aren't C# programmers (i.e. the bulk of PowerShell users). So I think adding a few lines of expository text and some examples would help convince people that this is a good idea. Just a thought...",
      "created_at": "2019-06-08T10:13:36Z",
      "updated_at": "2019-06-08T10:13:36Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "@BrucePay I did describe the scenarios where it'd be most useful in PowerShell.  I've added some code examples to help illustrate, thank you!",
      "created_at": "2019-06-08T13:16:15Z",
      "updated_at": "2019-06-08T13:16:15Z"
    },
    {
      "author": "patridge",
      "author_association": "NONE",
      "body": "In addition to use cases above, I'd also love this feature for the debugging potential as I develop scripts/cmdlets.\r\n\r\nI'm currently trying to figure out where things are going wrong with a collection of interdependent variables I'm declaring as I write my first cmdlet. Since I'm still writing it, some of the variable names change, so I want to use the exact variable name when dumping out values.\r\n\r\nSomething like this would be handy for that output.\r\n\r\n```powershell\r\nWrite-Host \"$(nameof($someVariable)): $someVariable\"\r\n```\r\n\r\nI'm just starting to learn to use `Get-Variable -Scope Local` as a workaround on the debugging side, but a `nameof` shorthand would allow for more output control and eliminate some of the noise that is also part of the full local scope.",
      "created_at": "2022-01-04T16:49:50Z",
      "updated_at": "2022-01-04T16:49:50Z"
    }
  ],
  "created_at": "2019-05-20T17:10:39Z",
  "number": 9626,
  "state": "open",
  "title": "Add nameof keyword",
  "updated_at": "2022-01-04T16:49:50Z"
}