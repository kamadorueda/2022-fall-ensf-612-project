{
  "_url": "https://github.com/PowerShell/PowerShell/issues/7020",
  "author": "rjmholt",
  "body": "In scenarios where an application hosts PowerShell, there is sometimes a need to use a runspace pool to handle concurrent tasks. In a scenario like that, if you need to have a module loaded in that `InitialSessionState` in each runspace, there's no way to do it that respects the module path. The APIs that do module importing end up just randomly picking a module with the given name or specification. This makes module interaction in those scenarios much much harder.\r\n\r\nFundamentally, there are three ways to import a module with `InitialSessionState`:\r\n* https://github.com/PowerShell/PowerShell/blob/0d51ea7aead668e1ffdfe37ca260a57d12037f14/src/System.Management.Automation/engine/InitialSessionState.cs#L1919-L1924\r\n* https://github.com/PowerShell/PowerShell/blob/0d51ea7aead668e1ffdfe37ca260a57d12037f14/src/System.Management.Automation/engine/InitialSessionState.cs#L1875-L1883\r\n* https://github.com/PowerShell/PowerShell/blob/0d51ea7aead668e1ffdfe37ca260a57d12037f14/src/System.Management.Automation/engine/InitialSessionState.cs#L1900-L1911\r\n\r\nIt turns out the first cascades into the second, which in turn calls the third. In all cases a [`ModuleSpecification`](https://github.com/PowerShell/PowerShell/blob/master/src/System.Management.Automation/engine/Modules/ModuleSpecification.cs) is generated, but in the first two with [all the fields set to `null` except `Name`](https://github.com/PowerShell/PowerShell/blob/0d51ea7aead668e1ffdfe37ca260a57d12037f14/src/System.Management.Automation/engine/Modules/ModuleSpecification.cs#L44-L56). The only way to create a `ModuleManifest` with any other fields (like `MinimumVersion` or `Guid`) set is [to pass it a `Hashtable` in the constructor naming the fields their values](https://github.com/PowerShell/PowerShell/blob/0d51ea7aead668e1ffdfe37ca260a57d12037f14/src/System.Management.Automation/engine/Modules/ModuleSpecification.cs#L66-L78).\r\n\r\nThe module import itself is handled by [`ProcessImportModule`](https://github.com/PowerShell/PowerShell/blob/0d51ea7aead668e1ffdfe37ca260a57d12037f14/src/System.Management.Automation/engine/InitialSessionState.cs#L2842-L2951), which generally calls [`ModuleCmdletBase.GetModuleIfAvailable`](https://github.com/PowerShell/PowerShell/blob/0d51ea7aead668e1ffdfe37ca260a57d12037f14/src/System.Management.Automation/engine/Modules/ModuleCmdletBase.cs#L3953-L4025). In the case of a name ending with `psd1`, this uses `Test-ModuleManifest` to get the module info (I don't know what happens if a relative path is used here -- I'm not sure what the path is interpreted as relative to). Otherwise, we call `Get-Module -ListAvailable <name>` and then do some post processing to get a list of modules.\r\n\r\nIn all cases, we get a list of `PSModuleInfo`s back, from which we take the first and call [`ProcessImportModule`'s evil twin](https://github.com/PowerShell/PowerShell/blob/0d51ea7aead668e1ffdfe37ca260a57d12037f14/src/System.Management.Automation/engine/InitialSessionState.cs#L3011-L3087) (which, while an overload of the first, isn't quite next to it in the file). This then runs `Import-Module` on that `PSModuleInfo`.\r\n\r\nThe problem is that `Get-Module -ListAvailable -Name <name>` calls [`GetAvailableLocallyModules`](https://github.com/PowerShell/PowerShell/blob/0d51ea7aead668e1ffdfe37ca260a57d12037f14/src/System.Management.Automation/engine/Modules/GetModuleCommand.cs#L466-L479), which in turn calls [`ModuleCmdletBase.GetModule`](https://github.com/PowerShell/PowerShell/blob/0d51ea7aead668e1ffdfe37ca260a57d12037f14/src/System.Management.Automation/engine/Modules/ModuleCmdletBase.cs#L850-L882).\r\n\r\nFor modules where the \"name\" has been given as a rooted path, this calls [`GetModuleForRootedPaths`](https://github.com/PowerShell/PowerShell/blob/0d51ea7aead668e1ffdfe37ca260a57d12037f14/src/System.Management.Automation/engine/Modules/ModuleCmdletBase.cs#L902-L991), which is why `InitialSessionState.ImportPSModuleFromPath` actually works well.\r\n\r\n**BUT**, when the name is not a rooted path it calls [`GetModuleForNonRootedPaths`](https://github.com/PowerShell/PowerShell/blob/0d51ea7aead668e1ffdfe37ca260a57d12037f14/src/System.Management.Automation/engine/Modules/ModuleCmdletBase.cs#L884-L900), which gets a Dictionary of module path directory keys to module values with [`GetAvailableLocallyModulesCore`](https://github.com/PowerShell/PowerShell/blob/0d51ea7aead668e1ffdfe37ca260a57d12037f14/src/System.Management.Automation/engine/Modules/ModuleCmdletBase.cs#L1001-L1045) *and then enumerates the modules in Dictionary key order* - i.e. **at random**.\r\n\r\nSo basically these APIs just get a random module matching the given constraints from anywhere on the module path.\r\n\r\nI imagine an ideal resolution would be to make `Get-Module -ListAvailable` list modules in module path order, or use an `OrderedDictionary` or something similar.\r\n\r\nFor context, we ran into this [trying to respect the module path for user-installed PSScriptAnalyzer versions](https://github.com/PowerShell/vscode-powershell/issues/1298#issuecomment-385758057). Rather than reimplement module path processing, [we now just use the latest version of PSScriptAnalyzer we find on the path](https://github.com/PowerShell/PowerShellEditorServices/pull/677). But there will be scenarios where people want to allow user override of a module, which is exactly what the module path is designed to do.",
  "closed_at": null,
  "comments": [],
  "created_at": "2018-06-07T19:00:28Z",
  "labels": [
    "WG-Engine",
    "Issue-Discussion"
  ],
  "number": 7020,
  "state": "open",
  "title": "InitialSessionState.ImportPSModule just selects a random module on the module path",
  "updated_at": "2018-06-08T00:28:28Z"
}