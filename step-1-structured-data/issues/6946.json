{
  "_url": "https://github.com/PowerShell/PowerShell/issues/6946",
  "author": "mklement0",
  "body": "Currently, you cannot access an object's property if that property's name happens to start with a (decimal) _digit_:\r\n\r\n```powershell\r\n$obj = [pscustomobject] @{ '1a' = '1a''s value' }\r\n \r\n # !! BREAKS, because the property name starts with a digit.\r\n$obj.1a\r\n```\r\n\r\nNote: It does work with an _all-digit name_, such as `111`, as explained below.\r\n\r\nThe error message you get is:\r\n\r\n```none\r\n...\r\nMissing property name after reference operator.\r\n...\r\n```\r\n\r\nThe current _workarounds_ are to either use _quoting_ or to _indirectly_ reference the property via a _variable_ containing the name:\r\n\r\n```powershell\r\n# OK: Quote the property name\r\n$obj.'1a'\r\n$obj.\"1a\"\r\n\r\n# OK: Access the property via  a *variable*\r\n$propName = '1a'\r\n$obj.$propName\r\n```\r\n\r\n<sup>Note: `$obj.{1a}`, as mentioned by @george-chakhidze below, happens to work too, but it is  an accidental by-product of script-block stringification.\r\n</sup>\r\n\r\n\r\nIs there a good reason _not_ to allow direct use of the literal property name?\r\nIn other words: why shouldn't `$obj.1a` work as-is?\r\n\r\n(By contrast, there are property names that do invariably require quoting, such as\r\n `([pscustomobject] @{ 'a.b' = 'a.b''s value' }).'a.b'`)\r\n\r\nEnvironment data\r\n----------------\r\n\r\nWritten as of:\r\n\r\n```powershell\r\nPowerShell Core v6.1.0-preview.2\r\n```\r\n",
  "closed_at": "2018-05-30T21:12:39Z",
  "comments": [
    {
      "author": "george-chakhidze",
      "author_association": "NONE",
      "body": "```powershell\r\n$obj.{1a}\r\n```\r\nis OK too.",
      "created_at": "2018-05-28T13:24:13Z",
      "updated_at": "2018-05-28T13:24:13Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "@george-chakhidze `$obj.{1a}` works because the string value for the scriptblock `[1a}` is `'1a'. So it's essentially equivalent to `$obj.'1a'`.\r\n\r\n@mklement0 It's not allowed because it's sufficiently anomalous that it's probably a mistake. Cat's walking on keyboards should not produce valid programs. If you _really_ want to do it, then you have to make it explicit with quoting as in the case of this [StackOverflow question](https://stackoverflow.com/questions/50556895/powershell-properties-issues) (I assume this is what prompted the question?)\r\n\r\nNow as it happens, `$foo.123` works fine. This is because we allow expressions of the LHS of `.` and, of course, `123` is a legal expression.    \r\n",
      "created_at": "2018-05-28T20:49:11Z",
      "updated_at": "2018-05-28T20:49:11Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@BrucePay:\r\n\r\nGood to know that `$obj.{1a}` only works _accidentally_, as a by-product of script-block stringification (I've updated the original post).\r\n\r\n> ... as in the case of this StackOverflow question. I assume this is what prompted the question?\r\n\r\nYes.\r\nAnd it is tangible evidence that not only cats walking on keyboards produce such property names, especially in the world of JSON.\r\n\r\n> It's not allowed because it's sufficiently anomalous that it's probably a mistake. \r\n\r\nIf that is truly the intent - and I don't think it should be - please provide a more meaningful error message.\r\n\r\n> Now as it happens, $foo.123 works fine. This is because we allow expressions of the LHS of . and, of course, 123 is a legal expression.\r\n\r\nYes, as it _happens_ - and I suggest not relying on things that _happen_.\r\n\r\nLet me ask the opposite question: with respect to _property access_ on _objects_, what good reason is there to interpret what's to the right of `.` as anything other than a property _name_, i.e., a _string_ (leaving property _paths_ aside)?\r\n(Hashtable keys are a different story).\r\n\r\n\r\n",
      "created_at": "2018-05-28T21:04:58Z",
      "updated_at": "2018-05-28T21:06:05Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 The issue in the stackoverflow question was not difficulty in figuring out that quoting the anomalous property name was required. The problem was that there was a _typo_ in that name. Quoted or not made no difference since the property didn't exist.\r\n\r\n> especially in the world of JSON.\r\n\r\nInterestingly, JavaScript doesn't allow property names to start with a number either. You have you have to use indexing instead. That would seem to discourage the use of such names in JSON.\r\n\r\n> If that is truly the intent - and I don't think it should be - please provide a more meaningful error message\r\n\r\nAs one of the people making that decision and the person who wrote the original code, I can say - yes, that is the intent. The error message is currently that the property is missing. I suppose we could change it to \"missing or invalid\".\r\n\r\n> Yes, as it happens - and I suggest not relying on things that happen\r\n\r\nPoor phrasing on my part. It's not an accident, it's the expected consequence of the explicit decision to allow expressions on the LHS of '.', which in turn was done, in part, to deal with scenarios where objects might have non-conforming property names. As is the case in the stackoverflow question.\r\n\r\n",
      "created_at": "2018-05-28T22:06:02Z",
      "updated_at": "2018-05-28T22:06:02Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@BrucePay:\r\n\r\n> The problem was that there was a _typo_ in that name.\r\n\r\nYes, the issue turned out to be a typo, but the fact remains that (a) digit-prefixed property names do occur, and (b) you do need explicit quoting to access them, and that may be surprising.\r\n\r\n> Interestingly, JavaScript doesn't allow property names\r\n\r\nTrue, but JSON has long since outgrown use in the context of JavaScript _only_.\r\n\r\nAnd, given that `var o = JSON.parse('{ \"1a\": \"value\" }')` works just fine even in JavaScript, you could similarly ask why JavaScript doesn't allow `o.1a` and instead requires `o['1a']` - but that's obviously a separate debate.\r\n\r\n> The error message is currently that the property is missing. I suppose we could change it to \"missing or invalid\".\r\n\r\nThat would certainly help, though to be truly helpful it would have to say something along the lines of \"when in doubt, _quote_ the name\".\r\n\r\n> which in turn was done, in part, to deal with scenarios where objects might have non-conforming property names. As is the case in the stackoverflow question.\r\n\r\nYet, typo aside, it is that very decision - treating what's to the right of `.` as an _expression_  ONLY - that _prevents_ the use of the non-conforming property name at hand.\r\n\r\nNote that _falling back to `[string]` interpretation_ - if interpretation as an _expression_ doesn't work  - makes perfect sense, as _that is already happening for non-digit-prefixed barewords_ a.k.a regular property access:\r\n\r\n```powershell\r\n$co.foo # .foo is *implicitly* treated like .'foo', because foo by itself is not an expression\r\n$co.1a # Why shouldn't this be treated like .'1a', if it can't be interpreted as an expression?\r\n```\r\n\r\nWith property access, the advantage of being able to use an expression to the right of `.` is _solely_ to calculate a _property name_ - so that (ultimately) treating what's to the right as anything other than a string makes no sense.\r\n\r\n",
      "created_at": "2018-05-28T22:38:22Z",
      "updated_at": "2018-05-28T22:52:25Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "> that (a) digit-prefixed property names do occur\r\n\r\nOff the top of my head, I can't think of a single language that allows property names to start with a digit.\r\n\r\n> Note that falling back to [string] interpretation - if interpretation as an expression doesn't work - makes perfect sense, as that is already happening for non-digit-prefixed barewords a.k.a regular property access\r\n\r\nThat's not what happens. The parser looks for either a propertyname token or a unary expression. If a propertyname token is found, it is used to look up the property. If an expression is found, that expression is evaluated, the result is converted to a string by calling `.ToString()` and that string is used to look up  the property.\r\n\r\n> that (ultimately) treating what's to the right as anything other than a string makes no sense.\r\n\r\nSo you're saying that in `$x.abc+5` the property name should be `abc+5`?. That would make things rather awkward. ",
      "created_at": "2018-05-29T02:09:45Z",
      "updated_at": "2018-05-29T02:09:45Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> I can't think of a single language that allows property names to start with a digit.\r\n\r\nWe need to be careful to distinguish between _allowing the definition of_ a property with a name that starts with a digit _in principle_ on the one hand and allowing that name to be _accessed with a bareword_ on the other hand.\r\n\r\nAs the JavaScript example showed, JavaScript supports the former, but not the latter, and that is currently also true of PowerShell.\r\n\r\nThe overall question, however, is whether there is a good reason for this asymmetry.\r\n\r\nPowerShell is already unusual in allowing _expressions_  in lieu of name literals as accessors, the way you describe.\r\n\r\n> So you're saying that in `$x.abc+5` the property name should be `abc+5`\r\n\r\nNo, it should be parsed as `$x.abc + 5`, which is indeed what happens already.\r\n\r\n`$x.(abc+5)` - explicit use of `(...)` -  is a different story, and there the current behavior makes sense too: `abc+5` is interpreted as a _command_ and causes an error (unless there is a _command_ literally named `abc+5`).\r\n\r\n> The parser looks for either a propertyname token or a unary expression\r\n\r\nWell, `1a` is, by the current rules, _neither_, so the question is what behavior makes sense in that case:\r\n\r\nSince the result of the expression is converted to a _string_, as you state, so as to be interpreted as a _property name_, it seems to me that _giving_ up on something that looks like a unary numeric expression at first glance but then cannot be evaluated as such is unhelpful (especially with the current error message).\r\n\r\nUse of a unary _numeric_ expression as a _property_ accessor seems unlikely to be helpful in most cases and _it's far from obvious that this kind of interpretation does take place_ - in contrast with more readily recognizable expressions such as `$obj.$propName` or `$obj.('foo' + 2)` -\r\n\r\nI see the following ways to address this (there may be subtleties I'm missing):\r\n\r\n* (a) expand the definition of a property-name token to allow a leading digit.\r\n\r\n* (b) fall back to interpretation as a string literal if expression evaluation fails.\r\n\r\n* (c) report a _meaningful_ error (it seems that we've already found common ground there).\r\n\r\nEven with (b) in place the behavior could still be surprising, however:\r\n\r\n```powershell\r\n$o = [pscustomobject] @{ '1e2' = 'hi' }\r\n$o.1e2  # !! $null, because `1e2` is interpreted as [double] 100\r\n```\r\n\r\nWhat muddies the waters is that for _hashtable keys_, which can be of _any type_, it _does_ make sense to distinguish between  `@{ '1e2' = 'hi' }` (`[string]` key) and `@{ 1e2 = 'hi' }` (`[double]` key, interpretation as unary expression that is a _number literal_), although you could argue that `@{ 1a = 'hi' }` - currently a different, but similarly obscure error (`Missing closing '}' in statement block or type definition`) - too should fall back to interpreting `1a` as a _string_.\r\n\r\nWith hashtables too, if I were to guess, many users are unaware that keys are parsed as _expressions_ if they don't start with a letter.\r\n\r\nThe ship has sailed, but I'd say that defaulting to _string-literal_ interpretation with  _explicit opt-in_ to expression evaluation - similar to how `$` and `(` at the start of tokens in argument mode signal a non-literal argument  -  would have made for a model that's easier to grasp and remember.\r\n",
      "created_at": "2018-05-29T03:19:32Z",
      "updated_at": "2018-05-29T03:19:32Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I'm inclined to agree with that, really. It should default to string interpretation unless explicitly cast otherwise. However, it becomes tricky to distinguish there between what is intended to be a variable cast and what is simply part of a string. \r\n\r\nIf you allow expressions to be recognised as strings in hashtable literals, then how is it supposed to treat type casts correctly?\r\n\r\n```PowerShell\r\n$TypeHash = @{\r\n     [int]32 = \"hello!\"\r\n}\r\n# should this work?\r\n$TypeHash.'[int]32'\r\n# because it's not so simple to ensure that that's not the case if we just \r\n# say 'parse everything as strings, unless... unless what, exactly?'\r\n```",
      "created_at": "2018-05-30T16:37:13Z",
      "updated_at": "2018-05-30T16:37:24Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @vexx32.\r\n\r\nYes, bringing hashtables into the picture complicates the situation, especially since Powershell - generally commendably - makes it so easy to treat them the same syntactically and even to convert one type to the other.\r\n\r\nAs for syntax: The ambiguity would go away if you:\r\n\r\n* default to _string_ interpretation to the right of `.`\r\n\r\n* _except_ if the _1st char_ is either `$` or `(`,  in which case the variable reference / subexpression / expression should be evaluated and the _result as-is_ be used as a hashtable _key_  / the _stringified result_ be used as a _property name_.\r\n\r\nApplied to your example:\r\n\r\n```powershell\r\n$hash = @{ [int]32 = \"hello!\" }; $hash.([int] 32) # OK\r\n\r\n$obj = (Get-Item /); $obj.('Na' + 'me')  # OK\r\n```\r\n\r\nIn fact, all of the above _already works_, except that in the absence of either `$` or `(`, a _digit too_ as the 1st char. to the `.` right too causes evaluation as en _expression_, and that's where the trouble starts.\r\n\r\nWhy? Because the parser only considers a token that starts with a _letter_ a _member-name_ (property-name) token, as the following example shows:\r\n\r\n```powershell\r\nPS> (([system.management.automation.psparser]::Tokenize('$obj.a1', [ref] $null)).Type)[-1]\r\nMember # OK, recognized as a member name:  'a1' starts with with a *letter*\r\n\r\nPS> (([system.management.automation.psparser]::Tokenize('$obj.1a', [ref] $null)).Type)[-1]\r\nCommandArgument # NOT recognized as member name: '1a' starts with a *digit*.\r\n```\r\n\r\nIn the latter case - and for _any_ token that doesn't parse as `Member` - PowerShell then evaluates the token as a _unary expression_ (if I understood @BrucePay  correctly).\r\n\r\nIn the case of _property_ access, that currently gives us counter-intuitive behaviors in two scenarios:\r\n\r\n```powershell\r\n$obj = [pscustomobject] @{ '1a' = 'one A'; '1e2' = 'one E two'; '100' = 'hundred' }\r\n\r\n# As detailed in the original post:\r\n# An unexpected and confusing error, because 1a is interpreted as an *expression* and *fails*.\r\nPS> $obj.1a\r\n... Missing property name after reference operator. ...\r\n\r\nPS> $obj.1e2\r\nhundred # !! because $obj.1e2 turned into $obj.'100', \r\n        # !! given that 1e2 as an expression becomes [double] 100, which stringifies to '100'\r\n```\r\n\r\nIn the case of _hashtable-key_ access, interpretation as a a _numeric_ expression makes comparatively more sense, but you could argue that even there, for any _non-string_ key, you should use:\r\n\r\n* either: `$hash.([int] 32])`, as shown (explicit expression use with `(...)`)\r\n* or: `[...]`: `$hash[[int] 32]`, `[...]` is an always-expression-only context\r\n\r\nLimiting the syntax to that makes sense, especially considering that `.`-based hashtable-entry access is _syntactic sugar borrowed from PROPERTY access_ for the unambiguous original`[...]` syntax - the latter explicitly and unambiguously allows _only_ expressions.\r\n\r\n---\r\n\r\nIn conclusion:\r\n\r\nChanging the parsing to the right of `.`  to require _explicit opt-in_ to _expression_ evaluation via `$` or `(`:\r\n\r\n* is _probably fine_ for _property_ access, because it's hard to imagine anyone having relied on `$obj.1e2` accessing property `'100'`.\r\n\r\n* is _problematic_ for _hashtable-key_ access, because existing code _does_ rely on being able to specify _numeric_ keys - see below.\r\n\r\nGiven the latter, the question is whether introducing divergent behavior (changing only _property_ access) is ultimately more confusing than helpful.\r\n\r\nHere's an example where existing code relies on numeric keys with `.`:\r\n\r\n```powershell\r\n$null = 'abc' -match '(b)'; $Matches.1\r\nb  # OK  - currently the same as: $Matches[1]\r\n```\r\n`$Matches` is a hashtable with _integer_ keys containing the overall regex match (key `0`), the 1st capture group (`1`), ...\r\n\r\nIf we changed the interpretation of `.1` do refer to a _string_ key `'1'`, the above code would break (you'd have to use `$Matches[1]` or `$Matches.(1)` instead).\r\n\r\n",
      "created_at": "2018-05-30T19:21:50Z",
      "updated_at": "2018-05-30T19:21:50Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "I always wondered how `$Matches` managed to work almost like an array, but still function as a hashtable. Very interesting... I'll have to keep that in mind.\r\n\r\nAll said, I personally have no qualms with how it currently functions. It could be improved a little, perhaps, but it's pretty consistent as it is, and it does seem like changing the behaviour for, say, a specific use case, seems to be... Unwise, and liable to cause other problems. \r\n\r\nI don't really see an elegant solution here.",
      "created_at": "2018-05-30T19:29:17Z",
      "updated_at": "2018-05-30T19:29:17Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@vexx32 \r\n\r\n> I don't really see an elegant solution here.\r\n\r\nYes, unfortunately; arguably, the `.` syntactic sugar for hashtables keys should have applied _string-only_ interpretation from the start (and required differently typed keys to be accessed with `[...]` or even `.(...)`), but that ship has sailed.\r\n\r\n>  say, a specific use case\r\n\r\nIt's more than a specific use case, but it is not common.\r\n\r\nThe best we can do under the circumstances is to provide a meaningful error message - see #6959\r\n\r\n",
      "created_at": "2018-05-30T21:12:39Z",
      "updated_at": "2018-05-30T21:12:39Z"
    }
  ],
  "created_at": "2018-05-27T23:30:50Z",
  "number": 6946,
  "state": "closed",
  "title": "Is there a good reason not to allow direct access to properties whose name starts with a digit?",
  "updated_at": "2018-08-03T19:47:40Z"
}