{
  "_url": "https://github.com/PowerShell/PowerShell/issues/7620",
  "author": "felixfbecker",
  "body": "Steps to reproduce\r\n------------------\r\n\r\nWhen running PowerShell, I sometimes need to redirect all \"log\" streams (including the information stream) to STDERR. For this, I am trying to redirect the information stream 6 to the warning stream 3:\r\n```powershell\r\n'test' 6>&3\r\n```\r\nI also tried redirecting all streams:\r\n```\r\n'test' *>&3\r\n```\r\nAnd redirecting to the error stream:\r\n```\r\n'test' 6>&2\r\n```\r\n```\r\n'test' *>&2\r\n```\r\n\r\nExpected behavior\r\n-----------------\r\n\r\nThis should redirect `test` to the warning or error stream, as described in https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_redirection \r\n\r\n\r\nActual behavior\r\n---------------\r\n\r\nThe first two examples fail with\r\n```\r\nAt line:1 char:10\r\n+ 'test' 6>&3\r\n+          ~\r\nMissing file specification after redirection operator.\r\n+ CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException\r\n+ FullyQualifiedErrorId : MissingFileSpecification\r\n```\r\n\r\n```none\r\nAt line:1 char:10\r\n+ 'test' *>&3\r\n+          ~\r\nMissing file specification after redirection operator.\r\n+ CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException\r\n+ FullyQualifiedErrorId : MissingFileSpecification\r\n```\r\n\r\nRedirecting to stream 2 fails with:\r\n```\r\nAt line:1 char:8\r\n+ 'test' 6>&2\r\n+        ~~~~\r\nThe '6>&2' operator is reserved for future use.\r\n+ CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException\r\n+ FullyQualifiedErrorId : RedirectionNotSupported\r\n```\r\n```\r\nAt line:1 char:8\r\n+ 'test' *>&2\r\n+        ~~~~\r\nThe '*>&2' operator is reserved for future use.\r\n+ CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException\r\n+ FullyQualifiedErrorId : RedirectionNotSupported\r\n```\r\n\r\nThe only thing that works properly is redirecting to the output stream like `*>&1` or `6>&1`, which makes `*>&1 | Write-Warning` possible as a warning, but that will put _everything_ on the warning stream, including the _actual output_ of the function.\r\n\r\nEnvironment data\r\n----------------\r\n\r\n<!-- provide the output of $PSVersionTable -->\r\n\r\n```powershell\r\n> $PSVersionTable\r\nName                           Value\r\n----                           -----\r\nPSVersion                      6.0.2\r\nPSEdition                      Core\r\nGitCommitId                    v6.0.2\r\nOS                             Darwin 17.7.0 Darwin Kernel Version 17.7.0: Thu Jun 21 22:53:14 PDT 2018; root:xnu-4570.71.2~1/...\r\nPlatform                       Unix\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "PetSerAl",
      "author_association": "CONTRIBUTOR",
      "body": "Linked documentation only show three forms of redirection operator: `n>`, `n>>` and `n>&1`. There are no documented operators `n>&2` or `n>&3`.",
      "created_at": "2018-08-23T15:17:41Z",
      "updated_at": "2018-08-23T15:17:41Z"
    },
    {
      "author": "felixfbecker",
      "author_association": "CONTRIBUTOR",
      "body": "That's true, but it's not very obvious, especially when the same operator in bash works for stderr too (`>&2`). The error messages are also confusing.\r\n\r\nIn Linux programs, often STDERR is used as the logging stream, especially if STDOUT is speaking an RPC protocol, e.g. needs to be valid JSON. PowerShell currently can't really be used for this because any information or warning logs will get sent to STDOUT.",
      "created_at": "2018-08-23T15:25:38Z",
      "updated_at": "2018-08-23T15:51:20Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "@felixfbecker Something to keep in mind: in traditional text-based shells, the various output streams are just undifferentiated text so it doesn't matter what goes where.. In PowerShell, the streams are strongly typed. The error stream only contains ErrorRecords, the VerboseStream only contains VerboseRecords, etc. The only polymorphic stream is the output stream so it's the only one where merge semantics are clear. That said, the higher-level scenario is important and we should have a way to accommodate it. One of the ideas we had in the past is to allow you to redirect into an action (scriptblock) and the action can do things like logging, etc. Anyway, I'm going to mark this as an enhancement request.",
      "created_at": "2018-08-23T15:48:22Z",
      "updated_at": "2018-08-23T15:48:22Z"
    },
    {
      "author": "felixfbecker",
      "author_association": "CONTRIBUTOR",
      "body": "That makes sense - in a way, it reminds me of [ReactiveX `Materialize`](http://reactivex.io/documentation/operators/materialize-dematerialize.html) - redirecting all event types to the primary stream, while maintaining the information about where it came from through the type info.\r\n\r\nYou should already be able to pipe it further into `ForEach-Object` and check if `$_` is `ErrorRecord`, `InformationRecord`, and depending on the type, call `Write-Error`, `Write-Warning`, etc.\r\n\r\nHere is an implementation of `Dematerialize` in PowerShell:\r\n\r\n```powershell\r\nfilter Out-StreamByType {\r\n    if ($_ -is [ErrorRecord]) {\r\n        $e = [ErrorRecord]$_\r\n        Write-Error -ErrorRecord $e\r\n    } elseif ($_ -is [InformationRecord]) {\r\n        $i = [InformationRecord]$_\r\n        Write-Information -MessageData $i.MessageData -Tags $i.Tags\r\n    } elseif ($_ -is [WarningRecord]) {\r\n        $w = [WarningRecord]$_\r\n        Write-Warning -Message $w.Message\r\n    } elseif ($_ -is [VerboseRecord]) {\r\n        $v = [VerboseRecord]$_\r\n        Write-Verbose -Message $v.Message\r\n    } elseif ($_ -is [DebugRecord]) {\r\n        $d = [DebugRecord]$d\r\n        Write-Debug -Message $d.Message\r\n    } else {\r\n        $_\r\n    }\r\n}\r\n```\r\n\r\nIf we extend this, we can write a function that redirects output streams arbitrarily:\r\n\r\n```powershell\r\n# Writes the input to the given target stream\r\nfunction Out-TargetStream {\r\n    param(\r\n        [Parameter(Mandatory, Position = 0)]\r\n        [ValidateRange(1, 6)]\r\n        [int] $Target,\r\n\r\n        # A union of all parameters of the Write cmdlets\r\n        # Error\r\n        [Parameter(ValueFromPipeline)]\r\n        [ErrorRecord] $ErrorRecord,\r\n\r\n        # Debug, Verbose, Warning\r\n        [Parameter(ValueFromPipelineByPropertyName, ValueFromPipeline)]\r\n        [Alias('MessageData')] # Information\r\n        $Message,\r\n\r\n        # Information\r\n        [Parameter(ValueFromPipelineByPropertyName)]\r\n        [string[]] $Tags\r\n    )\r\n    switch ($Target) {\r\n        1 { $Message }\r\n        2 {\r\n            if ($null -ne $ErrorRecord) {\r\n                Write-Error -ErrorRecord $ErrorRecord\r\n            } else {\r\n                Write-Error -Message $Message\r\n            }\r\n        }\r\n        3 { Write-Warning -Message $Message }\r\n        4 { Write-Verbose -Message $Message }\r\n        5 { Write-Debug -Message $Message }\r\n        6 { Write-Information -MessageData $Message -Tags $Tags }\r\n    }\r\n}\r\n\r\n# Redirects streams to other streams\r\nfilter Out-Stream {\r\n    param(\r\n        [int] $SuccessTarget = 1,\r\n        [int] $ErrorTarget = 2,\r\n        [int] $WarningTarget = 3,\r\n        [int] $VerboseTarget = 4,\r\n        [int] $DebugTarget = 5,\r\n        [int] $InformationTarget = 6\r\n    )\r\n    if ($_ -is [ErrorRecord]) {\r\n        $_ | Out-TargetStream -Target $ErrorTarget\r\n    } elseif ($_ -is [InformationRecord]) {\r\n        $_ | Out-TargetStream -Target $InformationTarget\r\n    } elseif ($_ -is [WarningRecord]) {\r\n        $_ | Out-TargetStream -Target $WarningTarget\r\n    } elseif ($_ -is [VerboseRecord]) {\r\n        $_ | Out-TargetStream -Target $VerboseTarget\r\n    } elseif ($_ -is [DebugRecord]) {\r\n        $_ | Out-TargetStream -Target $DebugTarget\r\n    } else {\r\n        $_ | Out-TargetStream -Target $SuccessTarget\r\n    }\r\n}\r\n```\r\n\r\nThis makes use of PowerShell's `ValueFromPipelineByPropertyName` and `ValueFromPipeline` handling to automatically destructure Record objects from the pipeline into common properties (e.g. `Message`) and passing those into the required `Write` cmdlets as asked for by the user. Some properties may get lost (e.g. error -> warning, or information -> verbose). If the types are incompatible, e.g. an object in the success stream -> verbose stream, it will be coerced to a string by PowerShell automatically (calling `.ToString()`).\r\n\r\nUsage:\r\n```powershell\r\n# Redirect error to warning stream, and warning to verbose\r\nWrite-Error \"test\" *>&1 | Out-Stream -ErrorTarget 3 -WarningTarget 4\r\n\r\n# Redirect output to information stream (useful for executing native commands!)\r\necho \"Doing operation...\" | Out-Stream -SuccessTarget 6\r\n```\r\n\r\nThis is basically what I would expect the redirection operator to be able to do. PowerShell is a very dynamic language and has automatic type coercion, so it should be able to automatically coerce types between streams.",
      "created_at": "2018-09-03T17:05:33Z",
      "updated_at": "2018-09-03T17:10:11Z"
    },
    {
      "author": "coin8086",
      "author_association": "NONE",
      "body": "> @felixfbecker Something to keep in mind: in traditional text-based shells, the various output streams are just undifferentiated text so it doesn't matter what goes where.. In PowerShell, the streams are strongly typed. The error stream only contains ErrorRecords, the VerboseStream only contains VerboseRecords, etc. The only polymorphic stream is the output stream so it's the only one where merge semantics are clear. That said, the higher-level scenario is important and we should have a way to accommodate it. One of the ideas we had in the past is to allow you to redirect into an action (scriptblock) and the action can do things like logging, etc. Anyway, I'm going to mark this as an enhancement request.\r\n\r\nGood explanation. But I think it's better put into the document so that we don't get confused by the error.",
      "created_at": "2019-01-27T14:04:53Z",
      "updated_at": "2019-01-27T14:04:53Z"
    }
  ],
  "created_at": "2018-08-23T13:43:38Z",
  "number": 7620,
  "state": "open",
  "title": "Cannot redirect streams to anything else than output stream 1",
  "updated_at": "2019-01-27T14:04:53Z"
}