{
  "_url": "https://github.com/PowerShell/PowerShell/issues/7034",
  "author": "alx9r",
  "body": "It seems like it should be possible to subscribe to Runspace.AvailabilityChanged and Runspace.StateChanged to wait for a runspace to be opened when using Runspace.OpenAsync().  However, I have not found a way to use those events in a manner that reliably waits until the opening process is complete.  \r\n\r\nSpecifically, I am surprised that the runspace transitions to Available,Opened then Busy,Opened before it completes the import of modules specified by InitialSessionState.  It seems like neither the Opened nor Available states should be reached until the module is imported.\r\n\r\nSteps to reproduce\r\n------------------\r\n\r\n```powershell\r\n$moduleContent = {\r\n    function fibonacci {\r\n        param([int]$n)\r\n        [bigint]$a=0\r\n        [bigint]$b=1\r\n        foreach ($x in 0..$n)\r\n        {\r\n            $a,$b = $b,($a+$b)\r\n        }\r\n        $b\r\n    }\r\n    0..0 | % { fibonacci 5000 }\r\n}\r\n\r\n$modulePath = \"$([System.IO.Path]::GetTempPath())slowLoading.psm1\"\r\n$moduleContent | Set-Content $modulePath\r\n\r\n$initialSessionState = [initialsessionstate]::CreateDefault()\r\n$initialSessionState.ImportPSModule($modulePath)\r\n\r\n$runspace = [runspacefactory]::CreateRunspace($initialSessionState)\r\n$runspace.OpenAsync()\r\n\r\n1..500 | \r\n    % {\r\n        [pscustomobject]@{\r\n            i         = $_\r\n            Available = $runspace.RunspaceAvailability\r\n            State     = $runspace.RunspaceStateInfo.State\r\n        }\r\n        sleep 0.5\r\n    }\r\n```\r\n\r\nExpected behavior\r\n-----------------\r\n\r\n```none\r\n i Available State\r\n - ---------   -----\r\n  1      None Opening\r\n...\r\n  8      None Opening\r\n  9      Busy Opening\r\n...\r\n285      Busy Opening\r\n286 Available  Opened\r\n```\r\n\r\nActual behavior\r\n---------------\r\n\r\n```none\r\n  i Available State\r\n  - ---------   -----\r\n  1      None Opening\r\n...\r\n  8      None Opening\r\n  9 Available  Opened\r\n 10 Available  Opened\r\n 11      Busy  Opened\r\n...\r\n285      Busy  Opened\r\n286 Available  Opened\r\n```\r\n\r\nEnvironment data\r\n----------------\r\n\r\n<!-- provide the output of $PSVersionTable -->\r\n\r\n```powershell\r\n> $PSVersionTable\r\n\r\nName                           Value\r\n----                           -----\r\nPSVersion                      6.1.0-preview.691\r\nPSEdition                      Core\r\nGitCommitId                    v6.1.0-preview.691\r\nOS                             Microsoft Windows 6.3.9600 \r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "alx9r",
      "author_association": "NONE",
      "body": "FWIW it seems like pattern matching on a merged stream of `RunspaceAvailabilityChanged` and `StateChanged` events can be used to infer when a runspace is ready for use.  There seems to be two characteristic streams depending on whether modules are specified in `InitialSessionState.Modules`.\r\n\r\nThe characteristic event streams seem to be as shown below.  The last event mentioned in the respective stream seems to indicate that the runspace is ready for use.\r\n\r\n```none\r\nNo Modules Specified\r\n\r\nRunspaceAvailability RunspaceStateInfo\r\n-------------------- -----------------\r\n                     Opening          \r\nAvailable                             \r\n                     Opened           \r\n```\r\n\r\n```none\r\nModules Specified\r\n\r\nRunspaceAvailability RunspaceStateInfo \r\n-------------------- ----------------- \r\n                     Opening           \r\nAvailable                              \r\n                     Opened            \r\nBusy                                   \r\nAvailable                              \r\n```\r\n\r\nI don't know how robust this method is, but it's the best method I have found for getting a signal when a runspace is ready for use.  I've also found that having such a signal is critical for achieving speedup by utilizing multiple processors when executing CPU-bound PowerShell.",
      "created_at": "2018-06-15T15:28:16Z",
      "updated_at": "2018-06-15T15:28:16Z"
    }
  ],
  "created_at": "2018-06-09T16:48:52Z",
  "labels": [
    "Issue-Question",
    "WG-Engine"
  ],
  "number": 7034,
  "state": "open",
  "title": "How is waiting meant to work when using Runspace.OpenAsync?",
  "updated_at": "2018-06-15T15:28:16Z"
}