{
  "_url": "https://github.com/PowerShell/PowerShell/issues/12132",
  "author": "jhoneill",
  "body": "At present there are multiple open issues (inc #6652, #2963, and #2964, #2449) which overlap with this one, but don't completely cover it and if my understanding of the facts is badly lacking, or  I haven't found the key item among the issues I'm more than than happy for the powers that be to close this one. \r\n\r\n**Scenario**. I want to implement a Parameter validation attribute class to support functions in a module. \r\nIf I write the class in C# and load it with `add-type` my understanding is that it is compiled to a temporary DLL and loaded and available system wide, whatever method is used to load it . \r\n\r\nIf I write the class in PowerShell it is not exported by the module if it is placed in the PSM1 file, or a file dot sourced by the PSM1.  Here is the class \r\n```PowerShell\r\nusing namespace System.Collections\r\nusing namespace System.Collections.Generic\r\nusing namespace System.Drawing.Printing\r\nusing namespace System.Management.Automation\r\n#Validator as PS Class [ValidatePrinterExistsAttribute()]\r\nclass ValidatePrinterExistsAttribute : ValidateArgumentsAttribute {\r\n    [void] Validate([object]$Argument, [EngineIntrinsics]$EngineIntrinsics) {\r\n        if(-not ($Argument -in [PrinterSettings]::InstalledPrinters)) {\r\n          Throw [ParameterBindingException]::new(\"'$Argument' is not a valid printer name.\")\r\n        }\r\n    }\r\n}\r\n```\r\nand here is a related class in C#\r\n```\r\nAdd-type  -ReferencedAssemblies \"System.Drawing.Common\", \"System.Linq\",\"System.Management.Automation\"  @\"\r\nusing System.Drawing.Printing;\r\nusing System.Linq;\r\nusing System.Management.Automation;\r\npublic class ValidPrinterSetGenerator : IValidateSetValuesGenerator\r\n{\r\n    public string[] GetValidValues()\r\n    {\r\n        return PrinterSettings.InstalledPrinters.Cast<string>().ToArray();\r\n    }\r\n}\r\n\"@  -WarningAction SilentlyContinue -CompilerOptions \"/nowarn:CS1701,CS1702\"\r\n```\r\n\r\n(I found I had to use /NoWarn to supress issues which suggested some .NET Core parts were mismatched) .\r\nAfter loading these via the PSM file  the C# class is available and   `[ValidPrinterSetGenerator]::new().GetValidValues()` returns a the list of printers, but  a function in the module which uses the  PS class for one of its parameters gives this error \r\n```\r\n#501 PS7 C:\\Users\\mcp\\Documents\\PowerShell\\classTest>.\\load2.ps1\r\nInvalidOperation: C:\\Users\\mcp\\Documents\\PowerShell\\classTest\\classtest.psm1:19:9\r\nLine |\r\n  19 |          [ValidatePrinterExistsAttribute()]\r\n     |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n     | Cannot find the type for custom attribute 'ValidatePrinterExistsAttribute'. Make sure that the assembly that contains this type is loaded.\r\n```\r\n\r\nAs I understand it the class might be available to things wholly within the module, but the validation attribute needs be accessible outside the module's scope. (Parameter stuff being done outside the module) \r\n\r\n**The is a workaround: add the classes to the `ScriptsToProcess` in the module manifest**. \r\n\r\nThere is a secondary issue even with workaround. If the module is loaded using` import-module `in a script the validation works but the PS class is invisible thereafter unless the script is dot-sourced. However if the script uses `using module`  or `#requires -module` the class is available without dot-sourcing.  I think it is broadly OK to say load modules which require at least V5 because they have classes with the `using`  syntax. \r\n\r\nGiven the length of time some of issues have been open, I'm wondering if the intent is to \r\n1.  Make import and using/requires consistent  and / or \r\n2.  Provide a way to export PS classes from a module, rather than pre-loading them and/or\r\n3.  Provided some more detailed documentation of the status quo ? \r\n\r\n\r\n\r\n",
  "closed_at": "2020-03-16T13:34:23Z",
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Add-Type uses \"Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes\" as namespace. So \"[Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes.ValidatePrinterExistsAttribute()]\" could work.",
      "created_at": "2020-03-16T09:55:57Z",
      "updated_at": "2020-03-16T09:55:57Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "\r\n\r\n> Add-Type uses \"Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes\" as namespace. So \"[Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes.ValidatePrinterExistsAttribute()]\" could work.\r\n\r\nSadly, not\r\n```\r\n>[Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes.ValidatePrinterExistsAttribute] \r\nInvalidOperation: Unable to find type [Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes.ValidatePrinterExistsAttribute].\r\n```\r\n\r\nBut it is present to do the validation\r\n```\r\n>test2 fax\r\nfax\r\n>test2 foobar\r\ntest2: Cannot validate argument on parameter 'name'. 'foobar' is not a valid printer name.\r\n```",
      "created_at": "2020-03-16T10:48:04Z",
      "updated_at": "2020-03-16T10:48:04Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@jhoneill Please add more strong repo steps for both cases including the module sources - it would safe time of reviewers. Thanks!",
      "created_at": "2020-03-16T11:13:30Z",
      "updated_at": "2020-03-16T11:13:30Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> @jhoneill Please add more strong repo steps for both cases including the module sources - it would safe time of reviewers. Thanks!\r\n\r\nSimple demo. There are comments in the PSM1 / PSD1 to show which lines to enable to change where the loading happens.  \r\nYou can import the module and run test2 <<printer name>> or try doing that with load.ps1 or by dot sourcing load.ps1 and comparing the results. \r\n\r\nAs well as test2.ps1  You can compare the c# class behaviour e.g.\r\n`[ValidPrinterSetGenerator]::new().GetValidValues()` \r\nand ps class behaviour e.g. \r\n`[ValidatePrinterExistsAttribute]\r\n`\r\n\r\n[classtest.zip](https://github.com/PowerShell/PowerShell/files/4337898/classtest.zip)\r\n\r\nThanks !!\r\n",
      "created_at": "2020-03-16T11:36:41Z",
      "updated_at": "2020-03-16T11:36:41Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> 1. Make import and using/requires consistent  and / or\r\n\r\nThey've mentioned a few times that requiring `using` was a design decision because classes are largely a parse time concept, so a parse time import was needed.\r\n\r\n> 2. Provide a way to export PS classes from a module, rather than pre-loading them and/or\r\n\r\nIf the classes are defined within the psm1, `using module` will import them.  This is currently the only \"proper\" way to define classes to be exported.",
      "created_at": "2020-03-16T12:16:22Z",
      "updated_at": "2020-03-16T12:16:22Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "This looks like dup #1762.",
      "created_at": "2020-03-16T12:30:08Z",
      "updated_at": "2020-03-16T12:30:08Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> > 1. Make import and using/requires consistent  and / or\r\n> \r\n> They've mentioned a few times that requiring `using` was a design decision because classes are largely a parse time concept, so a parse time import was needed.\r\n> \r\n> > 1. Provide a way to export PS classes from a module, rather than pre-loading them and/or\r\n> \r\n> If the classes are defined within the psm1, `using module` will import them. This is currently the only \"proper\" way to define classes to be exported.\r\n\r\nWell, partly. If the classes are in the PSM1 file, instead of Dot-Sourced into I can have this as my PSM\r\n```\r\nusing namespace System.Drawing.Printing\r\nusing namespace System.Management.Automation\r\nusing namespace System.Management.Automation.Language\r\nclass ValidatePrinterExistsAttribute : ValidateArgumentsAttribute {\r\n    [void] Validate([object]$Argument, [EngineIntrinsics]$EngineIntrinsics) {\r\n        if(-not ($Argument -in [PrinterSettings]::InstalledPrinters)) {\r\n          Throw [ParameterBindingException]::new(\"'$Argument' is not a valid printer name.\")\r\n        }\r\n    }\r\n}\r\n\r\nfunction test2 {\r\nparam (\r\n    [ValidatePrinterExistsAttribute()]\r\n    $name\r\n)\r\n$name\r\n}\r\n\r\n```  \r\nThen \r\n`ipmo .\\classtest.psm1 ; test2 fax ; test2 foo; [ValidatePrinterExistsAttribute] `\r\nvalidates _but_ can't find the attribute class and as you say \r\n\r\n`using module .\\classtest.psm1`\r\n`test2 fax ; test2 foo; [ValidatePrinterExistsAttribute]`\r\nValidates and **does** find the attribute class \r\n\r\nOK. So 2 learnings\r\n1.  Put the classes **directly into the PSM** . Dot Sourcing them in does not work.  Those people who like a minimal PSM1 file will have to learn to cope.  \r\n2.  `Using` loads more `than` import-module ` does (and I think `requires`  is like using, not like import\r\n\r\nPasting the using ... & `test...` lines into load2.ps1 and running that ...  validates and finds the class but after loading\r\n```\r\n>test2 foo\r\ntest2: Cannot validate argument on parameter 'name'. 'foo' is not a valid printer name.\r\n> [ValidatePrinterExistsAttribute]\r\nInvalidOperation: Unable to find type [ValidatePrinterExistsAttribute].\r\n```\r\nThe  module's function is there and calls the class, but the class isn't visible outside the script which loaded the module... unless I dot source load2.ps1.  So Dot sourcing is required in one place, and fails in another. \r\n\r\n\r\n",
      "created_at": "2020-03-16T12:55:05Z",
      "updated_at": "2020-03-16T12:55:05Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> This looks like dup #1762.\r\nOverlaps but not exactly a dup :-) \r\nThe difference by adding classes to the PSM that @SeeminglyScience  called out is new (and very useful) information.\r\n[Might have to blog that]",
      "created_at": "2020-03-16T13:09:35Z",
      "updated_at": "2020-03-16T13:10:10Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> > This looks like dup #1762.\r\n> > Overlaps but not exactly a dup :-)\r\n> > The difference by adding classes to the PSM that @SeeminglyScience  called out is new (and very useful) information.\r\n> > [Might have to blog that]\r\n\r\nNah it's the same thing I think.  My guess is that the bug is related to when the resolution of the `ITypeName` is cached.  It applies to most instances of trying to use an attribute that is loaded (even with `Add-Type -TypeDef`, even with `Add-Type -Path` to a dll).  Type resolution for attributes outside of the built in ones is sorta borked.",
      "created_at": "2020-03-16T13:14:56Z",
      "updated_at": "2020-03-16T13:15:19Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Can confirm, I've seen a lot of funkiness when using custom attributes. Sometimes it's fine to call them `NameAttribute` and PS picks it up fine with `[Name()]`, other times it refuses to find it and you've gotta just call the class itself `[Name]`.\r\n\r\nAmong many other oddities that are frustrating as all heck to reliably reproduce.",
      "created_at": "2020-03-16T13:16:33Z",
      "updated_at": "2020-03-16T13:16:33Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I set \"answered\" since we have a workaround and cross-reference with meta-issue #6652.",
      "created_at": "2020-03-16T13:28:06Z",
      "updated_at": "2020-03-16T14:14:10Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "@vexx32  yes saw your comments on 1762 , and had the same with where you can omit 'attribute' and next thing you find you can't  - and agree it's full of oddities. \r\n  \r\n@iSazonov  Makes sense :-) \r\n\r\n",
      "created_at": "2020-03-16T13:34:23Z",
      "updated_at": "2020-03-16T13:34:23Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "@vexx32 It might amused you that after this a penny dropped that one of the problems I was getting might be because I'd removed \"attribute\" ... just put it back in into close to 100  places where I'd replaced a dynamic parameters with static ones and a validate class and now things behave (as above) without . sourcing ",
      "created_at": "2020-03-17T16:21:04Z",
      "updated_at": "2020-03-17T16:21:04Z"
    },
    {
      "author": "TitaniumCoder477",
      "author_association": "NONE",
      "body": "> If the classes are defined within the psm1, `using module` will import them. This is currently the only \"proper\" way to define classes to be exported.\r\n\r\nFrom what I can tell, this is apparently still true. But this doesn't make any sense to me. I download a psm1 file from my repo as pure text over TLS, and I convert  it to a dynamic module via New-Module and then import it into memory with Import-Module. Now I can access the functions as I wish, and when I am done, I have nothing to cleanup on the file system. Why cannot I do the same thing with a class? I should be able to download the class file, whether in a psm1 or ps1 file, as pure text over TLS and then import it easily into memory for instantiation. Logically, it makes sense to just import it with a module OR import it with another such command. For example:\r\n\r\n```\r\n$fooClass = New-Class -ScriptBlock $fooClassAsText\r\n$fooClass | Import-Class\r\n$myFooObj = [Foo]::new()  #If the class import was unsuccessful, I'll get an exception here telling me that Foo doesn't exist\r\n```",
      "created_at": "2020-04-28T20:40:24Z",
      "updated_at": "2020-04-28T20:40:24Z"
    }
  ],
  "created_at": "2020-03-16T09:27:16Z",
  "number": 12132,
  "state": "closed",
  "title": "Classes, modules, fixing behaviour and scope",
  "updated_at": "2020-04-28T20:40:25Z"
}