{
  "_url": "https://github.com/PowerShell/PowerShell/issues/16482",
  "author": "iRon7",
  "body": "### Summary of the new feature / enhancement\r\n\r\nRelated to requests:\r\n\r\n* [`#20317` Add Named Arguments String.Format Overloads](https://github.com/dotnet/runtime/issues/20317)\r\n*  [`#13675` Named format template parameters](https://github.com/PowerShell/PowerShell/issues/13675)\r\n* [`#11693` Make string templating a first-class feature by exposing $ExecutionContext.InvokeCommand.ExpandString() as cmdlet Expand-String](https://github.com/PowerShell/PowerShell/issues/11693)\r\n\r\n(and all linked requests)\r\n\r\n> Yeah this is something that gets asked about _pretty frequently_ in support channels. There's probably a few issues for it already that could be closed in favor of this one.\r\n\r\n### Proposed technical implementation details (optional)\r\n\r\nWhy not (also) adding this functionality to the existing `Out-String` cmdlet with e.g. a `-Format` parameter?\r\nKnowing that there are quiet some other cmdlets that supersede and extend related operators and .net methods.\r\n\r\n> [`String.Format`](https://docs.microsoft.com/en-us/dotnet/api/system.string.format) is already a huge source of bugs and performance issues and adding more layers is not something we really want to do. I like the general idea of a basic templating system but I think it would be better served as a higher level concept not directly on string\r\n\r\nUnfortunately, I am not a C# programmer but just from a programming point of view, it shouldn't be too much effort to add functionally similar to this (PowerShell) prototype:\r\n\r\n### `Out-String -Format`\r\n<details>\r\n  <summary>Prototype</summary>\r\n\r\n```PowerShell\r\nfunction OutString {\r\n    [CmdletBinding()]param(\r\n        [Parameter(ValueFromPipeline = $true, Mandatory = $true)]$InputObject,\r\n        [Parameter(position = 0)][string]$Format\r\n    )\r\n\r\n    begin { $i = $Null }\r\n\r\n    process {\r\n        if ($Format -and $Null -eq $i) {\r\n            $i = 0\r\n            $Keys = if ($_ -is [System.Collections.IDictionary]) { $_.get_Keys() } else { $_.PSObject.Properties.Name }\r\n            $Names = foreach ($Key in @($Keys)) {\r\n                $Name = \"(?<={)$Key(?=([,:].*)?})\"\r\n                if ($Format -Match $Name) {\r\n                    $Format = $Format -Replace $Name, $i++\r\n                    $Key\r\n                }\r\n            }\r\n            if (!$Names -and $Format -in $Keys) {\r\n                $Names =  $Format\r\n                $Format = '{0}'\r\n            }\r\n        }\r\n        if ($Names) { $Format -f @(foreach ($Name in $Names) { $_.$Name }) } else { $_ }\r\n    }\r\n}\r\n```\r\n</details>\r\n\r\n### Examples\r\n```PowerShell\r\nGet-Module |OutString -Format '{Name, -40} {Version, 10}'\r\n\r\nMicrosoft.PowerShell.Management             3.1.0.0\r\nMicrosoft.PowerShell.Security               3.0.0.0\r\nMicrosoft.PowerShell.Utility                3.1.0.0\r\nMicrosoft.WSMan.Management                  3.0.0.0\r\nPowerShellEditorServices.Commands             0.2.0\r\nPowerShellEditorServices.VSCode               0.2.0\r\nPSReadLine                                    2.1.0\r\n```\r\n\r\n```PowerShell\r\nGet-ChildItem |OutString -f '{BaseName}({LastWriteTime:yyyy-MM-dd}){Extension}'\r\n\r\nArchive(2021-11-16)\r\nApp_List(2021-11-16).json\r\nBuild-List(2021-11-17).ps1\r\nConvertTo-String(2021-11-17).ps1\r\nTest-List(2021-11-17).ps1\r\n```",
  "closed_at": null,
  "comments": [
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "At second thought (or actually it was my first), maybe this should be a separate `ConvertTo-String` cmdlet (with a `-Format` parameter). I am missing the choice of the **`Out`** [verb](https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/approved-verbs-for-windows-powershell-commands?view=powershell-7.2#data-verbs) in `Out-String` a little:\r\n\r\n### `Out`\r\n> Sends data out of the environment. For example, the `Out-Printer` cmdlet sends data to a printer.\r\n\r\n### `ConvertTo`\r\n> Converts from one or more types of input to a primary output type (the cmdlet noun indicates the output type).\r\n\r\n### `Out-String`\r\n[**Description**](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/out-string?view=powershell-7.2#description)\r\n> The `Out-String` cmdlet [**converts**](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/out-string?view=powershell-7.2#description) input objects [**in**](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/out-string?view=powershell-7.2#description)to strings...\r\n\r\nMaybe it is because *by default* `Out-String` converts the input into a *single* string (but that is also the case with parsers as `ConvertTo-Json`) or maybe it is considered to be at the end of the pipeline `... |Convert-Json |Out-String` (but then it is still not really a end cmdlet, I might still do: `... |Out-String |Out-Print`).",
      "created_at": "2021-11-18T07:02:49Z",
      "updated_at": "2021-11-18T07:02:49Z"
    }
  ],
  "created_at": "2021-11-17T13:06:38Z",
  "number": 16482,
  "state": "open",
  "title": "Add `-Format` parameter to `Out-String`",
  "updated_at": "2021-11-23T11:33:52Z"
}