{
  "_url": "https://github.com/PowerShell/PowerShell/issues/7860",
  "author": "agaudreault",
  "body": "To leverage the Argument completer attribute in our cmdlets, we sometime need to pass parameters to it. However, it is quite hard to use them and write quality code at the same time.\r\n\r\nHere is a working example using the ScriptBlock constructor.\r\n```powershell\r\npublic class DemoCompleterAttribute : ArgumentCompleterAttribute\r\n{\r\n\tpublic static Dictionary<string, int[]> Values = new Dictionary<string, int[]>\r\n\t{\r\n\t\t{\"set1\", new []{1,2,3,4,5}},\r\n\t\t{\"set2\", new []{6,7,8,9,10}}\r\n\t};\r\n\r\n\tpublic DemoCompleterAttribute(string setName)\r\n\t\t: base(CreateScriptBlock(GetFunction(setName)))\r\n\t{\r\n\t}\r\n\r\n\tpublic static string[] GetSet(string setName)\r\n\t{\r\n\t\treturn DemoCompleterAttribute.Values[setName].Select(x => x.ToString()).ToArray();\r\n\t}\r\n\r\n\tprivate static string GetFunction(string setName)\r\n\t{\r\n\t\treturn $\"\\t[{typeof(DemoCompleterAttribute)}]::{nameof(GetSet)}('{setName}')\";\r\n\t}\r\n\r\n\tprivate static ScriptBlock CreateScriptBlock(string function)\r\n\t{\r\n\t\tstring script = \"param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)\\n\" +\r\n\t\t\t\t\t\t\"function GetList{\\n\" +\r\n\t\t\t\t\t\t$\"{function}\\n\" +\r\n\t\t\t\t\t\t\"}\\n\" +\r\n\t\t\t\t\t\t\"$list = GetList\\n\" +\r\n\t\t\t\t\t\t\"$list | Where-Object { $_ -Like \\\"*$wordToComplete*\\\" } | ForEach-Object { [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_) }\";\r\n\t\tScriptBlock scriptBlock = ScriptBlock.Create(script);\r\n\t\treturn scriptBlock;\r\n\t}\r\n}\r\n```\r\n\r\nHere is a better implementation possibility that would scale a lot more with complex logic using the parameters.\r\n```powershell\r\npublic class BetterCompleterAttribute : ArgumentCompleterAttribute, IArgumentCompleter\r\n{\r\n\tprivate string SetName { get; }\r\n\r\n\tpublic BetterCompleterAttribute(string setName)\r\n\t\t: base() // :base(typeof(BetterCompleterAttribute))\r\n\t{\r\n\t\tSetName = setName;\r\n\t}\r\n\r\n\tprivate IEnumerable<string> GetSet()\r\n\t{\r\n\t\treturn DemoCompleterAttribute.Values[SetName].Select(x => x.ToString()).ToArray();\r\n\t}\r\n\r\n\tpublic IEnumerable<CompletionResult> CompleteArgument(string commandName, string parameterName, string wordToComplete, CommandAst commandAst, IDictionary fakeBoundParameters)\r\n\t{\r\n\t\tIEnumerable<string> values = GetSet();\r\n\r\n\t\tvar wordToCompletePattern = WildcardPattern.Get(string.IsNullOrWhiteSpace(wordToComplete) ? \"*\" : wordToComplete + \"*\", WildcardOptions.IgnoreCase);\r\n\t\tforeach (string str in values)\r\n\t\t{\r\n\t\t\tif (wordToCompletePattern.IsMatch(str))\r\n\t\t\t{\r\n\t\t\t\tyield return new CompletionResult(str, str, CompletionResultType.ParameterValue, str);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\nInstead of creating a new instance of IArgumentCompleter, We should be able to check if the argumentCompleterAttribute implements IArgumentCompleter and call CompleteArgument.\r\nhttps://github.com/PowerShell/PowerShell/blob/5d03e1653a7d518715fa3f00587cad6b5c78cc89/src/System.Management.Automation/engine/CommandCompletion/CompletionCompleters.cs#L1977\r\n\r\nSee ArgumentCompletionsAttribute call to CompleteArgument method. It uses the current instance and allows the possibility to use the values passed in the constructor.",
  "closed_at": null,
  "comments": [],
  "created_at": "2018-09-25T21:10:50Z",
  "number": 7860,
  "state": "open",
  "title": "ArgumentCompleterAttribute should be able to implement IArgumentCompleter",
  "updated_at": "2018-09-26T07:47:44Z"
}