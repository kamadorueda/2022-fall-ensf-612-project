{
  "_url": "https://github.com/PowerShell/PowerShell/issues/3173",
  "author": "Jaykul",
  "body": "There was a [PowerShell Team blog post years ago](https://blogs.msdn.microsoft.com/powershell/2010/01/07/how-objects-are-sent-to-and-from-remote-sessions/) about how serialization works and how it should be possible to customize -- and of course, now I have access to all the source code, but so far I haven't been able to make extending the serialization work. If someone can help me figure this out, I'll make sure we get a HowTo document for future module authors out of it ...\r\n\r\nI'm going to use a simple example, but remember that I'm looking for the way to make Deserialization work **properly** -- I don't want to hear about all the workarounds for this _particular_ case (there are several). The real problem I'm trying to solve is more complicated.\r\n\r\nI need to call a remote function which takes a DateTimeOffset object, Unlike DateTime, DateTimeOffest isn't treated as a primitive type (although it should be #3172), so I want to fix that in my module.\r\n\r\n## Here's what I tried:\r\n\r\n```posh\r\nusing namespace System.Management.Automation\r\n\r\nclass DateTimeOffsetDeserializer : System.Management.Automation.PSTypeConverter {\r\n\r\n    [bool] CanConvertFrom([object]$sourceValue, [Type]$destinationType)\r\n    {\r\n        Write-Warning \"CanConvertFrom $SourceValue to $($destinationType.FullName)\"\r\n        return ([PSObject]$sourceValue).PSTypeNames.Contains(\"Deserialized.System.DateTimeOffset\")\r\n    }\r\n\r\n    [object] ConvertFrom([object]$sourceValue, [Type]$destinationType, [IFormatProvider]$formatProvider, [bool]$ignoreCase)\r\n    {\r\n        Write-Warning \"ConvertFrom $SourceValue to $($destinationType.FullName)\"\r\n        [PSObject]$psSourceValue = $sourceValue\r\n        return [DateTimeOffset]::new($psSourceValue.Ticks, $psSourceValue.Offset)\r\n    }\r\n\r\n    [bool] CanConvertTo([object]$sourceValue, [Type]$destinationType)\r\n    {\r\n        Write-Warning \"CanConvertTo $SourceValue to $($destinationType.FullName)\"\r\n        return ([PSObject]$sourceValue).PSTypeNames.Contains(\"Deserialized.System.DateTimeOffset\") -and $destinationType -eq \"System.DateTimeOffset\"\r\n    }\r\n\r\n    [object] ConvertTo([object]$sourceValue, [Type]$destinationType, [IFormatProvider]$formatProvider, [bool]$ignoreCase)\r\n    {\r\n        Write-Warning \"ConvertTo $SourceValue to $($destinationType.FullName)\"\r\n        [PSObject]$psSourceValue = $sourceValue\r\n        return [DateTimeOffset]::new($psSourceValue.Ticks, $psSourceValue.Offset)\r\n    }\r\n}\r\n\r\n# This should be enough, right?\r\nUpdate-TypeData -TypeName 'DateTimeOffset' -TargetTypeForDeserialization 'DateTimeOffsetDeserializer' -Force\r\n\r\n# I tried adding all the rest of these\r\nUpdate-TypeData -TypeName 'Deserialized.System.DateTimeOffset' -TargetTypeForDeserialization 'DateTimeOffsetDeserializer' -Force\r\nUpdate-TypeData -TypeName 'DateTimeOffset' -MemberName 'TargetTypeForDeserialization' -MemberType 'NoteProperty' -Value 'DateTimeOffsetDeserializer'\r\nUpdate-TypeData -TypeName 'Deserialized.System.DateTimeOffset' -MemberName 'TargetTypeForDeserialization' -MemberType 'NoteProperty' -Value 'DateTimeOffsetDeserializer'\r\n```\r\n\r\n\r\n### But nothing makes the this come out as a DateTimeOffset\r\n```posh\r\nusing namespace System.Management.Automation\r\n[PSSerializer]::Deserialize( [PSSerializer]::Serialize([DateTimeOffset]::Now) ).PSTypeNames\r\n```\r\n\r\n### Or make this not be \"Deserialized\"\r\n```posh\r\nInvoke-Command -ComputerName localhost { [DateTimeOffset]::Now } | % PSTypeNames\r\n```\r\n\r\n### Or make this run without crashing:\r\n```posh\r\nInvoke-Command -ComputerName localhost { param([DateTimeOffset]$Time) $Time.LocalDateTime } -Args ([DateTimeOffset]::Now)\r\n```\r\n\r\nI also tried creating the `DateTimeOffsetDeserializer` class in C#, but I think I'm misunderstanding that original blog post or something about how the registration works...",
  "closed_at": null,
  "comments": [
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "Ok, after three days of trying ... I finally thought of searching through **all** of GitHub for use of `TargetTypeForDeserialization` and came across the solution. The TypeData needs to be like this:\r\n\r\n### Register the TargetType for the Deserialized type:\r\n\r\n```posh\r\nUpdate-TypeData -TypeName 'Deserialized.System.DateTimeOffset' -TargetTypeForDeserialization 'System.DateTimeOffset'\r\n```\r\n\r\n### Then register the TypeConverter for that TargetType:\r\n\r\n```posh\r\nUpdate-TypeData -TypeName 'System.DateTimeOffset' -TypeConverter 'DateTimeOffsetDeserializer'\r\n```\r\n\r\nThis is the part that was completely skipped over in [the blog post](https://blogs.msdn.microsoft.com/powershell/2010/01/07/how-objects-are-sent-to-and-from-remote-sessions/) -- if anyone can add a couple of lines to that post, that would be great! \ud83d\ude09 \r\n\r\nYou can, of course, do all of this in a Types.ps1xml instead:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\r\n<Types>\r\n    <Type>\r\n        <Name>System.DateTimeOffset</Name>\r\n        <TypeConverter>\r\n            <TypeName>DateTimeOffsetDeserializer</TypeName>\r\n        </TypeConverter>\r\n        <Members>\r\n            <MemberSet>\r\n                <Name>PSStandardMembers</Name>\r\n                <Members>\r\n                    <NoteProperty>\r\n                        <Name>SerializationDepth</Name>\r\n                        <Value>1</Value>\r\n                    </NoteProperty>\r\n                </Members>\r\n            </MemberSet>\r\n        </Members>\r\n    </Type>\r\n    <Type>\r\n        <Name>Deserialized.System.DateTimeOffset</Name>\r\n        <Members>\r\n            <MemberSet>\r\n                <Name>PSStandardMembers</Name>\r\n                <Members>\r\n                    <NoteProperty>\r\n                        <Name>TargetTypeForDeserialization</Name>\r\n                        <Value>System.DateTimeOffset</Value>\r\n                    </NoteProperty>\r\n                </Members>\r\n            </MemberSet>\r\n        </Members>\r\n    </Type>\r\n</Types>\r\n```\r\n\r\nI should note (because I haven't tested this on PowerShell 3 or 4): the explanation in the SDK makes this somewhat more convoluted -- rather than specifying the _actual target type_ as the `TargetTypeForDeserialization`, they state that you should specify the Deserializer as the `TargetTypeForDeserialization` (i.e. in place of `System.DateTimeOffset` above), which means that you need an extra call (or `<Type>` entry) to set the `SerializationDepth` ....\r\n\r\nThat makes _no sense_ to me, but perhaps it's actually necessary for some situations or older versions of PowerShell.",
      "created_at": "2017-02-22T03:20:04Z",
      "updated_at": "2017-02-22T03:56:47Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@Jaykul Great gem! Thanks!\r\nYou could put this in https://github.com/PowerShell/PowerShell-Docs",
      "created_at": "2017-02-22T09:34:39Z",
      "updated_at": "2017-02-22T09:34:39Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "It turns out, there's a different problem: this *does not work* for PowerShell classes.\r\n\r\nTake this simple case for example:\r\n\r\n```posh\r\nclass Test {\r\n    [string]$FirstName\r\n    [string]$LastName\r\n    [string]$FullName\r\n\r\n    Test([string]$FirstName, [string]$LastName) {\r\n        $this.FirstName = $FirstName\r\n        $this.LastName = $LastName\r\n        $this.FullName = $FirstName + \" \" + $LastName\r\n    }\r\n}\r\n```\r\n\r\nBecause it has a custom constructor, you need a custom converter.  \r\n\r\nTo hide some of the sillyness of this, I like to use an intermediate PSObjectConverter:\r\n\r\n```posh\r\n# A do-nothing converter, just to hide the \"object\" methods\r\nclass PSObjectConverter : System.Management.Automation.PSTypeConverter\r\n{\r\n    [bool] CanConvertFrom([PSObject]$psSourceValue, [Type]$destinationType)\r\n    {\r\n        return $false\r\n    }\r\n\r\n    [object] ConvertFrom([PSObject]$psSourceValue, [Type]$destinationType, [IFormatProvider]$formatProvider, [bool]$ignoreCase)\r\n    {\r\n        throw [NotImplementedException]::new()        \r\n    }\r\n\r\n    # These things down here are just never used. Why they must be here, I have no idea.\r\n    [bool] CanConvertFrom([object]$sourceValue, [Type]$destinationType)\r\n    {\r\n        return $false;\r\n    }\r\n\r\n    [object] ConvertFrom([object]$sourceValue, [Type]$destinationType, [IFormatProvider]$formatProvider, [bool]$ignoreCase)\r\n    {\r\n        throw [NotImplementedException]::new();\r\n    }\r\n\r\n    [bool] CanConvertTo([object]$sourceValue, [Type]$destinationType)\r\n    {\r\n        throw [NotImplementedException]::new();\r\n    }\r\n\r\n    [object] ConvertTo([object]$sourceValue, [Type]$destinationType, [IFormatProvider]$formatProvider, [bool]$ignoreCase)\r\n    {\r\n        throw [NotImplementedException]::new();\r\n    }\r\n}\r\n\r\n\r\nclass TestConverter : PSObjectConverter\r\n{\r\n    [bool] CanConvertFrom([PSObject]$psSourceValue, [Type]$destinationType)\r\n    {\r\n        Write-Warning \"CanConvertFrom $($psSourceValue.PSTypeNames)\"\r\n        return $psSourceValue.PSTypeNames.Contains(\"Deserialized.Test\")\r\n    }\r\n\r\n    [object] ConvertFrom([PSObject]$psSourceValue, [Type]$destinationType, [IFormatProvider]$formatProvider, [bool]$ignoreCase)\r\n    {\r\n        Write-Warning \"ConvertFrom $($psSourceValue.PSTypeNames)\"\r\n        Write-Warning \"So there can be no doubt this does not work:\"\r\n        Write-Warning (\"[Test]::new('\" + $psSourceValue.FirstName + \"', '\" + $psSourceValue.LastName + \"')\")\r\n        $Converted = [Test]::new($psSourceValue.FirstName, $psSourceValue.LastName)\r\n        Write-Warning \"REMOTE EXECUTION NEVER REACHES THIS LINE\"\r\n        return $Converted\r\n    }\r\n}\r\n\r\n```\r\n\r\nFinally, register the serialization:\r\n```posh\r\nUpdate-TypeData -TypeName 'Deserialized.Test' -TargetTypeForDeserialization 'Test'\r\nUpdate-TypeData -TypeName 'Test' -TypeConverter 'TestConverter'\r\n```\r\n\r\nNow, test it.  Locally, it works fine:\r\n\r\n```posh\r\n> using namespace System.Management.Automation\r\n>  [PSSerializer]::Deserialize( [PSSerializer]::Serialize( [Test]::new(\"Joel\",\"Bennett\")  ) )\r\n\r\nWARNING: CanConvertFrom Deserialized.Test Deserialized.System.Object\r\nWARNING: ConvertFrom Deserialized.Test Deserialized.System.Object\r\nWARNING: So there can be no doubt this does not work:\r\nWARNING: [Test]::new('Joel', 'Bennett')\r\nWARNING: REMOTE EXECUTION NEVER REACHES THIS LINE\r\n\r\nFirstName LastName FullName\r\n--------- -------- --------\r\nJoel      Bennett  Joel Bennett\r\n```\r\n\r\nBut when I try to run the command remotely, it just hangs?\r\n\r\n```posh\r\nInvoke-Command -ComputerName localhost {\r\n    \"Hello from ${Env:ComputerName}, I got $($args.ForEach{$_.PSTypeNames[0]}) and I'm going to send them back to you:\"\r\n    $args\r\n    \"Goodbye!\"\r\n} -Args ( [Test]::new(\"Joel\",\"Bennett\") )\r\n```\r\n\r\n```\r\nHello from USTWL-JOELB, I got Deserialized.Test and I'm going to send them back to you:\r\nWARNING: CanConvertFrom Deserialized.Test Deserialized.System.Object\r\nWARNING: ConvertFrom Deserialized.Test Deserialized.System.Object\r\nWARNING: So there can be no doubt this does not work:\r\nWARNING: [Test]::new('Joel', 'Bennett')\r\n```\r\n\r\n@lzybkr Is this just not possible?",
      "created_at": "2017-02-22T19:07:05Z",
      "updated_at": "2017-02-22T19:07:05Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "Thanks for the excellent repro.\r\n\r\nGetting this scenario to work might be tricky.\r\n\r\nScriptblocks have runspace affinity. Class methods are really just scriptblocks, they get runspace affinity too.  I think this is an architectural flaw, but it's not easy to fix without requiring locks throughout the engine.\r\n\r\nIn this repro - there is only 1 local runspace. The deserialization is happening on a thread with no runspace and it's waiting for the `Invoke-Command` runspace (the only local runspace, the runspace where the module was imported) to become available to run commands.\r\n\r\nOne fix would be to not block in Invoke-Command - instead timeout and poll for events.",
      "created_at": "2017-02-23T00:07:47Z",
      "updated_at": "2017-02-23T00:07:47Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks. I'll just ... write those classes in C# I guess. But I guess we need to document that you can write C# classes and PowerShell converters but not both in PowerShell, and not PowerShell classes with C# converters (I guess).",
      "created_at": "2017-02-23T01:59:26Z",
      "updated_at": "2017-02-23T02:05:55Z"
    },
    {
      "author": "Brain2000",
      "author_association": "NONE",
      "body": "This is certainly not complete, but will at least let you copy over the class definition and properties to a PSSession. Maybe someone can add methods/constructors... \r\n\r\n```\r\nclass test\r\n{\r\n  [string]$abc;\r\n  [string]$def;\r\n}\r\n\r\nfunction getClassDef\r\n{\r\n\t[OutputType([string])]\r\n\tparam (\r\n\t\t[Parameter(Mandatory=$true)][Type]$classType\r\n\t)\r\n\r\n\t$create = \"class $($classType.Name)`r`n{`r`n \";\r\n\t$create += $classType.GetProperties() | ForEach-Object { \"   [$($_.PropertyType.ToString())]`$$($_.Name)`r`n\"; }\r\n\t$create += \"}\";\r\n\r\n\treturn $create;\r\n}\r\n\r\n$def = getClassDef([test]);\r\n$s = New-PSSession someRemoteComputer\r\nInvoke-Command $s { Invoke-Expression $Using:def } #this creates the class remotely\r\n\r\n#now run a test\r\nInvoke-Command $s { $t = [test]::new(); $t; }\r\n\r\n\r\n```",
      "created_at": "2018-12-20T03:29:04Z",
      "updated_at": "2018-12-20T03:29:04Z"
    },
    {
      "author": "SSvilen",
      "author_association": "NONE",
      "body": "Hi @PaulHigin - we were discussing the topic of object's rehydration after your session about remoting at PSConfEu. You suggested me to open an issue, so that you can discuss that internally and may be do a blog post about it.  It seems that this is not a new topic - so I'll use that issue here as reminder. Thanks to @Jaykul  I have something to work with, but may be new blog post about this topic would be a good start",
      "created_at": "2019-06-10T20:20:00Z",
      "updated_at": "2019-06-10T20:20:00Z"
    },
    {
      "author": "PaulHigin",
      "author_association": "COLLABORATOR",
      "body": "@SSvilen  Thanks, I am back in office now.  I am glad that this helps, but as we discussed this is really something that should be addressed in a blog.  I'll try to do so in the not too distant future.",
      "created_at": "2019-06-18T17:52:37Z",
      "updated_at": "2019-06-18T17:52:37Z"
    },
    {
      "author": "kenny1983",
      "author_association": "NONE",
      "body": "Hi guys, just wondering whether there's been any new developments on this issue in the past 4 months, as I'm trying to get the following script working:\r\n```\r\nclass PSProvisioner {\r\n    [Management.Automation.PSCredential] $Credential\r\n    [Management.Automation.Runspaces.PSSession] $Session\r\n\r\n    [TimeSpan] $TotalTime\r\n\r\n    PSProvisioner() {\r\n        $this.Credential = ([Management.Automation.PSCredential]::new(`\r\n            \"vagrant\", $(ConvertTo-SecureString \"vagrant\" -AsPlainText -Force)))\r\n        $this.Session = New-PSSession -ComputerName 192.168.15.11 `\r\n            -Port 55985 -Credential $this.Credential\r\n    }\r\n\r\n    [void] PrintHeader([string] $header) {\r\n        Write-Host $header\r\n        ...Do some other stuff\r\n    }\r\n\r\n    [void] Test([PSProvisioner] $inst) {\r\n        Invoke-Command -Session $this.Session -ScriptBlock {\r\n            ($Using:inst).PrintHeader(\"This is a test!\")\r\n        }\r\n    }\r\n}\r\n\r\n$provisioner = [PSProvisioner]::new()\r\n$provisioner.Test($provisioner)\r\n```\r\nWhich throws the following error:\r\n```\r\nMethod invocation failed because [Deserialized.PSProvisioner] does not contain a method named 'PrintHeader'.\r\nAt D:\\Dev\\MutatioDev\\provision-guest.ps1:393 char:9\r\n+         Invoke-Command -Session $this.Session -ScriptBlock {\r\n+         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n    + CategoryInfo          : InvalidOperation: (PrintHeader:String) [], RuntimeException\r\n    + FullyQualifiedErrorId : MethodNotFound\r\n```\r\nWould absolutely adore some guidance on how to get this to work, if it's at all possible. In the meantime, I guess I'll have to go back to using scripts \ud83d\ude41 MTIA!",
      "created_at": "2019-10-20T08:45:14Z",
      "updated_at": "2019-10-20T08:45:14Z"
    },
    {
      "author": "Kagre",
      "author_association": "NONE",
      "body": "I'm not sure if it's related or not, but there also appears to be a scoping issue with `-TargetTypeForDeserialization`\r\n\r\n```powershell\r\n.{ #<--- Write-Warning's do not show when run inside this scope, & likewise\r\nclass Test {\r\n    [string]$FirstName\r\n    [string]$LastName\r\n    [string]$FullName\r\n\r\n    Test([string]$FirstName, [string]$LastName) {\r\n        $this.FirstName = $FirstName\r\n        $this.LastName = $LastName\r\n        $this.FullName = $FirstName + \" \" + $LastName\r\n    }\r\n}\r\n\r\n# Minifiy: A do-nothing converter, just to hide the \"object\" methods\r\nclass PSObjectConverter : System.Management.Automation.PSTypeConverter{\r\n  [bool]   CanConvertFrom([PSObject]$psSourceValue, [Type]$destinationType){\r\n    return $false}\r\n  [object] ConvertFrom([PSObject]$psSourceValue, [Type]$destinationType, [IFormatProvider]$formatProvider, [bool]$ignoreCase){\r\n    throw [NotImplementedException]::new()}\r\n\r\n  # These things down here are just never used. Why they must be here, I have no idea.\r\n  [bool]   CanConvertFrom([object]$sourceValue, [Type]$destinationType){\r\n    return $false;}\r\n  [object] ConvertFrom([object]$sourceValue, [Type]$destinationType, [IFormatProvider]$formatProvider, [bool]$ignoreCase){\r\n    throw [NotImplementedException]::new();}\r\n  [bool]   CanConvertTo([object]$sourceValue, [Type]$destinationType){\r\n    throw [NotImplementedException]::new();}\r\n  [object] ConvertTo([object]$sourceValue, [Type]$destinationType, [IFormatProvider]$formatProvider, [bool]$ignoreCase){\r\n    throw [NotImplementedException]::new();}\r\n}\r\n\r\nclass TestConverter : PSObjectConverter\r\n{\r\n    [bool] CanConvertFrom([PSObject]$psSourceValue, [Type]$destinationType)\r\n    {\r\n        Write-Warning \"CanConvertFrom $($psSourceValue.PSTypeNames)\"\r\n        return $psSourceValue.PSTypeNames.Contains(\"Deserialized.Test\")\r\n    }\r\n\r\n    [object] ConvertFrom([PSObject]$psSourceValue, [Type]$destinationType, [IFormatProvider]$formatProvider, [bool]$ignoreCase)\r\n    {\r\n        Write-Warning \"ConvertFrom $($psSourceValue.PSTypeNames)\"\r\n        Write-Warning \"So there can be no doubt this does not work:\"\r\n        Write-Warning (\"[Test]::new('\" + $psSourceValue.FirstName + \"', '\" + $psSourceValue.LastName + \"')\")\r\n        $Converted = [Test]::new($psSourceValue.FirstName, $psSourceValue.LastName)\r\n        Write-Warning \"REMOTE EXECUTION NEVER REACHES THIS LINE\"\r\n        return $Converted\r\n    }\r\n}\r\n\r\nUpdate-TypeData -TypeName 'Deserialized.Test' -TargetTypeForDeserialization 'Test'\r\nUpdate-TypeData -TypeName 'Test' -TypeConverter 'TestConverter'\r\n\r\n($result = [System.Management.Automation.PSSerializer]::Deserialize( \r\n  [System.Management.Automation.PSSerializer]::Serialize( \r\n    [Test]::new(\"Joel\",\"Bennett\")  ) ))\r\n    \r\nget-member -InputObject $result | out-string | write-host -ForegroundColor DarkCyan\r\n}\r\n```\r\n\r\nOtherwise Jobs would have been nice\r\n```powershell\r\n#UsingExample.ps1\r\n. ($Def = {\r\n   class MyObject{\r\n      [int]$Value\r\n      \r\n      MyObject(){\r\n         $this.Value = 0\r\n      }\r\n\r\n      MyObject($v){\r\n         $this.Value = $v\r\n      }\r\n      \r\n      [void] inc(){\r\n         $null = $this.Value++\r\n      }\r\n   }\r\n\r\n   class MyObjectDeserializer : System.Management.Automation.PSTypeConverter {\r\n      [bool] CanConvertFrom([object]$ObjToCast, [Type]$ToType) {\r\n         return $ToType -eq [MyObject]\r\n      }\r\n\r\n      [object] ConvertFrom([object]$ObjToCast, [Type]$ToType, [IFormatProvider]$formatProvider, [bool]$ignoreCase) {\r\n         try{return [MyObject]::new(($ObjToCast.Value))}catch {\r\n            throw ([System.InvalidCastException]\"Unknown Value: $($ObjToCast.Value)\")\r\n         }\r\n      }\r\n\r\n      ################# Not used by PowerShell? ##############################################################\r\n      [bool] CanConvertTo([object]$Value, [Type]$ToType){                                                    #\r\n         throw [System.NotImplementedException]::new(                                                        #\r\n            \"CanConvertTo([Object]'$Value', [Type]'$ToType')\")}                                              #\r\n      [object] ConvertTo([object]$Value, [Type]$ToType, [IFormatProvider]$formatProvider, [bool]$ignoreCase){#\r\n         throw [System.NotImplementedException]::new(                                                        #\r\n            \"ConvertTo([Object]'$Value', [Type]'$ToType', [IFormatProvider], [bool]'$ignoreCase')\")}         #\r\n      ########################################################################################################\r\n   }\r\n   Update-TypeData -TypeName MyObject -TypeConverter 'MyObjectDeserializer'\r\n   Update-TypeData -TypeName 'Deserialized.MyObject' -TargetTypeForDeserialization MyObject\r\n})\r\n\r\n$obj = [MyObject]::new()\r\n\r\n$pss = [System.Management.Automation.PSSerializer]\r\n$dsObj = $pss::Deserialize($pss::Serialize($Obj))\r\n\r\n$wk1 = start-job -Name 'UsingExample\\Worker1' -InitializationScript $Def -ScriptBlock {\r\n   $o = $using:obj\r\n   gm -InputObject $o\r\n   \r\n   $o = [MyObject]$o # <--- Why doesn't it Auto-Rehydrate?\r\n   \r\n   $o.inc()\r\n   $o.value\r\n}\r\nstart-sleep 2\r\nreceive-job $wk1\r\nremove-job $wk1\r\n```",
      "created_at": "2021-03-10T01:03:03Z",
      "updated_at": "2021-03-10T01:03:03Z"
    },
    {
      "author": "Kagre",
      "author_association": "NONE",
      "body": "Never mind `-TargetTypeForDeserialization` appears to be \"working as designed\", and so too is the localized randomization of class type names. \r\n\r\nAfter mucking about with the localized class naming and the timing of the deserialization declaration, I've finally got the Jobs --if not elegant-- at least working (I'll leave the Invoke-Command, re-rehydration(bihydration?) of a job returned deserialized object, and code cleanup to someone else):\r\n\r\n```powershell\r\n#UsingExample.ps1\r\n. ($Def = {\r\n   class MyObject{\r\n      [int]$Value\r\n      \r\n      MyObject(){\r\n         $this.Value = 0\r\n      }\r\n\r\n      MyObject($v){\r\n         $this.Value = $v\r\n      }\r\n      \r\n      [void] inc(){\r\n         $null = $this.Value++\r\n      }\r\n   }\r\n\r\n   class MyObjectDeserializer : System.Management.Automation.PSTypeConverter {\r\n      static [string]$DSTypeName = ''\r\n      \r\n      [bool] CanConvertFrom([object]$ObjToCast, [Type]$ToType) {\r\n         write-host \"CanConvert: from $($ObjToCast.PSTypeNames[0]) to $ToType\" -ForegroundColor DarkCyan\r\n         write-host \"Looking for: $($this::DSTypeName)\" -ForegroundColor Yellow -BackgroundColor Black\r\n         $ObjToCast.PSTypeNames | out-string | write-host  -ForegroundColor Yellow -BackgroundColor Black\r\n         $ObjToCast.PSTypeNames.Contains($this::DSTypeName) | write-host  -ForegroundColor Yellow -BackgroundColor Black\r\n         return $ToType -eq [MyObject] -and (\r\n            $ObjToCast.PSTypeNames.Contains($this::DSTypeName) -or\r\n            $ObjToCast.PSTypeNames.Contains('Deserialized.MyObject')\r\n         )\r\n      }\r\n\r\n      [object] ConvertFrom([object]$ObjToCast, [Type]$ToType, [IFormatProvider]$formatProvider, [bool]$ignoreCase) {\r\n         write-host \"ConvertFrom: from $($ObjToCast.PSTypeNames[0]) to $ToType\" -ForegroundColor DarkCyan\r\n         try{return [MyObject]::new(($ObjToCast.Value))}catch {\r\n            throw ([System.InvalidCastException]\"Unknown Value: $($ObjToCast.Value)\")\r\n         }\r\n      }\r\n\r\n      ################# Not used by PowerShell? ##############################################################\r\n      [bool] CanConvertTo([object]$Value, [Type]$ToType){                                                    #\r\n         throw [System.NotImplementedException]::new(                                                        #\r\n            \"CanConvertTo([Object]'$Value', [Type]'$ToType')\")}                                              #\r\n      [object] ConvertTo([object]$Value, [Type]$ToType, [IFormatProvider]$formatProvider, [bool]$ignoreCase){#\r\n         throw [System.NotImplementedException]::new(                                                        #\r\n            \"ConvertTo([Object]'$Value', [Type]'$ToType', [IFormatProvider], [bool]'$ignoreCase')\")}         #\r\n      ########################################################################################################\r\n   }\r\n   $psz = [System.Management.Automation.PSSerializer]\r\n   $o = [MyObject]::New(0)\r\n   $dso = $psz::Deserialize($psz::Serialize($o))\r\n   $LocalDSTypeName = $dso.PSTypeNames[0]\r\n   [MyObjectDeserializer]::DSTypeName = $LocalDSTypeName\r\n\r\n   Update-TypeData -TypeName MyObject -TypeConverter 'MyObjectDeserializer'\r\n   Update-TypeData -TypeName 'Deserialized.MyObject' -TargetTypeForDeserialization MyObject\r\n   if($LocalDSTypeName -ne 'Deserialized.MyObject'){\r\n      Update-TypeData -TypeName $LocalDSTypeName -TargetTypeForDeserialization MyObject\r\n   }\r\n   rv o,dso\r\n})\r\n$JobDef = {\r\n   [MyObjectDeserializer]::DSTypeName = '$LocalDSTypeName'\r\n   Update-TypeData -TypeName '$LocalDSTypeName' -TargetTypeForDeserialization MyObject -ErrorAction SilentlyContinue\r\n}\r\n$JobDef = [ScriptBlock]::Create(($Def.ToString()+ $JobDef.ToString().replace('$LocalDSTypeName',$LocalDSTypeName)))\r\n\r\n$obj = [MyObject]::new()\r\n$obj.inc()\r\n\r\nwrite-host 'Local: Expected auto-cast by deserialization rehydration' -ForegroundColor Magenta\r\n$dsObj = $psz::Deserialize($psz::Serialize($Obj))\r\n($x = ((get-member -InputObject $dsObj)[0].TypeName)) | write-warning\r\n\r\n$wk1 = start-job -Name 'UsingExample\\Worker1' -InitializationScript $JobDef -ScriptBlock {\r\n#   [MyObjectDeserializer]::DSTypeName = $using:LocalDSTypeName\r\n#   Update-TypeData -TypeName $using:LocalDSTypeName -TargetTypeForDeserialization MyObject\r\n   \r\n   write-host \"`nJob: Expected implicit cast by auto-deserialization rehydration\" -ForegroundColor Magenta\r\n   $o = $using:obj # <--- Why doesn't it Auto-Rehydrate? Yay, if finally works\r\n   $o.PSTypeNames | out-string | write-host\r\n   #$o.inc()\r\n   \r\n   write-host \"`nJob: Explicit cast to [MyObject]\" -ForegroundColor Magenta\r\n   $o = [MyObject]$o\r\n   $o.inc()\r\n   \r\n   write-host \"`nJob: localized explicit rehydration\" -ForegroundColor Magenta\r\n   $oo = [MyObject]::new()\r\n   $dsoo = $psz::Deserialize($psz::Serialize($oo))\r\n   $dsoo.PSTypeNames | out-string | write-host\r\n\r\n   $o.Value\r\n}\r\nwait-job -job $wk1 -Timeout 60\r\nreceive-job $wk1\r\nremove-job $wk1\r\n\r\n\r\n<#\r\n$s = new-pssession 'server'\r\ninvoke-command -Session $s -ScriptBlock $def\r\ninvoke-command -Session $s -ScriptBlock {\r\n   \"hello from ${Env:ComputerName}, I got $()\"\r\n} -\r\n#>\r\n```",
      "created_at": "2021-03-10T18:29:24Z",
      "updated_at": "2021-03-10T18:29:24Z"
    },
    {
      "author": "White328",
      "author_association": "NONE",
      "body": " what is the meaning of stream of bytes?\nPlease explain a bit.",
      "created_at": "2021-03-10T18:41:09Z",
      "updated_at": "2021-03-10T18:41:09Z"
    },
    {
      "author": "Kagre",
      "author_association": "NONE",
      "body": "> what is the meaning of stream of bytes?\r\n> Please explain a bit.\r\n\r\nwhere are you seeing a \"stream of bytes\"?",
      "created_at": "2021-03-10T18:51:07Z",
      "updated_at": "2021-03-10T18:51:07Z"
    },
    {
      "author": "Kagre",
      "author_association": "NONE",
      "body": "> re-rehydration(bihydration?) of a job's returned deserialized object\r\n\r\nbyedration ",
      "created_at": "2021-03-10T23:20:14Z",
      "updated_at": "2021-03-10T23:20:14Z"
    }
  ],
  "created_at": "2017-02-20T00:45:08Z",
  "number": 3173,
  "state": "open",
  "title": "How do we customize serialization?",
  "updated_at": "2021-03-10T23:20:14Z"
}