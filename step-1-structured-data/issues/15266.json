{
  "_url": "https://github.com/PowerShell/PowerShell/issues/15266",
  "author": "Stroniax",
  "body": "## Summary of the new feature/enhancement\r\n\r\nI have in multiple situations wished for a way to create an attribute that was able to provide validation _and_ completion, or validation _and_ transformation, so that an attribute is able to provide more than one functionality in conjunction, and prevent me from needing to define a set of 2-3 attributes every time I define a specific parameter.\r\n\r\nBecause argument completion, argument validation, and argument transformation are currently provided by three separate base attributes that must be derived to acquire any functionality, the following statements are true:\r\n1. We cannot define a \"standard\" completion for a specific parameter type.\r\n2. We cannot require any two attributes to be provided in conjunction with another.\r\n3. We cannot derive from an existing attribute to provide PowerShell validation functionality (such as an existing validation attribute derived from `System.ComponentModel.DataAnnotations.ValidationAttribute`).\r\n\r\n<!-- \r\nA clear and concise description of what the problem is that the new feature would solve.\r\nTry formulating it in user story style (if applicable):\r\n'As a user I want X so that Y.' with X being the being the action and Y being the value of the action.\r\n-->\r\n\r\n## Proposed technical implementation details (optional)\r\n\r\nI propose that the current validation, transformation, and completion attributes are functionally replaced with interfaces, where the existing attributes are modified to be a base implementation of the interfaces. This would allow an attribute to perform completion and validation, or transformation and then validation, etc.. \r\n\r\nIdeally, these interfaces would provide additional details for the implementation. This is what I have envisioned:\r\n\r\n```\r\nnamespace System.Management.Automation {\r\n\r\n    /// <summary>\r\n    /// Defines methods used for validating an argument passed to a parameter, variable, or property.\r\n    /// If this is implemented by a type that also implements <see cref=\"IArgumentTransformation\"/>,\r\n    /// transformation will be invoked before validation.\r\n    /// <para>\r\n    /// Note that the System.ComponentModel.DataAnnotations.ValidationAttribute and derived classes \r\n    /// may also be used for argument validation without inheriting this method. If this interface \r\n    /// is implemented by a class derived from the ValidationAttribute, both validation methods will\r\n    /// be invoked, beginning with <see cref=\"ValidateArgument\"/>.\r\n    /// </para>\r\n    /// </summary>\r\n    internal interface IArgumentValidation\r\n    {\r\n        /// <summary>\r\n        /// <see langword=\"true\"/> indicates that each parameter, if enumerable, should be provided separately\r\n        /// to <see cref=\"ValidateArgument\"/>. <see langword=\"false\"/> indicates that the entire value provided\r\n        /// to the parameter should be passed to <see cref=\"ValidateArgument\"/> as a single object.\r\n        /// </summary>\r\n        bool ProcessEnumeratedArgumentsSeparately { get; }\r\n        /// <summary>\r\n        /// Performs validation on an argument. This method should throw an exception\r\n        /// when an input value is invalid for the given parameter.\r\n        /// <para><paramref name=\"command\"/> and <paramref name=\"parameter\"/> may be null\r\n        /// if this validation is not being invoked during parameter binding.</para>\r\n        /// </summary>\r\n        /// <param name=\"argument\">The argument provided to the instance being monitored.</param>\r\n        /// <param name=\"engineIntrinsics\"><inheritdoc cref=\"EngineIntrinsics\" path=\"/summary\"/></param>\r\n        void ValidateArgument(object argument,\r\n            EngineIntrinsics engineIntrinsics,\r\n            CommandAst? command,\r\n            ParameterAst? parameter\r\n            );\r\n    }\r\n    /// <summary>\r\n    /// Defines methods used for transforming an argument from one type to another.\r\n    /// If this is implemented by a type that also implements <see cref=\"IArgumentValidation\"/>,\r\n    /// this contract's implementation will be invoked first on any arguments before\r\n    /// they are validated.\r\n    /// </summary>\r\n    internal interface IArgumentTransformation\r\n    {\r\n        /// <inheritdoc cref=\"IArgumentValidation.ProcessEnumeratedArgumentsSeparately\"/>\r\n        bool ProcessEnumeratedArgumentsSeparately { get; }\r\n        /// <summary>\r\n        /// Provides transformation on an argument. This method should return a value\r\n        /// that can be assigned to the parameter - such as an instance of the type\r\n        /// defined by <see cref=\"ParameterAst.StaticType\"/>.\r\n        /// <para><paramref name=\"command\"/> and <paramref name=\"parameter\"/> may be null\r\n        /// if this transformation is not being invoked during parameter binding.</para>\r\n        /// </summary>\r\n        /// <param name=\"argument\">The argument provided to the instance being monitored.</param>\r\n        /// <param name=\"parameter\">The type required by the parameter.</param>\r\n        /// <param name=\"engineIntrinsics\"><inheritdoc cref=\"EngineIntrinsics\" path=\"/summary\"/></param>\r\n        /// <returns></returns>\r\n        object TransformArgument(object argument,\r\n            EngineIntrinsics engineIntrinsics,\r\n            CommandAst? command,\r\n            ParameterAst? parameter);\r\n    }\r\n    /// <summary>\r\n    /// Defines methods used for offering argument completion, such as when a user types in\r\n    /// a partial parameter value and presses the \"Tab\", \"Ctrl + ,\" or other key binding\r\n    /// to complete an argument for a given parameter.\r\n    /// <para>\r\n    /// </summary>\r\n    internal interface IArgumentCompletion\r\n    {\r\n        uint? MinimumCachedCompletionCount { get; }\r\n        /// <summary>\r\n        /// Offers argument completion suggestions. This method should not throw any exception \r\n        /// (exceptions will be ignored). Values are only requested when argument completion is\r\n        /// requested. The first returned value will be suggested immediatly; as many as\r\n        /// <see cref=\"MinimumCachedCompletionCount\"/> values will be cached asynchronously so\r\n        /// that the next completion requested is ready, without loading all completions before\r\n        /// any values are suggested.\r\n        /// </summary>\r\n        /// <param name=\"argument\">The value defined when completion was requested.</param>\r\n        /// <param name=\"engineIntrinsics\"><inheritdoc cref=\"EngineIntrinsics\" path=\"/summary\"/></param>\r\n        /// <param name=\"commandName\">The name of the command for which completion was requested.</param>\r\n        /// <param name=\"parameterName\">The name of the parameter for which completion was requested.</param>\r\n        /// <param name=\"commandAst\"><inheritdoc cref=\"CommandAst\" path=\"/summary\"/></param>\r\n        /// <param name=\"fakeBoundParameters\">Current values bound to the command.</param>\r\n        /// <returns></returns>\r\n        IEnumerable<CompletionResult> CompleteArgument(\r\n            string? argument,\r\n            string commandName,\r\n            string parameterName,\r\n            CommandAst commandAst,\r\n            IDictionary<string, object?> fakeBoundParameters,\r\n            EngineIntrinsics engineIntrinsics);\r\n    }\r\n}\r\n```\r\nAt run time, instead of looking for if `typeof(ValidateArgumentsAttribute).IsAssignableFrom(type)` a check could be made for if `typeof(IArgumentValidation).IsAssignableFrom(type)`. All transformations would occur before any validations.\r\n\r\nThis would allow any attribute to provide multiple of these functionalities. The following example could simultaneously provide transformation, validation, and completion for a parameter that requires an IPv4 instance of `System.Net.IPAddress`.\r\n\r\n```\r\npublic class IPv4Attribute : Attribute, IArgumentTransformation, IArgumentValidation, IArgumentCompletion\r\n{\r\n    public bool ProcessEnumeratedArgumentsSeparately => true;\r\n    public IPAddress? InitialCompletionIfNull { get; }\r\n    public IPv4Attribute() {}\r\n    public IPv4Attribute(string initialCompletionIfNull)\r\n    {\r\n      if (IPAddress.TryParse(initialCompletionIfNull, out var ip) && ip.AddressFamily == AddressFamily.InterNetwork)\r\n      {\r\n        InitialCompletionIfNull = ip;\r\n      }\r\n      else\r\n      {\r\n         throw new ArgumentException(\"The IP address was invalid or not an IPv4 address.\", nameof(initialCompletionIfNull));\r\n      }\r\n    }\r\n\r\n    public IEnumerable<CompletionResult> CompleteArgument(string wordToComplete, string commandName, string parameterName, EngineIntrinsics engineIntrinsics, CommandAst commandAst, IDictionary<string, object?> fakeBoundParameters)\r\n    {\r\n        IPAddress ip = IPAddressHelper.ParsePartialAddress(new WildcardPattern(wordToComplete + \"*\", startingAddress: InitialCompletionIfNull), AddressFamily.InterNetwork);\r\n        IEnumerable<CompletionResult> results = IPAddressHelper.OfferNext(ip, 100, AddressFamily.InterNetwork);\r\n        return results;\r\n    }\r\n\r\n    public object TransformArgument(object argument, Type parameterType, EngineIntrinsics engineIntrinsics)\r\n    {\r\n        IPAddress ip;\r\n        if (argument is IPAddress)\r\n        {\r\n            ip = (IPAddress)argument;\r\n            try\r\n            {\r\n                return ToType(ip.MapToIPv4(), parameterType);\r\n            }\r\n            catch\r\n            {\r\n                return ToType(argument, parameterType);\r\n            }\r\n        }\r\n        else if (LanguagePrimitives.TryConvertTo<long>(argument, out var ipLong))\r\n        {\r\n            var octets = new byte[4];\r\n            octets[0] = (byte)Math.Truncate((double)ipLong / 16777216);\r\n            octets[1] = (byte)Math.Truncate((double)ipLong % 16777216 / 65536);\r\n            octets[2] = (byte)Math.Truncate((double)ipLong % 65536 / 256);\r\n            octets[3] = (byte)Math.Truncate((double)ipLong % 256);\r\n            return ToType(new IPAddress(octets), parameterType);\r\n        }\r\n        else if (IPAddress.TryParse(argument.ToString(), out ip))\r\n        {\r\n            try\r\n            {\r\n                return ToType(ip.MapToIPv4(), parameterType);\r\n            }\r\n            catch\r\n            {\r\n                return ToType(ip, parameterType);\r\n            }\r\n        }\r\n        else if (LanguagePrimitives.TryConvertTo(argument, out ip))\r\n        {\r\n            return ToType(ip, parameterType);\r\n        }\r\n        else\r\n        {\r\n            return argument;\r\n        }\r\n    }\r\n    /// <summary>\r\n    /// May convert an instance to <paramref name=\"resultType\"/>.\r\n    /// </summary>\r\n    /// <param name=\"argument\"></param>\r\n    /// <param name=\"resultType\"></param>\r\n    /// <returns></returns>\r\n    private object ToType(object argument, Type resultType)\r\n    {\r\n        if (LanguagePrimitives.TryConvertTo(argument, resultType, out var result)) {\r\n            return result;\r\n        }\r\n        else\r\n        {\r\n            return argument;\r\n        }\r\n    }\r\n\r\n    public void ValidateArgument(object argument, EngineIntrinsics engineIntrinsics)\r\n    {\r\n        IPAddress ip;\r\n        if (argument is IPAddress isIp)\r\n        {\r\n            ip = isIp;\r\n        }\r\n        else if (IPAddress.TryParse(argument.ToString(), out var parsedIp))\r\n        {\r\n            ip = parsedIp;\r\n        }\r\n        else\r\n        {\r\n            throw new ValidationMetadataException($\"The value {argument} is not an IP address.\");\r\n        }\r\n        if (ip.AddressFamily != System.Net.Sockets.AddressFamily.InterNetwork)\r\n        {\r\n            throw new ValidationMetadataException($\"The value {ip} is not an IPv4 address (the address family is {ip.AddressFamily}).\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n<!-- \r\nA clear and concise description of what you want to happen.\r\nConsider providing an example PowerShell experience with expected result.\r\n-->\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "We discussed this in the Engine Working Group, and we don't see any reason against the proposed API and that it's a proposal in the right direction.\r\n\r\nWe think more discussion should be had in this issue around:\r\n\r\n- The demand for such an API (is it worth the complexity or the maintenance burden?)\r\n- Whether the shape of the API is right (does it fit all use cases we imagine? how easy is it to use incorrectly? are there possibly simpler alternatives? could we envisage making a breaking change in this?) (in particular the use of interfaces on attributes is less conventional in C# and it might be worth exploring or suggesting an alternate implementation)\r\n\r\nEssentially this is a fairly large proposed API and we need to stress test the proposal somewhat, in the form of things like counter proposals, exploration of invalid configurations or implementations, a look at performance implications, etc.\r\n\r\nOnce some discussion is had here, we can then discuss a prototype, RFC, and/or PR.",
      "created_at": "2021-06-10T23:57:55Z",
      "updated_at": "2021-06-10T23:57:55Z"
    }
  ],
  "created_at": "2021-04-19T03:54:20Z",
  "labels": [
    "Issue-Enhancement",
    "WG-Engine"
  ],
  "number": 15266,
  "state": "open",
  "title": "Completion, Validation, Transformation as Interfaces",
  "updated_at": "2021-06-23T22:36:54Z"
}