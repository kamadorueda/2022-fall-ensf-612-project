{
  "_url": "https://github.com/PowerShell/PowerShell/issues/2226",
  "author": "vors",
  "body": "Copied from TFS item 819298\n\nOriginal Connect item: https://connect.microsoft.com/PowerShell/feedback/details/635454/add-support-for-linq\n\n> When LINQ is available, it can push queries into the native language of the underlying storage without requiring users to learn that query language.  This transformation can speed up queries to perform hundreds times faster, and when the alternative is to ship large amounts of data over the wire to be filtered locally, thousands of times faster.\n> \n> In many cases using LINQ can convert a script which ran so slow as to be infeasible into scripts that we can run every day, and in fact, can run whenever we like -- and it also drastically reduces CPU impact.\n> \n> For a trivial example, see this post on Stack Overflow http://stackoverflow.com/questions/4559233/technique-for-selectively-formatting-data-in-a-powershell-pipeline-and-output-as where the switch to using LINQ (by embedded the LINQ into a C# function via Add-Type and calling it from PowerShell) provided 1000 times speedup.  It's currently not possible to write that LINQ query at all in pure PowerShell, and the alternative (as it was written in the other answer on that StackOverflow question, using Where-Object) is extremely slow even on modest data sets.\n> \n> The bottom line is that the Where-Object and Select-Object cmdlets are very slow, and using them to query databases, and other remote systems results in not only the slowdown of processing thousands of items in a Where-Object, but potentially sending them all over the wire as well.  \n> \n> Since LINQ to events is becoming available through the Rx project, it's more useful, and more important than ever, and we really need a way to write LINQ natively in PowerShell.\n",
  "closed_at": null,
  "comments": [
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "Oh please, oh please, oh please ... :wink: \n",
      "created_at": "2016-09-19T22:10:09Z",
      "updated_at": "2016-09-19T22:10:09Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "(@powercode you'll probably be interested in this discussion).\r\n\r\nSome random thoughts on what implications LINQ/extension methods have for PowerShell...\r\n\r\n@Jaykul I added an updated answer to your [answer](http://stackoverflow.com/questions/4559233/technique-for-selectively-formatting-data-in-a-powershell-pipeline-and-output-as) on StackOverflow that replaces all the pipeline use with `.where()`. This removes the last usage of the pipeline from the code. The result is pretty fast.\r\n\r\n@vors The example that @Jaykul provided used `XLinq` which is perfectly usable from PowerShell as it stands. (XLinq isn't \"really\" LINQ anyway, it's just an alternative model for manipulating XML).\r\n\r\nTo see what the experience might be like, I've been playing with wrapping the `[Linq.Enumerable]` methods in `ScriptMethods` so I can write things like:\r\n```PowerShell\r\n# Find processes with the most threads on this machine\r\n(Get-Process).select{\r\n    param($p) \r\n    [pscustomobject] @{\r\n        Name=$p.Name; \r\n        Id=$p.Id; \r\n        Threads=$p.Threads.Count}}.\r\n            OrderByDescending{param ($p) $p.threads}.\r\n                Take(10)\r\n``` \r\nThe result is usually somewhat to much faster than the pipeline, even without lazy evaluation and a lot of copying. But it's also rather more complex to use.  Now, while I am personally fond of this sort of thing, is this the experience we want to provide? For example, @mklement0 seems adamantly opposed to pushing methods as a first-class experience.  So perhaps we should have a real language experience like `from $x where $_ .Size -gt 10 select ...`. Or a set of cmdlets that built up the query. Or even automatically rewrite parts of the pipeline into LINQ queries to make regular Where/Select/etc. automatically faster. Also note that there is a [LINQ for PowerShell](https://www.powershellgallery.com/packages/LINQ/4.0) module on the gallery. It's incomplete and hasn't been updated in a couple of years (only has 1200 downloads) so maybe people really aren't that keen on LINQ in PowerShell after all.\r\n\r\nAnd finally, what are the core scenarios for doing this? Is it just to be faster (a good thing)? Or is there specific functionality that you want to unlock. What about LINQ-to-SQL? We have classes now. Is this something we should invest in?\r\n",
      "created_at": "2018-04-30T03:32:57Z",
      "updated_at": "2018-04-30T03:32:57Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "Another \"stunt-query\" that gets the 10 most common words from the text of \"War and Peace\". It uses a few extra operators I created (split(), trim() and match()) that aren't standard query operators.\r\n```powershell\r\n$h=@{}\r\n[io.file]::ReadAllLines(\"c:\\temp\\WarAndPeace.txt\").\r\n    trim().\r\n        split().\r\n            match('^[a-z]+$').\r\n                aggregate{param ($x, $y) \r\n                    if ($x -isnot [hashtable]) { $h[$x]++; $x = $h } $x[$y]++; $x }.\r\n                        select{param ($t) \r\n                            @($t.GetEnumerator()).\r\n                                select{ param ($w)\r\n                                    [pscustomobject] @{\r\n                                        Word = $w.Key; \r\n                                        Count = $w.Value}}.\r\n                                            OrderByDescending{$args[0].Count}.\r\n                                                Take(10)} \r\n```",
      "created_at": "2018-04-30T05:36:59Z",
      "updated_at": "2018-04-30T05:36:59Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> So perhaps we should have a real language experience like `from $x where $_ .Size -gt 10 select ....`\r\n\r\nTo quote @Jaykul: Oh please, oh please, oh please ... \r\n\r\nThe query-like syntax fits better with the rest of PowerShell - a \"whitespacey\" experience that doesn't cause the confusion with argument mode that method syntax entails (though it's still an embedded language users will have to learn).\r\n\r\n\r\n> rewrite parts of the pipeline into LINQ queries to make regular Where/Select/etc. automatically faster. \r\n\r\nIs that feasible? Certainly would be great.\r\n\r\n> And finally, what are the core scenarios for doing this?\r\n\r\nAs you say, a performance gain alone would be useful, but LINQ is such a wonderfully expressive, general-purpose feature that I can see its utility in a wide range of scenarios, including LINQ-to-SQL.\r\n\r\n",
      "created_at": "2018-04-30T13:33:57Z",
      "updated_at": "2018-04-30T13:33:57Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "> the confusion with argument mode that method syntax entails \r\n\r\nI'm confused :-) What confusion? Method syntax is *all* expression mode. Every bit of the query I wrote above is in expression mode.\r\n\r\n> As you say, a performance gain alone would be useful, \r\n\r\nPlaying with this a bit more, I see that there will be a bound on how much faster we can get. LINQ query operators depend heavily on lambdas or, for us, scriptblocks, So the overhead of invoking a scriptblock will be a limiting factor on how fast we can get. (Perhaps things like [PSLambda](https://github.com/SeeminglyScience/PSLambda) could help though at the risk of introducing another syntax mode. )\r\n",
      "created_at": "2018-04-30T20:45:43Z",
      "updated_at": "2018-04-30T20:45:43Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "That's good to know; the PSLambda project sounds interesting; unless a solely method-based approach is chosen (see below), another syntax mode sounds unavoidable, though ideally it would feel like a variant of the existing (main) ones (argument mode and operators).\r\n\r\n> I'm confused :-) Method syntax is _all_ expression mode.\r\n> Every bit of the query I wrote above is in expression mode.\r\n\r\nAnd my head is still spinning.\r\n\r\nTo recap previous arguments:\r\n\r\nMethod syntax invites confusion with PowerShell's shell-like argument [parsing] mode (notwithstanding the fact that the _option_ of using method syntax on .NET types directly is a great _extensibility_ feature):\r\n\r\nFrom the perspective of a shell user mostly familiar with command syntax (argument mode), the tricky differences are:\r\n\r\n* parentheses are required (vs. whitespace in argument mode)\r\n* arguments must be `,`-separated (vs. whitespace in argument mode, where `,` constructs _arrays_)\r\n* bareword arguments (unquoted strings) aren't allowed\r\n\r\nWith the exception of the - little-known and little-used - `.Where()` and `.ForEach` collection \"operators\" (see https://github.com/PowerShell/PowerShell-RFC/pull/126 for how to make them more PowerShell-like), PowerShell's _own_, core functionality relies only on _cmdlets / functions_ (argument mode) and _operators_ (expression mode, but _resembling_ argument mode), and my vote is to keep it that way.\r\n",
      "created_at": "2018-04-30T21:22:08Z",
      "updated_at": "2018-04-30T21:22:08Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 \r\n> PowerShell's own, core functionality relies **only** on cmdlets / functions (argument mode)\r\n\r\nI really don't understand where you got this idea from. It has _never_ been the case that we relied only on cmdlets. There just wasn't enough time to cover all the scenarios (simple example:  getting the substring of a string.) We targeted the _most common_ scenarios with cmdlets because they gave the best user experience and then depended on .NET to back fill what remained.\r\n\r\n> and operators (expression mode, but resembling argument mode), \r\n\r\nWhat do you mean by \"resembling\" here? They are distinct modes: barewords are allowed in argument mode but not in expression mode. Operators are allowed in expression mode but not in argument mode. They both allow simple expressions (including method calls) so I suppose that's a resemblance.  Method calls are part of expression mode and I can't say I've ever seen someone try to use a method like a command but I've seem a lot of instances where command invocations are written like method calls (and subsequently don't work).\r\n",
      "created_at": "2018-05-01T17:40:14Z",
      "updated_at": "2018-05-01T17:40:14Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@BrucePay:\r\n\r\n> I really don't understand where you got this idea from.\r\n\r\nTo be clear: only _you_ can provide behind-the-scenes glimpses - both historical and present - and I always appreciate them.\r\n\r\nBy contrast, I can only talk about de-facto behavior and _guess_ at design intent in cases where it it isn't documented.\r\n\r\n---\r\n\r\n> It has never been the case that we relied only on cmdlets.\r\n\r\n_De facto_, virtually all of PowerShell's _own_ functionality is provided by cmdlets and operators (with the exception of the useful, but little-known and little-used `.ForEach()` and `.Where()` collection \"operator\" methods that [I wish had true operator representation](https://github.com/PowerShell/PowerShell-RFC/pull/126).)\r\n\r\n_Whether it was the original intent or not_, the following de-facto separation makes sense and is worth keeping:\r\n\r\n* Cover _basic_ needs with PowerShell's _own_ constructs - cmdlets and operators - whose syntax - while spanning two distinct parsing modes - doesn't _clash_:\r\n\r\n   * _Cmdlets_ return are high-level, shell-syntax-friendly analogs to OO methods (loosely speaking).\r\n   * Objects returned by them are _typically_ treated as \"property bags\" in basic command-line/scripting scenarios, meaning that only _property_ access is needed.\r\n   * Objects and their properties can be acted on with _operators_ in the context of expressions, without causing _fundamental_ confusion (see below).\r\n\r\n* For _advanced_ needs, provide full access to the .NET framework is _available_, which is a wonderful _option_ to have and sets PowerShell apart from traditional shells; however, this option comes at a cost:\r\n\r\n   * You need to know more about the underlying .NET types and what methods they expose.\r\n        * While `Get-Member` helps in discovering method _signatures_, with respect to getting _help_ you're on your own (whereas the purpose of _properties_ is usually self-evident).\r\n\r\n   * You need to know the subtleties of parameter binding when calling .NET methods directly.\r\n\r\n   * Last not least, you need to be aware of how method syntax differs from command syntax.\r\n\r\n**It therefore makes sense to limit introduction of new PowerShell-native features to cmdlets and operators.**\r\n\r\n> simple example: getting the substring of a string.\r\n\r\nGetting a substring via the `.Substring()` _method_ is actually a good example of something that is _rarely_ needed: due to PowerShell's OO nature and its excellent regex support via `-split`, `-match`, and `-regex` you typically do _not_ need to deal with `.Substring()`.\r\n\r\n---\r\n\r\n> What do you mean by \"resembling\" here? \r\n\r\nUnderstanding PowerShell's two fundamental parsing modes - argument mode vs. expression mode - is a challenge any PowerShell user faces, but it's the unavoidable price to pay for a shell that also offers the constructs of a  \"real\" programming language (again, kudos to PowerShell).\r\n\r\nSo, yes, operators belong to the real of _expressions_, where string literals cannot be barewords (unquoted), for instance.\r\n\r\nAside from that, however, operators being separated from their operands by _whitespace_ (rather than `(...)` and `,` - though `,` has a role in some operators too) is what I meant by \"resembling\" argument mode.  \r\nA negative way of phrasing it: Using literals (quoting need aside) and variable access - including _property_ access on variables - _doesn't clash_ with argument-mode syntax the way that _method_ calls do.\r\n\r\n```powershell\r\n$arr = 'Call', 'me',  'Ishmael'\r\n\r\n# Operator syntax - reminiscent of argument mode (whitespace as separator, no (...))\r\n$arr -join ' '\r\n\r\n# Method syntax - uses (...) and \",\" - both of which function differently in argument mode.\r\n[string]::Join(' ', $arr)\r\n```\r\n\r\n> I've seem a lot of instances where command invocations are written like method calls (and subsequently don't work).\r\n\r\nIndeed, and that's why introducing method calls for basic PowerShell functionality is problematic:\r\n\r\n* In the most benign case, you can _get away_ with confusing the parsing modes, but the underlying misconception may come back to bite you later:\r\n\r\n```powershell\r\n# The web is full of examples of confused syntax like this:\r\nNew-Object Foo.Bar($arg1, $arg2) # should be: New-Object Foo.Bar [-ArgumentList] $arg1, $arg2\r\n```\r\n\r\n* The introduction of `Set-StrictMode -Version 2` is living proof that the confusion is real:\r\n\r\n```powershell\r\nfunction foo { param($bar, $baz) \"[$bar], [$baz]\" }\r\nfoo(1, 2) # binds *array* 1, 2 to $bar only - BREAKS with Set-StrictMode -Version 2 or higher.\r\n```\r\n\r\n* On a related note, the PSv3 introduction of argument-mode-syntax comparison statements / operation statements to `Where-Object`  / `ForEach-Object` is a nod to how argument-mode syntax is easier to type and read.\r\n\r\n",
      "created_at": "2018-05-02T21:49:11Z",
      "updated_at": "2018-05-07T21:08:33Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 \r\n> De facto, virtually all of PowerShell's own functionality is provided by cmdlets and operators \r\n\r\nExcept for little things like the _entire language_ (statements, etc.). And types (casts). And the ability to call methods. If we hadn't wanted people to use methods we wouldn't have implemented the feature. And we did think a lot about the feature before adding it. The intended experience is not binary, it's a continuum. As you grow with experience, your abilities will also grow. To quote Jeffrey, PowerShell has an extremely wide dynamic range.\r\n\r\nBTW: when I say _types_, I'm talking about things like this extremely old joke:\r\n```\r\n-join [char[]] ([int[]] [char[]] 'hal'| foreach {$_+1})\r\n```\r\n\r\n> substring ... a good example of something that is rarely needed: \r\n\r\nHmmm ... I get 2.9 million hits for \"powershell substring\". Unfortunately. But you're right - we should have cmdlets for basic data manipulation . Please support  @FriedrichWeinmann's  issue [Commands for string methods & operators on the pipeline](https://github.com/PowerShell/PowerShell/issues/6697)\r\n\r\nYour example\r\n```\r\n$arr = 'Call', 'me',  'Ishmael'\r\n```\r\nis all expression mode; whitespace is unnecessary as in\r\n```\r\n$arr-join' '\r\n```\r\nAnd finally\r\n```\r\n($arr -join ' ').Count\r\n[string]::Join(' ', $arr).Count\r\n```\r\nAll in expression mode, parens are required around both to get the count.\r\n\r\n> Indeed, and that's why introducing method calls for basic PowerShell functionality is problematic:\r\n\r\nNo, that's not problem. The people who make these mistakes are invariably programmers who are used to methods in other languages and try to write PowerShell like it was C# (or whatever). They may not even be aware that PowerShell also has methods.\r\n\r\n(You know, it just occurred to me how ironic it is to be having a discussion about how methods are _bad_ in an issue proposing the addition of extension methods.:-))",
      "created_at": "2018-05-02T23:57:58Z",
      "updated_at": "2018-05-02T23:57:58Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@BrucePay:\r\n\r\n> Except for little things like the entire language (statements, etc.). And types (casts). \r\n\r\nYes, I didn't mention the language constructs explicitly, but I did say this:\r\n\r\n> Understanding PowerShell's two fundamental parsing modes - argument mode vs. expression mode - is a challenge any PowerShell user faces, but it's the unavoidable price to pay for a shell that also offers the constructs of a \"real\" programming language.\r\n\r\nThis should tell you that my concern is not about expression mode / control-flow statement syntax _per se_ - on the contrary.\r\n\r\nAnd:\r\n\r\n> For advanced needs, provide full access to the .NET framework is available, which is a wonderful option to have and sets PowerShell apart from traditional shells; however, this option comes at a cost:\r\n\r\nThis should tell you that your saying \"If we hadn't wanted people to use methods\" is refuting a point that I never made.\r\n\r\n> it's a continuum\r\n\r\nWith methods, it is not, for the reasons stated (syntax confusion, parameter-binding pitfalls, separate knowledge domain).\r\nBut - again - it's a is wonderful _advanced_ option to have.\r\n\r\n> Please support @FriedrichWeinmann's issue Commands for string methods & operators on the pipeline\r\n\r\nLooks like a great idea (I'd already up-voted it).\r\n\r\n> BTW: when I say _types_, I'm talking about things like this extremely old joke:\r\n\r\nI get the joke, but I don't know what you mean re types.\r\n\r\n> Your example `$arr = 'Call', 'me',  'Ishmael'` is all expression mode; whitespace is unnecessary\r\n\r\nJust to drive the point home: my arguments were never about _expression mode_ per se. They were about _method syntax_ and the additional domain of knowledge you enter when using them (and, again, that is a wonderful _advanced_ option).\r\n\r\nYes, you _can_ omit whitespace (as you can _in part_ in argument mode, `Get-Item /|select name`), but I hope we can agree that it is ill-advised, because the easy readability of of commands an operator-based expression comes from using whitespace).\r\n\r\n> The people who make these mistakes are invariably programmers who are used to methods in other languages and try to write PowerShell like it was C# (or whatever). \r\n\r\nIndeed, you can use PowerShell entirely as if it were C# - virtually all the tools are there. You can get away without ever calling a cmdlet or use PowerShell's (unique to it) operators.\r\nBut I hope it is self-evident that that wouldn't be a good idea and that there's a PowerShell way to do things, and if that PowerShell way functions _consistently_ with _the fewer concepts to master the better_, learning it is easier.\r\n\r\nFor someone who doesn't come from a programming background, argument mode (command-line syntax) and expression mode _with properties_ is a manageable entry point, with an _option_ to _later_ branch out into the method world, as needed.\r\n\r\n> They may not even be aware that PowerShell also has methods.\r\n\r\nWith the exception of `.Where()` and `.ForEach()`, PowerShell _itself_ has no user-facing methods that I am aware of (I'm not talking about the API), and my suggestions is that we keep it that way for a clean separation between PowerShell's own core functionality and the realm of .NET in general, which avoids conceptual and syntax challenges especially for _beginners_.\r\n\r\nFor people who _want and need_ method calls, the door is wide open and - have I mentioned this before? - it is a great option to have.\r\n\r\n> (You know, it just occurred to me how ironic it is to be having a discussion about how methods are bad in an issue proposing the addition of extension methods.:-))\r\n\r\nLet me know if you still feel that I've ever made the point that \"methods are bad\".\r\n\r\nThere's also no need to _choose_ in this particular case; just like C#, we could provide _method syntax _and_ query syntax.\r\n\r\nIn the case of method syntax, however, to the user this would be just another door into the realm of the underlying .NET world (no matter how much work is needed behind the scenes to \"pass the functionality through\").\r\n\r\nBy contrast, query syntax, such as your `from $x where $_ .Size -gt 10 select ...` example, with its whitespace-based token separation and absence of parentheses and lambdas, feels like a more natural PowerShell fit to me.\r\n\r\nOn a meta note: I feel that a lot of effort in this debate was spent on not discussing the actual points that I made. Were there specific ways in which I presented my arguments that obscured their intent?\r\n\r\n\r\n\r\n",
      "created_at": "2018-05-03T12:14:47Z",
      "updated_at": "2018-05-07T21:09:50Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "@SteveL-MSFT We definitely need an RFC with detailed design for this, if only because the standard query operator `Where()` collides with out existing `Where()` method. There's also lazy vs strict semantics to consider, fat-arrow lambdas and I'm sure a bunch of other things I can't think of right now.",
      "created_at": "2018-05-05T06:15:14Z",
      "updated_at": "2018-05-05T06:15:14Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "@BrucePay - if the existing `Where` method turns into a proper extension method, then overload resolution should avoid any issues with the LINQ method because the identity conversion on the first argument (a scriptblock) would be better than the conversion from scriptblock to delegate.",
      "created_at": "2018-05-08T00:27:31Z",
      "updated_at": "2018-05-08T00:27:31Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "Do you think we should have special syntax for finding extension methods?\r\n\r\nlike \r\n``` \r\nusing extensionsfrom \"System.Linq.Enumerable, System.Linq\"\r\n```\r\n\r\nOr reuse the existing like \r\n```\r\nusing assembly System.Linq\r\n```\r\n\r\nI strongly believe we should only get extension methods statically, i.e. what is available at parse time, not by finding the best match at runtime.\r\n",
      "created_at": "2018-05-14T16:08:27Z",
      "updated_at": "2018-05-14T16:08:27Z"
    },
    {
      "author": "vors",
      "author_association": "COLLABORATOR",
      "body": "I think `using assembly System.Linq` is sufficient and consistent with C#.",
      "created_at": "2018-05-19T16:14:16Z",
      "updated_at": "2018-05-19T16:14:16Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "I'd like to just side-step @mklement0's opinions about members. PowerShell is an _object oriented_ .NET programming language. Properties and Methods are a _**core** part of OOP_ and PowerShell's ETS system is all about adding more of them -- the idea that Methods are somehow \"un\" PowerShell is preposterous.\r\n\r\nSo, for the record ...\r\n\r\nI think it would be wonderful to have LINQ Query syntax. \r\n\r\nI also think it would be awesome to have pipeline syntax that was optimized against LINQ extensions. Do you remember the stuff that Bart de Smet wrote while trying to make \"Rx\" work for PowerShell pipelines? It was complicated to work with, but exposed awesome functionality!\r\n\r\nBut it should be **clear** that although query syntax may have been the original reason for adding extension methods to the .NET Framework, the reality is that extension methods are used **extensively** throughout every type of library and API. The whole \"fluent programming\" fad was basically built upon them. We can't avoid exposing extension methods _as methods_ by adding a query syntax: there are lots of extension methods that are really **painful** to call statically, and lots of them require generic type arguments which makes them _basically impossible_ to call...\r\n\r\nP.S.: I think it is a well known truism about PowerShell that Methods vs. Pipeline is a **tradeoff**. The PowerShell pipeline is fluent and expressive, and has the lower _memory usage_ of streaming actions on objects instead of storing the whole collection in memory -- similar to the benefits of LINQ. However, pipelines require cmdlets, which have significant performance overhead -- so despite the benefits of pipelines, chaining methods and `pure language` without cmdlets is nearly always faster, and extension methods (and in particular, LINQ collection methods) will continue that expectation.\r\n",
      "created_at": "2018-05-21T05:13:49Z",
      "updated_at": "2018-05-21T05:13:49Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@Jaykul:\r\n\r\n> I think it would be wonderful to have LINQ Query syntax.\r\n\r\nI'm glad to hear it.\r\n\r\nI too think that exposing LINQ functionality via methods _as well_ is definitely called for:\r\n\r\n* generally, providing access to [LINQ] extension methods more thoroughly fulfills PowerShell's promise of full access to the .NET framework.\r\n\r\n* specifically, certain LINQ features are accessible via method syntax only.\r\n\r\n---\r\n\r\nWe therefore needn't continue the methods-in-PowerShell debate here, so let me try to bring closure to it:\r\n\r\n> PowerShell is an object oriented .NET programming language.\r\n\r\nPowerShell is also a _shell_, and the mix of syntax modes - unavoidable, as discussed - is a challenging thing to master. While the OOP aspect of accessing _properties_ is easy to grasp, _methods_ can cause confusion and present additional challenges (to briefly recap: syntax confusion with command mode, parameter-binding subtleties, introduction of a new knowledge domain).\r\n\r\nAs stated many times before, having the _option_ to take full advantage of .NET types and their methods is unequivocally wonderful and sets PowerShell apart from other shells.  \r\n\r\nThat option, however, is an _advanced_ feature - as is the ETS:\r\n\r\n* Writing your own ETS definitions as an end user is definitely an advanced task (irrespective of whether you use it to implement properties or methods).\r\n\r\n* PowerShell built-in ETS definitions are transparent to the end user and in the vast majority of cases add _properties_, not methods (in fact, if we leave `.ToString()` aside, which users needn't and are unlikely to call directly, the PSv5.1 ETS definitions define only 2 methods overall, for the `Microsoft.Management.Infrastructure.CimInstance#MSFT_*` types: `GetSecurityDescriptor()` and `.SetSecurityDescriptor()`.)\r\n\r\nIn short, the current (largely de-facto) separation - cmdlets and operators for PowerShell's own functionality (API aside), with optional access to the full .NET framework if and as needed for advanced tasks - is useful and worth keeping.\r\n\r\nAs stated, adding support for LINQ falls into the  full-access-to-the-full-.NET-framework category and it just so happens that LINQ's query syntax - to me - fits in better with PowerShell syntax; additionally, adding PowerShell-like syntactic sugar sounds like a worthwhile endeavor (hinted at in @BrucePay's example: `from $x where $_ .Size -gt 10 select ...` vs. `from $obj in $x where $obj.Size -gt 10 select ...`)\r\n\r\n---\r\n\r\nOn a meta note:\r\n\r\nPlease stop calling others' arguments \"preposterous\". It adds nothing to the discussion and only serves to antagonize.\r\n",
      "created_at": "2018-05-21T14:53:34Z",
      "updated_at": "2018-05-21T14:53:34Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee reviewed this and agrees an RFC should be authored",
      "created_at": "2018-05-23T22:13:56Z",
      "updated_at": "2018-05-23T22:13:56Z"
    },
    {
      "author": "fMichaleczek",
      "author_association": "NONE",
      "body": "@Jaykul I found only that link on Bart de Smet's blog [LINQ THROUGH POWERSHELL](http://community.bartdesmet.net/blogs/bart/archive/2008/06/07/linq-through-powershell.aspx)\r\n\r\nAre you speaking about this implementation ?\r\n\r\nI try with an updated Linq.Dynamic https://github.com/StefH/System.Linq.Dynamic.Core\r\n\r\n[Operators List](https://github.com/StefH/System.Linq.Dynamic.Core/wiki/Dynamic-Expressions#operators)\r\n\r\n```\r\n\r\nAdd-Type -AssemblyName System.Data\r\nAdd-Type -AssemblyName System.Data.DataSetExtensions\r\nAdd-Type -AssemblyName System.Data.Linq\r\nAdd-Type -Path \"$pwd\\System.Linq.Dynamic.Core\\1.0.8.9\\lib\\netstandard2.0\\System.Linq.Dynamic.Core.dll\"\r\n\r\n-------------------------------------------------------------------------------------\r\nusing namespace System.Collections\r\nusing namespace System.Data \r\nusing namespace System.Linq \r\nusing namespace System.Linq.Dynamic.Core\r\n\r\n$t1 = [DataTable]::new()\r\n$t1.Columns.AddRange(@(\r\n    [DataColumn]@{ ColumnName = 'FundId' ; DataType = [int] }\r\n    [DataColumn]@{ ColumnName = 'Date'   ; DataType = [datetime] }\r\n    [DataColumn]@{ ColumnName = 'CodeA' ; DataType = [string] }\r\n    [DataColumn]@{ ColumnName = 'Orders' ; DataType = [int32[]] }\r\n))\r\n$t1.Rows.Add(1, [DateTime]::Now, 'A1', [int32[]]@(1) ) > $null\r\n$t1.Rows.Add(2, [DateTime]::Now.AddDays(-365), 'A2', [int32[]]@(1,2,3,4) ) > $null\r\n$t1.Rows.Add(3, [DateTime]::Now.AddHours(-12), 'A3', [int32[]]@(1,2,3) ) > $null\r\n\r\n$sourceTable = [Queryable]::AsQueryable([DataTableExtensions]::AsEnumerable($t1))\r\n\r\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n$sourceTable\r\n\r\nFundId Date                CodeA Orders      \r\n------ ----                ----- ------      \r\n     1 28/05/2018 10:02:51 A1    {1}         \r\n     2 28/05/2017 10:02:51 A2    {1, 2, 3, 4}\r\n     3 27/05/2018 22:02:51 A3    {1, 2, 3}  \r\n\r\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n[DynamicQueryableExtensions]::Where($sourceTable, \"DateTime(Date) >= DateTime(2018, 1, 1)\")\r\n\r\nFundId Date                CodeA Orders   \r\n------ ----                ----- ------   \r\n     1 28/05/2018 10:01:30 A1    {1}      \r\n     3 27/05/2018 22:01:30 A3    {1, 2, 3}\r\n     \r\n     \r\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n[DynamicQueryableExtensions]::Where($sourceTable, \"int32(FundId) > 2\")\r\n\r\nFundId Date                CodeA Orders   \r\n------ ----                ----- ------   \r\n     3 27/05/2018 22:02:51 A3    {1, 2, 3}\r\n     \r\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n[DynamicQueryableExtensions]::Where($sourceTable, 'int32(Orders.Count) >= 3')\r\n\r\nAn error occurred while enumerating through a collection: Target object is not an ExpandoObject.\r\nAt line:2 char:1\r\n+ [DynamicQueryableExtensions]::Where($sourceTable, 'int(Orders.Count)  ...\r\n+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n    + CategoryInfo          : InvalidOperation: (System.Linq.Enu...m.Data.DataRow]:WhereEnumerableIterator`1) [], RuntimeException\r\n    + FullyQualifiedErrorId : BadEnumeration\r\n\r\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n[DynamicQueryableExtensions]::Select($sourceTable, 'new(FundId as Id, Date as LastWriteTime)')\r\n\r\n{ Id = 1, LastWriteTime = 28/05/2018 10:02:51 }\r\n{ Id = 2, LastWriteTime = 28/05/2017 10:02:51 }\r\n{ Id = 3, LastWriteTime = 27/05/2018 22:02:51 }\r\n\r\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n$Query = [DynamicQueryableExtensions]::Where($sourceTable, \"DateTime(Date) >= DateTime(2018, 1, 1)\")\r\n$Query.ToString()\r\n$Query = [DynamicQueryableExtensions]::OrderBy($Query, 'CodeA descending')\r\n$Query.ToString()\r\n\r\nSystem.Data.EnumerableRowCollection`1[System.Data.DataRow].Where(Param_0 => (Convert(Param_0.get_Item(\"Date\")) >= new DateTime(2018, 1, 1)))\r\nSystem.Data.EnumerableRowCollection`1[System.Data.DataRow].Where(Param_0 => (Convert(Param_0.get_Item(\"Date\")) >= new DateTime(2018, 1, 1))).OrderByDescending(Param_1 => Param_1.get_Item(\"Co\r\ndeA\"))\r\n\r\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n```\r\n",
      "created_at": "2018-05-28T08:54:30Z",
      "updated_at": "2018-05-28T08:55:13Z"
    },
    {
      "author": "mkellerman",
      "author_association": "NONE",
      "body": "**Poke**\r\n\r\nHi guys,\r\n\r\nJust discovered what LINQ was, and how it can accelerate some of my data manipulation I'm doing on a few projects.\r\n\r\nHas this died? Where do we stand on this?\r\n\r\nThere isn't many people using LINQ, because PowerShell is still a growing language. Most of the people who picked up PowerShell in the first place where administrators, and their needs for LINQ is quite limited. If we want more types of users to use PowerShell as their daily driver (DataScience, Reporting, BigData), we should introduce more ways for us to interact with the data in a user friendly way. If not cooked in, at least as a robust module.\r\n\r\nThe question is, how can we simplify the process of invoking a LINQ expression though PowerShell? \r\n\r\nCan we do something like this:\r\n```powershell\r\nGet-Process | Invoke-LINQExpression -Command 'from p in items select p).GroupBy(g =>g.name)'\r\n```\r\nSimply parse the string into a PowerShell invokable LINQ expression? \r\n\r\nIMO, we should keep the LINQ syntax unchanged so users who are already familiar with the language, can simply port over their expressions to powershell.\r\n\r\nI realize this might be to 'simple', but simply exposing a simpler way to invoking LINQ expression from the pipeline, would help novice users, like myself, have an easier time accessing some of these faster speeds for these scenarios.\r\n\r\nOr even having as a method:\r\n```powershell\r\n$Process.LINQ('from p in items select p).GroupBy(g =>g.name)')\r\n```",
      "created_at": "2019-01-31T17:04:14Z",
      "updated_at": "2019-01-31T17:04:14Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "There's no need to do so. LINQ methods should be able to be mapped to script blocks fairly directly; I believe the main issue there is that some of them are generically-typed methods, which PowerShell doesn't yet support.\r\n\r\nExisting methods that require delegates or similar can _already_ be used in PowerShell, via script blocks:\r\n\r\n```powershell\r\nusing namespace System.Collections.Generic\r\n[List[string]] $Collection = 1..50\r\n$Collection.RemoveAll(\r\n    {\r\n        param($x)\r\n        $x -gt 10\r\n    }\r\n)\r\n$Collection # outputs numbers 1 through 10\r\n```\r\n\r\nI think the main issue is designing adapters to work with the different types of inline functions that are available from the C# methods, and potentially also upgrading the parser to recognise and properly invoke generic methods, as many LINQ methods are generic.",
      "created_at": "2019-01-31T17:26:08Z",
      "updated_at": "2019-01-31T17:26:08Z"
    },
    {
      "author": "mkellerman",
      "author_association": "NONE",
      "body": "Hey guys, am I missing something?\r\n\r\nJust did some quick tests, to see the differences between between all 3 types of Where filtering:\r\n```powershell\r\n$InputObjects = (1..500000) | Select-Object @{n=\"Name\";e={$_}}\r\n\r\nWrite-Host \"Invoking: Where-Object\"\r\n    $Measure = Measure-Command {\r\n        $InputObjects | Where-Object { $_.Name -eq 5000 }\r\n    }\r\n    Write-Host \"ExecutionTime: $($Measure.TotalSeconds)`r`n\"\r\n\r\nWrite-Host \"Invoking: .Where()\"\r\n    $Measure = Measure-Command {\r\n        $InputObjects.Where({ $_.Name -eq 5000 })\r\n    }\r\n    Write-Host \"ExecutionTime: $($Measure.TotalSeconds)`r`n\"\r\n\r\nWrite-Host \"Invoking: [System.Linq.Enumerable]::Where()\"\r\n    $Measure = Measure-Command {\r\n        [System.Linq.Enumerable]::Where($InputObjects, [Func[object,bool]]{ param($x) $x.Name -eq 5000 })\r\n    }\r\n    Write-Host \"ExecutionTime: $($Measure.TotalSeconds)`r`n\"\r\n```\r\n\r\nResults:\r\n```\r\nInvoking: Where-Object\r\nExecutionTime: 87.4306334\r\n\r\nInvoking: .Where()\r\nExecutionTime: 31.1690778\r\n\r\nInvoking: [System.Linq.Enumerable]::Where()\r\nExecutionTime: 59.088012\r\n```\r\n\r\nI'm not seeing any speed/performance improvement in this simple example. Can someone help me improve my methodology?",
      "created_at": "2019-01-31T19:09:48Z",
      "updated_at": "2019-01-31T19:09:48Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "I don't think there's anything wrong with your methodology -- it clearly shows that even without using PSLambda, LINQ methods are a lot faster than pipeline cmdlets.\r\n\r\nThe `.Where()` easter egg method _did not exist at all_ when this issue was originally created in Connect, but it doesn't affect this story except as proof that exposing (faster) methods is useful, even when they're not very discoverable. Unfortunately, the way that `.Where()` was added requires adding each method by hand, so it doesn't resolve the general request about generic methods or extension methods in general.",
      "created_at": "2019-02-01T16:04:26Z",
      "updated_at": "2019-02-01T16:04:26Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "TANGENT: For what it's worth @mkellerman -- if you want the fastest of the fast, you just need to use PSLambda to make the delegate. I'm using a strongly typed collection here just because i prefer that when working with LINQ, but it's probably not really necessary.\r\n\r\n```PowerShell\r\nWrite-Host \"Initializing Collection\"\r\n[System.Collections.Generic.KeyValuePair[string, int][]]$InputObjects = (1..500000).ForEach({ [System.Collections.Generic.KeyValuePair[string, int]]::new(\"$_\", $_) })\r\n\r\nWrite-Host \"Invoking: Where-Object\"\r\n    $Measure = Measure-Command {\r\n        $InputObjects | Where-Object { $_.Key -eq \"5000\" }\r\n    }\r\n    Write-Host \"ExecutionTime: $($Measure.TotalSeconds)`r`n\"\r\n\r\nWrite-Host \"Invoking: .Where()\"\r\n    $Measure = Measure-Command {\r\n        $InputObjects.Where({ $_.Key -eq \"5000\" })\r\n    }\r\n    Write-Host \"ExecutionTime: $($Measure.TotalSeconds)`r`n\"\r\n\r\nWrite-Host \"Invoking: [System.Linq.Enumerable]::Where()\"\r\n    $Measure = Measure-Command {\r\n        [System.Linq.Enumerable]::Where($InputObjects, [Func[[System.Collections.Generic.KeyValuePair[string, int]],bool]]{ param($x) $x.Key -eq \"5000\" })\r\n    }\r\n    Write-Host \"ExecutionTime: $($Measure.TotalSeconds)`r`n\"\r\n\r\nWrite-Host \"Invoking: [Linq.Enumerable]::Where with PSLambda\"\r\n    $Measure = Measure-Command {\r\n        $lambda = New-PSDelegate { param($x) $x.Key -eq \"5000\" } -Delegate ([Func[[System.Collections.Generic.KeyValuePair[string, int]],bool]])\r\n        [System.Linq.Enumerable]::Where($InputObjects, $lambda)\r\n    }\r\n    Write-Host \"ExecutionTime: $($Measure.TotalSeconds)`r`n\"\r\n```\r\n\r\n### Results\r\n\r\n```\r\nInvoking: Where-Object\r\nExecutionTime: 15.1560668\r\n\r\nInvoking: .Where()\r\nExecutionTime: 4.6443658\r\n\r\nInvoking: [System.Linq.Enumerable]::Where()\r\nExecutionTime: 9.4843462\r\n\r\nInvoking: [Linq.Enumerable]::Where with PSLambda\r\nExecutionTime: 0.1397667 \ud83d\ude2e \r\n```\r\n\r\n\ud83c\udfc3\ud83d\udca8\ud83d\udca8\ud83d\udca8",
      "created_at": "2019-02-01T16:31:35Z",
      "updated_at": "2019-02-01T16:31:35Z"
    },
    {
      "author": "mkellerman",
      "author_association": "NONE",
      "body": "Oh dang! That's sexy!\r\n\r\nOkay, so how can we wrap this up better for the average PS user? I'm going to go read up on PSDelegate and PSLambda.",
      "created_at": "2019-02-01T16:54:50Z",
      "updated_at": "2019-02-01T16:54:50Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@Jaykul Why is PSLambda so much swifter, and how can we repurpose that perhaps in the built in conversion paths for, say, a script block delegate?",
      "created_at": "2019-02-01T17:14:46Z",
      "updated_at": "2019-02-01T17:14:46Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "Well, the reason LINQ is so slow is that inside of the LINQ method, it's running that scriptblock (back out into PowerShell's runspace, feeding it the parameter) half a million times...\r\n\r\nUsing LINQ with PSLambda is faster because we're basically *not* using PowerShell at all \ud83d\ude0a \r\n\r\nAs Bruce said earlier, PSLambda represents _yet another language mode_ (and one that's even more restrictive than classes). We're accepting the limitation that we can't use cmdlets in exchange for writing compile-able PowerShell, and getting a compiled (IL) .NET lambda method.  Then, when we invoke the LINQ `Where`, we're not calling back out into the PowerShell runspace (and copying variables around) over and over...\r\n\r\nAnd of course, I had to tell it the type/signature of the lambda, too. I'm sure we could do something intelligent there (i.e. detect parameter and return types), but if we do it all transparently, it's going to be hard to explain why it's only super fast _sometimes_ (when you don't use cmdlets)...",
      "created_at": "2019-02-01T21:35:00Z",
      "updated_at": "2019-02-01T21:35:00Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "\ud83e\udd14 \r\n\r\nPragmatic solution from my perspective would seem to be perhaps you just make it work when it can, and if someone uses a cmdlet in a LINQ method maybe a PSSA warning to indicate it will be slower than usual?",
      "created_at": "2019-02-01T21:47:16Z",
      "updated_at": "2019-02-01T21:47:16Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "@Jaykul \r\n\r\n> Well, the reason LINQ is so slow is that inside of the LINQ method, it's running that scriptblock (back out into PowerShell's runspace, feeding it the parameter) half a million times...\r\n\r\nYeah, there is a significant amount of overhead in scope creation, and the default `ScriptBlock` to delegate converter will create a new scope for every invocation.\r\n\r\n**Edit 07/22/2021:** While the above is technically true in that it does create a lot of overhead, that isn't necessarily why it's slow.  For instance if it dot sourced, it would actually be significantly slower in a lot of circumstances due to the compiler no longer optimizing the generated expressions.\r\n\r\n> We're accepting the limitation that we can't use cmdlets in exchange for writing compile-able PowerShell, and getting a compiled (IL) .NET lambda method.\r\n\r\nIn the case of PSLambda, it's a lot more restrictive than that.  It's statically typed, has static member resolution, can't redefine variables, no pipeline support, and probably more.  It could be changed to use the DLR, generate enumerable state machines for the pipeline, etc, but it would definitely take a bit of a performance hit.\r\n\r\n> we're not calling back out into the PowerShell runspace (and copying variables around) over and over...\r\n\r\nIt's worth noting that you *can* actually use (and mutate) variables from the scope that defined the delegate.  A thread safe wrapper for `PSVariable` is created if a reference is found during compilation.\r\n\r\n**Edit 07/22/2021:** thread safe...ish\r\n\r\n> And of course, I had to tell it the type/signature of the lambda, too. I'm sure we could do something intelligent there (i.e. detect parameter and return types)\r\n\r\nYeah, some basic support for that already exists in PSLambda, but only *inside* the delegate.  This works for example:\r\n\r\n```powershell\r\n$delegate = New-PSDelegate {\r\n    $ExecutionContext.InvokeProvider.ChildItem.Get('function:', $true).\r\n        Select{ $pso => $pso.BaseObject }. # Func<PSObject, object>\r\n        OfType([g[System.Management.Automation.FunctionInfo]]).\r\n        FirstOrDefault{ $f => $f.Name.Equals('TabExpansion2') } # Func<FunctionInfo, bool>\r\n}\r\n\r\n$delegate.Invoke()\r\n# CommandType     Name             Version    Source\r\n# -----------     ----             -------    ------\r\n# Function        TabExpansion2\r\n```\r\n\r\nSupport for that during `psdelegate` conversion would be possible within the engine, I just didn't have any visibility into the call site from the perspective of a `PSTypeConverter`\r\n\r\n@vexx32 \r\n\r\n> Pragmatic solution from my perspective would seem to be perhaps you just make it work when it can, and if someone uses a cmdlet in a LINQ method maybe a PSSA warning to indicate it will be slower than usual?\r\n\r\nIt's a bit more complicated than that. That could really only be done in the most basic of expressions, otherwise behavior would differ wildly without an extraordinary amount of work to refine the compiler.\r\n\r\nMy opinion is that if a strict, statically compiled language mode were to be added then it should require some sort of explicit opt-in.",
      "created_at": "2019-02-04T15:24:08Z",
      "updated_at": "2021-07-22T15:31:52Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "Also for reference, here's a working version of @BrucePay's stunt query\r\n\r\n```powershell\r\nusing namespace System\r\nusing namespace System.Collections.Generic\r\nusing namespace System.IO\r\nusing namespace System.Text.RegularExpressions\r\n\r\n$delegate = [psdelegate]{\r\n    # Generic return type inference seems to be broken for SelectMany, oops\r\n    $selectManyDelegate = [Func[string, IEnumerable[string]]]{\r\n        $line => $line.Split([array]::Empty([g[char]]))\r\n    }\r\n\r\n    return ([File]::\r\n        ReadAllLines('c:\\temp\\WarAndPeace.txt').\r\n        Select{ $line => $line.Trim() }.\r\n        SelectMany($selectManyDelegate).\r\n        Where{ $word => { [regex]::IsMatch($word, '^[a-z]+$', [RegexOptions]::IgnoreCase) }}.\r\n        Aggregate(\r\n            <# seed: #> [Dictionary[string, int]]::new([StringComparer]::OrdinalIgnoreCase),\r\n            <# func: #> {\r\n                ($map, $word) => {\r\n                    if ($map.ContainsKey($word)) {\r\n                        $map[$word]++\r\n                        return $map\r\n                    }\r\n\r\n                    $map.Add($word, 1)\r\n                    return $map\r\n                }\r\n\r\n            # Also a bug in finding the IEnumerable<> implementation on Dictionary<,>\r\n            }) -as [IEnumerable[KeyValuePair[string, int]]]).\r\n        OrderByDescending{ $kvp => $kvp.Value }.\r\n        Take(10)\r\n}\r\n\r\n$delegate.Invoke()\r\n# Key  Value\r\n# ---  -----\r\n# The  34258\r\n# and  21396\r\n# to   16500\r\n# of   14904\r\n# a    10388\r\n# he    9298\r\n# in    8733\r\n# his   7930\r\n# that  7412\r\n# was   7200\r\n```",
      "created_at": "2019-02-04T18:11:24Z",
      "updated_at": "2019-02-04T18:11:24Z"
    },
    {
      "author": "Ryan2065",
      "author_association": "NONE",
      "body": "I recently wrote a module (EFPosh) that exposes Linq functionality through cmdlets in a PowerShell-friendly way I think. I wanted to post it here and see what people thought.\r\n\r\nInstead of trying to figure out how to write the Func delegates in PowerShell using .Net methods, I decided to handle that on the backend and expose query functionality through these commands:\r\n\r\nNew-EFPoshQuery\r\nStart-EFPoshQuery\r\nAdd-EFPoshQuery\r\n\r\nA query would go like this (pseudo-code as I wrote this for EntityFramework):\r\n\r\n``` PowerShell\r\nNew-EFPoshQuery -Object $ObjectToQuery\r\nAdd-EFPoshQuery -Property '<TabComplete list of properties>' -Equals 'Value' -And\r\nAdd-EFPoshQuery -Property '<TabComplete list of properties>' -GreaterThan 5 -Or\r\nAdd-EFPoshQuery -Property '<TabComplete list of properties>' -Contains @('Array')\r\nStart-EFPoshQuery -ToList -Distinct\r\n```\r\n\r\nThe idea is once New-EFPoshQuery is executed, tab complete works for Add-EFPoshQuery through ArgumentCompletors. This way the syntax works from the command line and through a script.\r\n\r\nIt's a little weird to think about not executing the query in the line you start it, but deferred execution is an IQueryable idea that can come to PowerShell also!\r\n\r\nOn the back end I'm using the DynamicLinq library but that is more out of wanting to get something out the door rather than a necessity. It wouldn't be difficult (and might be easier) to build the delegates without a 3rd-party library.\r\n\r\nHere's the code if you want to see what I'm doing:\r\n\r\nhttps://github.com/Ryan2065/EFPosh/tree/master/src/Module/EFPosh/Commands\n\n<blockquote><img src=\"https://avatars0.githubusercontent.com/u/2614529?s=400&v=4\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/Ryan2065/EFPosh\">Ryan2065/EFPosh</a></strong></div><div>Contribute to Ryan2065/EFPosh development by creating an account on GitHub.</div></blockquote>",
      "created_at": "2020-06-02T20:10:09Z",
      "updated_at": "2020-06-02T20:10:11Z"
    },
    {
      "author": "Ryan2065",
      "author_association": "NONE",
      "body": "I was thinking about it, and in my module I store the IQueryable internally and let you build off of it and it's disposed when Start is run or New is re-run.  Another way to write this that would be more PowerShell Friendly is this:\r\n\r\n```\r\n$Results = New-EFPoshQuery -Object $ObjectToQuery |\r\nAdd-EFPoshQuery -Property '<TabComplete list of properties>' -Equals 'Value' -And |\r\nAdd-EFPoshQuery -Property '<TabComplete list of properties>' -GreaterThan 5 -Or |\r\nAdd-EFPoshQuery -Property '<TabComplete list of properties>' -Contains @('Array') |\r\nStart-EFPoshQuery -ToList -Distinct\r\n```\r\n\r\nSo return the IQueryable and pipe it to the next command. That's more Poshey and allows you to write the query on multiple lines.",
      "created_at": "2020-06-02T20:19:17Z",
      "updated_at": "2020-06-02T20:19:17Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "I generally agree with ideas behind this (dated) purpose but I also feel (from StackOverflow inquiries) that a lot of PowerShell scripters do not completely understand the actual differences between the PowerShell Pipeline and a deferred execution. They are not able to draw deeper conclusions from performance measurements (using `Measure-Command`). Meaning that they just want to use `linq` in their script because _they're told_ it is up to a 1000 times faster or simply because they see a few methods were _it appears that_ one takes 1000 times more CPU cycles than the other. This often leads to twisted Linq/PowerShell implementations sometimes even combined with a the addition assignment operator (`+=` ) to build an object collection.\r\nBesides, so far I can tell, a Linq query on the PowerShell pipeline \"`InputObject`\" items will always require to hold the pipeline.\r\nIn other words, I think it is important to stay realistic, a \"_**1000 times speedup**_\" (implying the PowerShell pipeline is quiet worthless), is practically not what you get as a performance improvement by using Linq methods and measuring the performance of the whole end-to-end PowerShell solution.\r\n\r\nTaking @Jaykul measurements as an example.\r\nWhere it is assumed that `$InputObjects` already resides in memory, which is often not the case as it usually comes from somewhere else (e.g. a disk, AD, remote database, the cloud,...) and also requires a strict type (were usually [PowerShell variables are loosely typed](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_variables?view=powershell-7.1#types-of-variables)). It is important to look at the performance of retrieving the actual results of the concerned methods too:\r\n\r\n<details>\r\n  <summary>Include result measurements</summary>\r\n\r\n```PowerShell\r\nWrite-Host \"Initializing Collection\"\r\n[System.Collections.Generic.KeyValuePair[string, int][]]$InputObjects = (1..500000).ForEach({ [System.Collections.Generic.KeyValuePair[string, int]]::new(\"$_\", $_) })\r\n\r\nWrite-Host \"Invoking: Where-Object\"\r\n    $Measure = Measure-Command {\r\n        $Pipeline = $InputObjects | Where-Object { $_.Key -eq \"5000\" }\r\n    }\r\n    Write-Host \"ExecutionTime: $($Measure.TotalSeconds)`r`n\"\r\n\r\nWrite-Host \"Invoking: .Where()\"\r\n    $Measure = Measure-Command {\r\n        $Where = $InputObjects.Where({ $_.Key -eq \"5000\" })\r\n    }\r\n    Write-Host \"ExecutionTime: $($Measure.TotalSeconds)`r`n\"\r\n\r\nWrite-Host \"Invoking: [System.Linq.Enumerable]::Where()\"\r\n    $Measure = Measure-Command {\r\n        $Linq = [System.Linq.Enumerable]::Where($InputObjects, [Func[[System.Collections.Generic.KeyValuePair[string, int]],bool]]{ param($x) $x.Key -eq \"5000\" })\r\n    }\r\n    Write-Host \"ExecutionTime: $($Measure.TotalSeconds)`r`n\"\r\n\r\nWrite-Host \"Invoking: [Linq.Enumerable]::Where with PSLambda\"\r\n    $Measure = Measure-Command {\r\n        $PSlambda = New-PSDelegate { param($x) $x.Key -eq \"5000\" } -Delegate ([Func[[System.Collections.Generic.KeyValuePair[string, int]],bool]])\r\n        $Lambda = [System.Linq.Enumerable]::Where($InputObjects, $PSlambda)\r\n    }\r\n    Write-Host \"ExecutionTime: $($Measure.TotalSeconds)`r`n\"\r\n    \r\nWrite-Host \"Retrieving: Where-Object\"\r\n    $Measure = Measure-Command {\r\n        $PipelineValue = $Pipeline.Value\r\n    }\r\n    Write-Host \"ExecutionTime: $($Measure.TotalSeconds)`r`n\"\r\n\r\nWrite-Host \"Retrieving: .Where()\"\r\n    $Measure = Measure-Command {\r\n        $WhereValue = $Where.Value\r\n    }\r\n    Write-Host \"ExecutionTime: $($Measure.TotalSeconds)`r`n\"\r\n\r\nWrite-Host \"Retrieving: [System.Linq.Enumerable]::Where()\"\r\n    $Measure = Measure-Command {\r\n        $LinqValue = $Linq.Value\r\n    }\r\n    Write-Host \"ExecutionTime: $($Measure.TotalSeconds)`r`n\"\r\n\r\nWrite-Host \"Retrieving: [Linq.Enumerable]::Where with PSLambda\"\r\n    $Measure = Measure-Command {\r\n        $LambdaValue = $Lambda.Value\r\n    }\r\n    Write-Host \"ExecutionTime: $($Measure.TotalSeconds)`r`n\"\r\n```\r\n</details>\r\n\r\nIn a _fresh_ PowerShell session this yields:\r\n```\r\nInitializing Collection\r\nInvoking: Where-Object\r\nExecutionTime: 3.9269345\r\n\r\nInvoking: .Where()\r\nExecutionTime: 1.0701013\r\n\r\nInvoking: [System.Linq.Enumerable]::Where()\r\nExecutionTime: 0.0144116\r\n\r\nInvoking: [Linq.Enumerable]::Where with PSLambda\r\nExecutionTime: 0.0985589\r\n\r\nRetrieving: Where-Object\r\nExecutionTime: 0.0033488\r\n\r\nRetrieving: .Where()\r\nExecutionTime: 0.005539\r\n\r\nRetrieving: [System.Linq.Enumerable]::Where()\r\nExecutionTime: 1.7921827\r\n\r\nRetrieving: [Linq.Enumerable]::Where with PSLambda\r\nExecutionTime: 0.0645393\r\n```",
      "created_at": "2021-07-22T10:13:44Z",
      "updated_at": "2021-07-22T12:58:05Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> It is important to look at the performance of retrieving the actual results of the concerned methods too:\r\n\r\nNote that the above examples do take this into account as well. While `Measure-Command` does output to a null pipe, it does still enumerate output.  It just doesn't send it anywhere. Though of course it is still valuable to see the timing of the distinct steps, just want to make sure it's known since it's not particularly obvious.",
      "created_at": "2021-07-22T15:34:57Z",
      "updated_at": "2021-07-22T15:34:57Z"
    },
    {
      "author": "Ryan2065",
      "author_association": "NONE",
      "body": "> Where it is assumed that $InputObjects already resides in memory, which is often not the case as it usually comes from somewhere else (e.g. a disk, AD, remote database, the cloud,...)\r\n\r\nIf we had true Linq, we could use Entity Framework and do server-side processing of our Linq queries with DB providers so the whole collection isn't brought back and evaluated in memory.\r\n\r\n",
      "created_at": "2021-07-22T17:56:17Z",
      "updated_at": "2021-07-22T17:56:17Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> If we had true Linq, we could use Entity Framework and do server-side processing of our Linq queries with DB providers so the whole collection isn't brought back and evaluated in memory.\r\n\r\nSupport for `IQueryable` is a whole different host of work that probably needs it's own issue.",
      "created_at": "2021-07-23T00:41:13Z",
      "updated_at": "2021-07-23T00:41:13Z"
    },
    {
      "author": "Ryan2065",
      "author_association": "NONE",
      "body": "I mean, Linq works with both IQueryable and IEnumerable. Why can't a solution hit both targets?\r\n\r\nEFPosh has a \"BinaryExpressionConverter\" to turn PowerShell binary expressions like $x -eq 1 into Linq binary expressions. I used that in the above tests and it was by far the quickest, also works with IQueryable and IEnumerable.\r\n\r\nI left the Import statement to show where the dll came from\r\n\r\n```\r\nImport-Module \"C:\\Users\\RyanEphgrave\\OneDrive - Eph-It\\Documents\\WindowsPowerShell\\Modules\\EFPosh\\1.2.6\\Dependencies\\BinaryExpressionConverter.dll\" -Force\r\n\r\nWrite-Host \"Initializing Collection\"\r\n[System.Collections.Generic.KeyValuePair[string, int][]]$InputObjects = (1..500000).ForEach({ [System.Collections.Generic.KeyValuePair[string, int]]::new(\"$_\", $_) })\r\n\r\nWrite-Host \"Invoking: Where-Object\"\r\n    $Measure = Measure-Command {\r\n        $InputObjects | Where-Object { $_.Key -eq \"5000\" }\r\n    }\r\n    Write-Host \"ExecutionTime: $($Measure.TotalSeconds)`r`n\"\r\n\r\nWrite-Host \"Invoking: .Where()\"\r\n    $Measure = Measure-Command {\r\n        $InputObjects.Where({ $_.Key -eq \"5000\" })\r\n    }\r\n    Write-Host \"ExecutionTime: $($Measure.TotalSeconds)`r`n\"\r\n\r\nWrite-Host \"Invoking: [System.Linq.Enumerable]::Where()\"\r\n    $Measure = Measure-Command {\r\n        [System.Linq.Enumerable]::Where($InputObjects, [Func[[System.Collections.Generic.KeyValuePair[string, int]],bool]]{ param($x) $x.Key -eq \"5000\" })\r\n    }\r\n    Write-Host \"ExecutionTime: $($Measure.TotalSeconds)`r`n\"\r\n\r\nWrite-Host \"Invoking: [Linq.Enumerable]::Where with PSLambda\"\r\n    $Measure = Measure-Command {\r\n        $lambda = New-PSDelegate { param($x) $x.Key -eq \"5000\" } -Delegate ([Func[[System.Collections.Generic.KeyValuePair[string, int]],bool]])\r\n        [System.Linq.Enumerable]::Where($InputObjects, $lambda)\r\n    }\r\n    Write-Host \"ExecutionTime: $($Measure.TotalSeconds)`r`n\"\r\n\r\nWrite-Host \"Invoking: [Linq.Enumerable]::Where with BinaryExpressionConverter\"\r\n    $Measure = Measure-Command {\r\n        $ConvertedExpression = ConvertTo-BinaryExpression -FuncType $InputObjects[0].GetType() -Expression { $_.Key -eq \"5000\" }\r\n        [System.Linq.Enumerable]::Where($InputObjects, $ConvertedExpression.Compile())\r\n    }\r\n    Write-Host \"ExecutionTime: $($Measure.TotalSeconds)`r`n\"\r\n\r\n```\r\n\r\n```\r\nInitializing Collection\r\nInvoking: Where-Object\r\nExecutionTime: 8.3685408\r\n\r\nInvoking: .Where()\r\nExecutionTime: 2.3706274\r\n\r\nInvoking: [System.Linq.Enumerable]::Where()\r\nExecutionTime: 4.1634949\r\n\r\nInvoking: [Linq.Enumerable]::Where with PSLambda\r\nExecutionTime: 0.1275231\r\n\r\nInvoking: [Linq.Enumerable]::Where with BinaryExpressionConverter\r\nExecutionTime: 0.0232382\r\n```\r\n\r\nIt's something to look at.  I've had a lot of difficulties with this and I think it's mostly a lack of internal PowerShell knowledge, not that it can't be done. I spent weeks trying to figure out how to do simple things, like get variable values inside the Binary Expression. \r\n",
      "created_at": "2021-07-23T05:06:30Z",
      "updated_at": "2021-07-23T05:06:30Z"
    },
    {
      "author": "pabrams",
      "author_association": "NONE",
      "body": "But.... I heard that they kill a puppy every time someone uses write-host! You must really hate puppies!",
      "created_at": "2021-07-23T14:05:26Z",
      "updated_at": "2021-07-23T14:05:48Z"
    },
    {
      "author": "pabrams",
      "author_association": "NONE",
      "body": "> Meaning that they just want to use `linq` in their script because _they're told_ it is up to a 1000 times faster or simply because they see a few methods were _it appears that_ one takes 1000 times more CPU cycles than the other. \r\n\r\nI don't know about that... I think a lot of them just think it's cool or they like the syntax, or they're used to it.",
      "created_at": "2021-07-23T14:09:45Z",
      "updated_at": "2021-07-23T14:09:45Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> I mean, Linq works with both IQueryable and IEnumerable. Why can't a solution hit both targets?\r\n\r\nBecause one is just adding binding support for extension methods and the other is translating PowerShell language into an expression tree usable by `IQueryable` (PowerShell already does this, and so does PSLambda, but neither are as exact as they'd need to be for this).\r\n\r\nBut I'm not saying it's not possible or shouldn't be done, just that it is it's own discussion and requires a lot more design work than just making some static methods appear like they're instance methods.\r\n\r\n> EFPosh has a \"BinaryExpressionConverter\" to turn PowerShell binary expressions like $x -eq 1 into Linq binary expressions. I used that in the above tests and it was by far the quickest, also works with IQueryable and IEnumerable.\r\n\r\nYeah that'll definitely top even PSLambda.  It's binary expression calls out to `LanguagePrimitives.Compare` (which is a decision I would definitely not make twice)\r\n\r\n> It's something to look at. I've had a lot of difficulties with this and I think it's mostly a lack of internal PowerShell knowledge, not that it can't be done. I spent weeks trying to figure out how to do simple things, like get variable values inside the Binary Expression.\r\n\r\nFWIW you can always see how Roslyn does things by looking at [sharplab](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA+ABATARgLABQGADAAQY4oDchJ5OAdADICWAdgI40G0DM5WUgGFSAb0KlJ5fhV4AeCsQB8pALIAKAJIBFAK4woATwCGwADYwFOZaQDOEXVDAwAlGIlTPi0m2MBbGFIAXnoGTQB5BgARFlgwABdoQwYAcRh4mLjEqBYYW3UAIgYClwYAMVjbePUXbk8vAHY7BycYBgB1AAsDGHVjYJV+oJDfANqPSQBfQkmgA).  That's something I learned way too late to take much advantage of.",
      "created_at": "2021-07-23T14:25:17Z",
      "updated_at": "2021-07-23T14:25:17Z"
    },
    {
      "author": "Szeraax",
      "author_association": "NONE",
      "body": "Average user here just chiming in with my experience using LINQ tonight.\r\n\r\nI had a 500k int[] and a 150k int[] and I needed to see which items in the 500k weren't part of the 150k. I let this run for several minutes while I looked for something better:\r\n```\r\n$c = $a.where{$_ -notin $b}\r\n```\r\n\r\nThen I ran this: \r\n```\r\n$c = [system.linq.enumerable]::Except([int[]]$a,[int[]]$b)\r\n```\r\nWhich completed in under 2s. \r\n\r\nI don't know why I needed to specify int[] for each item in there, and there is no documentation that I can find that specifically tells you do similar (I was referred here by @mklement0's [SO Answer](https://stackoverflow.com/questions/54963252/how-use-linq-explict-in-powershell-or-analogue-of-not-in-in-sql)). \r\n\r\nIf it was easier and/or better documented how to use powershell to do these LINQ queries, I think they'd be well loved by the community. ",
      "created_at": "2021-12-06T07:28:52Z",
      "updated_at": "2021-12-06T07:30:01Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "@Szeraax ,\r\n\r\n> Which completed in under 2s.\r\n\r\nBe careful with justifying PowerShell against [LINQ](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/). Linq is definitely fast but is almost the opposite of PowerShell (pipeline): where Linq uses a [deferred execution / lazy evaluation](https://docs.microsoft.com/en-us/dotnet/standard/linq/deferred-execution-lazy-evaluation) (meaning that the statement `[system.linq.enumerable]::Except([int[]]$a,[int[]]$b)` isn't doing much and only executed when it is needed (e.g. display the results) and the PowerShell [Pipeline](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_pipelines) let's you proactively work ahead (and input/process/output each item in a stream), e.g.: `$a |Where-Object {$_ -notin $b } |...`.\r\n\r\n> I don't know why I needed to specify `int[]`\r\n\r\nPowerShell is a loosely typed Programming Language by nature and `Linq` requires a strict type command\r\n\r\nQuote [PowerShell scripting performance considerations](https://docs.microsoft.com/en-us/powershell/scripting/dev-cross-plat/performance/script-authoring-considerations):\r\n\r\n---\r\nPowerShell scripts that leverage .NET directly and avoid the pipeline tend to be faster than idiomatic PowerShell. Idiomatic PowerShell typically uses cmdlets and PowerShell functions heavily, often leveraging the pipeline, and dropping down into .NET only when necessary.\r\n\r\n> **Note\"\"\r\n> Many of the techniques described here are not idiomatic PowerShell and may reduce the readability of a PowerShell script. Script authors are advised to use idiomatic PowerShell unless performance dictates otherwise.\r\n---\r\n\r\nTaking your commands: for the linq query you can't just do `c$[3]` but need to do `@(c$)[3]` where you actually might also notice the deferred execution as (the first time) this takes a longer on the variable `$c` provided by the linq query then the one resulted from PowerShell.\r\nSee also: [Comparing two arrays & get the values which are not common](https://stackoverflow.com/a/35872835/1701026) and [Fastest Way to get a uniquely index item from the property of an array](\r\nhttps://stackoverflow.com/a/59437162/1701026)\r\n\r\nSpecific to your question, I would rather see propose #2132 implemented and have sweet PowerShell syntax like: \r\n```PowerShell\r\n$c = $a -notin $b\r\n```",
      "created_at": "2021-12-06T09:34:33Z",
      "updated_at": "2021-12-06T10:08:11Z"
    }
  ],
  "created_at": "2016-09-10T00:16:56Z",
  "labels": [
    "Issue-Enhancement",
    "WG-Language",
    "Committee-Reviewed"
  ],
  "number": 2226,
  "state": "open",
  "title": "Add support for extension methods (LINQ)",
  "updated_at": "2021-12-06T10:08:11Z"
}