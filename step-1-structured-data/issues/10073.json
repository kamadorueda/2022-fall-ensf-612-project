{
  "_url": "https://github.com/PowerShell/PowerShell/issues/10073",
  "author": "bergmeister",
  "body": "# PR Summary\r\n\r\nThis is the first feature of [RFC002](https://github.com/PowerShell/PowerShell-RFC/blob/master/2-Draft-Accepted/RFC0002-Generalized-Splatting.md) for enhanced splatting.\r\nAs agreed in the accepted RFC, one should not need to declare a variable in order to splat. This PR adds the ability to definite the splatted hashtable in the same line as the command. As discussed, the `@@` has to be introduced to differentiate from the scenario where the 1st argument is a hashtable.\r\n\r\nThe scenario that this PR enables is:\r\n```pwsh\r\nGet-ChildItem @@{Path='C:\\'; Filter=$filter}\r\n```\r\n\r\nThis PR adds the new `At`  `TokenKind`  in order to be able the parse the syntax and adds a public `Splatted` property to `HashTableAst` so that the compiler knows at runtime that the argument is splatted.\r\n\r\nThe experimental feature `PSGeneralizedSplatting` is created for it. Although there are switch statements using the new `At` that are not guarded by an if check for this experimental feature (which was not possible due to the flow analysis of C# resulting in a compiler error), this is OK because the experimental feature flag prevents the tokenizer from creating an `At` token in the first place.\r\n\r\nA semantic check was added so that the only implemented use case is using `@@{` as an argument to a command, therefore the user will get an actionable error when trying to use it in another context, e.g. for a .Net method or a hashtable as `@@{'key='value'}` to conform with previous behaviour (where the tokenizer returned an error in those cases). I've also checked it does not impact using `@@` inside a function name (even before a function name could not start with `@@` so no change here).\r\n\r\nThis PR does not add tab completion functionality to the keys of the splatted hashtable. This is something that is not present at the moment anyway with splatted variables and is a separate enhancement that one could add in another PR, as well as other features in the RFC. The goal of this RFC is to implement just 1 feature in this RFC that adds value, therefore making it a minimum viable feature.\r\n\r\nI added tests for existing and new splatting functionality and error cases.\r\n\r\n## PR Context\r\n\r\nhttps://github.com/PowerShell/PowerShell-RFC/blob/master/2-Draft-Accepted/RFC0002-Generalized-Splatting.md\r\n\r\n## PR Checklist\r\n\r\n- [x] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [x] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` or `[ WIP ]` to the beginning of the title (the `WIP` bot will keep its status check at `Pending` while the prefix is present) and remove the prefix when the PR is ready.\r\n- **[Breaking changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)**\r\n    - [x] None\r\n    - **OR**\r\n    - [x] [Experimental feature(s) needed](https://github.com/MicrosoftDocs/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/About/about_Experimental_Features.md)\r\n        - [x] Experimental feature name: `PSGeneralizedSplatting`\r\n- **User-facing changes**\r\n    - [ ] Not Applicable\r\n    - **OR**\r\n    - [x] [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n- **Testing - New and feature**\r\n    - [ ] N/A or can only be tested interactively\r\n    - **OR**\r\n    - [x] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n",
  "closed_at": "2020-07-22T22:43:30Z",
  "comments": [
    {
      "author": "TylerLeonhardt",
      "author_association": "MEMBER",
      "body": "This should probably be marked as an experimental feature.",
      "created_at": "2019-07-07T17:47:55Z",
      "updated_at": "2019-07-07T17:47:55Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "- I fear that if it is an experimental feature, it will not get much test coverage or usage. Usage will be limited to people can write scripts that run on v7 only anyway.\r\n- Editor syntax highlighting and code analysis in VS-Code will be cumbersome because one would need to enable the experimental feature just for viewing the code (which might be the code from another repo). Figuring out the cause of this, will not be clear to most people (the parser gives a `UnrecognizedToken` error : `Unrecognized token in source text.`).\r\n- We still have a few previews to go until PS 7 goes RTM and the code change is a very subtle addition without explicitly altering current behaviour, therefore I see it as low risk anyway.",
      "created_at": "2019-07-07T20:51:05Z",
      "updated_at": "2019-07-07T20:51:51Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "I'd also like it marked as experimental. Experimental isn't just about risk. It's about acceptance of syntax, workflow, etc., and most importantly, it lets users know that the design of this feature is not yet complete.\r\n\r\nAs expressed [here](https://github.com/PowerShell/PowerShell-RFC/issues/209) I think `@@` and `@$` are really bad additions to the PowerShell syntax, and proposed what I think are better alternatives to each of those.",
      "created_at": "2019-07-07T21:38:04Z",
      "updated_at": "2019-07-07T21:38:04Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "Also, experimental does not mean it's not going to make it into v7 either. It simply means we're experimenting with some syntax/commands/etc. and want to be able to allow the broader community kick the tires on those things before we sign-off on them as supported.",
      "created_at": "2019-07-07T21:39:28Z",
      "updated_at": "2019-07-07T21:39:28Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@KirkMunro is correct that Experimental means that the design can change and would not be a breaking change.  ",
      "created_at": "2019-07-08T15:40:55Z",
      "updated_at": "2019-07-08T15:40:55Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "Ok, we have 3 changes here:\r\n- Adding the new entry to the `TokenKind` enum and the new HashTableAst property: as far I understand the `ExperimentalFeature` implementation does not allow to exclude those additions, for the property the best I can do is return false if the feature flag is off\r\n- Usage of the added TokenKind in the Parser and Tokenizer. What should the parser do if the feature is not enabled? Should they throw explicitly if usage of the new `TokenKind` is detected or just be a no-op?\r\n- Compiler (runtime): Usage of `ExperimentalFeature` is clear.\r\n\r\nHappy to add the experimental feature fences around those section after the first review approves the current format.",
      "created_at": "2019-07-08T16:27:53Z",
      "updated_at": "2019-07-08T17:22:04Z"
    },
    {
      "author": "TylerLeonhardt",
      "author_association": "MEMBER",
      "body": "@daxian-dbw can probably supply advice here on proper Experimental Feature usage.",
      "created_at": "2019-07-08T16:46:47Z",
      "updated_at": "2019-07-08T16:46:47Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "@rjmholt @lzybkr I've reacted to all the comments and implemented changes: I've changed it to perform a look-ahead so that it correctly recognises `@{{` only as `AtAtCurly`.\r\nI am aware that implementing the experimental feature and more complex tests are still outstanding but would like to get feedback or sign off on the current design implementation before doing that at the end of this PR. In terms of future timeline I'd like to keep this PR as minimal as possible. For example, at the moment people already use splatting despite that lack of tab completion or being able to inline it. The aim of this PR is to add only the in-lining capability to get this into PS 7, which is the most important, minimum viable aspect IMHO. Any hints on how to implement tab completion later would be appreciated though and I could potentially look at doing them later.",
      "created_at": "2019-09-01T21:49:23Z",
      "updated_at": "2019-09-02T11:23:33Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "If possible, I'd like this design/functionality revisited by the committee. It only simplifies one scenario that would have previously required line continuation characters, and with poorly designed syntax. More effort in a design that is more respectful to how parameters are normally used while considering other line continuation scenarios would be appreciated here. This new syntax isn't sugar by any means...it's just sour.",
      "created_at": "2019-09-02T01:04:26Z",
      "updated_at": "2019-09-02T01:04:26Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "As far as I understand the need for the additional @ character in `@@{` is due to the fact that we do want to differentiate from the case of a hashtable being passed as an (unnamed) parameter, thus the design avoids introducing a breaking change. Apart from using a different character or character set I cannot think of a better way to deal with it.\r\nI'd be happy adapting to a slightly different syntax or if you can think of a totally different approach that is better but in this case make a concrete proposal please (because this is the hardest part). With that in mind, I'd appreciate if we can make a timely decision so that a minimum viable implementation of the syntax can potentially ship in 7.0 (pending feedback). Although we've already agreed to a syntax, I'd be happy to revise but we'd need to be relatively quick, therefore some concrete proposals would help. At the end, personally I'd rather have something than nothing in 7.0. I don't find the current syntax especially bad, when using splatting with a variable one needs to do `@$` so the additional @ makes even logical sense to me.",
      "created_at": "2019-09-02T11:18:53Z",
      "updated_at": "2019-09-02T11:19:17Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "> I'd be happy adapting to a slightly different syntax or if you can think of a totally different approach that is better but in this case make a concrete proposal please (because this is the hardest part).\r\n\r\nI've already made that proposal in [PowerShell/PowerShell-RFC #179](https://github.com/PowerShell/PowerShell-RFC/pull/179), which proposes using `@` as an indicator that you want PowerShell to stop treating newlines as statement terminators until it encounters a statement terminator or a blank line. Some folks have expressed that they don't like the lack of a closing sigil with that, which is why [this alternative proposal was very recently added](https://github.com/PowerShell/PowerShell-RFC/blob/d7f3899abd789ad1fd487185ddf97195f7185806/1-Draft/RFCNNNN-Multi-Line-Continuation.md#enclosures-instead-of-a-sigil), which suggests that `` @` `` and `` `@ `` could be enclosures to enable multi-line parsing of the current statement.\r\n\r\nThe key advantage to those proposals compared with inline splatting is simple: they tell the parser how to treat newlines and leading or trailing whitespace when it comes to terminating statements, allowing users to format their code in a way that suits them better, while preserving basic PowerShell syntax. Inline splatting, on the other hand, only takes parameters into consideration, and completely changes how you would have to enter them to span a command across multiple lines without using backticks.",
      "created_at": "2019-09-03T14:18:33Z",
      "updated_at": "2019-09-03T14:18:33Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "@PoshChan  Rerun failures",
      "created_at": "2019-09-21T19:22:54Z",
      "updated_at": "2019-09-21T19:22:54Z"
    },
    {
      "author": "PoshChan",
      "author_association": "COLLABORATOR",
      "body": "@bergmeister, all requests start with the magic word: `Please`\n\n<details>\n<summary>Commands available in this repo for you:\n</summary>\n<ul><li>\n<code>retry &lt;target&gt;</code> this will attempt to retry only the failed jobs for the target pipeline, <code>restart</code> can be used in place of <code>retry</code>\n</li>\n<li>\n<code>rebuild &lt;target&gt;</code> this will perform a complete rebuild of the target pipeline, <code>rerun</code> can be used in place of <code>rebuild</code> Supported values for &lt;target&gt; which can be a comma separated list are: <code>static</code>,<code>windows</code>,<code>macos</code>,<code>linux</code>,<code>all</code>\n</li>\n<li>\n<code>get failures</code> this will attempt to get the latest failures for all of the target pipelines\n</li>\n<li>\n<code>remind me in &lt;value&gt; &lt;units&gt;</code> this will create a reminder that will be posted after the specified duration &lt;value&gt; is a number, and &lt;units&gt; can be <code>minutes</code>, <code>hours</code>, or <code>days</code> (singular or plural)\n</li>\n\n</ul>\n</details>\n\n",
      "created_at": "2019-09-21T19:23:15Z",
      "updated_at": "2019-09-21T19:23:15Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "@PoshChan Please retry Windows",
      "created_at": "2019-09-21T19:24:11Z",
      "updated_at": "2019-09-21T19:24:11Z"
    },
    {
      "author": "PoshChan",
      "author_association": "COLLABORATOR",
      "body": "@bergmeister, successfully started retry of `PowerShell-CI-Windows`",
      "created_at": "2019-09-21T19:24:52Z",
      "updated_at": "2019-09-21T19:24:52Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "@PoshChan  Please retry Linux",
      "created_at": "2019-09-22T18:44:34Z",
      "updated_at": "2019-09-22T18:44:34Z"
    },
    {
      "author": "PoshChan",
      "author_association": "COLLABORATOR",
      "body": "@bergmeister, successfully started retry of `PowerShell-CI-Linux`",
      "created_at": "2019-09-22T18:44:51Z",
      "updated_at": "2019-09-22T18:44:51Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "Everyone, especially @rjmholt @lzybkr  :\r\nI've made the following changes and would consider the PR ready for merge now and would like to get feedback. I've updated the PR summary, please re-read it. What I've done after the first review:\r\n- Add the experimental feature `PSGeneralizedSplatting`, which makes sure no `AtAt` token gets produced if the feature is not enabled and safe-guard other changed areas\r\n- Change the `AtAtCurly` token to `AtAt` only (`@@`) and perform look-ahead in the tokenizer for a following `{` in order to mark it as a token of `AtAt` `TokenKind`.\r\n- Add a semantic check to make sure the usage of it is restricted only to be the arguments of a `CommandAst`. The AST does not differentiate between a cmdlet or native command but splatting does not make any sense in this case anyway\r\n- Added more positive and negative tests",
      "created_at": "2019-09-22T19:15:59Z",
      "updated_at": "2019-09-23T06:13:43Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "I thought I suggested previously that there shouldn't be a `AtAt` token if this is truly generalized splatting.\r\n\r\nInstead, `@` is like an operator that is applied to any expression, so for example, `@ @{}` (note the whitespace) generates a UnaryExpressionAst with the child HashtableAst.",
      "created_at": "2019-10-03T19:15:49Z",
      "updated_at": "2019-10-03T19:15:49Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "> I thought I suggested previously that there shouldn't be a `AtAt` token if this is truly generalized splatting.\r\n> \r\n> Instead, `@` is like an operator that is applied to any expression, so for example, `@ @{}` (note the whitespace) generates a UnaryExpressionAst with the child HashtableAst.\r\n\r\nThat approach could prevent other uses of `@` without risking breaking changes though, right? What are the benefits of having `@` be an unary operator for any expression vs having `@@{` as a token to open inline splatting?\r\n\r\nI'm still hoping we'll drop this approach and move forward with `` @` `` and `` `@ `` as enclosures for multi-line continuation, but to even build that as experimental, I worry that a unary `@` operator would complicate things.",
      "created_at": "2019-10-04T12:10:56Z",
      "updated_at": "2019-10-04T12:10:56Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> Instead, @ is like an operator that is applied to any expression, so for example, @ @{} (note the whitespace) generates a UnaryExpressionAst with the child HashtableAst\r\n\r\nYeah that makes sense to me.\r\n\r\n@bergmeister I'm thinking that will change a few things in the PR:\r\n\r\n- The tokenizer should look for an `At` token. It will need to look ahead to make sure it's not seeing `@(` or `@{`\r\n- That token will need to be recognised in the current place we look for splatting, but should call expression rule underneath it I'm guessing, and generate a `SplatExpressionAst` around the expression\r\n- That AST will mean we need new visitor methods on ICustomAstVisitor2 and AstVisitor2, with a default implementation on ICustomAstVisitor2\r\n- Instead of trying to go through and create constructors for each expression type that makes sense as a splat, it's probably easiest to just have a `SplatExpressionAst` take an `ExpressionAst` as a child and add a semantic check to ensure there's nothing strange there. Although it might also be worth it to make it a syntactic error -- don't have a strong feeling on that one.\r\n- Then in the compiler under `VisitCommand` you probably want something like:\r\n\r\n    ```csharp\r\n    ...\r\n    \r\n    if (splatTest is SplatExpressionAst splatExpression)\r\n    {\r\n        splatted = true;\r\n    }\r\n    else if (splatTest is VariableExpressionAst variableExpression)\r\n    {\r\n        splatted = variableExpression.Splatted;\r\n    }\r\n    \r\n    ...\r\n    ```\r\n\r\n    And `VisitSplatExpression` would probably just strip off the splat and visit the expression underneath.",
      "created_at": "2019-10-04T17:27:58Z",
      "updated_at": "2019-10-04T17:36:53Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "@rjmholt @lzybkr \r\nI've changed the token to be just an `At` token as suggested, which I agree with is a good idea as it will keep it generic and avoid future complications of assigning certain expressions like `@@{` or `@$` to a certain token, especially since there is already a `SplattedVariable` token that will be a tad awkward to deal with in future implementations of more features of generalized splatting....\r\n\r\nHowever, I disagree trying to create something where one can have a whitespace after the `At` token not only because there is no value to the user for that, but also because it unnecessarily complicates it and was also not part of the spec per RFC. I'd like to keep the implementation to be minimum viable.\r\nThe current solution of having the `Splatted` property on the `HashTableAst` fits neatly into the existing structure and allows to lift the property to an `ExpressionAst` for future implementations of other features of generalized splatting like e.g. `Get-Item @$var` or `Get-Item @$(Get-GetItemArgument)`.\r\nIf you still disagree with me, please elaborate more why having an AST of it's own (proposed by Rob) would be useful and how it would fitinto existing syntax like `Get-Item @var` (which generates a `SplattedVariable` token ) without the risk of breaking things.\r\n\r\nThe current implementation has the advantage that it only adds to the code without having to touch the existing logic. I am happy to adapt the PR further but it needs more detailed reasoning. Whilst the idea of having the `At` token generate an `UnaryExpressionAst` with the `HashtableAst` sounds good from a high level, I don't see how it fits into the low level design/implementation, which still has to deal with already existing syntax (which we want to touch as little as possible to avoid regressions). Or maybe I just need a hint as to where you'd image the search for the `At` token to be planted in `Parser.cs` to generate the `UnaryExpressionAst` whilst keeping  things working in the same way.",
      "created_at": "2019-10-06T12:14:56Z",
      "updated_at": "2019-10-06T19:03:51Z"
    },
    {
      "author": "TylerLeonhardt",
      "author_association": "MEMBER",
      "body": "This issue has changes that could potentially change syntax. Please consider adding this feature to [EditorSyntax](https://github.com/PowerShell/EditorSyntax) which is used for syntax highlighting in GitHub, Visual Studio Code, Atom, Sublime Text, and many more locations.\r\n\r\nConsistent syntax highlighting is very important for the language and a feature isn't \"complete\" until syntax highlighting is what is expected.\r\n\r\nIf you can't contribute to [EditorSyntax](https://github.com/PowerShell/EditorSyntax), at least open an issue to track the work - however, please note, that no one is actively working on the repo and so the work will likely not get done in a timely manner.\r\n\r\nWe hope that you consider contributing to [EditorSyntax](https://github.com/PowerShell/EditorSyntax).\r\n\r\n(note this is copy/pasted text for any change that looks like it could impact EditorSyntax - and will be a bot in the future)",
      "created_at": "2019-10-12T14:33:58Z",
      "updated_at": "2019-10-12T14:33:58Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "I need to call out something about this PR that still doesn't sit right with me.\r\n\r\nBased on my understanding this PR is designed to solve one specific issue: being able to use inline splatting of a hashtable. Does it also add support the following?\r\n\r\n1. Inline splatting of an array?\r\n1. Inline splatting of a hashtable that is in a parameter of an object or behind an invocation of a command?\r\n\r\nEven if this PR supports the first scenario (via `@@(...)`) and the second scenario (via `@$(...)`), this syntax still doesn't feel like the right solution for this problem.\r\n\r\nI suggested it before (during the original RFC if I recall correctly), but I'll bring it up again: why use this syntax instead of a common `-splat` parameter? The `-splat` parameter is respectful of PowerShell's \"way\", it helps advance learning/discovery (it says \"splat\", so that gives you something to work with when you search for help/docs), and it could even have a special-case alias of `@` if we wanted so that users could use `-@` (special case because today PowerShell does not recognize `@` as a parameter token, but we could allow it for this specific scenario if we wanted to).\r\n\r\nThat's almost the syntax that you have been pushing forward here, but supporting splatting of any array or hashtable whether it is provided as a literal value, or comes from a parameter, method, or command invocation. The only difference is you'd have a space between `-@/-splat` and the actual hashtable, which I think is also a good thing.",
      "created_at": "2019-10-23T10:40:42Z",
      "updated_at": "2019-10-23T10:40:42Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "@TylerLeonhardt  I've created the following tracking issue for EditorSyntax:\r\nhttps://github.com/PowerShell/EditorSyntax/issues/188\r\n@KirkMunro  Yes, it only implements inline splatting of a hashtable. This is the only feature that I want and it is a minimum, viable feature IMHO, your use cases are unfortunately not of interest to me but you could add them afterwards if you wanted to because I only use the `@` operator now.",
      "created_at": "2019-10-28T11:23:27Z",
      "updated_at": "2019-10-28T12:00:03Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT \r\nCan you please bring up this PR with  @PowerShell/powershell-committee to make a decision whether the committee wants this feature to be part of the next preview, which is the last point of being able to get features in. I have addressed comments and implemented a minimum viable version that is open for extension so that other features that the PS teams or the community wants can be added to it without having to refactor it.\r\nIt's been nearly a month ago since the last feedback of the PowerShell team on this.\r\n\r\nCurrently this PR implements inline splatting of a hashtable, which is a subset of the generalized splatting RFC, however, I do not plan to implement more features as this is the minimum viable implementation of the only feature that I want. Please let me know if that is deemed OK or if you'd require tab completion for this feature as well (currently there is no tab completion for traditional inline splatting, hence why I see it as an additional, optional, nice to have feature). If tab completion is required, I might try to add it but I want to have approval first that the PS wants this for PS7 and that the PS team is OK with only adding the inline splatting aspect of generalized splatting.",
      "created_at": "2019-10-28T11:34:03Z",
      "updated_at": "2019-10-28T18:38:30Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "For consideration by anyone reviewing this PR and the @PowerShell/powershell-committee, please have a look at PR #10984 as well, which supports inline splatting as well as other scenarios requested in the original RFC via a `-splat` common parameter.\r\n\r\ncc: @SteveL-MSFT ",
      "created_at": "2019-11-04T17:03:19Z",
      "updated_at": "2019-11-04T17:04:09Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, I do not have any objections against your implementation approach.\r\nAt the end the committee should make a decision which implementation they favour or if they want a mix of them, I am open to any solution that gets inline splatting into ps 7.\r\n\r\nI have addressed the recent review requests and also stated that apart from optional tab completion (if requested) that I see my implementation as a complete, viable feature of one of the RFC goals and that I will not implement other features described in the RFC as this would be unnecessary scope increase for me.",
      "created_at": "2019-11-04T18:29:44Z",
      "updated_at": "2019-11-04T18:33:08Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as Review Needed because it has been there has not been any activity for **7 days**.\nMainainer, Please provide feedback and/or mark it as `Waiting on Author`",
      "created_at": "2020-05-27T02:03:41Z",
      "updated_at": "2020-05-27T02:03:41Z"
    },
    {
      "author": "adityapatwardhan",
      "author_association": "MEMBER",
      "body": "There are two PRs that are implementing the same RFC - [RFC002 ](https://github.com/PowerShell/PowerShell-RFC/blob/master/2-Draft-Accepted/RFC0002-Generalized-Splatting.md). \r\n\r\nI request @PowerShell/powershell-committee to guide on which of the implementations should be accepted.\r\n\r\nThe other PR with the implementation is: https://github.com/PowerShell/PowerShell/pull/10984",
      "created_at": "2020-05-28T18:58:58Z",
      "updated_at": "2020-05-28T18:58:58Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "It should be said that both PRs do not implement all the features in the RFC, just a subset of it that are the most important ones for me and the other author, which I think is OK in terms of being minimum, viable.\r\nAlso: This PR follows the `@@` syntax that was agreed in the RFC exactly, the other PR proposes a different approach via common parameters.\r\n\r\nI'd be happy as long as either of the 2 PRs get accepted. When deciding between the 2 PRs, I'd like the @PowerShell/powershell-committee to also consider what is best in terms of follow up PRs if other people contribute e.g. the remaining features in the RFC or tab completion for the inline-splatted arguments.",
      "created_at": "2020-05-28T20:10:23Z",
      "updated_at": "2020-05-28T20:11:28Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "We in the @PowerShell/powershell-committee are going to holistically review this vs. #10984 next week in our RFC meeting. This one seems to match the RFC we approved (at least skimming through), while @KirkMunro's does not, but we want to also consider the `-splat` parameter as a possibility. \r\n\r\nThat being said, we did review the original RFC0002 and its feedback *very* extensively before accepting. ",
      "created_at": "2020-06-03T22:50:48Z",
      "updated_at": "2020-06-03T22:50:48Z"
    },
    {
      "author": "codykonior",
      "author_association": "NONE",
      "body": "I like -splat, only because @@{ feels so visually jarring and so much like a typo. ",
      "created_at": "2020-06-10T04:47:16Z",
      "updated_at": "2020-06-10T04:47:52Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Personally, I don't like either very much. `-Splat` feels out of place / could use a better name, perhaps. `@@{ ... }` as you say, feels more like a typo than useful syntax, though its brevity is nice.\r\n\r\nI don't have a compelling alternative, but I wish I did.",
      "created_at": "2020-06-10T04:52:07Z",
      "updated_at": "2020-06-10T04:52:07Z"
    },
    {
      "author": "johlju",
      "author_association": "NONE",
      "body": "I prefer `@@` since that would be more intuitive how splatting was done prior. Since there is an RFC that was approved for using `@@` then a PR that closest match that RFC should be merged. If there is anything more to be gained by instead use `-splat` that would need to be explained in another RFC. IMHO, until then the `-splat` PR can be closed.\r\n\r\nIt would be very strange to merge a PR that contradict an approved RFC without having another RFC to back it. \ud83e\udd14 ",
      "created_at": "2020-06-10T13:05:20Z",
      "updated_at": "2020-06-10T13:05:20Z"
    },
    {
      "author": "codykonior",
      "author_association": "NONE",
      "body": "People on Twitter literally requested that we weigh in on what we\u2019d prefer, so that\u2019s what we\u2019ve done. ",
      "created_at": "2020-06-10T13:22:55Z",
      "updated_at": "2020-06-10T13:22:55Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "I prefer `@@{...}` as well. I'd loathe seeing more ubiquitous parameters added. There are already plenty I have to wade through in completion lists.  I think there should be a **very high bar** for any new ubiquitous parameters.  To me `@@{...}` makes sense because I use the splat operator `@` to splat a hashtable. ",
      "created_at": "2020-06-10T17:06:56Z",
      "updated_at": "2020-06-10T17:06:56Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "The one real criticism I have for `@@{ ... }` as a syntax is that it is likely to be prone to typos, and if you happen to be using hashtables as actual parameters the difference between `@{ ... }` and `@@{ ... }` is a _very_ easy mistake to make.",
      "created_at": "2020-06-10T17:15:58Z",
      "updated_at": "2020-06-10T17:15:58Z"
    },
    {
      "author": "ChrisWarwick",
      "author_association": "NONE",
      "body": "> I like -splat, only because @@{ feels so visually jarring and so much like a typo.\r\n\r\nI *dislike* @@{ for the same reason; this is starting to look very Perl-like; very mysterious and very un-PowerShell.  My humble opinion is that -splat is the better way.\r\n\r\n(Throwing in my knee-jerk reaction after seeing this brought up on Twitter)",
      "created_at": "2020-06-10T18:57:31Z",
      "updated_at": "2020-06-10T18:57:31Z"
    },
    {
      "author": "felixfbecker",
      "author_association": "CONTRIBUTOR",
      "body": "`@@{ }` also is very intuitive to me. `@` is already the splat operator, we're just making it also accept a hastable expression `@{ }`.\r\n\r\nAn extra parameter, that _magically affects other parameters_ is a lot harder to wrap my head around. It is also less clear to me in terms of precedence - i.e. what if you provide some parameters but also the `-Splat` parameter in different order. Currently the order of named parameters in PowerShell doesn't matter and that is a great invariant. It wouldn't be clear to me anymore whether that is the case or not with a `-Splat` parameter.\r\n\r\nI see the point of saying \"explicit, spelled out is better than a symbol\" but `@` _is already_ the splat operator. Consistency in language design is important. And the meaning of the word \"splat\" really is not obvious to newcomers either.",
      "created_at": "2020-06-10T19:15:47Z",
      "updated_at": "2020-06-10T19:17:12Z"
    },
    {
      "author": "ChrisWarwick",
      "author_association": "NONE",
      "body": "> Currently the order of named parameters in PowerShell doesn't matter and that is a great invariant\r\n\r\nA very good point, and something my knee-jerk reaction hadn't considered. \r\n\r\nI still shudder at the proposed syntax. I get the point the you and Keith make about @ being the splatting operator already (so splatting a hashtable follows). I also imagine that the actual real-world use may mean that beginners aren't heavily impacted. I guess I'm just subliminally recalling those occasions when I opened a Perl script *that I'd written* and wondered if I'd been stoned at the time. It's the aesthetics rather than the basic lexicography. \r\n",
      "created_at": "2020-06-10T19:34:49Z",
      "updated_at": "2020-06-10T19:34:49Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@jamesbru mentioned briefly during the weekly PowerLunch community chat a possibility that I like a little more; `Command-Name -@ @{ ... }` (he can correct me if I misunderstood his idea in any way ^^)\r\n\r\nIt's a nice medium between this implementation and `-splat`, doesn't occlude an otherwise potentially valid parameter name, and keeps most of the look of this implementation. It may be a little more complicated to work into parsing, however, since it would need to branch off from the usual command parameter parsing (`-@` is not currently parsed as a valid parameter, but _is_ considered a valid positional argument currently.)",
      "created_at": "2020-06-10T20:45:14Z",
      "updated_at": "2020-06-10T20:45:25Z"
    },
    {
      "author": "oising",
      "author_association": "CONTRIBUTOR",
      "body": "I prefer `@@{ ... }` -- it's more intuitive to me. ",
      "created_at": "2020-06-11T01:33:55Z",
      "updated_at": "2020-06-11T01:33:55Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "I have to admit that `-@` has the elegance of only applying to commands, so we don't have to think about what `@@{ ... }` means when not being passed to a command as a parameter.\r\n\r\nHowever, I think my personal preference is for a splat sigil or operator:\r\n\r\n- Ubiquitous parameters that do special strange things conflate syntax and parameter value passing too much for my liking\r\n- We already have `@var`, which doesn't square well with `-@`; the different sigil implies to me that the shape of the peg has changed, whereas the `-@` implies that the shape of the hole has. My mental schema of splatting is now inconsistent juggling both at once\r\n- We also support multiple splatting today (example below). This makes it harder for `-@`, since currently PowerShell does not allow duplicate parameter names.\r\n\r\n```powershell\r\n> $x = 1,2,3\r\n> $y = @{ d = 'a'; e = 'b' }\r\n> $z = @{ f = 'Duck'; g = 'Banana' }\r\n> function Test($a, $b, $c, $d, $e, $f, $g) { $a; $b; $c; $d; $e; $f; $g }\r\n> Test @x @y @z\r\n1\r\n2\r\n3\r\na\r\nb\r\nDuck\r\nBanana\r\n```",
      "created_at": "2020-06-11T01:45:55Z",
      "updated_at": "2020-06-11T01:45:55Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@rjmholt `-@` is actually never parsed as a parameter name currently, so it would need changes to parsing as it is, there shouldn't be any additional issues compared to implementing `@@{...}`. It parses as a positional value only at the moment. If anything, it can easily take a shortcut out of the parameter parsing mode since `-@` is already an invalid parameter name. \ud83d\ude42 \r\n\r\nIn my opinion `-@` would be nicer & potentially clearer, but I understand everyone has their own preferences. ^^",
      "created_at": "2020-06-11T01:50:48Z",
      "updated_at": "2020-06-11T01:52:17Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "> -@ is actually never parsed as a parameter name currently\r\n\r\nYeah I get that, saw above you said it currently parses as a bareword literal. But my concerns are both more and less technical than that:\r\n\r\n- Changing parsing would need to be done either in the parser (probably the wrong place) or the parameter binder (more likely), and that would be difficult to implement correctly.\r\n- More importantly, irrespective of how the implementation treats it, the language is a human/computer interaction interface, and the question in my mind is how users who are used to PowerShell will parse it. It looks like any other parameter, just with a strange name. But to what extent will it obey the existing parameter conventions? I think the fact we would need a very different code path to deal with it is a warning sign that it would probably open up a number of cases where what users expect and what it does differ.",
      "created_at": "2020-06-11T01:58:34Z",
      "updated_at": "2020-06-11T01:58:34Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "> We also support multiple splatting today (example below). This makes it harder for -@, since currently PowerShell does not allow duplicate parameter names.\r\n\r\n@rjmholt That wouldn't be an issue if -@ accepted an array, like the -splat PR already does (IIRC -- it's been a while).",
      "created_at": "2020-06-12T21:33:08Z",
      "updated_at": "2020-06-12T21:33:50Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "Also this discussion goes a little further than simply the syntactical differences between `@@{...}` and `-splat @{}`.\r\n\r\nThe latter also supports splatting properties or method results, such as:\r\n\r\n```powershell\r\nfunction Do-This {\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$Value\r\n    )\r\n    $sb = {\r\n        # $PSBoundParameters is empty in this child scope, but $PSCmdlet.MyInvocation.BoundParameters is not\r\n        Invoke-Something -splat $PSCmdlet.MyInvocation.BoundParameters\r\n    }\r\n    & $sb\r\n}\r\n```\r\n\r\nIn general, the `-splat` syntax supports more options, and if we accept `-@` as an alias, replace `-splat` with `-@`, or just leave it as `-splat`, I feel we're making something that is much better for the non-developer and less experienced population of PowerShell scripters.\r\n\r\nAlso related, for splatting properties or method results, there is a separate PR (#11003) that supports doing that with the normal splat operator that we all use now (e.g. `Invoke-Something @PSCmdlet.MyInvocation.BoundParameters`). It's been so long I forgot that I had that other PR open independent of the `-splat` PR. Just calling that out to raise some awareness for anyone reading this PR discussion about the options that are available.",
      "created_at": "2020-06-12T21:39:44Z",
      "updated_at": "2020-06-14T15:24:59Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "@PoshChan please retry macos",
      "created_at": "2020-06-12T22:53:23Z",
      "updated_at": "2020-06-12T22:53:23Z"
    },
    {
      "author": "PoshChan",
      "author_association": "COLLABORATOR",
      "body": "@bergmeister, did not find matching build context: `PowerShell-CI-macOS`; allowed contexts: PowerShell-CI-SSH",
      "created_at": "2020-06-12T22:54:16Z",
      "updated_at": "2020-06-12T22:54:16Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee discussed this in context of [RFC0002](https://github.com/PowerShell/PowerShell-RFC/blob/master/2-Draft-Accepted/RFC0002-Generalized-Splatting.md) where we decided that we would withdraw RFC0002 with the exception of fixing the issue to allow explicit parameters to override a splatted hashtable and discuss named parameters for .NET method invocation as a separate issue.  So in light of that, we will be closing this PR as discussed with @bergmeister ",
      "created_at": "2020-07-22T22:43:24Z",
      "updated_at": "2020-07-22T22:43:24Z"
    },
    {
      "author": "SeidChr",
      "author_association": "NONE",
      "body": "no -splat, no -@, no @@ yet, will there be anything like that in the future? It seems like all approaches to improve splatting and thus usability are declined. Is there anything else in the work?",
      "created_at": "2021-05-26T13:16:08Z",
      "updated_at": "2021-05-26T13:16:08Z"
    }
  ],
  "created_at": "2019-07-07T14:22:46Z",
  "number": 10073,
  "state": "closed",
  "title": "Add @@ syntax for inline splatting as hashtable as new experimental feature PSGeneralizedSplatting",
  "updated_at": "2021-05-26T13:16:08Z"
}