{
  "_url": "https://github.com/PowerShell/PowerShell/issues/16889",
  "author": "daxian-dbw",
  "body": "# PR Summary\r\n\r\nRelated to #2083\r\n\r\nRefactor module assembly loading logic to allow the whole module to be loaded in a custom ALC.\r\n\r\n## PR Context\r\n\r\nThe document [Loading through .NET Core Assembly Load Contexts](https://docs.microsoft.com/en-us/powershell/scripting/dev-cross-plat/resolving-dependency-conflicts?view=powershell-7.2#loading-through-net-core-assembly-load-contexts) introduces a technique to allow a module author to fully control the potentially conflicting dependencies by leveraging a custom `AssemblyLoadContext`. This technique was used by the [Bicep](https://github.com/PSBicep/PSBicep) module, and have a great example documented in this blog post: [Resolving PowerShell Module Conflicts](https://pipe.how/get-assemblyloadcontext/).\r\n\r\nThis technique requires the use of dependency assemblies to be wrapped in a \"bridge\" assembly. The true module assemblies will need to reference the \"bridge\" assembly, depending on which to pull in the real dependencies. It's usually not easy to satisfy that requirement, especially for an existing module, that often means significant refactoring.\r\n\r\nThis PR refactors how assembly loading works during module loading. It leverages the existing-but-not-really-used `AssemblyCache` to make sure a nested module assembly or a root module assembly will not be loaded into the default ALC when they are designed to be loaded by a custom ALC of the module.\r\n\r\nWith the changes in this PR, we don't need the \"bridge\" assembly anymore, the real nested/root module assemblies can be directly loaded in a custom ALC, which handles all their dependencies in an isolated way.\r\n\r\n## Example\r\n\r\nThe `IsolatedModule` located at `<repo-root>\\test\\tools\\Modules\\IsolatedModule` serves as an example of such a module, and it's also used in our test.\r\nThe module assemblies are published by `<repo-root>\\test\\tools\\TestAlc`. Simply run `dotnet publish` in this folder to populate the assemblies to the folder `<repo-root>\\test\\tools\\Modules\\IsolatedModule` with the pre-defined folder structure.\r\n\r\nThe layout of files in `IsolatedModule` is:\r\n```\r\n\u2502   IsolatedModule.psd1\r\n\u2502   Test.Isolated.Init.dll\r\n\u2502\r\n\u2514\u2500\u2500\u2500Dependencies\r\n        Newtonsoft.Json.dll\r\n        Test.Isolated.Nested.dll\r\n        Test.Isolated.Root.dll\r\n```\r\nThe content of `IsolatedModule.psd1` is:\r\n```\r\n@{\r\n    ModuleVersion = '0.0.1'\r\n    GUID = '20d4742b-b17d-4ce8-b8da-29b25433cd18'\r\n    Author = 'Microsoft Corporation'\r\n\r\n    RootModule = 'Test.Isolated.Root.dll'\r\n    NestedModules = @('Test.Isolated.Init.dll', 'Test.Isolated.Nested.dll')\r\n    FunctionsToExport = @()\r\n    CmdletsToExport = @('Test-NestedCommand', 'Test-RootCommand')\r\n    VariablesToExport = '*'\r\n    AliasesToExport = @()\r\n}\r\n```\r\n\r\nThe nested module `Test.Isolated.Init.dll` is the only one that PowerShell can discover under the module base folder. It contains a custom ALC implementation and will set up the `Resolving` handler to handle loading the real module assemblies `Test.Isolated.Nested.dll` and `Test.Isolated.Root.dll`.\r\n\r\nThe processing order for module loading is `RequiredAssemblies` -> `NestedModules` -> `RootModule`.\r\nIn this example, `Test.Isolated.Init.dll` is the first nested module and it gets processed first. After that, `Resovling` handler has been setup to deal with `Test.Isolated.Nested.dll` and `Test.Isolated.Root.dll`. PowerShell won't be able to locate those 2 assemblies, so it's up to the `Resovling` handler to load them in the custom ALC.\r\n\r\n`Test.Isolated.Nested.dll` depends on the `10.0.0.0` version of `Newtonsoft.Json.dll`, which will be loaded by the custom ALC when requested.\r\n\r\nAll module assemblies will be put in the `AssemblyCache`, and PowerShell type resolution always searches `AssemblyCache` first (existing behavior). So, public types exposed by `Test.Isolated.Nested.dll` and `Test.Isolated.Root.dll` will be resolvable, but the specific `Newtonsoft.Json.dll` under the `Dependencies` folder will always be invisible to PowerShell.\r\n\r\n> NOTE: As is called in the processing order, `RequiredAssemblies` are first processed, by which time the `Resolving` handler hasn't been setup yet. So, it's impossible to load required assemblies into the module's custom ALC. But `RequiredAssemblies` is more commonly used by script module instead of binary module.\r\n\r\n## PR Checklist\r\n\r\n- [x] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [x] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [ ] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` or `[ WIP ]` to the beginning of the title (the `WIP` bot will keep its status check at `Pending` while the prefix is present) and remove the prefix when the PR is ready.\r\n- **[Breaking changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)**\r\n    - [x] None\r\n    - **OR**\r\n    - [ ] [Experimental feature(s) needed](https://github.com/MicrosoftDocs/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/About/about_Experimental_Features.md)\r\n        - [ ] Experimental feature name(s): <!-- Experimental feature name(s) here -->\r\n- **User-facing changes**\r\n    - [x] Not Applicable\r\n    - **OR**\r\n    - [ ] [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [ ] Issue filed: <!-- Number/link of that issue here -->\r\n- **Testing - New and feature**\r\n    - [ ] N/A or can only be tested interactively\r\n    - **OR**\r\n    - [x] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n- **Tooling**\r\n    - [x] I have considered the user experience from a tooling perspective and don't believe tooling will be impacted.\r\n",
  "closed_at": "2022-02-23T23:01:12Z",
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@daxian-dbw Is it all only about binary modules?\r\nIf I remember right we discussed `Import-Module -Isolate` to put whole module in custom dynamic-created ALC with _generic handler_ - do you consider this?",
      "created_at": "2022-02-17T06:56:03Z",
      "updated_at": "2022-02-17T06:56:03Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "This is only for binary module, and only for binary modules that do not use types from the conflicting assembly as parameter type or return type.\r\n\r\nWe are not going with the \"Import-Module -Isolated\" approach because of the type-identity issue. An end user won't really understand how the module is supposed to work, and allowing the end user to choose whether or not to import a module to a custom ALC just won't work -- the end user will run into the type-identity issue without a clue of what's going on, and will just believe it's a broken feature.\r\n\r\nWe have discussed this in the [RFC](https://github.com/PowerShell/PowerShell-RFC/pull/298) in length, and it's clear that it's the module author's responsibility to avoid conflicts, and our job is to make that easier.",
      "created_at": "2022-02-17T17:05:47Z",
      "updated_at": "2022-02-17T17:05:47Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": ">  Newtonsoft.Json.dll\r\n\r\nCan we replace the dll with custom test dll? Newtonsoft is updated frequently (with security fixes too) and we will have to track and update it.",
      "created_at": "2022-02-17T17:20:18Z",
      "updated_at": "2022-02-17T17:20:18Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "No need to update the version in the test. The test is deliberately using an old version `10.0.0.1` to indicate that it can depends on specific version of the assembly without being affected by what PowerShell is using.",
      "created_at": "2022-02-17T17:25:41Z",
      "updated_at": "2022-02-17T17:25:41Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> No need to update the version in the test.\r\n\r\nI hope MSFT compliance CIs pass this :-)",
      "created_at": "2022-02-17T17:27:23Z",
      "updated_at": "2022-02-17T17:27:23Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@PaulHigin Thanks for the review! I will review the comments to make them more descriptive and with more details.",
      "created_at": "2022-02-17T22:57:25Z",
      "updated_at": "2022-02-17T22:57:25Z"
    },
    {
      "author": "pull-request-quantifier[bot]",
      "author_association": "NONE",
      "body": "### ![](https://img.shields.io/static/v1?label=Quantified&message=Extra%20Large&color=red)\r\n\r\nThis PR has `662` quantified lines of changes. In general, a change size of upto `200` lines is ideal for the best PR experience!\r\n\r\n------\r\n\r\n<details >\r\n    <summary display=\"inline\"> <strong>Quantification details</strong></summary>\r\n    <p />\r\n\r\n```\r\nLabel      : Extra Large\r\nSize       : +412 -250\r\nPercentile : 88.73%\r\n\r\nTotal files changed: 16\r\n\r\nChange summary by file extension:\r\n.psm1 : +11 -5\r\n.cs : +277 -244\r\n.ps1 : +65 -1\r\n.psd1 : +13 -0\r\n.sln : +0 -0\r\n.csproj : +46 -0\r\n```\r\n> Change counts above are quantified counts, based on the [PullRequestQuantifier customizations](https://github.com/microsoft/PullRequestQuantifier/blob/main/docs/prquantifier-yaml.md).\r\n    \r\n</details>\r\n\r\n\r\n<details>\r\n    <summary display=\"inline\"> <strong>Why proper sizing of changes matters</strong> </summary>\r\n    <p/>\r\n    <p/>\r\n\r\nOptimal pull request sizes drive a better predictable PR flow as they strike a\r\nbalance between between PR complexity and PR review overhead. PRs within the\r\noptimal size (typical small, or medium sized PRs) mean:\r\n\r\n- Fast and predictable releases to production:\r\n  - Optimal size changes are more likely to be reviewed faster with fewer\r\niterations.\r\n  - Similarity in low PR complexity drives similar review times.\r\n- Review quality is likely higher as complexity is lower:\r\n  - Bugs are more likely to be detected.\r\n  - Code inconsistencies are more likely to be detetcted.\r\n- Knowledge sharing is improved within the participants:\r\n  - Small portions can be assimilated better.\r\n- Better engineering practices are exercised:\r\n  - Solving big problems by dividing them in well contained, smaller problems.\r\n  - Exercising separation of concerns within the code changes.\r\n\r\n#### What can I do to optimize my changes\r\n\r\n- Use the PullRequestQuantifier to quantify your PR accurately\r\n  - Create a context profile for your repo using the [context generator](https://github.com/microsoft/PullRequestQuantifier/releases)\r\n  - Exclude files that are not necessary to be reviewed or do not increase the review complexity. Example: Autogenerated code, docs, project IDE setting files, binaries, etc. Check out the `Excluded` section from your `prquantifier.yaml` context profile. \r\n  - Understand your typical change complexity, drive towards the desired complexity by adjusting the label mapping in your `prquantifier.yaml` context profile.\r\n  - Only use the labels that matter to you, [see context specification](./docs/prquantifier-yaml.md) to customize your `prquantifier.yaml` context profile.\r\n- Change your engineering behaviors\r\n  - For PRs that fall outside of the desired spectrum, review the details and check if:\r\n    - Your PR could be split in smaller, self-contained PRs instead\r\n    - Your PR only solves one particular issue. (For example, don't refactor and code new features in the same PR).\r\n\r\n#### How to interpret the change counts in git diff output\r\n\r\n- One line was added: `+1 -0`\r\n- One line was deleted: `+0 -1`\r\n- One line was modified: `+1 -1` (git diff doesn't know about modified, it will\r\ninterpret that line like one addition plus one deletion)\r\n- Change percentiles: Change characteristics (addition, deletion, modification)\r\nof this PR in relation to all other PRs within the repository.\r\n\r\n</details>\r\n\r\n<p />\r\n\r\n------\r\n\r\nWas this comment helpful? <a href=\"https://pullrequestquantifierfeedback.azurewebsites.net/feedback?payload=eyJBdXRob3JOYW1lIjoiZGF4aWFuLWRidyIsIlJlcG9zaXRvcnlMaW5rIjoiaHR0cHM6Ly9naXRodWIuY29tL1Bvd2VyU2hlbGwvUG93ZXJTaGVsbCIsIlB1bGxSZXF1ZXN0TGluayI6Imh0dHBzOi8vZ2l0aHViLmNvbS9Qb3dlclNoZWxsL1Bvd2VyU2hlbGwvcHVsbC8xNjg4OSIsIkV2ZW50VHlwZSI6IlRodW1ic1VwIn0=&amp;anonymous=True\" target=\"_blank\" title=\"Thumbs up\"><strong>:thumbsup:</strong></a> <a href=\"https://pullrequestquantifierfeedback.azurewebsites.net/feedback?payload=eyJBdXRob3JOYW1lIjoiZGF4aWFuLWRidyIsIlJlcG9zaXRvcnlMaW5rIjoiaHR0cHM6Ly9naXRodWIuY29tL1Bvd2VyU2hlbGwvUG93ZXJTaGVsbCIsIlB1bGxSZXF1ZXN0TGluayI6Imh0dHBzOi8vZ2l0aHViLmNvbS9Qb3dlclNoZWxsL1Bvd2VyU2hlbGwvcHVsbC8xNjg4OSIsIkV2ZW50VHlwZSI6Ik5ldXRyYWwifQ==&amp;anonymous=True\" target=\"_blank\" title=\"Neutral\"><strong>&nbsp;:ok_hand:</strong></a> <a href=\"https://pullrequestquantifierfeedback.azurewebsites.net/feedback?payload=eyJBdXRob3JOYW1lIjoiZGF4aWFuLWRidyIsIlJlcG9zaXRvcnlMaW5rIjoiaHR0cHM6Ly9naXRodWIuY29tL1Bvd2VyU2hlbGwvUG93ZXJTaGVsbCIsIlB1bGxSZXF1ZXN0TGluayI6Imh0dHBzOi8vZ2l0aHViLmNvbS9Qb3dlclNoZWxsL1Bvd2VyU2hlbGwvcHVsbC8xNjg4OSIsIkV2ZW50VHlwZSI6IlRodW1ic0Rvd24ifQ==&amp;anonymous=True\" target=\"_blank\" title=\"Thumbs down\"><strong>&nbsp;:thumbsdown:</strong></a> (<a href=\"MAILTO:prquantifier@microsoft.com\" title=\"Mail to prquantifier@microsoft.com\">Email</a>)\r\n[Customize PullRequestQuantifier](https://github.com/PowerShell/PowerShell/blob/master/.github/prquantifier.yaml) for this repository.\r\n\r\n",
      "created_at": "2022-02-18T17:30:06Z",
      "updated_at": "2022-02-18T17:30:06Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@daxian-dbw I forget ask about processing native dll-s. I don't see the scenarios in description and tests. Do you consider this?",
      "created_at": "2022-02-18T18:01:20Z",
      "updated_at": "2022-02-18T18:01:20Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "No special handling to native dlls. A module author can register the `ResolvingUnmanagedDll` event to the custom ALC, which will take precedence when resolving native dlls.",
      "created_at": "2022-02-18T18:14:42Z",
      "updated_at": "2022-02-18T18:14:42Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Great!",
      "created_at": "2022-02-24T03:17:59Z",
      "updated_at": "2022-02-24T03:17:59Z"
    }
  ],
  "created_at": "2022-02-16T21:17:07Z",
  "number": 16889,
  "state": "closed",
  "title": "Refactor module assembly loading logic to allow the whole module to be loaded in a custom ALC",
  "updated_at": "2022-02-24T03:18:00Z"
}