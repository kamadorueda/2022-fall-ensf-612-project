{
  "_url": "https://github.com/PowerShell/PowerShell/issues/12926",
  "author": "vexx32",
  "body": "## Summary of the new feature/enhancement\r\n\r\nCurrently, finding event metadata is pretty difficult in PS. The event members are deliberately hidden from autocompletion, can't be directly accessed from objects like methods can to reveal metadata which is often useful in determining how you want to work with them, and aren't available for autocompletion.\r\n\r\nAdditionally, while `Register-EngineEvent` and `Register-ObjectEvent` do exist, they won't always work. For example, using some GUI-centric script patterns, many users can run into deadlocks using `Register-ObjectEvent` and some Forms classes.\r\n\r\nTo work around this, many scripters resort to using the hidden `$obj.add_EventName($handler)` methods which are not discoverable, not well-documented (as they are generally considered an implementation detail), and difficult to work with in PS.\r\n\r\nMost documentation around events is C#-centric and will recommend the C# syntax for registering and deregistering delegates; `obj.EventName += eventHandler;`\r\n\r\nThis creates friction and confusion; users have neither appropriate access to event metadata to determine how to work with them in PS, nor appropriate documentation to fill in the gaps where Register-ObjectEvent isn't a workable solution. Additionally, even discovering event names for use with Register-ObjectEvent is difficult since the members aren't directly available.\r\n\r\n## Proposed technical implementation details (optional)\r\n\r\n1. Expose event members as actual object members, allowing their names to register for tab completion, and the PSEvent metadata to be shown to users accessing the event.\r\n2. Implement a custom binder for use with `+=` / `-=` which bridges the gap by calling the appropriate `add_*` / `remove_*` method for the targeted event.\r\n3. Add some logic into the Compiler to perform a runtime check for LHS being a PSEvent when handling expressions with `+=` or `-=` operators (this will be dependent on #1 being implemented, or this check cannot be relied on). If the LHS is PSEvent, call out to the binder from #2 and (de)register the event. Naturally, fall back to standard `+=` behaviour if the LHS is not `PSEvent`.\r\n\r\n### Demonstration\r\n\r\n```ps1\r\nPS> $ps = [powershell]::Create()\r\nPS> $handler = { Write-Host \"event triggered!\" }\r\n# Tab completion lists the event member as well\r\nPS> $ps.Invo\r\nInvocationStateInfo     Invoke                  InvokeAsync             InvocationStateChanged  \r\nPS> $ps.InvocationStateChanged += $handler\r\nPS> $ps.AddScript('Write-Output \"data from pipe\"').Invoke()\r\nevent triggered!\r\nevent triggered!\r\ndata from pipe\r\nPS> $ps.InvocationStateChanged -= $handler\r\nPS> $ps.AddScript('Write-Output \"data from pipe\"').Invoke()\r\ndata from pipe\r\n```\r\n\r\nI have working code for this that I can submit as a PR if there is interest in having this be a part of PowerShell. Just have to put some tests together \ud83d\ude0e \r\n\r\nBelow illustrates the metadata event members would show if users attempt to examine them, once the aforementioned changes are in place.\r\n\r\n```\r\nPS> $ps.InvocationStateChanged\r\n\r\nMemberType      : Event\r\nValue           : System.EventHandler`1[System.Management.Automation.PSInvocationStateChangedEventArgs] InvocationStateChanged\r\nTypeNameOfValue : System.Management.Automation.PSEvent\r\nName            : InvocationStateChanged\r\nIsInstance      : True\r\n\r\n\r\nPS /Users/joelfrancis/repos/Github/powershell> $ps.InvocationStateChanged.Value\r\n\r\nMemberType       : Event\r\nName             : InvocationStateChanged\r\nDeclaringType    : System.Management.Automation.PowerShell\r\nReflectedType    : System.Management.Automation.PowerShell\r\nMetadataToken    : 335544336\r\nModule           : System.Management.Automation.dll\r\nAttributes       : None\r\nIsSpecialName    : False\r\nAddMethod        : Void add_InvocationStateChanged(System.EventHandler`1[System.Management.Automation.PSInvocationStateChangedEventArgs])\r\nRemoveMethod     : Void remove_InvocationStateChanged(System.EventHandler`1[System.Management.Automation.PSInvocationStateChangedEventArgs])\r\nRaiseMethod      : \r\nIsMulticast      : True\r\nEventHandlerType : System.EventHandler`1[System.Management.Automation.PSInvocationStateChangedEventArgs]\r\nCustomAttributes : {}\r\nIsCollectible    : True\r\n\r\n\r\nPS> $ps.InvocationStateChanged.GetType()\r\n\r\nIsPublic IsSerial Name                                     BaseType\r\n-------- -------- ----                                     --------\r\nTrue     False    PSEvent                                  System.Management.Automation.PSMemberInfo\r\n\r\nPS> $ps.InvocationStateChanged.Value.GetType()\r\n\r\nIsPublic IsSerial Name                                     BaseType\r\n-------- -------- ----                                     --------\r\nFalse    False    RuntimeEventInfo                         System.Reflection.EventInfo\r\n```\r\n",
  "closed_at": null,
  "comments": [],
  "created_at": "2020-06-09T14:13:49Z",
  "number": 12926,
  "state": "open",
  "title": "Improve discoverability and support for (de)registering event handlers",
  "updated_at": "2020-06-10T12:08:13Z"
}