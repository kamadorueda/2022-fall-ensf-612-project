{
  "_url": "https://github.com/PowerShell/PowerShell/issues/9295",
  "author": "msftrncs",
  "body": "After upgrading to PowerShell 6.2, from 6.1.3, and removing PowerShell 6 Preview (6.2 RC 1), PowerShell often will not start.  The window appears, powershell looks like its starting, and then the window closes.    Several attempts are usually needed to get a window to successfully get to a prompt.\r\n\r\nAll the update/uninstall process was done at one time.  I have two different machines that seem to be exhibiting this issue, but I don't have any that are not.\r\n\r\n# Environment data\r\n\r\n```none\r\nName                           Value\r\n----                           -----\r\nPSVersion                      6.2.0\r\nPSEdition                      Core\r\nGitCommitId                    6.2.0\r\nOS                             Microsoft Windows 10.0.17763\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\nMy other machine is running the most recent Windows 19H1 Insiders Preview.\r\n\r\nI am also experiencing a lot of crashing in VS Code's PowerShell 2.0.1 extension with certain documents open, but at least PowerShell 6.2 usually opens fine in the 'integrated console' of the extension.  May or may not be related, but I am not seeing anyone posting on that topic either.\r\n\r\nLet me know if there is any other data I can include.\r\n\r\nNote I originally had trouble with earlier updates to the preview releases, see #8442.  I have not reviewed the condition there as in this case, PowerShell does usually open if I keep trying.",
  "closed_at": "2019-07-09T20:14:50Z",
  "comments": [
    {
      "author": "msftrncs",
      "author_association": "CONTRIBUTOR",
      "body": "It may be related to VS Code or the PowerShell extension on VS Code.   After rebooting my system, I was able to immediately open PowerShell with no issue.  With VS Code open, non-administrative sessions of PowerShell refuse to stay open.  Even after closing VS Code, PowerShell seems to refuse reliably opening.",
      "created_at": "2019-04-04T20:52:33Z",
      "updated_at": "2019-04-04T20:52:33Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "You could run PowerShell Core from cmd.exe and see an error message.",
      "created_at": "2019-04-05T17:37:20Z",
      "updated_at": "2019-04-05T17:37:20Z"
    },
    {
      "author": "msftrncs",
      "author_association": "CONTRIBUTOR",
      "body": "When I try to open PWSH from CMD at prompt, PowerShell starts fine.  Even with that session of PowerShell open, attempting to open it from a taskbar icon results in it not opening.  I also tried typing PWSH in an Explorer address bar and get same no-open result.\r\n\r\nBy not opening, this is what happens.   A window pops up, and has the header info:\r\n```\r\nPowerShell 6.2.0\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\n\r\nhttps://aka.ms/pscore6-docs\r\nType 'help' to get help.\r\n````\r\nThe command prompt never appears, and after a short delay, the window closes.\r\n\r\nIf I leave the system for a while (minutes, maybe 10 minutes, but I do continue doing other tasks on the system) then opening PowerShell works fine.   I've been able to kind of repeat the pattern.  After PowerShell is opening fine, I close VS Code (if it was even open), wait a bit, reopen VS Code, wait a bit (maybe a minute) and then PowerShell fails opening again, and this remains again for some period of time.\r\n\r\nI tried repeating all this on my 19H1 insiders machine last night, and it would not repeat past the first time.  The first time opening PowerShell failed, but every subsequent time worked, even after a reboot.",
      "created_at": "2019-04-05T17:50:40Z",
      "updated_at": "2019-04-05T17:50:40Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> When I try to open PWSH from CMD at prompt,\r\n\r\nAlways?\r\n\r\nIf you open PowerShell Core home directory and double click on pwsh.exe - does it start well in any time?",
      "created_at": "2019-04-05T17:56:49Z",
      "updated_at": "2019-04-05T17:56:49Z"
    },
    {
      "author": "msftrncs",
      "author_association": "CONTRIBUTOR",
      "body": "> > When I try to open PWSH from CMD at prompt,\r\n\r\n> Always?\r\n\r\nSo far.   I would try a PWSH window, it would fail, I would open CMD, type PWSH, it started fine, try another PWSH window, it would fail.  EXIT the CMD instance of PWSH and try again, it would open just fine again.  I'd keep repeating, closing CMD window entirely, starting over, still PWSH at a CMD prompt seems to be always working.\r\n\r\nAlso, I will not completely swear, that even after an instance of a PWSH window successfully opens, attempting again a few minutes later and it won't open again, without any particular reason I can so far deduce.",
      "created_at": "2019-04-05T18:02:53Z",
      "updated_at": "2019-04-05T18:02:53Z"
    },
    {
      "author": "msftrncs",
      "author_association": "CONTRIBUTOR",
      "body": "> If you open PowerShell Core home directory and double click on pwsh.exe - does it start well in any time?\r\n\r\nIt seems to be the same no-open condition.  This is weird though, because directly clicking on EXE file seems to result in the same no-open condition most the time, but clicking on the short-cut stored in the start menu folder seems more sporadic, often opening successfully, but definitely not always.",
      "created_at": "2019-04-05T18:27:39Z",
      "updated_at": "2019-04-05T18:28:31Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Windows OS keeps a window parameters for every (console) application. It seems the parameters is broken and we need clean up them from registry.",
      "created_at": "2019-04-05T18:31:57Z",
      "updated_at": "2019-04-05T18:32:24Z"
    },
    {
      "author": "cpmcgrath",
      "author_association": "NONE",
      "body": "I'm experiencing this too. If it helps, the following appears in the Event Viewer:\r\n```none\r\nSource: .NET Runtime\r\nApplication: pwsh.exe\r\nCoreCLR Version: 4.6.27317.3\r\nDescription: The process was terminated due to an internal error in the .NET Runtime at IP 00007FF93A6B298E (00007FF93A6B0000) with exit code 80131506.\r\n```\r\n\r\n```none\r\nSource: Application Error\r\nFaulting application name: pwsh.exe, version: 6.2.0.0, time stamp: 0x5c410542\r\nFaulting module name: coreclr.dll, version: 4.6.27317.3, time stamp: 0x5c40be0f\r\nException code: 0xc0000005\r\nFault offset: 0x000000000000298e\r\nFaulting process id: 0x4f48\r\nFaulting application start time: 0x01d4f30cd62ddac2\r\nFaulting application path: C:\\Program Files\\PowerShell\\6\\pwsh.exe\r\nFaulting module path: C:\\Program Files\\PowerShell\\6\\coreclr.dll\r\nReport Id: 532d875c-683f-4640-bf93-310d5de00cb4\r\nFaulting package full name: \r\nFaulting package-relative application ID: \r\n```",
      "created_at": "2019-04-14T22:13:57Z",
      "updated_at": "2019-04-14T22:13:57Z"
    },
    {
      "author": "msftrncs",
      "author_association": "CONTRIBUTOR",
      "body": "Just like @cpmcgrath, I can confirm that I see the same thing in the application event log immediately after a failure to launch:\r\n(2 events)\r\n```\r\nApplication: pwsh.exe\r\nCoreCLR Version: 4.6.27317.3\r\nDescription: The process was terminated due to an internal error in the .NET Runtime at IP 00007FFFDDAB298E (00007FFFDDAB0000) with exit code 80131506.\r\n```\r\n```\r\nFaulting application name: pwsh.exe, version: 6.2.0.0, time stamp: 0x5c410542\r\nFaulting module name: coreclr.dll, version: 4.6.27317.3, time stamp: 0x5c40be0f\r\nException code: 0xc0000005\r\nFault offset: 0x000000000000298e\r\nFaulting process id: 0xc60\r\nFaulting application start time: 0x01d4f3a7d85fc982\r\nFaulting application path: C:\\Program Files\\PowerShell\\6\\pwsh.exe\r\nFaulting module path: C:\\Program Files\\PowerShell\\6\\coreclr.dll\r\nReport Id: 2d4862a8-7e13-4eeb-8d60-4ec7e2e74f30\r\nFaulting package full name: \r\nFaulting package-relative application ID: \r\n```\r\n\r\nI am still seeing this corelated to opening VS Code with the PowerShell Preview Extension, but I suppose other applications that use .Net could set up this condition as well.\r\n",
      "created_at": "2019-04-15T16:31:43Z",
      "updated_at": "2019-04-15T16:31:43Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@msftrncs Could you please compile and run debug build to get more info? Also it would be nice to get repo steps from you so that we can reproduce the problem on clean system.",
      "created_at": "2019-04-16T03:57:31Z",
      "updated_at": "2019-04-16T03:57:31Z"
    },
    {
      "author": "Antaris",
      "author_association": "NONE",
      "body": "I am experiencing this same issue.\r\n\r\nSource: Application Error\r\n```\r\nFaulting application name: pwsh.exe, version: 6.2.0.0, time stamp: 0x5c410542\r\nFaulting module name: coreclr.dll, version: 4.6.27317.3, time stamp: 0x5c40be0f\r\nException code: 0xc0000005\r\nFault offset: 0x000000000000298e\r\nFaulting process id: 0x4e64\r\nFaulting application start time: 0x01d520380945a490\r\nFaulting application path: C:\\Program Files\\PowerShell\\6\\pwsh.exe\r\nFaulting module path: C:\\Program Files\\PowerShell\\6\\coreclr.dll\r\nReport Id: 0fe828fd-a45e-4dc2-b7f0-77b07ecdba93\r\nFaulting package full name: \r\nFaulting package-relative application ID: \r\n```\r\n\r\nSource: .NET Runtime\r\n```\r\nApplication: pwsh.exe\r\nCoreCLR Version: 4.6.27317.3\r\nDescription: The process was terminated due to an internal error in the .NET Runtime at IP 00007FFC0240298E (00007FFC02400000) with exit code 80131506.\r\n```\r\n\r\nI've attached the information collected by Windows Error Reporting.\r\n[Report.zip](https://github.com/PowerShell/PowerShell/files/3275712/Report.zip)\r\n\r\nObservations:\r\n- I am running Windows v1903 (OS Build 18362.30)\r\n- I do have Visual Studio Code installed (v1.35.0) with the Powershell extension (v2019.5.0)\r\n- It seems to happen after a reboot\r\n- Profile load time does seem to take a while\r\n- It sometimes happens in Adminsitrative mode, and sometimes not\r\n- I have the `postgit` module installed as part of my profile, which is defined below:\r\n\r\n```\r\nImport-Module posh-git\r\n\r\n# Customise the Prompt\r\n$GitPromptSettings.DefaultPromptPrefix.Text = '$((Get-Date).ToShortTimeString()) ';\r\n$GitPromptSettings.DefaultPromptPrefix.ForegroundColor = [ConsoleColor]::Magenta;\r\n#$GitPromptSettings.DefaultPromptSuffix.Text = ' $(GitVersionForCurrentRepoPrefixed)`r`n\u03bb ';\r\n$GitPromptSettings.DefaultPromptSuffix.Text = '`r`n\u03bb ';\r\n```",
      "created_at": "2019-06-11T09:49:00Z",
      "updated_at": "2019-06-11T09:49:00Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@Antaris Thanks! Is your repo persistent? Can you repo with latest PowerShell Core build? ",
      "created_at": "2019-06-11T10:00:47Z",
      "updated_at": "2019-06-11T10:00:47Z"
    },
    {
      "author": "Antaris",
      "author_association": "NONE",
      "body": "It is not persistent, more intermittent. I'll try and download the latest build and see if that fixes it.",
      "created_at": "2019-06-11T10:04:34Z",
      "updated_at": "2019-06-11T10:04:34Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@Antaris If you can please fork the repo and build - with debug mode you could get more information in exception.\r\n\r\n@SteveL-MSFT  Should we be worried about 6.2 version?\r\n\r\n",
      "created_at": "2019-06-11T11:02:41Z",
      "updated_at": "2019-06-11T11:02:41Z"
    },
    {
      "author": "anmenaga",
      "author_association": "CONTRIBUTOR",
      "body": "Judging by faulting module name I have a feeling that is .NET problem. Similar thing happened before.\r\nMeanwhile, here is a simple way to get a dump of the crashing process with all details that will help greatly to investigate and fix. @Antaris - you can try [ProcDump utility](https://docs.microsoft.com/en-us/sysinternals/downloads/procdump):\r\n```\r\nRegister as the Just-in-Time (AeDebug) debugger. Makes full dumps in c:\\dumps.\r\nC:\\>procdump -ma -i c:\\dumps\r\n```\r\nThe next time PS crashes, the dump with detailed error info will be written to the specified folder.",
      "created_at": "2019-06-11T16:54:33Z",
      "updated_at": "2019-06-11T16:54:33Z"
    },
    {
      "author": "Antaris",
      "author_association": "NONE",
      "body": "@anmenaga \r\n\r\nI managed to trigger this experience this morning. Fresh re-start of my laptop. The first time I opened PowerShell Core, it was fine. I then used Visual Studio Code to read my PS Core profile, and initiated a save _without making alterations_. I then opened PowerShell Core and it immediately closed.\r\n\r\nDump file is here:\r\nhttps://drive.google.com/file/d/1KKeS3co8rE3w1xi3cFUPT21notKSmudT/view?usp=sharing\r\n\r\n@iSazonov Sorry, I haven't had time to test this against the current commit, I'll try and get that done this week",
      "created_at": "2019-06-12T06:16:57Z",
      "updated_at": "2019-06-12T07:10:16Z"
    },
    {
      "author": "anmenaga",
      "author_association": "CONTRIBUTOR",
      "body": "It looks like the Access violation is coming from under `TaskbarJumpList.CreateElevatedEntry`.\r\n@bergmeister , do you recall any stability issues with this function?\r\n```\r\nExceptionAddress: 00007fff471f298e (coreclr!InteropSyncBlockInfo::GetRCWAndIncrementUseCount+0x000000000000000a)\r\n   ExceptionCode: c0000005 (Access violation)\r\n  ExceptionFlags: 00000001\r\nNumberParameters: 2\r\n   Parameter[0]: 0000000000000000\r\n   Parameter[1]: 0000000000000018\r\nAttempt to read from address 0000000000000018\r\n\r\nPartial stack:\r\ncoreclr!InteropSyncBlockInfo::GetRCWAndIncrementUseCount+0xa\r\ncoreclr!RCWHolder::Init+0x16\r\ncoreclr!ComObject::SupportsInterface+0x101\r\ncoreclr!ObjIsInstanceOf+0x482\r\ncoreclr!JITutil_ChkCastAny+0x95\r\ncoreclr!JITutil_ChkCastInterface+0x2e\r\nMicrosoft_PowerShell_ConsoleHost!Microsoft.PowerShell.TaskbarJumpList.CreateElevatedEntry(System.String)+0x386\r\nMicrosoft_PowerShell_ConsoleHost!Microsoft.PowerShell.ConsoleHost+<>c.<Start>b__4_0()+0x14\r\n```\r\n\r\n",
      "created_at": "2019-06-12T16:31:18Z",
      "updated_at": "2019-06-12T16:31:18Z"
    },
    {
      "author": "Antaris",
      "author_association": "NONE",
      "body": "That would explain why this doesnt happen if I launch `pwsh` from the command line.",
      "created_at": "2019-06-12T16:53:01Z",
      "updated_at": "2019-06-12T16:53:01Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "We have seen reports of sporadic failures of it before and other people tried to improve the COM calls. In this case I rather suspect that the used Windows Insider build 19H1 might be a culprit as well.\r\nI ported the original C++ code from Windows PowerShell to C# using the same COM calls and used the Windows Api pack source code for the COM interface definitions.\r\nThe good news is that this code only runs when pwsh starts interactively and that the jumplist menu registration needs to happen only once (there is code that checks that implicitly). Maybe we should put a try{}catch block around it and only log out the failure stack trace?\r\nGenerally speaking, when I did it I had to port the full .Net code of the Windows Api Pack to .Net Core and tweak it to allow for a jumpstart entry with elevation. 2 weeks ago, WPF added the source code for JumpList and with a PR to allow for an elevated jumplist we could defer a lot of the work to just a few lines, but ultimately I think it is a .Net Core problem.",
      "created_at": "2019-06-12T17:43:52Z",
      "updated_at": "2019-06-12T21:11:43Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@bergmeister are you willing to take on this work?  Please :)",
      "created_at": "2019-06-12T20:53:11Z",
      "updated_at": "2019-06-12T20:53:11Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "I can try, the WPF API will need something like an added boolean parameter (defaulting to false) to make the jumplist entry open the application in elevated mode. It will depend on how flexible the WPF guys are in terms of willing to accept the API change and how hard it is to get a PR merged but I think it will be race against time because .Net Core 3 wants to publish an RC around July (meaning that they are less likely to accept such changes after that time)....\r\nOtherwise the only alternative would be to try to catch the error (but to me this looks like an uncatchable, fatal CLR error).\r\nI myself have unfortunately never experienced such errors",
      "created_at": "2019-06-12T21:08:40Z",
      "updated_at": "2019-06-12T21:14:04Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "It seems a race condition in GUI.\r\n\r\n@SteveL-MSFT It is not clear about 6.2 version -  should we fix it too ?",
      "created_at": "2019-06-13T03:46:05Z",
      "updated_at": "2019-06-13T03:46:05Z"
    },
    {
      "author": "jlouros",
      "author_association": "NONE",
      "body": "Without any data to back up my next statement, it seems this issue almost never happens if I open PowerShell with 'Run as Administrator'",
      "created_at": "2019-06-13T08:24:57Z",
      "updated_at": "2019-06-13T13:06:51Z"
    },
    {
      "author": "Antaris",
      "author_association": "NONE",
      "body": "@jlouros I've experienced both running non-elevated, and running as an Adminstrator",
      "created_at": "2019-06-13T08:36:07Z",
      "updated_at": "2019-06-13T08:36:07Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "Does this happen for PS 7-preview1 as well? .Net Core 3 has improved COM interaction, it might be an issue of .Net Core 2.1.\r\nAlso: Maybe a similar improvement to the code similar to PR #7580 could help as well?",
      "created_at": "2019-06-13T11:21:03Z",
      "updated_at": "2019-06-13T11:21:03Z"
    },
    {
      "author": "msftrncs",
      "author_association": "CONTRIBUTOR",
      "body": "@bergmeister, I have had it happen with 7 preview as well, but much less often.   7 preview seems to give a CLR error dump, but it closes so quickly \u2026  but I got it:\r\n\r\n![image](https://user-images.githubusercontent.com/26179051/59439692-579fc500-8dbb-11e9-87dc-8e19f743ca4e.png)\r\n\r\nI also don't experience this nearly as much when running 'as administrator', as @jlouros mentions, but as @Antaris said, it does still ocassionally happen.",
      "created_at": "2019-06-13T14:13:23Z",
      "updated_at": "2019-06-13T14:13:23Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "We could get more information with debug build (we ignore errors in release build in the code!)",
      "created_at": "2019-06-13T14:30:21Z",
      "updated_at": "2019-06-13T14:30:21Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT  I opened an API proposal in WPF to get a sign off first (the proposed change is non-breaking, so it should be OK) and included some low level implementation details. I have not looked at the WPF code itself in detail but it should not be too difficult (the hardest part might be the testing)\r\nhttps://github.com/dotnet/wpf/issues/950\r\nThis would be the way forward for PowerShell 7, as I start reading the WPF code in more detail, I will try to compare it to my implementation and see if I can improve the COM calls, I am wondering if this is a problem of the `AppartmentState` being `MTA` because I basically translated the C++ Windows PowerShell code to C# and used the interface definitions from the Windows API back when I originally did the implementation",
      "created_at": "2019-06-13T22:10:26Z",
      "updated_at": "2019-06-13T22:16:59Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@bergmeister I think for now, perhaps the interim solution is to wrap it in try...catch so that pwsh at least starts.  We can take that fix to 6.2.x servicing.  The proper fix can come later.",
      "created_at": "2019-06-13T22:22:41Z",
      "updated_at": "2019-06-13T22:22:41Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "@SteveL-MSFT Are you sure a fatal CLR exception can be caught? Verifying the fix will be hard as I do not have an environment where I can reproduce this. I could try building a version of PowerShell with this fix and upload it here so that people in this issue test it?",
      "created_at": "2019-06-13T22:24:26Z",
      "updated_at": "2019-06-13T22:28:10Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@bergmeister I can't repro this myself.  I think the best option might be as you suggest to build a private and ask someone who can repro it to try it out.",
      "created_at": "2019-06-14T03:11:40Z",
      "updated_at": "2019-06-14T03:11:40Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I see that we ignore return codes in the code that can be bad.",
      "created_at": "2019-06-14T04:33:32Z",
      "updated_at": "2019-06-14T04:33:32Z"
    },
    {
      "author": "weltkante",
      "author_association": "CONTRIBUTOR",
      "body": "[edit] disregard my previous comment, even though `[PreserveSig]` attributes are wrong in multiple places, while making the PR to fix them I noticed they were only wrong on interface methods you didn't call.\r\n\r\nI have the changes [here](https://github.com/PowerShell/PowerShell/compare/master...weltkante:interop-fix) if you want a PR anyways, but it shouldn't be the source of the crashes.",
      "created_at": "2019-06-14T08:14:10Z",
      "updated_at": "2019-06-14T08:57:02Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "@weltkante  Interesting, I took the interface definitions from the original Windows API pack (see e.g. [here](https://github.com/devkimchi/Windows-API-Code-Pack-1.1/blob/3c5e4eec41a147d80c19c8fd6417e4c8f7ff7e77/source/WindowsAPICodePack/Shell/Interop/PropertySystem/PropertySystemCOMInterfaces.cs#L86)) and was not aware of this. I am not an expert in this area but if you think your changes make it better, please submit a PR.",
      "created_at": "2019-06-14T09:04:22Z",
      "updated_at": "2019-06-14T09:04:22Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "@Antaris  @jlouros @msftrncs @cpmcgrath\r\nIn PR #9896, I added a global catch around it and added logging to got more information out.\r\nPlease download the MSI from the `PowerShell-CI-windows` build of that PR. If you are not familiar with the system just use the direct link to the build [here](https://powershell.visualstudio.com/PowerShell/_build/results?buildId=25651) and click on the button on the top right, and then click on `Artifacts` and then the `artifacts` submenu. This will download you a zip and in there is the MSI, which is a custom version of PowerShell 7 from the lastest commit in master.\r\n![image](https://user-images.githubusercontent.com/9250262/59502177-12e85c80-8e95-11e9-8f9b-23fb9eca7fc9.png)\r\n\r\nPlease report if it fixes it and if not, please provide the log messages that get printed to the PowerShell console. It will log out all the stages the code goes through. If you see a message of the format `Exception '{exception}' with stack trace {exception.StackTrace} successfully caught.` please let us know because that would mean that the `catch` statement was able to catch the fatal CLR error (which I doubt at the moment).\r\nThis is just a test build and not intended for any supported use.\r\nUPDATE (June 19): I updated the link to a newer build that should catch the exceptions inside the `Task.Run` statement as before it could've still leaked.",
      "created_at": "2019-06-14T10:12:12Z",
      "updated_at": "2019-06-19T10:49:54Z"
    },
    {
      "author": "Antaris",
      "author_association": "NONE",
      "body": "@bergmeister I've installed that Preview7 MSI and will get back to you as I try and recreate the issue, and run it for a couple of days as my main shell \ud83d\udc4d ",
      "created_at": "2019-06-14T11:30:23Z",
      "updated_at": "2019-06-14T11:30:23Z"
    },
    {
      "author": "weltkante",
      "author_association": "CONTRIBUTOR",
      "body": "> I see that we ignore return codes in the code that can be bad.\r\n\r\n@iSazonov where do you see that? I just did a review of the COM interface declarations as well as the calling `CreateElevatedEntry` method and couldn't find anything obviously wrong, at least in the methods which are actually used. It looks like all methods declaring PreserveSig are checking their return codes (methods returning void and not declaring PreserveSig have their return code checked by the interop layer).\r\n\r\nAnyways, not checking return codes cannot lead to AccessViolationException in coreclr. If the stacktrace from @anmenaga [above](https://github.com/PowerShell/PowerShell/issues/9295#issuecomment-501353113) is representative for the issue then it could very well be another bug in the coreclr interop layer (there already have been a few)\r\n\r\nIf your investigation doesn't lead anywhere it might be worth having someone from coreclr having a look at the dump. The stacktrace being in internal coreclr code really doesn't look very much like calling into wrongly coded interop declarations. In particular when in the coreclr [RCWHolder helper class](https://github.com/dotnet/coreclr/blob/master/src/vm/runtimecallablewrapper.h#L1599) the line `m_pSB->GetInteropInfoNoCreate()->GetRCWAndIncrementUseCount();` returns NULL for the middle call of `GetInteropInfoNoCreate` then it didn't really get very far on making the crashing call. (This is what happened in the dump, no idea if its representative.)",
      "created_at": "2019-06-14T12:05:39Z",
      "updated_at": "2019-06-14T12:08:05Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I mean\r\n```c#\r\n                if (hResult < 0)\r\n                {\r\n                    Debug.Fail($\"BeginList on ICustomDestinationList failed with HResult '{hResult}'.\");\r\n                    return;\r\n                }\r\n```\r\nIn release build we ignore fail results.",
      "created_at": "2019-06-14T12:13:22Z",
      "updated_at": "2019-06-14T12:13:33Z"
    },
    {
      "author": "weltkante",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov ah ok, this doesn't really ignore the failure result, it just doesn't give out diagnostics. It still returns immediately, meaning the attempt to create the JumpList entry is aborted without doing any more COM calls. Doing a return certainly can't lead to the kind of crash we're seeing here.",
      "created_at": "2019-06-14T12:16:21Z",
      "updated_at": "2019-06-14T12:16:21Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "I just had a look at WPF's implementation and its code checks that it is in STA apartment state. WPF threads are all in STA so I am not sure if this check is due to WPF or if STA is more suited for the COM calls that we make (PowerShell Core, even 7, is in MTA mode due to .Net Core historically not supporting STA):\r\nhttps://github.com/dotnet/wpf/blob/ae1790531c3b993b56eba8b1f0dd395a3ed7de75/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/Shell/JumpList.cs#L564",
      "created_at": "2019-06-14T13:20:37Z",
      "updated_at": "2019-06-14T13:20:37Z"
    },
    {
      "author": "weltkante",
      "author_association": "CONTRIBUTOR",
      "body": "Usually COM handles the apartment for you, if you aren't on STA then CoCreateInstance will create a dedicated STA thread for the COM objects if they are registered as only running on STA.\r\n\r\n> PowerShell Core, even 7, is in MTA mode due to .Net Core historically not supporting STA\r\n\r\nYou can't just turn a thread to STA, if you do that then you need a message loop too. If you don't have a Windows message loop then you probably shouldn't be STA.",
      "created_at": "2019-06-14T13:41:46Z",
      "updated_at": "2019-06-14T13:50:52Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "@Antaris Thanks. P.S.: If you see a message of the format `Exception '{exception}' with stack trace {exception.StackTrace} successfully caught.` please let us know because that would mean that the `catch` statement was able to catch the fatal CLR error (which I doubt at the moment).\r\nIn the meantime I suspect that this error happens rather on machines of different hardware spec, I tired with 1, 4 and 16 CPU cores . Can anyone share details?",
      "created_at": "2019-06-14T18:51:16Z",
      "updated_at": "2019-06-14T19:04:33Z"
    },
    {
      "author": "Antaris",
      "author_association": "NONE",
      "body": "@bergmeister I haven't been able to replicate the issue in the last few days. I'll keep at it, as I use PowerShell constantly.\r\n\r\nI have also not encountered any exceptions.\r\n\r\nFor reference, my spec machine is:\r\nDell XPS 15 9570\r\nIntel Core i7-8750H - 6 Core\r\n32GB RAM",
      "created_at": "2019-06-17T11:41:24Z",
      "updated_at": "2019-06-17T11:41:24Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "That is good but have you ever seen a message in the console saying something like\r\n`Exception '{exception}' with stack trace {exception.StackTrace} successfully caught.`?\r\nOnly if you've seen it then it would be the proof that the fatal CLR error could be caught successfully.",
      "created_at": "2019-06-17T12:50:47Z",
      "updated_at": "2019-06-17T12:52:33Z"
    },
    {
      "author": "usta",
      "author_association": "NONE",
      "body": "I can reproduce this bug every time if I try to run PowerShell. I will describe in 2 different Scenario, in the first one, it is working without any problems on the other hand with the second one not. \r\nIf needed i can provide more logs or outputs.\r\n\r\n### **My Hardware :** \r\nLenovo Y520\r\nIntel I7 7700HQ ( 2.8Ghz )\r\n16GB Ram\r\nSamsung 512 970Pro SSD\r\nWesternDigital WD10SPCX 1TB HDD\r\nNvidia 1050TI GPU 4GB\r\n\r\n### **My Software :** \r\n**OS :** \r\nM$ Windows 10 - Version 1903 - OsBuild 18917.1000\r\n\r\n**VS Code :** \r\nVersion: 1.36.0-insider (system setup)\r\nCommit: 68a7e5bc437b38d0281df0756997a25da2a2900c\r\nDate: 2019-06-18T18:40:22.519Z\r\nElectron: 4.2.4\r\nChrome: 69.0.3497.128\r\nNode.js: 10.11.0\r\nV8: 6.9.427.31-electron.0\r\nOS: Windows_NT x64 10.0.18917\r\n\r\n**PowerShell:** \r\n$PSVersionTable\r\n\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.0.0-preview.1\r\nPSEdition                      Core\r\nGitCommitId                    7.0.0-preview.1\r\nOS                             Microsoft Windows 10.0.18917\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n\r\n### **Scenarios :** \r\n\r\n### Scenario1 : \r\n**Steps :** \r\n1-try to right click a folder and select PowerShell preview 7 -> open here\r\n**Result :** \r\nworks perfectly without any problem\r\n\r\n### Scenario2 : \r\n**Steps :** \r\n1-open a VS Code in an pipenv ( virtualenv) folder ( Right click a folder/directory and select Open with Code Insider ) \r\n2-wait until it initialize virtualenv\r\n3-try to right click same folder and select PowerShell preview 7 -> open here ( or try to run it via shortcut )\r\n**Result :** \r\nGives this error  and close : \r\nInternal CLR error. (0x80131506)\r\n   at Microsoft.PowerShell.TaskbarJumpList.CreateElevatedEntry(System.String)\r\n   at Microsoft.PowerShell.ConsoleHost+<>c.<Start>b__4_0()\r\n   at System.Threading.Tasks.Task.InnerInvoke()\r\n   at System.Threading.Tasks.Task+<>c.<.cctor>b__274_0(System.Object)\r\n   at System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop(System.Threading.Thread, System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef, System.Threading.Thread)\r\n   at System.Threading.Tasks.Task.ExecuteEntryUnsafe(System.Threading.Thread)\r\n   at System.Threading.Tasks.Task.ExecuteFromThreadPool(System.Threading.Thread)\r\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\r\n   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()\r\n\r\n",
      "created_at": "2019-06-19T04:28:43Z",
      "updated_at": "2019-06-19T04:28:43Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "@usta Can you please describe what you mean by 'pipenv (virtualenv)', I do not use Python very much. Since you say you can always reproduce, please read my comment below, install the custom build and please report if it fixes it:\r\nhttps://github.com/PowerShell/PowerShell/issues/9295#issuecomment-502053584",
      "created_at": "2019-06-19T10:51:45Z",
      "updated_at": "2019-06-19T10:51:45Z"
    },
    {
      "author": "usta",
      "author_association": "NONE",
      "body": "> \r\n> \r\n> @usta Can you please describe what you mean by 'pipenv (virtualenv)', I do not use Python very much. Since you say you can always reproduce, please read my comment below, install the custom build and please report if it fixes it:\r\n> [#9295 (comment)](https://github.com/PowerShell/PowerShell/issues/9295#issuecomment-502053584)\r\n@bergmeister \r\n It looks like this one have fixed that bug ( if I have hit the same problem I will mention it here ) thanks\r\n",
      "created_at": "2019-06-20T10:26:57Z",
      "updated_at": "2019-06-20T10:28:02Z"
    },
    {
      "author": "msftrncs",
      "author_association": "CONTRIBUTOR",
      "body": "I cannot seem to reproduce it with the custom build, but it was pretty rare with 7 preview 1, yet 6.2 does it very regularly.   There might be some usefulness in applying a patch to a custom build of 6.2, or a series of builds from 6.2.  Just adding the debug/try/catch in might have changed something such a timing related resource lock up or something.",
      "created_at": "2019-06-20T17:57:43Z",
      "updated_at": "2019-06-20T17:57:43Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "cc @TravisEz13 @adityapatwardhan we should consider taking @bergmeister's change to 6.2.2",
      "created_at": "2019-06-20T21:00:23Z",
      "updated_at": "2019-06-20T21:00:23Z"
    },
    {
      "author": "usta",
      "author_association": "NONE",
      "body": "@bergmeister can we reopen this bug please ?\r\nBecause i have hit same bug today again  (with the one you have mentioned ( the custom build ) )\r\n(or maybe a different one)\r\n\r\nGetStartupInfo\r\nCoCreateInstance\r\nBeginList\r\nSetValue\r\nCommit\r\nCoCreateInstance\r\nAddObject\r\nInternal CLR error. (0x80131506)\r\n   at Microsoft.PowerShell.TaskbarJumpList.CreateElevatedEntry(System.String)\r\n   at Microsoft.PowerShell.ConsoleHost+<>c.<Start>b__4_0()\r\n   at System.Threading.Tasks.Task.InnerInvoke()\r\n   at System.Threading.Tasks.Task+<>c.<.cctor>b__274_0(System.Object)\r\n   at System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop(System.Threading.Thread, System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef, System.Threading.Thread)\r\n   at System.Threading.Tasks.Task.ExecuteEntryUnsafe(System.Threading.Thread)\r\n   at System.Threading.Tasks.Task.ExecuteFromThreadPool(System.Threading.Thread)\r\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\r\n   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()\r\n\r\n\r\nPS C:\\Windows\\System32> $PSVersionTable\r\n\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.0.0-preview2.25651\r\nPSEdition                      Core\r\nGitCommitId                    7.0.0-preview2.25651\r\nOS                             Microsoft Windows 10.0.18922\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n",
      "created_at": "2019-06-25T15:58:01Z",
      "updated_at": "2019-06-25T15:58:01Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "@usta Yes, I agree, we should re-open (I do not have the rights though but will notify maintainers). Thank you very much for reporting and providing the log, now we know that the problem happens on this line (should it happen again but with a different log where `AddObject` is not the last line before the crash let us know though):\r\nhttps://github.com/PowerShell/PowerShell/blob/86a1697da95974495fc8f08bc58932d0b4020603/src/Microsoft.PowerShell.ConsoleHost/WindowsTaskbarJumpList/TaskbarJumpList.cs#L89-L90\r\n@daxian-dbw @SteveL-MSFT @iSazonov  This means that despite initial positive reports that PR #9928 is not able to catch the fatal CLR error that has been reported multiple times (all bug reports reported the same error). Whilst there was still some value in doing a global catch for something that is not essential, the problem still persists... With the additional information I could try to look into seeing if we can code more defensively to avoid getting to this point where this issue happens (which I suspect to be a bug in the coreclr itself, is it worthwhile opening an issue there?). Otherwise I can only think of disabling this feature via e.g. an environment variable (or storing some info if the jumplist has been populated once already since it persists afterwards, not sure if it persists after Windows updates though...) Let me know what you think/prefer.\r\nOn a related note, I opened the following issue and PR in WPF to add the required APIs to radically simplify the code/responsibility in this repo going forward but so far the PR has not been reviewed and the issue has been tagged with `.Net 5`....:\r\nhttps://github.com/dotnet/wpf/issues/950\r\nhttps://github.com/dotnet/wpf/pull/996",
      "created_at": "2019-06-25T21:43:40Z",
      "updated_at": "2019-06-25T21:45:09Z"
    },
    {
      "author": "usta",
      "author_association": "NONE",
      "body": "@bergmeister now i tried again and again to reproduce same error. \r\nAt the end i may reproduce it but this time it give anohter log: \r\n\r\nGetStartupInfo\r\nCoCreateInstance\r\nBeginList\r\nSetValue\r\nCommit\r\nCoCreateInstance\r\nAddObject\r\nException 'System.Runtime.InteropServices.InvalidComObjectException: COM object that has been separated from its underlying RCW cannot be used.\r\n   at System.StubHelpers.InterfaceMarshaler.ConvertToNative(Object objSrc, IntPtr itfMT, IntPtr classMT, Int32 flags)\r\n   at Microsoft.PowerShell.ComInterfaces.ICustomDestinationList.AddUserTasks(IObjectArray poa)\r\n   at Microsoft.PowerShell.TaskbarJumpList.CreateElevatedEntry(String title)\r\n   at Microsoft.PowerShell.ConsoleHost.<>c.<Start>b__4_0()' with stack trace    at System.StubHelpers.InterfaceMarshaler.ConvertToNative(Object objSrc, IntPtr itfMT, IntPtr classMT, Int32 flags)\r\n   at Microsoft.PowerShell.ComInterfaces.ICustomDestinationList.AddUserTasks(IObjectArray poa)\r\n   at Microsoft.PowerShell.TaskbarJumpList.CreateElevatedEntry(String title)\r\n   at Microsoft.PowerShell.ConsoleHost.<>c.<Start>b__4_0() successfully caught.\r\nPS C:\\Users\\usta>",
      "created_at": "2019-06-25T21:59:26Z",
      "updated_at": "2019-06-25T21:59:26Z"
    },
    {
      "author": "usta",
      "author_association": "NONE",
      "body": "If needed I will be glad to test another build or try to provide other logs ( which might need to overcome this bug )",
      "created_at": "2019-06-25T22:02:46Z",
      "updated_at": "2019-06-25T22:02:46Z"
    },
    {
      "author": "usta",
      "author_association": "NONE",
      "body": "@bergmeister \r\nI am not even a m$ technology programmer but just because of curiosity isn't this line also needs an extra check before passing to AddUserTasks ?\r\n( https://github.com/PowerShell/PowerShell/blob/86a1697da95974495fc8f08bc58932d0b4020603/src/Microsoft.PowerShell.ConsoleHost/WindowsTaskbarJumpList/TaskbarJumpList.cs#L87 ) \r\nI mean isn't that might be better something like this :\r\nhResult = pShortCutCollection.AddObject((IShellLinkW)nativePropertyStore);\r\nif (hResult < 0)\r\n {\r\npShortCutCollection.Clear();\r\nDebug.Fail($\"Couldnt add nativePropertyStore to  Collection :  HResult '{hResult}'.\");\r\nreturn;\r\n}",
      "created_at": "2019-06-25T22:49:24Z",
      "updated_at": "2019-06-25T22:49:24Z"
    },
    {
      "author": "msftrncs",
      "author_association": "CONTRIBUTOR",
      "body": "Is it possible to detect if the jump list already exists (persists), and skip the steps to build it in that case?",
      "created_at": "2019-06-26T02:32:58Z",
      "updated_at": "2019-06-26T02:32:58Z"
    },
    {
      "author": "weltkante",
      "author_association": "CONTRIBUTOR",
      "body": "@usta no, AddObject is declared as returning void and thus the interop layer will do the check (and throw an exception)\r\n\r\n@msftrncs I don't know of any managed API which exposes reading of jumplists, so I suspect that the native API doesn't even support it, but I didn't check. In any way, just checking for existence is wrong, it would cause jumplists to become outdated if one of their properties changed.\r\n\r\nIn either way if you can't fix the problem here (and I seriously doubt adding try/catch for a coreclr panic is going to work nor a good idea) you should probably raise an issue with coreclr for further examination. You do have a dump to examine after all. The scenario in the dump certainly looks like a coreclr bug to me. (See my [comment above](https://github.com/PowerShell/PowerShell/issues/9295#issuecomment-502083413) for what goes wrong in the dump.)",
      "created_at": "2019-06-26T07:25:33Z",
      "updated_at": "2019-06-26T07:28:27Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "I opened an issue with all the details in the CoreClr repo, maybe they can help us. I had a look at our code again and there is no more defensive way of querying an API if the jumplist has already been created, we only get the maximum number of available slots available and already return early if there is not enough space for the jumplist, all we could do is cache the jumplist internally or have something like a feature flag to skip the problematic jumplist creation code (once the jumplist entry has been created, it persists).\r\nhttps://github.com/dotnet/coreclr/issues/25502",
      "created_at": "2019-06-29T23:09:47Z",
      "updated_at": "2019-07-01T11:26:38Z"
    },
    {
      "author": "usta",
      "author_association": "NONE",
      "body": "@bergmeister I have tried latest daily build and it looks like in this build I couldn't reproduce the bug.\r\nWhether it is fixed or the reason for that bug gone.\r\n\r\nPS C:\\Users\\usta> echo $PSVersionTable\r\n\r\nName                           Value\r\n----                           -----\r\nPSVersion                      7.0.0-dailypreview2.26796\r\nPSEdition                      Core\r\nGitCommitId                    7.0.0-dailypreview2.26796\r\nOS                             Microsoft Windows 10.0.18922\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0",
      "created_at": "2019-07-01T22:23:50Z",
      "updated_at": "2019-07-01T22:24:42Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "Everyone: The CoreClr team has investigated the issue and the problem is that the COM APIs that are being called are strictly STA only (PS Core currently still operates in MTA until #7216 is resolved) and the coreclr did not provide any warnings/errors. Therefore I've pushed changes to create the JumpList in an STA thread, which should hopefully be the final resolution.\r\nPlease re-test with the latest [build ](https://powershell.visualstudio.com/PowerShell/_build/results?buildId=27045) of PR #9896 and provide feedback",
      "created_at": "2019-07-03T19:07:32Z",
      "updated_at": "2019-07-03T19:29:03Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "Everyone: The fix for this issue has been backported to the recent release of `6.2.2`, please update and provide feedback if it fixed it. Users of the preview will have to wait for `7.0.0-preview.2`\r\nhttps://github.com/PowerShell/PowerShell/releases/tag/v6.2.2\r\ncc @msftrncs @usta @Antaris @cpmcgrath @jlouros",
      "created_at": "2019-07-16T18:48:31Z",
      "updated_at": "2019-07-16T18:48:31Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": ":tada:This issue was addressed in #10057, which has now been successfully released as `v7.0.0-preview.2`.:tada:\n\nHandy links:\n* [Release Notes](https://github.com/PowerShell/PowerShell/releases/tag/v7.0.0-preview.2)\n",
      "created_at": "2019-07-17T20:56:29Z",
      "updated_at": "2019-07-17T20:56:29Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": ":tada:This issue was addressed in #9928, which has now been successfully released as `v7.0.0-preview.2`.:tada:\n\nHandy links:\n* [Release Notes](https://github.com/PowerShell/PowerShell/releases/tag/v7.0.0-preview.2)\n",
      "created_at": "2019-07-17T20:56:31Z",
      "updated_at": "2019-07-17T20:56:31Z"
    }
  ],
  "created_at": "2019-04-04T20:31:25Z",
  "labels": [
    "Issue-Bug",
    "WG-Engine",
    "Resolution-Fixed"
  ],
  "number": 9295,
  "state": "closed",
  "title": "JumpList causes pwsh to fail",
  "updated_at": "2019-07-17T20:56:31Z"
}