{
  "_url": "https://github.com/PowerShell/PowerShell/issues/17498",
  "author": "pyrostew",
  "body": "# PR Summary\r\n\r\nFollowing the issue #17497 locks are being added to the Hide and Show methods in ProgressPane.cs to ensure that `_savedRegion` is not set to null after being check in the `IsShowing` property and being used in for loop in the Hide Method.\r\n\r\nI am not sure if this is considered an acceptable fix for this issue, there might be a higher level that this would be better fixed at, but I'm not familiar enough with the code to know where that might be.\r\n\r\n## PR Context\r\nSee Issue #17497 \r\n\r\n## PR Checklist\r\n\r\n- [x] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [x] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` or `[ WIP ]` to the beginning of the title (the `WIP` bot will keep its status check at `Pending` while the prefix is present) and remove the prefix when the PR is ready.\r\n- **[Breaking changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)**\r\n    - [x] None\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "microsoft-cla-retired[bot]",
      "author_association": "NONE",
      "body": "[![CLA assistant check](https://cla.opensource.microsoft.com/pull/badge/signed)](https://cla.opensource.microsoft.com/PowerShell/PowerShell?pullRequest=17498) <br/>All CLA requirements met.",
      "created_at": "2022-06-08T09:26:50Z",
      "updated_at": "2022-06-08T09:28:20Z"
    },
    {
      "author": "pull-request-quantifier[bot]",
      "author_association": "NONE",
      "body": "### ![](https://img.shields.io/static/v1?label=Quantified&message=Medium&color=yellow)\r\n\r\nThis PR has `122` quantified lines of changes. In general, a change size of upto `200` lines is ideal for the best PR experience!\r\n\r\n------\r\n\r\n<details >\r\n    <summary display=\"inline\"> <strong>Quantification details</strong></summary>\r\n    <p />\r\n\r\n```\r\nLabel      : Medium\r\nSize       : +63 -59\r\nPercentile : 44.4%\r\n\r\nTotal files changed: 1\r\n\r\nChange summary by file extension:\r\n.cs : +63 -59\r\n```\r\n> Change counts above are quantified counts, based on the [PullRequestQuantifier customizations](https://github.com/microsoft/PullRequestQuantifier/blob/main/docs/prquantifier-yaml.md).\r\n    \r\n</details>\r\n\r\n\r\n<details>\r\n    <summary display=\"inline\"> <strong>Why proper sizing of changes matters</strong> </summary>\r\n    <p/>\r\n    <p/>\r\n\r\nOptimal pull request sizes drive a better predictable PR flow as they strike a\r\nbalance between between PR complexity and PR review overhead. PRs within the\r\noptimal size (typical small, or medium sized PRs) mean:\r\n\r\n- Fast and predictable releases to production:\r\n  - Optimal size changes are more likely to be reviewed faster with fewer\r\niterations.\r\n  - Similarity in low PR complexity drives similar review times.\r\n- Review quality is likely higher as complexity is lower:\r\n  - Bugs are more likely to be detected.\r\n  - Code inconsistencies are more likely to be detetcted.\r\n- Knowledge sharing is improved within the participants:\r\n  - Small portions can be assimilated better.\r\n- Better engineering practices are exercised:\r\n  - Solving big problems by dividing them in well contained, smaller problems.\r\n  - Exercising separation of concerns within the code changes.\r\n\r\n#### What can I do to optimize my changes\r\n\r\n- Use the PullRequestQuantifier to quantify your PR accurately\r\n  - Create a context profile for your repo using the [context generator](https://github.com/microsoft/PullRequestQuantifier/releases)\r\n  - Exclude files that are not necessary to be reviewed or do not increase the review complexity. Example: Autogenerated code, docs, project IDE setting files, binaries, etc. Check out the `Excluded` section from your `prquantifier.yaml` context profile. \r\n  - Understand your typical change complexity, drive towards the desired complexity by adjusting the label mapping in your `prquantifier.yaml` context profile.\r\n  - Only use the labels that matter to you, [see context specification](./docs/prquantifier-yaml.md) to customize your `prquantifier.yaml` context profile.\r\n- Change your engineering behaviors\r\n  - For PRs that fall outside of the desired spectrum, review the details and check if:\r\n    - Your PR could be split in smaller, self-contained PRs instead\r\n    - Your PR only solves one particular issue. (For example, don't refactor and code new features in the same PR).\r\n\r\n#### How to interpret the change counts in git diff output\r\n\r\n- One line was added: `+1 -0`\r\n- One line was deleted: `+0 -1`\r\n- One line was modified: `+1 -1` (git diff doesn't know about modified, it will\r\ninterpret that line like one addition plus one deletion)\r\n- Change percentiles: Change characteristics (addition, deletion, modification)\r\nof this PR in relation to all other PRs within the repository.\r\n\r\n</details>\r\n\r\n<p />\r\n\r\n------\r\n\r\nWas this comment helpful? <a href=\"https://pullrequestquantifierfeedback.azurewebsites.net/feedback?payload=eyJBdXRob3JOYW1lIjoicHlyb3N0ZXciLCJSZXBvc2l0b3J5TGluayI6Imh0dHBzOi8vZ2l0aHViLmNvbS9Qb3dlclNoZWxsL1Bvd2VyU2hlbGwiLCJQdWxsUmVxdWVzdExpbmsiOiJodHRwczovL2dpdGh1Yi5jb20vUG93ZXJTaGVsbC9Qb3dlclNoZWxsL3B1bGwvMTc0OTgiLCJFdmVudFR5cGUiOiJUaHVtYnNVcCJ9&amp;anonymous=True\" target=\"_blank\" title=\"Thumbs up\"><strong>:thumbsup:</strong></a> <a href=\"https://pullrequestquantifierfeedback.azurewebsites.net/feedback?payload=eyJBdXRob3JOYW1lIjoicHlyb3N0ZXciLCJSZXBvc2l0b3J5TGluayI6Imh0dHBzOi8vZ2l0aHViLmNvbS9Qb3dlclNoZWxsL1Bvd2VyU2hlbGwiLCJQdWxsUmVxdWVzdExpbmsiOiJodHRwczovL2dpdGh1Yi5jb20vUG93ZXJTaGVsbC9Qb3dlclNoZWxsL3B1bGwvMTc0OTgiLCJFdmVudFR5cGUiOiJOZXV0cmFsIn0=&amp;anonymous=True\" target=\"_blank\" title=\"Neutral\"><strong>&nbsp;:ok_hand:</strong></a> <a href=\"https://pullrequestquantifierfeedback.azurewebsites.net/feedback?payload=eyJBdXRob3JOYW1lIjoicHlyb3N0ZXciLCJSZXBvc2l0b3J5TGluayI6Imh0dHBzOi8vZ2l0aHViLmNvbS9Qb3dlclNoZWxsL1Bvd2VyU2hlbGwiLCJQdWxsUmVxdWVzdExpbmsiOiJodHRwczovL2dpdGh1Yi5jb20vUG93ZXJTaGVsbC9Qb3dlclNoZWxsL3B1bGwvMTc0OTgiLCJFdmVudFR5cGUiOiJUaHVtYnNEb3duIn0=&amp;anonymous=True\" target=\"_blank\" title=\"Thumbs down\"><strong>&nbsp;:thumbsdown:</strong></a> (<a href=\"MAILTO:prquantifier@microsoft.com\" title=\"Mail to prquantifier@microsoft.com\">Email</a>)\r\n[Customize PullRequestQuantifier](https://github.com/PowerShell/PowerShell/blob/master/.github/prquantifier.yaml) for this repository.\r\n\r\n",
      "created_at": "2022-06-08T13:59:25Z",
      "updated_at": "2022-06-08T13:59:25Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as Review Needed because it has been there has not been any activity for **7 days**.\nMaintainer, please provide feedback and/or mark it as `Waiting on Author`",
      "created_at": "2022-06-16T14:01:19Z",
      "updated_at": "2022-06-16T14:01:19Z"
    },
    {
      "author": "sandscap-sc",
      "author_association": "NONE",
      "body": "@anmenaga @daxian-dbw @PaulHigin Can this be reviewed please? \r\n\r\nFYI - I received the following in VSCode debugging a script that was using a lot of progress bars in the PS Integrated Terminal.\r\n\r\n```\r\nSystem.NullReferenceException: Object reference not set to an instance of an object.\r\n   at Microsoft.PowerShell.ProgressPane.Hide()\r\n   at Microsoft.PowerShell.ConsoleTextWriter.WriteLine(String value)\r\n   at Microsoft.PowerShell.ConsoleHostUserInterface.WriteImpl(String value, Boolean newLine)\r\n   at System.Management.Automation.MshCommandRuntime.WriteInformation(InformationRecord record, Boolean overrideInquire)\r\n   at Microsoft.PowerShell.Commands.ReceiveJobCommand.WriteJobResults(Job job)\r\n   at Microsoft.PowerShell.Commands.ReceiveJobCommand.WriteJobResultsRecursivelyHelper(Hashtable duplicate, Job job, Boolean registerInsteadOfWrite)\r\n   at Microsoft.PowerShell.Commands.ReceiveJobCommand.WriteResultsForJobsInCollection(List`1 jobs, Boolean checkForRecurse, Boolean registerInsteadOfWrite)\r\n   at Microsoft.PowerShell.Commands.ReceiveJobCommand.ProcessRecord()\r\n   at System.Management.Automation.CommandProcessor.ProcessRecord()\r\n```",
      "created_at": "2022-07-20T15:55:17Z",
      "updated_at": "2022-07-20T15:55:17Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@SteveL-MSFT In what cases would `Hide` be called from multiple threads?",
      "created_at": "2022-07-25T23:04:18Z",
      "updated_at": "2022-07-25T23:04:18Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "My doubts are there are already locks in some code paths and we can fall in dead lock. I'd want understand what is a code path for the PR issue which bypasses existing locks.",
      "created_at": "2022-07-26T03:26:53Z",
      "updated_at": "2022-07-26T03:26:53Z"
    },
    {
      "author": "pyrostew",
      "author_association": "NONE",
      "body": "I believe these locks are a pretty safe addition. The state of the class is fully internal, the locks could only be deadlocked if something outside of the class managed to get a lock on the lock object, but the lock object is private so that isn't possible. Sprinkling more smaller locking objects around just the internal state objects would increase the risk of mistakes and make it harder to maintain going forward. The objective is to only allow the one of the hide and show methods to be called at any one time. The only way to get a deadlock from the added locks would be for one of the show/hide methods to call the other from inside the locked code block, which isn't happening and should be easy to spot in the future should further changes be made to these methods.\r\n\r\nThis was the simplest fix to an issue my team and I feel is pretty critical, clearly the ideal fix would be dig through the call tree and find where there is actually an issues with multiple threads interacting with the progress bars. but given the very specific scenario where I encountered this, it would be very complex to debug and find the true root cause.",
      "created_at": "2022-07-26T16:22:11Z",
      "updated_at": "2022-07-26T16:27:50Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "I have the similar concern as @PaulHigin and @iSazonov.\r\n\r\nBy looking at the code, it seems the issue would happen only if more than one threads are calling `Hide` on the same `ProgressPane` instance -- one sets `_savedRegion` to null while the other is still at the early phase of the method.\r\n\r\nThe part that I don't understand is why there are multiple threads manipulating the same progress pane, and that feels to me is the root cause of this issue.",
      "created_at": "2022-07-26T16:54:57Z",
      "updated_at": "2022-07-26T16:54:57Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> The part that I don't understand is why there are multiple threads manipulating the same progress pane, and that feels to me is the root cause of this issue.\r\n\r\nMy understanding always was that ConsoleHost is _owner_. And it has already has locks to exclude race conditions.  But the issue shows there is a code path which bypasses these locks.",
      "created_at": "2022-07-26T17:22:39Z",
      "updated_at": "2022-07-26T17:22:58Z"
    },
    {
      "author": "pyrostew",
      "author_association": "NONE",
      "body": "I'm happy to update this PR with suggestions for a more appropriate fix, but I'll need pointing at the right place as I'm not familiar with the architecture of the project.",
      "created_at": "2022-07-27T08:28:24Z",
      "updated_at": "2022-07-27T08:28:24Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> I'm happy to update this PR with suggestions for a more appropriate fix, but I'll need pointing at the right place as I'm not familiar with the architecture of the project.\r\n\r\nYou could look locks which works for local scenario. There are two places with such locks if I remember right. Then it would be great to find where the code is called in _remoting_ code. There is a _deserialization for ProgressRecord_ - a root of the issue there.",
      "created_at": "2022-07-28T06:08:43Z",
      "updated_at": "2022-07-28T06:08:43Z"
    },
    {
      "author": "PaulHigin",
      "author_association": "COLLABORATOR",
      "body": "The `WriteProgress` call from the remoting layer is likely through the `RemoteHost` object handling on the client.\r\n\r\nhttps://github.com/PowerShell/PowerShell/blob/b780a34ad1a8b0fb4aa02c5a486d1e9a995615ab/src/System.Management.Automation/engine/remoting/common/WireDataFormat/RemoteHost.cs#L136\r\n\r\nhttps://github.com/PowerShell/PowerShell/blob/b780a34ad1a8b0fb4aa02c5a486d1e9a995615ab/src/System.Management.Automation/engine/remoting/host/RemoteHostMethodInfo.cs#L136\r\n\r\nThe client normally marshals the remote host write onto the pipeline thread, and we should find out why that isn't happening in this case.\r\n\r\nhttps://github.com/PowerShell/PowerShell/blob/b780a34ad1a8b0fb4aa02c5a486d1e9a995615ab/src/System.Management.Automation/engine/remoting/client/ClientMethodExecutor.cs#L71\r\n\r\n",
      "created_at": "2022-07-28T15:54:05Z",
      "updated_at": "2022-07-28T15:54:05Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as Review Needed because it has been there has not been any activity for **7 days**.\nMaintainer, please provide feedback and/or mark it as `Waiting on Author`",
      "created_at": "2022-08-05T02:01:15Z",
      "updated_at": "2022-08-05T02:01:15Z"
    },
    {
      "author": "PaulHigin",
      "author_association": "COLLABORATOR",
      "body": "Looking at the original issue (#17497), I see that this only occurs during a WinRM remoting disconnect/reconnect event.  It appears that after reconnection, the remote host calls are no longer marshaled onto the client cmdlet thread.  I would like to first understand why this is happening before adding locks.  My guess is some client state information is lost after the reconnect.",
      "created_at": "2022-08-08T17:18:21Z",
      "updated_at": "2022-08-08T17:18:21Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as Review Needed because it has been there has not been any activity for **7 days**.\nMaintainer, please provide feedback and/or mark it as `Waiting on Author`",
      "created_at": "2022-08-16T02:01:18Z",
      "updated_at": "2022-08-16T02:01:18Z"
    }
  ],
  "created_at": "2022-06-08T09:26:38Z",
  "number": 17498,
  "state": "open",
  "title": "Adding Lock statements to ProgressPane Hide and Show functions.",
  "updated_at": "2022-09-27T19:53:09Z"
}