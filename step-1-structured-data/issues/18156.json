{
  "_url": "https://github.com/PowerShell/PowerShell/issues/18156",
  "author": "ernest33",
  "body": "### Prerequisites\n\n- [X] Write a descriptive title.\n- [X] Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\n- [X] Search the existing issues.\n- [X] Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\n- [X] Refer to [Differences between Windows PowerShell 5.1 and PowerShell](https://docs.microsoft.com/powershell/scripting/whats-new/differences-from-windows-powershell).\n\n### Steps to reproduce\n\n```PoweShell\r\nwinget upgrade | Out-String\r\n```\n\n### Expected behavior\n\n```console\nwinget upgrade\r\nNom                                                          ID                           Version          Disponible   Source\r\n------------------------------------------------------------------------------------------------------------------------------\r\nStardock Curtains                                            Stardock.Curtains            1.2              1.19.1       winget\r\nMicrosoft Visual C++ 2013 Redistributable (x64) - 12.0.30501 Microsoft.VC++2013Redist-x64 12.0.30501.0     12.0.40664.0 winget\r\nJetBrains ETW Host Service (x64)                             JetBrains.ReSharper          2022.2.2         2022.2.3     winget\r\nWindows Software Development Kit - Windows 10.0.19041.685    Microsoft.WindowsSDK         < 10.0.22000.832 10.0.22621.1 winget\r\nMSYS2 64bit                                                  msys2.msys2                  20220603         20220904     winget\r\nWindows Software Development Kit - Windows 10.0.17763.132    Microsoft.WindowsSDK         < 10.0.22000.832 10.0.22621.1 winget\r\nMySQL Installer - Community                                  Oracle.MySQL                 1.6.3.0          8.0.30       winget\r\nMicrosoft Visual C++ 2013 Redistributable (x86) - 12.0.30501 Microsoft.VC++2013Redist-x86 12.0.30501.0     12.0.40664.0 winget\r\n8 des mises \u00e0 niveau sont disponibles.\r\n1 package(s) have version numbers that cannot be determined. Use \"--include-unknown\" to see all results.\n```\n\n\n### Actual behavior\n\n```console\nNom                                                   ID                           Version          Disponible   Source\r\n-----------------------------------------------------------------------------------------------------------------------\r\nStardock Curtains                                     Stardock.Curtains            1.2              1.19.1       winget\r\nMicrosoft Visual C++ 2013 Redistributable (x64) - 12\u00d4\u00c7\u00aa Microsoft.VC++2013Redist-x64 12.0.30501.0     12.0.40664.0 winget\r\nJetBrains ETW Host Service (x64)                      JetBrains.ReSharper          2022.2.2         2022.2.3     winget\r\nWindows Software Development Kit - Windows 10.0.1904\u00d4\u00c7\u00aa Microsoft.WindowsSDK         < 10.0.22000.832 10.0.22621.1 winget\r\nMSYS2 64bit                                           msys2.msys2                  20220603         20220904     winget\r\nWindows Software Development Kit - Windows 10.0.1776\u00d4\u00c7\u00aa Microsoft.WindowsSDK         < 10.0.22000.832 10.0.22621.1 winget\r\nMySQL Installer - Community                           Oracle.MySQL                 1.6.3.0          8.0.30       winget\r\nMicrosoft Visual C++ 2013 Redistributable (x86) - 12\u00d4\u00c7\u00aa Microsoft.VC++2013Redist-x86 12.0.30501.0     12.0.40664.0 winget\r\n8 des mises \u251c\u00e1 niveau sont disponibles.\r\n1 package(s) have version numbers that cannot be determined. Use \"--include-unknown\" to see all results.\n```\n\n\n### Error details\n\n```console\nBy exemple check the line about 'Microsoft Visual C++ 2013 Redistributable (x64)'\r\nExpected \r\nWindows Software Development Kit - Windows 10.0.17763.132    Microsoft.WindowsSDK         < 10.0.22000.832 10.0.22621.1 winget\r\nBut currently i got \r\nWindows Software Development Kit - Windows 10.0.1904\u00d4\u00c7\u00aa Microsoft.WindowsSDK         < 10.0.22000.832 10.0.22621.1 winget\n```\n\n\n### Environment data\n\n```powershell\nName                           Value\r\n----                           -----\r\nPSVersion                      7.3.0-preview.8\r\nPSEdition                      Core\r\nGitCommitId                    7.3.0-preview.8\r\nOS                             Microsoft Windows 10.0.19044\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\n```\n\n\n### Visuals\n\n_No response_",
  "closed_at": null,
  "comments": [
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "When PowerShell runs a native command and processes it somehow (var, pipe) the raw output from that command is seen as a bunch of bytes. It needs to have a way to convert those bytes to a string using an encoding format. In PowerShell's case it uses the value of `[System.Console]::OutputEncoding` which based on your error I guess is the code page `850`. The trouble here is it looks like `winget` is always outputting the bytes using the UTF-8 encoding. We can see this by looking at the expected output\r\n\r\n> 8 des mises \u00e0 niveau sont disponibles.\r\n\r\nThis is seen as the following string value in PowerShell when it decodes those bytes\r\n\r\n> 8 des mises \u251c\u00e1 niveau sont disponibles.\r\n\r\nWe can see that `\u00e0` now becomes `\u251c\u00e1`. By testing this assumption, the UTF-8 byte encoding of [\u00e0 U+00E0](https://www.compart.com/en/unicode/U+00E0) is `0xC3, 0xA0`. On a French system the default console codepage is [850](https://en.wikipedia.org/wiki/Code_page_850) and by using the character map we can see the bytes `0xC3 0xA0` map to `\u251c\u00e1` giving us the string we see in PowerShell. You'll find the other differences are also caused by chars beyond the standard ASCII range (0-127) being encoded with UTF-8 but being read using the default console code page of 850 causing these problems.\r\n\r\nThe workaround this problem is to either get the native application to respect the console code page setting, or by explicitly telling PowerShell what encoding to use by setting `[System.Console]::OutputEncoding`. For your case you can do\r\n\r\n```powershell\r\n$origEncoding = [System.Console]::OutputEncoding\r\ntry {\r\n    [System.Console]::OutputEncoding = [System.Text.UTF8Encoding]::new()\r\n    winget upgrade | Out-String\r\n}\r\nfinally {\r\n    [System.Console]::OutputEncoding = $origEncoding\r\n}\r\n```\r\n\r\nIf you don't care about preserving the existing value you can just do\r\n\r\n```powershell\r\n[System.Console]::OutputEncoding = [System.Text.UTF8Encoding]::new()\r\nwinget upgrade | Out-String\r\n```\r\n\r\nKeep in mind this is a process wide setting and not something scoped inside PowerShell itself.",
      "created_at": "2022-09-25T22:49:43Z",
      "updated_at": "2022-09-25T22:50:26Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "@jborean93  I don't think it is a code page thiing \r\n\r\n```\r\n> winget list\r\n... \r\n\r\nMicrosoft ASP.NET Core 6.0.9 - Shared \u2026 Microsoft.DotNet.AspNetCore.6\r\n```\r\n\r\nNote the file is clipped and the ellipsis is a 16 bit character.  (8230 decimal) \r\n\r\n```\r\n$v = winget list\r\n$v[-2]\r\nMicrosoft ASP.NET Core 6.0.9 - Shared \u00d4\u00c7\u00aa Microsoft.DotNet.AspNetCore.6           6.0.9   ...\r\n```\r\nBring the text in as 8-bit ASCII and the ellipsis and the 2 byte character becomes ` \u00d4\u00c7\u00aa ` .\r\n\r\n\r\n\r\n",
      "created_at": "2022-09-26T08:59:09Z",
      "updated_at": "2022-09-26T08:59:09Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "Your example shows that it is. An [ellipsis](https://www.compart.com/en/unicode/U+2026) when encoded through UTF-8 (what winget does) is `0xE2 0x80 0xA6` (note 3 bytes not 2). These bytes when decoded using the [850 codepage](https://en.wikipedia.org/wiki/Code_page_850) is `\u00d4\u00c7\u00aa` as you've seen in the output as well as the output in OPs example when their columns were truncated using an ellipsis.",
      "created_at": "2022-09-26T10:10:52Z",
      "updated_at": "2022-09-26T10:15:29Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "I'm going to have to improve my understanding of code pages  :-(  \r\nThis isn't a French code page issue which was one thing I _read_ but I don't think was _meant_.  \r\n\r\nIf I run **cmd** and send the output of winget to a file and then type the file the same ` \u2026` -->  `0xE2 0x80 0xA6`  happens and `cmd`  prints these using the table  at  https://en.wikipedia.org/wiki/Code_page_850#Character_set   0xE2 = \u00d4 ,  0x80=\u00c7 and 0xA6=\u00aa     The same\" misinterpretation\" happens if I do `winget list | more` in **cmd** \r\nchcp tells me on my machine (en-GB) the code page is 850 (en-gb). I can change it to to 437 (en-US) I get the same result, but   chcp 65001 causes **cmd** to interpret those 3 bytes correctly. The 4 high order bits in E2 say this characters is expressed in 3 bytes, and the 4 lower order bits, and the 6 low order bits from the second and third bytes give 16 bits for the unicode character U+2026 \r\n \r\nI'm reading this as _when winget output is redirected ellipsis is always sent as as the 3 bytes_ `0xE2 0x80 0xA6` and **cmd** _writing to the console interprets those depending on the current code page._ \r\nIf **PowerShell** types the file it is processed as UTF-8  so unlike cmd it renders the ellipsis in the file\r\n\r\nBut if I do `$psversionTable | clip`  PowerShell sends the ellipsis in `PSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}`  as the 3 UTF Bytes and clip assumes it is getting codepage 850 characters and they paste like this  \r\n```\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u00d4\u00c7\u00aa}\r\n```\r\n\r\nBut if I do `[System.Console]::OutputEncoding = [System.Console]::OutputEncoding = [System.Text.UTF8Encoding]::new() `\r\nThe 3 bytes are understood as their UTF-8 meaning. \r\n```\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\n```\r\n\r\nIt seems when data is piped in PowerShell assumes the bytes mean what the console encoding says the should mean, but going out I'm I don't think the bytes leaving PowerShell are changing, but it's not clear how `clip` comes to process them correctly because setting console encoding doesn't change the result of running chcp from within PowerShell. \r\n\r\n<blockquote><div><strong><a href=\"https://en.wikipedia.org/wiki/Code_page_850#Character_set\">Code page 850 - Wikipedia</a></strong></div></blockquote>",
      "created_at": "2022-09-26T14:28:46Z",
      "updated_at": "2022-09-26T15:47:58Z"
    },
    {
      "author": "ernest33",
      "author_association": "NONE",
      "body": "> ```powershell\r\n> $origEncoding = [System.Console]::OutputEncoding\r\n> try {\r\n>     [System.Console]::OutputEncoding = [System.Text.UTF8Encoding]::new()\r\n>     winget upgrade | Out-String\r\n> }\r\n> finally {\r\n>     [System.Console]::OutputEncoding = $origEncoding\r\n> }\r\n> ```\r\n\r\nThanks for the work around @jborean93 \ud83d\udc4d\ud83c\udffb.\r\n\r\nWhat i find \"fun\" is if in powershell console...\r\n- (A) In maximized mode i type \"winget upgrade\" the ellipsis is gone and i have full column 'Name'.\r\n- (B) If i reduce the terminal (width) and i do again the command i have ellipsis....well that's ok :-)\r\n- (C) But why if i redirect the output using \"winget upgrade | Out-String\" Powershell seem to use a virtual terminal with a small width + _the converted ellipsis_\r\n![image](https://user-images.githubusercontent.com/770202/192341605-6c3118d3-80d9-4286-90aa-4a481ae96804.png)\r\n\r\nAnyway thanks for the answers.",
      "created_at": "2022-09-26T17:28:46Z",
      "updated_at": "2022-09-26T17:28:46Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "@jhoneill there are 3 things at play here\r\n\r\n* No redirection in cmd - output is written directly to the console like with PowerShell so no encoding problems\r\n* Redirected to a file `... > stdout` - The stdout is redirected but the raw bytes is whatever the native app writes the output as\r\n  * This is why the file contains UTF-8 bytes and confirms that it is ignoring the console codepage setting and always uses UTF-8\r\n  * Note in pwsh redirecting to a file still goes through pwsh, cmd is special in that the stdout pipe of the new process is a HANDLE to that file\r\n* Piped to another command `... | clip` - This depends on app you are piping to\r\n  * Typically this is a direct pipe connection so clip is getting the raw bytes\r\n  * If the 2nd exe tries to read this as a string then it typically also tries to read it based on the console codepage set\r\n  * Other exe might just read the raw bytes and won't worry about the encoding, like clip\r\n  * Once again pwsh is different where it actually converts this to a string and vice versa to input to clip.exe\r\n\r\n> The same\" misinterpretation\" happens if I do winget list | more in cmd chcp tells me on my machine (en-GB) the code page is 850 (en-gb). I can change it to to 437 (en-US) I get the same result, but chcp 65001 causes cmd to interpret those 3 bytes correctly. The 4 high order bits in E2 say this characters is expressed in 3 bytes, and the 4 lower order bits, and the 6 low order bits from the second and third bytes give 16 bits for the unicode character U+2026\r\n\r\nTypically exe's use the console code page setting which is why things usually just work but when they don't you have problems. So unless the codepage was set to `65001 (utf-8)` then more will fail to decode those 3 bytes properly as it's using a different encoding than what it actually was to encode that string in the first place.\r\n\r\n> I'm reading this as when winget output is redirected ellipsis is always sent as as the 3 bytes 0xE2 0x80 0xA6 and cmd writing to the console interprets those depending on the current code page.\r\nIf PowerShell types the file it is processed as UTF-8 so unlike cmd it renders the ellipsis in the file\r\n\r\nSure, in pwsh it will read files as UTF-8 by default so those raw bytes are read correctly. PowerShell does not read output from a native exe as UTF-8 by default, it's dependent on the setting of `[Console]::OutputEncoding` which can be UTF-8 but it could also be something else.\r\n\r\n> But if I do $psversionTable | clip PowerShell sends the ellipsis in PSCompatibleVersions {1.0, 2.0, 3.0, 4.0\u2026} as the 3 UTF Bytes and clip assumes it is getting codepage 850 characters and they paste like this. It seems when data is piped in PowerShell assumes the bytes mean what the console encoding says the should mean, but going out I'm I don't think the bytes leaving PowerShell are changing, but it's not clear how clip comes to process them correctly because setting console encoding doesn't change the result of running chcp from within PowerShell.\r\n\r\nSending input to a native command is dependent on the value of `$OutputEncoding` (I know confusing name). So depending on what this is and how the native exe reads the stdin this may or may not work properly. The problem could either lie in how the native exe is reading those bytes or how pwsh reads the output. Both unfortunately will need to line up and also align with how `clip.exe` is expecting it to work.\r\n\r\nI've documented this behaviour in this gist https://gist.github.com/jborean93/44b4688cc518d67bd7bc2192648384a3. It's not fully complete but it goes over all this in more depth and the various encoding options used by native applications.\r\n\r\n@ernest33 see below for replies to your comments\r\n\r\nWhen you don't pipe or capture output of a native command in PowerShell the native application has direct access to the console and when it writes output it is written to the console directly using an API where encoding is less of a problem. This is why this works as the output doesn't go in PowerShell at all. I can't fully explain why the ellipsis aren't present here but at a guess winget tries to adjust the column sizes based on whether stdout is redirected or not. If it's redirected then it's using a pre-set column width which then uses the ellipsis but now has to deal with the encoding problem because pwsh needs to read those bytes\n\n<blockquote><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> Gist</div><div><strong><a href=\"https://gist.github.com/jborean93/44b4688cc518d67bd7bc2192648384a3\">Details about console encoding in PowerShell</a></strong></div><div>Details about console encoding in PowerShell. GitHub Gist: instantly share code, notes, and snippets.</div></blockquote>",
      "created_at": "2022-09-26T19:57:03Z",
      "updated_at": "2022-09-26T19:57:05Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "@jborean93  Thanks for the explanation.  I'm not sure if I was misremembering or misunderstanding, but I appreciate  the clarification ",
      "created_at": "2022-09-28T08:40:35Z",
      "updated_at": "2022-09-28T08:40:35Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> Sending input to a native command is dependent on the value of `$OutputEncoding` (I know confusing name). So depending on what this is and how the native exe reads the stdin this may or may not work properly. The problem could either lie in how the native exe is reading those bytes or how pwsh reads the output. **Both unfortunately will need to line up and also align with how `clip.exe` is expecting it to work.**\r\n\r\nI think in this case PowerShell 7 sets `$OutputEncoding` to  UTF-8 (PowerShell 5 sets it to ASCII), and the console is set to CodePage 850 on my personal Windows 11 machine  and CodePage 437 on my client-provided windows 10 one (the two have different system locales) so we get a mismatch. \r\n\r\nI'm trying to think of a reason why  keeping `[System.Console]::OutputEncoding`   and `$OutputEncoding`  in sync _wouldn't_ be a good idea,  the ellipsis in `$psversionTable`  will get corrupted because pwsh is doing what `$OutputEncoding` says it should and `clip.exe.` is doing what `[System.Console]::OutputEncoding` tells _it_ to do and they're diverging. \r\n**(which is what that Gist says at the end!)** \r\n\r\nThis is a different issue to winget ignoring the codepage when output is piped or redirected. But to my mind the creators of winget already had their own special circle of hell :-)  ",
      "created_at": "2022-09-28T09:15:31Z",
      "updated_at": "2022-09-28T09:52:28Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "There's https://github.com/PowerShell/PowerShell/issues/14945 which I've opened before about `$OutputEncoding` and `[Console]::InputEncoding` not lining up (they should). It would be nice if `[Console]::OutputEncoding` also lined up but it's somewhat less of an issue as most console apps respect the console output codepage that pwsh will use to decode the bytes it receives.",
      "created_at": "2022-09-28T10:04:13Z",
      "updated_at": "2022-09-28T10:04:13Z"
    }
  ],
  "created_at": "2022-09-25T12:55:43Z",
  "labels": [
    "Needs-Triage",
    "WG-Engine-Format"
  ],
  "number": 18156,
  "state": "open",
  "title": "Putting 'winget upgrade | Out-String' in a var result with bad character (i'm using french Windows)",
  "updated_at": "2022-09-28T10:04:13Z"
}