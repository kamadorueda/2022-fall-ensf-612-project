{
  "_url": "https://github.com/PowerShell/PowerShell/issues/7445",
  "author": "nutix56",
  "body": "```PowerShell\r\n#example 1\r\n$files = Get-ChildItem -File\r\n#Let's get the length of every file.\r\n$files..Length\r\n```\r\n\r\n```PowerShell\r\n#example 2\r\n$hash = @{\r\n    first = @{\r\n        name = 'one'\r\n        value = 1\r\n    }\r\n    second = 'two'\r\n    'first name' = 'Jobs'\r\n}\r\n#The member intellisense would be clearer in PowerShell_ISE editor and the TAB completion.\r\n$hash..first\r\n```",
  "closed_at": null,
  "comments": [
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "If I understand you correctly, you want a dedicated operator named `..`  that makes member enumeration explicit and thereby avoids the ambiguity with the current `.`-based member enumeration, where a property of a given name at the collection level takes precedence over element-level properties (such as `.Length` in your first example).\r\n\r\nI don't quite understand how your 2nd example fits into this, however. Can you clarify by updating the original post, and, while you're at it, use code blocks (`` ```powershell ... ``) to better format your code?\r\n\r\nHaving a dedicated operator would potentially allows us to solve 3 existing problems:\r\n\r\n* as stated, it would resolve the ambiguity of `.`: the new operator signals the explicit intent to operate on the _elements_ of the collection, not the collection itself.\r\n\r\n* it would allow us to provide an alternative to the pipeline-like behavior of `.` (implicit unwrapping, flattening of arrays) - see #6802 (though perhaps having different behaviors would ultimately be too confusing)\r\n\r\n* it would allow implementing _assignment_ operations too, which are currently not supported for fear of unintended use - see #5271 and, in particular, https://github.com/PowerShell/PowerShell/issues/5271#issuecomment-340285892\r\n\r\n\r\n",
      "created_at": "2018-08-03T19:01:12Z",
      "updated_at": "2018-08-03T19:01:12Z"
    },
    {
      "author": "RichardSiddaway",
      "author_association": "NONE",
      "body": "How does Powershell differentiate  .. when used as the range operator from .. when used to access the members of a collection.\r\n\r\nnot arguing against the need to access the collection member's properties just don't understand how the two uses of the same operator symbol will work\r\n\r\n\r\n",
      "created_at": "2018-08-03T19:28:58Z",
      "updated_at": "2018-08-03T19:28:58Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@RichardSiddaway: \r\n\r\nI was focusing on making the case for such an operator in the abstract, but you're right, the syntactic form needs careful consideration too.\r\n\r\n`..` is problematic for its potential to be confused with the range operator alone.\r\n\r\nGroovy uses `*.`, for instance, and at first blush that may work, given that we don't allow unquoted property names to start with digits (unless it's an all-digit name, in which quoting or use of an expression could disambiguate - see #6946).\r\n\r\nBut let's see if there is a fundamental willingness to introduce such an operator.\r\n",
      "created_at": "2018-08-03T20:01:39Z",
      "updated_at": "2018-08-03T20:01:39Z"
    },
    {
      "author": "nutix56",
      "author_association": "NONE",
      "body": "Sorry, my english is poor! \r\nYes, that's what i mean, thanks @mklement0 \r\nAbout the confusing you mentioned, the range operator operates on two variables or literal value, like:\r\n```PowerShell\r\n1..10\r\n```\r\nor\uff08PowerShell 6.0+)\r\n```PowerShell\r\n'a'..'z'\r\n```\r\nor\r\n```PowerShell\r\n$from..$to\r\n```\r\nand their mixed mode combination.\r\n\r\nBut when we use the new operator as i said, it's like:\r\n```PowerShell\r\n$files..Length\r\n```\r\nthe second operand is a member name, it's not a variable which must starts with '$'.\r\nEven in the following case:\r\n```PowerShell\r\nfunction one { 1 }\r\n#3..one is error code\r\n#we must write like this\r\n3..(one)\r\n#or \r\n3..$(one)\r\n```\r\n\r\nThe second example is intend to use items of IDictionary object as elements of collection object, just like the 1st example. It's a extensional advice.\r\n",
      "created_at": "2018-08-04T14:30:05Z",
      "updated_at": "2018-08-04T18:59:55Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for updating the initial post, @nutix56.\r\n\r\nRe the 2nd example: I'm still not entirely clear what you expect the output of `$hash..first` to be: The _key-value pairs_ of the nested hashtable (2 `[System.Collections.DictionaryEntry]` instances representing the `name` and `value` entries each)? Or just their _values_?\r\n\r\nAs for the syntax: I meant confusing to the _user_, not necessarily whether it _technically_ works (syntactically):\r\n\r\n* In terms of being confusing, perhaps the fact that ranges _can_ start with a variable, but _rarely do_, makes that less of a concern.\r\n\r\n* Even technically, though, there's ambiguity that would have to be resolved with non-obvious rules (and I can't speak to how much it would complicate parsing):\r\n\r\nPowerShell supports expressions as property names, so `$files..Length` could be written as `$b='Length'; $files..$b` (at least it wouldn't be a good idea to disallow this with `..`, given that it's supported with `.`). So with a token such as `$a..$b` you would then have to infer from the _values_ of `$a` and `$b` whether they're both _numeric_  (-> range operator) or not (-> member enumeration). Note that the range operator is extremely flexible in what it accepts as numeric input, so that `' 5 '..$False` is equivalent to `5...0`, for instance).",
      "created_at": "2018-08-04T18:22:25Z",
      "updated_at": "2018-08-04T18:22:25Z"
    },
    {
      "author": "msftrncs",
      "author_association": "CONTRIBUTOR",
      "body": "The first issue example 1, work-around is `$files | select-object Length`, didn't realize listing all the file lengths was so difficult.  This seems peculiar, since in a hash table, the keys overload the base properties, but here a property is getting hidden by a base PowerShell property.  The work around for the hash is to use the method call `get_[propertyname]()`\r\n\r\nThe second example I don't think shows anything.  There is no 'first' property that is getting overloaded.  `$hash['first']` is also acceptable.  I do think this should be the correct way to retrieve values from the hash, however.",
      "created_at": "2018-08-07T06:13:28Z",
      "updated_at": "2018-08-07T06:18:20Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @msftrncs.\r\n\r\nThere's a more concise workaround: `(Get-ChildItem).ForEach('Length')` (and you'd need to add `-ExpandProperty` to yours).\r\n\r\nInteresting that the logic is reversed with hashtables (entry keys shadowing the hashtable's own properties when using dot notation).\r\n\r\nUnfortunately, that precludes meaningful application of the potential new operator to hashtables, because `.` already acts like that operator.\r\n\r\nIf the logic weren't reversed, that is,  if the behavior were consistent with member enumeration,  `@{ Count = 'Chocula' }.Count` would return `1` (it currently returns `Chocula`), i.e., the hashtable's own property, whereas `@{ Count = 'Chocula' }*.Count` would then unambiguously target the _entry_, returning `Chocula`.",
      "created_at": "2018-08-07T21:21:10Z",
      "updated_at": "2018-08-07T21:21:10Z"
    },
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 This is an aside, but WRT to assigning to a property on each member of a collection, you can do it with .foreach() as follows:\r\n```powershell\r\nPS[2] (8) > $l = @{a=1},@{a=2},@{a=3}\r\nPS[2] (9) > $l.foreach(\"a\", 13)\r\nPS[2] (10) > $l\r\n\r\nName                           Value\r\n----                           -----\r\na                              13\r\na                              13\r\na                              13\r\n```\r\nNow regarding what operator we might use (since '..' is definitly out for the reasons stated) Groovy uses '*' for spreading (=== \"splatting\") whereas PowerShell uses '@'.  Consequently the corresponding operator in PowerShell would be \"@.\"as in:\r\n```powershell\r\n $lengths = $list@.Length\r\n```\r\nNow in a previous language I designed, I used '->' for a similar purpose (but slightly different semantics)\r\n```powershell\r\n$lengths = $list->Length\r\n```\r\nI liked the fact that it was clearly visible in the code.  Another possibility is to have a semantic such that if the RHS is a scriptblock, then it gets applied to each element, minifying the foreach scenario even further.\r\n```powershell\r\n(1..10)->{$_ * 2}\r\n```\r\n(Early in PowerShell we spent a bunch of time talking to the folks in the languages group in MS Research. One of the researchers was very keen on having a minimal foreach/map/apply/select notation so this would probably make him happy :-)\r\n",
      "created_at": "2018-08-09T01:00:44Z",
      "updated_at": "2018-08-15T23:16:31Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @BrucePay.\r\n\r\nGood point about `@.` being more appropriate.\r\n\r\nThanks for the reminder about `.ForEach()` also being able to _set_ properties.\r\n\r\nThough `.ForEach()` therefore technically gives us everything we'd need the new operator for, I still think the latter is a useful addition (and it doesn't sound like you disagree, I'm just spelling it out), because:\r\n\r\n* with `.ForEach()` you need to _quote_ the property name, and you need method syntax.\r\n\r\n* the fact that `.ForEach()` even supports property extraction by a _string_ as the name and especially  _assignment_ is not intuitively obvious and easy to forget - probably also because the use case of passing a single script block, as you would to `ForEach-Object` and the `foreach` loop, is so prevalent.\r\n\r\n* `@.` is much more concise, and concision is important for frequently used core features\r\n\r\n> that if the RHS is a scriptblock\r\n> `(1..10)->{$_ * 2}`\r\n\r\nIn the case of  a script  block, however, I feel that `.ForEach()` is more appropriate (not least because there wouldn't be a `.` analog for something `(1..10)@.{$_ * 2}`):\r\n\r\n```powershell\r\n(1..10).ForEach({$_ * 2}) # I know you can omit the (...), but that seems fraught to me.\r\n```\r\n\r\nThough, [as I've proposed](https://github.com/PowerShell/PowerShell-RFC/pull/126), I wish we had `.ForEach()` in _operator_ form:\r\n\r\n```powershell\r\n(1..10) -foreach {$_ * 2}\r\n```\r\n\r\n@chuanjiao10:\r\n\r\nYes, getting carried away with abstract symbols is generally problematic, and there is an inherent tension between readability and concision.\r\n\r\nHowever, if the `.` operator (member access) makes sense to you, then `@.` should make sense to you as a natural extension of `.` for an inherently collection-focused language such as PowerShell.\r\n\r\nThe use of symbols is less problematic for frequently used features, because seeing them often makes them second nature.  \r\n\r\nHere, `@.` creates an operator whose `@` symbol is already established as pertaining to collections, as Bruce states (argument splatting, `@(...)`), which  helps with remembering its purpose.\r\n",
      "created_at": "2018-08-09T15:02:32Z",
      "updated_at": "2018-08-09T15:02:57Z"
    },
    {
      "author": "felixfbecker",
      "author_association": "CONTRIBUTOR",
      "body": "I don't see the need for this. I find it rare that a property conflicts with a collection property, and for the other cases, you can easily do `$collection |% property`. What's better about `$collection..property`?",
      "created_at": "2018-09-21T16:28:11Z",
      "updated_at": "2018-09-21T16:28:11Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "As an aside: I suggest we use `@.` in the discussion from now on.\r\n\r\n> What's better about `$collection@.property`\r\n\r\n* No situational ambiguity, especially with property names provided a _variables or expressions_.\r\n\r\n* Better performance, especially compared to `... | % property`, but even relative to `.ForEach( 'property')`\r\n\r\n* Conceptual clarity: you signal the intent to perform member enumeration as opposed to accessing a property of the collection itself.\r\n\r\n* Concision \r\n\r\n",
      "created_at": "2018-09-21T16:35:56Z",
      "updated_at": "2018-11-27T02:32:29Z"
    },
    {
      "author": "felixfbecker",
      "author_association": "CONTRIBUTOR",
      "body": "All your points except your second one can be made for `|% property` too.",
      "created_at": "2018-09-21T16:39:28Z",
      "updated_at": "2018-09-21T16:39:28Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "By that logic, member enumeration via `.` should never have implemented - yet it became a very popular feature.\r\n\r\nThe second point, performance, matters - member enumeration is fast, and you don't want to sacrifice speed just to work around its limitations.\r\n\r\nAdditionally, re concision: Use of aliases is discouraged in scripts, so your alternative would really be `... | ForEach-Object property`.\r\n",
      "created_at": "2018-09-21T16:45:33Z",
      "updated_at": "2018-09-21T16:45:33Z"
    },
    {
      "author": "felixfbecker",
      "author_association": "CONTRIBUTOR",
      "body": "`.` already existed to access properties, so there was no additional operator introduced. It's just PowerShell being a bit smarter in certain situations to do what you probably meant to do. It makes sense, because PowerShell is smart enough to wrap and unwrap values and collections in other contexts as well (e.g. when passing `string` to a `string[]` parameter, or a single-element array to a `string` parameter).\r\n\r\nBut whenever a new operator is introduced you have to consider that this is one additional thing for people to learn, one more thing that someone might not understand when they read a PowerShell script.",
      "created_at": "2018-09-21T16:51:37Z",
      "updated_at": "2018-09-21T16:51:37Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> `.` already existed to access properties, so there was no additional operator introduced.\r\n\r\nYes, but one _should have been_ introduced.\r\n\r\nAs great a feature as member enumeration was to introduce in principle, conflating it with the regular member accessor, `.`, resulted in the problematic behavior that `@.` aims to fix.\r\n\r\n\r\n",
      "created_at": "2018-09-21T16:59:07Z",
      "updated_at": "2018-09-21T16:59:07Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "Maybe it should just be `$Collection%Property` or `$Collection.%Property` \ud83d\ude09 ",
      "created_at": "2018-11-26T23:42:34Z",
      "updated_at": "2018-11-26T23:44:05Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "`%` is worth considering, @Jaykul, for symmetry with the `%` alias.\r\n\r\nHowever:\r\n\r\n* Just `%` could break existing code:\r\n\r\n```powershell\r\nPS> $foo = $bar = 1; $foo%$bar  # '%' interpreted as modulo operator\r\n0 \r\n```\r\n\r\n* `.%` may be confusing, due to reversing the logic: conceptually, you enumerate first (`%`), and then you member-access (`.`)\r\n\r\nTherefore, it is the form `%.` that is a potential alternative to `@.`\r\n\r\n",
      "created_at": "2018-11-27T02:47:47Z",
      "updated_at": "2018-11-27T02:47:47Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "Although that is also technically valid with numbers (it's not very often we do fractional modulo): \r\n```posh\r\n$ten = 10; $ten%.2\r\n```\r\n\r\nPowerShell won't allow a `.$variable` (or `.text`) on the right-hand side of the modulo operator, so I think it's safe enough...",
      "created_at": "2018-11-30T03:14:09Z",
      "updated_at": "2019-12-16T22:42:58Z"
    },
    {
      "author": "nutix56",
      "author_association": "NONE",
      "body": "The operator focus on: \r\n\r\n![QQ\u622a\u56fe20191213105900](https://user-images.githubusercontent.com/42074358/70766142-d04a0300-1d97-11ea-8ae1-d0fd9da4df16.png)\r\n\r\nBut, maybe it's better to use '...'\r\n\r\nWe can use it as a replacement for the simplest loop statement, like\r\n\r\n`$lenths = $(foreach($f in Get-ChildItem -File) { $f.Length})`\r\n`$lenths`\r\n\r\n=>\r\n\r\n`$lengths = (Get-ChildItem -File)...Length`\r\n\r\n'...' means more enumerable elements,\r\n\r\nwhen we use it between a collection object and its element property name, it means enumerate the property on each element of the collection object.\r\n\r\nI think it's very informal.",
      "created_at": "2019-12-13T03:06:47Z",
      "updated_at": "2019-12-13T03:23:51Z"
    },
    {
      "author": "RichardSiddaway",
      "author_association": "NONE",
      "body": "If all you want is a single property why not use select-object\r\n\r\nPS> Get-ChildItem -File | select -ExpandProperty length\r\n",
      "created_at": "2019-12-13T09:20:42Z",
      "updated_at": "2019-12-13T09:21:06Z"
    },
    {
      "author": "nutix56",
      "author_association": "NONE",
      "body": "> \r\n> \r\n> If all you want is a single property why not use select-object\r\n> \r\n> PS> Get-ChildItem -File | select -ExpandProperty length\r\n\r\nIt's more convenient, doesn't it?",
      "created_at": "2019-12-14T00:12:26Z",
      "updated_at": "2019-12-14T00:12:26Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "To recap the issue succinctly:\r\n\r\n[Member enumeration](https://stackoverflow.com/a/44620191/45375) with `.` is:\r\n\r\n* (a) delightfully concise\r\n* (b) fast\r\n\r\nIts only drawback is the inability to _predictably_  target the _elements'_ members rather than the _collection object_'s in case of naming conflicts.\r\n\r\nHaving a distinct syntax - next to `.` - that unambiguously targets the _elements_ would solve that problem (and would also allow addressing other `.` limitations - see [above](https://github.com/PowerShell/PowerShell/issues/7445#issuecomment-410346897)).\r\n\r\nThe current workarounds fall short:\r\n\r\n* `Select-Object -ExpandProperty length` satisfies neither (a) nor (b): it is verbose and slow.\r\n\r\n* `.ForEach('Length')` _somewhat_ satisfies (b) (still slower than member enumeration), but not (a)\r\n\r\nTo my mind, the best candidate for the new syntax, after the discussion above, is `%.`:\r\n\r\n```powershell\r\n$collection%.Length # Return the *elements'* .Length property values.\r\n```\r\n",
      "created_at": "2019-12-14T15:05:50Z",
      "updated_at": "2019-12-14T18:15:00Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "I'm not sure we need it (since collections don't have many members), but that syntax seems clean, concise, and unambiguous.",
      "created_at": "2019-12-16T22:40:44Z",
      "updated_at": "2019-12-16T22:40:44Z"
    },
    {
      "author": "msftrncs",
      "author_association": "CONTRIBUTOR",
      "body": "Technically, isn't `$collection%.property` then the same as `$collection.foreach{$_.property}`? (but shorter)",
      "created_at": "2019-12-17T05:13:41Z",
      "updated_at": "2019-12-17T05:13:41Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@msftrncs: yes, though that is somewhat slower - and more verbose - than the aforementioned `$collection.ForEach('Property')` syntax (which is still verbose) - the latter syntax also supports _assigning_ to property values more efficiently (pass an extra argument with the value).\r\n\r\nSpeaking of which: `%.`, with its unambiguous intent, could and should support _assigning_ to properties as well (which with `.` was deemed too dangerous - see https://github.com/PowerShell/PowerShell/issues/5271#issuecomment-340285892); e.g., you could do something like:\r\n\r\n```powershell\r\n# Assign the - invariably *same* - property value to all elements of the array.\r\n(Get-Item *.txt)%.LastWriteTime = Get-Date\r\n```\r\n\r\n@Jaykul, glad to hear you like the syntax; re the need for it: \r\n\r\n* PowerShell treats collections uniformly in many contexts (which is a good thing), and you may not even know what particular collection type you're dealing with in a given situation (not least because PowerShell itself returns different collection types situationally (`[object[]]` vs. `[System.Collections.ArrayList]` vs. `[System.Collections.ObjectModel.Collection[PSObject]]`).\r\n\r\n  * That is, in a given situation you may not even be aware of the potential for name conflicts, and you won't find out until later.\r\n\r\n* As for specific members:\r\n  * The `Item` method present on most collections is pitfall when dealing with XML or JSON data with such element / property names, for instance; `Length` and `Count` to lesser degrees.\r\n\r\n  * `ToString` is currently _invariably_ invoked on the collection itself (where it is more or less useless), but having a concise, predictable way to call the `ToString` method on all elements of a collection would be helpful, so that you could do the following (which with just `.` currently _fails_):\r\n\r\n```powershell\r\n# Predictably call .ToString() on the elements, not the collection itself.\r\n((Get-date), (Get-Date).AddDays(1))%.ToString('dd')\r\n\r\n# The above would be the concise equivalent of:\r\n((Get-date), (Get-Date).AddDays(1)).ForEach('ToString', 'dd')\r\n```\r\n",
      "created_at": "2019-12-17T15:41:25Z",
      "updated_at": "2019-12-17T15:41:25Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "Yes, but I don't find this argument compelling **at all**:\r\n\r\n> In a given situation you may not even be aware of the potential for name conflicts, and you won't find out until later.\r\n\r\nI mean, that's obviously true. But most of the time, it doesn't matter. It's not that this is non-deterministic and might be different on different computers, so I can just write it and run it.\r\n\r\nAdding a _longer_ syntax that's more explicit about what it's doing and therefore _theoretically_ clearer about what will happen doesn't mean that anyone's going to use it, because while it's technically clearer, we can't go back in time and do this unambiguously (i.e. we won't remove the fact that `.` unrolls child properties as long as they don't conflict with properties on the collection). \r\n\r\nSo this will be a great in those specific but rare situations where we actually run into a duplicate -- but people will have to actually know about it, **and** be 100% sure they don't need their code to run in PowerShell 7 or earlier.\r\n\r\nPotentially this would just add an optional operator that's confusingly similar to several other operators and practically not used in the real world, and is therefore always confusing when people see it.",
      "created_at": "2019-12-18T04:40:01Z",
      "updated_at": "2019-12-18T04:40:01Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> But most of the time, it doesn't matter. \r\n> So this will be a great in those specific but rare situations where we actually run into a duplicate \r\n\r\nThe point is: You shouldn't have to worry about when it _does_ matter.\r\n\r\nWhen you write code, your intent is always clear: you'll know ahead of time whether you're looking for a property of the _collection_ or properties of its _elements_.\r\n\r\nCurrently, if you're not careful (and remember all member names of the collection you're dealing with), that intent can be thwarted in the latter case, with potentially confusing symptoms.\r\n\r\nHaving a _direct, unambiguous expression of one's intent_ in the form of `%.` is therefore a great asset in my book.\r\n\r\nYes, the behavior of `.` can't be changed anymore, but anyone who understands what  `%.`  offers may consider adopting it as a matter of _habit_.\r\n\r\n> people will have to actually know about it, and be 100% sure they don't need their code to run in PowerShell 7 or earlier.\r\n\r\nThat applies to any new feature; it's the price of progress.\r\nWe have the same problem with the ternary operator, null-coalescing, pipeline chains...\r\n\r\nAs for the concern about adding another, similar-looking operator: Let's make it easy to look up help for operators: #11339",
      "created_at": "2019-12-18T11:35:01Z",
      "updated_at": "2019-12-18T11:36:53Z"
    },
    {
      "author": "Jaykul",
      "author_association": "CONTRIBUTOR",
      "body": "The problem is that this isn't true:\r\n\r\n> When you write code, your intent is always clear: you'll know ahead of time whether you're looking for a property of the collection or properties of its elements.\r\n\r\nEven _if_ we add this operator, only half of that is possible: you'll be able to specify that you're looking for a property of the elements. That's it. When you're looking at code that uses `%.` you'll know the author meant a property of the elements. The other half isn't possible -- when you're looking at code, you won't know for sure that they deliberately chose to use `.` instead of `%.` because they're looking for a property of the collection...\r\n\r\nIf we do add this feature, we should also add a script analyzer rule that recommends people use `%.` whenever the analyzer can tell that they're addressing the elements of the collection. It would be a hard rule to write, because you don't know for sure whether a command returns multiple items or not, which is one of the reasons we got the automatic unrolling in the first place -- so we could just write it without worrying about it \ud83d\ude09",
      "created_at": "2019-12-19T03:47:16Z",
      "updated_at": "2019-12-19T03:47:16Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> When you're looking at code that uses `%.` you'll know the author meant a property of the elements.\r\n\r\nThat's all I ask for. You can't fix the past, but you can make things better in the future.\r\nThat is, going forward you'll be able to - and should - express your intent unambiguously, and the reward is predictable results.\r\n\r\n> we should also add a script analyzer rule that recommends people use %. whenever the analyzer can tell that they're addressing the elements of the collection.\r\n\r\nGreat, if feasible - but it sounds like it isn't.\r\n\r\n> one of the reasons we got the automatic unrolling in the first place -- so we could just write it without worrying about it \ud83d\ude09\r\n\r\nThat would be great if you _didn't_ have to worry about it, but the whole reason for this discussion is that you currently _do_ (situationally, and you may not anticipate when it'll hit you), and  `%.` offers a way so you _no longer have to_.\r\n\r\n",
      "created_at": "2019-12-19T03:59:50Z",
      "updated_at": "2019-12-19T03:59:50Z"
    },
    {
      "author": "iRon7",
      "author_association": "NONE",
      "body": "> I don't see the need for this. I find it rare that a property conflicts with a collection property, and for the other cases, you can easily do `$collection |% property`. What's better about `$collection..property`?\r\n\r\nTo compliment @mklement0 arguments:\r\n\r\n* I don't think it is rare, in fact, due to the (_common_ and _useful_) `ToString` method conflict, I even thought for a long time that **_member_ enumeration** was only applicable to properties.\r\n\r\n* `$collection |% property` often requires an extra pair of parenthesizes when combined with other statements (as other chained member enumerations or concatenations), where a statement as `$collection..property` doesn't.\r\n\r\nMy thoughts: it doesn't have to be a shorthand syntax, it just need to be consistent and easy readable. Why not adding a PowerShell _property_ like member to each collection (e.g. using the `ForEach` method also as a property,-_if possible_-) that holds a bare minimum of members, knowing that currently e.g. a simple array already contains (`(,@() | gm -Force).Count`) **49** members (excluding `Count`, `Length`, `GetType()`, `ToString()`, etc.).\r\n\r\n**Wishful thinking:**\r\nCurrently: `($collection |% GetType).Name `,\r\nPurposed: `$Collection.ForEach.GetType().Name`\r\n\r\n\r\nCurrently: `Write-host 'Week days:' ($DateTimes |% ToString('dddd'))`,\r\nPurposed: `Write-host 'Week days:' $DateTimes.ForEach.ToString('dddd')`\r\n(or even `Write-host 'Week days:' $DateTimes.Format('dddd')`, see: #14372)\r\n\r\n`$a |% {$_ |% Length}` # Recursive collection\r\nCurrently: `$a |% {$_ |% Length}`\r\nPurposed: `$a.ForEach.ForEach.Length`",
      "created_at": "2020-12-10T10:30:08Z",
      "updated_at": "2020-12-10T13:39:02Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@iRon7, with the caveat that you need to specify the member name _as a quoted string_, the `.ForEach()` method already allows you to do this:\r\n\r\n```powershell\r\n$dates = , (Get-Date) * 3\r\n\r\n$dates.ForEach('GetType').Name\r\n\r\n$dates.ForEach('ToString', 'dddd')\r\n```\r\n\r\nWhile your proposal of a `.ForEach` _property_ lessens the syntactic awkwardness, a `%.` _operator_ seems much preferable to me: \r\n\r\n* Unequivocally operating on the elements of a collection will be a frequently employed feature, so concision is important.\r\n\r\n* As for obscurity concerns: `%` is well established as having the connotation of \"for each\" (albeit in a command context, and in expression contexts `%` is the modulo operators, but combined with `.` I wouldn't expect confusion).\r\n\r\n* Generally speaking, \r\n  * We're talking about a _general-purpose operation_  applied to _arbitrary objects_, so an _operator_ is conceptually more appropriate than introducing another intrinsic pseudo type member; intrinsic members (and the ETS) are a wonderful thing, but we should strive to minimize the \"magic\" we superimpose across _all_ .NET types, because it can cause confusion over which parts are native, and it can also causes naming conflicts, as is already the case with [``System.Collections.Generic.List`1.ForEach``](https://docs.microsoft.com/en-US/dotnet/api/System.Collections.Generic.List-1.ForEach).\r\n\r\n  * On a related note: The syntactic awkwardness of the `.ForEach()` and `.Where()` methods - which I presume is in part responsible for their relative obscurity - led me to propose the introduction of `-foreach` and `-where` _operators_ a while ago, but the proposal was rejected - see https://github.com/PowerShell/PowerShell-RFC/blob/00aec722fe23d124e7fb7542e710491edf644cc0/X-Rejected/RFC0034-Expose-ForEach-Where-Methods-as-Operators.md\r\n\r\n\r\n\r\n\r\n\r\n<blockquote><img src=\"https://avatars0.githubusercontent.com/u/11524380?s=400&v=4\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> GitHub</div><div><strong><a href=\"https://github.com/PowerShell/PowerShell-RFC\">PowerShell/PowerShell-RFC</a></strong></div><div>RFC (Request for Comments) documents for community feedback on design changes and improvements to PowerShell ecosystem - PowerShell/PowerShell-RFC</div></blockquote>",
      "created_at": "2020-12-10T13:12:57Z",
      "updated_at": "2020-12-10T13:15:43Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "P.S., @iRon7: having a member do double duty as both a method and a property would also be confusing and introduce an inconsistency, because invoking method members _without `()`_ should output the method _signatures_ (overloads) - e.g., `'foo'.ToString`. Curiously, this doesn't currently work for `.ForEach` and .`Where`, but that should be considered a bug - see #14376.",
      "created_at": "2020-12-10T13:34:43Z",
      "updated_at": "2020-12-10T15:35:13Z"
    }
  ],
  "created_at": "2018-08-03T18:03:51Z",
  "number": 7445,
  "state": "open",
  "title": "We need a new operator '..' to access to members of childitems of a collection",
  "updated_at": "2020-12-10T15:35:13Z"
}