{
  "_url": "https://github.com/PowerShell/PowerShell/issues/7112",
  "author": "iSazonov",
  "body": "I get very strange and disturbing performance results for Import-Csv cmdlet.\r\n\r\nImport 111 Mb csv log file:\r\n- On Windows PowerShell always ~ 3.7 sec. Memory ~ 10 Mb.\r\n-On PowerShell Core from 6 sec up to 27 sec - each subsequent launch increases the time by 1-2-3 seconds. Memory grow from 1 Mb to 105 Mb. After waiting some minutes memory decreases to ~1 MB and agaim the cmdlet take ~6 sec.\r\n\r\nI suppose we get the same for any script.",
  "closed_at": "2019-06-21T04:22:12Z",
  "comments": [
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov we have seen similar memory growth with string related activities in JSON too. I suspect .NET Core is just greedier with its GC than Framework.\r\n\r\nBut the slow down.. that is concerning.",
      "created_at": "2018-06-19T16:16:38Z",
      "updated_at": "2018-06-19T16:18:17Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@daxian-dbw If you are working on performance tests this may be of interest to you.",
      "created_at": "2018-06-19T17:15:26Z",
      "updated_at": "2018-06-19T17:15:26Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Maybe related #6965 (memory).\r\n/cc @alx9r",
      "created_at": "2018-06-20T06:17:11Z",
      "updated_at": "2018-06-20T06:17:11Z"
    },
    {
      "author": "alx9r",
      "author_association": "NONE",
      "body": "@iSazonov Your description sounds like it might be a case of the garbage collector falling behind.  Do you have a repro I can run?  It's probably worth measuring any difference between `GCSettings.IsServerGC` true and false.\r\n\r\nFWIW, `GCSettings.IsServerGC` seems to be false by default for both powershell.exe and pwsh.exe.  As I understand it, that default means that there is one GC thread regardless of how many threads are simultaneously producing garbage.  If I'm understanding this right, any managed code invoked by PowerShell that is both CPU-bound and well-parallelized is likely to run out of memory if you have enough cores and it runs long enough.\r\n\r\nIt could be that whatever Import-Csv (and the JSON activities @markekraus reported) are doing became more parallelized from Windows PowerShell to PowerShell Core.",
      "created_at": "2018-06-20T13:38:18Z",
      "updated_at": "2018-06-20T13:38:18Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@alx9r The repo is simple\r\n```powershell\r\nMeasure-Command { Import-Csv file.csv }\r\n```\r\nThe file I used has ~110 Mb size.\r\n\r\n> It could be that whatever Import-Csv (and the JSON activities @markekraus reported) are doing became more parallelized from Windows PowerShell to PowerShell Core.\r\n\r\nThen my test had to be even faster than in Windows PowerShell but it is 3-10(!) times slower from the first run.\r\nAlthough speed and memory can be different problems.",
      "created_at": "2018-06-20T14:14:19Z",
      "updated_at": "2018-06-20T14:15:21Z"
    },
    {
      "author": "alx9r",
      "author_association": "NONE",
      "body": "@iSazonov I'm not seeing the dramatic speed difference you reported.  Perhaps the specifics of the .csv file matter.  Here is my test code:\r\n\r\n```PowerShell\r\n$PSVersionTable\r\n\r\n\"GCSettings.IsServerGC : $([System.Runtime.GCSettings]::IsServerGC)\"\r\n$filePath = \"$([System.IO.Path]::GetTempPath())5abb9571859c48cea807d755cc48058b.csv\"\r\n\r\n# uncomment the following to generate a ~130MB .csv file first\r\n<#\r\n$numLines = (50 * [System.Math]::Pow(2,12))\r\n\r\n1..$numLines |\r\n    % { ($_..($_ + 100) | % {\"$_\"}) -join ',' } |\r\n    Set-Content $filePath\r\n#>\r\n\r\n\"Import-Csv $filePath\"\r\nMeasure-Command { Import-Csv $filePath } | select TotalSeconds | Format-List\r\n```\r\n\r\nThese are the results for Windows PowerShell and PowerShell core, respectively:\r\n\r\n```none\r\nName                           Value\r\n----                           -----\r\nPSVersion                      5.1.14409.1012\r\nPSEdition                      Desktop\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}\r\nBuildVersion                   10.0.14409.1012\r\nCLRVersion                     4.0.30319.42000\r\nWSManStackVersion              3.0\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nGCSettings.IsServerGC : False\r\nImport-Csv C:\\Users\\un1\\AppData\\Local\\Temp\\5abb9571859c48cea807d755cc48058b.csv\r\nTotalSeconds : 37.3680663\r\n```\r\n\r\n```none\r\nName                           Value\r\n----                           -----\r\nPSVersion                      6.1.0-preview.688\r\nPSEdition                      Core\r\nGitCommitId                    v6.1.0-preview.688\r\nOS                             Microsoft Windows 6.3.9600\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\nGCSettings.IsServerGC : False\r\nImport-Csv C:\\Users\\un1\\AppData\\Local\\Temp\\5abb9571859c48cea807d755cc48058b.csv\r\nTotalSeconds : 57.3899851\r\n```\r\n\r\nPeak memory usage for the test runs was as follows:\r\n\r\n* Windows PowerShell: 23.8 MB\r\n* PowerShell Core: 35.4 MB\r\n\r\n",
      "created_at": "2018-06-20T15:27:42Z",
      "updated_at": "2018-06-20T15:27:42Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": ">Perhaps the specifics of the .csv file matter. \r\n\r\nYes, but Windows PowerShell frees the memory so quickly that sometimes memory consumption can not be seen.\r\nI also see that in your test PowerShell Core is much slower.",
      "created_at": "2018-06-20T15:41:16Z",
      "updated_at": "2018-06-20T15:41:16Z"
    },
    {
      "author": "rthardin",
      "author_association": "NONE",
      "body": "I did a bit of iterative testing with a smaller CSV file (104866 bytes). On my system, the results show that Import-Csv performance does vary between back-to-back runs. The minimum runtime was 71 ms and the maximum was 192 ms. It looks like the runtime would decrease each time the GC came along. I'm running PowerShell inside a Docker container (`mcr.microsoft.com/powershell:centos-7`).\r\n\r\nI understand this issue was filed based on processing much larger input files (>100 MB), so I hope these findings are not a distraction; I thought the findings may still be relevant.\r\n\r\n```powershell\r\n$PSVersionTable\r\n\r\nWrite-Host \"Creating source data...\"\r\n\"random_numbers\" | Out-File source.csv\r\nGet-Random -SetSeed 1 | Out-Null\r\nfor ($i=0; $i -le 10000; $i++) {\r\n\t(Get-Random).ToString() | Out-File source.csv -Append\r\n}\r\nWrite-Host \"Measuring Import-Csv performance over time...\"\r\n\"index,duration_ms,bytes_consumed\" | Out-File 7112_results.csv\r\nfor ($i=0; $i -le 5000; $i++) {\r\n\t$millis = (Measure-Command { Import-Csv stats.csv }).TotalMilliseconds\r\n\t$memory = [System.GC]::GetTotalMemory($false)\r\n\t$i.ToString() + \",\" + $millis.ToString() + \",\" + $memory | Out-File 7112_results.csv -Append\r\n}\r\nWrite-Host \"Done\"\r\n```\r\n\r\n```powershell\r\n$PSVersionTable                                                                                                                                                                                                                          \r\n\r\nName                           Value                                                                                                                                                                                                          \r\n----                           -----                                                                                                                                                                                                          \r\nPSVersion                      6.0.2                                                                                                                                                                                                          \r\nPSEdition                      Core                                                                                                                                                                                                           \r\nGitCommitId                    v6.0.2                                                                                                                                                                                                         \r\nOS                             Linux 4.9.87-linuxkit-aufs #1 SMP Wed Mar 14 15:12:16 UTC 2018                                                                                                                                                 \r\nPlatform                       Unix                                                                                                                                                                                                           \r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}                                                                                                                                                                                        \r\nPSRemotingProtocolVersion      2.3                                                                                                                                                                                                            \r\nSerializationVersion           1.1.0.1                                                                                                                                                                                                        \r\nWSManStackVersion              3.0             \r\n```\r\n\r\n![screen shot 2018-06-29 at 3 04 45 pm](https://user-images.githubusercontent.com/1462450/42110061-d1ef81e0-7bad-11e8-9849-ccd7bb5c3f39.png)\r\n\r\nQuartile |   Runtime | Memory\r\n-------- | --------- | ------\r\nMinimum  |  71.37 ms | 10.19 MB\r\nQ1       | 125.87 ms | 39.88 MB\r\nMedian   | 138.86 ms | 50.56 MB\r\nQ3       | 151.39 ms | 59.35 MB\r\nMaximum  | 192.12 ms | 65.38 MB\r\n\r\n[source.csv.txt](https://github.com/PowerShell/PowerShell/files/2150592/source.csv.txt)\r\n[7112_results.csv.txt](https://github.com/PowerShell/PowerShell/files/2150519/7112_results.csv.txt)",
      "created_at": "2018-06-29T19:08:07Z",
      "updated_at": "2018-06-29T19:09:10Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@rthardin Thanks for great tests! Could you please continue and test on Windows - for PowerShell Core and Windows PowerShell for comparison?",
      "created_at": "2018-06-30T20:35:54Z",
      "updated_at": "2018-06-30T20:35:54Z"
    },
    {
      "author": "rthardin",
      "author_association": "NONE",
      "body": "@iSazonov Unfortunately I don't have the time to spare at the moment, but the test script is posted above for others to try.",
      "created_at": "2018-07-02T13:27:03Z",
      "updated_at": "2018-07-02T13:27:03Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Updated scripts for testing\r\n```powershell\r\n##############################\r\nWrite-Host \"Creating source data...\"\r\n\"random_numbers\" | Out-File source.csv\r\nGet-Random -SetSeed 1 | Out-Null\r\nfor ($i=0; $i -le 10000; $i++) {\r\n\t(Get-Random).ToString() | Out-File source.csv -Append\r\n}Write-Host \"Measuring Import-Csv performance over time...\"\r\n\"index,duration_ms,bytes_consumed\" | Out-File psobject_results.csv\r\nfor ($i=0; $i -le 5000; $i++) {\r\n\t$millis = (Measure-Command { Import-Csv source.csv }).TotalMilliseconds\r\n\t$memory = [System.GC]::GetTotalMemory($false)\r\n\t$i.ToString() + \",\" + $millis.ToString() + \",\" + $memory | Out-File psobject_results.csv -Append\r\n}\r\nWrite-Host \"Done\"\r\n\r\n######################\r\nWrite-Host \"Measuring Import-Csv performance over time...\"\r\n\"index,duration_ms,bytes_consumed\" | Out-File psobject_results.csv\r\nfor ($i=0; $i -le 5000; $i++) {\r\n $millis = (Measure-Command { [psobject]::new() }).TotalMilliseconds\r\n $memory = [System.GC]::GetTotalMemory($false)\r\n $i.ToString() + \",\" + $millis.ToString() + \",\" + $memory | Out-File psobject_results.csv -Append\r\n}\r\nWrite-Host \"Done\"\r\n\r\n\r\n######################\r\nWrite-Host \"Measuring Import-Csv performance over time...\"\r\n\"index,duration_ms,bytes_consumed\" | Out-File psobject_results.csv\r\nfor ($i=0; $i -le 5000; $i++) {\r\n $millis = (Measure-Command { [object]::new() }).TotalMilliseconds\r\n $memory = [System.GC]::GetTotalMemory($false)\r\n $i.ToString() + \",\" + $millis.ToString() + \",\" + $memory | Out-File psobject_results.csv -Append\r\n}\r\nWrite-Host \"Done\"\r\n```\r\n\r\nI started with `Import-Csv` and temporary disable output in the C# code. Results was well. So I guess that root of problems in creating PSObject and next two tests confirm this. Windows PowerShell is 30-100 percent faster.\r\nIt's unclear where the problem is - in PowerShell Core or in .Net Core.\r\n\r\n/cc @SteveL-MSFT @daxian-dbw \r\n",
      "created_at": "2018-07-03T12:38:52Z",
      "updated_at": "2018-07-03T12:38:52Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@iSazonov to see if we slowed down creating PSObjects (looking at the Import-CSV cmdlet, it's really just adding NoteProperty members to a PSObject), I ran this test:\r\n\r\n> measure-command { 1..1000 | % { $a = [PSObject]::new(); 1..10 | % { $a | Add-Member -NotePropertyName \"a$_\" -NotePropertyValue $_ }; $a | Add-Member -NotePropertyName id -NotePropertyValue $_; $a } }\r\n\r\nWindows PowerShell 5.1 consistently took around 15.7s on my machine.  PSCore6.1-3 consistently took around 8.4s, so about twice as fast.\r\n\r\nWill have to investigate more where the bottleneck is.",
      "created_at": "2018-07-10T00:53:25Z",
      "updated_at": "2018-07-10T00:53:25Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@SteveL-MSFT I can confirm that property adding is faster on PowerShell Core. I think `[PSObject]::new()` is slower.",
      "created_at": "2018-07-10T03:34:53Z",
      "updated_at": "2018-07-10T03:34:53Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "When looking at performance traces, comparing 5.1 to 6.0.2 (and preview, almost indistinguishable from 6.0.2) I found the following using the sample csv from @alx9r :\r\n\r\nIt is calls to `System.Collections.Hashtable.InitHash(Object, Int32, out UInt32, out UInt32)` that is twice as slow on 6.0.2. (5263ms compared to 9250ms). This comes from the fact that the windows version uses `System.OrdinalComparer.GetHashCode(String)` where core is using `System.Globalization.CompareInfo.GetHashCodeOfStringCore(String, CompareOptions)`\r\n\r\nThis function is called from several code paths from `System.Management.Automation.PSMemberInfoIntegratingCollection``1.AddToTypesXmlCache(T, Boolean)` which I think is called when we add properties to our psobject.\r\n\r\n@SteveL-MSFT - I think you have to compare creating a PSObject with many properties. That is what seems to be expensive - not the creation of a PSObject per se.\r\n",
      "created_at": "2018-07-11T07:49:55Z",
      "updated_at": "2018-07-11T07:51:11Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "@SteveL-MSFT In general, core is faster the full framework, but I think the code sample you used is running so much pipeline stuff that the general speed improvements hides the fact that the addition of properties to psobjects is slower.",
      "created_at": "2018-07-11T07:54:25Z",
      "updated_at": "2018-07-11T07:54:25Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "Basically, this seems to boil down to `String.GetHashCode` being twice as slow.\r\n```\r\nforeach($i in 1..10000000) {$Null = \"PowerShell6HasSlowerHashCode\".GetHashCode()}\r\n```\r\n4.165s on Windows PowerShell.\r\n7.167s on PowerShell 6.0.2.",
      "created_at": "2018-07-11T08:07:22Z",
      "updated_at": "2018-07-11T08:07:22Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@powercode thanks for doing the analysis.  I can confirm that I have similar result on my machine where PSCore6 is slower than Windows PowerShell calling GetHashCode().  Opened https://github.com/dotnet/corefx/issues/30994",
      "created_at": "2018-07-11T16:59:50Z",
      "updated_at": "2018-07-11T16:59:50Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "Per dotnetcore team, this is expected as they made an improvement to GetHashCode() to be randomized (per session) for security reasons.",
      "created_at": "2018-07-12T19:26:55Z",
      "updated_at": "2018-07-12T19:26:55Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "Hmm.. I bet the issue in #6199 is related too then. The sampled JSON there was creating a large number of properties on a large number of PSObjects and then the same JSON was converted with NewtonSoft, the performance improvement was significant in terms of both memory usage and execution time.",
      "created_at": "2018-07-12T20:49:36Z",
      "updated_at": "2018-07-12T20:49:36Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": ">Per dotnetcore team, this is expected as they made an improvement to GetHashCode() to be randomized (per session) for security reasons.\r\n\r\n\"per session\" - this should not affect because we see the slowdown inside the session each time an object is created.",
      "created_at": "2018-07-13T05:15:00Z",
      "updated_at": "2018-07-13T05:15:00Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "@iSazonov It is about them having a more expensive algorithm now. Not just different per session. \r\n\r\nHowever, it seems like we have an opportunity for optimization. As it looks now, we recalulate the hash code for the every property name for every line in the csv. If we were smarter about how we created custom objects (some sort of prototype object maybe) a lot of the work could be amortized.\r\n\r\nI'm thinking in the lines of \"Create a prototype object, doing all the work needed in the typesystem\" and then \"Instantiate 10 million of these objects\" given this array of property values.\r\n\r\n\r\n",
      "created_at": "2018-07-13T07:35:27Z",
      "updated_at": "2018-07-13T07:35:27Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@powercode I tried cloning PSObject but don't get benefits. I believe we need more generic improvements. Also not only Import-Csv is slow - ConvertTo-Csv and web cmdlets too #6199.",
      "created_at": "2018-07-13T08:33:28Z",
      "updated_at": "2018-07-13T08:33:28Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "@iSazonov We would need new API:s",
      "created_at": "2018-07-13T16:01:16Z",
      "updated_at": "2018-07-13T16:01:16Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@vancem Please look the PerfView traces (for Core and Windows)\r\nhttps://ufile.io/s3t7v (I haven't access to `\\\\clrmain`).\r\n\r\nYou can use follow PowerShell scripts to record new traces\r\n\r\n```powershell\r\ncd c:\\tmp\\\r\n\r\n# For measuring creating PSObject-s\r\n\"random_numbers\" | Out-File .\\source1.csv\r\nGet-Random -SetSeed 1 | Out-Null\r\nfor ($i=0; $i -le 1000; $i++) {\r\n\t(Get-Random).ToString() | Out-File .\\source1.csv -Append\r\n}\r\n\r\nfunction perf_test($source, $result) {\r\n    Write-Host \"Measuring Import-Csv performance over time...\"\r\n\r\n    \"index,duration_ms,bytes_consumed\" | Out-File $result\r\n    for ($i=0; $i -le 200; $i++) {\r\n\r\n            $millis = (Measure-Command { Import-Csv $source }).TotalMilliseconds\r\n            # Uncomment this if you want analize results in Excel\r\n            $memory = [System.GC]::GetTotalMemory($false)\r\n\t    $i.ToString() + \",\" + $millis.ToString() + \",\" + $memory | Out-File $result -Append\r\n    }\r\n    Write-Host \"Done\"\r\n}\r\n\r\nperf_test .\\source1.csv .\\resultsWindows1.csv\r\n\r\n\r\n\r\n\r\n###############\r\n# For measuring adding new properties to PSObject-s\r\n$fields = 0..19 | ForEach-Object { \"random_numbers$_\" }\r\n($fields -join \",\") | Out-File .\\source2.csv\r\nGet-Random -SetSeed 1 | Out-Null\r\nfor ($i=0; $i -le 1000; $i++) {\r\n    $values = 0..19 | ForEach-Object { (Get-Random).ToString() }\r\n    ($values -join \",\") | Out-File .\\source2.csv -Append\r\n}\r\n\r\nperf_test .\\source2.csv .\\resultsWindows2.csv\r\n\r\n\r\n```\r\n",
      "created_at": "2018-07-19T11:18:52Z",
      "updated_at": "2018-07-19T11:19:41Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I forgot to say that my traces is based on PowerShell Core 6.0 Preview3 with .Net Core 2.1.301.",
      "created_at": "2018-07-20T05:05:08Z",
      "updated_at": "2018-07-20T05:05:08Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@vancem Have you any news?",
      "created_at": "2018-07-26T04:50:12Z",
      "updated_at": "2018-07-26T04:50:12Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "Faster hash may help some, but the real perf boost is to enable a scenario where we know up front that we will create a lot of pscustomobjects with the same layout and create the metadata objects up front. Then we should be able to amortize the work of creating the properties. @lzybkr, didn't you have some ideas around this?\r\n\r\n",
      "created_at": "2018-07-26T06:42:38Z",
      "updated_at": "2018-07-26T06:42:38Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Of cause we can make some improvements in this code but main question remains open - why this code works fine on .Net Framework and is so bad on .Net Core?",
      "created_at": "2018-07-26T09:52:37Z",
      "updated_at": "2018-07-26T09:52:37Z"
    },
    {
      "author": "vancem",
      "author_association": "NONE",
      "body": "I agree that while there are a bunch of interesting performance questions here, by for the most interesting is why running the same powershell benchmarks on .NET Core runs slower than .NET Desktop.\r\n\r\nThank you @iSazonov  for providing the traces.   Sorry it took so long for met to really take a look.  I have been multiplexing investigations.  \r\n\r\nFirst just to understand the data you put on https://ufile.io/s3t7v   \r\n\r\n1. You are measuring the time it takes for powershell to Import-Csv on a file. \r\n2. In the first run, there is only one column in the comma separated file you are reading in.  \r\n3. In the second run you there are 20 columns \r\n\r\nYou did this for \r\n1. Powershell that runs on .NET Core (pwsh.exe).  Data in PerfViewDataCore*.etl.zip, \r\n2. Powershell for Desktop .NET (PowerShell.exe).  Data in PerfViewDataWindows*.etl.zip.  \r\n\r\nEverything is running as 64 bit processes.   Of the two runs, the second one (with 20 columns in the CSV file), has the most dramatic difference.  It takes about 17 seconds to run on .NET Core but only 9.5 seconds on .NET Desktop.   Thus that is the most interesting case to look at first.\r\n\r\nIn both cases, from the trace it is clear that these are both CPU bound cases.   There is no interesting blocked time involved in the scenario.  \r\n\r\nAs usual with cases like this where you 'swap out' large things (like runtimes), the difference is caused by many things.   It actually is non-trivial to properly analyze it as you have to be sure you remain 'fair' to each case as you 'drill in' and find interesting differences.  \r\n\r\nOne way of testing if the app is 'most doing the same thing' is to see what objects it allocates.   Looking at the 'GC Heap Alloc Ignore Free' shows that the .NET Core case allocates 4GB of objects and the Desktop does 3.7GB (about 8%more).   Most of this is because of a Func delegate that is allocated in the \r\nRunspaces.TypeTable.GetMembers() method (called from AddToTypesXmlCache).  \r\n\r\nThis method is definitely a method of interest.  It is not clear if it is being called less or if a JIT optimization is not happening. but it is definitely of interest.  \r\n\r\nHowever an important point allocation are 'about the same (within 10%), so you would expect GC overhead to be in line with that.   It is not.   .NET Core's GC time is 3.5 seconds, where Desktop is 1.3 (2.7x bigger).   Drilling into the stacks inside the CLR.dll CoreCLR we see that HndScanHandlesForGC is 2 seconds of CPU time in .NET Core and only .076 seconds for .NET Desktop).   This is very likely because .NET Core uses dependent handles more.   Clearly this is worth fixing (it is 11% of the cost RIGHT THERE)\r\n\r\nAnother thing I look at is to group CPU by DLL and see if there are unexpected anomalies.  In particular I expect the 'user' DLLs to basically use the same amount of CPU independent of the runtime (sure runtime or framework things might be different and thus more expensive, but the CPU in YOUR dll should be basically the same.   This is NOT the case.   In particular for the microsoft.powershell.commands.utility DLL, \r\n\r\n1. .NET Core CPU - 1977 msec\r\n2. .NET Desktop - 357 msec \r\n\r\n\r\nThus .NET Core used 5.5X more CPU.   WOW, that is a big increase.   Drilling into it most of it is in the ImportCsvHelper.ParseNextRecord and the methods it calls.    There is clearly differences in inlining but it really is hard to get 5X differences because of code quality differences on real world code.  Clearly we have to dig into this.   \r\n\r\n@iSazonov - are we sure we are running OPTIMIZED code?   Running under a debugger can definitely turn off optimization we should check this.   \r\n\r\nSo the simple answer is, the answer is not simple.    More investigation is needed.\r\n\r\n@iSazonov  - I have a Powershell that ships with windows, but I don't have one for .NET Core.   Can you zip up your .NET Core version (ideally with source), so I can collect more specialized data to do further investigation?   \r\n\r\nThere does seem to be a bunch of stuff the .NET Core team could do.  We should log an issue at https://github.com/dotnet/coreclr \r\n\r\nThanks \r\n\r\n+ @brianrob @valenis \r\n",
      "created_at": "2018-07-26T22:19:59Z",
      "updated_at": "2018-07-26T22:19:59Z"
    },
    {
      "author": "vancem",
      "author_association": "NONE",
      "body": "Actually I see that download instructions for Powershell Core.  I will give those a whirl.  \r\n ",
      "created_at": "2018-07-26T22:22:46Z",
      "updated_at": "2018-07-26T22:22:46Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@vancem Thanks for your detailed analysis.  The PSCore6 from our [releases](https://github.com/PowerShell/PowerShell/releases/tag/v6.1.0-preview.4) page is both crossgen'd and built as Release",
      "created_at": "2018-07-27T00:36:40Z",
      "updated_at": "2018-07-27T00:36:40Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> are we sure we are running OPTIMIZED code?\r\n\r\nNo, traces I pushed on the share is not crossgen-ed. Sorry that I did not mention this. Really I tried locally Preview3 version and did not find a difference in behavior (of cause crossgen-ed binaries is more fast). ",
      "created_at": "2018-07-27T04:59:31Z",
      "updated_at": "2018-07-27T04:59:31Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@vancem Seems there is not published pdb files for Preview4 so I compiled the master branch with crossgen option (`Start-PSBuild -Restore -TypeGen -ResGen  -Configuration Release`). Now .Ner Core 2.1.2 is used.\r\n\r\nYou can download this from https://ufile.io/34gsf\r\n",
      "created_at": "2018-07-27T10:25:18Z",
      "updated_at": "2018-07-27T12:15:00Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "I did a bit of hacking...\r\n\r\nWith the following:\r\n\r\n- using the overload `Add(PSMember, bool prevalidated)` for all objects except the first when adding the noteproperties.\r\n- with a new constructor to PSObject that preallocates the _instanceMembers collection with an initial capacity\r\n- Replace a Linq.Any() with a List.Count > 0\r\n\r\nI was able to improve the performance of import-csv by a factor of 10x.\r\nA csv with 200k lines and 100 columns took 00:04:34 before the optimizations and 00:00:26 after (a speedup of 10x).\r\n\r\nWe still spend a sizeable time of that calculating hashes, but it is at least a lot better.\r\n",
      "created_at": "2018-07-31T13:27:35Z",
      "updated_at": "2018-07-31T14:31:30Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I believe we should continue this research. We still did not find all the root causes of why Windows PowerShell has better performance.\r\n\r\nThe issue header was updated to reflect this.",
      "created_at": "2018-08-07T03:37:24Z",
      "updated_at": "2018-08-07T03:39:40Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "When I looked at the traces, the hash code calculation showed up over and over again, when comparing 5.1 to 6.0. So that at least one of the root causes. PowerShell is a very heavy user of GetHashCode.",
      "created_at": "2018-08-08T08:53:57Z",
      "updated_at": "2018-08-08T08:53:57Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "We could implement fast GetHashCode for some (what?) internal classes. ",
      "created_at": "2018-08-09T04:40:38Z",
      "updated_at": "2018-08-09T04:40:38Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "I would rather push for corefx to have an opt-out option for randomized GetHashCode() (and use it in specific cases where it's not a security concern) rather than doing our own implementation if this is the perf blocker.",
      "created_at": "2018-08-09T16:39:45Z",
      "updated_at": "2018-08-09T16:39:45Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "It's worth checking if we're computing the hash code too often. Can the algorithm be improved?",
      "created_at": "2018-08-09T17:35:34Z",
      "updated_at": "2018-08-09T17:35:34Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@lzybkr  Tracking issue https://github.com/dotnet/corefx/issues/30994 . There seems to be no chance of doing Marvin algorithm faster.",
      "created_at": "2018-08-10T04:07:36Z",
      "updated_at": "2018-08-10T04:07:36Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@SteveL-MSFT I guess that having an opt-out option for randomized GetHashCode() is a problem - CoreFX do de-virtualization optimization for default GetHashCode() so without the optimization other GetHashCode() can be slower then de-virtualized Marvin.",
      "created_at": "2018-08-10T04:14:14Z",
      "updated_at": "2018-08-10T04:14:14Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "@lzybkr There are for sure things we do that could be improved, but I agree with @SteveL-MSFT  that at the end of the day, there still be quite a lot of calls to GetHashCode. So having a way to opt out seems like a good path. \r\n\r\nIn my view, one does not exclude the other.",
      "created_at": "2018-08-10T10:32:58Z",
      "updated_at": "2018-08-10T10:32:58Z"
    },
    {
      "author": "benaadams",
      "author_association": "NONE",
      "body": "> I would rather push for corefx to have an opt-out option for randomized GetHashCode() \r\n\r\nAlready exists\r\n\r\n> We could implement fast GetHashCode for some (what?) internal classes.\r\n\r\nFor `HashTable` your can pass a `IEqualityComparer` to the constructor. Better would to be to use the strongly typed  `HashSet<string>` and pass `IEqualityComparer<string>` to its constructor; which [implements a non-randomized HashCode](https://github.com/dotnet/coreclr/blob/30359cda224ee5d1f041921b420c3c9349793989/src/System.Private.CoreLib/shared/System/String.Comparison.cs#L756-L815). It can be a `readonly static` singleton object as it shouldn't require state.\r\n\r\n`Dictionary<string, TKey>` already has an opitimization for this if you don't specify the comparer for the `string`; but this doesn't currently exist in `HashSet<string>` (I don't think could exist in `HashTable` at the framework level as it is not strongly typed, so couldn't apply a fast path for strings).",
      "created_at": "2018-08-10T15:10:58Z",
      "updated_at": "2018-08-10T15:10:58Z"
    },
    {
      "author": "benaadams",
      "author_association": "NONE",
      "body": "Sorry I completely forgot what `Hashtable` did \ud83d\ude04 \r\n\r\nIts strongly typed equivalent is `Dictionary<TKey, TValue>` ",
      "created_at": "2018-08-11T21:26:28Z",
      "updated_at": "2018-08-11T21:26:28Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Current status.\r\n\r\n1. We added some optimizations to reduce allocations and increase performance. (Thanks @powercode!)\r\n2. I see @benaadams start work on 3 optimizations in CoreCLR. Thanks!\r\n\r\n3. We get new Issue #7603 about memory garbage. The same we see in current issue too - PowerShell Core doesn't free memory so fast as Windows PowerShell.\r\nI found related Issue https://github.com/aspnet/Home/issues/1976 It was splitted on some issues.\r\n",
      "created_at": "2018-08-24T06:05:30Z",
      "updated_at": "2018-08-24T11:49:36Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "In 6.1.0 RC1 trace I see that we do many allocations in System.Management.Automation.ReservedNameMembers.\r\n![generatepstypenames](https://user-images.githubusercontent.com/22290914/44656702-6b736980-a9e9-11e8-942b-4129b923031d.png)\r\nGeneratePSTypeNames(System.Object)\r\n\r\nMost in MemberMatch..ctor(). I have no idea if we can improve this, but it's surprising that we create links to standard methods dynamically while they could be static.\r\n",
      "created_at": "2018-08-27T11:11:14Z",
      "updated_at": "2018-08-27T11:11:14Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "@iSazonov I'd say that there is something strange with your profiling session. You have a call to `MemberMatch.ctor`, but that is never invoked. I tried changing the definition to a static class, and it still compiled fine.\r\n\r\nThere doesn't seem to be a path from GeneratePSTypeNames to PSNoteProperty.Copy either, so I'm not sure how much I would trust that data.\r\n\r\nWhen debugging, it is the same old `AddToTypesXmlCache` that shows up as the source of the copy. Not sure why the data is off. @vancem, can you help us here? \r\n\r\nA breakpoint in GeneratePSTypeNames is not hit at all during debugging, and yet it shows up in the profile.\r\n",
      "created_at": "2018-08-27T20:28:49Z",
      "updated_at": "2018-08-27T20:28:49Z"
    },
    {
      "author": "powercode",
      "author_association": "COLLABORATOR",
      "body": "@iSazonov, you must be running something else than me. Can you share your command?",
      "created_at": "2018-08-27T21:34:52Z",
      "updated_at": "2018-08-27T21:34:52Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@powercode I am using the test published above for Import-Csv (columns = 700, rows = 5000 - I start the test and stop the trace recording after some seconds). PowerShell Core 6.1.0 RC1 with crossgen.exe coped into pshome directory.\r\nScreenshot above is GC Heap Alloc Ignore Free.\r\nTraces https://files.fm/u/b2pysja2\r\nPerhaps I do something wrong :-(",
      "created_at": "2018-08-28T03:42:02Z",
      "updated_at": "2018-08-28T03:43:01Z"
    },
    {
      "author": "vancem",
      "author_association": "NONE",
      "body": "If you have symbols to system.management.Automation, setting up you symbol path (File -> Set Symbol Path) and source path (File -> Set Source Path), and then you can right click on a node name and select Goto Source, and PerfView will take you to the line (attributed with metric).    This allows you to see exactly what line is involved.\r\n\r\nNote that inlining can often make it hard to follow  because the name in the source is really the caller (or caller's caller \u2026).   Having the line number (which by the way is approximate, it may be the line before as well), is helpful to disambiguate.  \r\n\r\nIf you ever get suspicious about things, you can fall back to the debugger.   Set breakpoints (probably with hit counts, every 1000 or so) for some of the locations that PerfView pointed you at and you can see if they agree with the debugger.   \r\n\r\nI have looked at lots of traces, and I have only rarely seen something where a name could not be explained by inlining only very, very rarely (and it could have been me misinterpreting the code).   If by checking with the debugger, you believe you have found such a case, I would need all the source, PDBs and repro information to really investigate the issue.  \r\n",
      "created_at": "2018-08-28T20:07:44Z",
      "updated_at": "2018-08-28T20:07:44Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@vancem We haven't published PDB files for RC1. In PerfView log I saw that it search crossgen.exe and coped the utility in startup directory - right? After that I can see entry points in system.management.Automation",
      "created_at": "2018-08-29T07:03:28Z",
      "updated_at": "2018-08-29T07:04:12Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@iSazonov now that we have moved to .NET Core 3.0, can you rerun your perf test?",
      "created_at": "2019-06-20T05:26:41Z",
      "updated_at": "2019-06-20T05:26:41Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I'm even afraid to think about it :-))))\r\n\r\nWill do.",
      "created_at": "2019-06-20T06:03:27Z",
      "updated_at": "2019-06-20T06:03:27Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "| - | Windows PowerShell| PowerShell Core |\r\n| --- | --- | --- |\r\n| One column | 6-17s/9-16Mb | 1.8-3.4s/7.6-9.3Mb |\r\n| 700 columns | 55s/16Mb | 16s/10Mb |",
      "created_at": "2019-06-20T13:55:29Z",
      "updated_at": "2019-06-20T13:55:29Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@iSazonov So the perf issue with `Import-Csv` is now gone after moving to .NET 3.0 preview? What do you mean by `one column` and `700 columns`?",
      "created_at": "2019-06-20T14:41:06Z",
      "updated_at": "2019-06-20T14:41:06Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@daxian-dbw After @powercode improvements for PSObject all cmdlets works faster with the objects and make less allocations.\r\nAfter moving to .Net Core 3.0 we get better GC. Now GC does cleanups even better .Net Framework (I say about the tests I did here). Perhaps .Net Core 3.0 add a performance too but I don't compare with previous PowerShell Core released versions.\r\n\r\n> What do you mean by one column and 700 columns?\r\n\r\nIn my tests I generate csv files. In first test the csv file consists of one column. Second - 700 columns. The first test shows a general increase in performance (I would assume that most of it comes from .Net Core 3.0). Second one explicitly shows an increase in performance which comes from @powercode PR.",
      "created_at": "2019-06-20T17:58:32Z",
      "updated_at": "2019-06-20T17:58:32Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@iSazonov so can we close this?",
      "created_at": "2019-06-20T20:58:59Z",
      "updated_at": "2019-06-20T20:58:59Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "We get great progress for Import-Csv cmdlet so I close the issue. \r\n\r\nMake sense to open new issues if we will find another scenarios with bad performance.\r\n\r\n(Although I would like to have something to see performance history - improvements and regressions after new commits)",
      "created_at": "2019-06-21T04:21:52Z",
      "updated_at": "2019-06-21T04:21:52Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "> (Although I would like to have something to see performance history - improvements and regressions after new commits)\r\n\r\nAbsolutely. We need to have some perf tests that serve as benchmarks to help us see the trend. Currently we have none of those tests. Opened https://github.com/PowerShell/PowerShell/issues/9996",
      "created_at": "2019-06-24T16:02:11Z",
      "updated_at": "2019-06-24T16:02:11Z"
    }
  ],
  "created_at": "2018-06-19T15:17:57Z",
  "number": 7112,
  "state": "closed",
  "title": "Performance of Windows PowerShell is better then PowerShell Core",
  "updated_at": "2019-06-24T16:02:11Z"
}