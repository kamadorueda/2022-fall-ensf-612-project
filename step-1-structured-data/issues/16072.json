{
  "_url": "https://github.com/PowerShell/PowerShell/issues/16072",
  "author": "schiroky",
  "body": "### Prerequisites\n\n- [X] Write a descriptive title.\n- [X] Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\n- [X] Search the existing issues.\n- [X] Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\n- [X] Refer to [Differences between Windows PowerShell 5.1 and PowerShell](https://docs.microsoft.com/powershell/scripting/whats-new/differences-from-windows-powershell).\n\n### Steps to reproduce\n\nAs a prerequisite ensure to have the Azure Information Protection client installed and configured.\r\nWith that a particular registry key will be created:\r\n[HKCU:\\Software\\Classes\\Local Settings\\Software\\Microsoft\\MSIPC]\r\n\r\nTry to check for this key with the command:\r\n\r\nPS C:\\Windows\\System32> Test-Path -Path \"HKCU:\\Software\\Classes\\Local Settings\\Software\\Microsoft\\MSIPC\"\r\n\n\n### Expected behavior\n\n```console\nAs a result, you should see (on PowerShell 7.1.4.0 x64):\r\n\r\nPS C:\\Windows\\System32> True\n```\n\n\n### Actual behavior\n\n```console\nBut instead on PowerShell 7.1.4.0 x64 it returns:\r\n\r\nPS C:\\Windows\\System32> False\n```\n\n\n### Error details\n\n```console\nIn fact the key exist for sure. When checking the key with PowerShell 5.1, I always get the correct value returned:\r\n\r\nPS C:\\Windows\\System32> True\r\n\r\nI have created my own folder under the corresponding sub-key, and checking this is working. So at first we believed it must be related to the folder or it's settings. Nevertheless, why it works with PowerShell 5.1. Something seems to block 7.1 from reading this key.\r\nComparing a working and non-working folder does not show any differences. I also collaborated with an engineer from our AIP security team (responsible for the AIP client), but we did not find a difference.\r\n\r\nCould you please check and assist finding a work around or the cause of this problem, or even better a solution?\n```\n\n\n### Environment data\n\n```powershell\nName                           Value\r\n----                           -----\r\nPSVersion                      7.1.4\r\nPSEdition                      Core\r\nGitCommitId                    7.1.4\r\nOS                             Microsoft Windows 10.0.19042\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\n```\n\n\n### Visuals\n\n_No response_",
  "closed_at": "2021-09-19T00:00:40Z",
  "comments": [
    {
      "author": "dwtaber",
      "author_association": "CONTRIBUTOR",
      "body": "I created a key with the same name and location in my HKCU hive, and I was unable to reproduce the issue.  What are the permissions for the key?  Do you get the same results in elevated and non-elevated sessions?  Are you able to reproduce the issue on other machines?",
      "created_at": "2021-09-09T16:33:19Z",
      "updated_at": "2021-09-09T16:33:19Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "Would it possible to run the following gist on the registry key and compare it with one that works https://gist.github.com/jborean93/7dc4a3546f1d65159fb9cb5c1eb82446. You will have to run this in WinPS as it looks like I need to do more work to have it loadable in PSCore at some point.\r\n\r\n<details>\r\n  <summary>Click to expand!</summary>\r\n\r\n```powershell\r\nFunction Get-RegKeyInfo {\r\n    <#\r\n    .SYNOPSIS\r\n    Gets details about a registry key.\r\n\r\n    .DESCRIPTION\r\n    Gets very low level details about a registry key.\r\n\r\n    .PARAMETER Path\r\n    The path to the registry key to get the details for. This should be a string with the hive and key path split by\r\n    ':', e.g. HKLM:\\Software\\Microsoft, HKEY_CURRENT_USER:\\Console, etc. The Hive can be in the short form like HKLM or\r\n    the long form HKEY_LOCAL_MACHINE.\r\n\r\n    .EXAMPLE\r\n    Get-RegKeyInfo -Path HKLM:\\SYSTEM\\CurrentControlSet\r\n    #>\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(\r\n            Mandatory = $true,\r\n            Position = 0,\r\n            ValueFromPipeline = $true,\r\n            ValueFromPipelineByPropertyName = $true\r\n        )]\r\n        [String[]]\r\n        $Path\r\n    )\r\n\r\n    begin {\r\n        Add-Type -TypeDefinition @'\r\nusing Microsoft.Win32.SafeHandles;\r\nusing System;\r\nusing System.ComponentModel;\r\nusing System.Runtime.InteropServices;\r\nusing System.Text;\r\n\r\nnamespace Registry\r\n{\r\n    internal class NativeHelpers\r\n    {\r\n        [StructLayout(LayoutKind.Sequential)]\r\n        public struct KEY_BASIC_INFORMATION\r\n        {\r\n            public Int64 LastWriteTime;\r\n            public UInt32 TitleIndex;\r\n            public Int32 NameLength;\r\n            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)] public char[] Name;\r\n        }\r\n\r\n        [StructLayout(LayoutKind.Sequential)]\r\n        public struct KEY_FLAGS_INFORMATION\r\n        {\r\n            // This struct isn't really documented and most of the snippets online just show the UserFlags field. For\r\n            // whatever reason it seems to be 12 bytes in size with the flags in the 2nd integer value. The others I\r\n            // have no idea what they are for.\r\n            public UInt32 Reserved1;\r\n            public KeyFlags UserFlags;\r\n            public UInt32 Reserved2;\r\n        }\r\n\r\n        [StructLayout(LayoutKind.Sequential)]\r\n        public struct KEY_FULL_INFORMATION\r\n        {\r\n            public Int64 LastWriteTime;\r\n            public UInt32 TitleIndex;\r\n            public Int32 ClassOffset;\r\n            public Int32 ClassLength;\r\n            public Int32 SubKeys;\r\n            public Int32 MaxNameLen;\r\n            public Int32 MaxClassLen;\r\n            public Int32 Values;\r\n            public Int32 MaxValueNameLen;\r\n            public Int32 MaxValueDataLen;\r\n            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)] public char[] Class;\r\n        }\r\n\r\n        [StructLayout(LayoutKind.Sequential)]\r\n        public struct KEY_HANDLE_TAGS_INFORMATION\r\n        {\r\n            public UInt32 HandleTags;\r\n        }\r\n\r\n        [StructLayout(LayoutKind.Sequential)]\r\n        public struct KEY_LAYER_INFORMATION\r\n        {\r\n            public UInt32 IsTombstone;\r\n            public UInt32 IsSupersedeLocal;\r\n            public UInt32 IsSupersedeTree;\r\n            public UInt32 ClassIsInherited;\r\n            public UInt32 Reserved;\r\n        }\r\n\r\n        [StructLayout(LayoutKind.Sequential)]\r\n        public struct KEY_TRUST_INFORMATION\r\n        {\r\n            public UInt32 TrustedKey;\r\n            public UInt32 Reserved;\r\n        }\r\n\r\n        [StructLayout(LayoutKind.Sequential)]\r\n        public struct KEY_VIRTUALIZATION_INFORMATION\r\n        {\r\n            public UInt32 VirtualizationCandidate;\r\n            public UInt32 VirtualizationEnabled;\r\n            public UInt32 VirtualTarget;\r\n            public UInt32 VirtualStore;\r\n            public UInt32 VirtualSource;\r\n            public UInt32 Reserved;\r\n        }\r\n\r\n        public enum KeyInformationClass : uint\r\n        {\r\n            Basic = 0,\r\n            Node = 1,\r\n            Full = 2,\r\n            Name = 3,\r\n            Cached = 4,\r\n            Flags = 5,\r\n            Virtualization = 6,\r\n            HandleTags = 7,\r\n            Trust = 8,\r\n            Layer = 9,\r\n        }\r\n    }\r\n\r\n    internal class NativeMethods\r\n    {\r\n        [DllImport(\"NtDll.dll\")]\r\n        public static extern UInt32 NtQueryKey(\r\n            SafeHandle KeyHandle,\r\n            NativeHelpers.KeyInformationClass KeyInformationClass,\r\n            IntPtr KeyInformation,\r\n            Int32 Length,\r\n            out Int32 ResultLength\r\n        );\r\n\r\n        [DllImport(\"Advapi32.dll\", CharSet = CharSet.Unicode)]\r\n        public static extern Int32 RegOpenKeyExW(\r\n            SafeHandle hKey,\r\n            string lpSubKey,\r\n            KeyOptions ulOptions,\r\n            KeyAccessRights samDesired,\r\n            out SafeRegistryHandle phkResult\r\n        );\r\n\r\n        [DllImport(\"NtDll.dll\")]\r\n        public static extern Int32 RtlNtStatusToDosError(\r\n            UInt32 Status\r\n        );\r\n    }\r\n\r\n    internal class SafeMemoryBuffer : SafeHandleZeroOrMinusOneIsInvalid\r\n    {\r\n        public SafeMemoryBuffer() : base(true) { }\r\n        public SafeMemoryBuffer(int cb) : base(true)\r\n        {\r\n            base.SetHandle(Marshal.AllocHGlobal(cb));\r\n        }\r\n        public SafeMemoryBuffer(IntPtr handle) : base(true)\r\n        {\r\n            base.SetHandle(handle);\r\n        }\r\n\r\n        protected override bool ReleaseHandle()\r\n        {\r\n            Marshal.FreeHGlobal(handle);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    [Flags]\r\n    public enum KeyAccessRights : uint\r\n    {\r\n        QueryValue = 0x00000001,\r\n        SetValue = 0x00000002,\r\n        CreateSubKey = 0x00000004,\r\n        EnumerateSubKeys = 0x00000008,\r\n        Notify = 0x00000010,\r\n        CreateLink = 0x00000020,\r\n        Wow6464Key = 0x00000100,\r\n        Wow6432Key = 0x00000200,\r\n\r\n        Delete = 0x00010000,\r\n        ReadControl = 0x00020000,\r\n        WriteDAC = 0x00040000,\r\n        WriteOwner = 0x00080000,\r\n        StandardRightsRequired = Delete | ReadControl | WriteDAC | WriteOwner,\r\n        AccessSystemSecurity = 0x01000000,\r\n\r\n        Read = ReadControl | QueryValue | EnumerateSubKeys | Notify,\r\n        Execute = Read,\r\n        Write = ReadControl | SetValue | CreateSubKey,\r\n        AllAccess = StandardRightsRequired | 0x3F\r\n    }\r\n\r\n    [Flags]\r\n    public enum KeyFlags : uint\r\n    {\r\n        None = 0x00000000,\r\n        Volatile = 0x00000001,\r\n        Symlink = 0x00000002,\r\n    }\r\n\r\n    [Flags]\r\n    public enum KeyOptions : uint\r\n    {\r\n        None = 0x00000000,\r\n        Volatile = 0x00000001,\r\n        CreateLink = 0x00000002,\r\n        BackupRestore = 0x00000004,\r\n        OpenLink = 0x00000008,\r\n    }\r\n\r\n    public class KeyInformation\r\n    {\r\n        public DateTime LastWriteTime { get; internal set; }\r\n        public UInt32 TitleIndex { get; internal set; }\r\n        public string Name { get; internal set; }\r\n        public string Class { get; internal set; }\r\n        public Int32 SubKeys { get; internal set; }\r\n        public Int32 ValueCount { get; internal set ; }\r\n        public KeyFlags Flags { get; internal set; }\r\n        public bool VirtualizationCandidate { get; internal set; }\r\n        public bool VirtualizationEnabled { get; internal set; }\r\n        public bool VirtualTarget { get; internal set; }\r\n        public bool VirtualStore { get; internal set; }\r\n        public bool VirtualSource { get; internal set; }\r\n        public UInt32 HandleTags { get; internal set; }\r\n        public bool TrustedKey { get; internal set; }\r\n\r\n        /*  Parameter is invalid\r\n        public bool IsTombstone { get; internal set; }\r\n        public bool IsSupersedeLocal { get; internal set; }\r\n        public bool IsSupersedeTree { get; internal set; }\r\n        public bool ClassIsInherited { get; internal set; }\r\n        */\r\n    }\r\n\r\n    public class Key\r\n    {\r\n        public static SafeRegistryHandle OpenKey(SafeHandle key, string subKey, KeyOptions options,\r\n            KeyAccessRights access)\r\n        {\r\n            SafeRegistryHandle handle;\r\n            Int32 res = NativeMethods.RegOpenKeyExW(key, subKey, options, access, out handle);\r\n            if (res != 0)\r\n                throw new Win32Exception(res);\r\n\r\n            return handle;\r\n        }\r\n\r\n        public static KeyInformation QueryInformation(SafeHandle handle)\r\n        {\r\n            KeyInformation info = new KeyInformation();\r\n\r\n            using (var buffer = NtQueryKey(handle, NativeHelpers.KeyInformationClass.Basic))\r\n            {\r\n                var obj = (NativeHelpers.KEY_BASIC_INFORMATION)Marshal.PtrToStructure(\r\n                    buffer.DangerousGetHandle(), typeof(NativeHelpers.KEY_BASIC_INFORMATION));\r\n\r\n                IntPtr nameBuffer = IntPtr.Add(buffer.DangerousGetHandle(), 16);\r\n                byte[] nameBytes = new byte[obj.NameLength];\r\n                Marshal.Copy(nameBuffer, nameBytes, 0, nameBytes.Length);\r\n\r\n                info.LastWriteTime = DateTime.FromFileTimeUtc(obj.LastWriteTime);\r\n                info.TitleIndex = obj.TitleIndex;\r\n                info.Name = Encoding.Unicode.GetString(nameBytes, 0, nameBytes.Length);\r\n            }\r\n\r\n            using (var buffer = NtQueryKey(handle, NativeHelpers.KeyInformationClass.Full))\r\n            {\r\n                var obj = (NativeHelpers.KEY_FULL_INFORMATION)Marshal.PtrToStructure(\r\n                    buffer.DangerousGetHandle(), typeof(NativeHelpers.KEY_FULL_INFORMATION));\r\n\r\n                IntPtr classBuffer = IntPtr.Add(buffer.DangerousGetHandle(), obj.ClassOffset);\r\n                byte[] classBytes = new byte[obj.ClassLength];\r\n                Marshal.Copy(classBuffer, classBytes, 0, classBytes.Length);\r\n\r\n                info.Class = Encoding.Unicode.GetString(classBytes, 0, classBytes.Length);\r\n                info.SubKeys = obj.SubKeys;\r\n                info.ValueCount = obj.Values;\r\n            }\r\n\r\n            using (var buffer = NtQueryKey(handle, NativeHelpers.KeyInformationClass.Flags))\r\n            {\r\n                var obj = (NativeHelpers.KEY_FLAGS_INFORMATION)Marshal.PtrToStructure(\r\n                    buffer.DangerousGetHandle(), typeof(NativeHelpers.KEY_FLAGS_INFORMATION));\r\n\r\n                info.Flags = obj.UserFlags;\r\n            }\r\n\r\n            using (var buffer = NtQueryKey(handle, NativeHelpers.KeyInformationClass.Virtualization))\r\n            {\r\n                var obj = (NativeHelpers.KEY_VIRTUALIZATION_INFORMATION)Marshal.PtrToStructure(\r\n                    buffer.DangerousGetHandle(), typeof(NativeHelpers.KEY_VIRTUALIZATION_INFORMATION));\r\n\r\n                info.VirtualizationCandidate = obj.VirtualizationCandidate == 1;\r\n                info.VirtualizationEnabled = obj.VirtualizationEnabled == 1;\r\n                info.VirtualTarget = obj.VirtualTarget == 1;\r\n                info.VirtualStore = obj.VirtualStore == 1;\r\n                info.VirtualSource = obj.VirtualSource == 1;\r\n            }\r\n\r\n            using (var buffer = NtQueryKey(handle, NativeHelpers.KeyInformationClass.HandleTags))\r\n            {\r\n                var obj = (NativeHelpers.KEY_HANDLE_TAGS_INFORMATION)Marshal.PtrToStructure(\r\n                    buffer.DangerousGetHandle(), typeof(NativeHelpers.KEY_HANDLE_TAGS_INFORMATION));\r\n\r\n                info.HandleTags = obj.HandleTags;\r\n            }\r\n\r\n            using (var buffer = NtQueryKey(handle, NativeHelpers.KeyInformationClass.Trust))\r\n            {\r\n                var obj = (NativeHelpers.KEY_TRUST_INFORMATION)Marshal.PtrToStructure(\r\n                    buffer.DangerousGetHandle(), typeof(NativeHelpers.KEY_TRUST_INFORMATION));\r\n\r\n                info.TrustedKey = obj.TrustedKey == 1;\r\n            }\r\n\r\n            /*  Parameter is invalid\r\n            using (var buffer = NtQueryKey(handle, NativeHelpers.KeyInformationClass.Layer))\r\n            {\r\n                var obj = (NativeHelpers.KEY_LAYER_INFORMATION)Marshal.PtrToStructure(\r\n                    buffer.DangerousGetHandle(), typeof(NativeHelpers.KEY_LAYER_INFORMATION));\r\n\r\n                info.IsTombstone = obj.IsTombstone == 1;\r\n                info.IsSupersedeLocal = obj.IsSupersedeLocal == 1;\r\n                info.IsSupersedeTree = obj.IsSupersedeTree == 1;\r\n                info.ClassIsInherited = obj.ClassIsInherited == 1;\r\n            }\r\n            */\r\n\r\n            return info;\r\n        }\r\n\r\n        private static SafeMemoryBuffer NtQueryKey(SafeHandle handle, NativeHelpers.KeyInformationClass infoClass)\r\n        {\r\n            int resultLength;\r\n            UInt32 res = NativeMethods.NtQueryKey(handle, infoClass, IntPtr.Zero, 0, out resultLength);\r\n            // STATUS_BUFFER_OVERFLOW or STATUS_BUFFER_TOO_SMALL\r\n            if (!(res == 0x80000005 || res == 0xC0000023))\r\n                throw new Win32Exception(NativeMethods.RtlNtStatusToDosError(res));\r\n\r\n            SafeMemoryBuffer buffer = new SafeMemoryBuffer(resultLength);\r\n            try\r\n            {\r\n                res = NativeMethods.NtQueryKey(handle, infoClass, buffer.DangerousGetHandle(), resultLength,\r\n                    out resultLength);\r\n\r\n                if (res != 0)\r\n                    throw new Win32Exception(NativeMethods.RtlNtStatusToDosError(res));\r\n            }\r\n            catch\r\n            {\r\n                buffer.Dispose();\r\n                throw;\r\n            }\r\n\r\n            return buffer;\r\n        }\r\n    }\r\n}\r\n'@\r\n    }\r\n\r\n    process {\r\n        $resolvedPaths = $Path\r\n\r\n        foreach ($regPath in $resolvedPaths) {\r\n            if (-not $regPath.Contains(':')) {\r\n                $exp = [ArgumentException]\"Registry path must contain hive and keys split by :\"\r\n                $PSCmdlet.WriteError([Management.Automation.ErrorRecord]::new(\r\n                    $exp, $exp.GetType().FullName, 'InvalidArgument', $regPath\r\n                ))\r\n                continue\r\n            }\r\n            $hive, $subKey = $regPath -split ':', 2\r\n            $hiveId = switch ($hive) {\r\n                { $_ -in @('HKCR', 'HKEY_CLASES_ROOT') } { 0x80000000 }\r\n                { $_ -in @('HKCU', 'HKEY_CURRENT_USER') } { 0x80000001 }\r\n                { $_ -in @('HKLM', 'HKEY_LOCAL_MACHINE') } { 0x80000002 }\r\n                { $_ -in @('HKU', 'HKEY_USERS') } { 0x80000003 }\r\n                { $_ -in @('HKPD', 'HKEY_PERFORMANCE_DATA') } { 0x80000004 }\r\n                { $_ -in @('HKPT', 'HKEY_PERFORMANCE_TEXT') } { 0x80000050 }\r\n                { $_ -in @('HKPN', 'HKEY_PERFORMANCE_NLSTEXT') } { 0x80000060 }\r\n                { $_ -in @('HKCC', 'HKEY_CURRENT_CONFIG') } { 0x80000005 }\r\n                { $_ -in @('HKDD', 'HKEY_DYN_DATA') } { 0x80000006 }\r\n                { $_ -in @('HKCULS', 'HKEY_CURRENT_USER_LOCAL_SETTINGS') } { 0x80000007 }\r\n            }\r\n            if (-not $hiveId) {\r\n                $exp = [ArgumentException]\"Registry hive path is invalid\"\r\n                $PSCmdlet.WriteError([Management.Automation.ErrorRecord]::new(\r\n                    $exp, $exp.GetType().FullName, 'InvalidArgument', $regPath\r\n                ))\r\n                continue\r\n            }\r\n            if ($subKey.StartsWith('\\')) {\r\n                $subKey = $subKey.Substring(1)\r\n            }\r\n\r\n            $hive = [Microsoft.Win32.SafeHandles.SafeRegistryHandle]::new([IntPtr]::new($hiveId), $false)\r\n            $key = $null\r\n            try {\r\n                # We can't use the PowerShell provider because it doesn't set OpenLink which means we couldn't detect\r\n                # if the path was a link as the handle would be for the target.\r\n                $key = [Registry.Key]::OpenKey($hive, $subKey, 'OpenLink', 'QueryValue')\r\n                [Registry.Key]::QueryInformation($key)\r\n            }\r\n            catch {\r\n                $PSCmdlet.WriteError([Management.Automation.ErrorRecord]::new(\r\n                    $_.Exception, $_.Exception.GetType().FullName, 'NotSpecified', $regPath\r\n                ))\r\n                continue\r\n            }\r\n            finally {\r\n                $key.Dispose()\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nGet-RegKeyInfo -Path 'HKCU:\\Software\\Classes\\Local Settings\\Software\\Microsoft\\MSIPC'\r\n```\r\n</details>\r\n\r\nThis allows you to get information on a registry key that doesn't normally get exposed in .NET/PowerShell and it may identify some differences between a key that works and one that does not. If it does fail to open the key handle it will at least give you the error behind it as well.\r\n\r\n<blockquote><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\" width=\"48\" align=\"right\"><div><img src=\"https://github.githubassets.com/favicons/favicon.svg\" height=\"14\"> Gist</div><div><strong><a href=\"https://gist.github.com/jborean93/7dc4a3546f1d65159fb9cb5c1eb82446\">Gets detailed information about a registry key</a></strong></div><div>Gets detailed information about a registry key. GitHub Gist: instantly share code, notes, and snippets.</div></blockquote>",
      "created_at": "2021-09-09T19:26:09Z",
      "updated_at": "2021-09-09T19:27:53Z"
    },
    {
      "author": "schiroky",
      "author_association": "NONE",
      "body": "I have removed the Azure Information Protection client for testing, but issue still persist. I have tested on 3 systems (Windows 10 Enterprise) right now, and I can reproduce from scratch every time. I have manually created the key: issue persist. There's no difference running the command as user or elevated. The permissions of the key can not be the problem, because creating the key manually will end up in having the needed permissions. I'm admin on the box. I tried also renaming the manual created key 'MSIPC' to 'MSIPx' and this is working!\r\n\r\nHere's the output of the registry key compare:\r\n\r\nFor manual created MSIPC key causing the problem:\r\n\r\nLastWriteTime           : 10/09/2021 06:07:32\r\nTitleIndex              : 0\r\nName                    : MSIPC\r\nClass                   : \r\nSubKeys                 : 0\r\nValueCount              : 0\r\nFlags                   : None\r\nVirtualizationCandidate : False\r\nVirtualizationEnabled   : False\r\nVirtualTarget           : False\r\nVirtualStore            : False\r\nVirtualSource           : False\r\nHandleTags              : 0\r\nTrustedKey              : False\r\n\r\nFor same key renamed to MSIPx key not causing the problem:\r\n\r\nLastWriteTime           : 10/09/2021 06:08:34\r\nTitleIndex              : 0\r\nName                    : MSIPx\r\nClass                   : \r\nSubKeys                 : 0\r\nValueCount              : 0\r\nFlags                   : None\r\nVirtualizationCandidate : False\r\nVirtualizationEnabled   : False\r\nVirtualTarget           : False\r\nVirtualStore            : False\r\nVirtualSource           : False\r\nHandleTags              : 0\r\nTrustedKey              : False\r\n\r\n I have the impression that PowerShell core itself does something wrong here.\r\n",
      "created_at": "2021-09-10T06:22:38Z",
      "updated_at": "2021-09-10T06:22:38Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "There's nothing that jumps out on the output you've shared unfortunately. What's the output if you do `Get-Item -Path \"HKCU:\\Software\\Classes\\Local Settings\\Software\\Microsoft\\MSIPC\" -ErrorAction Stop`? Is `MSIPC` an actual registry key (item on the left hand pane of regedit) or a property (item on the right hand pane of regedit)?",
      "created_at": "2021-09-10T08:33:39Z",
      "updated_at": "2021-09-10T08:33:39Z"
    },
    {
      "author": "schiroky",
      "author_association": "NONE",
      "body": "It's about a registry key, not a property. Get-Item in PowerShell core 7.1.4 says:\r\n\r\nGet-Item: Cannot find path 'HKCU:\\Software\\Classes\\Local Settings\\Software\\Microsoft\\MSIPC' because it does not exist.\r\n\r\nStill, with PowerShell 5.1 is says:\r\n\r\n    Hive: HKEY_CURRENT_USER\\Software\\Classes\\Local Settings\\Software\\Microsoft\r\n\r\n\r\nName                           Property\r\n----                           --------\r\nMSIPC                          MSIPP-MK : {1, 0, 0, 0...}\r\n                               MSIPP-SK : {1, 0, 0, 0...}\r\n\r\nAnd the key exist - definitely.\r\n",
      "created_at": "2021-09-10T08:41:00Z",
      "updated_at": "2021-09-10T08:41:00Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Perhaps it's a difference in the permissions/etc of one of the parent keys here?",
      "created_at": "2021-09-10T12:35:41Z",
      "updated_at": "2021-09-10T12:35:41Z"
    },
    {
      "author": "schiroky",
      "author_association": "NONE",
      "body": "Can not be the cause, because it's working fine with PowerShell 5.1. Hence, cannot be a permission issue in any kind.",
      "created_at": "2021-09-10T12:38:21Z",
      "updated_at": "2021-09-10T12:38:21Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "One last thing to check is if .NET can open the key handle\r\n\r\n```powershell\r\n$hive = [Microsoft.Win32.RegistryKey]::OpenBaseKey(\"CurrentUser\", \"Default\")\r\n$key = $hive.OpenSubKey(\"Software\\Classes\\Local Settings\\Software\\Microsoft\\MSIPC\", $false)\r\nif ($null -eq $key) {\r\n    throw \"Could not open key handle\"\r\n}\r\n```\r\n\r\nCan you also check if your pwsh version is running as 32 or 64 bit and compare that with WinPS. Doing `[IntPtr]::Size` should be 4 for 32-bit and 8 for 64-bit. It's possible pwsh is running as a 32-bit process and thus the registry paths are slightly different due to the path virtualisation that happens. It's a similar problem with `C:\\WIndows\\System32`.",
      "created_at": "2021-09-10T22:33:15Z",
      "updated_at": "2021-09-10T22:33:15Z"
    },
    {
      "author": "schiroky",
      "author_association": "NONE",
      "body": "I'm running 64-bit versions and the command up in message \"Could not open key handle\" on PowerShell Core 7.1.4. Running PowerShell 5.1 does not throw the message.",
      "created_at": "2021-09-13T06:32:24Z",
      "updated_at": "2021-09-13T06:32:24Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "Considering the .NET code has failed would indicate a change in the .NET runtime rather than something done in PowerShell. The same class is what is used by the Registry provider in PowerShell and if that fails to open the key then you would expect PowerShell to also fail.\r\n\r\nI've had a brief look at the code across the versions and nothing is jumping out at me, it essentially looks the same and calls [RegOpenKeyEx](https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regopenkeyexw) in the same manner. Unfortunately the same method also ignores errors other than `ERROR_ACCESS_DENIED` and returns `$null` if it failed to open the key making it harder to identify why it may have failed to open. You can manually call the same Win32 function and raise an error by calling\r\n\r\n```powershell\r\nAdd-Type -TypeDefinition @'\r\nusing Microsoft.Win32.SafeHandles;\r\nusing System;\r\nusing System.ComponentModel;\r\nusing System.Runtime.InteropServices;\r\n\r\nnamespace Registry\r\n{\r\n    public class NativeMethods\r\n    {\r\n        [DllImport(\"Advapi32.dll\", CharSet = CharSet.Unicode)]\r\n        private static extern Int32 RegOpenKeyExW(\r\n            SafeHandle hKey,\r\n            string lpSubKey,\r\n            KeyOptions ulOptions,\r\n            KeyAccessRights samDesired,\r\n            out SafeWaitHandle phkResult);\r\n            \r\n        public static SafeHandle RegOpenKeyEx(SafeHandle key, string subKey, KeyOptions options,\r\n            KeyAccessRights access)\r\n        {\r\n            SafeWaitHandle handle;\r\n            Int32 res = RegOpenKeyExW(key, subKey, options, access, out handle);\r\n            if (res != 0)\r\n                throw new Win32Exception(res);\r\n\r\n            return handle;\r\n        }\r\n    }\r\n\r\n    [Flags]\r\n    public enum KeyAccessRights : uint\r\n    {\r\n        QueryValue = 0x00000001,\r\n        SetValue = 0x00000002,\r\n        CreateSubKey = 0x00000004,\r\n        EnumerateSubKeys = 0x00000008,\r\n        Notify = 0x00000010,\r\n        CreateLink = 0x00000020,\r\n        Wow6464Key = 0x00000100,\r\n        Wow6432Key = 0x00000200,\r\n\r\n        Delete = 0x00010000,\r\n        ReadControl = 0x00020000,\r\n        WriteDAC = 0x00040000,\r\n        WriteOwner = 0x00080000,\r\n        StandardRightsRequired = Delete | ReadControl | WriteDAC | WriteOwner,\r\n        AccessSystemSecurity = 0x01000000,\r\n\r\n        Read = ReadControl | QueryValue | EnumerateSubKeys | Notify,\r\n        Execute = Read,\r\n        Write = ReadControl | SetValue | CreateSubKey,\r\n        AllAccess = StandardRightsRequired | 0x3F\r\n    }\r\n\r\n    [Flags]\r\n    public enum KeyOptions : uint\r\n    {\r\n        None = 0x00000000,\r\n        Volatile = 0x00000001,\r\n        CreateLink = 0x00000002,\r\n        BackupRestore = 0x00000004,\r\n        OpenLink = 0x00000008,\r\n    }\r\n}\r\n'@\r\n\r\n# HKCU = 0x80000001\r\n$hive = [Microsoft.Win32.SafeHandles.SafeRegistryHandle]::new([IntPtr]::new(0x80000001), $false)\r\n$keyPath = \"Software\\Classes\\Local Settings\\Software\\Microsoft\\MSIPC\"\r\n$writable = $false\r\n\r\n[Registry.KeyAccessRights]$access = \"Read\"\r\nif ($writable) {\r\n    $access = $access -bor \"Write\"\r\n}\r\n[Registry.NativeMethods]::RegOpenKeyEx($hive, $keyPath, \"None\", $access).Dispose()\r\n```\r\n\r\nTry running that in both Windows PowerShell and PowerShell and see what the results are. I would also set `$writable = $true` for testing to see if it makes any difference when trying to open the keys.",
      "created_at": "2021-09-15T20:10:38Z",
      "updated_at": "2021-09-15T20:10:38Z"
    },
    {
      "author": "schiroky",
      "author_association": "NONE",
      "body": "Running this on PowerShell 7.1.4 result into:\r\n\r\nMethodInvocationException:\r\nLine |\r\n  77 |  [Registry.NativeMethods]::RegOpenKeyEx($hive, $keyPath, \"None\", $acce \u2026\r\n     |  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n     | Exception calling \"RegOpenKeyEx\" with \"4\" argument(s): \"The system cannot find the file specified.\"\r\n\r\nRunning on PowerShell 5.1 is working with no feedback. So just fine. Regardless if I set $writable or not.\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2021-09-16T13:54:02Z",
      "updated_at": "2021-09-16T13:54:02Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "This is probably as low level as you can get without delving into the undocument NT APIs. [RegOpenKeyEx](https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regopenkeyexw) is **the** Win32 function used to open a handle to the key and if that's complaining that the path doesn't exist then there's some sort of mechanism happening to hide this stuff from the process.\r\n\r\nHave you installed PowerShell from the Windows store? IIRC it uses some sort of virtualised registry that essetially silo's the application stopping it from writing (and looks like reading) registry keys. See the following related issues\r\n\r\n* https://github.com/PowerShell/PowerShell/issues/15626\r\n* https://github.com/PowerShell/PowerShell/issues/14957\r\n* https://github.com/PowerShell/PowerShell/issues/14093\r\n* https://github.com/PowerShell/PowerShell/issues/12237\r\n* https://github.com/PowerShell/PowerShell/issues/14407\r\n\r\nLooking a bit deeper it seems like this is due to an incorrect manifest for the PowerShell MSIX package that is shipped with the store and has subsequently been fixed with https://github.com/PowerShell/PowerShell/pull/15375. The fix is in place for 7.2.x but 7.1.x still has the broken manifest. I've posted a comment asking if it can be backported to 7.1.x but for the time being to get access to the registry location you should use PowerShell installed from an `.msi` rather than the store.\r\n\r\nIf you aren't using the MSIX/store package of PowerShell I honestly have no clue what the issue could be. It's not a problem specific in the PowerShell code but rather how PowerShell as a process is working in the OS.",
      "created_at": "2021-09-16T21:53:06Z",
      "updated_at": "2021-09-16T21:53:06Z"
    },
    {
      "author": "schiroky",
      "author_association": "NONE",
      "body": "Wow, that's it! I had installed PowerShell from the Store, yes. I have removed it and I installed the .msi. Catch - problem does not occur anymore. \r\n\r\nThank you so much!\r\n\r\nThe ticket can be closed by now.\r\n",
      "created_at": "2021-09-17T05:55:44Z",
      "updated_at": "2021-09-17T05:55:44Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "Glad we could solve it.",
      "created_at": "2021-09-17T06:19:27Z",
      "updated_at": "2021-09-17T06:19:27Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This issue has been marked as answered and has not had any activity for **1 day**. It has been closed for housekeeping purposes.",
      "created_at": "2021-09-19T00:00:39Z",
      "updated_at": "2021-09-19T00:00:39Z"
    }
  ],
  "created_at": "2021-09-09T13:51:49Z",
  "labels": [
    "Issue-Question",
    "Resolution-Answered",
    "WG-Cmdlets-Management"
  ],
  "number": 16072,
  "state": "closed",
  "title": "Test-Path does not work as expected on PowerShell 7.1.4 for a particular registry key",
  "updated_at": "2021-09-19T00:00:40Z"
}