{
  "_url": "https://github.com/PowerShell/PowerShell/issues/6467",
  "author": "mklement0",
  "body": "* The primary purpose of this issue to highlight how the existing behavior may be surprising to newcomers (and even for seasoned users hard to remember and therefore predict in specific situations).\r\n\r\n* Given that the behavior has been around since the beginning, changing it is probably not an option, but _documenting_ how the behavior may be surprising is worth doing; while _some_ aspects of the behavior can be inferred from [`about_Parsing`](https://github.com/PowerShell/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/About/about_Parsing.md), the overall implications aren't clear.\r\n  * @SteveL-MSFT: This issue subsumes #3217, which therefore no longer needs the `Documentation Needed` label.\r\n\r\n* While this may ultimately become a [documentation-repo issue](https://github.com/PowerShell/PowerShell-Docs/issues), I would first like to solicit some feedback as to what code changes, if any, should be considered, after all (there are edge cases), and as to whether my summary is accurate.\r\n\r\n* While there may be good _technical_ reasons for these behaviors, the problem is that they may be unexpected, especially given the deviation from how `cmd.exe` and `bash` handle these scenarios.\r\n\r\n* All surprising behaviors can be avoided with proper _quoting_ - which is also worth pointing out in the docs -  but the need to quote negates one of the convenient aspects of argument syntax. If at the end of the day you cannot remember whether a particular token _requires_ quoting, your choices are to resort to trial and error, or to quote _everything_, which is cumbersome.\r\n\r\nNote: By **_compound command-line token_** I mean a **logically single token composed of the _following syntax constructs_ by _direct concatenation_**:\r\n \r\n* barewords (unquoted strings without special meaning; e.g., `foo`)\r\n* quoted strings (e.g.; `'bar'`, `\"baz\"`)\r\n* variable references (`$foo`) and subexpressions (`$(...)`)\r\n\r\nExamples:\r\n\r\n* `bar${foo}` and `${foo}bar` and `$($foo)bar`\r\n* `foo\"bar\"` and `\"bar\"foo`\r\n\r\n**The surprising aspects are**:\r\n\r\n### Asymmetry: Whether a quoted string or subexpression comes _first_ matters:\r\n\r\nPlacing the quoted string or subexpression _first_ results in *2* arguments:\r\n\r\n```powershell\r\nPS> Write-Output 'hi'there\r\nhi\r\nthere\r\n\r\n> Write-Output $($env:HOME)/Documents\r\n/Users/jdoe\r\n/Documents\r\n```\r\n\r\nOtherwise, a _single_ argument is passed, as expected:\r\n\r\n```powershell\r\nPS> Write-Output hi'there'\r\nhithere\r\n\r\nPS> Write-Output Documents:$($env:HOME)  # Note: just $env:HOME without $() is not affected.\r\nDocuments:/Users/jdoe\r\n```\r\n\r\n###  `.` following a leading quoted string is interpreted as [string] property access\r\n\r\n```powershell\r\nPS> Write-Output 'hi'.there\r\n   # NO output, because an attempt is made to access property .there on the string instance\r\n```\r\n\r\n###  `.` as the initial char. followed by a quoted string results in *2* arguments\r\n\r\n```powershell\r\nPS> Write-Output .'hi'\r\n.\r\nhi\r\n```\r\n\r\n###  `-` as the initial char. in something that turns out _not_ to be a parameter name  results in *2* arguments with the presence of `:` or `.` \r\n\r\nSee also: #6292 and #6360.\r\n\r\n```powershell\r\nPS> Write-Output -foo:bar\r\n-foo:\r\nbar\r\n\r\nPS> Write-Output -ip=10.0.0.1\r\n-ip=10\r\n.0.0.1\r\n```\r\n###  `-` as the initial char. causes embedded variable references not to be expanded\r\n\r\nSee also: #4624.\r\n\r\n```powershell\r\nPS> Write-Output a$HOME\r\na/home/jdoe  # e.g.; $HOME was expanded, as expected\r\n\r\nPS> Write-Output -a$HOME\r\n-a$HOME  # !! $HOME was NOT expanded\r\n```\r\n\r\nNote that the problem only surfaces if the there's at least 1 literal char. following the `-` before the variable reference; for instance, in `-$HOME` the variable _is_ expanded.\r\n\r\n\r\nEnvironment data\r\n----------------\r\n\r\nWritten as of:\r\n\r\n```powershell\r\nPowerShell Core v6.0.2\r\n```\r\n",
  "closed_at": "2018-10-31T20:47:56Z",
  "comments": [
    {
      "author": "BrucePay",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 wrt your comment, \r\n> deviation from how cmd.exe and bash handle these scenarios.\r\n\r\nJust so you'll have the context, traditional shells like bash are 'expand and parse shells'. They work as follows:\r\n1. a line of text is read\r\n2. quote removal is done, variables are expanded inline\r\n3. The expanded line is then parsed and executed. \r\nIt is important to note step 2 - the values of variables are expanded in place as _strings_. This _could not work_ for PowerShell with _live object_. Even if we went with some form of deserialized object in the string, the performance impact would be unacceptable. \r\n\r\nPowerShell language processing is much more akin to python or ruby:\r\n1. a line of text is read\r\n2. the text is tokenized and parsed (there are deals between the tokenized and the parser so I made it one step.)\r\n3. AST/code are generated and executed.\r\n\r\nThe expand-and-parse approach results in a particular set of characteristics. The parse-then-execute approach results in a different set of characteristics. PowerShell will never behave exactly like bash, It's fundamentally different. Our hope with PowerShell, was to have an equivalently flexible interactive experience while retaining the ability to script with true objects.\r\n\r\n> Whether a quoted string or subexpression comes first matters:\r\n\r\nIn both cases, you simply have a delimited token. '...' or $(...). After the trailing delimiter, scanning for the next token begins. Spaces are not needed to separated the tokens. The only thing that matter is that a complete token has been read.\r\n\r\n>  following a leading quoted string is interpreted as [string] property access\r\n\r\nNot exactly. If a '.' appears after a completed argument (string literal, variable, etc) then it will be treated as a member accessor expression, with the constraint that there can be no space before the '.' and the preceding token.\r\n```\r\nPS[1] (130) > write-output @{a=1;b=2}.count # Literal hashtable\r\n2\r\nPS[1] (131) > write-output \"abc\".length  # Literal string\r\n3\r\nPS[1] (132) > write-output (get-date).dayofweek # Cmdlet call\r\nThursday\r\n```\r\n> as the initial char. in something that turns out not to be a parameter name results in 2 arguments with the presence of ':' \r\n\r\nNo. The type of a token is determined at **parse time** and only at parse time. How a parameter token (-param:) gets treated eventually depends on the type of command that is being bound. With [cmdletbinding()], if there isn't a format parameter corresponding to the actual parameter, you get an error. With simple functions, if there is a formal parameter with a matching name, then it gets bound otherwise it gets added to $args. If it's a native command, it gets passed as a string since that's all that can be passed to a native command. There is a fiddle that tries to stitch the two tokens \"-parm:\" and \"value\" back into a single string for literal arguments and there are requests to extend this fiddle. I'm beginning to think that would be a bad idea since the current hack seems to be causing people to make untrue assumptions. The more special cases there are the harder it is to explain.",
      "created_at": "2018-03-22T21:44:23Z",
      "updated_at": "2018-03-22T21:44:23Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@BrucePay: \r\n\r\nFirst things first: \r\n\r\nI appreciate the detailed response and illuminating peek behind the curtain.\r\n\r\nAny changes to the existing behavior are probably too risky, but I want us to have clarity what a better approach might look like if and when the time comes where a change is feasible.\r\n\r\nIn the meantime, the list I've compiled is hopefully useful to _document_ for others coming from a Bash / cmd background how the actual behavior may differ from their expectations.\r\n\r\n---\r\n\r\n> PowerShell will never behave exactly like bash, It's fundamentally different.\r\n> the values of variables are expanded in place as strings. This could not work for PowerShell with live object. \r\n\r\nAbsolutely, in general, but in the case at hand - the compound tokens I describe - we are _also_ dealing with _strings_ - at least that's the only sensible interpretation.\r\n\r\nOne way to simplify the behavior is to _consistently_ treat the components of a compound token as _separate arguments_, which is a simple rule that would be easy to remember.\r\n\r\nAll you would then have to tell Bash / cmd users is: in order to join distinct syntax constructs to form a single (string) argument, always use string interpolation _explicitly_, i.e., enclose the entire token in `\"...\"`.\r\n\r\n---\r\n\r\n> In both cases, you simply have a delimited token. '...' or $(...). After the trailing delimiter, scanning for the next token begins. Spaces are not needed to separated the tokens.\r\n\r\nExcept that in the case of `hi\"there\"` - as opposed to `\"hi\"there` - spaces _are_ needed, given that it is interpreted as a _single_ argument.\r\n\r\n> If a '.' appears after a completed argument (string literal, variable, etc) then it will be treated as a member accessor expression, with the constraint that there can be no space before the '.' and the preceding token.\r\n\r\nWhile that makes perfect sense for an expression with a leading `$`, `@`, or `(`, (e.g., `$Host.Name`, `$(Get-Date).Ticks`, `@(1, 2).Count`, `(Get-Date).Ticks`, I question the value of doing it for _string literals_ (e.g., `'foo'.bar`).  \r\nGranted, you could do something like `'foo'.ToUpper()`, but the likelihood that the user intent is to treat the `.` as a _literal_ and conceive of the token as a multi-quoting-style _string_ is much greater.\r\n\r\n(Again, if `'foo'` and `.bar`, due to being syntactically distinct elements, consistently became distinct arguments, that problem wouldn't arise.)\r\n\r\n> There is a fiddle that tries to stitch the two tokens \"-parm:\" and \"value\" back into a single string for literal arguments and there are requests to extend this fiddle. I'm beginning to think that would be a bad idea since the current hack seems to be causing people to make untrue assumptions. The more special cases there are the harder it is to explain.\r\n\r\nI whole-heartedly agree with the sentiment about special cases.\r\n\r\n[Applying the hack consistently](https://github.com/PowerShell/PowerShell/issues/6292#issuecomment-374009123) whenever something turns out _not_ to be a named parameter _reduces_ the number of special cases - at least from the _user's_ perspective, which I think is more important.\r\n\r\nThe alternative is to _disallow_ the use of such pseudo-parameters (except when calling _external_ programs) and _fail_ in their presence, informing users they need to use _quoting_.\r\n\r\nBy contrast, the current behavior of simply splitting the token into _two_ arguments is useless.\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2018-03-26T19:41:26Z",
      "updated_at": "2018-04-05T22:16:40Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "@mklement0: if this is purely a doc bug now, would you mind closing this issue so we can track everything in PowerShell/PowerShell-Docs#3038 ? Thanks!",
      "created_at": "2018-10-31T20:43:52Z",
      "updated_at": "2018-10-31T20:43:52Z"
    },
    {
      "author": "UberKluger",
      "author_association": "NONE",
      "body": "@mklement0\r\nI think I can explain all your \"surprising aspects\". (using @BrucePay's answer for some information) Note: the explanations are somewhat comprehensive so that this comment can be a stand alone description of the actual behaviour, not just a reply/analysis of your issue.\r\n\r\n**Asymmetry: Whether a quoted string or subexpression comes first matters:**\r\n\r\nActually, the problem here is one of definition. The idea that command arguments are always separated by (un-escaped) white-space (as in bash) and the bits between the spaces are the individual \"arguments\" no longer applies when the command line is parsed according to a (complex) grammar where white-space is just one of several token separators/terminators. If a quoted string or subexpression is the first thing seen (in a space delimited \"argument\") then it is not the first *part* of the argument, it is an *entire* argument (after evaluation in *expression* mode). What follows is *another* argument (evaluated in expression or argument mode as appropriate). If the beginning of the \"argument\" (first token) does not invoke expression mode evaluation (e.g. the quoted string or subexpression is not \"first\") then the \"argument\" is parsed in *argument* mode. Even then, the \"argument\" might be terminated by something other than finding space (e.g. a grouping `( )` ). There is no \"asymmetry\" because in one case you have two syntactically separate arguments and in the other case you have one argument with parts that just look like the first case re-arranged (two apples vs one orange or maybe an apple and a kumquat vs an orange).\r\n\r\n**. following a leading quoted string is interpreted as [string] property access**\r\n\r\nThis is actually a derivative of the previous one. The leading quoted string switches evaluation to *expression* mode. So when dealing with a string literal, which makes more sense, treating `'foo'.bar` as a member access or as an automatic concatenation?\r\nI would suggest that the answer depends upon which is the easiest to do in some other way (and then choose the meaning to be the other one).\r\n\r\nIf the user's intent was to create a concatenation of 2 literal strings, well that's trivial - `'foo.bar'`\r\nWhat about a non-literal? `'foo'.$x` Again, that's easy - `\"foo.$x\"`\r\nIn each case it was even the same number of characters, just re-arranged slightly (and change `'` into `\"`).\r\n\r\nNow, what if we **really** wanted to do a member access on a literal string, how else could we do that? It's not *that* difficult - `$('foo').bar` or `$('foo').$x`- but it is *more* complicated. So let's choose member access since it sometimes makes things just that little bit easier without increasing the difficulty the rest of the time.\r\n\r\nFurther, as @BrucePay noted, the sequences `$( )`, `\" \"` and `' '` are all \"delimited tokens\". Initially I considered adding `{ }` (script block) as it is a \"delimited\" token but its behaviour differs in the next section (argument not beginning with delimited token).\r\n\r\nIf an argument begins with a delimited token then it ends with the token **unless** *immediately* followed by a member access or indexer expression (`.`something with no spaces allowed or `[` numeric expression `]`) in which case it is (always) a member access / indexed token, which ends at the end of the member access / indexer expression **unless** *immediately* followed ... (and so on, recursively). Thus, the behaviour is consistent for all forms. Making (expandable or verbatim) string tokens act differently would create divergent behaviour (aka special case).\r\n\r\n**. as the initial char. followed by a quoted string results in 2 arguments**\r\n\r\nThis one took a bit of research (and some guess work due, I suspect, to inadequate documentation). In fact, the \"problem\" is bigger than stated. A single `.` *immediately* followed by an expression of any kind results in separate arguments. Of course, this would be expected for grouping `( )` and script blocks `{ }` but also applies to subexpressions `$( )`, strings (both types) and variable access (with or without member access). Why? Because (I think) a single `.` is being parsed as a call operator. Yes, I know it is referred to as the \"dot sourcing operator\" but this only applies when invoking powershell script files. `.` works exactly like `&` when the target is something other than a powershell script file. It just needs to be separated from its argument (to prevent it being treated as part of a file path). If its argument is a token of itself (such as a string or variable reference) then no space is necessary. Obviously, using `.` as a call operator is only meaningful if it is the first token in the command but apparently the token parser doesn't care where it is, just whether it satisfies the grammar for being treated as a separate token, i.e. NOT prepended to a bare word.\r\n\r\n**- as the initial char. in something that turns out not to be a parameter name results in 2 arguments with the presence of : or .**\r\n**- as the initial char. causes embedded variable references not to be expanded**\r\n\r\nI suspect these two are different facets of the same \"problem\". By beginning an argument with `-`, I suspect that powershell prepares to form a named parameter argument and that's how it's parsed. If the \"argument\" matches a certain pattern (see below) then it is considered to be a parameter name (and possible value). The following regular expression defines what is considered to be a named parameter argument (for ASCII only, Unicode more complicated):\r\n```\r\nwhile ( $argstr = read-host ) {\r\n  if ( $argstr -match '(-[_A-Za-z?][^\"&''(,.:;[{|}]*(?::|(?=[ &(),.[{|}])))?(.*)' ) {\r\n    \"Named parameter: {0}`nRemainder: {1}\" -f $matches[1..2]\r\n  }\r\n}\r\n```\r\nInterestingly, among the characters that terminate a parameter name, `:` is parsed into the parameter *name* while the rest start the next token. Even if powershell discovers that there is no parameter of that name, it still passes the separated name/value arguments (presumably so the invoked cmdlet/function can figure out what it wants to do), only restoring the original argument text if invoking a native command. Note: the same thing happens if a cmdlet/function is supplied with a splatting hash table with unexpected parameter names. The extra names and values appear in `$args` as `-paramname:` followed by the value in the next element.\r\nOnce powershell is expecting that an argument includes a parameter name specification, why would it apply variable expansion? This is another case of \"which is easier to do another way\". If you want programmatic control over which parameters get supplied, a splatting hash table is a better way (at least for invoking cmdlets/functions). If you allowed variable substitutions in parameter names then how do you specify a named parameter argument with a `$` in its name (totally legal)\r\n```\r\nfunction contrived(${heybig$pender}) { echo ${heybig$pender} }\r\n\r\ncontrived -heybig$pender:$false\r\n```\r\nYou could require the `$` to be escaped but then it doesn't *look* like the same parameter name. I also point out (tongue firmly in cheek :smirk:) that programmatically adjusting parameter names is text manipulation not object manipulation (like splatting). Very 1990's and not powershelly at all but possibly necessary when invoking native commands because splatting is rather cmdlet/function centric (for native commands, just use expandable strings for the parameter names/values). An interesting, and perhaps even more \"surprising\", aspect of the \"is it a parameter name\" check is that, even if the pattern match fails, there is no backtracking. A variable substitution will be ignored up to the point where the pattern match fails but **will** occur if it appears *after* the point of failure\r\n```\r\nWrite-Host -param$HOME'quoted'$HOME.length\r\n-param$HOMEquotedC:\\users\\user.length\r\n```\r\nso it would seem that there are actually 3 modes when parsing a command line, expression mode, argument mode AND parameter name literal mode. The initial `-` selects parameter name literal mode and then the invalid parameter name character (`'` in the example) switches back to argument mode **from that point**.\r\n\r\nAnd, of course, essentially none of the above is detailed in the documentation. Actually, what I found most lacking in the documentation (until I start researching this comment) was the explanation of the behaviour when the beginning of the argument is **NOT** an expression / parameter name literal mode invoking token, i.e. a bare word or direct variable access (no member access / indexer). In this case, it seems, the resulting argument is the concatenation of the value of every subsequent delimited token (not script blocks), direct variable access token (ignoring potential member access / indexer expressions) or bare word token (the value being the characters comprising it, between the end of the previous token and the beginning of the next token type) until a token other than one of these is found. Also, if the \"value\" of a subexpression is an array or maybe anything that implements `[IList]` (but not `[IEnumerable]` since hash tables aren't enumerated) then it is enumerated and all the elements converted to strings and joined by space. All this is to be gleaned from several unexplained examples. (Even this description is likely wrong or incomplete.) \r\n\r\nComments regarding opinions:\r\n\r\n>> PowerShell will never behave exactly like bash, it's fundamentally different.\r\n>> (In bash) The values of variables are expanded in place as strings. This could not work for PowerShell with live object(s).\r\n>\r\n> Absolutely, in general, but in the case at hand - the compound tokens I describe - we are also dealing with strings - at least that's the only sensible interpretation.\r\n\r\nThe bit that was not stated by @BrucePay in the above changes this a bit\r\n>> The values of variables **(which are all strings)** are expanded in place as strings.\r\n\r\nSo yes, the compound tokens are strings BUT they are generated from the values of objects with many properties of varying types that need to be selected (individually or in groups) and converted to strings. Clearly a much more complicated grammar and evaluation process is required. Just assuming that the default interpretation of a (string like) construct is intended to be a (literal) string doesn't allow much versatility and could introduce complexity and confusion if that interpretation differed from the same construct's meaning elsewhere.\r\n\r\n> Granted, you could do something like 'foo'.ToUpper(), but the likelihood that the user intent is to treat the `.` as a literal and conceive of the token as a multi-quoting-style string is much greater.\r\n\r\nI myself wouldn't think of it that way because just about everywhere else in powershell, that is syntactically similar, it would be a member access operator. Syntactically similar means a string with nothing stuck on the front of it. I suspect that just about everybody would look at\r\n```\r\n(nothing here touching the string) 'foo'.ToUpper()\r\n```\r\nand think, \"Yep, member access\", not \"Um, member access unless maybe it is a command argument\" (the second one being a fairly typical response to a \"special case\"). Just because a semantic grammar allows largely useless constructs doesn't mean those constructs should be repurposed to provide something more meaningful, particularly if there already exist equally effective ways to achieve the desired result. The useless constructs will simply not be used. Is this a waste? Think about this. A regular expression defines a set of strings that match the expression. How many of us actually generate every string from that expression (assuming it is a finite set)? We just use the expression to achieve a certain result. So it is here. The powershell grammar allows things like `'foo'.ToUpper()` but that doesn't mean anybody has to use it. It's not a waste because the existence of the grammar (and thus `'foo'.ToUpper()`) allows us to achieve our goal. The trick (as it relates to this thread) is to understand how the grammar works so that the difference between things like `'foo'.bar` and `bar.'foo'` in a command argument is well known. To this end, the fewer \"unless maybe\"s, the better.\r\n\r\nAlso, you probably wouldn't do `'foo'.ToUpper()` very often but you might like the ability to do\r\n```\r\n'Some really very long string that contains a whole lot of characters and might even extend over several lines'.ToCharArray()\r\n```\r\nSure, you could do `$([char[]]'Some really ... several lines')`, which is similar, so how about\r\n```\r\n'55'.PadLeft(20,'#')\r\n```\r\nYou'd have to enter (exactly) 18 `#`s. Tedious, much! What if the string were actually compound with unknown length\r\n```\r\n\"$intpart.${fracpart}e$exppart\".PadLeft(20,'~')\r\n```\r\nGranted, these are somewhat esoteric examples and the last one isn't a \"constant\" string but then how often would you want to **auto** concatenate 2 **known** strings. From the last example, would you want to split the behaviour up, not between strings `' '`/`\" \"` and non-strings `$( )` but between verbatim strings and the other (potentially non-constant) expandable strings and subexpressions?\r\n\r\n>(Again, if 'foo' and .bar, due to being syntactically distinct elements, consistently became distinct arguments, that problem wouldn't arise.)\r\n\r\nSo what about the syntactically distinct parts of\r\n- $Host.Name\r\n- $(Get-Date).Ticks\r\n- @(1, 2).Count\r\n- (Get-Date).Ticks\r\n\r\nIs `'foo'` just an object with properties like the example objects, or is it special?\r\n\r\n(Just a note: your initial examples contain `foo\"bar\"` and `bar\"foo\"` which are syntactically identical. Did you mean `\"bar\"foo`?)",
      "created_at": "2021-06-13T15:54:51Z",
      "updated_at": "2021-06-13T15:54:51Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@UberKluger:\r\n\r\nThe point of creating this issue was to point out that the existing behavior - even though it can be explained - is:\r\n\r\n* counterintuitive\r\n* governed by too many, inconsistent rules.\r\n\r\nAnd, yes, in the initial post I meant to contrast `foo\"bar\"` and `\"bar\"foo` (now fixed), and their different behavior is a prime example of these issues.\r\n\r\nGiven that changing to a straightforward a compound-token-is-always-implicitly-an-expandable-string approach is not an option due to backward-compatibility concerns, the next best thing is to _document_ these rules (when I initially created the issue, I was wondering whether at least _some_ inconsistencies could be remedied as [bucket 3](https://github.com/PowerShell/PowerShell/blob/master/docs/dev-process/breaking-change-contract.md#bucket-3-unlikely-grey-area) changes).\r\n\r\nI've personally stopped contributing to this and the documentation repo, so I am unsubscribing from this thread, but if you feel you have an explanation of the current behavior that should be part of the documentation (or can at least serve as the basis for writing help content), I encourage you to [create an issue in the documentation repo](https://github.com/MicrosoftDocs/PowerShell-Docs/issues/new/choose).\r\n\r\n",
      "created_at": "2021-06-13T18:00:49Z",
      "updated_at": "2021-06-13T18:00:49Z"
    }
  ],
  "created_at": "2018-03-22T20:14:21Z",
  "labels": [
    "WG-Language",
    "Issue-Discussion",
    "Resolution-Answered"
  ],
  "number": 6467,
  "state": "closed",
  "title": "Parsing of compound command-line tokens into arguments is surprising",
  "updated_at": "2021-06-13T18:00:50Z"
}