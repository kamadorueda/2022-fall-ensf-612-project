{
  "_url": "https://github.com/PowerShell/PowerShell/issues/8261",
  "author": "rjmholt",
  "body": "Opened out of https://github.com/PowerShell/PowerShell/pull/8218.\r\n\r\nWe do very little santisation/normalisation on paths passed in as module names in `ModuleSpecification` types to various cmdlets.\r\n\r\nNot many users rely directly on this functionality, but things like `RequiredModules` in module manifests do.\r\n\r\nWe currently don't have any layering or type API (that I know of) to reflect that a path passed in has been converted by PowerShell to one that's safe for .NET to operate on, and the ideal scenario would be for us to change that. Otherwise we are doomed to repeat the same path checks/resolutions at every layer in the code, either hurting perf or causing serious bugs.\r\n\r\n## Steps to reproduce\r\n\r\nSome examples of this problem:\r\n- Remove module using a path in a qualified name doesn't work:\r\n    ```powershell\r\n       Describe \"Remove-Module works with FullyQualifiedName using a path for the name\" {\r\n        BeforeAll {\r\n            $moduleName = 'rmomod'\r\n            $moduleVersion = '1.2'\r\n            $modulePath = Join-Path $TestDrive $moduleName\r\n            $manifestPath = Join-Path $modulePath \"$moduleName.psd1\"\r\n    \r\n            New-Item -ItemType Directory -Path $modulePath\r\n    \r\n            New-ModuleManifest -Path $manifestPath -ModuleVersion $moduleVersion\r\n    \r\n            if ($IsWindows)\r\n            {\r\n                $sep = '\\'\r\n                $altSep = '/'\r\n            }\r\n            else\r\n            { \r\n                $sep = '/'\r\n                $altSep = '\\'\r\n            }\r\n    \r\n            $absoluteTestCases = @(\r\n                @{ ModuleName = $moduleName; Case = 'module name' }\r\n                @{ ModuleName = $modulePath; Case = 'absolute module dir path' }\r\n                @{ ModuleName = \"$TestDrive${altSep}$moduleName\"; Case = 'absolute module dir path with alt dir separators' }\r\n                @{ ModuleName = $manifestPath; Case = 'absolute manifest path' }\r\n                @{ ModuleName = \"$TestDrive${altSep}$moduleName${sep}$moduleName.psd1\"; Case = 'absolute manifest path with alt dir separators' }\r\n            )\r\n\r\n            $relativeTestCases = @(\r\n                @{ Case = 'relative path to module dir'; Location = $TestDrive; ModuleName = \"./$moduleName\" }\r\n                @{ Case = 'relative path to module dir with alt sep'; Location = \"$TestDrive/duck\"; ModuleName = \"..${altSep}moduleName\" }\r\n                @{ Case = 'relative path to manifest with alt sep'; Location = \"$TestDrive/$moduleName\"; ModuleName = \"./$moduleName.psd1\" }\r\n                @{ Case = 'relative path to manifest with alt sep'; Location = $TestDrive; ModuleName = \".${sep}$moduleName{$altSep}$moduleName.psd1\" }\r\n                @{ Case = 'current dir being module dir'; Location = \"$TestDrive/$moduleName\"; ModuleName = \".\" }\r\n            )\r\n        }\r\n    \r\n        BeforeEach {\r\n            Import-Module $modulePath\r\n        }\r\n    \r\n        AfterEach {\r\n            Remove-Module $moduleName -ErrorAction SilentlyContinue\r\n        }\r\n    \r\n        It \"Removes the module by <Case>\" -TestCases $absoluteTestCases {\r\n            param([string]$ModuleName, [string]$Case)\r\n    \r\n            $fqn = @{\r\n                ModuleName = $ModuleName\r\n                ModuleVersion = $moduleVersion\r\n            }\r\n    \r\n            Remove-Module -FullyQualifiedName $fqn -ErrorAction Stop\r\n            Get-Module $moduleName | Should -HaveCount 0\r\n        }\r\n\r\n        It \"Removes the module by <Case>\" -TestCases $relativeTestCases {\r\n            param([string]$Location, [string]$ModuleName, [string]$Case)\r\n\r\n            $fqn = @{\r\n                ModuleName = $ModuleName\r\n                ModuleVersion = $moduleVersion\r\n            }\r\n\r\n            if (-not (Test-Path $Location))\r\n            {\r\n                New-Item -ItemType Directory -Path $Location\r\n            }\r\n\r\n            Push-Location $Location\r\n            try\r\n            {\r\n                Remove-Module -FullyQualifiedName $fqn -ErrorAction Stop\r\n                Get-Module $moduleName | Should -HaveCount 0\r\n            }\r\n            finally\r\n            {\r\n                Pop-Location\r\n            }\r\n        }\r\n    }\r\n    ```\r\n- Required modules in a script:\r\n    ```powershell\r\n    Describe \"Requiring modules by absolute path\" {\r\n        BeforeAll {\r\n            $scriptPath = Join-Path $TestDrive \"script.ps1\"\r\n            $success = 'SUCCESS'\r\n\r\n            $moduleName = 'reqmod'\r\n            $modulePath = Join-Path $TestDrive $moduleName\r\n            $manifestPath = Join-Path $modulePath \"$moduleName.psd1\"\r\n\r\n            New-Item -ItemType Directory $modulePath -Force\r\n\r\n            New-ModuleManifest -Path $manifestPath -ModuleVersion '3.2.4'\r\n\r\n            if ($IsWindows)\r\n            {\r\n                $sep = '\\'\r\n                $altSep = '/'\r\n            }\r\n            else\r\n            {\r\n                $sep = '/'\r\n                $altSep = '\\'\r\n            }\r\n\r\n            $oldModulePath = $env:PSModulePath\r\n            $env:PSModulePath += [System.IO.Path]::PathSeparator + $TestDrive\r\n\r\n            $testCases = @(\r\n                @{ Case = 'module name, with module on path'; ModuleName = $moduleName }\r\n                @{ Case = 'absolute path to module dir'; ModuleName = $modulePath }\r\n                @{ Case = 'absolute path to module dir with alt sep'; ModuleName = \"$TestDrive${altSep}$moduleName\" }\r\n                @{ Case = 'absolute path to manifest'; ModuleName = $manifestPath }\r\n                @{ Case = 'absolute path to manifest with alt sep'; ModuleName = \"$TestDrive${sep}$moduleName${altSep}$moduleName.psd1\" }\r\n            )\r\n        }\r\n\r\n        AfterAll {\r\n            $env:PSModulePath = $oldModulePath\r\n        }\r\n\r\n        Context \"Autoload unloaded required module\" {\r\n            AfterEach {\r\n                Remove-Module $moduleName -ErrorAction SilentlyContinue\r\n            }\r\n\r\n            It \"Autoloads the required module by <Case>\" -TestCases $testCases {\r\n                param([string]$ModuleName, [string]$Case)\r\n\r\n                $script = @\"\r\n    #requires -Modules @{ ModuleName = '$ModuleName'; ModuleVersion = '$moduleVersion' }\r\n    '$success'\r\n    \"@\r\n\r\n                New-Item -Path $scriptPath -Value $script -Force\r\n                & $scriptPath | Should -BeExactly $success\r\n            }\r\n        }\r\n\r\n        Context \"Verify required module is already loaded\" {\r\n            BeforeAll {\r\n                Import-Module $modulePath\r\n            }\r\n\r\n            AfterAll {\r\n                Remove-Module $moduleName -ErrorAction SilentlyContinue\r\n            }\r\n\r\n            It \"Verifies that the required module is loaded by <Case>\" -TestCases $testCases {\r\n                param([string]$ModuleName, [string]$Case)\r\n\r\n                $script = @\"\r\n    #requires -Modules @{ ModuleName = '$ModuleName'; ModuleVersion = '$moduleVersion' }\r\n    '$success'\r\n    \"@\r\n\r\n                New-Item -Path $scriptPath -Value $script -Force\r\n                & $scriptPath | Should -BeExactly $success\r\n            }\r\n        }\r\n    }\r\n    ```\r\n    (This second case actually supports alt separators, which I didn't expect. But still no module dir. And no relative paths either)",
  "closed_at": null,
  "comments": [
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "/cc @daxian-dbw ",
      "created_at": "2018-11-14T19:40:22Z",
      "updated_at": "2018-11-14T19:40:22Z"
    }
  ],
  "created_at": "2018-11-13T23:52:45Z",
  "labels": [
    "Issue-Enhancement",
    "WG-Cmdlets-Core"
  ],
  "number": 8261,
  "state": "open",
  "title": "ModuleSpecification/FullyQualifiedName usage does not handle paths well",
  "updated_at": "2018-11-14T19:40:23Z"
}