{
  "_url": "https://github.com/PowerShell/PowerShell/issues/15844",
  "author": "TobiasPSP",
  "body": "### Summary of the new feature / enhancement\r\n\r\nFor decades, Windows admins have been using `Get-EventLog` to query classic event logs. In PowerShell 3, `Get-EventLog` was superseeded by the more powerful and versatile `Get-WinEvent` which technically has convincing features: it is faster, accepts sophisticated xml queries, can access evtx based event logs, and more. \r\n\r\nHowever, `Get-WinEvent` was never really adopted by the community, and still `Get-EventLog` is used most often. In *PowerShell Core*, `Get-Eventlog` was actually removed from the package so users hooked to `Get-EventLog` are faced with code changes.\r\n\r\nThe primary reason just **why** users did not adopt the technically superior `Get-WinEvent` is simple: its user interface is awkward and non-discoverable. To perform an average query, at minimum a *FilterHashtable* is needed, and its predefined supported keys are not discoverable. So a user would have to google and investigate which keys are needed when in contrast, `Get-EventLog` would simply suggest intuitive parameters.\r\n\r\nSince the new `Get-WinEvent` can do what `Get-EventLog` did (and more and faster), this cmdlet should simply support the old parametersets from `Get-EventLog` and translate them into the awkward filter hashtable keys.\r\n\r\n## Current Situation\r\n\r\nHere is an average event log query using `Get-EventLog` returning the installed updates within the past 30 days:\r\n```powershell\r\n$30Days = (Get-Date).AddDays(-30)\r\nGet-Eventlog -LogName System -EntryType Information -InstanceId 19 -After $30Days -Source 'Microsoft-Windows-WindowsUpdateClient'\r\n```\r\n\r\nWith `Get-WinEvent`, a user would have to compose at minimum a filter hashtable like so:\r\n```powershell\r\n$30Days = (Get-Date).AddDays(-30)\r\n$filter = @{\r\n    LogName = 'System'\r\n    Level = 4,5\r\n    Id = 19\r\n    StartTime = $30Days\r\n    ProviderName = 'Microsoft-Windows-WindowsUpdateClient'\r\n}\r\nGet-WinEvent -FilterHashtable $filter\r\n```\r\nNone of the hashtable keys needed here is discoverable. They are not intuitive, there is no intellisense or completion, thus a user would have to go google.\r\n\r\nThat said, once the correct filter hashtable has been composed, `Get-WinEvent` returns the very same information (albeit property names may differ a little, this would be something admins can easily work around).\r\n\r\n## Suggestion\r\n\r\nBy adding the parameters supported by `Get-EventLog` to `Get-WinEvent`, the cmdlet could automate the process of composing the filter hashtable. In essence, `Get-WinEvent` would be usable just as easily as `Get-EventLog` has been for years. This would ease transition to *PowerShell Core* and also increase the performance of event log queries altogether.\r\n\r\nWith such a concept, the user would run `Get-WinEvent` like this:\r\n\r\n```powershell\r\n$30Days = (Get-Date).AddDays(-30)\r\nGet-WinEvent -LogName System -EntryType Information -InstanceId 19 -After $30Days -Source 'Microsoft-Windows-WindowsUpdateClient'\r\n```\r\n\r\n\r\n\r\n### Proposed technical implementation details (optional)\r\n\r\nThe implementation is primarily diligence work and not technically challenging. Basically, the parameters have to be translated to the appropriate hashtable keys.\r\n\r\nBelow is a proof of concept which is obviously **neither complete nor production ready**. I added the most commonly used parameters used by `Get-EventLog`. I did not i.e. implement the *list* parameterset (which should be trivial enough).\r\n\r\n```powershell\r\n<#\r\nSuggestion to improve Get-WinEvent in order to make it compatible to the commonly used Get-EventLog calls\r\n\r\nBelow is a prototype using a proxy function. Run it to enhance Get-WinEvent.\r\nTo get rid of the enhancement, either restart PowerShell or run:\r\nRemove-Item -Path function:Get-WinEvent\r\n\r\nNote that the prototype emits the composed hashtable to the console (green)\r\n#>\r\n\r\nfunction Get-WinEvent\r\n{\r\n    [CmdletBinding(DefaultParameterSetName='GetLogSet', HelpUri='https://go.microsoft.com/fwlink/?LinkID=138336')]\r\n    param(\r\n        \r\n        [Parameter(ParameterSetName='ListLogSet', Mandatory=$true, Position=0)]\r\n        [AllowEmptyCollection()]\r\n        [string[]]\r\n        ${ListLog},\r\n\r\n        [Parameter(ParameterSetName='LogNameGetEventlog', Mandatory=$true, Position=0)] <#NEW#> \r\n        [Parameter(ParameterSetName='GetLogSet', Position=0, ValueFromPipeline=$true, ValueFromPipelineByPropertyName=$true)]\r\n        [string[]]\r\n        ${LogName},\r\n\r\n        [Parameter(ParameterSetName='ListProviderSet', Mandatory=$true, Position=0)]\r\n        [AllowEmptyCollection()]\r\n        [string[]]\r\n        ${ListProvider},\r\n\r\n        <# Get-EventLog supports wildcards, Get-WinEvent does not. Needs to be corrected. #>\r\n        [Parameter(ParameterSetName='GetProviderSet', Mandatory=$true, Position=0, ValueFromPipelineByPropertyName=$true)]\r\n        [string[]]\r\n        ${ProviderName},\r\n\r\n        [Parameter(ParameterSetName='FileSet', Mandatory=$true, Position=0, ValueFromPipelineByPropertyName=$true)]\r\n        [Alias('PSPath')]\r\n        [string[]]\r\n        ${Path},\r\n\r\n        [Parameter(ParameterSetName='FileSet')]\r\n        [Parameter(ParameterSetName='GetProviderSet')]\r\n        [Parameter(ParameterSetName='GetLogSet')]\r\n        [Parameter(ParameterSetName='HashQuerySet')]\r\n        [Parameter(ParameterSetName='XmlQuerySet')]\r\n        [ValidateRange(1, 9223372036854775807)]\r\n        [long]\r\n        ${MaxEvents},\r\n        \r\n        <# NEW #>\r\n        [Parameter(ParameterSetName='LogNameGetEventlog')]\r\n        [ValidateRange(0, 2147483647)]\r\n        [int]\r\n        ${Newest},\r\n        \r\n        [Parameter(ParameterSetName='GetProviderSet')]\r\n        [Parameter(ParameterSetName='ListProviderSet')]\r\n        [Parameter(ParameterSetName='ListLogSet')]\r\n        [Parameter(ParameterSetName='GetLogSet')]\r\n        [Parameter(ParameterSetName='HashQuerySet')]\r\n        [Parameter(ParameterSetName='XmlQuerySet')]\r\n        [Parameter(ParameterSetName='LogNameGetEventlog')] <#NEW#> \r\n        [Alias('Cn')]\r\n        [ValidateNotNullOrEmpty()] <#CORRECTED#>\r\n        [string] <# used to be [String[]], Get-WinEvent accepts [string] only, should be changed to accept string arrays #>\r\n        ${ComputerName},\r\n\r\n        [Parameter(ParameterSetName='GetProviderSet')]\r\n        [Parameter(ParameterSetName='ListProviderSet')]\r\n        [Parameter(ParameterSetName='ListLogSet')]\r\n        [Parameter(ParameterSetName='GetLogSet')]\r\n        [Parameter(ParameterSetName='HashQuerySet')]\r\n        [Parameter(ParameterSetName='XmlQuerySet')]\r\n        [Parameter(ParameterSetName='FileSet')]\r\n        [pscredential]\r\n        [System.Management.Automation.CredentialAttribute()]\r\n        ${Credential},\r\n\r\n        [Parameter(ParameterSetName='FileSet')]\r\n        [Parameter(ParameterSetName='GetProviderSet')]\r\n        [Parameter(ParameterSetName='GetLogSet')]\r\n        [ValidateNotNull()]\r\n        [string]\r\n        ${FilterXPath},\r\n\r\n        [Parameter(ParameterSetName='XmlQuerySet', Mandatory=$true, Position=0)]\r\n        [xml]\r\n        ${FilterXml},\r\n\r\n        [Parameter(ParameterSetName='HashQuerySet', Mandatory=$true, Position=0)]\r\n        [hashtable[]]\r\n        ${FilterHashtable},\r\n\r\n        [Parameter(ParameterSetName='GetProviderSet')]\r\n        [Parameter(ParameterSetName='ListLogSet')]\r\n        [Parameter(ParameterSetName='GetLogSet')]\r\n        [Parameter(ParameterSetName='HashQuerySet')]\r\n        [switch]\r\n        ${Force},\r\n\r\n        [Parameter(ParameterSetName='GetLogSet')]\r\n        [Parameter(ParameterSetName='GetProviderSet')]\r\n        [Parameter(ParameterSetName='FileSet')]\r\n        [Parameter(ParameterSetName='HashQuerySet')]\r\n        [Parameter(ParameterSetName='XmlQuerySet')]\r\n        [switch]\r\n        ${Oldest},\r\n    \r\n        <# NEW #>\r\n        [Parameter(ParameterSetName='LogNameGetEventlog')]\r\n        [ValidateNotNullOrEmpty()]\r\n        [datetime]\r\n        ${After},\r\n\r\n        <# NEW #>\r\n        [Parameter(ParameterSetName='LogNameGetEventlog')]\r\n        [ValidateNotNullOrEmpty()]\r\n        [datetime]\r\n        ${Before},\r\n        \r\n        <# NEW #>\r\n        [Parameter(ParameterSetName='LogNameGetEventlog')]\r\n        [ValidateNotNullOrEmpty()]\r\n        [string[]]\r\n        ${UserName},\r\n\r\n        <# NEW #>\r\n        [Parameter(ParameterSetName='LogNameGetEventlog', Position=1)]\r\n        [ValidateRange(0, 9223372036854775807)]\r\n        [ValidateNotNullOrEmpty()]\r\n        [long[]]\r\n        ${InstanceId},\r\n\r\n        <# NEW #>\r\n        [Parameter(ParameterSetName='LogNameGetEventlog')]\r\n        [ValidateNotNullOrEmpty()]\r\n        [ValidateRange(1, 2147483647)]\r\n        [int[]]\r\n        ${Index},\r\n\r\n        <# NEW #>\r\n        [Parameter(ParameterSetName='LogNameGetEventlog')]\r\n        [Alias('ET')]\r\n        [ValidateNotNullOrEmpty()]\r\n        [ValidateSet('Error','Information','FailureAudit','SuccessAudit','Warning')]\r\n        [string[]]\r\n        ${EntryType},\r\n\r\n        <# NEW #>\r\n        [Parameter(ParameterSetName='LogNameGetEventlog')]\r\n        [Alias('ABO')]\r\n        [ValidateNotNullOrEmpty()]\r\n        [string[]]\r\n        ${Source},\r\n\r\n        <# NEW #>\r\n        [Parameter(ParameterSetName='LogNameGetEventlog')]\r\n        [Alias('MSG')]\r\n        [ValidateNotNullOrEmpty()]\r\n        [string]\r\n        ${Message},\r\n\r\n        <# NEW #>\r\n        [Parameter(ParameterSetName='LogNameGetEventlog')]\r\n        [switch]\r\n        ${AsBaseObject},\r\n        \r\n        [Parameter(ParameterSetName='ListGetEventlog')]\r\n        [switch]\r\n        ${List},\r\n\r\n        [Parameter(ParameterSetName='ListGetEventlog')]\r\n        [switch]\r\n        ${AsString}\r\n        \r\n        \r\n        \r\n    )\r\n\r\n    begin\r\n    {\r\n        try {\r\n            $outBuffer = $null\r\n            if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer))\r\n            {\r\n                $PSBoundParameters['OutBuffer'] = 1\r\n            }\r\n            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand('Microsoft.PowerShell.Diagnostics\\Get-WinEvent', [System.Management.Automation.CommandTypes]::Cmdlet)\r\n\r\n            # if the user chose the Get-EventLog compatible parameters,\r\n            # compose the appropriate filterhashtable:\r\n            $scriptCmd = if ($PSCmdlet.ParameterSetName -eq 'LogNameGetEventlog')\r\n            {\r\n                # mandatory parameter:\r\n                $filter = @{\r\n                    LogName = $PSBoundParameters['Logname']\r\n                }\r\n                $null = $PSBoundParameters.Remove('LogName')\r\n                \r\n                if ($PSBoundParameters.ContainsKey('Before'))\r\n                {\r\n                    $filter['EndTime'] = $PSBoundParameters['Before']\r\n                    $null = $PSBoundParameters.Remove('Before')\r\n                }\r\n                if ($PSBoundParameters.ContainsKey('After'))\r\n                {\r\n                    $filter['StartTime'] = $PSBoundParameters['After']\r\n                    $null = $PSBoundParameters.Remove('After')\r\n                }\r\n                if ($PSBoundParameters.ContainsKey('EntryType'))\r\n                {\r\n                    # severity is translated to an integer array:\r\n                    \r\n                    $levelFlags = [System.Collections.Generic.List[int]]@()\r\n\r\n                    # string input converted to integer array:\r\n                    if ($PSBoundParameters['EntryType'] -contains 'Error')\r\n                    {\r\n                        $levelFlags.Add(1) # critical\r\n                        $levelFlags.Add(2) # error\r\n                    }\r\n                    if ($PSBoundParameters['EntryType'] -contains 'Warning')\r\n                    {\r\n                        $levelFlags.Add(3) # warning\r\n                    }\r\n                    if ($PSBoundParameters['EntryType'] -contains 'Information')\r\n                    {\r\n                        $levelFlags.Add(4) # informational\r\n                        $levelFlags.Add(5) # verbose\r\n                    }\r\n                    \r\n                        \r\n                    # default to 0:\r\n                    if ($levelFlags.Count -gt 0)\r\n                    {\r\n                        $filter['Level'] = [int[]]$levelFlags\r\n                    }\r\n                        \r\n                    # audit settings stored in Keywords key:\r\n                    if ($PSBoundParameters['EntryType'] -contains 'FailureAudit')\r\n                    {\r\n                        $filter['Keywords'] += 0x10000000000000\r\n                    }\r\n                    if ($PSBoundParameters['EntryType'] -contains 'SuccessAudit')\r\n                    {\r\n                        $filter['Keywords'] += 0x20000000000000\r\n                    }\r\n                    $null = $PSBoundParameters.Remove('EntryType')\r\n                }\r\n                if ($PSBoundParameters.ContainsKey('InstanceId'))\r\n                {\r\n                    $filter['ID'] = $PSBoundParameters['InstanceId']\r\n                    $null = $PSBoundParameters.Remove('InstanceId')\r\n                }\r\n                if ($PSBoundParameters.ContainsKey('Source'))\r\n                {\r\n                    $filter['ProviderName'] = $PSBoundParameters['Source']\r\n                    $null = $PSBoundParameters.Remove('Source')\r\n                }\r\n                \r\n                $PSBoundParameters['FilterHashtable'] = $filter\r\n                Write-Host ($filter | Out-String) -ForegroundColor Green\r\n                \r\n                if ($PSBoundParameters.ContainsKey('Newest'))\r\n                {\r\n                    $PSBoundParameters['MaxEvents'] = $PSBoundParameters['Newest']\r\n                    $null = $PSBoundParameters.Remove('Newest')\r\n                }\r\n            }\r\n            \r\n            \r\n            $scriptCmd = \r\n            {\r\n                & $wrappedCmd @PSBoundParameters\r\n            } \r\n            $steppablePipeline = $scriptCmd.GetSteppablePipeline($myInvocation.CommandOrigin)\r\n            $steppablePipeline.Begin($PSCmdlet)\r\n        } catch {\r\n            throw\r\n        }\r\n    }\r\n\r\n    process\r\n    {\r\n        try {\r\n            $steppablePipeline.Process($_)\r\n        } catch {\r\n            throw\r\n        }\r\n    }\r\n\r\n    end\r\n    {\r\n        try {\r\n            $steppablePipeline.End()\r\n        } catch {\r\n            throw\r\n        }\r\n    }\r\n    <#\r\n\r\n            .ForwardHelpTargetName Microsoft.PowerShell.Diagnostics\\Get-WinEvent\r\n            .ForwardHelpCategory Cmdlet\r\n\r\n    #>\r\n\r\n}\r\n```\r\n\r\nOnce you run this code, you can then continue to use `Get-WinEvent` like before, but you now *can also start using the parameters that you know from `Get-EventLog`*. The enhanced `Get-WinEvent` automatically converts these parameters into a filterhashtable, and there is no need anymore for the user to know its keys or predefined awkward codes for event types.\r\n\r\n## Notes\r\n\r\nThere are a few technical limitations, i.e. `Get-EventLog` supports wildcards for providernames whereas `Get-WinEvent` does not. `Get-WinEvent` should be enhanced in these areas to be on the same level.\r\n\r\nObviously the new parameters should get rich intellisense to suggest available lognames and provider names.\r\n",
  "closed_at": "2021-10-20T17:04:27Z",
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "In general, I very like this idea of making this cmdlet more friendly. However, I think that this is not the right way to emulate the old cmdlet (which is also not without its flaws) that can mislead users.\r\nWe could add more parameters in new parameter set.\r\nBut I'd start with investigation whether we enhance tab completion for FilterHashtable parameter (don't forget about new predictor API!).\r\n\r\n> Below is a proof of concept which is obviously neither complete nor production ready.\r\n\r\nI don't see a point to keep the issue open. I suggest to continue in Discussions or on other community resources and come back with final proposal which ready for approval and implementation.\r\n\r\n> So a user would have to google and investigate which keys are needed when in contrast, Get-EventLog would simply suggest intuitive parameters.\r\n\r\nThe cmdlet has 16 examples in docs. If that's not enough you could contribute to the docs.",
      "created_at": "2021-07-29T14:10:40Z",
      "updated_at": "2021-07-29T14:10:40Z"
    },
    {
      "author": "MartinGC94",
      "author_association": "CONTRIBUTOR",
      "body": "IMO hashtables with or without completion for the key/values don't feel as good to use interactively as real parameters do. The reason for this is all the extra characters you have to write `@{};` + the quotes around string values.  \r\nIn scripts hashtables are great because of how easy they are to read (especially when they are aligned properly).\r\n\r\nHow do people typically use the event log cmdlets? Directly from the CLI? Or in scripts? I personally only use them to make smaller functions like getting the last boot time or whatever so I don't mind the current syntax (although completions for the hashtable would definitely be appreciated).",
      "created_at": "2021-07-29T22:49:36Z",
      "updated_at": "2021-07-29T22:49:36Z"
    },
    {
      "author": "TobiasPSP",
      "author_association": "COLLABORATOR",
      "body": "> However, I think that this is not the right way to emulate the old cmdlet (which is also not without its flaws) that can mislead users.\r\n\r\n> I don't see a point to keep the issue open. I suggest to continue in Discussions or on other community resources and come back with final proposal which ready for approval and implementation.\r\n\r\n> The cmdlet has 16 examples in docs. If that's not enough you could contribute to the docs.\r\n\r\nWhy would adding well established parameters be misleading? After all, Get-WinEvent already is providing parameter sets for hashtable, xlm and xpath input, so it is tailored towards many different target audiences already. I think we should add the primary target audience \u201eadmins\u201c which often don\u2018t even know what a \u201ehashtable\u201c is. \r\n\r\nIn fact, asking user input via structures of any kind - hashtable, xpath, etc - is not the way how powershell cmdlets typically work. Typically, cmdlets prompt for user information via discoverable parameters. The fact that Get-Eventlog is still in wide use in WPS/industrial whereas Get-WinEvent is not, vividly illustrates this dilemma.\r\n\r\nSo why not just adding parameters that have been in common use for many years and do the job, especially since changes are trivial in comparison to adding intellisense for hashtable keys (which is definitely a great suggestion as yet another enhancement for that particular parameterset).\r\n",
      "created_at": "2021-07-30T06:33:55Z",
      "updated_at": "2021-07-30T07:23:03Z"
    },
    {
      "author": "TobiasPSP",
      "author_association": "COLLABORATOR",
      "body": "To go a step further to improve practical usability for admins, I'd suggest that Get-WinEvent should expose the \"Properties\" property content as a direct object array. \r\n\r\nMost of the time, when reading the eventlog, people are after the real \"beef\" which is embedded in a static \"message\" template. The embedded \"beef\" that is inserted in this template currently surfaces in the \"Properties\" property. \r\n\r\nRather than taking message and using string manipulation and RegEx to get to the actual event information, \"Properties\" provides object-oriented access. \r\n\r\nHowever, \"Properties\" is an array of type \"EventProperty\" which inside stores the actual value in \"Value\". It has no other property and is a simple wrapper, so there is no extra value in keeping this object vs. returning its value property directly. \r\n\"Unrolling\" that value and returning a simple object array of values would make this information more accessible. \r\n\r\nTo not run into compatibility issues, this could be implemented as a scriptproperty \"Values\", for example. It would be a simple enhancement of the ps1xml.\r\n\r\n## Current Situation\r\n\r\nCurrently values need to be unrolled. If I just wanted to know which software was installed on my system within the past 30 days, I'd need something like this:\r\n\r\n```powershell\r\n$30Days = (Get-Date).AddDays(-30)\r\n$filter = @{\r\n    LogName = 'System'\r\n    Level = 4,5\r\n    Id = 19\r\n    StartTime = $30Days\r\n    ProviderName = 'Microsoft-Windows-WindowsUpdateClient'\r\n}\r\nGet-WinEvent -FilterHashtable $filter | Select-Object -Property TimeGenerated, @{N='Values'; E={ $_.Properties | Foreach-Object { $_.Value }}}\r\n```\r\n\r\nIf I tried to intuitively enumerate \"Properties\", this would provide a list of EventProperty objects, not the values that I'd expect:\r\n\r\n```powershell\r\nGet-WinEvent -FilterHashtable $filter | Select-Object -Property TimeGenerated, @{N='Values'; E={ $_.Properties }}\r\n```\r\n\r\n## Suggested Outcome\r\n\r\nWith a new \"Values\" scriptproperty, non-programmers would have a much easier and intuitive way of accessing the values:\r\n\r\n```powershell\r\nGet-WinEvent -FilterHashtable $filter | Select-Object -Property TimeGenerated, @{N='Values'; E={ $_.Values }}\r\n```\r\n\r\n\r\n",
      "created_at": "2021-07-30T07:41:27Z",
      "updated_at": "2021-07-30T07:41:27Z"
    },
    {
      "author": "TobiasPSP",
      "author_association": "COLLABORATOR",
      "body": "> The cmdlet has 16 examples in docs. If that's not enough you could contribute to the docs.\r\n\r\nWhile it's of course a good thing to have rich examples, in this patricular instance the number of examples is the symptom of the problem, not the cure. 16 examples are not enough here because not a single one of them explains how to do basic routine tasks, and adding more examples will only add to the confusion. It's a flaw in the user interface that is too complex.\r\n\r\nDon't take my word for it. Let's look at reality and assume an admin needs to dump error events to quickly find out what's wrong with a server. That's a common task, and that's why 'Get-WinEvent' exists. \r\n\r\nWith the deprecated `Get-EventLog`, solving this problem takes seconds since this cmdlet adheres to the sacred PowerShell principles and provides filter parameters named exactly like the properties it filters. The user can recycle entry-level PowerShell knowledge: by looking at the cmdlet output, immediately identifies the \"column\" *EntryType* and uses the parameter `-EntryType` to filter - mission accomplished in 10 seconds.\r\n\r\nWith `Get-WinEvent`, the user finds **no** intuitive parameter to filter. So the user is forced to resort to the documentation (\"but I just wanted errors - do I really need that?\").\r\n\r\nhttps://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.diagnostics/get-winevent?view=powershell-7.1\r\n\r\nIt takes the user now 10 examples until finally example #10 claims to solve his problem: *Get error events that have a specified string in their name*. Unfortunately this example isn't doing what its title claims. It is in fact not related to error events at all. It simply does an expensive client-side grouping for *LevelDisplayName* (which BTW is bad practice).\r\n\r\nSo the user continues to read on while the server is sitting there malfunctioning and the boss is getting nervous. Example #17 is the next one that seems promising: *Use FilterHashtable to get application errors*. Bad luck again: it simply filters for a **provider name** that just happens to report errors. No error filtering again. This is filtering for a provider name, not errors.\r\n\r\nNo more examples related to his issue - an issue that is trivial and at the core of what `Get-WinEvent` should do. \r\n\r\nEven if the user was so experienced as to suspect that the parameter `-FilterHashtable` might be of help here, the documentation of this parameter just lists supported key names - but neither their purpose nor required values, so again no success. The required hashtable key *Level* isn't intuitive in the first place, but without the numeric code values it is of no use anyway (1=Critical, 2=Error, 3=Warning,...)\r\n\r\nEssence: the user is unable to successfully perform this trivial task because both the user interface design and the documentation of `Get-WinEvent` currently are of low usability.\r\n\r\nSo from daily experience in hundreds of companies and IT departments, I wrapped my head around it and wondered what could be really helpful for this particular audience to actually master their daily business with `Get-WinEvent`. They already know `Get-EventLog` and never had issues with it, so adding the old user interface back to the new cmdlet seems simple and effective.\r\n\r\nI know we all come from different areas and have different focus, background and experience. I hope this real-world scenario can illustrate a tiny bit why I am proposing this change and why I think it is important. \r\n\r\nWe can work on symptoms (documentation, intellisense for hashtables) but primarily we should cure the cause which is a user interface that is inappropriate for the primary target audience and needs too much explaining. \r\n\r\nPlus the suggested change is so trivial.\r\n\r\n\n\n<blockquote><img src=\"https://docs.microsoft.com/media/logos/logo-powershell-social.png\" width=\"48\" align=\"right\"><div><strong><a href=\"https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.diagnostics/get-winevent\">Get-WinEvent (Microsoft.PowerShell.Diagnostics) - PowerShell</a></strong></div><div>The Get-WinEvent cmdlet gets events from event logs, including classic logs, such as the System and Application logs. The cmdlet gets data from event logs that are generated by the Windows Event Log technology introduced in Windows Vista. And, events in log files generated by Event Tracing for Windows (ETW). By default, Get-WinEvent returns event information in the order of newest to oldest. Get-WinEvent lists event logs and event log providers. To interrupt the command, press CTRL+C. You can get events from selected logs or from logs generated by selected event providers. And, you can combine events from multiple sources in a single command. Get-WinEvent allows you to filter events using XPath queries, structured XML queries, and hash table queries. If you're not running PowerShell as an Administrator, you might see error messages that you cannot retrieve information about a log. </div></blockquote>",
      "created_at": "2021-07-30T10:56:27Z",
      "updated_at": "2021-07-30T10:56:29Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Four years ago, I made a few fixes and improvements to this cmdlet and left the work because there was no feedback. So, thank you for paying attention to this cmdlet. At that time I was thinking about how to make this cmdlet smarter and more useful, but because of the passage of time I don't remember all details anymore. (I consider some QBE scenarios in particular.)\r\n\r\nMy concern about \"emulation\" is that would confuse users because they would expect this works the same but it's not since another underlying API is used. Moreover, I suppose we can make this cmdlet more smart than just copying the parameters.\r\n\r\nThis cmdlet has much more features and better performance than Get-EventLog but I agree that it is harder to use. A root of the problem is user don't know and don't see meta information of events. The main difficulty is that each type of event has a different format. \r\nMoreover evtx format is so flexible that either there could be no meta information at all (which has to be taken elsewhere, in a SDK), or there could be self-describing events or the log file could have a manifest.\r\n\r\nAs you see it is not easy to find a common approach.\r\n\r\nI would suggest:\r\n- QBE approach\r\n- XML parameter to generate XML formatted output based on meta information in the event\r\n- Expand parameter to convert EventLogRecord class to PSCustomObject based on meta information in the event\r\n- Metadata parameter to output either log manifest in readable format or metadata for self-describing event.\r\n\r\nI may have had other ideas, but I don't remember because of the passage of time.",
      "created_at": "2021-07-30T15:25:02Z",
      "updated_at": "2021-07-30T15:25:02Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "I wonder if a `New-WinEventFilter` cmdlet which has parameters and simply returns a hashtable would be a good experience?  Perhaps even allow piping that result directly into `Get-WinEvent`?",
      "created_at": "2021-08-02T21:47:39Z",
      "updated_at": "2021-08-02T21:47:39Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "It'd be fine and possibly even better if it returned a concrete type with those values being publicly settable, I think; powershell folks could still use a hashtable as the parameter as long as the parameter type is the new type, and it allows the properties to be publicly set.\r\n\r\nThe error messages during parameter binding would be pretty decent, and you have the benefit of being able to auto-gen help content for those type members that you can reference from the cmdlet(s) help files.",
      "created_at": "2021-08-03T00:56:13Z",
      "updated_at": "2021-08-03T00:56:13Z"
    },
    {
      "author": "TobiasPSP",
      "author_association": "COLLABORATOR",
      "body": "> I wonder if a `New-WinEventFilter` cmdlet which has parameters and simply returns a hashtable would be a good experience?\r\n\r\nI thought about that, too, but there are good reasons why IMHO this should be a new parameterset inside `Get-WinEvent`:\r\n\r\n* Consistency: internally, `Get-WinEvent` uses XML to do the query, so -FilterXPath. -FilterXML and -FilterHashtable as well as some distinct parameters such as -Logname all take user input and transform it into the appropriate XML query. The suggested new parameters would adopt the same principle. \r\n* Simplicity: separating the query into two cmdlets provides no extra value. Currently, when you submit `-Verbose`,  `Get-WinEvent` emits the composed XML as a verbose stream. This should be the same here, too, so when a user uses the suggested parameter set, we should emit the constructed hashtable to the verbose stream as well.\r\n* No API: cmdlets are the primary user interface and not a backend API. So we shouldn't treat `Get-WinEvent` as a backend API that is accessible through another cmdlet with the real user interface. That's what parametersets are typically used for.\r\n\r\nAdding a new parameterset to the cmdlet isn't really a hard thing to do, and I can't see any compatibility issues or added complexity. ",
      "created_at": "2021-08-03T03:55:40Z",
      "updated_at": "2021-08-03T03:55:40Z"
    },
    {
      "author": "TobiasPSP",
      "author_association": "COLLABORATOR",
      "body": "\r\n> My concern about \"emulation\" is that would confuse users because they would expect this works the same but it's not since another underlying API is used. Moreover, I suppose we can make this cmdlet more \r\n\r\nI hear you, and I would see the same problem if we *named* the cmdlet smilar, i.e. `Get-EventLog` or `Get-EventLogEx`. This would raise the expectation of similar *output*.\r\n\r\nI am focusing on *input* though. It is common place in PowerShell cmdlets that parameter names are standardized, i.e. Path, Filter, etc. even though users understand that they can have slightly different effects with different cmdlets. So duplicate parameter names isn't a problem, rather the cure and a good practice in PowerShell.\r\n\r\nI have conducted extensive testincg, so that said, and even though we are using a different API, the suggested parameters in fact work *exactly* like the ones in `Get-EventLog`. Again, the parameters are for filtering, and after all both cmdlets access the same event data.\r\n\r\nJust the *output*  is in a different format. Since  cmdlet names are sufficiently different, IMHO there is no risk of confusing these two. A user who simply exchanges the  cmdlet names in old scripts (thanks to  parameter compatibility) can't complain that output is different. Same with `Get-WmiObject` and `Get-CimInstance`.",
      "created_at": "2021-08-03T04:04:52Z",
      "updated_at": "2021-08-03T04:04:52Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> I wonder if a `New-WinEventFilter` cmdlet which has parameters and simply returns a hashtable would be a good experience?\r\n\r\nIt is trivial for common event properties but  it's hard for specific event properties.\r\nOOB in Windows there are hundreds of event providers, each of which can have tens of event types, i.e. there are tens of thousands of event types. Extracting meta-information for all of them would take a few minutes. (And remember that not all of them have static metadata, i.e. we cannot always use caching>)\r\n\r\nThe only scenario we could implement is with strict adherence to the following steps:\r\n1. Pick up an event provider (read and cache metadata)\r\n2. Pick up an event number\r\n3. Search metadata for the event (the event provider + the event number)\r\n4. Get specific properties for the event\r\n\r\nThis force we think about dynamic parameters. Although I'm not sure if there are any multi-level nesting. if no we could enhance Get-WinEvent with dynamic parameters (PSPropertyExpression?) without introducing new cmdlet (New-WinEventFilter).\r\n\r\n> Just the output is in a different format.\r\n\r\nThat's exactly what I'm talking about. It makes it harder for users to adapt than it helps them. Why make a Tesla a steamroller? :-)\r\nThat goes for internal implementation as well. It's better to fully utilize the power of the new API than to try to waste it on primitive things\r\n\r\n> IMHO there is no risk of confusing these two\r\n\r\n I can not agree with this. I think it is high risk to break something and tricky.\r\n\r\nI also had difficulty transitioning from Get-EventLog to Get-WinEvent. This happens quickly for scripts. Difficulties in interactive scripting. And there are ways to help users.",
      "created_at": "2021-08-03T04:22:21Z",
      "updated_at": "2021-08-03T04:24:24Z"
    },
    {
      "author": "TobiasPSP",
      "author_association": "COLLABORATOR",
      "body": "> It'd be fine and possibly even better if it returned a concrete type with those values being publicly settable, I think; powershell folks could still use a hashtable as the parameter as long as the parameter type is the new type, and it allows the properties to be publicly set.\r\n\r\nI hope I understand the comment correctly. If not please apologize.\r\n\r\nMy understanding is that rather than custom-build hand-tailored intellisense for a hashtable in this cmdlet, you suggest to replace it by some new object type that in itself (i.e. via its members) is discoverable.\r\n\r\nSince we cannot break compatibility, this would add a new parameterset as well. So the question would be whether the target user benefits more from yet another structured input object or from individual parameters that together compose the user input.\r\n\r\nThe vast majority of PowerShell cmdlets receive user input via parameters with simple data types. Only very rarely do we see complex input objects. And if we do, these are either designed with piping in mind, or they support simple autoconversion from strings, so the user can always use simple data types to submit arguments.\r\n\r\nHowever discoverable you make a structural input, simply typing them into a single line, with  special characters or artifical new lines via \";\" or other complexities is cumbrsome.\r\n\r\nAs a rule of thumb IMHO, complex input objects are ok if what you do happens is more related to scripting and programming, i.e. `New-CimSessionOption` creates such a \"custom object\" yet doing this is rarely needed interactively. Interactively, `New-CimSession` (as an example) surfaces the same known and proven parameters like `-ComputerName` and `-Credential` that are required and that even occasional scripters are familiar with.\r\n\r\nAs a conclusion, daily tasks should IMHO be discoverable and doable via simple parameters. This helps occasional scripters and supports experienced admins when they do their typical production \"trial and error\" where they play with cmdlet outcome and add or remove individual parameters rather than having to edit separate complex structures.\r\n\r\nSo maybe we should split this here into two different threads: there is definitely room to improve the existing filterhashtable parameterset and make it more discoverable. My proposal here focuses on a new parameterset trying to avoid complex structures altogether.",
      "created_at": "2021-08-03T04:27:43Z",
      "updated_at": "2021-08-03T04:27:43Z"
    },
    {
      "author": "TobiasPSP",
      "author_association": "COLLABORATOR",
      "body": "> It is trivial for common event properties but it's hard for specific event properties.\r\n> OOB in Windows there are hundreds of event providers, each of which can have tens of event types, i.e. there are tens of thousands of event types. Extracting meta-information for all of them would take a few minutes. (And remember that not all of them have static metadata, i.e. we cannot always use caching>)\r\n\r\nMaybe I am missing something here. When it comes to cmdlet **input** and typical filtering (as supported by `-FilterHashtable`), there are only a few parameters that almost exactly map `Get-EventLog`. We shouldn't try and go beyond `-FilterHashtable` without good reason. \r\n\r\nThere are definitely additional sophisticated filter opportunities that go beyond what `-FlterHashtable` can do. For those rare circumstances where this is needed, users typically use -Verbose (to first create an initial XML from a simple filterhashtable), then use manual editing and re-submit tuned XPath. It was my feeling that the parametersets for XML exist exactly for this one scenario: to tap into the full and rich filtering backend. As far as I know, when you submit a `-FilterXml`, you already access the full API potential. Or am I missing something maybe?\r\n\r\nI am all for expanding the capabilities of this cmdlet while at it, provided these capabilities are what the majority of users need. Maybe we should get more concrete and come up with query examples that currently are not supported.\r\n\r\nAnother thing is looking at cmdlet **output**. There is valuable information hidden inside the returned objects, namely inside the property *Properties*. I'd suggest we surface this as ordered hashtables, using numeric keys at first (in lack of metadata describing the names of these properties which are event specific), plus an optional parameter `-PropertyName` which can take an array of custom names that would replace the default numeric key names.\r\n\r\nThat way, a user could simply pick the true property values needed from a given event type, manipulate the hashtable and \"convert\" it to [PSCustomObject] at last, producing beautiful object oriented output right from `Get-WinEvent`.",
      "created_at": "2021-08-03T04:35:01Z",
      "updated_at": "2021-08-03T04:38:31Z"
    },
    {
      "author": "TobiasPSP",
      "author_association": "COLLABORATOR",
      "body": "The initial suggestion was to add a cute little parameterset to have the every-day functionality that users are familiar with in Get-Eventlog. Technically this is trivial. \r\n\r\nMaybe we should separate discussions about (definitely promising) efforts to tap into metadata and create even more advanced queries to a new issue, or is this related to the suggested simple parameters, and I don\u2019t see it yet?",
      "created_at": "2021-08-03T10:49:39Z",
      "updated_at": "2021-08-03T10:49:39Z"
    },
    {
      "author": "TobiasPSP",
      "author_association": "COLLABORATOR",
      "body": "> It makes it harder for users to adapt than it helps them.\r\n\r\nCurrently, the user I have in mind struggles with getting the cmdlet to run in the first place (see my earlier post explaining why users currently can't discover the functionality of `Get-WinEvent`). This user group (admins and ITPro) won't probably even notice that the returned data is wrapped inside a different type as long as they can read the data.\r\n\r\nIt is a bit like with `Get-WMIObject` and `Get-CimInstance`. They basically return the same information but use different objects and have different concepts (COM vs. WSMan). I haven't seen problems, and people love the way how they can continue to use the same input information (WMI classes and filters) to get going.",
      "created_at": "2021-08-03T10:56:27Z",
      "updated_at": "2021-08-03T10:57:14Z"
    },
    {
      "author": "jdhitsolutions",
      "author_association": "COLLABORATOR",
      "body": "@PowerShell/wg-powershell-cmdlets reviewed this and don't believe `New-EventLog` is a cmdlet that most users use as it is more developer-oriented than for managing the event log.  Since the EventLog cmdlet code is available in the PS repo under MIT License, a community member can use that and publish a standalone module to PowerShellGallery to get data of its utility before we revisit having this as part of PS7.  Instead, the WinEvent cmdlets replace the EventLog cmdlets but we recognize that they are more complicated to use.  We would prefer to focus the discussion on https://github.com/PowerShell/PowerShell/issues/15844 to improve the WinEvent cmdlets.",
      "created_at": "2021-10-20T17:04:27Z",
      "updated_at": "2021-10-20T17:04:27Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@jdhitsolutions Is the link to #15844 correct in your post?",
      "created_at": "2021-10-20T18:44:26Z",
      "updated_at": "2021-10-20T18:44:26Z"
    }
  ],
  "created_at": "2021-07-29T09:42:03Z",
  "number": 15844,
  "state": "closed",
  "title": "Make Get-WinEvent compatible to Get-EventLog",
  "updated_at": "2021-10-20T18:44:26Z"
}