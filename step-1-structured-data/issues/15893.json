{
  "_url": "https://github.com/PowerShell/PowerShell/issues/15893",
  "author": "ArnoCan",
  "body": "### Prerequisites\n\n- [X] Write a descriptive title.\n- [X] Make sure you are able to repro it on the [latest released version](https://github.com/PowerShell/PowerShell/releases)\n- [X] Search the existing issues.\n- [X] Refer to the [FAQ](https://github.com/PowerShell/PowerShell/blob/master/docs/FAQ.md).\n- [X] Refer to [Differences between Windows PowerShell 5.1 and PowerShell](https://docs.microsoft.com/powershell/scripting/whats-new/differences-from-windows-powershell).\n\n### Steps to reproduce\n\nThis issue is technically  related to #15888, #15889, and #15892.\r\n\r\nThe specifications and definitions are:\r\n\r\n* [PowerShell-7.1 - B. Grammar](https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-15?view=powershell-7.1) - see *escaped-character*\r\n* [about_Quoting_Rules](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_quoting_rules?view=powershell-7.1) - PowerShell-7.1\r\n* [Everyone quotes command line arguments the wrong way](https://docs.microsoft.com/en-us/archive/blogs/twistylittlepassagesallalike/everyone-quotes-command-line-arguments-the-wrong-way)\r\n\r\n\r\n1. The pure evaluation from the PowerShell prompt behaves as stated in [about_Quoting_Rules](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_quoting_rules?view=powershell-7.1) and uses the syntax of the domain [PowerShell-7.1 - B. Grammar](https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-15?view=powershell-7.1)\r\n\r\n2. The call of a PowerShell script behaves the same way.\r\n\r\n3. The call of an executable such as another PowerShell instance leaves the PowerShell syntax domain and passes the DOS/cmd.exe syntax domain before entering the PowerShell syntax domain again.\r\n   ```\r\n   PS> pwsh.exe        powershell-script.ps1  <command-line-parameters>\r\n   PS> powershell.exe  powershell-script.ps1  <command-line-parameters>\r\n   ```\r\n\r\n   This is for example the case for:\r\n   ```\r\n   PS> powershell.exe -noprofile -executionpolicy bypass -file  X:\\print_argv_list.ps1  \"\\\"\"a\"\r\n   ['\"a', ]\r\n   PS> .\\pwsh.exe -noprofile -executionpolicy bypass -file  X:\\print_argv_list.ps1  \"\\\"\"a\"\r\n   ['\"a', ]\r\n   PS>\r\n   ```\r\n   where the DOS in-string escape character backslash is successfully applied.\r\n\r\n   The backslash is not specified in the grammar [PowerShell-7.1 - B. Grammar](https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-15?view=powershell-7.1) by *escaped-character*.\r\n\r\n   Same with Python:\r\n   ```\r\n   PS> C:\\Python371\\python.exe -c \"import sys;print(sys.argv[1:])\" \"\\\"\"a\"\r\n   ['\"a']\r\n   PS>\r\n   ```\r\n\r\n   The latter leads me to the assumption, that the initial execution is actually performed in a DOS/cmd.exe like environment, thus escaped and quoted in accordance to the DOS/cmd.exe command line syntax rules. But I called a PowerShell executable at a PowerShell prompt. So I do not expect an intermediary DOS exec call with it's native command line syntax, which has significant differences. Some cases could even not be realized due to the partially contrary/non-compatible specifications.\r\n\r\nThis makes it difficult to scan/parse a raw call string statically. Because in each case the actuall call chain has to be determined.\r\n\r\nThe command line call syntax should not change during the call process. At least it should be protected and/or transformed appropriately and passed transparently to the target executable.\r\n\r\nThe user should have to apply one command line syntax only - PowerShell.\r\nThe number of the evaluations of the input command line should be determined and fixed - at best 1x for each call-level.\r\n\n\n### Expected behavior\n\n```console\nPS> powershell.exe -noprofile -executionpolicy bypass -file  X:\\print_argv_list.ps1  \"`\"a\"\r\n['\"a', ]\r\nPS> .\\pwsh.exe -noprofile -executionpolicy bypass -file  X:\\print_argv_list.ps1  \"`\"a\"\r\n['\"a', ]\r\nPS> .\\pwsh.exe -noprofile -executionpolicy bypass -file  X:\\print_argv_list.ps1  \"\\\"\"a\"\r\n['\\a']\n```\n\n\n### Actual behavior\n\n```console\nPS> powershell.exe -noprofile -executionpolicy bypass -file  X:\\print_argv_list.ps1  \"`\"a\"\r\n['a', ]\r\nPS> .\\pwsh.exe -noprofile -executionpolicy bypass -file  X:\\print_argv_list.ps1  \"`\"a\"\r\n['a', ]\r\nPS> .\\pwsh.exe -noprofile -executionpolicy bypass -file  X:\\print_argv_list.ps1  \"\\\"\"a\"\r\n['\"a']\n```\n\n\n### Error details\n\n_No response_\n\n### Environment data\n\n```powershell\nName                           Value\r\n----                           -----\r\nPSVersion                      7.1.3\r\nPSEdition                      Core\r\nGitCommitId                    7.1.3\r\nOS                             Microsoft Windows 10.0.19042\r\nPlatform                       Win32NT\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\n```\n\n\n### Visuals\n\n_No response_",
  "closed_at": "2021-08-13T17:00:37Z",
  "comments": [
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "> I called a PowerShell executable at a PowerShell prompt. So I do not expect an intermediary DOS exec call with it's native command line syntax, which has significant differences. Some cases could even not be realized due to the partially contrary/non-compatible specifications.\r\n\r\nIs this a PowerShell issue or a Windows one? I don't know of any way to invoke a process on WIndows while bypassing the typical command line syntax. \ud83e\udd37 \r\n\r\nAlso, looking at the other issues you filed, the problem you're seeing looks just about the same between all of them, with only slight differences in how it presents, so I'm not sure what you're hoping to achieve other than confusing folks by filing them all separately. \ud83d\ude15 ",
      "created_at": "2021-08-09T13:13:38Z",
      "updated_at": "2021-08-09T13:19:19Z"
    },
    {
      "author": "ArnoCan",
      "author_association": "NONE",
      "body": "The main confusion of the input and result are:\r\n```\r\nPS> .\\pwsh.exe -noprofile -executionpolicy bypass -file  X:\\print_argv_list.ps1  \"\\\"\"a\"\r\n['\"a']\r\n```\r\nBecause the backslash is not defined by the PowerShell syntax specification as escape character, see *escaped-character*. But the backtick only.\r\n\r\nI don't know how the internal call structure is. So I cannot say where the internal issue for the call is.\r\n\r\nThe only thing I know here is that the backslash is defined by DOS/cmd.exe as an in-quote escape character. Because the caret does not work within double quotes.\r\n```\r\nC:\\Python371>python.exe -c \"import sys;print(sys.argv[1:])\" \"^\"a\"\r\n['^a']\r\n\r\nC:\\Python371>python.exe -c \"import sys;print(sys.argv[1:])\" \"\\\"a\"\r\n['\"a']\r\n\r\nC:\\Python371>\r\n```\r\nThus I assume that a DOS based evaluation and execution is proceeded.\r\n\r\nI tried some calls for example with DOS based escaping, but failed due to the required biased quotes of the PowerShell, thus was not able to pass all my trial strings through to the DOS based call. Therefore I had to add even in the above call an extra double quote.\r\n```\r\n\"\\\"a\" => \"\\\"\"a\"\r\n```\r\nTherefore I did not managed to pass e.g. the following string  due to the non-balanced double qoute error of the PowerShell:\r\n```\r\n\"^\"a\"\r\n```\r\nThe alternative:\r\n```\r\n'^\"a'\r\n```\r\npassed, but did not work as expected.\r\n\r\nThis is why I assume that a simple update of the specification will eventually not suffice for all scenarios.\r\n",
      "created_at": "2021-08-09T13:39:25Z",
      "updated_at": "2021-08-09T13:39:25Z"
    },
    {
      "author": "237dmitry",
      "author_association": "NONE",
      "body": "> Therefore I did not managed to pass e.g. the following string due to the non-balanced double qoute error of the PowerShell\r\n\r\n```powershell\r\n PS > pwsh -f .\\1.ps1 '^\"\"\"a'\r\n['^\"a']\r\n\r\n PS > gc .\\1.ps1\r\n\"['$args']\"\r\n```",
      "created_at": "2021-08-09T16:28:57Z",
      "updated_at": "2021-08-09T16:28:57Z"
    },
    {
      "author": "jborean93",
      "author_association": "COLLABORATOR",
      "body": "There are multiple levels you need to take into account that aren't specifically PowerShell related.\r\n\r\n* PowerShell's parser to create a string\r\n  * If running in PowerShell itself and you want to create a string you need to abide by the parsing rules\r\n  * That is single quotes/doubles quotes as per https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_quoting_rules?view=powershell-7.1\r\n  * This logic is about creating a string object in PowerShell for use elsewhere\r\n  * This is basically how does PowerShell treat `\"abc\"` vs `'abc'` vs `'\"abc\"'` and so on\r\n* PowerShell's logic when calling a native executable\r\n  * This is the logic that PowerShell uses to convert the arguments that it sees when invoking a native binary\r\n  * e.g. `my.exe $arg1 \"arg2\" ...`\r\n  * It essentially reads each value as positional arguments and generates a list of strings to then pass to the native API\r\n  * On Windows there is no native API to invoke an executable with a list of arguments so PowerShell has logic to convert that list to a single string\r\n  * There are numerous issues around this https://github.com/PowerShell/PowerShell/issues/1995\r\n  * 7.2 is implementing some features that try to make this easier to deal with some some of this logic is on shifting ground\r\n  * In a general sense on Windows, PowerShell will enclose an argument in double quotes but it does not escape the inner double quotes if present\r\n  * `my.exe foo \"bar hello\" '{\"foo\": \"bar\"}'` becomes the following command line value `my.exe foo \"bar hello\" \"{\"foo\": \"bar\"}\"`\r\n* The platforms logic when setting argv of the new process\r\n  * Linux has a native API to start a process with a list of arguments so this is quite simple\r\n  * Windows on the other hand has https://docs.microsoft.com/en-us/archive/blogs/twistylittlepassagesallalike/everyone-quotes-command-line-arguments-the-wrong-way\r\n  * E.g. Windows treats `\"` as a way to escape whitespace chars and `\\\"` as a way to have a literal double quote\r\n* The new process' logic when reading argv\r\n  * A process could use the argv passed into it or it could have it's own rules and just reads the command line string directly\r\n  * There's nothing much PowerShell can do about this as the behaviour is entirely up to the binary being called\r\n\r\nUsing my example above say you were to do the following in PowerShell (on Windows at least)\r\n\r\n```powershell\r\n$nativeArgs = @('argument1', \"argument 2\")\r\n$bar = \"value 123\"\r\n\r\nmy.exe $nativeArgs foo \"bar $bar\" '{\"foo\": \"$bar\"}'\r\n```\r\n\r\nWhat happens is the following:\r\n\r\n* PowerShell parses the line `$nativeArgs ...` and creates an array of strings based on the standard PowerShell quoting rules\r\n* PowerShell parses the line `my.exe ...` and sees it is calling a native binary and it has positional arguments\r\n* These positional arguments are read just like positional arguments to a cmdlet and are flattened down to 2 array\r\n  * `$nativeArgs` already contains an array of strings so no extra parsing there - becomes the args `arguments1`, `argument 2`\r\n  * `foo` is a bare positional argument and is treated as a string - becomes the arg `foo`\r\n  * `\"bar $bar\"` is a double quoted value so is treated as a string and embedded vars are \"templated\" in - becomes the argument `bar value 123`\r\n  * `'{\"foo\": \"$bar\"}'` is a string value inside single quotes so no variable templating applies - becomes the argument `{\"foo\": \"$bar\"}`\r\n* PowerShell takes the list of arguments and wraps them in double quotes if they contain whitespace (space/newline/etc)\r\n  * `argument1` has no space so is kept as `argument1`\r\n  * `argument 2` has a space so it's changed to `\"argument 2\"`\r\n  * `foo` has no space so is kept as `foo`\r\n  * `bar value 123` has a space so it's changed to `\"bar value 123\"`\r\n  * `{\"foo\": \"$bar\"}` has a space so it's changed to `\"{\"foo\": \"$bar\"}\"`\r\n* The list of arguments are added together with spaces and invoked on the C API\r\n  * The command becomes `\"my.exe\" argument1 \"argument 2\" foo \"bar value 123\" \"{\"foo\": \"$bar\"}\"`\r\n* Now the native binary starts and goes to read the command line\r\n  * It either uses the standard Windows rules as defined in https://docs.microsoft.com/en-us/archive/blogs/twistylittlepassagesallalike/everyone-quotes-command-line-arguments-the-wrong-way\r\n  * Or it ignores all that, reads the full command line as a string and parses it in it's own way\r\n* For the first everything works fine until it gets to `\"{\"foo\": \"$bar\"}\"`\r\n  * The argument here ultimately becomes `{foo: $bar}` which is obviously not correct\r\n  * To fix this in PowerShell you would have to escape the inner double quotes manually and do `my.exe $nativeArgs foo \"bar $bar\" '{\\\"foo\\\": \\\"$bar\\\"}'`\r\n  * Escaping for this uses `\\\"` as the escaping happens in this layer and not PowerShell\r\n  * This is the type of things that are targeted towards fixing in 7.2\r\n  * The key thing to note here is the escaping done here is not escaping for PowerShell but rather escaping for this layer\r\n  * Essentially the escaping logic for PowerShell doesn't apply\r\n* For the 2nd there's no golden rule - it's entirely up to the underlying application\r\n\r\nUltimately there is no one size fits all and it's made complex by the many different layers that are involved\n\n<blockquote><img src=\"https://docs.microsoft.com/media/logos/logo-powershell-social.png\" width=\"48\" align=\"right\"><div><strong><a href=\"https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_quoting_rules\">about Quoting Rules - PowerShell</a></strong></div><div>Describes rules for using single and double quotation marks in PowerShell.</div></blockquote>\n<blockquote><div><strong><a href=\"https://docs.microsoft.com/en-us/archive/blogs/twistylittlepassagesallalike/everyone-quotes-command-line-arguments-the-wrong-way\">Everyone quotes command line arguments the wrong way</a></strong></div></blockquote>",
      "created_at": "2021-08-09T20:00:32Z",
      "updated_at": "2021-08-09T20:00:34Z"
    },
    {
      "author": "ArnoCan",
      "author_association": "NONE",
      "body": "@237dmitry\r\nI tried to pass the string literal:\r\n```\r\n^\"a\r\n```\r\nto the native layer with the expected literal result - from the native layer:\r\n```\r\n\"a\r\n```\r\nWhich may have a different call context than the call of a native PowerShell script - see also @jborean93.\r\n\r\nAnyhow, this was just a simple trial to understand the instances of the call chain.\r\n",
      "created_at": "2021-08-10T02:48:58Z",
      "updated_at": "2021-08-10T02:48:58Z"
    },
    {
      "author": "ArnoCan",
      "author_association": "NONE",
      "body": "@jborean93\r\nThanks for the comprehensive description. This is exactly the challange.\r\n\r\nMy focus on the syntax specification in external code like Python is matched in particular by:\r\n>The new process' logic when reading argv\r\n>\r\n>    A process could use the argv passed into it or it could have it's own rules and just reads the command line string directly\r\n\r\nThis is what I am scanning/lexing/tokenizing online and offline - argv and/or any complete or partial command line string. Therefore I require in particular the complete normative information about quoting and escaping.\r\n\r\nSpoken in terms of this issue - the missing parts of the syntax specification: \r\n- The resulting syntax of native calls requires [PowerShell-7.1 - B. Grammar](https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-15?view=powershell-7.1) plus the syntax specification of the ~~native~~ *native platform subprocess* call environment. The latter seems basically not available.\r\n\r\n- The syntax of the ~~native~~ *native platform subprocess* layer should be at least referenced by the PowerShell specification. See \r\n[PowerShell-7.1 - C. References](https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-16?view=powershell-7.1)\r\n",
      "created_at": "2021-08-10T04:26:30Z",
      "updated_at": "2021-08-10T06:00:18Z"
    },
    {
      "author": "ArnoCan",
      "author_association": "NONE",
      "body": "@vexx32\r\nThe issues are related all to the command line processing and the call of external subprocesses, in particular Python based.\r\nBut target actually different issues:\r\n\r\n- #15888: \r\n  Split into argv - I guess within calling PowerShell.\r\n- #15889: \r\n  Consistency of single and double quotes - where this does not matter - I guess within calling PowerShell.\r\n- #15892: \r\n  Escape behaviour - I guess within calling PowerShell for PowerShell interpreter and subprocess caller.\r\n- #15893: \r\n  Finally the requirement of the complete normative syntax specification for the native PowerShell interpreter as well as subprocess environments. With additional parsers as these require their own quoting/escaping embedded into the same call, but are different from the syntax of the PowerShell.\r\n\r\nThe tasks themself are a bit confusing, therefore I separated them in order to clearly distinguish and define the concrete issues case by case.\r\n",
      "created_at": "2021-08-10T06:01:19Z",
      "updated_at": "2021-08-10T06:03:26Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "This issue has been treated pretty extensively in https://github.com/PowerShell/PowerShell/issues/1995.\r\n\r\nThere's also discussion in https://github.com/PowerShell/PowerShell/issues/13068.\r\n\r\nEssentially, from https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-251192254, the Windows process creation API requires the command line as a single string rather than an array, and then parses that with [`CommandLineToArgvW`](https://docs.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-commandlinetoargvw). This all means that PowerShell is forced to either make a breaking change in how it parses the command line or propagate bad transformations through the .NET and Windows APIs.\r\n\r\nGiven the extensive discussion of this in pre-existing issues, I'll mark this and the other issues as duplicates of #1995.",
      "created_at": "2021-08-12T15:23:23Z",
      "updated_at": "2021-08-12T15:23:23Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This issue has been marked as duplicate and has not had any activity for **1 day**. It has been closed for housekeeping purposes.",
      "created_at": "2021-08-13T17:00:36Z",
      "updated_at": "2021-08-13T17:00:36Z"
    }
  ],
  "created_at": "2021-08-09T13:06:36Z",
  "labels": [
    "Resolution-Duplicate"
  ],
  "number": 15893,
  "state": "closed",
  "title": "The specification of the call syntax of the native PowerShell command line prompt is not consistent.",
  "updated_at": "2021-08-13T17:00:37Z"
}