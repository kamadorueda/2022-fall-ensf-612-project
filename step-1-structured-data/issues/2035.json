{
  "_url": "https://github.com/PowerShell/PowerShell/issues/2035",
  "author": "dlwyatt",
  "body": "## Steps to reproduce\n\nDefine a PowerShell function with an array parameter using the ValueFromRemainingArguments property of the Parameter attribute.  Instead of sending multiple arguments, send that parameter a single array argument.\n\n``` posh\n & {\n     param(\n         [string]\n         [Parameter(Position=0)]\n         $Root,\n\n         [string[]]\n         [Parameter(Position=1, ValueFromRemainingArguments)]\n         $Extra)\n     $Extra.Count;\n     for ($i = 0; $i -lt $Extra.Count; $i++)\n     {\n        \"${i}: $($Extra[$i])\"\n     }\n } root aa,bb\n```\n## Expected behavior\n\nThe array should be bound to the parameter just as you sent it, the same way it works for cmdlets.  (The \"ValueFromRemainingArguments\" behavior isn't used, in this case, it should just bind like any other array parameter type.)  The output of the above script block should be:\n\n2\n0: aa\n1: bb\n## Actual behavior\n\nPowerShell appears to be performing type conversion on the argument to treat the array as a single element of the parameter's array, instead of checking first to see if more arguments will be bound as \"remaining arguments\" first.  The output of the above script block is currently:\n\n1\n0: aa bb\n## Additional information\n\nTo demonstrate that the behavior of cmdlets is different, you can use this code:\n\n``` posh\nAdd-Type -OutputAssembly $env:temp\\testBinding.dll -TypeDefinition @'\n    using System;\n    using System.Management.Automation;\n\n    [Cmdlet(\"Test\", \"Binding\")]\n    public class TestBindingCommand : PSCmdlet\n    {\n        [Parameter(Position = 0)]\n        public string Root { get; set; }\n\n        [Parameter(Position = 1, ValueFromRemainingArguments = true)]\n        public string[] Extra { get; set; }\n\n        protected override void ProcessRecord()\n        {\n            WriteObject(Extra.Length);\n            for (int i = 0; i < Extra.Length; i++)\n            {\n                WriteObject(String.Format(\"{0}: {1}\", i, Extra[i]));\n            }\n        }\n    }\n'@\n\nImport-Module $env:temp\\testBinding.dll\n\nTest-Binding root aa,bb\n```\n## Environment data\n\n<!-- provide the output of $PSVersionTable -->\n\n``` powershell\n> $PSVersionTable\nName                           Value\n----                           -----\nPSEdition                      Core\nPSVersion                      6.0.0-alpha\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}\nWSManStackVersion              3.0\nGitCommitId                    v6.0.0-alpha.9-107-g203ace04c09dbbc1ac00d6b497849cb69cc919fb-dirty\nPSRemotingProtocolVersion      2.3\nCLRVersion\nSerializationVersion           1.1.0.1\nBuildVersion                   3.0.0.0\n```\n",
  "closed_at": "2017-10-13T01:23:18Z",
  "comments": [
    {
      "author": "dlwyatt",
      "author_association": "CONTRIBUTOR",
      "body": "Here are the ParameterBinding traces from each scenario:\n\nFunction:\n\n```\nDEBUG: ParameterBinding Information: 0 : BIND NAMED cmd line args [Test-BindingFunction]\nDEBUG: ParameterBinding Information: 0 : BIND POSITIONAL cmd line args [Test-BindingFunction]\nDEBUG: ParameterBinding Information: 0 :     BIND arg [root] to parameter [Root]\nDEBUG: ParameterBinding Information: 0 :         Executing DATA GENERATION metadata: [System.Management.Automation.ArgumentTypeConverterAttribute]\nDEBUG: ParameterBinding Information: 0 :             result returned from DATA GENERATION: root\nDEBUG: ParameterBinding Information: 0 :         BIND arg [root] to param [Root] SUCCESSFUL\nDEBUG: ParameterBinding Information: 0 : BIND REMAININGARGUMENTS cmd line args to param: [Extra]\nDEBUG: ParameterBinding Information: 0 :     BIND arg [System.Collections.Generic.List`1[System.Object]] to parameter [Extra]\nDEBUG: ParameterBinding Information: 0 :         Executing DATA GENERATION metadata: [System.Management.Automation.ArgumentTypeConverterAttribute]\nDEBUG: ParameterBinding Information: 0 :             result returned from DATA GENERATION: System.String[]\nDEBUG: ParameterBinding Information: 0 :         COERCE arg to [System.String[]]\nDEBUG: ParameterBinding Information: 0 :             Parameter and arg types the same, no coercion is needed.\nDEBUG: ParameterBinding Information: 0 :         BIND arg [System.String[]] to param [Extra] SUCCESSFUL\nDEBUG: ParameterBinding Information: 0 : MANDATORY PARAMETER CHECK on cmdlet [Test-BindingFunction]\nDEBUG: ParameterBinding Information: 0 : CALLING BeginProcessing\nDEBUG: ParameterBinding Information: 0 : CALLING EndProcessing\n```\n\nCmdlet:\n\n```\nDEBUG: ParameterBinding Information: 0 : BIND NAMED cmd line args [Test-Binding]\nDEBUG: ParameterBinding Information: 0 : BIND POSITIONAL cmd line args [Test-Binding]\nDEBUG: ParameterBinding Information: 0 :     BIND arg [root] to parameter [Root]\nDEBUG: ParameterBinding Information: 0 :         BIND arg [root] to param [Root] SUCCESSFUL\nDEBUG: ParameterBinding Information: 0 : BIND REMAININGARGUMENTS cmd line args to param: [Extra]\nDEBUG: ParameterBinding Information: 0 :     BIND arg [System.Collections.Generic.List`1[System.Object]] to parameter [Extra]\nDEBUG: ParameterBinding Information: 0 :         COERCE arg to [System.String[]]\nDEBUG: ParameterBinding Information: 0 :             Trying to convert argument value from System.Collections.Generic.List`1[System.Object] to System.String[]\nDEBUG: ParameterBinding Information: 0 :             ENCODING arg into collection\nDEBUG: ParameterBinding Information: 0 :             Binding collection parameter Extra: argument type [List`1], parameter type [System.String[]], collection type Array, element type [System.String],\ncoerceElementType\nDEBUG: ParameterBinding Information: 0 :             Arg is IList with 1 elements\nDEBUG: ParameterBinding Information: 0 :             Creating array with element type [System.String] and 1 elements\nDEBUG: ParameterBinding Information: 0 :             Argument type System.Collections.Generic.List`1[System.Object] is IList\nDEBUG: ParameterBinding Information: 0 :             COERCE collection element from type Object[] to type System.String\nDEBUG: ParameterBinding Information: 0 :             COERCE arg to [System.String]\nDEBUG: ParameterBinding Information: 0 :                 Trying to convert argument value from System.Object[] to System.String\nDEBUG: ParameterBinding Information: 0 :                 ERROR: ERROR: COERCE FAILED: arg [System.Object[]] could not be converted to the parameter type [System.String]\nDEBUG: ParameterBinding Information: 0 :     BIND arg [System.Object[]] to parameter [Extra]\nDEBUG: ParameterBinding Information: 0 :         COERCE arg to [System.String[]]\nDEBUG: ParameterBinding Information: 0 :             Trying to convert argument value from System.Object[] to System.String[]\nDEBUG: ParameterBinding Information: 0 :             ENCODING arg into collection\nDEBUG: ParameterBinding Information: 0 :             Binding collection parameter Extra: argument type [Object[]], parameter type [System.String[]], collection type Array, element type [System.String],\ncoerceElementType\nDEBUG: ParameterBinding Information: 0 :             Arg is IList with 2 elements\nDEBUG: ParameterBinding Information: 0 :             Creating array with element type [System.String] and 2 elements\nDEBUG: ParameterBinding Information: 0 :             Argument type System.Object[] is IList\nDEBUG: ParameterBinding Information: 0 :             COERCE collection element from type String to type System.String\nDEBUG: ParameterBinding Information: 0 :             COERCE arg to [System.String]\nDEBUG: ParameterBinding Information: 0 :                 Parameter and arg types the same, no coercion is needed.\nDEBUG: ParameterBinding Information: 0 :             Adding element of type String to array position 0\nDEBUG: ParameterBinding Information: 0 :             COERCE collection element from type String to type System.String\nDEBUG: ParameterBinding Information: 0 :             COERCE arg to [System.String]\nDEBUG: ParameterBinding Information: 0 :                 Parameter and arg types the same, no coercion is needed.\nDEBUG: ParameterBinding Information: 0 :             Adding element of type String to array position 1\nDEBUG: ParameterBinding Information: 0 :         BIND arg [System.String[]] to param [Extra] SUCCESSFUL\nDEBUG: ParameterBinding Information: 0 : MANDATORY PARAMETER CHECK on cmdlet [Test-Binding]\nDEBUG: ParameterBinding Information: 0 : CALLING BeginProcessing\nDEBUG: ParameterBinding Information: 0 : CALLING EndProcessing\n```\n\nWhat's interesting to me is this bit from the cmdlet trace:\n\n```\nDEBUG: ParameterBinding Information: 0 :             Binding collection parameter Extra: argument type [List`1], parameter type [System.String[]], collection type Array, element type [System.String],\ncoerceElementType\nDEBUG: ParameterBinding Information: 0 :             Arg is IList with 1 elements\nDEBUG: ParameterBinding Information: 0 :             Creating array with element type [System.String] and 1 elements\nDEBUG: ParameterBinding Information: 0 :             Argument type System.Collections.Generic.List`1[System.Object] is IList\nDEBUG: ParameterBinding Information: 0 :             COERCE collection element from type Object[] to type System.String\nDEBUG: ParameterBinding Information: 0 :             COERCE arg to [System.String]\nDEBUG: ParameterBinding Information: 0 :                 Trying to convert argument value from System.Object[] to System.String\nDEBUG: ParameterBinding Information: 0 :                 ERROR: ERROR: COERCE FAILED: arg [System.Object[]] could not be converted to the parameter type [System.String]\n```\n\nIf I'm understanding this correctly, it looks like the binder is receiving a 1-element List<Object>, and the element happens to be a 2-element Object[] in this case.  It tries (and fails, in the case of the cmdlet binding) to convert the List<Object> directly to a String[], but fails because the inner array (Object[]]) couldn't be directly converted to a String.\n\nWhen we're doing a function's binding, the ArgumentTypeConverterAttribute gets involved, and it has no problem \"casting\" anything to a string.  In this case, the string representation of the array @('aa','bb) is the string 'aa bb' (assuming a default value for the $OFS variable.)\n\nIn both cases, the array we actually passed as an argument to the command was wrapped in a single-element List<Object>, and the binder tried to do conversions on that List _first_, instead of acting directly on the values that were passed to the command.  It's just that the ArgumentTypeConverterAttribute was successfully able to convert the List, and the code path that was taken for the cmdlet's binding was not, so it fell through to converting the list's element instead.\n",
      "created_at": "2016-08-23T16:53:55Z",
      "updated_at": "2016-08-23T16:53:55Z"
    },
    {
      "author": "dlwyatt",
      "author_association": "CONTRIBUTOR",
      "body": "I haven't stepped through the code yet, but it seems logical that this List<Object> is what's being built up any time a ValueFromRemainingArguments parameter is in play.  That would be logical, and I would expect it to be a 2-element List that contains strings if we had passed the values as separate arguments instead of a single array.\n\nIf that is what's happening, then what seems to be missing is some logic to check, when ValueFromRemainingArguments is in play, whether the List contains only a single element.  If so, perhaps the list should be unwrapped before the parameter binder starts trying to do type conversion.\n",
      "created_at": "2016-08-23T17:00:10Z",
      "updated_at": "2016-08-23T17:00:10Z"
    },
    {
      "author": "dlwyatt",
      "author_association": "CONTRIBUTOR",
      "body": "That does appear to be the case.  Here's a trace of binding for the cmdlet with the array split into two string arguments:\n\n```\ntrace-command ParameterBinding -PSHost -Expression { Test-Binding root aa bb }\n\n# snip\n\nDEBUG: ParameterBinding Information: 0 :             Binding collection parameter Extra: argument type [List`1], parameter type [System.String[]], collection type Array, element type [System.String],\ncoerceElementType\nDEBUG: ParameterBinding Information: 0 :             Arg is IList with 2 elements\n```\n",
      "created_at": "2016-08-23T17:02:46Z",
      "updated_at": "2016-08-23T17:02:46Z"
    },
    {
      "author": "dlwyatt",
      "author_association": "CONTRIBUTOR",
      "body": "There is logic like this already (see https://github.com/PowerShell/PowerShell/blob/master/src/System.Management.Automation/engine/CmdletParameterBinderController.cs#L1696), but since the original call to BindParameter didn't fail, it doesn't run, in the case of a PowerShell function.\n\nWill submit a fix shortly.\n",
      "created_at": "2016-08-23T19:05:26Z",
      "updated_at": "2016-08-23T19:06:14Z"
    },
    {
      "author": "MarvTheRobot",
      "author_association": "CONTRIBUTOR",
      "body": "Is this not down to how the string array is being passed in? Would \"aa\",\"bb\"  work any better. \n\nI only ask as something similar happens to me in PowerShell data files in DSC. If I comma separate nodes, they end up as an array in the first element of an object array. When I remove the comma, I get an array as expected without being put into a containing array. --> ok so 'similar' is a very loose term ;)\n\nEither way, it's a good bit of investigation and work. Perhaps I should stop being lazy and do similar. \n",
      "created_at": "2016-08-24T05:32:11Z",
      "updated_at": "2016-08-24T05:32:11Z"
    },
    {
      "author": "dlwyatt",
      "author_association": "CONTRIBUTOR",
      "body": "The quotation marks aren't important in this case.  PowerShell's in argument parsing mode at that point, so unless a string contains spaces or certain other special syntax characters (such as commas), it's okay to pass without quotes.  That's how you can do things like `dir c:\\` instead of `dir \"c:\\\"` all the time.  :)\n",
      "created_at": "2016-08-24T06:01:11Z",
      "updated_at": "2016-08-24T06:01:11Z"
    },
    {
      "author": "MarvTheRobot",
      "author_association": "CONTRIBUTOR",
      "body": "Ah, well THAT is a very good point.\n\nOn Wed, Aug 24, 2016 at 7:01 AM +0100, \"Dave Wyatt\" notifications@github.com wrote:\n\nThe quotation marks aren't important in this case.  PowerShell's in argument parsing mode at that point, so unless a string contains spaces or certain other special syntax characters (such as commas), it's okay to pass without quotes.  That's how you can do things like `dir c:\\` instead of `dir \"c:\\\"` all the time.  :)\n\n## \n\nYou are receiving this because you commented.\nReply to this email directly or view it on GitHub:\nhttps://github.com/PowerShell/PowerShell/issues/2035#issuecomment-241965543\n",
      "created_at": "2016-08-24T06:17:01Z",
      "updated_at": "2016-08-24T06:17:01Z"
    },
    {
      "author": "jpsnover",
      "author_association": "CONTRIBUTOR",
      "body": "It is working exactly as I expect.  Here is the example which best illustrates what is happening:\nroot aa   bb,cc   dd,ee,ff\n3\n0: aa\n1: bb cc\n2: dd ee ff\n",
      "created_at": "2016-08-28T15:10:38Z",
      "updated_at": "2016-08-28T15:10:38Z"
    },
    {
      "author": "dlwyatt",
      "author_association": "CONTRIBUTOR",
      "body": "@jpsnover : In that example, you're sidestepping the problem by passing in three arguments to the $Extra parameter.  The code path that's causing a problem is when you just pass the parameter an array without using the \"additional arguments\" syntax sugar.\n",
      "created_at": "2016-08-28T16:01:24Z",
      "updated_at": "2016-08-28T16:01:24Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "The current parameter binder is working as I expect too.  \n\nYou can get the desired output by using splatting:\n\n``` powershell\n$params = @{Extra = @('aa','bb')}\n...\n} root @params\n```\n\nThat said, it might be nice to have a convenient syntax for splatting unnamed/positional arguments that took an array like:\n\n``` powershell\n$extra = 'aa','bb'\n...\n} root @extra\n```\n\nBut to make it really convenient it should work on an array literal e.g.\n\n``` powershell\n} root @@('aa','bb')\n```\n\nNot exactly sure what the syntax should be since today this doesn't work with hashtable literals either.\n",
      "created_at": "2016-08-28T17:18:44Z",
      "updated_at": "2016-08-28T17:18:44Z"
    },
    {
      "author": "dlwyatt",
      "author_association": "CONTRIBUTOR",
      "body": "I don't see how this can be expected behavior.  Going back to the original example, giving the function a name this time:\n\n``` posh\nfunction Do-Something {\n     param(\n         [string]\n         [Parameter(Position=0)]\n         $Root,\n\n         [string[]]\n         [Parameter(Position=1, ValueFromRemainingArguments)]\n         $Extra)\n\n     $Extra.Count;\n     for ($i = 0; $i -lt $Extra.Count; $i++)\n     {\n        \"${i}: $($Extra[$i])\"\n     }\n }\n\nDo-Something Root Extra1 Extra2 Extra3\nDo-Something Root @('Extra1', 'Extra2', 'Extra3')\n```\n\nBoth of those calls _should_ have identical values for the `$Extra` variable inside the function.  `-Extra` is the last positional parameter defined, and has the `ValueFromRemainingArguments` attribute.  I can either pass it the whole array in one go (same as any other parameter defined with an array object type), or I can use the syntax that is enabled by `ValueFromRemainingArguments` instead.\n\nBut they're not identical, because of the bug that's demonstrated here.  If you look at the discussion for the PR to fix it, there are even more weird scenarios involving cmdlets like Write-Output.  (Parameter binding for functions takes a different code path than cmdlets, and has different quirks in this case.)\n",
      "created_at": "2016-08-28T17:23:41Z",
      "updated_at": "2016-08-28T17:24:24Z"
    },
    {
      "author": "rkeithhill",
      "author_association": "COLLABORATOR",
      "body": "Let's start with the case where there is no `ValueFromRemainingArguments`:\n\n``` powershell\nfunction Do-Something {\n     param(\n         [string]\n         [Parameter(Position=0)]\n         $Root,\n\n         [string[]]\n         [Parameter(Position=1)]\n         $Extra)\n\n     $Extra.Count;\n     for ($i = 0; $i -lt $Extra.Count; $i++)\n     {\n        \"${i}: $($Extra[$i])\"\n     }\n }\n```\n\nThat results in:\n\n```\n148> Do-Something Root 'Extra1', 'Extra2', 'Extra3'\n3\n0: Extra1\n1: Extra2\n2: Extra3\n```\n\nThat was your initial expected output.  But this doesn't accept extra args: `Do-Something Root Extra1 Extra2 Extra3`.  So you add in `ValueFromRemainingArguments` to handle that case and voila, that case works:\n\n```\n151> Do-Something Root Extra1 Extra2 Extra3\n3\n0: Extra1\n1: Extra2\n2: Extra3\n```\n\nUnfortunately the original array case behavior has changed.\n\n```\n152> Do-Something Root Extra1, Extra2, Extra3\n1\n0: Extra1 Extra2 Extra3\n```\n\nI can see how that appears to be buggy and I guess it comes down to what the semantics are for `ValueFromRemainingArguments`.  I think the semantics change pretty significantly for a parameter decorated with ValueFromRemainingArguments (why does that quote from Unforgiven come to mind - nevermind).  \n\nObviously, for such a parameter, PS aggregates all remaining/unbound arguments into a single argument value (converting to array if necessary) to supply to the parameter.  That appears to work as you'd expect for multiple space separated args.  But for arrays the behavior is perhaps not expected.  However, I think for the following case it is working as expected:\n\n```\n154> Do-Something Root Extra1,Extra2,Extra3 1,3 $false\n3\n0: Extra1 Extra2 Extra3\n1: 1 3\n2: False\n```\n\nI'm not sure what else PowerShell could do here but treat the first array as a \"single\" argument in this case.  But what to do about the case where you have a single argument that is an array?\n\n```\n155> Do-Something Root Extra1,Extra2,Extra3\n1\n0: Extra1 Extra2 Extra3\n```\n\nShould PowerShell be clever and if the first (and only) argument is an array, assign it as sort of the splatted value of the parameter instead of treating it as a single value in the array or remaining args?  I don't know.  But I can see a case being made that if the user wanted those as mulitple args they would have specified them as multiple args.  Not trying to be snarky but really just wondering if there could be a case where the user really wanted the first (and only) argument to be treated as a single argument (of type array) and this cleverness takes away that ability?\n",
      "created_at": "2016-08-28T18:21:51Z",
      "updated_at": "2016-08-28T18:21:51Z"
    },
    {
      "author": "dlwyatt",
      "author_association": "CONTRIBUTOR",
      "body": "For that, you'd behave just like any other array parameter where you wanted to send in a single-element array (such as -ArgumentList when calling New-Object for constructors that take an array):  unary comma.\n\n`Do-Something ,('Extra1', 'Extra2', 'Extra3')`\n",
      "created_at": "2016-08-28T18:23:58Z",
      "updated_at": "2016-08-28T18:24:51Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I agree with @rkeithhill  the current parameter binder for ValueFromRemainingArguments is working as expected - its by design and no fix needed.\n",
      "created_at": "2016-09-26T11:25:32Z",
      "updated_at": "2016-09-26T11:25:32Z"
    },
    {
      "author": "dlwyatt",
      "author_association": "CONTRIBUTOR",
      "body": "Well, whatever.  I don't see how anyone can agree with the binding behavior being different when using the syntax sugar, but fine.  My recommendation will be for people to never use ValueFromRemainingArguments when writing functions due to the surprise factor.\n",
      "created_at": "2016-09-26T12:45:20Z",
      "updated_at": "2016-09-26T12:45:20Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "There are fans of ValueFromRemainingArguments https://beatcracker.wordpress.com/2014/12/01/splatting-and-mandatory-parameters/\n",
      "created_at": "2016-09-26T13:41:47Z",
      "updated_at": "2016-09-26T13:41:47Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "I'd like to leave this open - I do think there is a bug here.  Ideally, `ValueFromRemainingArguments` should work the same when calling a function or cmdlet.\n\nThe following sample demonstrates multiple ways behavior differs:\n\n``` powershell\nAdd-Type -PassThru @\"\nusing System.Management.Automation;\n\n[Cmdlet(\"Write\", \"ThingC\")]\npublic class WriteThingCommand : PSCmdlet {\n    [Parameter(Mandatory = true, Position = 0, ValueFromRemainingArguments = true)] public string[] Things { get; set; }\n\n    override protected void ProcessRecord() {\n        var sb = new System.Text.StringBuilder();\n        sb.AppendFormat(\"  C`tLength: {0}\", Things.Length);\n        for (var i = 0; i < Things.Length; i++) {\n            var t = new PSObject(Things[i]);\n            sb.AppendFormat(\"`titem {0}: {1}\", i, t.ToString());\n        }\n        System.Console.WriteLine(sb.ToString());\n    }\n}\n\"@ | Select -First 1 | % { Import-Module -Assembly $_.Assembly }\n\nfunction Write-ThingF {\n    param([Parameter(Position = 0, ValueFromRemainingArguments, Mandatory)][string[]]$Things)\n    process {\n        $sb = [System.Text.StringBuilder]::new()\n        $null = $sb.AppendFormat(\"  F`tLength: {0}\", $Things.Length)\n        for ($i = 0; $i -lt $Things.Length; $i++) {\n            $null = $sb.AppendFormat(\"`titem {0}: {1}\", $i, [string]$Things[$i])\n        }\n        [Console]::WriteLine($sb.ToString())\n    }\n}\n\ntrap { [Console]::WriteLine(\"  error\"); continue }\n\n[Console]::WriteLine(\"Same\")\nWrite-ThingF -Things 1,2\nWrite-ThingC -Things 1,2\n\n[Console]::WriteLine(\"Differs\")\nWrite-ThingF 1,2\nWrite-ThingC 1,2\n\n[Console]::WriteLine(\"Same\")\nWrite-ThingF 1 2\nWrite-ThingC 1 2\n\n[Console]::WriteLine(\"Same\")\nWrite-ThingF -Things 1 2\nWrite-ThingC -Things 1 2\n\n[Console]::WriteLine(\"Same\")\nWrite-ThingF -Things 1,2 3,4\nWrite-ThingC -Things 1,2 3,4\n\n[Console]::WriteLine(\"Differs\")\nWrite-ThingF 1,2 3,4\nWrite-ThingC 1,2 3,4\n\n[Console]::WriteLine(\"Same\")\nWrite-ThingF -Things 1 2 3,4\nWrite-ThingC -Things 1 2 3,4\n\n[Console]::WriteLine(\"Differs\")\nWrite-ThingF 1 2 3,4\nWrite-ThingC 1 2 3,4\n```\n\nand the output\n\n```\nSame\n  F     Length: 2       item 0: 1       item 1: 2\n  C     Length: 2       item 0: 1       item 1: 2\nDiffers\n  F     Length: 1       item 0: 1 2\n  C     Length: 2       item 0: 1       item 1: 2\nSame\n  F     Length: 2       item 0: 1       item 1: 2\n  C     Length: 2       item 0: 1       item 1: 2\nSame\n  error\n  error\nSame\n  error\n  error\nDiffers\n  F     Length: 2       item 0: 1 2     item 1: 3 4\n  error\nSame\n  error\n  error\nDiffers\n  F     Length: 3       item 0: 1       item 1: 2       item 2: 3 4\n  error\n```\n",
      "created_at": "2016-09-26T20:24:49Z",
      "updated_at": "2016-09-26T20:24:49Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@lzybkr thank you for returning back to the origins of the discussion :-)\nI expanded your example. It shows that there is no problem if the cmdlet created in the PS language, but the problem is in conjunction Add-Type C# | Import-Module\nSo if considered \"F\" and \"C1\" as expected behavior (this has been discussed previously here and in #2038), the fix should be to fix \"C\" (Add-Type C# | Import-Module). Do you agree?\n\n``` powershell\nAdd-Type -PassThru @\"\nusing System.Management.Automation;\n\n[Cmdlet(\"Write\", \"ThingC\")]\npublic class WriteThingCommand : PSCmdlet {\n    [Parameter(Mandatory = true, Position = 0, ValueFromRemainingArguments = true)] public string[] Things { get; set; }\n\n    override protected void ProcessRecord() {\n        var sb = new System.Text.StringBuilder();\n        sb.AppendFormat(\"  C `tLength: {0}\", Things.Length);\n        for (var i = 0; i < Things.Length; i++) {\n            var t = new PSObject(Things[i]);\n            sb.AppendFormat(\"`titem {0}: {1}\", i, t.ToString());\n        }\n        System.Console.WriteLine(sb.ToString());\n    }\n}\n\"@ | Select -First 1 | % { Import-Module -Assembly $_.Assembly -Force }\n\nfunction Write-ThingC1 {\n    [CmdletBinding()]\n    param([Parameter(Position = 0, ValueFromRemainingArguments, Mandatory)][string[]]$Things)\n    process {\n        $sb = [System.Text.StringBuilder]::new()\n        $null = $sb.AppendFormat(\"  C1`tLength: {0}\", $Things.Length)\n        for ($i = 0; $i -lt $Things.Length; $i++) {\n            $null = $sb.AppendFormat(\"`titem {0}: {1}\", $i, [string]$Things[$i])\n        }\n        [Console]::WriteLine($sb.ToString())\n    }\n}\n\n\nfunction Write-ThingF {\n    param([Parameter(Position = 0, ValueFromRemainingArguments, Mandatory)][string[]]$Things)\n    process {\n        $sb = [System.Text.StringBuilder]::new()\n        $null = $sb.AppendFormat(\"  F `tLength: {0}\", $Things.Length)\n        for ($i = 0; $i -lt $Things.Length; $i++) {\n            $null = $sb.AppendFormat(\"`titem {0}: {1}\", $i, [string]$Things[$i])\n        }\n        [Console]::WriteLine($sb.ToString())\n    }\n}\n\ntrap { [Console]::WriteLine(\"  error\"); continue }\n\n[Console]::WriteLine(\"Same: 1,2\")\nWrite-ThingF -Things 1,2\nWrite-ThingC -Things 1,2\nWrite-ThingC1 -Things 1,2\n\n[Console]::WriteLine(\"Differs: 1,2\")\nWrite-ThingF 1,2\nWrite-ThingC 1,2\nWrite-ThingC1 1,2\n\n[Console]::WriteLine(\"Same: 1 2\")\nWrite-ThingF 1 2\nWrite-ThingC 1 2\nWrite-ThingC1 1 2\n\n[Console]::WriteLine(\"Same: 1 2\")\nWrite-ThingF -Things 1 2\nWrite-ThingC -Things 1 2\nWrite-ThingC1 -Things 1 2\n\n[Console]::WriteLine(\"Same: 1,2 3,4\")\nWrite-ThingF -Things 1,2 3,4\nWrite-ThingC -Things 1,2 3,4\nWrite-ThingC1 -Things 1,2 3,4\n\n[Console]::WriteLine(\"Differs: 1,2 3,4\")\nWrite-ThingF 1,2 3,4\nWrite-ThingC 1,2 3,4\nWrite-ThingC1 1,2 3,4\n\n[Console]::WriteLine(\"Same: 1 2 3,4\")\nWrite-ThingF -Things 1 2 3,4\nWrite-ThingC -Things 1 2 3,4\nWrite-ThingC1 -Things 1 2 3,4\n\n[Console]::WriteLine(\"Differs: 1 2 3,4\")\nWrite-ThingF 1 2 3,4\nWrite-ThingC 1 2 3,4\nWrite-ThingC1 1 2 3,4\n```\n\nand the output:\n\n```\nSame: 1,2\n  F     Length: 2   item 0: 1   item 1: 2\n  C     Length: 2   item 0: 1   item 1: 2\n  C1    Length: 2   item 0: 1   item 1: 2\nDiffers: 1,2\n  F     Length: 1   item 0: 1 2\n  C     Length: 2   item 0: 1   item 1: 2\n  C1    Length: 1   item 0: 1 2\nSame: 1 2\n  F     Length: 2   item 0: 1   item 1: 2\n  C     Length: 2   item 0: 1   item 1: 2\n  C1    Length: 2   item 0: 1   item 1: 2\nSame: 1 2\n  error\n  error\n  error\nSame: 1,2 3,4\n  error\n  error\n  error\nDiffers: 1,2 3,4\n  F     Length: 2   item 0: 1 2 item 1: 3 4\n  error\n  C1    Length: 2   item 0: 1 2 item 1: 3 4\nSame: 1 2 3,4\n  error\n  error\n  error\nDiffers: 1 2 3,4\n  F     Length: 3   item 0: 1   item 1: 2   item 2: 3 4\n  error\n  C1    Length: 3   item 0: 1   item 1: 2   item 2: 3 4\n```\n",
      "created_at": "2016-09-27T05:10:54Z",
      "updated_at": "2016-09-27T23:28:07Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "Your `Write-ThingC1` is exactly equivalent to my `Write-ThingF` - `[CmdletBinding()]` is implied by the use of the `[Parameter()]`.\n\nTo decide which behavior is correct, we need to understand the parameter binding algorithm. You can find the code [here](https://github.com/PowerShell/PowerShell/blob/master/src/System.Management.Automation/engine/CmdletParameterBinderController.cs#L213).\n\nRoughly speaking, the algorithm is:\n1. Bind named arguments\n2. Bind positional arguments ignoring the ValueFromRemainingArguments parameter\n3. Bind remaining arguments to `ValueFromRemainingArguments` parameter if any\n\nSo binding remaining arguments is a distinct step in the algorithm, expectations regarding binding positional arguments don't _necessarily_ apply.\n\nWe should probably consider how C# implements `params`. In C#, if the only argument starting the params` arguments is an array of the correct type, then C# will not create a new array to wrap the argument, otherwise C# expects 0 or more arguments of the array element type. C# does not convert the arguments like PowerShell would though.\n\nI think this makes intuitive sense, but it gets a little messy in PowerShell because of how freely we convert values including arrays. But lets just assume that PowerShell should work like C#. If there is a single unbound parameter to bind to the `ValueFromRemainingArguments` and that argument is a collection, it seems like PowerShell should convert the elements of the collection to the expected element type of the parameter.\n\nI realize that's a lot of words and might not be clear, so I'm suggesting that the correct behavior is what happens in the `Write-ThingC` case above - calling the binary cmdlet.\n\nNote that based on his PR, @dlwyatt came to the same conclusion. His PR looks good to me, so there's just the concern about potential breakage.\n",
      "created_at": "2016-09-28T22:24:01Z",
      "updated_at": "2016-09-28T22:24:01Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@lzybkr Thanks for a lot of words! :blush: This is very useful for me!\n\nI suspect that the root of the issue is the C# developer's view. :blush:\nWhat about PHP? Fortran? Fort? PDP11 ASM?\nAnd we need to look exclusively from the perspective of Powershell script writers experience.\n\nIn short, the issue is - a,b,c is one item or three?\n\n**In terms of Powershell formal syntax this is uniquely a single element.**\na,b,c - is a array regardless of where it resides.\n\nFrom PR #2038 Jeffrey Snover said:\n\n> the parser views this as 1 parameter - an array with 3 values\n\nand\n\n> That seems like a bad thing because cmdlets with positional parameters are, and need to be, precise.\n> So a change like this would yield a unpredictable UX.\n\nThus the issue is a question about cosmetic change. \nBut what we get as a result? Performance? No. Simplicity? No. Better UX? No.\nPowershell scripts writers use the current logic last 10 years as intuitive and \"As is\".\n\nSo we only get breaking change and the collapse of an indefinite number of scripts. Community will damn us :smile:\n\nI can't approve still this change.\n",
      "created_at": "2016-09-29T10:08:26Z",
      "updated_at": "2016-09-29T10:08:26Z"
    },
    {
      "author": "dlwyatt",
      "author_association": "CONTRIBUTOR",
      "body": "> In terms of Powershell formal syntax this is uniquely a single element.\n> a,b,c - is a array regardless of where it resides.\n\nNo, it's not, and that's where the confusion lies.  If you pass `a,b,c` to a parameter that's defined as an array type, then the parameter will be an array with 3 elements, _not_ an array containing one element which happens to be another array.\n\nThe best example I can give for this is the -ArgumentList parameter of New-Object.  It's an `[Object[]]` type, because New-Object can't know ahead of time what type of arguments the object's constructors might expect.  Most of the time, this isn't a problem, _except_ when the constructor expects a single argument that is itself an array.  For example, the `[ipaddress]` class lets you pass in an array of bytes:\n\n``` posh\n# This will fail:\n\nNew-Object -TypeName ipaddress -ArgumentList 1,2,3,4\n```\n\nIf you want to pass in the 4-element array as a single argument to a constructor, you use the leading unary comma (with some parentheses to make sure the parser knows what's going on):\n\n``` posh\nNew-Object -TypeName ipaddress -ArgumentList (,(1,2,3,4))\n```\n\nThat's how it has always worked for any parameter that does _not_ include the buggy ValueFromRemainingArguments attribute.\n",
      "created_at": "2016-09-29T11:30:59Z",
      "updated_at": "2016-09-29T11:30:59Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I speak from the position of script writer: when I see a,b,c - it is an array. Because the comma is the array constructor. Further there are nuances...\n\nAnd I agree that the different behavior of func and cmdlet is bad.\n\nAnd do we have a complete set of tests to understand what will be broken by the change?\n",
      "created_at": "2016-09-29T14:45:43Z",
      "updated_at": "2016-09-29T14:45:43Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee reviewed this and agree having consistency in script and c# is the right thing as well getting an array instead of a string\n",
      "created_at": "2016-11-02T23:39:29Z",
      "updated_at": "2016-11-02T23:39:29Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "@PowerShell/powershell-maintainers given that this is a breaking change that we want to take, we should try to figure out what it takes to get @dlwyatt 's PR at #2038 merged. I know it's very stale at this point, but  it would be useful, and we should deal with it or decide we're not going to take it. \r\n\r\n@dlwyatt: if you're not up for doing a rebase against the next 9 months of code, please check the \"Allow edits from maintainers\" box on the PR (might need to close and reopen or something like that), so that we can come and give it a shot (I might end up doing this myself, but I think it would be a useful exercise).  ",
      "created_at": "2017-05-25T17:21:28Z",
      "updated_at": "2017-05-25T17:21:28Z"
    },
    {
      "author": "dlwyatt",
      "author_association": "CONTRIBUTOR",
      "body": "No problem, I'll rebase.",
      "created_at": "2017-05-25T18:23:23Z",
      "updated_at": "2017-05-25T18:23:23Z"
    },
    {
      "author": "dlwyatt",
      "author_association": "CONTRIBUTOR",
      "body": "What a non-event that was.  No merge conflicts.  :)",
      "created_at": "2017-05-25T18:25:22Z",
      "updated_at": "2017-05-25T18:25:22Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I am very late to this party, but let me offer the following perspective:\r\n\r\n* I think everyone agrees that it is important that both cmdlets and advanced functions exhibit the same behavior.\r\n\r\n* I think that it is the _advanced functions_' current behavior that should be standardized.\r\n\r\nThe `ValueFromRemainingArguments` attribute is an _anomaly_ in the realm of PowerShell parameter parsing:\r\nAs the _plural_ in the name suggests, it _implicitly_ pertains to _multiple_ arguments at once - unlike any other parameter.\r\n\r\nTherefore, the following dichotomy makes sense to me:\r\n\r\n* If you opt into _regular_  PowerShell parsing - by way of using an _explicit parameter name_ on invocation, you _must_ use an _array_ to bind all remaining (not bound by regular parameters) arguments.\r\n(The fact that such arguments are currently collected as `[List[object]]` instances rather than as regular arrays is an - unfortunate - implementation detail that should be reconsidered  - see #4625).\r\n\r\n* Otherwise, _by omission of the parameter name_, you _implicitly opt into the anomaly_, which means that _multiple, separate_ arguments _implicitly_ bind to such a parameter as collection elements - whether these individual arguments happen to be arrays themselves or not.\r\n\r\n   * Remember that an important use of `ValueFromRemainingArguments` is to enable scripts that are called from _outside_ of PowerShell (via `-File`) to receive _arrays_ - which cannot be done any other way and _requires_ that the parameter name be _omitted_.\r\n\r\nIn other words, the following equivalence make sense to me:\r\n\r\n\r\n```powershell\r\n# Define a function with an unconstrained ValueFromRemainingArguments attribute\r\n# that outputs the count of arguments bound.\r\nFunction Foo { param([Parameter(ValueFromRemainingArguments)] $Rest) $Rest.Count }\r\n```\r\n\r\n* Pass multiple arguments:\r\n\r\n```powershell\r\n# Use positional arguments that are *individually* bound to $Rest.\r\n> Foo a b\r\n2\r\n\r\n# Do the same by using -Rest explicitly, which requires *array syntax*.\r\n> Foo -Rest a, b\r\n2\r\n```\r\n\r\n* Pass an array as a single argument:\r\n\r\n```powershell\r\n# Pass an array as the 1st and only argument.\r\n> Foo a, b\r\n1\r\n\r\n# Do the same via -Rest, which requires a *nested array*:\r\n> Foo -Rest (, ('a', 'b'))\r\n1\r\n```\r\n",
      "created_at": "2017-08-21T03:58:44Z",
      "updated_at": "2017-08-21T03:58:44Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Note that _one_ side of the dichotomy is already enforced consistently (both in advanced functions and compiled cmdlets):\r\n\r\n* If you use the parameter _name_, you must not specify _multiple_ arguments:\r\n\r\n```powershell\r\n# Cmdlet:\r\n# Fails, because only 'a' binds to -AdditionalChildPath, \r\n# leaving 'b' as an unrecognized extra positional argument.\r\n> Join-Path parent child -AdditionalChildPath a b\r\nJoin-Path : A positional parameter cannot be found that accepts argument 'b'\r\n...\r\n\r\n# Advanced function: ditto.\r\n> Function Foo { param([Parameter(ValueFromRemainingArguments)] $Rest) $Rest.Count }; Foo -Rest a b\r\nFoo : A positional parameter cannot be found that accepts argument 'b'.\r\n...\r\n```\r\n\r\nTo offer a **concise summary** of behavior that I think makes sense, is conceptually simple, and therefore easy to remember for users:\r\n\r\n* If you _omit the parameter name_, you may - and must - pass _multiple, individual arguments_.  \r\n (If any of these individual arguments happens to be an array, it will bind to _one_ element of the collection assigned to the parameter.)\r\n\r\n* If you _specify the parameter name_, you must pass the arguments _as an array_.\r\n\r\nThis is how advanced functions already work.\r\nNow let's make cmdlets work the same way.\r\n\r\n\r\n\r\n",
      "created_at": "2017-08-21T18:21:10Z",
      "updated_at": "2017-08-21T18:21:34Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "Close vis PR #2038",
      "created_at": "2017-10-13T01:23:16Z",
      "updated_at": "2017-10-13T01:23:16Z"
    }
  ],
  "created_at": "2016-08-23T15:51:55Z",
  "number": 2035,
  "state": "closed",
  "title": "Parameter binding problem with ValueFromRemainingArguments in PS functions",
  "updated_at": "2017-10-13T01:23:18Z"
}