{
  "_url": "https://github.com/PowerShell/PowerShell/issues/5579",
  "author": "mklement0",
  "body": "There are (at least?) 4 basic scenarios in which objects / properties end up\r\ninvisibly `[psobject]`-wrapped, which can lead to subtle\r\ndifferences in behavior:\r\n\r\nNote: By `[psobject]`-[extra-]wrapped I mean an object for which `-is [psobject]` returns `$true`.\r\n\r\n* Objects _received via the pipeline_ when processed via `$_` / `$PSItem` or an `[object]` or _untyped_ parameter - but _not_ if passed as an _argument_:\r\n\r\n```powershell\r\n###  Via the *pipeline*:\r\n# -> $true: use of $_\r\n'foo' | ForEach-Object { $_ -is [psobject] }\r\n# -> $true: use of [object]-typed parameter (or untyped)\r\n'foo' | & { param([parameter(valuefrompipeline)] [object] $foo) process { $foo -is [psobject] } }\r\n\r\n# -> $false: use of a specifically typed parameter\r\n'foo' | & { param([parameter(valuefrompipeline)] [string] $foo) process { $foo -is [psobject] } }\r\n\r\n### As an *argument*:\r\n# -> $false: untyped parameter (or [object]-typed), or any type other than [psobject]\r\n& { param($p) $p -is [psobject] } 'foo'\r\n& { param([string] $p) $p -is [psobject] } 'foo'\r\n# -> $true: only with explicit [psobject]-typing:\r\n& { param([psobject] $p) $p -is [psobject] } 'foo'\r\n```\r\n \r\n* Objects _output by a - binary - cmdlet_ - but *not* objects output by a *PowerShell* function or script or objects returned from an _expression_. (Note that the arrays that PowerShell implicitly constructs for collecting _multiple_ output objects on assignment to a variable or when a command call participates in an expression are themselves _not_ `[psobject]`-wrapped.)\r\n\r\n```powershell\r\n# -> $true: output from binary *cmdlet*\r\n(Write-Output 'foo') -is [psobject]\r\n\r\n# -> $false: output from *PowerShell code*\r\n(& { 'foo' }) -is [psobject]\r\n\r\n# -> $false: output from an expression\r\n'foo' -is [psobject]\r\n```\r\n\r\n* The value of any _calculated property_ whose value is determined via a _script block_ - but _not_ if the value is determined by a property _name_ (string):\r\n\r\n```powershell\r\n# -> $true: property value is determined by *script block*\r\n(Get-Item / | Select-Object @{ l='foo'; e={ $_.Name } }).foo -is [psobject]\r\n\r\n# -> $false: property value is determined by *name* (string)\r\n(Get-Item / | Select-Object @{ l='foo'; e='Name' }).foo -is [psobject]\r\n```\r\n\r\n* Perhaps not surprisingly, if you cast / type-constrain with `[psobject]` - for which there is no need, and in *most* scenarios this will have *no* practical implications; more surprisingly, however, the same applies to `[pscustomobject]`, given that these type accelerators are effectively _the same_ and _both_ refer to `[System.Management.Automation.PSObject]` (see #4344).\r\n\r\n```powershell\r\n# -> $true\r\n([psobject] 42) -is [psobject]\r\n\r\n# -> $true: [pscustomobject] is the same as [psobject] and \r\n#   does *not* create a custom object from arbitrary operands\r\n# (only [pscustomobject] @{ ... } works)\r\n([pscustomobject] 42) -is [psobject]\r\n```\r\n\r\n---\r\n\r\nAs for **real-world ramifications** (in addition to the difference in `Get-Member` representation - see below):\r\n\r\n* In *Windows PowerShell*, `ConvertTo-Json` is affected, as originally reported \r\nin #3153 - see below.\r\n(*PowerShell Core* is no longer affected, because that issue has been fixed\r\nvia #3231)\r\n\r\n* #5763\r\n\r\n* #14355\r\n\r\n* #14829\r\n\r\n* See #10687 [fixed in v7.0.0-preview.5]\r\n\r\n* `$_` in a `ForEach-Object` script block reflects each input object (extra-)`[psobject]`-wrapped, causing `-is [pscustomobject]` tests to become meaningless, as then _any_ input object passes the test - see [this SO question](https://stackoverflow.com/q/53268394/45375)\r\n\r\n* Passing an incidentally wrapped `[psobject]`-wrapped instance to an external serialization API such as `[Newtonsoft.Json.JsonConvert]::SerializeObject()` causes unexpected behavior - see [this SO post](https://stackoverflow.com/a/63588539/45375).\r\n\r\nNote that even non-wrapped instances in the sense above DO have ETS-defined properties (e.g., `[datetime]::now.psextended` reveals the `.DateTime` property).\r\n\r\n(While #4347 may sound related, the distinct issue there is that _additional_ properties may be added to outputs by _provider_ cmdlets.)\r\n\r\nExamples:\r\n\r\n```powershell\r\n# Two seemingly equivalent ways of constructing a [string] instance:\r\n# Using an expression vs. using a command:\r\n$o1 = 'hi'; $o2 = New-Object System.String 'hi'\r\n\r\n# Only the New-Object (*command*-generated) instance is wrapped, however.\r\n> ($o1 -is [psobject]), ($o2 -is [psobject])\r\nFalse\r\nTrue\r\n\r\n# With *multiple outputs*, *only the individual elements are wrapped*,\r\n# because the implicitly constructed array that collects the output is itself\r\n# NOT wrapped.\r\n> $arr = Write-Output 1, 2; $arr -is [psobject]; $arr[0] -is [psobject]\r\nFalse\r\nTrue\r\n\r\n# Two ways of constructing a [pscustomobject] instance\r\n# with an array-valued .foo property that is *not* wrapped\r\n# ($o2 itself, by contrast, *is* wrapped, because it is constructed with\r\n# a *conmand*).\r\n$o1 = [pscustomobject] @{ foo = 1, 2 }\r\n$o2 = New-Object pscustomobject -property @{ 'foo' = 1, 2  }\r\n\r\n# *Seemingly* equivalent ways, which, however result in a [psobject]-wrapped\r\n# .foo property.\r\n# Calculated property:\r\n$o3 = '' | Select-Object @{ l='foo'; e = { 1, 2 } }\r\n# Explicit [psobject] cast:\r\n$o4 = [pscustomobject] @{ foo = [psobject] (1, 2) }\r\n\r\n# All are instances of [System.Management.Automation.PSCustomObject]\r\n> $o1, $o2, $o3, $o4 | % GetType | % Name\r\nPSCustomObject\r\nPSCustomObject\r\nPSCustomObject\r\nPSCustomObject\r\n\r\n# All .foo properties are instances of [System.Object[]]\r\n> $o1.foo, $o2.foo, $o3.foo, $o4.foo | % GetType | % Name\r\nObject[]\r\nObject[]\r\nObject[]\r\nObject[]\r\n\r\n# However, only $o3 and $o4's .foo properties are considered [psobject] instances:\r\n> ($o1.foo -is [psobject]), ($o2.foo -is [psobject]), ($o3.foo -is [psobject]), ($o4.foo -is [psobject])\r\nFalse\r\nFalse\r\nTrue\r\nTrue\r\n\r\n# This subtle distinction can result in different behavior.\r\n# Note how Get-Member represents the properties differently.\r\n> $o1, $o3 | Get-Member foo | % Definition\r\nObject[] foo=System.Object[]\r\nSystem.Object[] foo=1 2\r\n\r\n# *Windows PowerShell* only:\r\n# Note how the JSONification of $o3 has an extraneous \"value\" wrapper for\r\n# the array and a \"Count\" property.\r\n> $o1, $o3 | ConvertTo-Json\r\n[\r\n  {\r\n      \"foo\":  [\r\n                  1,\r\n                  2\r\n              ]\r\n  },\r\n  {\r\n      \"foo\":  {\r\n                  \"value\":  [\r\n                                1,\r\n                                2\r\n                            ],\r\n                  \"Count\":  2\r\n              }\r\n  }\r\n]\r\n```\r\n\r\n\r\nEnvironment data\r\n----------------\r\n\r\nCurrent as of:\r\n\r\n```powershell\r\nPowerShell Core 7.1.0-preview.6\r\nWindows PowerShell 5.1\r\n```\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "san7hos",
      "author_association": "NONE",
      "body": "This is also observable in PS 5.1\r\n\r\n```\r\n> $PSVersionTable\r\n\r\nName                           Value\r\n----                           -----\r\nPSVersion                      5.1.17134.165\r\nPSEdition                      Desktop\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}\r\nBuildVersion                   10.0.17134.165\r\nCLRVersion                     4.0.30319.42000\r\nWSManStackVersion              3.0\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\n```\r\n```\r\nC:\\WINDOWS\\system32\r\n> $x = @(1,@(2,3),4)\r\nC:\\WINDOWS\\system32\r\n> $x | ConvertTo-Json -Compress\r\n[1,{\"value\":[2,3],\"Count\":2},4]\r\n```\r\n",
      "created_at": "2018-08-01T10:29:24Z",
      "updated_at": "2018-08-01T10:29:24Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@San7hos: That's actually a slightly different problem that _only_ affects Windows PowerShell at this point: the problem is caused by an ETS `.Count` property attached to `[System.Array]` - see [this SO answer](https://stackoverflow.com/a/38212718/45375) for details.\r\n\r\nIn your example, the nested array does _not_ have a `[psobject]` wrapper - `$x[1] -is [psobject]` yields `$False` - but it still triggers the serialization bug, because `ConvertTo-Json` sees this array as a _single object_.\r\n\r\nIn my example above, the `[psobject]` wrapper makes the difference: only if array-valued property `.foo` contains an extra-`[psobject]`-wrapped array does `ConvertTo-Json`  apply the ETS data; here's a succinct recap:\r\n\r\n```powershell\r\n# .foo as a regular array: works as expected in both PS Core and Windows PowerShell\r\nPS> [pscustomobject] @{ foo = 0, 0 } | ConvertTo-Json -Compress\r\n{\"foo\":[0,0]}   # OK\r\n\r\n# .foo being extra-[psobject]-wrapped: serialized via ETS definition for [System.Array],\r\n# which only exists in *Windows PowerShell* at this point, \r\n# so you'll only see the symptom there.\r\nPS> [pscustomobject] @{ foo = New-Object int[] 2 } | ConvertTo-Json -Compress\r\n{\"foo\":{\"value\":[0,0],\"Count\":2}}   # !! Extraneous .Count, .value properties\r\n```",
      "created_at": "2018-08-01T13:00:00Z",
      "updated_at": "2018-08-01T13:00:00Z"
    }
  ],
  "created_at": "2017-11-29T18:28:21Z",
  "labels": [
    "WG-Engine",
    "Issue-Discussion"
  ],
  "number": 5579,
  "state": "open",
  "title": "Objects are situationally invisibly [psobject]-wrapped, sometimes causing  unexpected behavior.",
  "updated_at": "2021-02-17T16:18:02Z"
}