{
  "_url": "https://github.com/PowerShell/PowerShell/issues/11677",
  "author": "skissane",
  "body": "# Summary of the new feature/enhancement\r\n\r\n`New-Item` cmdlet can be used to create an empty file. However, it gives an error if the file already exists. Sometimes, you just want to ensure the file exists \u2013 create it if it doesn't, do nothing if it does. Of course, one could do this with an `if` conditional but having just a switch to do it would make things a lot easier.\r\n\r\n(This is different from `-Force` \u2013 `-Force` replaces the existing file with an empty file, `-IfNotExists` would leave the existing file unmodified.)\r\n\r\nSometimes it is suggested that `New-Item` is equivalent to Unix `touch`. However, `touch` leaves existing files intact, `New-Item` obliterates them. If `New-Item` had an `-IfNotExists` option, it would be closer to `touch`.\r\n\r\n# Proposed technical implementation details (optional)\r\n\r\n<!-- \r\nA clear and concise description of what you want to happen.\r\nConsider providing an example PowerShell experience with expected result.\r\n-->\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I'd name the parameter -TouchFile. \"Touch\" says about expected behavior, \"File\" says that the parameter is a dynamic parameter for FileSystem provider.\r\n\r\nUpdate: -Touch \\<optional datetime>\r\n\r\n/cc @mklement0 ",
      "created_at": "2020-01-25T15:01:56Z",
      "updated_at": "2020-01-25T17:55:50Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "It's a useful thing to be able to do. \r\nCurrently you can do `if (-not (test-path $path)) {new-item $Path} `so this would make the syntax neater, rather than making impossible things possible. . \r\nIt needs to have the right behaviour for different item types. -TouchFile for files only is OK , but something more generic for directories etc. might be better.   \r\nI commonly find I write \r\n`md $path -erroraction SilentlyContinue `\r\nreally I _should_  use `try {} catch{} `and ignore \"exists\" errors , but stop for \"failed to add\" ones.  Some sort of \"Ensure-there-is \" which errors if it can't make one would make for nicer code \r\n\r\nMaking a simple powerShell function which is the equivalent of unix's `touch` on Windows would be the natural next thing to do. \r\n\r\n\r\n",
      "created_at": "2020-01-25T17:44:11Z",
      "updated_at": "2020-01-25T17:44:11Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> It needs to have the right behaviour for different item types. -TouchFile for files only is OK , but something more generic for directories etc. might be better.\r\n\r\nMakes sense.\r\nAlso I found that touch utility can accept optional timestamp.\r\nIf it will be a dynamic parameter for FileSystem provider the parameter could be `-Touch <optional datetime>`.",
      "created_at": "2020-01-25T17:54:22Z",
      "updated_at": "2020-01-25T17:54:22Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "tl;dr:\r\n\r\n* Good idea, but the switch should be named `-NoClobber` for consistency with existing switches with essentially the same purpose - this switch should _not_ modify the timestamp of an existing item.\r\n\r\n* I suggest leaving timestamp-related functionality out of `New-Item`.\r\n\r\n---\r\n\r\nThere are two independent aspects:\r\n\r\n* ensuring a file's _existence_\r\n\r\n* modifying a file's _timestamps_\r\n\r\nEven though the Unix `touch` utility combines the two aspects (in its argument-less form, it ensures the existence of the file _and_ updates the last-write timestamp if the file already exists), I don't think that's appropriate for `New-Item`, given its name and purpose.\r\n\r\nThe focus of `touch` is _timestamp functionality_, whereas `New-Item`'s is _existence_.\r\n\r\n`touch` has numerous useful options, and fundamentally the ability to target _multiple_ items, via wildcards; the best we could do with a dynamic `-Touch` parameter is to provide a limited, single-item subset of `touch`'s functionality - and I don't think that's worth it.\r\n\r\nFood for thought for a fully featured potential PowerShell implementation of the Unix `touch` utility  is in the `Touch-Item` implementation from [this Stack Overflow answer](https://stackoverflow.com/a/58756360/45375); note that I deliberately chose to go with non-standard verb `Touch`, because I couldn't come up with a succinct yet meaningful name using an approved verb.\r\n\r\n---\r\n\r\n> `md $path -erroraction SilentlyContinue`\r\n\r\nAs @skissane notes, `-Force`  _truncates_ the item if it is a _file_, but if it is a _directory_, it leaves an existing one alone (including its time stamps), hence:\r\n\r\n\r\n```powershell\r\n# Create the directory, unless it already exists.\r\n# Note: on Unix-like platforms 'md' and 'mkdir' refer to the Unix mkdir utility, \r\n# not New-Item.\r\nNew-Item -Type Directory -Force $path\r\n```\r\n\r\nThis asymmetry of the `-Force` behavior is unfortunate, but were's stuck with it.\r\n\r\nTherefore, for directories the new `-NoClobber` switch would have to have the same effect as `-Force`, ~~and would arguably be the better switch to use going forward, to better signal the intent.~~ - [see below](https://github.com/PowerShell/PowerShell/issues/11677#issuecomment-578534003).\r\n\r\n",
      "created_at": "2020-01-25T19:15:57Z",
      "updated_at": "2020-09-04T14:01:36Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "What about adding an `Update-Item` that works like `touch`?",
      "created_at": "2020-01-25T20:57:05Z",
      "updated_at": "2020-01-25T20:57:05Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "`Update` sounds like a good choice for the verb, but `Item` is too vague, I think: the cmdlet wouldn't be updating the _item itself_, but _a piece of associated metadata_.\r\n\r\nPerhaps `Update-ItemTimestamp`? Or just `Update-Timestamp`?\r\n\r\nA compliant alias name for it would be `udts` (`ud` being the official alias name for the `Update` verb).\r\n\r\nRe the term \"Item\": It suggests support for all providers, which I don't think we need or perhaps even can aim for; unfortunately, there is no better umbrella term for \"file or folder\" I can think of.",
      "created_at": "2020-01-25T21:11:52Z",
      "updated_at": "2020-01-25T21:11:52Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Update-Path",
      "created_at": "2020-01-26T11:42:19Z",
      "updated_at": "2020-01-26T11:42:19Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> Perhaps `Update-ItemTimestamp`? Or just `Update-Timestamp`?\r\n\r\nThat makes most sense. \r\n\r\nBack to the original question, I'm not sure how often we need to create an empty file, one can do \r\n$null  | Add-Content $path  which does nothing to the file if it exists (doesn't change the date stamp) but creates a zero byte file if there is none. \r\n\r\n> * Good idea, but the switch should be named `-NoClobber` for consistency with existing switches with essentially the same purpose - this switch should _not_ modify the timestamp of an existing item\r\n\r\nNew-item already seems to have `-NoClobber` by default   `-Force` to overcome that deletes the file and creates a new one. Doing append rather than create seems to be the answer for files but for directories or other containers that doesn't make sense.  \r\n\r\nWhat's best depends on whether the aim is to fix general cases and have a switch which does \"Ignore 'already exists' errors\" or give something very similar to touch for files. \r\n",
      "created_at": "2020-01-26T13:09:40Z",
      "updated_at": "2020-01-26T13:09:40Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> `Update` sounds like a good choice for the verb, but `Item` is too vague, I think: the cmdlet wouldn't be updating the _item itself_, but _a piece of associated metadata_.\r\n> (...)\r\n> Re the term \"Item\": It suggests support for all providers, which I don't think we need or perhaps even can aim for; unfortunately, there is no better umbrella term for \"file or folder\" I can think of.\r\n\r\nWell, I think it would be up to the provider to determine what updating an item means.  For example, lets say you have a cache provider (I think UD has one?), update item could refresh the cache expiration.  Registry also has a lastwritetime iirc (I know one is recorded somewhere, can't remember if it's surfaced in the dotnet API).\r\n\r\nThink of it like `Invoke-Item`.  Plenty of providers do not implement an `Invoke`, but the cmdlet still makes sense.",
      "created_at": "2020-01-26T13:23:15Z",
      "updated_at": "2020-01-26T13:23:33Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> Well, I think it would be up to the provider to determine what updating an item means.\r\n\r\nGood point; what I was thinking of is updating an item's _content_, for which we do have the noun _Content_, such as in `Set-Content`.\r\n\r\nIf we can come up with a generic `Update-Item` implementation that meaningfully works for multiple providers, I won't complain, but I wonder if that would become too generic / hard to discover, because the term _timestamp_ would then be in the _parameter_ names.\r\n\r\nAlso, such a cross-provider cmdlet would have to have to implement parts of the `touch`-specific functionality via dynamic, filesystem-provider-specific parameters (last-access vs. last-write timestamp, treatment of symbolic links).\r\n\r\nBut it sounds like at this point we should create a new issue focused on implementing `touch` functionality in a separate cmdlet, and keep this issue focused on the `-NoClobber` aspect.\r\n\r\n\r\n\r\n",
      "created_at": "2020-01-26T18:17:03Z",
      "updated_at": "2020-01-26T18:17:57Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> `$null | Add-Content $path` which does nothing to the file if it exists (doesn't change the date stamp)\r\n\r\nThat's a neat _workaround_, but far from obvious; I do think there is value in implementing _desired-state logic_ in this case (and in general): \"Do what is necessary to make sure that this file exists - whether it's already there or whether you have to create it\".\r\n\r\nHowever, one case I hadn't considered before: if `-Value` is _also_ specified, `-NoClobber` should cause a statement-terminating error, as the two parameters conflict conceptually, given that `New-Item` - by design - when given a `-Value`  - either truncates and fills or creates and fills, leaving only the specified `-Value` in the file (it shouldn't _append_; for that, we have `Add-Content`, which also creates the file on demand).\r\n\r\nAs an aside: specifying a `-Value` when creating a _directory_ - which arguably shouldn't be prevented _syntactically_ - is currently quietly ignored.\r\n\r\n>  deletes the file and creates a new one. \r\n\r\nActually, it _truncates the existing file_ instead, which is not the same, because truncating preserves the file creation date, permissions, ownership, ...\r\n\r\nYou could argue that `-Force` should indeed delete and re-create, but truncating is the current behavior.\r\n\r\nAs for `-NoClobber` vs. `-Force`:\r\n\r\nI hadn't consider that `-Force` has _another_ implication:\r\n\r\nIt creates _parent directories on demand_, so that you can use `New-Item -Force noSuchSubDirYet/newFile` and `New-Item -Force noSuchSubDirYet/another/newDir`.\r\n\r\nI we say that `-NoClobber`  means _only_: \"leave an existing item alone, (do not also create parent directories on demand)\", then adding `-Force` would be needed to ask for the latter, so that we get the following combinations:\r\n\r\nswitch(es) \u2192  / item type \u2193  | `-NoClobber` | `-Force` | `-NoClobber -Force`\r\n--------- | ------------ | ------- | ---------\r\nFile           | if file exists, leave it alone, except fail if `-Value` is also specified; if parent path doesn't exist, fail | (current behavior) create parent path on demand; truncate file, if it exists  | if file exists, leave it alone (except if `-Value` is also specified); create parent path on demand\r\nDirectory | if directory exists, leave it alone; if parent path doesn't exist, fail | (current behavior) if directory exists, leave it alone; if parent path doesn't exist, create it  | same as `-Force` alone\r\n\r\nNote that a slight inconsistency with respect to parameter name `-NoClobber` is that in the existing uses it usually results in an _error_ when the target file already exists, but, given the commonality of leaving an existing target untouched, I think it's still the right name.",
      "created_at": "2020-01-26T19:23:13Z",
      "updated_at": "2020-01-26T19:23:13Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "P.S., @iSazonov:\r\n\r\n> Update-Path\r\n\r\nIn PowerShell, a _path_ is an _address_ of sorts that locates a provider _item_, as reflected in parameters `-Path` and `-LiteralPath`, so I don't think that's the way to go; it also has echoes of `$env:PATH`. \"FileSystemItem\" instead of \"Item\" would capture \"file or directory\", but that's too wordy.",
      "created_at": "2020-01-26T19:29:19Z",
      "updated_at": "2020-01-26T19:29:19Z"
    },
    {
      "author": "ThomasNieto",
      "author_association": "CONTRIBUTOR",
      "body": "I don't think a new cmdlet is needed to update the modified date time. `Set-ItemProperty` cmdlet can update `LastWriteTime`, `LastAccessTime`, `CreationTime`  properties of a file.\r\n\r\n```powershell\r\nC:\\> Get-ItemProperty C:\\temp\\abc.psd1 -Name lastwritetime\r\n\r\nlastwritetime : 1/6/2020 11:22:09 PM\r\nPSPath        : Microsoft.PowerShell.Core\\FileSystem::C:\\temp\\abc.psd1\r\nPSParentPath  : Microsoft.PowerShell.Core\\FileSystem::C:\\temp\r\nPSChildName   : abc.psd1\r\nPSDrive       : C\r\nPSProvider    : Microsoft.PowerShell.Core\\FileSystem\r\n\r\n\r\nC:\\> Set-ItemProperty C:\\temp\\abc.psd1 -Name lastwritetime -Value (Get-Date)\r\nC:\\> Get-ItemProperty C:\\temp\\abc.psd1 -Name lastwritetime\r\n\r\nlastwritetime : 1/26/2020 2:32:33 PM\r\nPSPath        : Microsoft.PowerShell.Core\\FileSystem::C:\\temp\\abc.psd1\r\nPSParentPath  : Microsoft.PowerShell.Core\\FileSystem::C:\\temp\r\nPSChildName   : abc.psd1\r\nPSDrive       : C\r\nPSProvider    : Microsoft.PowerShell.Core\\FileSystem\r\n\r\n\r\nC:\\> Set-ItemProperty C:\\temp\\abc.psd1 -Name lastwritetime -Value (Get-Date).AddDays(-10)\r\nC:\\> Get-ItemProperty C:\\temp\\abc.psd1 -Name lastwritetime\r\n\r\nlastwritetime : 1/16/2020 2:33:05 PM\r\nPSPath        : Microsoft.PowerShell.Core\\FileSystem::C:\\temp\\abc.psd1\r\nPSParentPath  : Microsoft.PowerShell.Core\\FileSystem::C:\\temp\r\nPSChildName   : abc.psd1\r\nPSDrive       : C\r\nPSProvider    : Microsoft.PowerShell.Core\\FileSystem\r\n```",
      "created_at": "2020-01-26T20:38:27Z",
      "updated_at": "2020-01-26T20:46:04Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Excellent point, @ThomasNieto  - I completely forgot about `Set-ItemProperty`, because I rarely use it - but it effectively is the embodiment of what we discussed as an all-providers `Update-Item`.\r\n\r\nThis gives us most of what `touch` can do, except:\r\n\r\n* file creation on demand\r\n\r\n* being able to distinguish between modifying the properties of a symlink's _target_ and the _link itself_.\r\n\r\nArguably:\r\n\r\n* the former can be covered simply by having to call `New-Item [-NoClobber]` first.\r\n\r\n* the latter should be added as a dynamic filesystem-provider parameter to `Set-ItemProperty`, such as `-ModifyLink` (default would be to modify the link's _target_).\r\n\r\nGiven `Set-ItemProperty`'s support for positional arguments and using its built-in alias `sp`, concise commands are possible in interactive use; e.g., the following sets the last-write date of all `*.txt` files in the current directory to the start of yesterday:\r\n\r\n```powershell\r\nsp *.txt LastWriteTime (Get-Date).Date.AddDays(-1)\r\n```\r\n\r\nIn short: I'm no longer convinced we need a separate `touch`-like cmdlet.\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2020-01-26T21:10:34Z",
      "updated_at": "2021-05-24T14:43:28Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Let me offer a pragmatic solution, which is easy to implement _as a custom solution_ now, also in Windows PowerShell, using either an available `touch` utility or an emulation of it (with the same basis syntax).\r\n\r\nOn Unix, the `touch` utility is automatically available, so no action is required - just call it directly.\r\n\r\nOn Windows, there are two options, which you could place in your `$PROFILE`:\r\n\r\n* On machines that have WSL installed, you can wrap a Unix distro's `touch` utility as follows:\r\n  * `function touch { wsl touch $args }`\r\n\r\n* On other machines, you can use the function below, which emulates the _core_ functionality of the `touch` utility (no options supported) [_Update_: A more fully-featured `Touch-File` function can be found in [this Gist](https://gist.github.com/mklement0/82ed8e73bb1d17c5ff7b57d958db2872)].\r\n\r\n<details><summary>Custom \"touch\" function</summary>\r\n\r\n```powershell\r\n# Define the `touch` function only if a `touch` utility isn't present (it always is on Unix).\r\nif (-not (Get-Command -Type Application touch -ea Ignore)) {\r\n  function touch {\r\n    <#\r\n    .SYNOPSIS\r\n    Emulates the Unix touch utility.\r\n    \r\n    .DESCRIPTION\r\n    On Windows, emulates the core functionality (only) of \r\n    the Unix touch utility; examples:\r\n\r\n    touch new1.txt new2.txt\r\n\r\n      Creates said files as empty files in the current dir., if \r\n      files by that name don't yet exist yet; otherwise sets their\r\n      LastWriteTime to now. Note the use of spaces (only) to\r\n      separate multiple file names.\r\n\r\n    touch *.txt\r\n\r\n      Sets the LastWriteTime of all matching files, if any, to now.\r\n\r\n    Note:\r\n     * No parameter (names) other than -? are supported; all other\r\n       arguments are interpreted as file names. \r\n     * If you have WSL installed, you can alternatively call\r\n       `wsl touch ...`, which provides access to all features of the\r\n        Unix utility.            \r\n    #>\r\n\r\n    # As a courtesy, interpret -h, --help or the absence of arguments the same as -?\r\n    if (-not $args -or $args[0] -in '-h', '--help') { return touch -? }\r\n\r\n    # Get any existing files...\r\n    $item = Get-Item -ea SilentlyContinue -ErrorVariable errs -Path $args\r\n    if ($item) { \r\n      # ... and update their timestamps.\r\n      Write-Verbose \"Setting LastWriteTime timestamps to now for: $item\"\r\n      $item.ForEach('LastWriteTime', [datetime]::now)\r\n    }\r\n    # Create any files that couldn't be found.\r\n    $errs | ForEach-Object {\r\n      if ($_.Exception -is [System.Management.Automation.ItemNotFoundException]) {\r\n        Write-Verbose \"Creating file: $_.TargetObject\"\r\n        $null = New-Item -Type File -Path $_.TargetObject\r\n      }\r\n      else {\r\n        # Unexpected error, pass it through.\r\n        $_ | Write-Error\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</details>\r\n",
      "created_at": "2020-09-04T22:55:54Z",
      "updated_at": "2021-05-24T14:47:16Z"
    },
    {
      "author": "mukundshah",
      "author_association": "NONE",
      "body": "Please add a default alias `touch->New-Item`. \r\nDoesn't matter how differently they work.\r\nIf I'm a Linux user and use someone's Windows PC, then I am not going to waste my 30 minutes looking for the equivalent command. I will just type touch and it should work; No throw some \"Command not found\" error. Doesn't matter what it does, but it should do something, except throwing \"Command not found\". And if it ain't working, I'm never touching PowerShell, doesn't matter what platform it is.\r\n",
      "created_at": "2021-09-01T05:02:44Z",
      "updated_at": "2021-09-01T05:02:44Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> Please add a default alias `touch->New-Item`.\r\n> Doesn't matter how differently they work.\r\n> If I'm a Linux user and use someone's Windows PC, then I am not going to waste my 30 minutes looking for the equivalent command. I will just type touch and it should work; No throw some \"Command not found\" error. Doesn't matter what it does, but it should do something, except throwing \"Command not found\". And if it ain't working, I'm never touching PowerShell, doesn't matter what platform it is.\r\n\r\nAny shell you run on windows is going throw `command not found`, touch is a unix/linux executable not found in Windows. \r\nTouch works in pwsh on linux because the utility is there.  \r\n\r\n What you're saying here is if PowerShell fill in unix commands which aren't part of windows you won't use it where the commands are present. And if doesn't get you any nearer to knowing what commands you do need on windows. \r\n\r\nThat said,  there are some unix style aliases added to PowerShell on Windows, and `touch` would be easy to add.   It might be better as a feature request \r\nin its own right. \r\n",
      "created_at": "2021-09-01T10:26:05Z",
      "updated_at": "2021-09-01T10:26:05Z"
    },
    {
      "author": "mukundshah",
      "author_association": "NONE",
      "body": "> That said, there are some unix style aliases added to PowerShell on Windows, and `touch` would be easy to add. It might be better as a feature request in its own right.\r\n\r\nI don't know know how you interpreted my comment. I, myself, might have sounded rude and stupid.\r\n\r\nHowever, having an alias for `touch`, out of the box, like other commands, will be a great thing to do.\r\n\r\n> doesn't get you any nearer to knowing what commands you do need on windows.\r\n\r\nWe can flag the default alias, and when they are run for the first time, we can prompt the user with a line saying _Hey, `touch` is alias set for `New-Item`. You can instead use `New-Item` or other aliases if there is any._\r\n",
      "created_at": "2021-09-01T10:37:54Z",
      "updated_at": "2021-09-01T10:38:32Z"
    },
    {
      "author": "doctordns",
      "author_association": "COLLABORATOR",
      "body": "My view is to NOT define a built-in alias of Touch. That might well confuse users, especially on Linux. I promise you, if this were done, there would be support issues. \r\n\r\nIF the alias is useful for you, then you can add it to your profile. ",
      "created_at": "2021-09-01T11:21:14Z",
      "updated_at": "2021-09-01T11:21:14Z"
    },
    {
      "author": "mukundshah",
      "author_association": "NONE",
      "body": "can't we just do that for windows??",
      "created_at": "2021-09-01T11:23:00Z",
      "updated_at": "2021-09-01T11:23:00Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> > That said, there are some unix style aliases added to PowerShell on Windows, and `touch` would be easy to add. It might be better as a feature request in its own right.\r\n> \r\n> However, having an alias for `touch`, out of the box, like other commands, will be a great thing to do.\r\n\r\nAnyone who has had a frustrating experience looking for something missing will think that :-) \r\n\r\n\r\n\r\n> My view is to NOT define a built-in alias of Touch. That might well confuse users, especially on Linux. I promise you, if this were done, there would be support issues.\r\n\r\nI'm not sure. ls and ps as aliases are OK (and in Windows pwsh only).  diff going to compare object is still in 7.1 on Windows.\r\nIn 5.1 curl was aliased to invoke-webrequest which was considered harmful. I think touch is probably closer to the ls/ps than iwr, so relatively harmless. \r\n\r\n\r\n",
      "created_at": "2021-09-01T12:18:56Z",
      "updated_at": "2021-09-01T12:18:56Z"
    },
    {
      "author": "doctordns",
      "author_association": "COLLABORATOR",
      "body": "To some degree, those aliases were added to PowerShell 1.0 to help with early adoption. I am not sure they were ever designed in light of a Linux implementation of PowerShell.  ",
      "created_at": "2021-09-01T12:31:25Z",
      "updated_at": "2021-09-01T12:31:25Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> To some degree, those aliases were added to PowerShell 1.0 to help with early adoption. I am not sure they were ever designed in light of a Linux implementation of PowerShell.\r\n\r\nI think there is a \"helping muscle memory\" argument - one can make 3 or 4 groups of aliases\r\n\r\n1.  I've been using `type` to get file content since 1980-something and PowerShell hasn't forced me to change and use `gc` and someone who has been using `cat` on unix gets the same support. And it works the way either category of user expects.\r\n2.  Command.com and cmd.exe never had `pwd` but it's not harmful to have `pwd`  aliased to `Get-Location` , although the output _looks different_.  `ls` and `ps`  look different - they're _functionally close enough_  but unix switches will sometimes cause a failure,\r\n3. Something like `kill` isn't quite the same (`kill -9 1234` fails so using unix parameters fails most of the time ) but it seems to pass the _functionally close enough_ test\r\n4.  Aliasing `curl` to `invoke-webrequest` will fail in a lot of use cases it isn't _functionally close enough_ so having been in windows powershell but got pulled in pwsh 6. \r\n\r\nGroup 4 are things that do more harm than good. \"Hey let's alias `grep` to `select-string`\"  goes in that box. What about `ifconfig` to `ipconfig.exe` ? that's in group 2 or 3, but \"You do it a different way on windows\" is valid. \r\nWe've managed without `touch` for all this time but it's really in group 1 or 2.  It wouldn't take much to create it as a function on windows. \r\n```\r\nif (test-path $path)  {\r\nSet-ItemProperty -Path $Path -Name  LastWriteTime -Value (get-date)\r\n}\r\nelse {new-item path} \r\n```\r\nit probably needs pipeline support, and only output with `-passthru ` because (IIRC) unix seems to have an invisible touch. \r\n \r\n",
      "created_at": "2021-09-02T09:25:55Z",
      "updated_at": "2021-09-02T09:25:55Z"
    },
    {
      "author": "mukundshah",
      "author_association": "NONE",
      "body": "> To some degree, those aliases were added to PowerShell 1.0 to help with early adoption. I am not sure they were ever designed in light of a Linux implementation of PowerShell.\r\n\r\nDon't you think these all commands should be as uniform as possible, irrespective of what platform we're using?\r\nLike we have with copy, cut, paste, save, undo, select all, etc.\r\nMac being the exception, these functions have the same shortcut keys Ctrl + C, X, V, S, Z, A.\r\nmacOS just uses Cmd instead of Ctrl. But that's easy to figure out.\r\nWhat about the CLI commands? Why they can't be **similar**?\r\n",
      "created_at": "2021-09-04T13:00:31Z",
      "updated_at": "2021-09-04T13:04:57Z"
    },
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "> > To some degree, those aliases were added to PowerShell 1.0 to help with early adoption. I am not sure they were ever designed in light of a Linux implementation of PowerShell.\r\n> \r\n> Don't you think these all commands should be as uniform as possible, irrespective of what platform we're using?\r\n> Like we have with copy, cut, paste, save, undo, select all, etc.\r\n\r\n\r\nCtrl C X V and Z didn't always have those meanings, [Shift] [Insert], is still Paste, [Ctrl] [Insert] is still Copy and [shift] [delete]  is still paste.  If there is an edit menu [Alt] [E] will always open it and C is always copy,  T cut and P paste.  \r\nBTW X is \"cut\" because it looks like scissors , V is arrow pointing down for Insert (paste) and if you put an arrow head on a Z shape that looks like \"go back\"  Which is why we don't have ctrl U for undo and ctrl P is usually print not paste\r\n\r\nExcept ctrl + c  does something different in a windows and unix shell ...   You'd think, say, Microsoft office (which introduced these in the early 1990s, they weren't OS standards originally)  would use a fairly well understood control F for find, it works in notepad, internet explorer, edge, vs code, Word, Excel but it's _forward_ in Outlook.  [window key] [f] is \"feed back\" (Why?!) [s] for search. [Esc] is 'get out of here without saving' , except in Visio...  \r\n\r\n\r\n> What about the CLI commands? Why they can't be **similar**?\r\n\r\nWell...  you need to go back to the early designers of command.com and ask why, if they had taken < > and | from unix  so weren't _just_  a port of cp/m why they didn't use / for the path support `ls` and `rm`  as well as `dir` and `del`.  Or why `FIND` is totally different in command.com (and its successor cmd.exe) from unix. etc.     \r\nSomeone should have got the people implementing DOS / Windows IP stacks and Unix ones together and \"banged heads\" until they agreed whether the tool should be IPCONFIG or IFConfig ...   \r\nIn 1969 when the working practices for C and its derivatives (including unix) were set, CPU cycles were too precious to flatten case so everything was (and remains) case sensitive. CP/M , DOS and Windows saw the world as upper case and converted lower to upper.    \r\n\r\n**Some things are going to be different.** \r\n\r\n**Windows** PowerShell was designed as a replacement for cmd.exe , with long verb-noun command names which no-one really wants to type at the command line - hence `Get-Content` has aliases `content` , `gc`, `type` and `cat`.   People like Bruce Payette and Jason Shirk do occasionally comment here one on how some of those early decisions were arrived but basically it seemed like good idea at the time to have `cat`, `ls`, `ps`  and  `sort`  but no one spoke up for `touch` and others. \r\n\r\n**Cross platform** PowerShell hits a problem: if I say \"paste `dir | sort lastwritetime` into PowerShell\" it works in any Windows version `sort` is a default alias - for `sort-object`, and it sorts by that property.  But pwsh on linux  doesn't create that alias by default (it can be added) so it runs linux's native `sort` and the command fails.  If it were being designed today we probably wouldn't have sort as an alias trumping Windows' sort.exe. PowerShell _prefers_ working as the user of another shell on that OS would expect rather than imposing \"one true way\" on every OS, but it's not a strong preference ...  If you're on an OS with a `touch` command you get `touch` whether you're in powershell or not, and if your on an OS without - you don't.  \r\n\r\nYou're right that PowerShell can help people moving between OSes by bring windows-like commands to linux and linux-like commands to linux.  That's not its focus but where it can do so without huge effort, and without creating new problems (like `sort`) its a smart thing to do. \"We've always done it that way\" and \"No one has asked for it\" are always bad excuses for not doing something, but the lack of touch doesn't seem to have caused a lot of pain over the 13 or 14 years we've had PowerShell. If you had started Cmd instead you'd need a touch.exe and really that's the best solution but since Windows has managed this far without it I don't see it happening. \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2021-09-06T11:56:15Z",
      "updated_at": "2021-09-06T11:56:15Z"
    }
  ],
  "created_at": "2020-01-25T06:44:07Z",
  "labels": [
    "Issue-Enhancement",
    "WG-Cmdlets-Management",
    "Area-FileSystem-Provider"
  ],
  "number": 11677,
  "state": "open",
  "title": "Feature Request: Add -IfNotExists switch to New-Item",
  "updated_at": "2021-12-01T09:00:39Z"
}