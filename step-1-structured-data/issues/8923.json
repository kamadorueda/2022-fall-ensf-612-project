{
  "_url": "https://github.com/PowerShell/PowerShell/issues/8923",
  "author": "TylerLeonhardt",
  "body": "<!-- Anything that looks like this is a comment and can't be seen after the Pull Request is created. -->  \r\n\r\n## PR Summary\r\n\r\nThis PR does 4 things:\r\n\r\n* Adds a new cmdlet `New-PSBreakpoint` which creates new `Breakpoint` objects and writes them to the pipeline\r\n* Adds a `-Breakpoint` parameter to `Debug-Runspace` which will receive `Breakpoint` objects\r\n* Makes the constructors for `*Breakpoint` public for use with the API\r\n* Makes `Debugger.GetBreakpoint(string id)` and `Debugger.GetBreakpoints()` public since `SetBreakpoints` is public\r\n\r\nNote: `New-PSBreakpoint` and `Set-PSBreakpoint` (which already exists) are similar... but `Set-PSBreakpoint` also sets the breakpoints in the _current_ runspace. This is not ideal if we want to set breakpoints in a _different runspace than the current one_.\r\n\r\n## PR Context  \r\n\r\nThe \"Attach to process\" debugging experience in the PowerShell extension for VSCode is _ok_ but it's not great.\r\n\r\nThe reason it's not great is due to the `BreakAll` feature of PowerShell debugging which, when you run `Debug-Runspace`, will break at the first piece of code that gets run. This is not ideal when you \"Attach to process\" _and then_ run your code in the other runspace.\r\n\r\nToday, the experience drops you in `PSReadLine`'s psm1 if PSRL is available or in the vscode PowerShell helper psm1.\r\n\r\nIt's unexpected for the user and not ideal.\r\n\r\nThis PR will allow the extension to pass in the breakpoints that need to be set initially with `BreakAll` turned off for none of this silly behavior.\r\n\r\n### Silly behavior example\r\n\r\nIf you want a repro, try this:\r\n\r\nPowerShell instance 1:\r\n```\r\nEnter-PSHostProcess -Id $otherprocesspid\r\nDebug-Runspace 1\r\n```\r\n\r\nPowerShell instance 2:\r\n```\r\n./runfoo.ps1\r\n```\r\n\r\nNote that you end up NOT `runfoo.ps1`\r\n\r\n## PR Checklist\r\n\r\n- [x] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [ ] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] [Change is not breaking](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)\r\n- [ ] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [ ] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` or `[ WIP ]` to the beginning of the title (the `WIP` bot will keep its status check at `Pending` while the prefix is present) and remove the prefix when the PR is ready.  \r\n- **User-facing changes**\r\n    - [ ] Not Applicable\r\n    - **OR**  \r\n    - [x] [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [x] Issue filed: https://github.com/MicrosoftDocs/PowerShell-Docs/issues/4140\r\n- **Testing - New and feature**\r\n    - [ ] N/A or can only be tested interactively\r\n    - **OR**\r\n    - [ ] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n        - [ ] [Add `[feature]` to your commit messages if the change is significant or affects feature tests](https://github.com/PowerShell/PowerShell/blob/master/docs/testing-guidelines/testing-guidelines.md#requesting-additional-tests-for-a-pr)\r\n",
  "closed_at": "2019-04-14T02:14:54Z",
  "comments": [
    {
      "author": "PoshChan",
      "author_association": "COLLABORATOR",
      "body": "@TylerLeonhardt, your last commit had failures in `PowerShell-CI-static-analysis`\r\n",
      "created_at": "2019-04-02T03:08:12Z",
      "updated_at": "2019-04-02T03:08:12Z"
    },
    {
      "author": "TylerLeonhardt",
      "author_association": "MEMBER",
      "body": "@PaulHigin I've made two more APIs public:\r\n\r\n```\r\nDebugger.GetBreakpoint(string id)\r\nDebugger.GetBreakpoints()\r\n```\r\n\r\nIt seemed like the right thing to do considering the SetBreakpoints method public.\r\n\r\nThis is now fully ready for review with tests.",
      "created_at": "2019-04-03T20:53:17Z",
      "updated_at": "2019-04-03T20:54:46Z"
    },
    {
      "author": "PoshChan",
      "author_association": "COLLABORATOR",
      "body": "@TylerLeonhardt, your last commit had 1 failures in `PowerShell-CI-windows`\r\nEnable-RunspaceDebug -Breakpoint Unit Tests - Feature-Enabled.Error occurred in Describe block\r\n```powershell\r\nThe term 'New-PSBreakpoint' is not recognized as the name of a cmdlet, function, script file, or operable program.\r\nCheck the spelling of the name, or if a path was included, verify that the path is correct and try again.\r\nAt D:\\a\\1\\s\\test\\powershell\\Modules\\Microsoft.PowerShell.Utility\\Enable-RunspaceDebug.Tests.ps1:64 char:27\r\n```\r\n",
      "created_at": "2019-04-03T21:15:26Z",
      "updated_at": "2019-04-03T21:15:26Z"
    },
    {
      "author": "TylerLeonhardt",
      "author_association": "MEMBER",
      "body": "@PoshChan please restart CI-windows",
      "created_at": "2019-04-03T22:44:44Z",
      "updated_at": "2019-04-03T22:44:44Z"
    },
    {
      "author": "PoshChan",
      "author_association": "COLLABORATOR",
      "body": "@TylerLeonhardt, I do not understand: please restart CI-windows",
      "created_at": "2019-04-03T22:44:48Z",
      "updated_at": "2019-04-03T22:44:48Z"
    },
    {
      "author": "PoshChan",
      "author_association": "COLLABORATOR",
      "body": "@TylerLeonhardt, your last commit had 56 failures in `PowerShell-CI-windows`\r\n(These are 5 of the failures)\r\n\r\nParserTests (admin\\monad\\tests\\monad\\src\\engine\\core\\ParserTests.cs).Numerical Notations Tests (starting at line 2374 to line 2452).0b0 should return 0, with type [int]\r\n```powershell\r\nExpected '0', but got $null.\r\nat <ScriptBlock>, D:\\a\\1\\s\\test\\powershell\\Language\\Parser\\Parser.Tests.ps1: line 949\r\n949:             ExecuteCommand $Script | Should -Be $ExpectedValue\r\n```\r\nParserTests (admin\\monad\\tests\\monad\\src\\engine\\core\\ParserTests.cs).Numerical Notations Tests (starting at line 2374 to line 2452).0b10 should return 2, with type [int]\r\n```powershell\r\nExpected '2', but got $null.\r\nat <ScriptBlock>, D:\\a\\1\\s\\test\\powershell\\Language\\Parser\\Parser.Tests.ps1: line 949\r\n949:             ExecuteCommand $Script | Should -Be $ExpectedValue\r\n```\r\nParserTests (admin\\monad\\tests\\monad\\src\\engine\\core\\ParserTests.cs).Numerical Notations Tests (starting at line 2374 to line 2452).-0b10 should return -2, with type [int]\r\n```powershell\r\nExpected '-2', but got $null.\r\nat <ScriptBlock>, D:\\a\\1\\s\\test\\powershell\\Language\\Parser\\Parser.Tests.ps1: line 949\r\n949:             ExecuteCommand $Script | Should -Be $ExpectedValue\r\n```\r\nParserTests (admin\\monad\\tests\\monad\\src\\engine\\core\\ParserTests.cs).Numerical Notations Tests (starting at line 2374 to line 2452).0b11111111 should return -1, with type [int]\r\n```powershell\r\nExpected '-1', but got $null.\r\nat <ScriptBlock>, D:\\a\\1\\s\\test\\powershell\\Language\\Parser\\Parser.Tests.ps1: line 949\r\n949:             ExecuteCommand $Script | Should -Be $ExpectedValue\r\n```\r\nParserTests (admin\\monad\\tests\\monad\\src\\engine\\core\\ParserTests.cs).Numerical Notations Tests (starting at line 2374 to line 2452).0b1111111111111111 should return -1, with type [int]\r\n```powershell\r\nExpected '-1', but got $null.\r\nat <ScriptBlock>, D:\\a\\1\\s\\test\\powershell\\Language\\Parser\\Parser.Tests.ps1: line 949\r\n949:             ExecuteCommand $Script | Should -Be $ExpectedValue\r\n```\r\n",
      "created_at": "2019-04-03T23:00:45Z",
      "updated_at": "2019-04-03T23:00:45Z"
    },
    {
      "author": "TylerLeonhardt",
      "author_association": "MEMBER",
      "body": "The single Codacy failure is not important here.",
      "created_at": "2019-04-04T01:47:57Z",
      "updated_at": "2019-04-04T01:47:57Z"
    },
    {
      "author": "TylerLeonhardt",
      "author_association": "MEMBER",
      "body": "@PoshChan please retry windows",
      "created_at": "2019-04-04T20:42:59Z",
      "updated_at": "2019-04-04T20:42:59Z"
    },
    {
      "author": "PoshChan",
      "author_association": "COLLABORATOR",
      "body": "@TylerLeonhardt, successfully started retry of `PowerShell-CI-Windows`",
      "created_at": "2019-04-04T20:44:30Z",
      "updated_at": "2019-04-04T20:44:30Z"
    },
    {
      "author": "PoshChan",
      "author_association": "COLLABORATOR",
      "body": "@TylerLeonhardt, your last commit had 4 failures in `PowerShell-CI-macos`\r\nJEA session Transcript script test.Configuration name should be in the transcript header\r\n```powershell\r\nThe term 'Unregister-PSSessionConfiguration' is not recognized as the name of a cmdlet, function, script file, or operable program.\r\nCheck the spelling of the name, or if a path was included, verify that the path is correct and try again.\r\nat <ScriptBlock>, /Users/vsts/agent/2.149.2/work/1/s/test/powershell/engine/Remoting/RemoteSession.Basic.Tests.ps1: line 75\r\n75:             Unregister-PSSessionConfiguration -Name JEA -Force -ErrorAction SilentlyContinue\r\n\r\n```\r\nJEA session Get-Help test.Get-Help should work in JEA sessions\r\n```powershell\r\nThe term 'Unregister-PSSessionConfiguration' is not recognized as the name of a cmdlet, function, script file, or operable program.\r\nCheck the spelling of the name, or if a path was included, verify that the path is correct and try again.\r\nat <ScriptBlock>, /Users/vsts/agent/2.149.2/work/1/s/test/powershell/engine/Remoting/RemoteSession.Basic.Tests.ps1: line 114\r\n114:             Unregister-PSSessionConfiguration -Name JEA -Force -ErrorAction SilentlyContinue\r\n\r\n```\r\nValidate Set-ExecutionPolicy -Scope (Admin).-Scope LocalMachine is Settable, but overridden\r\n```powershell\r\nOperation is not supported on this platform.\r\nat <ScriptBlock>, /Users/vsts/agent/2.149.2/work/1/s/test/powershell/Modules/Microsoft.PowerShell.Security/ExecutionPolicy.Tests.ps1: line 1163\r\n1163:             Set-ExecutionPolicy -Scope Process -ExecutionPolicy Undefined\r\n\r\n```\r\nValidate Set-ExecutionPolicy -Scope (Admin).-Scope LocalMachine is Settable\r\n```powershell\r\nOperation is not supported on this platform.\r\nat <ScriptBlock>, /Users/vsts/agent/2.149.2/work/1/s/test/powershell/Modules/Microsoft.PowerShell.Security/ExecutionPolicy.Tests.ps1: line 1175\r\n1175:             Set-ExecutionPolicy -Scope Process -ExecutionPolicy Undefined\r\n\r\n```\r\n",
      "created_at": "2019-04-05T23:21:59Z",
      "updated_at": "2019-04-05T23:42:48Z"
    },
    {
      "author": "PoshChan",
      "author_association": "COLLABORATOR",
      "body": "@TylerLeonhardt, your last commit had 4 failures in `PowerShell-CI-linux`\r\nJEA session Transcript script test.Configuration name should be in the transcript header\r\n```powershell\r\nThe term 'Unregister-PSSessionConfiguration' is not recognized as the name of a cmdlet, function, script file, or operable program.\r\nCheck the spelling of the name, or if a path was included, verify that the path is correct and try again.\r\nat <ScriptBlock>, /home/vsts/work/1/s/test/powershell/engine/Remoting/RemoteSession.Basic.Tests.ps1: line 75\r\n75:             Unregister-PSSessionConfiguration -Name JEA -Force -ErrorAction SilentlyContinue\r\n\r\n```\r\nJEA session Get-Help test.Get-Help should work in JEA sessions\r\n```powershell\r\nThe term 'Unregister-PSSessionConfiguration' is not recognized as the name of a cmdlet, function, script file, or operable program.\r\nCheck the spelling of the name, or if a path was included, verify that the path is correct and try again.\r\nat <ScriptBlock>, /home/vsts/work/1/s/test/powershell/engine/Remoting/RemoteSession.Basic.Tests.ps1: line 114\r\n114:             Unregister-PSSessionConfiguration -Name JEA -Force -ErrorAction SilentlyContinue\r\n\r\n```\r\nValidate Set-ExecutionPolicy -Scope (Admin).-Scope LocalMachine is Settable, but overridden\r\n```powershell\r\nOperation is not supported on this platform.\r\nat <ScriptBlock>, /home/vsts/work/1/s/test/powershell/Modules/Microsoft.PowerShell.Security/ExecutionPolicy.Tests.ps1: line 1163\r\n1163:             Set-ExecutionPolicy -Scope Process -ExecutionPolicy Undefined\r\n\r\n```\r\nValidate Set-ExecutionPolicy -Scope (Admin).-Scope LocalMachine is Settable\r\n```powershell\r\nOperation is not supported on this platform.\r\nat <ScriptBlock>, /home/vsts/work/1/s/test/powershell/Modules/Microsoft.PowerShell.Security/ExecutionPolicy.Tests.ps1: line 1175\r\n1175:             Set-ExecutionPolicy -Scope Process -ExecutionPolicy Undefined\r\n\r\n```\r\n",
      "created_at": "2019-04-05T23:24:42Z",
      "updated_at": "2019-04-05T23:42:54Z"
    },
    {
      "author": "TravisEz13",
      "author_association": "MEMBER",
      "body": "test failures are related to #9304 ",
      "created_at": "2019-04-05T23:43:11Z",
      "updated_at": "2019-04-05T23:43:11Z"
    },
    {
      "author": "TravisEz13",
      "author_association": "MEMBER",
      "body": "If you rebase, you should get the fixes for the test failures.",
      "created_at": "2019-04-06T00:01:32Z",
      "updated_at": "2019-04-06T00:01:32Z"
    },
    {
      "author": "TylerLeonhardt",
      "author_association": "MEMBER",
      "body": "Ignoring the single Codacy issue. ",
      "created_at": "2019-04-09T14:57:34Z",
      "updated_at": "2019-04-09T14:57:34Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@TylerLeonhardt The design of this feels very awkward.\r\n\r\nIf I want to set a breakpoint inside of a runspace, I'm instinctively going to look for a `-Runspace` parameter in `Set-PSBreakpoint`. I'm not going to think: \"First I need to create a new breakpoint object, and then once that is created, I need to invoke `Debug-Runspace -Breakpoint $myBreakpoint`\". The former feels like how the rest of PowerShell works. The latter feels like how lower-level programming APIs work.\r\n\r\nWhat's stopping us from taking the more intuitive, PowerShell-like approach with the addition of a `-Runspace` parameter in `Set-PSBreakpoint`, discarding `New-PSBreakpoint` as it shouldn't be necessary, and leaving `Debug-Runspace` as is?\r\n\r\nFrom a programming standpoint, creating a new breakpoint object and then passing it into a runspace via API is fine...just not from PowerShell. Having both `New-PSBreakpoint` and `Set-PSBreakpoint` is bound to cause confusion, becauses suddenly it is no longer clear what cmdlet you should use to create a breakpoint, when it should be evident what you need to use. I say all of this as someone who does the vast majority of their debugging from the command line in the native console, even in vscode.",
      "created_at": "2019-06-16T17:36:49Z",
      "updated_at": "2019-06-16T17:49:03Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "Another question about this part:\r\n\r\n>The reason it's not great is due to the BreakAll feature of PowerShell debugging which, when you run Debug-Runspace, will break at the first piece of code that gets run. This is not ideal when you \"Attach to process\" and then run your code in the other runspace.\r\n> \r\n> Today, the experience drops you in PSReadLine's psm1 if PSRL is available or in the vscode PowerShell helper psm1.\r\n\r\nIt shouldn't be possible to enter into the PSReadLine `psm1` file or any of the vscode PowerShell helper `psm1` files. Those modules should be marked with the `[System.Diagnostics.DebuggerHidden()]` attribute so that the debugger has nothing to do with them. So while I agree we should support breakpoints in runspaces, attaching the debugger to a runspace with `BreakAll` should naturally have a better experience by nature of the debugger only stopping on code that it is allowed to stop on. I say this knowing full well that there are some issues with `DebuggerHidden` in PowerShell, but we need to get to the bottom of those issues and get them fixed so that the debugger doesn't confuse users by bringing them into code that they should otherwise have nothing to do with.",
      "created_at": "2019-06-16T17:45:10Z",
      "updated_at": "2019-06-16T17:45:31Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "FWIW, I dug into the code behind this to see what could be done, and an approach I started putting together looks something like the following (it's not done yet, just in progress in an experimental branch that is local on my machine right now):\r\n\r\n1. Define a Runspace transformation attribute that converts a string (name), int (id), or guid (instance id) into a collection of runspaces. Reasoning: To avoid parameter set bloat by allowing `*-PSBreakpoint` cmdlets that already have multiple parameter sets to have a single `-Runspace` parameter on all parameter sets that uses this transform and covers all bases for how you might want to refer to a runspace.\r\n1. Add a `-Runspace` parameter to `Get-PSBreakpoint`, `Set-PSBreakpoint`, and `Remove-PSBreakpoint` for breakpoint management in runspaces. This approach allows me to set a breakpoint in a runspace that is running without entering the debugger to do so, after which I can use `Get-Runspace` to check the status of my runspaces and see when the breakpoint gets hit (a very useful and necessary feature for debugging).\r\n1. Remove the `-Breakpoint` parameter from `Debug-Runspace`.\r\n1. Remove the `New-PSBreakpoint` command.\r\n\r\nIMHO this approach will be much easier for users to adopt and use.",
      "created_at": "2019-06-18T15:45:59Z",
      "updated_at": "2019-06-18T15:47:12Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "I've taken this far enough as a POC that I can tell it will work. `Set-PSBreakpoint` would have to ensure that debugging was enabled in the runspace before setting the breakpoint, but that's what I would expect to happen anyway. In general though this seems like a much better direction to move forward with.",
      "created_at": "2019-06-18T17:36:40Z",
      "updated_at": "2019-06-18T17:36:40Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "Oh yeah, one more thing: this model could/should apply to jobs as well, allowing me to set breakpoints in a running job from my current PowerShell session, manage breakpoints in those jobs, etc.",
      "created_at": "2019-06-18T17:42:48Z",
      "updated_at": "2019-06-18T17:42:48Z"
    },
    {
      "author": "TylerLeonhardt",
      "author_association": "MEMBER",
      "body": "I can get behind `*-PSBreakpoint` having a `-Runspace` but I need `Debug-Runspace` to have a `-NoInitialBreak` parameter to tell the debugger to not trigger breakall and not break immediately.\r\n\r\nI need this for PowerShell Editor Services.",
      "created_at": "2019-06-18T18:57:23Z",
      "updated_at": "2019-06-18T18:57:50Z"
    },
    {
      "author": "TylerLeonhardt",
      "author_association": "MEMBER",
      "body": "Since you've got a POC, do you want to send a PR for this?",
      "created_at": "2019-06-18T18:58:36Z",
      "updated_at": "2019-06-18T18:58:36Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "I don't mind flushing out the POC and submitting a PR. Some questions first:\r\n\r\nAs far as PSES goes, if you set the breakpoint in the runspace via `Set-PSBreakpoint`, and then you invoke `Debug-Runspace`, it won't do a break all because there is a breakpoint set. If you don't set a breakpoint (i.e. there are no breakpoints in the runspace at all), then it will do a break all. Is that what you need? Or do you very specifically need to be able to prevent break all under all circumstances?",
      "created_at": "2019-06-18T20:06:42Z",
      "updated_at": "2019-06-18T20:06:42Z"
    },
    {
      "author": "TylerLeonhardt",
      "author_association": "MEMBER",
      "body": "> do you very specifically need to be able to prevent break all under all circumstances\r\n\r\nYes. Under no circumstances should a editor debugger break unless:\r\n\r\n1. It hits a breakpoint\r\n2. A \"break immediately\" setting is set to true (there's a feature request for this actually in PSES)",
      "created_at": "2019-06-19T03:42:05Z",
      "updated_at": "2019-06-19T03:42:45Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "Got it, thanks.",
      "created_at": "2019-06-19T15:49:50Z",
      "updated_at": "2019-06-19T15:49:50Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@TylerLeonhardt: FYI, I'm making good progress on this, but I have something I need help with.\r\n\r\n`Enable-/Disable-/Remove-PSBreakpoint` all have a `-Breakpoint` parameter that accepts pipeline input. If I retrieve a breakpoint from a specific runspace and pipe that into one of those commands, I need to know the runspace (really I need the `ScriptDebugger`, but I can get that from the runspace) they come from. But if I add the runspace, or the `ScriptDebugger` directly as I had originally thought I would do, it will break the rehydration that those objects support today. Instead I can work around this by storing the runspace instanceid in the breakpoint, since that would allow rehydration to continue to work, and from that guid I can get the runspace and then update the breakpoint accordingly when one is passed in via pipeline input.\r\n\r\nIf I go for job support as well, I could also store the job instance id on the breakpoint as well, so that I can pipe breakpoints that I'm managing in a job, and have the runspace instance id for use within that job to set the breakpoint accordingly.\r\n\r\nDoes that make sense? Any problems you forsee with this approach before I go down this path?",
      "created_at": "2019-06-24T16:04:47Z",
      "updated_at": "2019-06-24T16:13:04Z"
    },
    {
      "author": "TylerLeonhardt",
      "author_association": "MEMBER",
      "body": "I'd like to hear @PaulHigin's thoughts on this. ",
      "created_at": "2019-06-24T17:01:21Z",
      "updated_at": "2019-06-24T17:01:21Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "Adding @PaulHigin's reply that happened on in email discussion about this.\r\n\r\n> I think it is a good idea to add a -Runspace parameter arguments to the breakpoint cmdlets.  I believe this will meet Tyler\u2019s needs, but we need to ensure all scenarios are covered.  I don\u2019t think it is necessary to update the Breakpoint type to include RunspaceId property.  It think it is an unlikely scenario to pass breakpoint via pipeline over a remote session.  For local use, passing via pipeline is likely and in this case we can simply append a note property to the Breakpoint type, that the updated cmdlets will recognize. \r\n>\r\n> Changing the Breakpoint type creates remoting compatibility issues that I would like to avoid.",
      "created_at": "2019-06-28T14:35:15Z",
      "updated_at": "2019-06-28T14:35:15Z"
    },
    {
      "author": "TylerLeonhardt",
      "author_association": "MEMBER",
      "body": "One thing you'll wanna watch out for is that the RemoteDebugger type does not have any SetBreakpoint() APIs.\r\n\r\nPaul's recommendation is to add to/leverage [this part of the code](https://github.com/PowerShell/PowerShell/blob/bd6fdae73520931f0d27a29d6290e18761772141/src/System.Management.Automation/engine/remoting/server/ServerRunspacePoolDriver.cs#L784-L814) to handle setting the breakpoints on the remote runspace",
      "created_at": "2019-06-28T15:50:23Z",
      "updated_at": "2019-06-28T15:50:37Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Could we consolidate results of the discussion in new Issue to have publicly a clear plan for community?",
      "created_at": "2019-06-29T04:34:18Z",
      "updated_at": "2019-06-29T04:34:18Z"
    },
    {
      "author": "PaulHigin",
      "author_association": "COLLABORATOR",
      "body": "Keep in mind that modifying RemoteDebugger function means we also have to update the remoting protocol version and document, and ensure backwards compatibility.",
      "created_at": "2019-07-01T15:40:26Z",
      "updated_at": "2019-07-01T15:40:26Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@PaulHigin Out of curiousity, why would you recommend modifying PreProcessDebuggerCommand instead of either...\r\n1. ...adding `Set*Breakpoint` abstract methods to the abstract base `Debugger` class and then implementing virtual overrides on the derived debugger classes; or\r\n1. ...adding `Set*Breakpoint` methods to the `RemoteDebugger` class that are not overrides?\r\n\r\nWhat does using `PreProcessDebuggerCommand` buy us that `Set*Breakpoint` methods do not?",
      "created_at": "2019-07-08T16:34:53Z",
      "updated_at": "2019-07-08T16:34:53Z"
    },
    {
      "author": "TylerLeonhardt",
      "author_association": "MEMBER",
      "body": "A `RemoteDebugger` is a pointer to a `ScriptDebugger` on the other end. The `ScriptDebugger` holds all the breakpoints used in a debug session. There\u2019s currently no reference (in code) to a `ScriptDebugger` from within a `RemoteDebugger`.\r\n\r\nThe idea is that within the `Set*Breakpoint` methods in the `RemoteDebugger` class, you\u2019d send a message using the remoting protocol to set the breakpoints within the `ScriptDebugger` on the other end.\r\n\r\nDoes that make sense?",
      "created_at": "2019-07-08T16:51:06Z",
      "updated_at": "2019-07-08T16:51:49Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@TylerLeonhardt Technically that makes sense to me, sure, and I have no problem implementing it that way, but I still wonder why you would suggest that approach vs making the `Set*Breakpoint` methods abstract on the abstract base `Breakpoint` class, so that those methods could directly invoke the corresponding methods on the `ScriptDebugger` on the other side, just as the `GetBreakpoint`/`GetBreakpoints` methods do [here](https://github.com/PowerShell/PowerShell/blob/3bfca6d0fa9c935d78e9f7e9640b3994e5ca5c65/src/System.Management.Automation/engine/remoting/client/remoterunspace.cs#L2019-L2030).",
      "created_at": "2019-07-08T17:37:27Z",
      "updated_at": "2019-07-08T17:40:48Z"
    },
    {
      "author": "PaulHigin",
      "author_association": "COLLABORATOR",
      "body": "Yes, as Tyler mentions, the PreProcessDebuggerCommand is where we process remote debugging commands as defined in the protocol.  ",
      "created_at": "2019-07-08T17:38:58Z",
      "updated_at": "2019-07-08T17:38:58Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "I appreciate the extra details @TylerLeonhardt and @PaulHigin, but I'm still missing some pieces of the puzzle. The fog is clearing up a little though. Here's where I'm at right now:\r\n\r\n1. There is a remote debugging protocol that defines how PowerShell debugging should work remotely, and it needs to be updated (the version and the document), to ensure backwards compatibility.\r\n\r\n    I had been looking for this document in the repository, but couldn't find it. Then I found it [here](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-psrdp/).\r\n\r\n    Is this in GitHub somewhere, so that updates can be added and the document versioned in a GitHub repository, and then the pdf/docx files get generated from markdown? Or is this something you gentlemen manage internally?\r\n\r\n1. Is the reason you are proposing that we extend the protocol and add the new messages to allow breakpoints to be set in remote script debuggers is so that someone can then use that protocol definition to communicate with a remote script debugger and do the same, independent of the PowerShell runtime? If so, can you give me an example where this is done?\r\n\r\n1. Today we have `GetBreakpoint` and `GetBreakpoints` public methods on a remote debugger that invoke corresponding `GetBreakpoint` and `GetBreakpoints` methods on the remote runspace debugger. Why don't these also work through messages sent to the remote script debugger via an extension to the remote debugging protocol? Or, the flipside: why not just expose abstract `Set*Breakpoint` methods on the `Breakpoint` base class, and then override them in other classes that derive from `Debugger`? i.e. Why do we want to _get_ breakpoints via method invocation and _set_ breakpoints via the remote debugging protocol?\r\n\r\nIf those questions don't make sense, please let me know.",
      "created_at": "2019-07-08T18:02:06Z",
      "updated_at": "2019-07-08T20:54:56Z"
    },
    {
      "author": "PaulHigin",
      "author_association": "COLLABORATOR",
      "body": "The MS-PSRP and MS-PSRDP protocol documents are Windows documents that we manage internally.\r\n\r\nThe protocol is how we execute remote debugging commands over the wire, so we have to extend it when adding new functionality, and this includes updating the document.\r\n\r\nThis was not implemented originally because there was no need for it.  But now that there is, we need to do it using the current protocol implementation mechanism.  You can look at the 'PreProcessDebuggerCommand' in the 'ServerRunspacePoolDriver.cs' source file to see how other functions are implemented.",
      "created_at": "2019-07-09T15:37:56Z",
      "updated_at": "2019-07-09T15:37:56Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks @PaulHigin.\r\n\r\nOn your last reply, I should add one point of clarification that is needed. When @TylerLeonhardt implemented this PR, one of the changes he made was to add `GetBreakpoint` and `GetBreakpoints` as abstract methods in the abstract base `Breakpoint` class. Since those recent additions were added that way, that is why I was asking where you draw the line on when to implement as methods that don't go over the wire via the MS-PSRDP, and when to go that route, adding to `PreProcessDebuggerCommand`.\r\n\r\n@TylerLeonhardt, based on what I've heard from Paul here, it sounds like `GetBreakpoint` and `GetBreakpoints` should also be extensions to the MS-PSRDP and pull breakpoints from a remote debugger via `PreProcessDebuggerCommand` additions instead of using the changes you made in this PR that extended the base class with abstract methods. Please let me know if you agree, because if so, I'll go ahead and make those changes.",
      "created_at": "2019-07-09T18:46:28Z",
      "updated_at": "2019-07-09T18:46:28Z"
    },
    {
      "author": "TylerLeonhardt",
      "author_association": "MEMBER",
      "body": "Yep, after further inspection of my code, I made an assumption that the RemoteDebugger (which has a Debugger property) was a reference to the ScriptDebugger... But it's not the case. It's totally circular (still a Remote Debugger type) \r\n\r\nmyRemoteDebugger.Debugger.Debugger.Debugger.Debugger",
      "created_at": "2019-07-10T14:33:03Z",
      "updated_at": "2019-07-10T14:33:03Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@TylerLeonhardt Thank you for confirming, and @PaulHigin, thank you for the protocol details. This all makes so much more sense now. :)",
      "created_at": "2019-07-10T18:36:41Z",
      "updated_at": "2019-07-10T18:36:41Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "What is conclusion about the PR? Should we revert it?",
      "created_at": "2019-07-11T04:54:49Z",
      "updated_at": "2019-07-11T04:54:49Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "I'd prefer just fixing it with another PR. I'm already well on my way with those changes, and many of the changes Tyler made will remain in place.",
      "created_at": "2019-07-11T13:40:30Z",
      "updated_at": "2019-07-11T13:40:30Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@PaulHigin Am I correct in my understanding (based on reading the code) that \"Get\" commands sent over the MS-PSRDP do not use the pre-processor, because they need to return data back to the caller and it doesn't seem that there is a way to do that aside from creating/invoking a `PowerShell` instance?\r\n\r\nFor example, the only \"Get\" command prior to needing to add `GetBreakpoint(int id)` and `GetBreakpoints()` is `GetDebuggerStopArgs`, which uses this enumeration: [`PreProcessCommandResult.GetDebuggerStopArgs`](https://github.com/PowerShell/PowerShell/blob/bd6fdae73520931f0d27a29d6290e18761772141/src/System.Management.Automation/engine/remoting/server/ServerRunspacePoolDriver.cs#L1268-L1271). That enumeration value isn't used anywhere (i.e. it's functionally equivalent to `PreProcessCommandResult.None`), so when it is returned from `PreProcessDebuggerCommand`, it just bypasses the switch statement, so `terminateImmediate` remains set to `false`, resulting in the command running through the runspace.",
      "created_at": "2019-07-11T15:57:20Z",
      "updated_at": "2019-07-11T15:57:20Z"
    },
    {
      "author": "PaulHigin",
      "author_association": "COLLABORATOR",
      "body": "Yes, that is correct.  For any over the wire debugger command that doesn't return data and just sets debugger state, PreProcessDebuggerCommand() simply sets the debugger state and stops.  But for for debugger commands that returns data (currently only GetDebuggerStopArgs), a script has to run so that data can be returned via the normal remoting mechanism.",
      "created_at": "2019-07-12T15:48:49Z",
      "updated_at": "2019-07-12T15:48:49Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "Hey @PaulHigin, I was trying to get this PR submitted today, but stumbled upon an ugly bug in how breakpoints are handled that got in the way. I want to fix that bug as part of the PR I'm working on. It's a pretty weird bug, and definitely needs fixing.\r\n\r\nHere's a repro scenario that works in 5.1 and 6.2.1 that should work in 7 preview as well:\r\n\r\n```powershell\r\n# Create a job that writes a bunch of different types of stream data\r\n$job = Start-Job -ScriptBlock {\r\n    1..1000 | ForEach-Object {\r\n        Start-Sleep -Seconds 1\r\n        $_\r\n        Write-Error 'boo'\r\n        Write-Verbose 'Verbose' -Verbose\r\n        $DebugPreference = 'Continue'\r\n        Write-Debug 'Debug'\r\n        Write-Warning 'Warning'\r\n    }\r\n}\r\n\r\n# Set a local breakpoint on the Get-Process command\r\nSet-PSBreakpoint -Command Get-Process\r\n\r\n# Take note that the breakpoint with ID 0 is a command breakpoint for Get-Process\r\n\r\n# Debug the job\r\nDebug-Job -Job $job\r\n\r\n# In your nested debugger, create a breakpoint inside of the job that triggers when the DebugPreference variable is written\r\nSet-PSBreakpoint -Variable DebugPreference\r\n\r\n# Detach your debugger\r\nd\r\n\r\n# Now that you're back in your main PowerShell runspace, have a look at your breakpoints\r\nGet-PSBreakpoint\r\n```\r\n\r\nThe reason this happens is because of an event loop. The `ScriptDebugger.HandleBreakpointUpdated` event handler is added to job debuggers and nested debuggers, and when you set or remove a breakpoint from inside a job debugger or a nested debugger, the event handler fires, internally invoking the corresponding set or remove breakpoint _on the parent `ScriptDebugger`_. This means breakpoints you set or remove in a child debugging session will result in updates to breakpoints with the same IDs in the parent debugger, even if those are not the same breakpoints at all. This is obviously incorrect, and I'm sure this has made someone scratch their head a few times. Enable and disable don't have the same effect, because they just enable or disable the breakpoint object that was already enabled or disabled, again.\r\n\r\nWhat I could use some help on here is how best to solve it. What was the original intent behind having a job or nested debugger trigger an event handler in a parent `ScriptDebugger` instance? With the changes I'm making, users will be able to manage breakpoints in one debugger independently from another, so I tend to think that there is really no need for the `ScriptDebugger.HandleBreakpointUpdated` event handler at all, but I don't have the history behind what is there now to understand what was supposed to happen. Can you share some of the backstory behind the intent here so that I can confirm whether or not removing this event handler is the right thing to do?\r\n\r\nPlease give this a look and let me know how you feel I should proceed as soon as you can.\r\n\r\nThanks!\r\n\r\ncc: @TylerLeonhardt ",
      "created_at": "2019-07-16T00:30:18Z",
      "updated_at": "2019-07-16T14:27:07Z"
    },
    {
      "author": "PaulHigin",
      "author_association": "COLLABORATOR",
      "body": "It feels to me that this work is getting out of hand.  I think we need to take a step back and be more clear about what debugging changes need to be made, the scope and motivation of those changes.  The best way to do this is via RFC and design documents.   \r\n\r\nLet's start with an RFC and a short summary of what we want to achieve along with scenarios we want to support.  Remote and job debugging support may be a separate effort.\r\n\r\ncc: SteveL-MSFT, @TylerLeonhardt ",
      "created_at": "2019-07-16T15:34:21Z",
      "updated_at": "2019-07-16T15:34:21Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@PaulHigin What?!?\r\n\r\nThat is a horrible suggestion. Seriously, just horrible.\r\n\r\nI'm just a contributor here, but I've put a lot of time into this. I've pushed another PR on the side because I felt getting this corrected (the design of this functionality and the issues in its implementation) were more important than finishing up tests on the other PR work.\r\n\r\nNow you want to put all of that work on hold _when I'm just about to submit a PR_, slam on the brakes, and push it through the terribly slow RFC process, where I have many, many RFCs that just are not progressing, throwing my efforts to get some of these things corrected and into PowerShell 7 out the door completely? Thanks but no thanks.\r\n\r\nThe original work @TylerLeonhardt did skipped the RFC process, and was merged. Now here we are with me having finished my dev work, but I found a bug that should be looked at, so I reached out because I can't make assumptions about why the existing implementation is there, and I don't have the luxury of being on your team to talk directly to you about this, so I ask questions here. I know that interrupts your other work. I'm trying to help you guys, and PowerShell as a whole (the product and the community). You're making it really hard for me to do that.\r\n\r\ncc: @SteveL-MSFT",
      "created_at": "2019-07-16T15:43:57Z",
      "updated_at": "2019-07-16T17:27:14Z"
    },
    {
      "author": "PaulHigin",
      "author_association": "COLLABORATOR",
      "body": "@KirkMunro \r\n\r\nI understand your frustration, but we need a way to manage extensive changes to the code base and RFCs are the current way to do that.  PRs are fine for small scope changes, but I feel this has gone beyond that and we need step back and think carefully about what we want to do and how to move forward.\r\n\r\nI know that RFCs are a slow process, but really it is meant to be so that we don't make decisions we later regret.  \r\n\r\nAlso, I have other high priority work to do so I cannot always be as responsive as I would like.\r\n\r\nRegarding RFCs, I find that smaller, well scoped, clear and concise writing gets better and quicker responses.  Verbose writing is harder to parse and understand.  Large scope changes are harder approve since it is difficult to think through all implications, including compatibility and documentation.  In general I prefer incremental changes where possible.",
      "created_at": "2019-07-16T17:17:12Z",
      "updated_at": "2019-07-16T17:17:12Z"
    },
    {
      "author": "TylerLeonhardt",
      "author_association": "MEMBER",
      "body": "Just to add\u2026 the original scope of this work was to _make the VSCode extension better_ by providing APIs (as in PowerShell\u2019s C# API) for managing breakpoints.\r\n\r\nWe expanded on that by exposing a few additions to cmdlets so that folks debugging from the CLI could take advantage of these features - thus `New-PSBreakpoint` and the `-Breakpoint` param were born.\r\n\r\nUpon seeing @KirkMunro\u2019s original thoughts on cmdlet design, I agreed that `New-PSBreakpoint` was probably less \u201cPowerShelly\u201d compared to `Set-PSBreakpoint -Runspace` and @PaulHigin and I both felt like that\u2019s probably the better way to go and @KirkMunro took that and ran with it.\r\n\r\nAs @KirkMunro continued this work, it\u2019s clear that there are edge cases in the debugging stack. That\u2019s not surprising - it\u2019s a piece of software.\r\n\r\nI personally think that we should not include any bug fixes with this change and instead, should address bug fixes in a separate PR so to make the size of the PR that adds this feature smaller.\r\n\r\nThe PR should only:\r\n* give the vscode extension an API to manage breakpoints in other runspaces\r\n* give a simple cmdlet experience so that users of the CLI can do similar breakpoint management in other runspaces.\r\n\r\n> give the vscode extension an API to manage breakpoints in other runspaces\r\n\r\nThis is why we didn\u2019t originally open an RFC for this is because the extension _needs_ this functionality to act in the way other language debuggers in vscode do. It was scoped to this.",
      "created_at": "2019-07-16T18:45:21Z",
      "updated_at": "2019-07-16T18:46:51Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "I'm good with that, for the most part. The other issues will quickly fall into my short list of items to resolve after this work.",
      "created_at": "2019-07-17T00:15:34Z",
      "updated_at": "2019-07-17T00:58:12Z"
    },
    {
      "author": "joeyaiello",
      "author_association": "CONTRIBUTOR",
      "body": "Even if you disagree strongly with something, please remember to follow our [code of conduct](https://github.com/PowerShell/PowerShell/blob/master/CODE_OF_CONDUCT.md) when posting in issues or PRs. Locking out the rest of this one as I think we're closed here.\r\n\r\nIf you still want to push for some of your changes that weren't merged, feel free to open a discussion issue. \r\n\r\nI'll be publishing a blog on RFCs and feature additions soon, hopefully it should address some of the confusion around scenarios like this one. ",
      "created_at": "2019-07-17T19:09:14Z",
      "updated_at": "2019-07-17T19:09:14Z"
    }
  ],
  "created_at": "2019-02-20T07:12:06Z",
  "number": 8923,
  "state": "closed",
  "title": "New `New-PSBreakpoint` cmdlet  & new `-Breakpoint` parameter for `Debug-Runspace`",
  "updated_at": "2019-07-17T19:09:28Z"
}