{
  "_url": "https://github.com/PowerShell/PowerShell/issues/3441",
  "author": "jeffbi",
  "body": "Fix #1930.\r\n\r\nRather than relying on case-insensitive string compares of source and destination paths, use operating system calls to determine whether two paths refer to the same file. This solves not only the case-insensitivity issue but also allows the cmdlet to operate properly if the destination is a hard or symbolic link to the source.\r\n\r\nThe Windows side is implemented in C#. The Unix side is implemented partially in native code.",
  "closed_at": "2017-04-21T23:09:54Z",
  "comments": [
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@jeffbi I updated the description as this seems the fix for #1930, but please correct it if I'm wrong.\r\nCould you please add more description about how your fix works? It will be helpful for reviewing the changes.\r\n\r\nThe last comment of #1930 shows:\r\n> edit: fixed, thanks @iSazonov\r\n\r\n@SteveL-MSFT, do you mean that bug had already been fixed by @iSazonov?",
      "created_at": "2017-03-28T01:07:32Z",
      "updated_at": "2017-03-28T01:07:32Z"
    },
    {
      "author": "jeffbi",
      "author_association": "CONTRIBUTOR",
      "body": "@daxian-dbw Yes, it is a fix for #1930. I had that at the end of the pull-request title, but it looks like it got clipped off.\r\n\r\nI've updated the description with more information.\r\n\r\nI believe @SteveL-MSFT's comment referred to fixing the wording on an earlier comment.",
      "created_at": "2017-03-28T01:27:53Z",
      "updated_at": "2017-03-28T01:27:53Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@daxian-dbw \r\n>@SteveL-MSFT, do you mean that bug had already been fixed by @iSazonov?\r\n\r\nIt was just a typo.\r\n\r\n",
      "created_at": "2017-03-28T04:29:39Z",
      "updated_at": "2017-03-28T04:29:39Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I tested\r\n```powershell\r\nTest-Path /etc/sysctl.conf\r\nTest-Path /etc/sysctl.CONF\r\n```\r\non WSL and Test-Path is case-sensitive. Do we really need additional code here?\r\n\r\n",
      "created_at": "2017-03-28T04:33:25Z",
      "updated_at": "2017-03-28T04:33:25Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@daxian-dbw yeah, the 'fixed' statement referred to a typo in the comment @iSazonov caught, nit that the issue was fixed",
      "created_at": "2017-03-28T05:45:50Z",
      "updated_at": "2017-03-28T05:45:50Z"
    },
    {
      "author": "jeffbi",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov The goal of the original code was to ensure that the cmdlet did not attempt to copy a file onto itself, and it did so by doing a case-insensitive compare of the two normalized paths. That worked fine on FAT volumes, on NTFS volumes under Windows in its default mode, and on HFS+ volumes on OS X. In your example, it would consider `/etc/sysctl.conf` and `/etc/sysctl.CONF` to be the same file and would not allow the copy. On a case-sensitive file system such as ext under Linux, or NTFS under either Linux or OS X, those two paths are generally *not* the same file, so the copy should be allowed to continue, which is the complaint in issue #1930. I'm fairly confident that if you ran `copy-item /etc/sysctl.conf /etc/sysctl.CONF` under WSL it would fail with an error saying it cannot copy the file onto itself.\r\n\r\nThen consider links. If file A is a file on a volume, and file B is a hard or symbolic link to file A, copying A to B would actually be copying A onto itself, which the cmdlet does not allow but cannot be detected by merely comparing two path strings.\r\n\r\nThe new code determines whether two paths refer to the same file (the goal of the original code) regardless of what the paths appear to be. It works on HFS+, ext, FAT, and NTFS file systems. For NTFS file systems, it does the right thing under Windows, where the volume is case-*in*sensitive, and on Mac/Linux where the volume is case-sensitive. And it works for hard and symbolic links on those file systems that support them.",
      "created_at": "2017-03-28T07:38:33Z",
      "updated_at": "2017-03-28T07:38:55Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "My question was only whether we can use existing code without new low level code?\r\nI believe yes.\r\nCurrently .Net Core works _uniformly_ on all platforms with hard and soft links. (We can even remove [this code for Unix](https://github.com/PowerShell/PowerShell/blob/master/src/System.Management.Automation/namespaces/FileSystemProvider.cs#L8179) and perhaps even more code can be replaced with .Net Core code there)\r\n```powershell\r\nName           : powershell\r\nLength         : 0\r\nCreationTime   : 3/21/2017 11:18:52 AM\r\nLastWriteTime  : 3/21/2017 11:18:52 AM\r\nLastAccessTime : 3/21/2017 11:18:52 AM\r\nMode           : -a---l\r\nLinkType       : SymbolicLink\r\nTarget         : C:\\Users\\sie\\Documents\\GitHub\\iSazonov\\PowerShell\\debug\\powershell.exe\r\nVersionInfo    : File:             C:\\Users\\sie\\Documents\\GitHub\\iSazonov\\PowerShell\\debug\\powershell\r\n```\r\nHere `Target` contains true value for soft and hard links. We can use `Mode` or `LinkType` to detect links.\r\nAnother option is `[Microsoft.PowerShell.Commands.InternalSymbolicLinkLinkCodeMethods]::GetLinkType`\r\n\r\nSo here we can make the code more simple.\r\n\r\nWe should create a new API to compare path and place it in engen\\Utils.cs or PathUtils.cs\r\n",
      "created_at": "2017-03-28T14:27:45Z",
      "updated_at": "2017-03-28T14:27:45Z"
    },
    {
      "author": "jeffbi",
      "author_association": "CONTRIBUTOR",
      "body": "This works differently in Linux.\r\n```\r\nPS> new-item junk.txt -value \"stuff\"\r\nPS> get-item j* | select name,mode,attributes,length,linktype,target\r\nName       : junk.txt\r\nMode       : ------\r\nAttributes : Normal\r\nLength     : 5\r\nLinkType   : \r\nTarget     : \r\n\r\nPS> new-item -itemtype symboliclink -path junk-sym.txt -value junk.txt \r\nPS> new-item -itemtype hardlink -path junk-hard.txt -value junk.txt\r\nPS> get-item j* | select name,mode,attributes,length,linktype,target\r\nName       : junk-hard.txt\r\nMode       : -----l\r\nAttributes : Normal\r\nLength     : 5\r\nLinkType   : HardLink\r\nTarget     : \r\n\r\nName       : junk-sym.txt\r\nMode       : -----l\r\nAttributes : ReparsePoint\r\nLength     : 24\r\nLinkType   : SymbolicLink\r\nTarget     : {/home/jeff/junk/junk.txt}\r\n\r\nName       : junk.txt\r\nMode       : -----l\r\nAttributes : Normal\r\nLength     : 5\r\nLinkType   : HardLink\r\nTarget     : \r\n```\r\n\r\nHere, the symbolic link points to its target, but the hard link does not. Also, once the hard link was created, the original file became a hard link as well. Linux (or the ext file system) does not distinguish between a hard link and the \"original\" file.\r\n\r\nA slightly off-topic question: Note that the symbolic link's attributes property says \"ReparsePoint\". That makes sense for Windows, but does it for Linux?",
      "created_at": "2017-03-28T20:39:30Z",
      "updated_at": "2017-03-28T20:39:30Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@jeffbi Sorry for mesh in my previous comment.\r\n\r\n> This works differently in Linux.\r\n\r\nI believe we should fix this locally - behavior on all platforms must be the same. So my suggestion is don't block the PR, continue the code review and open new Issue (if you confirm that we have inconsistency in file provider with soft/hard links on different platforms).",
      "created_at": "2017-03-29T09:10:18Z",
      "updated_at": "2017-03-29T09:10:18Z"
    },
    {
      "author": "jeffbi",
      "author_association": "CONTRIBUTOR",
      "body": "Is this being reviewed, or is it awaiting something from me?",
      "created_at": "2017-03-30T21:47:47Z",
      "updated_at": "2017-03-30T21:47:47Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I originally thought that we already have full compliance with links on all platforms as associated problems has been closed both locally and in CoreFX. As you pointed out it is not. I propose to open a new issue and collect the inconsistencies there. Anyway we need to fix it now or later. I need your help with this on Unix.\r\nI suppose this is the preferred way to reduce the places where we use low level API, PInvoke and \"If $Platform\".\r\nIf we can fix `Target`, then it will be a more fundamental and useful solution and this will simplify many things _including this PR_ (yes?). If it will be difficult to fix (Although I am assuming that your low-level code would simply be used in another API), we will take the PR \"as is\". Confirm if I don't wrong again and you agree with the road map.\r\n\r\n@daxian-dbw Could you please review my thoughts? ",
      "created_at": "2017-03-31T04:56:13Z",
      "updated_at": "2017-03-31T04:56:13Z"
    },
    {
      "author": "jeffbi",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov  I don't think we can \"fix\" `Target`, at least for Unix. Short of walking the file system, like the UNIX `find` command does, I don't believe there is a way to discover all the hard links to a given inode. An inode has a _count_ of links that refer to it, but not a list of the actual links.\r\n\r\nMy low-level code does not attempt to find all paths to an inode, just whether two paths point to the same inode. There is an open request issue in corefx (dotnet/corefx#10120) to implement this in corefx.\r\n\r\nIn PowerShell 5.1 on my Windows 10 box, the `Target` property contains a collection of other hard links to the same file. On PowerShell for CoreCLR, `Target` is empty. The code for discovering the links on Windows is `#if`-ed out, with a comment saying the Windows API functions `FindFirstFileName` and `FindNextFileName` are not supported in CoreCLR. Is that no longer the case? I re-enabled that code, using the appropriate DLL name from [here](https://msdn.microsoft.com/en-us/library/mt588480%28v=vs.85%29.aspx?#api-ms-win-core-file-l1-2-2.dll), and I'm able to populate `Target` on CoreCLR. That code, though, does have another instance of case-insensitive path comparison, which is what started this PR in the first place.\r\n\r\nI have come across a few other issues that are related to links, one in New-Item and two that directly affect #621 (the latter two are, I believe, corefx issues: see dotnet/corefx#17843 and dotnet/corefx#17844). Do we want to create a single issue as a catch-all for link-related items?",
      "created_at": "2017-04-03T21:53:21Z",
      "updated_at": "2017-04-03T21:53:21Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@jeffbi Great ** 2! \ud83d\ude04 Thanks!\r\nI see that:\r\n- We cannot fix Targets on Unix (at least effectively). Now we leave it as is and wait CoreFX solution.\r\n- We should open new Issue to fix targets on PowerShell Core on Windows to get the same behavior as Windows PowerShell (for NTFS).\r\n- We would open new Meta-Issue with your research results. (Although it is necessary to comprehend the already open [ones](https://github.com/PowerShell/PowerShell/search?q=symbolic+&type=Issues&utf8=%E2%9C%93) )\r\n\r\nSorry for the delay of the PR.",
      "created_at": "2017-04-04T04:20:11Z",
      "updated_at": "2017-04-04T04:20:11Z"
    },
    {
      "author": "jeffbi",
      "author_association": "CONTRIBUTOR",
      "body": "@daxian-dbw This has been waiting for approval/merge of PR #3509 because the Pester tests should be using New-Item to create directory symbolic links.\r\n\r\nI can get around that by shelling out to cmd.exe to run the mklink program, but that would mean revisiting the test script once the PR has been merged. Perhaps I could open a new issue to update the test.\r\n\r\nWould this be acceptable?",
      "created_at": "2017-04-14T17:18:51Z",
      "updated_at": "2017-04-14T17:18:51Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@jeffbi Thanks for letting me know. I noticed that @iSazonov has signed off #3509. I will quickly go through it and merge the PR if I don't spot anything obvious.",
      "created_at": "2017-04-14T20:49:08Z",
      "updated_at": "2017-04-14T20:49:08Z"
    },
    {
      "author": "jeffbi",
      "author_association": "CONTRIBUTOR",
      "body": "@daxian-dbw I think there are discussions required for #3509 regarding the proper way to create symlinks in various circumstances under Windows, and that that's why approval/merging of that PR is taking a while.",
      "created_at": "2017-04-14T20:58:58Z",
      "updated_at": "2017-04-14T20:58:58Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@jeffbi #3509 has been merged. Please sync and carry on with your test changes for this PR.",
      "created_at": "2017-04-14T21:23:59Z",
      "updated_at": "2017-04-14T21:23:59Z"
    },
    {
      "author": "jeffbi",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov In response to your review:\r\n\r\n- `RequireAdminOnWindows`: I knew about this, but decided against it in this case.\r\n  - Whether a test requires elevation on Windows is not about the test itself, but about the _precondition_ for the test---the _test_ can run without elevation, but it requires elevation (on Windows) to create the symbolic links the test works with.\r\n  - Using this tag would mean that we would need a separate `Describe` for almost every test, in some cases with the tests duplicated only because we couldn't do part of the setup without elevation. If I understand this tag correctly, this would also require creating identical tests that do no have this tag so they can be run on Unix, and possibly coming up with a mechanism for ensuring that only one of those tests is run. This seems to me to be a lot of extra code for little gain. Since all these tests are validating the same basic thing, I thought they should be contained in a single `Describe.`\r\n- Using `It \"\" -TestCase $testCases`: If we end up having multiple `Describe` blocks as discussed above, using the `$testCases` might not be practical since we'd probably end up with the logic contained within the `It` block in each `Describe` block.\r\n- `Remove-Item` after the `ShouldBe`: You're right about that, of course. However, we can't move the `Remove-Item $destination` into the `AfterAll` block because most of the time the source and the destination object are the same object and removing it would likely cause the next test to fail because its source object no longer exists. I can, though, do something like this:\r\n```\r\n$pathExists = Test-Path $testCase.Destaination\r\nRemove-Item -Path $testCase.Destination -Force -ErrorAction SilentlyContinue\r\n$pathExists | Should Be $true\r\n```\r\n- Native code: For consistency I modeled the coding style of the existing `isdirectory.h` and `isdirectory.cpp` files. I'm happy to make your suggested changes if you prefer.",
      "created_at": "2017-04-17T19:28:28Z",
      "updated_at": "2017-04-17T19:28:28Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": ">  RequireAdminOnWindows \r\n\r\nWe don't test Windows behavior, we test PowerShell behavior. So the tests is the same for elevated and non-elevated sessions. In other words if you perform these tests with `RequireAdminOnWindows`, we will not miss any bug. So we can safely put `RequireAdminOnWindows` tag.\r\n\r\nUnix tests is not skipped if `RequireAdminOnWindows` present!\r\n\r\n>Using  It \"\" -TestCase $testCases \r\n\r\nBased on my comments we can use this.\r\n\r\n>  Remove-Item  after the  ShouldBe \r\n\r\nMy suggesion is ` AfterEach` not ` AfterAll`. The `Remove-Item` is in `foreach` and it is executed for every test case.\r\n\r\n>Native code\r\n\r\nI agree with using current pattern.\r\n",
      "created_at": "2017-04-18T05:12:32Z",
      "updated_at": "2017-04-18T05:15:03Z"
    },
    {
      "author": "jeffbi",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov I've re-worked the structure of the tests.",
      "created_at": "2017-04-18T22:43:10Z",
      "updated_at": "2017-04-18T22:43:10Z"
    },
    {
      "author": "jeffbi",
      "author_association": "CONTRIBUTOR",
      "body": "The Travis CI build failure puzzles me. It appears to have succeeded on Linux but failed on OS X.\r\n\r\nIt appears that the offending line is\r\n```\r\nRemove-Item -Path $destinationPath -Force -ErrorAction SilentlyContinue\r\n```\r\nand it looks to me like it's ignoring the `-ErrorAction SilentlyContinue` part. Have I missed something?",
      "created_at": "2017-04-19T05:29:39Z",
      "updated_at": "2017-04-19T05:29:39Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@jeffbi That error seems to indicate a bug in the product code. The error string is from [FileSystemProviderStrings.resx](https://github.com/PowerShell/PowerShell/blob/master/src/System.Management.Automation/resources/FileSystemProviderStrings.resx#L201):\r\n```\r\n  <data name=\"ItemDoesNotExist\" xml:space=\"preserve\">\r\n    <value>An object at the specified path {0} does not exist.</value>\r\n  </data>\r\n```\r\nIt looks to me an exception with this resource string got thrown. Searching where this resource string is used in code might lead you somewhere.",
      "created_at": "2017-04-19T06:59:33Z",
      "updated_at": "2017-04-19T06:59:33Z"
    },
    {
      "author": "jeffbi",
      "author_association": "CONTRIBUTOR",
      "body": "@daxian-dbw Thanks for the suggestion. I'll take a look tomorrow. It's odd because I've run the Pester tests on all three platforms, and run the `Remove-Item` with `-ErrorAction SilentlyContinue` alone, and they all work.",
      "created_at": "2017-04-19T07:41:45Z",
      "updated_at": "2017-04-19T07:41:45Z"
    },
    {
      "author": "jeffbi",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov Can you look this over please?",
      "created_at": "2017-04-21T04:32:59Z",
      "updated_at": "2017-04-21T04:32:59Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Please correct https://github.com/PowerShell/PowerShell/pull/3441/files#r111716269",
      "created_at": "2017-04-21T08:18:10Z",
      "updated_at": "2017-04-21T08:18:10Z"
    },
    {
      "author": "jeffbi",
      "author_association": "CONTRIBUTOR",
      "body": "C++ comments updated",
      "created_at": "2017-04-21T09:23:16Z",
      "updated_at": "2017-04-21T09:23:16Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@jeffbi I don't  see last commit (with C++)",
      "created_at": "2017-04-21T11:23:52Z",
      "updated_at": "2017-04-21T11:23:52Z"
    },
    {
      "author": "jeffbi",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov Commit 19702a0",
      "created_at": "2017-04-21T17:24:48Z",
      "updated_at": "2017-04-21T17:24:48Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Thanks! I see now.\r\n\r\nLGTM.",
      "created_at": "2017-04-21T17:54:36Z",
      "updated_at": "2017-04-21T17:54:36Z"
    },
    {
      "author": "jeffbi",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov Thanks for the review! \ud83d\udc4d ",
      "created_at": "2017-04-21T18:01:07Z",
      "updated_at": "2017-04-21T18:01:07Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@jeffbi Do you specifically choose a work with the most sophisticated tests? \ud83d\ude04 ",
      "created_at": "2017-04-21T19:54:57Z",
      "updated_at": "2017-04-21T19:54:57Z"
    },
    {
      "author": "daxian-dbw",
      "author_association": "MEMBER",
      "body": "@jeffbi @iSazonov This is awesome!!! This is not a trivial issue to resolve, thank you both very much for the great fix and the thorough review discussion!",
      "created_at": "2017-04-21T23:06:24Z",
      "updated_at": "2017-04-21T23:06:24Z"
    }
  ],
  "created_at": "2017-03-28T00:51:30Z",
  "number": 3441,
  "state": "closed",
  "title": "Replace string-compare-based test for copying to same file with more \u2026",
  "updated_at": "2017-04-22T11:12:53Z"
}