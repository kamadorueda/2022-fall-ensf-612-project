{
  "_url": "https://github.com/PowerShell/PowerShell/issues/7092",
  "author": "lamw",
  "body": "FYI - I'm not sure if this is the *best* way to extract the SHA256 Thumbprint, but this has worked for me on Windows. If there is a better/recommended method that works on standard PowerShell for Windows as well PowerShell Core, I am definitely open to suggestion. \r\n\r\nSteps to reproduce\r\n------------------\r\n\r\n```powershell\r\nFunction Get-SSLThumbprint256 {\r\n    param(\r\n    [Parameter(\r\n        Position=0,\r\n        Mandatory=$true,\r\n        ValueFromPipeline=$true,\r\n        ValueFromPipelineByPropertyName=$true)\r\n    ]\r\n    [Alias('FullName')]\r\n    [String]$URL\r\n    )\r\n\r\nadd-type @\"\r\n        using System.Net;\r\n        using System.Security.Cryptography.X509Certificates;\r\n            public class IDontCarePolicy : ICertificatePolicy {\r\n            public IDontCarePolicy() {}\r\n            public bool CheckValidationResult(\r\n                ServicePoint sPoint, X509Certificate cert,\r\n                WebRequest wRequest, int certProb) {\r\n                return true;\r\n            }\r\n        }\r\n\"@\r\n    [System.Net.ServicePointManager]::CertificatePolicy = new-object IDontCarePolicy\r\n\r\n    # Need to connect using simple GET operation for this to work\r\n    Invoke-RestMethod -Uri $URL -Method Get | Out-Null\r\n\r\n    $ENDPOINT_REQUEST = [System.Net.Webrequest]::Create(\"$URL\")\r\n    $CERT = $ENDPOINT_REQUEST.ServicePoint.Certificate\r\n    # https://stackoverflow.com/a/22251597\r\n    $BYTES = $cert.Export([Security.Cryptography.X509Certificates.X509ContentType]::Cert)\r\n    Set-content -value $BYTES -encoding byte -path $ENV:TMP\\cert-temp\r\n    $SSL_THUMBPRINT = (Get-FileHash -Path $ENV:TMP\\cert-temp -Algorithm SHA256).Hash\r\n    return $SSL_THUMBPRINT -replace '(..(?!$))','$1:'\r\n}\r\n```\r\n\r\nExpected behavior\r\n-----------------\r\n\r\nThe ability to extract the SHA256 SSL Thumbprint from a given endpoint. An example is provided below which works on standard Windows PowerShell 5.1 (5.1.17134.112 )\r\n\r\n```powershell\r\nGet-SSLThumbprint256 -URL \"https://google.com:443\"\r\nB9:B0:D3:46:36:83:13:6F:9E:32:80:61:0C:EC:0D:D2:1F:65:BE:3C:2F:81:92:CF:7B:C8:90:F1:71:2A:1C:F5\r\n```\r\n\r\nActual behavior\r\n---------------\r\n\r\nWhen performing this on latest PowerShell Core, the following error is thrown:\r\n```powershell\r\nGet-SSLThumbprint256 -URL \"https://google.com:443\"\r\nadd-type : (3) : The type or namespace name 'ICertificatePolicy' could not be found (are you missing a using directive or an assembly reference?)\r\n(2) :         using System.Security.Cryptography.X509Certificates;\r\n(3) : >>>             public class IDontCarePolicy : ICertificatePolicy {\r\n(4) :             public IDontCarePolicy() {}\r\nAt line:13 char:1\r\n+ add-type @\"\r\n+ ~~~~~~~~~~~\r\n+ CategoryInfo          : InvalidData: (Microsoft.Power...peCompilerError:AddTypeCompilerError) [Add-Type], Exception\r\n+ FullyQualifiedErrorId : SOURCE_CODE_ERROR,Microsoft.PowerShell.Commands.AddTypeCommand\r\n\r\nadd-type : Cannot add type. Compilation errors occurred.\r\nAt line:13 char:1\r\n+ add-type @\"\r\n+ ~~~~~~~~~~~\r\n+ CategoryInfo          : InvalidData: (:) [Add-Type], InvalidOperationException\r\n+ FullyQualifiedErrorId : COMPILER_ERRORS,Microsoft.PowerShell.Commands.AddTypeCommand\r\n\r\nnew-object : Cannot find type [IDontCarePolicy]: verify that the assembly containing this type is loaded.\r\nAt line:25 char:59\r\n+ ... .ServicePointManager]::CertificatePolicy = new-object IDontCarePolicy\r\n+                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n+ CategoryInfo          : InvalidType: (:) [New-Object], PSArgumentException\r\n+ FullyQualifiedErrorId : TypeNotFound,Microsoft.PowerShell.Commands.NewObjectCommand\r\n\r\nYou cannot call a method on a null-valued expression.\r\nAt line:33 char:5\r\n+     $BYTES = $cert.Export([Security.Cryptography.X509Certificates.X50 ...\r\n+     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n+ CategoryInfo          : InvalidOperation: (:) [], RuntimeException\r\n+ FullyQualifiedErrorId : InvokeMethodOnNull\r\n\r\nSet-Content : Cannot bind parameter 'Encoding'. Cannot convert the \"byte\" value of type \"System.String\" to type \"System.Text.Encoding\".\r\nAt line:34 char:41\r\n+     Set-content -value $BYTES -encoding byte -path /tmp/cert-temp\r\n+                                         ~~~~\r\n+ CategoryInfo          : InvalidArgument: (:) [Set-Content], ParameterBindingException\r\n+ FullyQualifiedErrorId : CannotConvertArgumentNoMessage,Microsoft.PowerShell.Commands.SetContentCommand\r\n\r\nGet-FileHash : Cannot find path '/tmp/cert-temp' because it does not exist.\r\nAt line:35 char:24\r\n+ ... UMBPRINT = (Get-FileHash -Path /tmp/cert-temp -Algorithm SHA256).Hash ...\r\n+                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n+ CategoryInfo          : ObjectNotFound: (/tmp/cert-temp:String) [Get-FileHash], ItemNotFoundException\r\n+ FullyQualifiedErrorId : FileNotFound,Microsoft.PowerShell.Commands.GetFileHashCommand\r\n```\r\n\r\nEnvironment data\r\n----------------\r\n\r\n```powershell\r\n> $PSVersionTable\r\nName                           Value\r\n----                           -----\r\nPSVersion                      6.0.2\r\nPSEdition                      Core\r\nGitCommitId                    v6.0.2\r\nOS                             Darwin 17.6.0 Darwin Kernel Version 17.6.0: Tue May  8 15:22:16 PDT 2018; root:xnu-4570.61.1~1/RELEASE_X86_64\r\nPlatform                       Unix\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```\r\n",
  "closed_at": "2018-06-18T10:08:09Z",
  "comments": [
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "`ICertificatePolicy` and `CertificatePolicy` are absolute. You can see the warning here https://docs.microsoft.com/en-us/dotnet/api/system.net.servicepointmanager.certificatepolicy?view=netframework-4.7.2 That API is no longer included in .NET Core. \r\n\r\nInstead us the `ServerCertificateValidationCallback` API https://docs.microsoft.com/en-us/dotnet/api/system.net.servicepointmanager.servercertificatevalidationcallback?view=netcore-2.1#System_Net_ServicePointManager_ServerCertificateValidationCallback .  \r\n\r\nHere is quick and dirty way to do this that works in both Windows PowerShell and PowerShell Core.\r\n\r\n```powershell\r\n$Code = @'\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Net.Http;\r\nusing System.Net.Security;\r\nusing System.Security.Cryptography.X509Certificates;\r\n\r\nnamespace CertificateCapture\r\n{\r\n    public class Utility\r\n    {\r\n         public static Func<HttpRequestMessage,X509Certificate2,X509Chain,SslPolicyErrors,Boolean> ValidationCallback = \r\n            (message, cert, chain, errors) => {\r\n                var newCert = new X509Certificate2(cert);\r\n                var newChain = new X509Chain();\r\n                newChain.Build(newCert);\r\n                CapturedCertificates.Add(new CapturedCertificate(){\r\n                    Certificate =  newCert,\r\n                    CertificateChain = newChain,\r\n                    PolicyErrors = errors,\r\n                    URI = message.RequestUri\r\n                });\r\n                return true; \r\n            };\r\n        public static List<CapturedCertificate> CapturedCertificates = new List<CapturedCertificate>();\r\n    }\r\n\r\n    public class CapturedCertificate \r\n    {\r\n        public X509Certificate2 Certificate { get; set; }\r\n        public X509Chain CertificateChain { get; set; }\r\n        public SslPolicyErrors PolicyErrors { get; set; }\r\n        public Uri URI { get; set; }\r\n    }\r\n}\r\n'@\r\n\r\nif ($PSEdition -ne 'Core'){\r\n    Add-Type -AssemblyName System.Net.Http\r\n    Add-Type $Code -ReferencedAssemblies System.Net.Http\r\n} else {\r\n    Add-Type $Code\r\n}\r\n\r\n$Certs = [CertificateCapture.Utility]::CapturedCertificates\r\n\r\n$Handler = [System.Net.Http.HttpClientHandler]::new()\r\n$Handler.ServerCertificateCustomValidationCallback = [CertificateCapture.Utility]::ValidationCallback\r\n$Client = [System.Net.Http.HttpClient]::new($Handler)\r\n\r\n$Url = 'https://google.com/'\r\n\r\n$Result = $Client.GetAsync($Url).Result\r\n\r\n$Certs[-1].Certificate.Thumbprint\r\n```",
      "created_at": "2018-06-18T10:04:17Z",
      "updated_at": "2018-06-18T10:04:17Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "For clarity, this is the result of changes in .NET and not PowerShell itself.\r\n\r\nAlso, I missed that you were doing the sha265 thumbprint, but you should be able to adapt your code with what I provided.",
      "created_at": "2018-06-18T10:07:46Z",
      "updated_at": "2018-06-18T10:07:46Z"
    },
    {
      "author": "lamw",
      "author_association": "NONE",
      "body": "@markekraus I just tried to run the snippet above, but I'm not seeing any output when running on PowerShell Core (works on Windows PowerShell).\r\n\r\nHere's the platform I'm running Core on\r\n```\r\nName                           Value\r\n----                           -----\r\nPSVersion                      6.0.2\r\nPSEdition                      Core\r\nGitCommitId                    v6.0.2\r\nOS                             Darwin 17.6.0 Darwin Kernel Version 17.6.0: Tue May  8 15:22:16 PDT 2018; root:xnu-4570.61.1~1/RELEASE_X86_64\r\nPlatform                       Unix\r\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}\r\nPSRemotingProtocolVersion      2.3\r\nSerializationVersion           1.1.0.1\r\nWSManStackVersion              3.0\r\n```",
      "created_at": "2018-06-18T12:30:03Z",
      "updated_at": "2018-06-18T12:30:03Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "hmm it works for me on 6.0.2\r\n\r\n![image](https://user-images.githubusercontent.com/6509955/41539127-9844e84c-72d2-11e8-84f6-409fb209f444.png)\r\n",
      "created_at": "2018-06-18T13:36:22Z",
      "updated_at": "2018-06-18T13:36:22Z"
    },
    {
      "author": "markekraus",
      "author_association": "CONTRIBUTOR",
      "body": "oh.. I see you are on a unix platform of some kind... is that a macOS? In which case... there is no way to capture endpoint certificates in .NET Core 2.0 and lower on macOS and some Linux/Unix systems due to some platform implementation limitations.\r\n\r\nCan you try with 6.1.0-preview.3 https://github.com/PowerShell/PowerShell/releases/tag/v6.1.0-preview.3 ?\r\n\r\n6.1.0 will use .NET Core 2.1 which switched to managed code implementation for HttpClient and WebRequest that _should_ eliminate the platform specific limitations.",
      "created_at": "2018-06-18T13:43:33Z",
      "updated_at": "2018-06-18T13:43:33Z"
    },
    {
      "author": "lamw",
      "author_association": "NONE",
      "body": "Yes, this was executed on MacOS and I was hoping to have a generic solution that'll work across Windows, Mac & Linux. I'll give latest preview a try in a bit to see if that helps",
      "created_at": "2018-06-18T16:20:14Z",
      "updated_at": "2018-06-18T16:20:14Z"
    },
    {
      "author": "rmbolger",
      "author_association": "NONE",
      "body": "Lol, I knew @markekraus would be all over this. You are awesome.\r\n\r\n@lamw, here's some additional code to get the SHA256 thumbprint without needing the output file step and given the `$Certs` output from Mark's example.\r\n\r\n```powershell\r\n$sha256 = [Security.Cryptography.SHA256]::Create()\r\n$certBytes = $Certs[-1].Certificate.GetRawCertData()\r\n$hash = $sha256.ComputeHash($certBytes)\r\n$thumbprint = [BitConverter]::ToString($hash).Replace('-',':')\r\n```",
      "created_at": "2018-06-18T16:57:50Z",
      "updated_at": "2018-06-18T16:57:50Z"
    },
    {
      "author": "lamw",
      "author_association": "NONE",
      "body": "Thanks a bunch @rmbolger \r\n\r\nHere's quick/dirty function I just put together to verify on Windows PowerShell (still need to test this out on 6.1.0-preview.3)\r\n```\r\nFunction Get-SHA256Thumbprint {\r\n    param(\r\n    [Parameter(\r\n        Position=0,\r\n        Mandatory=$true,\r\n        ValueFromPipeline=$true,\r\n        ValueFromPipelineByPropertyName=$true)\r\n    ]\r\n    [Alias('FullName')]\r\n    [String]$URL\r\n    )\r\n\r\n    $Code = @'\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Net.Http;\r\nusing System.Net.Security;\r\nusing System.Security.Cryptography.X509Certificates;\r\n\r\nnamespace CertificateCapture\r\n{\r\n    public class Utility\r\n    {\r\n         public static Func<HttpRequestMessage,X509Certificate2,X509Chain,SslPolicyErrors,Boolean> ValidationCallback = \r\n            (message, cert, chain, errors) => {\r\n                var newCert = new X509Certificate2(cert);\r\n                var newChain = new X509Chain();\r\n                newChain.Build(newCert);\r\n                CapturedCertificates.Add(new CapturedCertificate(){\r\n                    Certificate =  newCert,\r\n                    CertificateChain = newChain,\r\n                    PolicyErrors = errors,\r\n                    URI = message.RequestUri\r\n                });\r\n                return true; \r\n            };\r\n        public static List<CapturedCertificate> CapturedCertificates = new List<CapturedCertificate>();\r\n    }\r\n\r\n    public class CapturedCertificate \r\n    {\r\n        public X509Certificate2 Certificate { get; set; }\r\n        public X509Chain CertificateChain { get; set; }\r\n        public SslPolicyErrors PolicyErrors { get; set; }\r\n        public Uri URI { get; set; }\r\n    }\r\n}\r\n'@\r\n    if ($PSEdition -ne 'Core'){\r\n        Add-Type -AssemblyName System.Net.Http\r\n        if (-not (\"CertificateCapture\" -as [type])) {\r\n            Add-Type $Code -ReferencedAssemblies System.Net.Http\r\n        }\r\n    } else {\r\n        if (-not (\"CertificateCapture\" -as [type])) {\r\n            Add-Type $Code\r\n        }\r\n    }\r\n\r\n    $Certs = [CertificateCapture.Utility]::CapturedCertificates\r\n\r\n    $Handler = [System.Net.Http.HttpClientHandler]::new()\r\n    $Handler.ServerCertificateCustomValidationCallback = [CertificateCapture.Utility]::ValidationCallback\r\n    $Client = [System.Net.Http.HttpClient]::new($Handler)\r\n    $Result = $Client.GetAsync($Url).Result\r\n\r\n    $sha256 = [Security.Cryptography.SHA256]::Create()\r\n    $certBytes = $Certs[-1].Certificate.GetRawCertData()\r\n    $hash = $sha256.ComputeHash($certBytes)\r\n    $thumbprint = [BitConverter]::ToString($hash).Replace('-',':')\r\n    return $thumbprint\r\n}\r\n\r\nGet-SHA256Thumbprint -URL \"https://google.com\"\r\n\r\nEB:81:11:96:DB:F7:3C:BA:64:66:7D:B5:C9:7D:A0:74:CE:7A:71:77:CD:5C:50:DE:BA:47:98:5B:8B:AC:A9:8E\r\n```\r\n\r\n",
      "created_at": "2018-06-18T17:31:27Z",
      "updated_at": "2018-06-18T17:31:27Z"
    }
  ],
  "created_at": "2018-06-17T14:12:36Z",
  "labels": [
    "Resolution-Answered"
  ],
  "number": 7092,
  "state": "closed",
  "title": "The type or namespace name 'ICertificatePolicy' could not be found (Extracting Thumbprint for SHA256)",
  "updated_at": "2018-06-18T17:31:28Z"
}