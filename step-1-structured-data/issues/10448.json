{
  "_url": "https://github.com/PowerShell/PowerShell/issues/10448",
  "author": "KirkMunro",
  "body": "I'm looking at bringing some of the functionality from the most popular modules I have written into native PowerShell when it is appropriate to do so.\r\n\r\n`Wait-Debugger` and DebugPx's `Enter-Debugger` command were both built at the same time, independently of one another. I always expected the native `Wait-Debugger` command would supercede `Enter-Debugger` at some point, but the way it entered the debugger on the statement following the `Wait-Debugger` command prevented it from supporting certain functionality. That limitation was removed when PR #8205 was merged. The debugger now stops on the `Wait-Debugger` command itself rather than on the statement following that command. With that in place, now is a good time to catch it up so that it supercedes `Enter-Debugger` in PowerShell 7 and later releases.\r\n\r\n# Summary of the new feature/enhancement\r\n\r\nAs a script author\r\nI want to use `Wait-Debugger` in a pipeline\r\nSo that I can attach a debugger in the location most appropriate for my needs.\r\n\r\nAs a script author\r\nI want to use a conditional scriptblock in a `Wait-Debugger` call\r\nSo that I can conditionally attach a debugger to a script.\r\n\r\nAs a script author\r\nI want to write a custom message to the host as I enter the debugger when a certain condition is met\r\nSo that I am reminded what happened when I attach a debugger to a script.\r\n\r\n# Proposed technical implementation details\r\n\r\nThis PR would add additional parameters to the `Wait-Debugger` command, and update that command for use in the pipeline. The parameters to consider adding include:\r\n\r\n```none\r\n[-ConditionScript] <scriptblock>\r\n[-Message <string>]\r\n[-InputObject <PSObject>]\r\n```\r\n\r\nThe code for these parameters is already in use in `Enter-Debugger` in DebugPx. It would simply be ported from that command in an appropriate way into `Wait-Debugger`, and hidden behind an experimental feature while people try it out.\r\n\r\n## Example 1: Using `Wait-Debugger` in a pipeline\r\n\r\nThis example demonstrates using `Wait-Debugger` in a pipeline, where the debugger will break automatically on each object as it passes through the pipeline.\r\n\r\n```powershell\r\nGet-Process | Wait-Debugger | Stop-Process -WhatIf\r\n```\r\n\r\nYou would most likely use `Wait-Debugger` in a pipeline with a condition, which you can see in the next example.\r\n\r\n## Example 2: Using `Wait-Debugger` with a condition script block\r\n\r\nThis example demonstrates using `Wait-Debugger` with a conditional script block. It will only wait for a debugger to attach if the condition has been met.\r\n\r\n```PowerShell\r\nWait-Debugger -ConditionScript {$x -eq $null}\r\n\r\nGet-Process | Wait-Debugger {$_.Id -eq $PID} | Stop-Process -WhatIf\r\n```\r\n\r\nThe first command will wait for a debugger to attach (or enter a breakpoint immediately if run locally), but only if `$x -eq $null` returns true.\r\n\r\nThe second command will wait for a debugger to attach (or enter a breakpoint immediately if run locally) if the current pipeline process ID is `$PID`. `-ConditionScript` is positional, allowing it to be used in the middle of a pipeline with great ease.\r\n\r\n## Example 3: Outputting a message in the host when a debugger is attached.\r\n\r\n```PowerShell\r\nforeach ($value in $myCollection) {\r\n    Wait-Debugger {$value.Name -eq $null} -Message 'It happened! The name of a collection item is null!'\r\n    # Do more things with $value here\r\n}\r\n```\r\n\r\n# Additional changes to consider:\r\n\r\n## Breakpoint alias\r\n\r\nIt would also be appropriate to add `breakpoint` as an alias for `Wait-Debugger`. Since `Wait-Debugger` is a command that you typically add temporarily to a script and then later remove it, and since the intent of that command is to trigger an on-demand breakpoint at that location, causing the debugger to wait for a remote debugger to attach, or entering the debugger immediately if the script is run locally, the `breakpoint` alias is appropriate to facilitate easier and more expressive use of this command. This alias is supported by DebugPx for `Enter-Debugger` already, and it makes it very convenient to work with the debugger.\r\n\r\nThere is an additional alias for `Enter-Debugger` in DebugPx: `bp`. While I love the simplicity of that alias, and while that alias gets heavy use by me personally (I don't have telemetry data from others at this time), I decided not to propose it be brought forward because we're cross platform and Linux has a `bp` command already. I don't want that conflict with existing commands.\r\n\r\n## Discoverability and the potential benefit in renaming `Wait-Debugger` as `Enter-Breakpoint`\r\n\r\nThere are some challenges with the `Wait-Debugger` name, as follows:\r\n\r\n* `Wait-Debugger` is not a very discoverable command name, because it's the only command that ships with PowerShell with a noun of `Debugger`.\r\n* It uses the verb `Wait`, which met the original intent well because it would cause a remote script to wait for a debugger to attach to it, but it also works in local scripts, in which case there is no wait, and that makes it a little confusing.\r\n* Non-developers are much less familiar with the concept of attaching a debugger.\r\n* From an end user's perspective, given the behavior in local and remote scripts, it seems like this command simply acts as a dynamic breakpoint that is declared in the script itself -- i.e. the command itself is a breakpoint. It seems less about waiting for and attaching a debugger -- that's what you do once you hit a breakpoint, but only with a remote script.\r\n\r\nSimilarly, `Enter-Debugger` shares a few of those challenges. I chose the verb `Enter` for `Enter-Debugger` because it felt more descriptive (it causes PowerShell to enter the debugger in the current location), but it also shares the discoverability issues since it is a \"lone\" `Debugger` command (although that makes two, there should only be one going forward).\r\n\r\nWith those thoughts in mind, I find myself wondering If the command would be better named as `Enter-Breakpoint`, with aliases of `breakpoint` and `etbp` (that isn't a Linux command, and it follows the recommended alias naming making it easy to use and remember). This would of course have a `Wait-Debugger` alias for backwards compatibility.\r\n\r\nThis may not seem necessary, but renaming the command could provide the following benefits:\r\n\r\n* It groups the command with other like commands (the `Breakpoint` noun commands), which is a significant benefit for discoverability.\r\n* It focuses a learner's attention on one concept: breakpoints.\r\n* It describes what the command does from an end user's perspective.\r\n* It doesn't confuse folks with the verb `Wait`, because all breakpoints work the same way, and waiting only comes into play when a script is running remotely. When local, they trigger according to their definition/action. When remote, when they trigger you need to attach a debugger to the remote process using `Debug-Job`, `Debug-Runspace`, etc.\r\n\r\nYou might ask yourself why you would ever use an `Enter-Breakpoint` command in a script when you can actually set breakpoints. The answer to that question is simple: it may be conceptually easier for folks to drop a breakpoint into a script as a command, especially if you want that break to be conditional, than it is to set up a breakpoint to stop in the right location under the right conditions using an IDE.",
  "closed_at": null,
  "comments": [
    {
      "author": "jhoneill",
      "author_association": "NONE",
      "body": "Following on from #10873 ... **Short version: I think this should be done, and would be happy if it was done as described** \r\nLong version: \r\nThis does two things which I think are obviously missing from `wait-debugger` , conditional break, and printing a message about the reason for the break. I can't fault the way it does them, which has some history of experience behind it. In addition the pipeline/passthru support allows a scenario I hadn't thought about.   \r\n\r\nNames ... `-ConditionScript` feels clunky. Other cmdlets use `scriptblock`  (Doh!) or names which this parameter is _not_ -like  FilterScript (nothing is filtered out), so there's nothing obvious to re-use. I'd probably use \"when\" but tbh I don't think that's any better, and means an alias won't be enough for anyone switching over from `enter-debugger`. \r\nOn aliases, `breakpoint `is a good alias; it looks and functions like a language keyword, and it's self-explanatory. We're either writing \"I want a break point here\" (`breakpoint`) or \"go away to the debugger and come back\", in verb-noun form - `wait-debugger` needs to keep working and a case can be made for `Enter-Debugger` (obviously) among others. \r\nOn the _noun_ side I don't see a single use of of the noun \"debugger\" as a problem. Being pedantic, a breakpoint is a marker which triggers something, you can mark/unmark as a break-point (add/set/remove) but you can't enter/invoke/wait-for one. So I'd stick with `debugger`.   \r\nOn _verbs_: `Enter` and `Wait `both seem valid to me; the script waits for the debugger to _return_ ;  the action in the debugger is \"continue\" and wait/continue make a good pair. Depending on what has been stepped through things may not resume at the same place so it is not a perfect \"pause & resume\" but it is good enough.  Entering and exiting the debugger also sounds fine in normal language (the sense of go-into, come-out-of _works_ ), pedants might say the debugger doesn't _exit_  as such, but it's good enough.  Having one of those as an alias and the other as the canonical name is fine - I don't think there is a compelling case for changing the canonical name, so I'd have `Enter` as the alias.   Other possible verbs ..  `Start `tends to be something asynchronous, and might be mistaken for the command to debug a job/runspace etc, so the other 2 are better. `Invoke `tends to be \"do something I don't have a verb for\"  There is a `debug `verb - PowerShell cmdlets use it in the sense of \"attach a debugger to this running thing\", so I don't really like `Debug-Script`. \r\n\r\nDiscovery: I'd use `get-command *debug*` or `get-command *breakpoint*` so `wait-debugger` with an alias of `breakpoint `works for me: I can't think myself into the mind of someone taking their first steps with breakpoints and debuggers, but I think those are probably still the keywords you'd want a search to hit.\r\n",
      "created_at": "2019-10-25T09:32:39Z",
      "updated_at": "2019-10-25T09:32:39Z"
    }
  ],
  "created_at": "2019-08-26T20:35:43Z",
  "labels": [
    "Issue-Enhancement"
  ],
  "number": 10448,
  "state": "open",
  "title": "Bring forward `Enter-Debugger` features into `Wait-Debugger`",
  "updated_at": "2019-10-25T09:32:39Z"
}