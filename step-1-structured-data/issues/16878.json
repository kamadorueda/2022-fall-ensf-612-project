{
  "_url": "https://github.com/PowerShell/PowerShell/issues/16878",
  "author": "iRon7",
  "body": "### Summary of the new feature / enhancement\r\n\r\nAs stated in the Stackoverflow answer [**Adding and Removing Xmlnode using**](https://stackoverflow.com/a/71092760/1701026), the PowerShell `Xml` dot referencing is a nice feature but is (to my opinion) a little overdone where it returns a `string` (rather than a `XmlElement`) in case it concerns a leaf node. This leads to inconsistency between the siblings and disconnects the object from the `xml` structure as noted in #11922 [**XML dot notation with indexed access doesn't work with assignments**](https://github.com/PowerShell/PowerShell/issues/11922).\r\nWithout changing the actual `string` type (which would certainly be a break change), it could be considered *decorate* the string leaf with the same members (basically all methods) as the `XmlElement`.\r\nFor this, I have written a (quick & dirty) `Get-Node` function that adds the concerned methods and shows how this might help to overcome the current inconsistency (between a XmlElement and a String) and get back into the `xml` structure:\r\n\r\n### `Get-Node`\r\n<details>\r\n  <summary>As PowerShell engine is able to change the xml node is either an XmlElement or String it is assumed that it should be able to decorate the string at the same moment.</summary>\r\n\r\n```PowerShell\r\nfunction Get-Node {\r\n    [CmdletBinding()]Param (\r\n        [String]$Name,\r\n        [Parameter(ValueFromPipeLine = $True)][Xml.XmlElement]$Parent\r\n    )\r\n    process {\r\n        $Nodes = $Parent.SelectNodes($Name)\r\n        $Index = 0\r\n        ForEach ($Child in $Parent.$Name) {\r\n            if ($Child -is [String]) {\r\n                $Child = $Child |Add-Member -MemberType NoteProperty -Name 'Node' -Value $Nodes[$index] -PassThru\r\n                ForEach ($Name in $Nodes[$Index].PSObject.Methods.Name) {\r\n                    If ($Child.PSObject.Methods.Name -NotContains $Name) {\r\n                        $Method = [ScriptBlock]::Create(\"if (`$Args) { `$This.Node.$Name(`$Args) } else { `$This.Node.$Name() }\")\r\n                        $Child = $Child |Add-Member -MemberType ScriptMethod -Name $Name -Value $Method -PassThru\r\n                    }\r\n                }\r\n            }\r\n            $Child\r\n            $Index++\r\n        }\r\n    }\r\n}\r\n```\r\n</details>\r\n\r\n```PowerShell\r\n$Xml = [Xml]@'\r\n<Lvl1>\r\n  <Lvl2>a</Lvl2>\r\n  <Lvl2>b</Lvl2>\r\n  <Lvl2>  \r\n    <Lvl3>1</Lvl3>\r\n    <Lvl3>2</Lvl3>\r\n  </Lvl2>\r\n</Lvl1>\r\n'@\r\n\r\n$Lvl1Nodes = $Xml.Lvl1 |Get-Node('Lvl2') # For this, I would like use dot reference syntax: $Lvl1Nodes = $Xml.Lvl1.Lvl2\r\n$Lvl1Nodes\r\na\r\nb\r\n\r\nLvl3\r\n----\r\n{1, 2}\r\n```\r\n\r\nNote that e.g. the first `Lvl2` node is still a `string` that equals 'a':\r\n```PowerShell\r\n$Lvl1Nodes[0] -is [String]\r\nTrue\r\n$Lvl1Nodes[0] -eq 'a'\r\nTrue\r\n```\r\n\r\nBut now I am able to refer back into the `Xml` structure as concerned in #11922:\r\n```PowerShell\r\n$Lvl1Nodes[0].set_InnerText('Test')\r\n[System.Xml.Linq.XDocument]::Parse($Xml.OuterXml).ToString()\r\n\r\n<Lvl1>\r\n  <Lvl2>Test</Lvl2>\r\n  <Lvl2>b</Lvl2>\r\n  <Lvl2>\r\n    <Lvl3>1</Lvl3>\r\n    <Lvl3>2</Lvl3>\r\n  </Lvl2>\r\n</Lvl1>\r\n```\r\n\r\nAnd the nodes act consistently (in e.g. selecting all of them to remove them from the parent):\r\n```PowerShell\r\n$Lvl1Nodes.SelectNodes('.').ForEach{ $Null = $_.ParentNode.RemoveChild($_) }\r\n[System.Xml.Linq.XDocument]::Parse($Xml.OuterXml).ToString()\r\n\r\n<Lvl1></Lvl1>\r\n```\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Engine WG discussed this issue today.\r\n\r\nThe suggestion of ETS properties is unlikely to be a feasible solution here, because `[string]` is treated by the ETS system almost like a value type (like `[int]`, for example). The result of this is that ETS properties and methods applied to strings don't \"stick\"; in many cases, simply saving the value into a new variable causes the ETS properties to be 'lost' and not be present on the value in the new variable, among other possible sticking points.\r\n\r\nIt might be worth looking into whether it's possible to have the leaf nodes behave as normal XmlElement entities (retain their original type) while adding some logic to the conversion paths for XmlElement in order to make these leaf nodes behave more like ordinary strings when needed.\r\n\r\nThe implementation is likely to require significant effort as it would require changes to the XmlAdapter, and it's not currently a priority. We're leaving this as up for grabs for the time being. We would need to see an initial prototype that attempts to solve this issue before we can meaningfully evaluate whether the change is something we can take on. It is likely an RFC would be required at some point as well so that all the details and any necessary breaking changes can be properly evaluated.",
      "created_at": "2022-02-18T00:42:50Z",
      "updated_at": "2022-02-18T00:42:50Z"
    }
  ],
  "created_at": "2022-02-13T10:14:07Z",
  "number": 16878,
  "state": "open",
  "title": "Decorate dot selected `Xml` strings (leaves) with `XmlElement` methods",
  "updated_at": "2022-02-18T00:42:50Z"
}