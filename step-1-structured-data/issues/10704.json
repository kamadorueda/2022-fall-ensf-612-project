{
  "_url": "https://github.com/PowerShell/PowerShell/issues/10704",
  "author": "KirkMunro",
  "body": "# PR Summary\r\n\r\nFix #10656.\r\n\r\n## PR Context\r\n\r\nMads Torgersen rightly pointed out at [this point](https://www.youtube.com/watch?v=TJiLhRPgyq4&feature=youtu.be&list=PLReL099Y5nRd04p81Q7p5TtyjCrj9tz1t&t=373) in a .NET Conf 2019 demonstration he delivered that testing for `$null` using `-is` is more accurate than testing for `$null` using `-eq`.\r\n\r\nPowerShell would benefit from having the same support, such that users can check if an object is or is not null by invoking `$x -is $null` or `$x -isnot $null`, or `Where-Object Property -is $null` or `Where-Object Property -isnot $null`, for two reasons:\r\n\r\n1. Code written this way is very discriptive, and matches the way we speak about what is actually happening when we test for `$null`.\r\n1. More importantly, this allows for comparisons of any object to `$null`, _including collections_. Before this change, if you want to test whether or not a collection is `$null`, you have to place the `$null` on the left-hand side of the operator, _which is not possible in `Where-Object`_. With this change in place, you can simply keep `$null` on the right-hand side of the `-is` and `-isnot` operators, regardless of the type of object on the left-hand side that you are comparing to `$null`.\r\n\r\nHere are the new patterns that will be supported once this PR is merged:\r\n\r\n```powershell\r\n$x -is $null\r\n$y -isnot $null\r\n$collection | where Property -is $null\r\n$collection | where Property -isnot $null\r\n```\r\n\r\nNote that `-is $null` will return `$true` if the left hand side is `$null`, `[DBNull]::Value`, `[NullString]::Value`, or `[System.Management.Automation.Internal.AutomationNull]::Value`.\r\n\r\nAlso note that this only works when you use a null literal on the right-hand side of `-is` and `-isnot`, regardless of whether you use the operators or `Where-Object`. The explicit check for a null literal is necessary to prevent the use of other variables or subexpressions on the right-hand side.\r\n\r\n## PR Checklist\r\n\r\n- [X] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [X] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [X] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` or `[ WIP ]` to the beginning of the title (the `WIP` bot will keep its status check at `Pending` while the prefix is present) and remove the prefix when the PR is ready.\r\n- **[Breaking changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)**\r\n    - [X] None\r\n    - **OR**\r\n    - [ ] [Experimental feature(s) needed](https://github.com/MicrosoftDocs/PowerShell-Docs/blob/staging/reference/6/Microsoft.PowerShell.Core/About/about_Experimental_Features.md)\r\n        - [ ] Experimental feature name(s): <!-- Experimental feature name(s) here -->\r\n- **User-facing changes**\r\n    - [ ] Not Applicable\r\n    - **OR**\r\n    - [X] [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [X] Issue filed: https://github.com/MicrosoftDocs/PowerShell-Docs/issues/4890\r\n- **Testing - New and feature**\r\n    - [ ] N/A or can only be tested interactively\r\n    - **OR**\r\n    - [X] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n- **Tooling**\r\n    - [X] I have considered the user experience from a tooling perspective and don't believe tooling will be impacted.\r\n    - **OR**\r\n    - [x] I have considered the user experience from a tooling perspective and enumerated concerns in the summary. This may include:\r\n        - Impact on [PowerShell Editor Services](https://github.com/PowerShell/PowerShellEditorServices) which is used in the [PowerShell extension](https://github.com/PowerShell/vscode-powershell) for VSCode (which runs in a different PS Host).\r\n        - Impact on Completions (both in the console and in editors) - one of PowerShell's most powerful features.\r\n        - Impact on [PSScriptAnalyzer](https://github.com/PowerShell/PSScriptAnalyzer) (which provides linting & formatting in the editor extensions).\r\n        - Impact on [EditorSyntax](https://github.com/PowerShell/EditorSyntax) (which provides syntax highlighting with in VSCode, GitHub, and many other editors).\r\n",
  "closed_at": "2021-04-24T13:17:22Z",
  "comments": [
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@KirkMunro should we provide support here also for the null-like values `[dbnull]::Value` and `[NullString]::Value` (or indeed possibly even `[AutomationNull]::Value`?)\r\n\r\nGiven the decisions in #9561, I would say that we probably should have this operation also treat the null-representatives as null via `LanguagePrimitives.IsNullLike(value)`. If distinction is required, `$value -is [dbnull]` will still be functional to make the distinction, but in most cases we don't need that distinction, I would think?\r\n\r\n/cc @daxian-dbw ",
      "created_at": "2019-10-04T19:15:29Z",
      "updated_at": "2019-10-04T19:15:29Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@PoshChan Please restart macos",
      "created_at": "2019-10-04T20:42:07Z",
      "updated_at": "2019-10-04T20:42:07Z"
    },
    {
      "author": "PoshChan",
      "author_association": "COLLABORATOR",
      "body": "@KirkMunro, successfully started retry of `PowerShell-CI-macOS`",
      "created_at": "2019-10-04T20:42:31Z",
      "updated_at": "2019-10-04T20:42:31Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@vexx32 So you're proposing this update invoke `LanguagePrimitives.IsNullLike` instead of just checking if the lhs is null? That seems to make sense to me, but technically that would make this a breaking change. It would be good to get @daxian-dbw's opinion to be sure that's the desired/expected behavior.\r\n\r\nAside: `LanguagePrimitives.IsNullLike` should probably check `IsNull` first, before checking `DBNull.Value` or `NullString.Value`, right, since the most common matches in PowerShell would be `null` or `AutomationNull.Value`. I'd also put `NullString.Value` before `DBNull.Value`. That way the comparisons are in order from most likely to least likely.",
      "created_at": "2019-10-04T20:51:48Z",
      "updated_at": "2019-10-04T20:55:29Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@KirkMunro yep, that's the conclusion we came to in #10422 which is currently stalled pending a question on how we determine equality and what matters to it when using `-ge`/`-le` instead of `-eq`; I believe the same change you recommend is made there, but that PR is yet to be merged.",
      "created_at": "2019-10-04T20:57:36Z",
      "updated_at": "2019-10-04T20:57:51Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I'd expect consistency with `-eq` for NullDB and etc.",
      "created_at": "2019-10-08T06:01:07Z",
      "updated_at": "2019-10-08T06:01:07Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov Are you're suggesting that we should support `[NullString]::Value`, `[DBNull]::Value` and `[AutomationNull]::Value` on the right-hand side of `-is` as well? Because there is a slight difference between `$null` and these values.\r\n\r\nWhen using `-eq`, to test for equality with these other null values, you need to use the singleton returned from the `Value` static member. When using `-is`, however, it is more natural and accurate to use the object type on the right-hand side. For example:\r\n\r\n```powershell\r\n$x = [AutomationNull]::Value\r\n$x -is [AutomationNull] # returns true\r\n$x -is [AutomationNull]::Value # returns an error because the right-hand side is not a type or null\r\n```\r\n\r\nI believe the above behavior is desirable and expected.\r\n\r\nThe only outstanding question I have on this PR is whether or not `$x -is $null` should return true when `$x` is one of the singleton nulls.",
      "created_at": "2019-10-09T13:51:03Z",
      "updated_at": "2019-10-09T13:52:42Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@KirkMunro i would that that if given the type itself to test, it would follow current behaviour, and if given a null singleton value, it should follow the IsNullLike pattern. Reason being is that `$nullLike -eq $null` will return true for all of them, and it would a point of confusion for this semantic to differ here, I think.",
      "created_at": "2019-10-09T13:56:37Z",
      "updated_at": "2019-10-09T13:56:37Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> $x -is [AutomationNull]::Value # returns an error because the right-hand side is not a type or null\r\n\r\nnull is not type too. So it is under question too. If we allow null then we should allow [AutomationNull]::Value too. Or disable null.\r\nAnd if we allow values why do not we allow:\r\n```powershell\r\n$x=\"abc\"\r\n$x -is \"abc\" # -> True\r\n```",
      "created_at": "2019-10-09T14:34:14Z",
      "updated_at": "2019-10-09T14:34:14Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "Using the `-is` operator is the most accurate and correct way to test for `$null`, because it avoids running user code (operator overloads), and simply checks if a value is null. That's why this PR was implemented. C# added support for `is null` in C# 7, and that is the best practice there. We're just following their lead. It also promotes better code because it keeps the operand on the right-hand side (collection unwrapping does not come into play with `-is`).\r\n\r\nThe other nulls already work using `-is`, with their types.\r\n\r\nYour question @iSazonov highlights exactly why I think we shouldn't support `[AutomationNull]::Value` and the other non-`$null` nulls on the right-hand side of `-is`: because it opens a can of worms. If we're going to support one value on the right-hand side of `-is`, then why not support all values on the right-hand side of `-is`? i.e. After checking for `$null` or instances of `Type`, why not fall back to an equality comparison?\r\n\r\nThe answer to that question is simple: intent/ambiguity.\r\n\r\n`-is $null` is not a test for equality. It's a check to see if something is null.\r\n`-is [string]` is not a test for equality either. It's a test to see if something is a string.\r\n\r\nBut what about the following syntax:\r\n\r\n`is 'string'` is a test to see if something is a string. The 'string' string gets converted into a type.\r\n\r\nIf you want to fall back to `-eq` when the right-hand side is not null and not a type, suddenly you have an ambiguity issue. When the right-hand side is a string, which is supported today, and when that string is also a type name are you checking if something is of type string or if something is a string that contains the value \"string\"?\r\n\r\nBy forcing tests for value equality to be done using the `-eq` or `-neq` operators, the intent is clear and unambiguous.",
      "created_at": "2019-10-09T15:03:14Z",
      "updated_at": "2019-10-09T17:17:54Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@vexx32 To your point, I think it makes sense when checking for `-is $null` to also match on the other null types. e.g. `[AutomationNull]::value -is $null` should return true IMHO. That allows scripters to avoid thinking about which null they are dealing with. If they want to test for a specific null other than `$null`, they can always use the type (i.e. `[NullString]`, `[DBNull]`, etc.).",
      "created_at": "2019-10-09T15:06:48Z",
      "updated_at": "2019-10-09T17:45:54Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "Is the final proposal then that:\r\n\r\n- The RHS of `-is` must be either a type object or `$null`\r\n- Other RHS expressions, including DBNull, AutomationNull and NullString, are errors\r\n- When the RHS is a type, it checks the LHS expression for being that type (established behaviour)\r\n- When the RHS is `$null`, it checks the LHS for being null-like (`null`, DBNull, AutomationNull, NullString) (new behaviour)",
      "created_at": "2019-10-09T16:30:57Z",
      "updated_at": "2019-10-09T16:30:57Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@rjmholt That's almost 100% correct.\r\n\r\n> * Other RHS expressions, including DBNull, AutomationNull and NullString, are errors\r\n\r\n`[DBNull]::Value`, `[NullString]::Value`, and `[S.M.A.Internal.AutomationNull]::Value` on the right-hand side are errors, just like any non-null, non-type value. The `[DBNull]`, `[NullString]`, and `[AutomationNull]` types are supported on the right-hand side though, because they are types.\r\n\r\nThe other statements you listed were accurate, and the code and tests were just updated to support that proposal.\r\n",
      "created_at": "2019-10-09T17:14:56Z",
      "updated_at": "2019-10-09T17:15:09Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": ">  If they want to test for a specific null other than $null, they can always use the type (i.e. [AutomationNull], [DBNull], etc.).\r\n\r\nFor consistency we could define [Null] type.\r\nIt is not clear why do we follow C# pattern.\r\n",
      "created_at": "2019-10-09T17:39:56Z",
      "updated_at": "2019-10-09T17:39:56Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "@KirkMunro sorry, was using the type name as a shorthand for the singleton value.\r\n\r\nOk, that sounds good to me. I certainly agree that not allowing the alt-null values on the RHS is the way to go.",
      "created_at": "2019-10-09T18:04:29Z",
      "updated_at": "2019-10-09T18:04:29Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "This is almost ready to go, but there are some interesting questions worth thinking out loud:\r\n\r\nConsider this:\r\n\r\n```powershell\r\n$w = $null\r\n$x = [System.Management.Automation.Internal.AutomationNull]::Value\r\n$y = [DBNull]::Value\r\n$z = [NullString]::Value\r\n```\r\n\r\nI originally expected with those variables that the following would all be true:\r\n\r\n```powershell\r\n$w -is $null and $x -is $null -and $y -is $null -and $z -is $null\r\n$x -is [System.Management.Automation.Internal.AutomationNull]\r\n$y -is [DBNull]\r\n$z -is [NullString]\r\n```\r\n\r\nAll nulls are recognized as null using `-is $null`, but the \"special\" nulls can also be identified using their types.\r\n\r\nIn practice, the test for `-is [S.M.A.Internal.AutomationNull]` fails.\r\n\r\nDo we expect `$x -is [System.Management.Automation.Internal.AutomationNull]` to return true? At first glance it seems that it would be very clearly incorrect if it returned false, but `AutomationNull` is used in PowerShell to represent nothing (not even `$null`), so maybe the test returning false is expected, because you simply cannot compare `AutomationNull` with anything at all.\r\n\r\nIf that's the case, should `[S.M.A.Internal.AutomationNull]::Value -eq $null` return true (which it does because of how `IsNullLike` is implemented)? Because that's not actually true. See:\r\n\r\n```PowerShell\r\n$a1 = @([System.Management.Automation.Internal.AutomationNull]::Value)\r\n$a2 = @($null)\r\n$a1.Count -eq $a2.Count # Returns false, because the first array is empty.\r\n```\r\n\r\nOn the other hand, `[DBNull]::Value` and `[NullString]::Value` are actually objects that represent `$null`, so those comparisons make sense.\r\n\r\nAlso, by leveraging `IsNullLike`, we lose the ability to uniquely distinguish an actual null from the other null values, unless we do this:\r\n\r\n```powershell\r\n$w -is $null -and\r\n$w -isnot [System.Management.Automation.Internal.AutomationNull] -and\r\n$w -isnot [DBNull] -and\r\n$w -isnot [NullString]\r\n```\r\n\r\n(Minus the second test if that's not really a valid test since `AutomationNull` is really nothing)\r\n\r\nDoes that matter? Probably not, but I wanted to put the question out there.\r\n\r\nBased on all of this thought process, I think we're wrong to suggest that `[System.Management.Automation.Internal.AutomationNull]::Value` should equal `$null` and be recogized as null when compared to `-is $null`. It's actually not null. It's less than that. It's nothing.\r\n\r\n@vexx32 You had to suggest I use `IsNullLike`, didn't you??? \ud83d\ude22 \ud83e\udd23 \r\n\r\nThis strangely reminds me the the discussion between Vizzini and the Dread Pirate Roberts in The Princess Bride. \u2620\ufe0f ",
      "created_at": "2019-10-09T18:21:07Z",
      "updated_at": "2019-10-12T18:43:00Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov Personally I strongly prefer not muddying the waters for the non-developer scripters out there by having a `[Null]` type in addition to `$null`. I think it adds little value, and it is much easier for folks to just use `$null` in all cases when they care about whether something is or is not some form of `$null`.",
      "created_at": "2019-10-09T18:23:59Z",
      "updated_at": "2019-10-09T18:23:59Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@KirkMunro actually, there already _is_ `Null` type. It's hiding in `LanguagePrimitives`, if I recall correctly, and is used for some of its internal bits and pieces (it takes the place of a `Type` argument when the passed value is `null`, for example).\r\n\r\nFor the purposes of being able to distinguish true `$null` from the others, end users do have access to `LanguagePrimitives.IsNull()`. However, this by design does not distinguish between AutomationNull and true null. There isn't supposed to be a difference in PowerShell, and there's not usually a meaningful reason or need to distinguish null and AutomationNull.\r\n\r\nIf there is such a need, we could potentially expose the (currently `internal` or `private` iirc) `[Null]` type from `LanguagePrimitives` with its own type accelerator (we could have typecast operations behave the same as with `[void]` for example) and have it be recognised by `-is` and `-isnot`.\r\n\r\nBut given we do already have access to `IsNull()` from within PowerShell there may not be a pressing need?",
      "created_at": "2019-10-09T19:20:51Z",
      "updated_at": "2019-10-09T19:21:58Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "I've changed this PR to WIP, pending the merge of #10769 -- that PR is required so that internally within the `IsNullLike` method that this PR uses, we compare against null using `is null` instead of `== null`. Once that PR is merged I will change this back to ready for merge.",
      "created_at": "2019-10-11T11:52:10Z",
      "updated_at": "2019-10-12T18:42:16Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "Also, regarding `[S.M.A.Internal.AutomationNull]` and the fact that you can't test for it by using `-is [System.Management.Automation.Internal.AutomationNull]`, users can test for automation null once these changes are merged using something like the following:\r\n\r\n```powershell\r\n$aNull = [System.Management.Automation.Internal.AutomationNull]::Value\r\n# How to check if $aNull is AutomationNull:\r\n$aNull -is $null -and $aNull -is [PSObject]\r\n```\r\n\r\nIf we prefer, I can make `$aNull -is [System.Management.Automation.Internal.AutomationNull]` return true as well (I've worked out the code locally for that and stashed it), but technically that's not true because `[S.M.A.Internal.AutomationNull]` is a static class and `[S.M.A.Internal.AutomationNull]::Value` is actually a singleton naked `PSObject` in PowerShell. Although, when we get into a technical discussion, by making `[DBNull]::Value -is $null` return true, we're technically lying there as well because it is not null -- it's an instance of `[DBNull]`. The same holds true for `[NullString]::value -is $null`.\r\n\r\nI can't help but wonder which of these approaches would be better:\r\n\r\n1. To put a stake in the ground that `-is` doesn't lie, period, in which case this PR can simply add support for `-is $null` and make that only return true if the left-hand side is actually null.\r\n\r\n1. To lie for the sake of much easier scripting, allowing any null-like instance to be identified as `$null`, which I added support for based on @vexx32's comments.\r\n\r\nIf we feel the latter is better, would it also be better for scripters if they could more easily identify what PowerShell considers to be `[S.M.A.Internal.AutomationNull]` for those rare cases where they are troubleshooting something and need see if that's what they're really dealing with by allowing it to be identified using `-is [System.Management.Automation.Internal.AutomationNull]`?\r\n\r\n@rjmholt: I know you agreed already to what is in place within this PR, but I'm curious to hear your thoughts on this.",
      "created_at": "2019-10-11T13:13:20Z",
      "updated_at": "2019-10-12T18:42:09Z"
    },
    {
      "author": "TylerLeonhardt",
      "author_association": "MEMBER",
      "body": "This issue has changes that could potentially change syntax. Please consider adding this feature to [EditorSyntax](https://github.com/PowerShell/EditorSyntax) which is used for syntax highlighting in GitHub, Visual Studio Code, Atom, Sublime Text, and many more locations.\r\n\r\nConsistent syntax highlighting is very important for the language and a feature isn't \"complete\" until syntax highlighting is what is expected.\r\n\r\nIf you can't contribute to [EditorSyntax](https://github.com/PowerShell/EditorSyntax), at least open an issue to track the work - however, please note, that no one is actively working on the repo and so the work will likely not get done in a timely manner.\r\n\r\nWe hope that you consider contributing to [EditorSyntax](https://github.com/PowerShell/EditorSyntax).\r\n\r\n(note this is copy/pasted text for any change that looks like it could impact EditorSyntax - and will be a bot in the future)",
      "created_at": "2019-10-12T14:29:40Z",
      "updated_at": "2019-10-12T14:29:40Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@TylerLeonhardt Can you explain how this impacts EditorSyntax in a non-copy/paste way? This doesn't add new keywords. It just modifies what is supported on the right-hand side of the `-is`/`-isnot` operators, allowing `$null` in addition to a type name. Given that is the case, it doesn't seem to me that this impacts EditorSyntax at all. Please confirm.",
      "created_at": "2019-10-12T18:20:25Z",
      "updated_at": "2019-10-12T18:20:25Z"
    },
    {
      "author": "TylerLeonhardt",
      "author_association": "MEMBER",
      "body": "Yep you're right. Missed that detail. Since you're not changing syntax, EditorSyntax is unaffected. Thanks! ",
      "created_at": "2019-10-12T18:35:38Z",
      "updated_at": "2019-10-12T18:35:38Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "All previous discussions and confusion around `AutomationNull` have been resolved at this point, and after determining that this PR is not dependent on #10769 (it just gives a slight performance boost to comparisons against `$null`), this PR is good to go. I have also updated the description above to explain more accurately what is being done and why.",
      "created_at": "2019-10-12T18:44:54Z",
      "updated_at": "2019-10-12T18:53:52Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> When the RHS is `$null`, it checks the LHS for being null-like\r\n\r\nPlease reconsider this decision: \r\n\r\nThe `-is` operator is about unambiguous type testing, and treating all null-like values the same in this context takes away the ability to test for `$null` specifically, which you could previously do with `$null -eq ...`, but which will no longer work unambiguously after https://github.com/PowerShell/PowerShell/pull/10422 is merged.\r\n\r\nI propose the following division of labor:\r\n\r\n* `-is $null` is only true for `$null` specifically.\r\n\r\n* null-like values can be tested for via their respective types (`-is [DbNull]`, ...), which already works _except_ for `AutomationNull`, unfortunately.\r\n\r\n* Use `$null -eq ...` as a catch-all test for all null-like values.\r\n\r\n",
      "created_at": "2019-10-15T05:32:10Z",
      "updated_at": "2019-10-15T05:33:26Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 I suppose that really depends on whether making the distinction has significant value.\r\n\r\nAre there cases where making the distinction is valuable, to the point that slightly more unusual tests are unwarranted? Even with this change, you can test for true null with `$null -isnot [PSObject]` and a few other expressions.\r\n\r\nHowever, keep in mind that we _already_ treat null equivalently to AutomationNull.Value in all conversion paths and binders and this would likely be no different. In light of that, I think it makes the most sense to be agnostic about the _type_ of null we're handling. A null value is a null value, regardless of the implementation detail.",
      "created_at": "2019-10-15T10:54:49Z",
      "updated_at": "2019-10-15T10:54:49Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> whether making the distinction has significant value.\r\n\r\nGenerally speaking: \r\n\r\n* If I explicitly test for a _type_, I neither want nor expect \"fuzziness\" (and the only true _non-type_ is `$null`).\r\n\r\n* If I use `-eq`, I expect and typically welcome on-demand type coercions.\r\n\r\nTherefore, `-eq` strikes me as the place to treat all null-like values the same, but not `-is`.\r\n\r\nIn particular, the distinction between `$null` and `AutomationNull` has _behavioral implications_ (enumeration/non-enumeration in the pipeline - see https://github.com/PowerShell/PowerShell/issues/9997#issuecomment-505296556 and https://github.com/PowerShell/PowerShell/issues/9997#issuecomment-506582327), so it is important to be able to tell the difference.\r\n\r\nAnd, to reiterate, that requires fixing the currently broken behavior:\r\n\r\n```powershell\r\n# Currently broken\r\n(& {}) -is  [System.Management.Automation.Internal.AutomationNull]  | Should -BeTrue\r\n```\r\n\r\nArcane and/or cumbersome workarounds such as `$null -isnot [PSObject]` and `$null -eq $v -and @($v).Count -eq 0` are unsatisfactory. \r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2019-10-15T12:56:00Z",
      "updated_at": "2019-10-15T13:00:37Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": ">  I think it probably prudent for -is $null to at least include AutomationNull.Value; \r\n\r\nSince they _are not_ the same and - situationally - _do not behave_ the same (which is something we cannot fix without breaking backward compatibility), they shouldn't be treated the same in the context of explicitly inspecting a value's _type_.\r\n\r\nUsing `-is` is an _advanced_ use case - less experienced scripters may never even have to deal with types explicitly.\r\n\r\nBy contrast, people who do use `-is` (and `-as` - see #4343), coming from a world of strict typing, I think will expect precision there.\r\n\r\nTo answer the \"is it null-like\" question, the following tests, which do not require `-is`, are available:\r\n\r\n```powershell\r\n# Strictest\r\nif ($null -eq $obj) { ...\r\n\r\n# Only works as expected with a scalar LHS\r\nif ($obj -eq $null) { ...\r\n\r\n# Loosest - also met by numerically 0 values and empty collection objects\r\nif (-not $obj) { ...\r\n```\r\n\r\n----\r\n\r\nAll that said:\r\n\r\nI can see the appeal in making `... -is $null` the new idiom to test for _all_ null-like values, because it is less awkward than `$null -eq ...`.\r\n\r\nI suppose as long as the explicit type tests work for the null-like types that aren't actually `$null` - such as `... -is [AutomationNull]` - so you can discover the difference if needed, that would work.  However, you then wouldn't need get a _direct_ \"is-it-really-`$null`\" test, but I guess the more common case would be to test for a null-like value that _isn't_ `$null`.\r\n",
      "created_at": "2019-10-15T13:26:41Z",
      "updated_at": "2019-10-15T13:26:41Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@mklement0 I've gone back and forth on this. It's worth presenting both perspectives I've had and then letting others decide how we want to go.\r\n\r\nFor an inexperienced scripter that doesn't understand or care to understand that there are different types of null, the simplicity of having `-is $null` compare against `$null` and the other three null-like types all at once is beneficial because it hides that extra complexity from them.\r\n\r\nFor a more experienced scripter/developer, being able to identify a specific type of `$null` is also beneficial, but I believe that...:\r\n\r\n1. ...this is something they would typically do when troubleshooting a script, not something they would do in their script, with the possibility of some exceptions here and there where they really want to identify what type of `$null` they're looking at in an actual script (but I think that scenario would be very uncommon).\r\n\r\n1. ...more experienced scripters/developers can learn how to identify the specific types of nulls much more easily than a less experienced scripter can learn and truly understand that there are different types of nulls.\r\n\r\nThat is why I'm currently on the side of the fence that `is $null` should invoke `LanguagePrimitives.IsNullLike` internally -- it keeps things simple for the less experienced, while still allowing more experienced folks to identify a specific type of `$null` if and when they need to.\r\n\r\nThe following table shows how users can identify the various `$null`'s depending on how the final PR gets implemented here:\r\n\r\n|Null type|Treat `-is $null` as `is null`|Treat `-is $null` as `LanguagePrimitives.IsNullLike`|\r\n|--|--|--|\r\n|Any|`$value -is $null -or $value -is [DBNull] -or $value -is [NullString] -or ($null -eq $value -and $value -is [PSObject])` <sup>1</sup>|`$value -is $null`|\r\n|`$null`|`$value -is $null`|`$value -is $null -and $value -isnot [DBNull] -and $value -isnot [NullString] -and $value -isnot [PSObject]` <sup>1,2</sup>|\r\n|`[DBNull]::Value`|`$value -is [DBNull]`|`$value -is [DBNull]`|\r\n|`[NullString]::Value`|`$value -is [NullString]`|`$value -is [NullString]`|\r\n|`[S.M.A.InternalAutomationNull]`|`$null -eq $value -and $value -is [PSObject]` <sup>1</sup>|`$value -is $null -and $value -is [PSObject]` <sup>1</sup>|\r\n\r\n <sup>1</sup> I have a local sandbox with the necessary changes to support `is [S.M.A.Internal.AutomationNull]`, but I held back on pushing that change into this PR because technically speaking, you cannot have an instance of `AutomationNull`. That said, from an end user's perspective, if you capture the results of a command that returns nothing, that thing you captured _is AutomationNull_, so personally I am OK with allowing that technical falsehood to be in the product. It could be considered hacky, but `AutomationNull` is already hacky, and we can only work with what we have. That said, it may be better to add a public `LanguagePrimitives.IsAutomationNull` method than to support `is [S.M.A.Internal.AutomationNull]` if we really need this capability, which would be less hacky.\r\n\r\n <sup>2</sup> In practice, scripters wouldn't need to include all of these tests, so this comparison may be much simpler than what is shown. For example, unless they're working with a database, they wouldn't need to include the test against `DBNull` here.",
      "created_at": "2019-10-15T13:36:53Z",
      "updated_at": "2019-10-15T14:03:31Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "> By contrast, people who do use -is (and -as - see #4343), coming from a world of strict typing, I think will expect precision there.\r\n\r\nIf that's the case, and if we think `-is` is really for more advanced scripters, then I could go the other way with this; however, when we talk (and likely think) about what we're doing, we naturally say to others or ourselves \"if x is null\", which makes me think `-is $null` is a great feature for less experienced scripters, and maybe it shouldn't be as strict for those folks.\r\n\r\n> I can see the appeal in making ... -is $null the new idiom to test for all null-like values, because it is less awkward than $null -eq ....\r\n\r\nThat, plus as mentioned above, it allows `Where-Object` with its `-is` parameter to be used to compare properties that contain collections against `$null`, which is something that you can't do today without using the `ScriptBlock` parameter set.",
      "created_at": "2019-10-15T13:45:51Z",
      "updated_at": "2019-10-15T13:47:08Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Yeah, I think it's worth including all null-likes there. Worth mentioning that a test for \"true null\" should be as simple as `$value -is $null -and $value -isnot [PSObject]`. That will exclude all the null-like values, as they are all considered PSObjects if I recall correctly.\r\n\r\nThanks for the detailed breakout @KirkMunro! :blush: ",
      "created_at": "2019-10-15T13:56:40Z",
      "updated_at": "2019-10-15T13:56:40Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "> they are all considered PSObjects if I recall correctly.\r\n\r\nThat is incorrect. `[DBNull]::Value` and `[NullString]::Value` are not of type `PSObject`, so the test for \"true null\" isn't as simple as you suggest. It's still not that complicated though, because `DBNull` and `NullString` may not even need to be considered, depending on what you're doing in your script.",
      "created_at": "2019-10-15T14:06:46Z",
      "updated_at": "2019-10-15T14:06:46Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for the detailed analysis, @KirkMunro - I now agree that making `-is $null` cover all null-like types is the better option.\r\n\r\n---\r\n\r\nMy only - minor, in the grand scheme of things - remaining concern is with how easy it is to test for `[AutomationNull]::Value`:\r\n\r\n> you cannot have an instance of AutomationNull\r\n\r\nIf something like `& {}` returns the `[AutomationNull]::Value` then you _do_ have an instance - even if it's the very same instance (singleton) every time.\r\n\r\n> so personally I am OK with allowing that technical falsehood to be in the product. It could be considered hacky, but AutomationNull is already hacky, and we can only work with what we have.\r\n\r\nYes, and it is the \"hackiness\" - the _situationally_ different behavior - that makes me think that distinguishing `$null` from `AutomationNull` is important to facilitate.\r\n\r\nThe abstraction is out of the bag, if you will, so pretending it is `$null` in all cases only adds to the confusion.\r\n\r\nWhile adding a `LanguagePrimitives.IsAutomationNull()` method is a good idea, I feel that `-is [AutomationNull]` should _also_ work, to (a) make it script-friendly and (b) consistent with `-is [DbNull]` and `-is [NullString]`.\r\n\r\nAs an aside: For `[AutomationNull]` to work in the type-name-only form, `System.Management.Automation.Internal.AutomationNull` would have to be added as a type accelerator.\r\n\r\n---\r\n\r\nA bit of a tangent re _technical falsehoods_:\r\n\r\n_Hiding_ certain abstractions - _as long as they don't leak_ - can be beneficial.\r\n\r\nFor instance, what truly deserves hiding is `psobject`, which should only ever have been an invisible helper type that PowerShell scripters should be allowed to be blissfully unaware of - but presently cannot - see #5579\r\n\r\nThe conflation of type accelerators `[psobject]` and `[pscustomobject]` to _both_ refer to `System.Management.Automation.PSObject` (see #4344) is another highly unfortunate legacy burden:\r\n\r\n```powershell\r\n# Not only passes 1 through, which is unexpected,\r\n# but also creates a typically-but-not-always-invisible PSObject wrapper.\r\n1 -as [pscustomobject]\r\n```\r\n\r\nIn the context of fixing #4343, that means that the following is meaningless:\r\n\r\n```powershell\r\n[pscustomobject] @{foo=1} -as [pscustomobject] # !! meaningless - ANY type matches\r\n```\r\n\r\nThat saddles us with having to use the full type name, which is the case that is currently broken ( the `-is` case works, however):\r\n\r\n```powershell\r\n[pscustomobject] @{foo=1} -as [System.Management.Automation.PSCustomObject] # !! CURRENTLY BROKEN\r\n```\r\n\r\nLong story short: while `[pscustomobject] @{foo=1}` may _technically_ be a `PSObject`, behind the scenes, the only meaningful interpretation from a _scripter's_ perspective is to consider it a `System.Management.Automation.PSCustomObject` instance - that is a \"lie\" worth telling consistently (it is already being told with `-is`, but not with `-as`), because it is consistent with the world view that PowerShell presents.\r\n\r\n",
      "created_at": "2019-10-15T14:42:48Z",
      "updated_at": "2019-10-15T14:42:48Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 while I agree the inconsistencies are unfortunate, I do not think that perpetuating the inconsistency here is valuable. We should strive to close the gap rather than widen it, so users have a more consistent experience as development progresses.",
      "created_at": "2019-10-15T14:58:39Z",
      "updated_at": "2019-10-15T15:00:27Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I agree on closing the gap, but to me that (now) means:\r\n\r\n* make `-is $null` return `$true` for _all_ null-like types.\r\n\r\n* add support for `-is [AutomationNull]` (and a `LanguagePrimitives.IsAutomationNull` method).\r\n\r\nNo inconsistency is being perpetuated there; instead, an unavoidably legacy inconsistency is made more tractable.\r\n",
      "created_at": "2019-10-15T15:05:47Z",
      "updated_at": "2019-10-15T15:05:47Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Agreed, that sounds like the most effective solution here. \ud83d\ude42 ",
      "created_at": "2019-10-15T16:03:31Z",
      "updated_at": "2019-10-15T16:03:31Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "Sorry for not reading the discussion, but I believe this is a breaking change.\r\n\r\nLest you think it's a harmless breaking change, consider:\r\n\r\n```PowerShell\r\ntry {\r\n    \"\" -is $Typo\r\n    Remove-Item -Recurse -Force stuff\r\n} catch {}\r\n```\r\n\r\nThe point in this sample - the typo returns `$null`. Today this code never hits the `Remove-Item` because of the exception.\r\n\r\nWith this change, the exception is never raised and the (possibly never run before code) is now reachable.\r\n\r\nI think there is a non-zero chance of this affecting real world scripts and extra caution should be applied if taken (e.g. in release notes, script analyzer rules, etc.)",
      "created_at": "2019-10-15T23:31:22Z",
      "updated_at": "2019-10-15T23:31:22Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Does a nonexistent variable return $null or AutomationNull.Value?",
      "created_at": "2019-10-15T23:44:43Z",
      "updated_at": "2019-10-15T23:44:43Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@lzybkr Couldn't you make that same argument for literally _any_ new command in PowerShell?\r\n\r\ne.g. If I have a local module with a `Get-Error` command that I sometimes load, and in a script I have this:\r\n\r\n```powershell\r\ntry {\r\n    Get-Error\r\n    Remove-Item -Recurse -Force $dir\r\n} catch {}\r\n```\r\n\r\nIf my module is not loaded, and then I run that script on the latest build of PowerShell, where `Get-Error` was just added, then suddenly the `Remove-Item` line would execute \"unexpectedly\". Should we treat all new commands as potential breaking changes as well?\r\n\r\nThat's contrived, but I think your example is pretty contrived as well. Have you ever seen such code?",
      "created_at": "2019-10-15T23:52:25Z",
      "updated_at": "2019-10-15T23:52:25Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "> I think there is a non-zero chance of this affecting real world scripts and extra caution should be applied if taken (e.g. in release notes, script analyzer rules, etc.)\r\n\r\nAlso, what sort of script analyzer rules?",
      "created_at": "2019-10-15T23:54:42Z",
      "updated_at": "2019-10-15T23:54:42Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "> Does a nonexistent variable return $null or AutomationNull.Value?\r\n\r\n`$null`",
      "created_at": "2019-10-15T23:55:20Z",
      "updated_at": "2019-10-15T23:55:20Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@KirkMunro @lzybkr I mean... `is null` in c# works only on that specific _keyword_, not on any identifier that happens to resolve to a `null` value.\r\n\r\nShouldn't we do the same thing here? Shouldn't we make it _only_ work for specifically entering exactly  `$value -is $null` ? That would probably require a bit different of a change, but would make this impossible to be a breaking change. It would also reduce ambiguity significantly.",
      "created_at": "2019-10-15T23:58:16Z",
      "updated_at": "2019-10-15T23:58:16Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "> Shouldn't we do the same thing here? Shouldn't we make it _only_ work for specifically entering exactly `$value -is $null` ?\r\n\r\nGood idea. There's no point having an arbitrary value on the right-hand side, just `$null` or a type. I'll see what I can do.",
      "created_at": "2019-10-16T00:00:33Z",
      "updated_at": "2019-10-16T00:00:33Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "@KirkMunro Re:\r\n> Couldn't you make that same argument for literally any new command in PowerShell?\r\n\r\nMaybe you could make that same argument, but I think my example was less contrived. My example does combine things I've seen in the wild - typos in variable names are common, and hitting code that hasn't run before due to a previous handled error is not unheard of.\r\n\r\nRegardless - if this only applies to the literal `$null`, my concerns are addressed. You can still call it a breaking change, but it is unlikely to break any real world scripts.",
      "created_at": "2019-10-16T00:18:01Z",
      "updated_at": "2019-10-16T00:18:01Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "Figuring out how to make it work for literal `$null` with the `-is` operator was actually really easy.\r\n\r\nWhat I haven't figured out yet is how to make it only work for literal `$null` with something like `Where-Object Property -is $null`.\r\n\r\nIn the former case, when the operator is compiled, it's easy to identify the literal `$null`. In the latter case, it's a cmdlet, which can accept any input, so it's definitely not as straightforward.",
      "created_at": "2019-10-16T02:27:20Z",
      "updated_at": "2019-10-16T02:27:20Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "You could, I _suppose_, check the `$MyInvocation` information to determine how the cmdlet was called? Not 100% sure how that would go from a compiled cmdlet, but in PS you can examine `$MyInvocation.Line` to determine what was passed to each parameter and work from there.\r\n\r\nIt's hacky as hell, but it's probably one of pretty few options to make the behaviour sync up with what we'd need for the real `-is` operator.",
      "created_at": "2019-10-16T02:37:34Z",
      "updated_at": "2019-10-16T02:37:34Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "If you add a property to CommandArgumentInternal, you could then pass a special internal only type if the command is Where-Object, then add a special case in Where-Object. I think it's minimal code and not too hacky. ",
      "created_at": "2019-10-16T05:17:07Z",
      "updated_at": "2019-10-16T05:17:07Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "If we actually need address real null check scenario we could introduce new operator `-isnull` without risk to break scripts.",
      "created_at": "2019-10-16T05:40:28Z",
      "updated_at": "2019-10-16T05:40:28Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov: While that would solve the problem, it would break the one-to-one correspondence between `Where-Object` arguments and operators, and, conversely, I don't think we want to introduce new operators.",
      "created_at": "2019-10-16T12:24:06Z",
      "updated_at": "2019-10-16T12:24:06Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@mklement0 We could have the same in the cmdlet too.",
      "created_at": "2019-10-16T13:23:57Z",
      "updated_at": "2019-10-16T13:23:57Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "@iSazonov: Sorry, I misunderstood your original comment: I thought you already were talking about the cmdlet, in the context of the difficulty of identifying a `$null` argument there.\r\n\r\nI think at this point everyone is happy with supporting only a _verbatim_ `$null` on the RHS of `-is` and `-isnot` and requiring any other variable reference to evaluate to an actual type - that way, no existing code should break.\r\n\r\nSince it sounds like @lzybkr knows of a way to identify a verbatim `$null`  even in the `Where-Object` case, there should be no need to introduce additional `-isnull` and `-isnotnull` operators.\r\n",
      "created_at": "2019-10-16T13:40:01Z",
      "updated_at": "2020-06-19T14:37:16Z"
    },
    {
      "author": "lzybkr",
      "author_association": "MEMBER",
      "body": "For specifics on my idea:\r\n\r\n* Add a `bool` property `nullLiteral` [here](https://github.com/PowerShell/PowerShell/blob/48db3de03ed427f10646f1fbb824a2b4eb958378/src/System.Management.Automation/engine/CommandParameter.cs#L22)\r\n* When generating code [here](https://github.com/PowerShell/PowerShell/blob/48db3de03ed427f10646f1fbb824a2b4eb958378/src/System.Management.Automation/engine/parser/Compiler.cs#L3545) - be sure to set this new property appropriately.\r\n* Then [here](https://github.com/PowerShell/PowerShell/blob/48db3de03ed427f10646f1fbb824a2b4eb958378/src/System.Management.Automation/engine/runtime/Operations/MiscOps.cs#L164) you can replace the `null` argument with an internal type if the command is `Where-Object` (check the ImplementingType to make sure it's the internal command).\r\n* Then in Where-Object, add your custom logic if the type is this internal type.",
      "created_at": "2019-10-16T17:26:33Z",
      "updated_at": "2019-10-16T17:26:33Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "@lzybkr Awesome! I had already worked my way into the first part, but this will make the rest easy. Thanks!",
      "created_at": "2019-10-16T17:48:19Z",
      "updated_at": "2019-10-16T17:48:19Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "> * Then [here](https://github.com/PowerShell/PowerShell/blob/48db3de03ed427f10646f1fbb824a2b4eb958378/src/System.Management.Automation/engine/runtime/Operations/MiscOps.cs#L164) you can replace the `null` argument with an internal type if the command is `Where-Object` (check the ImplementingType to make sure it's the internal command).\r\n\r\nYour post was really helpful @lzybkr, and it saved me a lot of time. This particular detail is tricky though, and I still have more details to work out to be able to support `-is -value $null`, and `-is -value:$null`. These seem to take different paths through the binder, so this will take a little longer while I work those paths out.",
      "created_at": "2019-10-17T18:21:17Z",
      "updated_at": "2019-10-17T18:22:17Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "Well that was a fun exercise. :)\r\n\r\nI've finished updating this to make both the `-is`/`-isnot` operator pair and the `Where-Object` `-is`/`-isnot` parameters only support `$null` on the right-hand side if you pass in literal null.\r\n\r\nI also ended up going with an approach that isn't a hack at all.\r\n\r\nAs I worked through the `Where-Object` scenario (which was the hardest part in all of this), I realized that the only way to really make this work so that only the `-Value` parameter of `Where-Object` would accept a `NullLiteral.Value` instance was to add an attribute to that parameter. The other approach (simply checking if the command was `Where-Object`) caused some issues if a null literal was passed into one of the other parameters.\r\n\r\nBy leveraging the attribute approach, I was able to mark the `-Value` parameter of `Where-Object` as a parameter that `SupportsNullLiteral` (that's the internal attribute name), meaning that if that parameter is passed in a null literal (`$null`, `$global:null`, `$local:null`, etc.), the binder will bind in a value of `NullLiteral.Value` (a singleton) instead so that the command can leverage its specific support for a null literal. Also, in the cmdlet implementation, if the parameter set is anything other than the parameter set with `-is` or `-isnot`, then any `NullLiteral.Value` that it receives is immediately converted back to `null` for normal processing.\r\n\r\n@lzybkr Since you provided your recommended set of changes for null literal support/checking, I'd really appreciate your review of the changes I landed on in the end.",
      "created_at": "2019-10-21T01:53:24Z",
      "updated_at": "2019-10-21T02:11:17Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "By the way, before I forget, [this code](https://github.com/PowerShell/PowerShell/blob/49e906bc3bd302e54ab1f5ad00c5bda8f8fba07f/src/System.Management.Automation/engine/parser/ast.cs#L9110-L9124) seems to be missing a check against `!VariablePath.IsDriveQualified`. I added a method below that one in this PR, and in my tests, I needed to ensure that the variable path was not drive qualified as part of the check for a null literal, so it surprised me to see this other test for a constant variable not doing the same. I haven't gone down the rabbit hole to see if/how that shows up in PowerShell though.",
      "created_at": "2019-10-21T02:24:19Z",
      "updated_at": "2019-10-21T02:24:19Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@daxian-dbw @SteveL-MSFT is there interest in having this available for PS7?\r\n\r\nPersonally I think it'd be a really nice addition to PS7 but I understand you guys are are very busy round about now. Just thought I'd give y'all a ping so it doesn't fall off the radar entirely. \ud83d\ude0a \ud83d\udc96 ",
      "created_at": "2019-11-19T17:15:34Z",
      "updated_at": "2019-11-19T17:15:34Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "This wasn't on my radar so didn't push for it before we started the preview.6 release process.  This is a great addition, but the substantial changes make my default answer to be in 7.1.",
      "created_at": "2019-11-19T20:54:14Z",
      "updated_at": "2019-11-19T20:54:14Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "Aww. \ud83d\ude41 \r\n\r\n'Twas worth a shot! \ud83d\ude01 ",
      "created_at": "2019-11-19T21:04:04Z",
      "updated_at": "2019-11-19T21:04:04Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "This PR is still awaiting a decision or a merge.",
      "created_at": "2020-05-11T12:15:51Z",
      "updated_at": "2020-05-11T12:15:51Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as Review Needed because it has been there has not been any activity for **7 days**.\nMainainer, Please provide feedback and/or mark it as `Waiting on Author`",
      "created_at": "2020-05-27T02:03:02Z",
      "updated_at": "2020-05-27T02:03:02Z"
    },
    {
      "author": "rjmholt",
      "author_association": "COLLABORATOR",
      "body": "I know this has already been discussed, but I want to register that I'm worried about a cmdlet having a different behaviour between the `$null` literal and another variable that is null. At runtime, my feeling is that the behaviour around a value should not depend on the syntax used to create it. I think that introduces complexity in both implementation and understanding and hurts our separations of concern between the parser and the PowerShell runtime.\r\n\r\nThis PR does great work, and I think the addition of `-is $null` makes sense both because of the .NET concepts at work and also to alleviate the pain of `-eq $null`. But I think we should design very carefully around:\r\n\r\n- `-is $null` vs `-is $variableThatIsNull` vs `-is $uninstantiatedVariable` -- in particular I'm not sure of anywhere else in PowerShell where accessing a variable (in `$` form) is different in those three scenarios\r\n- `-is $null` vs `Where-Object -is $null` (vs `Where-Object -IsNull`)\r\n\r\nI'm not sure I fully agree that the breaking change that the literal `$null` behaviour differentiation was intended to avoid is something we have considered to be breaking in the past (for example, a similar breakage could be claimed by defining most command names). I definitely understand the scenario there though, and I think it's a valuable point.\r\n\r\nAs I say, I think `-is $null` is a great addition. My concern is only that differentiating the `$null` literal from a null value puts a corner case into PowerShell that may not belong there.\r\n\r\nI just want to make these points in writing so that maintainers or the @PowerShell/powershell-committee can review the design carefully.",
      "created_at": "2020-06-02T20:53:43Z",
      "updated_at": "2020-06-02T20:53:43Z"
    },
    {
      "author": "SteveL-MSFT",
      "author_association": "MEMBER",
      "body": "@PowerShell/powershell-committee reviewed this, we prefer adding `-isnull` operator which can be used with `-not` instead of overloading `-is` which is expected to be used against types and would be a breaking change.",
      "created_at": "2020-06-03T22:41:16Z",
      "updated_at": "2020-06-03T22:41:16Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "@SteveL-MSFT That would effectively make it the only postfix operator currently existing in PS, at least if we're still talking `$object -isnull`\r\n\r\nI'd be concerned about whether that would overcomplicate the parsing logic for operators.",
      "created_at": "2020-06-03T22:53:06Z",
      "updated_at": "2020-06-03T22:53:17Z"
    },
    {
      "author": "msftbot[bot]",
      "author_association": "NONE",
      "body": "This pull request has been automatically marked as Review Needed because it has been there has not been any activity for **7 days**.\nMainainer, Please provide feedback and/or mark it as `Waiting on Author`",
      "created_at": "2020-06-11T02:00:22Z",
      "updated_at": "2020-06-11T02:00:22Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "We could make it a regular prefix unary operator with a `-isnotnull` variant, I suppose, which would also work with `Where-Object` (where the argument representing an operator can be placed in any position):\r\n\r\n```powershell\r\n# Expressions\r\n-isnull $var\r\n-isnotnull $var\r\n\r\n# Where-Object\r\n... | Where-Object -isnull Foo\r\n... | Where-Object -isnotnull Foo\r\n... | Where-Object -isnotnull   # once #8357  gets implemented\r\n```",
      "created_at": "2020-06-11T11:44:29Z",
      "updated_at": "2020-06-11T11:44:29Z"
    },
    {
      "author": "vexx32",
      "author_association": "COLLABORATOR",
      "body": "~~\ud83e\udd14 having experimented with Where-Object's parameter sets before... I genuinely don't think that you can make that binding work without overhauling the entire parameter binder.~~\r\n\r\n~~So that request is, at least for Where-Object, currently impossible @SteveL-MSFT @mklement0~~\r\n\r\nI stand corrected. \ud83d\ude42 ",
      "created_at": "2020-06-11T12:36:25Z",
      "updated_at": "2020-06-11T13:45:15Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "It works with the unary `-not` operator, so wouldn't it work with other unary operators too?\r\n\r\n```powershell\r\nPS> [pscustomobject] @{ foo = 0 } | Where-Object -Not foo\r\n\r\nfoo\r\n---\r\n  0\r\n```\r\n\r\nNote that, for the reasons mentioned, `Where-Object foo -Not` works too (though is awkward, though perhaps less so with `Where-Object foo -isnull`, but it's generally advisable to stick with the order required in expressions).\r\n\r\n\r\n",
      "created_at": "2020-06-11T12:39:42Z",
      "updated_at": "2020-06-11T12:41:30Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "My only objection to any of the arguments made above and to what the Committee decided on is that we should have `-isnotnull` instead of `-not -isnull` for the same reason that we have paired `-eq`/`-ne`, `-is`/`-isnot`, and so many other operators that have positive/negative comparisons associated with them.\r\n\r\nI also feel strongly that these should be postfix operators, not prefix operators so that the expressions can be read and more easily understood, so I'm going to move forward with that approach. Part of the value with these changes is eliminating the need to put the `$null` value you are comparing against first, which is not intuitive for non-developers and which never reads well.\r\n\r\n```powershell\r\n$array -isnull # Intuitive, reads exactly like what it checks\r\n\r\n-isnull $array # Not as readable\r\n```\r\n\r\nI've never liked that PSScriptAnalyzer always complains and tells me to put my `$null` values first in comparisons such as `$null -eq $value`.",
      "created_at": "2020-06-14T17:36:25Z",
      "updated_at": "2020-06-14T17:36:25Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "> @SteveL-MSFT That would effectively make it the only postfix operator currently existing in PS, at least if we're still talking `$object -isnull`\r\n> \r\n> I'd be concerned about whether that would overcomplicate the parsing logic for operators.\r\n\r\n@vexx32: You're forgetting about the `++` and `--` postfix operators. Adding additional postfix operators won't overcomplicate the parsing logic.",
      "created_at": "2020-06-14T19:14:30Z",
      "updated_at": "2020-06-14T19:14:46Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I can see the appeal of _postfix_ `-isnull` / `-isnotnull` for symmetry with `-is` / `-isnot`.\r\n\r\nHowever, I still think that `-is $null` / `-isnot $null` is by far preferable to having separate operators.\r\n\r\nI definitely understand @rjmholt's concern about the special-casing of only supporting a _verbatim_ `$null` as the RHS.\r\n\r\nHowever, he also states:\r\n\r\n> I'm not sure I fully agree that the breaking change that the literal `$null` behaviour differentiation was intended to avoid is something we have considered to be breaking in the past \r\n\r\nSo my plea is:\r\n\r\nLet us stick with `-is $null` / `-isnot $null`, irrespective of the syntactic form of the RHS, which eliminates the special casing and also simplifies the implementation.\r\n\r\nI think there's a reasonable case to be made that the technically breaking change that this constitutes falls into [Bucket 3: Unlikely Grey Area](https://github.com/PowerShell/PowerShell/blob/master/docs/dev-process/breaking-change-contract.md#bucket-3-unlikely-grey-area):\r\n\r\n* I've gone through about 30 pages of the top 3 matches among the 203,107 uses of the `-is` operator (https://github.com/search?p=20&q=language%3APowerShell+-is&type=Code) and didn't find a single instance of using a _variable_ as the RHS, which is the scenario @lzybkr was concerned about (the vast majority of these literal RHSs were type literals (e.g, `[string]`), with only very few instances of strings (e.g., `'string'`).\r\n\r\n* Even the case of code that contains `\"\" -is $Typo` (see [above](https://github.com/PowerShell/PowerShell/pull/10704#issuecomment-542446636)) _relying_ on a statement-terminating error strikes me as unlikely:\r\n   * With `$Typo` _accidentally_ evaluating to `$null` (as the naming suggests), the bug would likely have been discovered and fixed before deployment.\r\n    * Without an explicit `try` / `catch` / `$ErrorActionPreference = 'Stop'`, execution would _continue_ even _with_ the statement-terminating error (although with the proposed change an error would no longer be emitted).\r\n\r\n\r\n",
      "created_at": "2020-06-19T15:59:02Z",
      "updated_at": "2020-06-19T15:59:02Z"
    },
    {
      "author": "KirkMunro",
      "author_association": "CONTRIBUTOR",
      "body": "Closing. See https://github.com/PowerShell/PowerShell/pull/10238#issuecomment-826091414.",
      "created_at": "2021-04-24T13:17:22Z",
      "updated_at": "2021-04-24T13:17:22Z"
    }
  ],
  "created_at": "2019-10-04T19:04:44Z",
  "number": 10704,
  "state": "closed",
  "title": "Add -is $null and -isnot $null support to operators and Where-Object",
  "updated_at": "2021-04-24T13:17:23Z"
}