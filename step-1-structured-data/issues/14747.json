{
  "_url": "https://github.com/PowerShell/PowerShell/issues/14747",
  "author": "JamesWTruher",
  "body": "# Handling Parameter Binding in Native Executables\r\n\r\nPowerShell generally provides a useful experience when working with native executables, but there are a number of issues:\r\n\r\n- passing embedded quoted strings is very problematic\r\n- passing an empty string is very problematic (mostly impossible)\r\n- passing a string which looks like a ScriptBlock requires extra care\r\n\r\nA command line such as: `msiexec /i testdb.msi INSTALLLEVEL=3 /l* msi.log COMPANYNAME=\"Acme \"\"Widgets\"\" and \"\"Gizmos\"\"\"` is received as: `msiexec /i testdb.msi INSTALLLEVEL=3 /l* msi.log COMPANYNAME=\"Acme Widgets and Gizmos\"`. A command line such as: `msiexec /i testdb.msi INSTALLLEVEL=3 /l* msi.log COMPANYNAME=\"Acme \"\"Widgets\"\" and \"\"Gizmos.\"\"\"` is received as: `msiexec /i testdb.msi INSTALLLEVEL=3 /l* msi.log COMPANYNAME=\"Acme Widgets and Gizmos.\"` which strips the embedded double quotes.\r\n\r\nCurrent behavior does not allow empty strings to be passed, so the following is not possible:\r\n\r\n- `useradd -g 501 -u 1001 -p '' sam`\r\n- `emacsclient -u ''`\r\n\r\nThese behaviors should be supported as there are many scenarios where an empty string is required as a parameter value.\r\n\r\n### Handling Quotes\r\n\r\nWindows and Non-Windows have divergent behavior with regard to quotes.\r\nWhile both Windows and Unix shells recognize `\"one two three\"` as a single string,\r\nWindows does not recognize single quotes `'` as string designator.\r\nUnix shells (and PowerShell) has 2 types of strings;\r\nExpandable strings `\"$a\"` where `$a` is expanded with the value of the variable `$a,\r\nand literal strings `'$a'` where the literal string `$a` is passed.\r\n\r\nIn the case of Windows a string such as `'foo bar'` is 2 tokens (`'foo` and `bar'`) where Unix will see a single string `foo bar`.\r\n\r\n### Null vs Empty Strings\r\n\r\nMost shells don't have the same definition of `null` that PowerShell does.\r\nIn bash, for example, commands are invoked via strings, so naturally, an empty string can be easily notated with `''` or `\"\"`.\r\nSimilarly, in `CMD.EXE` an empty string may be passed with `\"\"`.\r\n\r\nHowever, the following should not result in empty strings being added:\r\n\r\n- `$null`\r\n- Reference to a variable which is unassigned\r\n- Reference to a variable which is assigned the value `$null`\r\n- When a collection wherein an element of the collection has the value `$null`\r\n\r\nNon-null elements of a collection will be bound:\r\n\r\n- `@($null, 1, $null)` will bind a single value `1` as a parameter value\r\n- `@($null, 1, $null, 2, $null)` will bind 2 values (`1` and `2`) as parameter values\r\n- `@($null, 1, $null, '', 2)` will bind 3 values (`1`, `''`, `2`) as parameter values\r\n\r\nexamples:\r\n\r\n```powershell\r\nPS> useradd -g 501 -u 1001 -p $null sam # error - \"sam\" is used as password and no username is passed\r\nPS> $a = $null\r\nPS> useradd -g 501 -u 1001 -p $a sam # error - \"sam\" is used as password and no username is passed\r\nPS> $a = @()\r\nPS> useradd -g 501 -u 1001 -p $a sam # error - \"sam\" is used as password and no username is passed\r\nPS> $a = @($null)\r\nPS> useradd -g 501 -u 1001 -p $a sam # error - \"sam\" is used as password and no username is passed\r\nPS> $a = ''\r\nPS> useradd -g 501 -u 1001 -p $a sam # no error - empty string is passed as password\r\nPS> $a = @('')\r\nPS> useradd -g 501 -u 1001 -p $a sam # no error - empty string is passed as password\r\nPS> $a = @('',\"sam\")\r\nPS> useradd -g 501 -u 1001 -p $a # no error - empty string is passed as password and same is passed as username value\r\nPS> $a = @(\"-g\",501,\"-u\",1001,\"-p\",'',\"sam\")\r\nPS> useradd $a # no error\r\nPS> $a = @(\"-g\",501,\"-u\",1001,$null,$null,$null,$null,\"-p\",'',\"sam\")\r\nPS> useradd $a # no error - nulls are not passed\r\n```\r\n\r\n### Additional Examples\r\n\r\n```powershell\r\nS> msiexec /i A:\\Example.msi PROPERTY=\"Embedded \"\"Quotes\"\" White Space\" # no error - embedded quotes are passed to native executable\r\nPS> msiexec /i A:\\Example.msi PROPERTY=\"Embedded White Space\" # no error - embedded spaces are passed to native executable\r\nPS> msiexec /i A:\\Example.msi PROPERTY=\"\" # no error - empty string is passed to native executable\r\n```\r\n\r\n### Globbing Considerations\r\n\r\nGlobbing will need to be done where appropriate. This behavior is platform dependent, so on Windows systems, globbing is not performed but is provided on Linux and Mac systems. This is because most utilities on Windows do their own globbing, but on Linux and Mac globbing is done by the shell. The current behavior for globbing does this and needs to remain unchanged to ensure that the scenarios continue to work on each platform. When a glob fails, the string provided shall be sent to the application without alteration.\r\n\r\nThe following example shows the difference based on platform:\r\n\r\n```powershell\r\nPS> # on Windows\r\nPS> .\\echoit.exe rm c:\\tmp\\dd\\f*\r\nArgument 1 <rm>\r\nArgument 2 <c:\\tmp\\dd\\f*>\r\n\r\n# on Mac/Linux\r\nPS> trace-command -pshost -name parameterbinding { /bin/ls /tmp/dd/f* }\r\nDEBUG: 2021-02-08 17:12:03.3886 ParameterBinding Information: 0 : BIND NAMED native application line args [/bin/ls]\r\nDEBUG: 2021-02-08 17:12:03.3887 ParameterBinding Information: 0 :     BIND argument [/tmp/dd/f1 /tmp/dd/f2]\r\nDEBUG: 2021-02-08 17:12:03.3956 ParameterBinding Information: 0 : CALLING BeginProcessing\r\n/tmp/dd/f1\r\n/tmp/dd/f2\r\nPS> trace-command -pshost -name parameterbinding { /bin/ls /tmp/dd/fff* }\r\nDEBUG: 2021-02-08 17:12:23.0600 ParameterBinding Information: 0 : BIND NAMED native application line args [/bin/ls]\r\nDEBUG: 2021-02-08 17:12:23.0601 ParameterBinding Information: 0 :     BIND argument [/tmp/dd/fff*]\r\nDEBUG: 2021-02-08 17:12:23.0670 ParameterBinding Information: 0 : CALLING BeginProcessing\r\nls: /tmp/dd/fff*: No such file or directory\r\n\r\n```\r\n\r\n#### Unsupported or Requiring Alteration\r\n\r\nSome elements may not be used as they represent PowerShell tokens.\r\n\r\n- An embedded semi-colon `;` is not allowed. PowerShell will parse this as a statement separator.\r\n- An open curly-brace will be interpreted as the beginning of a scriptblock\r\n\r\nfor example:\r\n\r\n`msiexec /p msipatch.msp;msipatch2.msp /n {00000001-0002-0000-0000-624474736554} /qb`\r\n\r\n- This is not allowed because of the embedded `;` which PowerShell will turn into 2 commands (`;` is a statement separator) this string must be quoted.\r\n- This is also not supported because of the use of ScriptBlock syntax. PowerShell can not determine if the ScriptBlock is a command (or in this case a guid).\r\nTo execute this command, quote the problematic strings or use `--%` after the executable.\r\n\r\n`msiexec /p 'msipatch1.msp;msipatch2.msp' /n '{00000001-0002-0000-0000-624474736554}' /qb`\r\n\r\nor\r\n\r\n`msiexec --% /p msipatch1.msp;msipatch2.msp /n {00000001-0002-0000-0000-624474736554} /qb`\r\n\r\nNB: The behavior for supporting ScriptBlocks as strings _could_ be supported via an allow-list for known executables. This may be needed because the amount of GUIDs (with braces) is used in a number of both Windows and Non-Windows utilities. However, managing the list of utilities may be burdensome.\r\n\r\n## Improved Tracing\r\n\r\nThe parameter binding tracing code for native executables is not currently implemented which makes debugging issues when execution native applications very difficult. Tracing for current parameter binding and new behavior shall be provided. In the case of the old style, the path to the executable and the string which makes up the `Arguments` property of the StartInfo object shall be provided. For the new behavior, since the arguments are a list, each element of the list shall be presented.\r\nThe following transcript shows how the tracing shall appear.\r\n\r\n```powershell\r\n# new style - native arguments are bound to ArgumentList property\r\nPS > trace-command -PSHOST -Name ParameterBinding { ~/echoit foo=\"bar \"\"blob\"\" bar\" zap foo:bar:baz,bip,bar }\r\nDEBUG: 2021-02-04 17:28:54.5674 ParameterBinding Information: 0 : BIND NAMED native application line args [/Users/james/echoit]\r\nDEBUG: 2021-02-04 17:28:54.5674 ParameterBinding Information: 0 :     BIND cmd line arg [foo=bar \"blob\" bar] to position [0]\r\nDEBUG: 2021-02-04 17:28:54.5675 ParameterBinding Information: 0 :     BIND cmd line arg [zap] to position [1]\r\nDEBUG: 2021-02-04 17:28:54.5675 ParameterBinding Information: 0 :     BIND cmd line arg [foo:bar:baz,bip,bar] to position [2]\r\nDEBUG: 2021-02-04 17:28:54.5728 ParameterBinding Information: 0 : CALLING BeginProcessing\r\nArgument 1 <foo=bar \"blob\" bar>\r\nArgument 2 <zap>\r\nArgument 3 <foo:bar:baz,bip,bar>\r\n\r\n# old style - native arguments are bound to Arguments property\r\nPS > trace-command -PSHOST -Name ParameterBinding { ~/echoit foo=\"bar \"\"blob\"\" bar\" zap foo:bar:baz,bip,bar }\r\nDEBUG: 2021-02-04 17:29:01.9987 ParameterBinding Information: 0 : BIND NAMED native application line args [/Users/james/echoit]\r\nDEBUG: 2021-02-04 17:29:01.9987 ParameterBinding Information: 0 :     BIND argument [\"foo=bar \"blob\" bar\" zap foo:bar:baz,bip,bar]\r\nDEBUG: 2021-02-04 17:29:02.0058 ParameterBinding Information: 0 : CALLING BeginProcessing\r\nArgument 1 <foo=bar blob bar>\r\nArgument 2 <zap>\r\nArgument 3 <foo:bar:baz,bip,bar>\r\nPS > \r\n\r\n# view of tracing when --% is used\r\nPS /Users/james> trace-command -PSHOST -name parameterbinding { ~/echoit --% 'foo bar' a,b,c \"one two\" \"a\\ b\\ c\"\r\n>> }\r\nDEBUG: 2021-02-08 17:07:10.0199 ParameterBinding Information: 0 : BIND NAMED native application line args [/Users/james/echoit]\r\nDEBUG: 2021-02-08 17:07:10.0199 ParameterBinding Information: 0 :     BIND cmd line arg ['foo] to position [0]\r\nDEBUG: 2021-02-08 17:07:10.0199 ParameterBinding Information: 0 :     BIND cmd line arg [bar'] to position [1]\r\nDEBUG: 2021-02-08 17:07:10.0199 ParameterBinding Information: 0 :     BIND cmd line arg [a,b,c] to position [2]\r\nDEBUG: 2021-02-08 17:07:10.0200 ParameterBinding Information: 0 :     BIND cmd line arg [\"one] to position [3]\r\nDEBUG: 2021-02-08 17:07:10.0200 ParameterBinding Information: 0 :     BIND cmd line arg [two\"] to position [4]\r\nDEBUG: 2021-02-08 17:07:10.0200 ParameterBinding Information: 0 :     BIND cmd line arg [\"a\\] to position [5]\r\nDEBUG: 2021-02-08 17:07:10.0200 ParameterBinding Information: 0 :     BIND cmd line arg [b\\] to position [6]\r\nDEBUG: 2021-02-08 17:07:10.0200 ParameterBinding Information: 0 :     BIND cmd line arg [c\"] to position [7]\r\nDEBUG: 2021-02-08 17:07:10.0261 ParameterBinding Information: 0 : CALLING BeginProcessing\r\nArgument 1 <'foo>\r\nArgument 2 <bar'>\r\nArgument 3 <a,b,c>\r\nArgument 4 <\"one>\r\nArgument 5 <two\">\r\nArgument 6 <\"a\\>\r\nArgument 7 <b\\>\r\nArgument 8 <c\">\r\n\r\n```\r\n\r\n### Additional considerations for tracing\r\n\r\nIt may be desirable to add additional tracing which provides information on the parameters _as they were provided_.\r\nThe tracing above is created at the point where the `StartInfo` object is populated,\r\nand it may be useful to see the parameter before it is altered by globbing, etc.\r\n\r\n## Current Implementation\r\n\r\nWhen PowerShell starts a new native process it takes all the arguments provided and attempts to stitch together the various parts into a single string (which is assigned to the `Arguments` property of the `StartInfo` object). This is done with some problematic behavior; empty strings `''` are explicitly stripped, embedded quotes and spaces are \"lost\" and require addition escaping.\r\n\r\n## New Behavior\r\n\r\nI think we can do better and reduce the effort and internal complexity when calling native applications. Dotnet has added a new property to the `StartInfo` object called `ArgumentList` which allows you to provide the arguments to the command as a collection of strings, alleviating the need to stitch the arguments into a single string. We can take advantage of this new API to reduce the complexity of our code. However, we should maintain backward compatibility if we can, so rather than producing new, breaking behavior via an experimental feature, I suggest that we provide a new runtime behavior based on a PowerShell variable. This allows users to change the behavior without restarting the PowerShell process and can be used when desired.\r\nBy not changing the default behavior we can provide users an easy way opt-in to the new behavior. Telemetry can be added if desired to capture the count of how many times the current way is used in comparison with this new implementation.\r\n\r\nNB: This proposal will actually _increase_ the internal complexity of our code because we'll have 2 ways of calling native applications. Hopefully, this would be temporary and we can use the new APIs exclusively in the future and deprecate the current code.\r\n\r\n### Tools used\r\n\r\nThe following utility is used to echo all passed parameters given in the examples above. This does not rely on the CLR runtime, but may be compiled for all platforms.\r\n\r\n```c\r\n#include <stdio.h>\r\nint main(int argc, char *argv[])\r\n{\r\n    for(int i = 1; i < argc; i++) {\r\n        printf(\"Argument %d <%s>\\n\", i, argv[i]);\r\n    }\r\n    return 0;\r\n}\r\n```\r\n\r\nWe can add this to the tools for build if needed (either by binaries checked in for each platform or build)\r\n\r\nRelated Links:\r\n\r\nPull Requests\r\n\r\n- https://github.com/PowerShell/PowerShell/pull/14692 (the PR to implement the behaviors listed here)\r\n- https://github.com/PowerShell/PowerShell/pull/13483\r\n\r\nIssues\r\n\r\n- https://github.com/PowerShell/PowerShell/issues/13068\r\n- https://github.com/PowerShell/PowerShell/issues/13428\r\n- https://github.com/PowerShell/PowerShell/issues/1995\r\n\r\n",
  "closed_at": null,
  "comments": [
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "> By not changing the default behavior we can provide users an easy way opt-in to the new behavior\r\n\r\nI suggest to rather have the new behavior by default and use the PowerShell variable rather for opting out of the new behavior. Especially with previews, it will allow people to discover whether they need to adapt their code or to give feedback that would allow tweaking of this new feature.",
      "created_at": "2021-02-09T20:41:23Z",
      "updated_at": "2021-02-09T20:41:23Z"
    },
    {
      "author": "kilasuit",
      "author_association": "COLLABORATOR",
      "body": "Should this not go as an experimental feature as opposed to using an environmental variable to control it? \n\n",
      "created_at": "2021-02-09T23:04:45Z",
      "updated_at": "2021-02-09T23:04:45Z"
    },
    {
      "author": "sba923",
      "author_association": "CONTRIBUTOR",
      "body": "> > By not changing the default behavior we can provide users an easy way opt-in to the new behavior\r\n> \r\n> I suggest to rather have the new behavior by default and use the PowerShell variable rather for opting out of the new behavior. Especially with previews, it will allow people to discover whether they need to adapt their code or to give feedback that would allow tweaking of this new feature.\r\n\r\nHow often would that break existing code?",
      "created_at": "2021-02-16T08:56:08Z",
      "updated_at": "2021-02-16T08:56:08Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I think the right approach with respect to enabling the new behavior is:\r\n\r\n* Have the new preference variable default to the OLD behavior, and require _opt-in_ to the new behavior; as suggested in https://github.com/PowerShell/PowerShell/pull/14692#issuecomment-773391188, it could be a `$PSNativeCommandArgumentPassing` (perhaps `$PSNativeArgumentPassing` is enough) with possible values `Legacy` (default, old behavior) and `Standard` (new behavior).\r\n\r\n    * Needing an opt-in is highly unfortunate, given that argument-passing to external programs is a core mandate of any shell, but if backward-compatibility is paramount, it's our only choice.\r\n\r\n* Introduce a temporary experimental feature that makes the engine act _as if the opt-in were in place_ - i.e. it acts as if `$PSNativeCommandArgumentPassing` were set to `Standard` (even if it is set to `Legacy` or the variable is missing); thereby, the new behavior will be in effect by default for preview users.\r\n\r\n  * However, visibility of experimental features and their current state is a problem in general - see #14862 for a suggested improvement.\r\n\r\n  * In the case at hand, is of vital importance that the new feature be widely publicized, to encourage people to put it to the test.\r\n\r\n    ",
      "created_at": "2021-02-21T14:32:59Z",
      "updated_at": "2021-02-21T14:32:59Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "_Update_: See #15143 for the most current version of this proposal; however, the post below additionally provides some background information on parameter-passing on Windows.\r\n\r\n---\r\n\r\nAs for the proposal:\r\n\r\n* Being able to trace native parameter passing will be a welcome addition on Windows (and in legacy mode on Unix).\r\n\r\n* The following behaviors mentioned in the OP are _incidental_ to the proposal:\r\n   * No changes from the current behavior:\r\n      * `$null` values are already ignored, both as individual arguments and as collection element.\r\n      * native globbing already works (though, as an aside, it is worth mentioning that this globbing is always case-_insensitive_, unlike the native behavior on Linux, and you get no control over whether _hidden_ items are also matched - they're _not_)\r\n   * N/A, due to how processes are launched on Unix-like platforms (the quoting styles of POSIX-compatible shells such as `bash` are irrelevant here):\r\n      * Quoting only applies to _shells_ on Unix, whose job is to parse a _command line_ - a single string encoding a command name and  its arguments - into the command name and the array of verbatim arguments to pass to it.\r\n      * Unlike on Windows, (non-shell) processes do _not_ receive a command line - they only ever receive an _array_ of _verbatim_ arguments - that's precisely what `.ArgumentList` gives us, and it _fully_ solves all problems on Unix.\r\n\r\n---\r\n\r\nUnfortunately, things aren't quite so simple on Windows, due to launched processes receiving a _command line_ that _they themselves_ must parse. This very unfortunate design forces processes to take on part of a job that should be exclusively a _shell's_ responsibility: parsing this command line into an array of verbatim arguments. \r\n\r\nAside from placing undue burden on non-shell processes, it opens the door to individual processes interpreting their command line _however they want_:\r\n\r\nWhile there is a _widely adhered-to convention_ for how to encode multiple arguments in such a process command line - namely the ones [used by Microsoft's C / C++ compiler / the CLR](https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args?view=msvc-160#parsing-c-command-line-arguments) (which I'll call the _C convention_ here) - no single encoding is guaranteed to work with _all_ programs:\r\n\r\n * The most prominent exception is `cmd.exe` - and therefore calls to _batch files_: they accept _only_ `\"\"` as an escaped `\"`, not the `\\\"` required by the C convention); while Microsoft compiler-generated executables _also_ support `\"\"`, there are third-party programs that support _only_ `\\\"`)\r\n\r\n * An additional problem is that batch files unfortunately and inappropriately parse their arguments _as if they had been passed from inside `cmd.exe`_, which causes something like `.\\foo.cmd http://example.org?foo&bar` to _break_ due to `&` being misinterpreted as a statement separator. Using `\"http://example.org?foo&bar\"`, i.e. quoting _from PowerShell_ doesn't help, because PowerShell - justifiably - _omits_ the quotes when it rebuilds the process command line behind the scenes,  given that value contains neither spaces nor _embedded_ `\"` chars.\r\n \r\n   * This is especially problematic given that the CLIs of many high-profile environments (e.g., Azure, Node.js) use batch files as their CLI entry points, so that something like `az ... http://example.org?foo&bar` predictably fails.\r\n\r\n  * Calling `cmd.exe /c <command-line>` or `cmd.exe /k <command-line>` _directly_ with a command line to be executed through a  happy accident actually _currently_ works as intended, without a workaround - and that behavior must be _retained_.\r\n\r\n * Finally, many programs are particular about _partial_ quoting of arguments, notably `msiexec.exe` with property arguments such as `PROP=\"VALUE WITH SPACES\"`; purely syntactically, `\"PROP=VALUE WITH SPACES\"` (which is what PowerShell currently sends) _should_ be equivalent (and if you let C runtime / CLR parse it, is - the resulting verbatim string is `PROP=VALUE WITH SPACES` in both cases), but in practice it is not.\r\n\r\n   * PowerShell should _not_ pay attention to the _original_ quoting on the _PowerShell_ command line in an attempt to emulate it when re-encoding behind the scenes; no such quoting may be present to begin with (e.g., `PROP=$someValuePossiblyWithSpaces`), and users generally shouldn't have to worry about such intricacies - see below.\r\n\r\nIt's impossible for PowerShell to fully solve these problems, but it makes sense to make _accommodations_ for these exceptions, so as to make the _vast majority_ of calls just work.\r\n\r\nFor the remaining, edge cases there is:\r\n *  `--%`  for console applications\r\n * `Start-Process` for GUI-subsystem applications with a CLI such as `msiexec` which allows you to fully control the process command line by passing a _single string_ to `-ArgumentList` (in a pinch you can also use it with console applications, but you lose stream integration). \r\n\r\n\r\n**In concrete terms this means for the _new_ behavior:**\r\n----\r\n\r\nAfter PowerShell's _own_ parsing, once the array of verbatim arguments - stripped of `$null`s -  to pass on is available:\r\n\r\n* On Unix-like platform:\r\n  * Pass that array to `.ArgumentList` - that is all that is ever needed.\r\n\r\n* On Windows:\r\n\r\n  * _Except for the cases detailed below_, also pass that array to `.ArgumentList` - behind the scenes, .NET performs the necessary _re-encoding_ based on the C conventions for us, and any conventional CLI should interpret the result correctly.\r\n\r\n  * The following _exceptions_ may apply independently or in combination, and they require _manual re-encoding by PowerShell_ (with assignment to `.Arguments`, as currently):\r\n\r\n    * If the target command is a _batch file_:\r\n      * use `\"\"` (rather than `\\\"`) to escape embedded verbatim `\"` (and ensure enclosure in syntactic `\"...\"`, even if the value has no spaces)\r\n      * `\"...\"`-enclose any argument that contain _no spaces_ (such arguments are normally _not_ quoted) _but contain any of the following `cmd.exe` metacharacters_: `& | < > ^ , ;` (while `,` and `;` have no impact on arguments pass-through with `%*`, they serve as argument separators in intra-batch file argument parsing; this also applies to `=`, but, unfortunately, passing something like `FOO=bar` as `\"FOO=bar\"` conflicts with the accommodation for `msiexec`-style CLIs below).\r\n\r\n    * Irrespective of the target executable, if any of the arguments have the form of a `misexec`-style partial-quoting argument, apply double-quoting only to the \"value\" part (the part after the separator):\r\n      *  Specifically, if an argument (a) matches regex `^([/-]\\w+[=:]|\\w+=)(.+)$`, and (b) the part after `=` or `:` _requires double-quoting_ (either due to containing spaces and/or an embedded `\"` and/or, in the case of a batch file containing `cmd.exe` metacharacters), leave the part _up to and including_ `=` or `:` _unquoted_, and double-quote only the remaining part.\r\n      * Examples:\r\n        * The following _PowerShell_ arguments: \r\n          * `FOO='bar none'`, `-foo:$value` (with `$value` containing verbatim `bar none`), ``/foo:bar` none`` (and even quoted-in-full variants `'FOO=bar none'`, ....)\r\n        * would end up in the `.Arguments` command line as follows:\r\n          * `FOO=\"bar none\"`, `-foo:\"bar none\"`, `/foo:\"bar none\"`\r\n\r\n    * Finally, a current behavior that must be _retained_, i.e. _no_ escaping of embedded `\"` is called for in the very specific case of `cmd.exe` being called with either the `/c` or the `/k` option followed by a _single_ argument (with spaces) representing a `cmd.exe` command line _in full_.\r\n      *  See [below](https://github.com/PowerShell/PowerShell/issues/14747#issuecomment-800376364) for details, including the proposal for an optional additional accommodation that would make sense.\r\n\r\n---\r\n\r\nAgain, these are reasonable accommodations to make, which:\r\n\r\n* allow users to focus solely on _PowerShell's syntax_ \r\n* should make the vast majority of calls just work.\r\n* are easy to conceptualize and document - the proposed tracing should help too.\r\n\r\nI invite everyone to scrutinize these accommodations to see if they're complete, overzealous, ...\r\n\r\nThis is a chance to finally cure all native quoting / argument-passing headaches - even if only by opt-in.\r\n\r\n(To experiment with the proposed behaviors up front (based on my personal implementation that sits _on top of_ the current behavior), you can use [`Install-Module Native`](https://github.com/mklement0/Native) and prepend `ie ` to command lines; if the proposed changes are implemented, such a stopgap will no longer be necessary, although it can still help on earlier versions.)\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2021-02-21T17:21:20Z",
      "updated_at": "2021-04-07T12:40:52Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> * Have the new preference variable\r\n\r\nIt should be noted that additional runtime behavior altering preference variables is not without risk. With each one added, the amount of ceremony required to guard against inherited preferences is increased heavily.\r\n\r\nI'm not weighing in on whether it's the right call in this scenario, just want to make sure that's considered.",
      "created_at": "2021-02-22T18:16:14Z",
      "updated_at": "2021-02-22T18:16:14Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Yes, that is a concern with _all_ preference variables, and the lack of lexical scoping is surely a candidate for #6745 (a similar concern arose recently with respect to allowing opt-in to using `/` as the path separator on Windows, https://github.com/PowerShell/PowerShell/issues/10509#issuecomment-740220540).\r\n\r\nThe - not exactly obvious - workaround is to use the `$private` scope:\r\n\r\n```powershell\r\n# Predefined preference variable:\r\n#  - defaults to 'Legacy'\r\n#  - is NOT defined with option 'AllScope'\r\n$global:PSNativeArgumentPassing = 'Legacy'\r\n\r\n& {\r\n\r\n    # Override the global preference variable *for this scope only*.\r\n    $private:PSNativeArgumentPassing = 'Standard'\r\n\r\n    \"In child scope: $PSNativeArgumentPassing\"\r\n\r\n    # Thanks to $private, descendant scopes again see the global variable.\r\n    & {\r\n      \"In grandchild scope: $PSNativeArgumentPassing\"\r\n    }\r\n\r\n}\r\n```\r\n\r\nI hope there's no question that:\r\n\r\n* introducing the new behavior is a must.\r\n* in-session control must be available as to which scopes adopt the new behavior vs. which ones do not.\r\n\r\nIn light of that, @SeeminglyScience: can you think of a different current-scope-only opt-in mechanism?",
      "created_at": "2021-02-22T20:38:57Z",
      "updated_at": "2021-02-22T20:51:56Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> Yes, that is a concern with _all_ preference variables\r\n\r\nIt's a little less of an issue since most of the existing preference variables are only going to change behavior that is already leaking to the user. Like error preference, usually when that changes runtime behavior it's when you're emitting an error to the user.\r\n\r\nI do say \"usually\" there because it can for sure end up forcing a different code path, but doesn't change the meaning of your code.  Also either way, the more that are added the harder it is to guard against.\r\n\r\n> In light of that, @SeeminglyScience: can you think of a different current-scope-only opt-in mechanism?\r\n\r\nCurrent scope isn't necessarily what you want either, too many things create a new scope where most users would not necessarily expect it.\r\n\r\nParser based lexical scoping does solve that problem, but creates a new one in the form of a new dialect which is very expensive in the long term.\r\n\r\nI don't know of a way to make a change like this without one of these extra chunks of complexity or breaking changes.",
      "created_at": "2021-02-23T03:12:34Z",
      "updated_at": "2021-02-23T03:12:34Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks, @SeeminglyScience - sounds like a preference variable is our only - imperfect - realistic short-term option.\r\n\r\n(A quick aside: `$PSDefaultParameterValues` is the one preference variable that _potentially_ has the farthest-reaching consequences, especially since modifying it directly in _any_ scope modifies the _global_ copy; fortunately, it doesn't seem to be used all that much in practice).\r\n\r\nIn practice, in terms of guiding users, this means:\r\n\r\n* Set the _global_ copy of `$PSNativeArgumentPassing` to `'Standard'` if you want _all_ code in your session to exhibit the new behavior.\r\n\r\n* Set a (non-global) scope-specific copy for that scope _and all its descendant scopes_ to exhibit the new behavior - but _not_ across module boundaries.\r\n\r\n* Set `$private:PSNativeArgumentPassing` to exhibit the new behavior in _that scope only_ - which requires knowledge of what does and doesn't run in a child scope (the rules for which are indeed not always clear - see #7157).\r\n\r\n\r\n",
      "created_at": "2021-02-23T23:08:41Z",
      "updated_at": "2021-02-23T23:08:41Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "A good experiment might be to try a *whole lot* of different build scripts for that use various toolsets and see how often they break with the new setting. That will be a prime example of accidental inheritance with often complex executable arguments.\r\n\r\nPersonally I'd still lean toward the stop parsing sigil being the way to go, ~~but in all honesty this issue has rarely affected me in a meaningful way so ymmv~~ (**Edit:** apparently because I coincidentally tend to bypass it with `cmd.exe /c`).",
      "created_at": "2021-02-24T17:27:39Z",
      "updated_at": "2021-03-16T16:36:03Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> I'd still lean toward the stop parsing sigil \r\n\r\nUnfortunately, `--%`, the stop-parsing symbol:\r\n\r\n* on _Windows_: is cumbersome and has non-obvious behavior and limitations - _and_ you need to know _when it is actually needed_, which is a big part of the problem - see https://github.com/MicrosoftDocs/PowerShell-Docs/issues/6149\r\n\r\n* on _Unix_: is a misnomer by definition (parsing _must_ happen there, in the absence of process-level command lines) and is virtually useless there, if you expect the behavior of the _native_ shell - see https://github.com/MicrosoftDocs/PowerShell-Docs/issues/4963\r\n\r\n> this issue has rarely affected me in a meaningful way \r\n\r\nI presume that's because you're a developer rather than a sysadmin or DevOps person.\r\n\r\nAs the following can attest:\r\n\r\n* #1995 (up-votes and the length of the discussion)\r\n* #13068  (in the sense that delegating to the native shell would be an attempt to _bypass_ the problem)\r\n* untold questions by users struggling with broken quoting on https://stackoverflow.com and sister sites such as https://superuser.com\r\n*  https://github.com/MicrosoftDocs/PowerShell-Docs/issues/2361\r\n\r\nthe issue at hand is a real, long-standing pain point.\r\n\r\nAnd the issue is an even bigger one on Unix, where - unlike on Windows - many capable native utilities exist, and that for performance reasons and due to lack of binary pipeline support resorting to native utilities (including the native shell) is sometimes a _must_.\r\n\r\nIt all comes back to this striking example (run on a Unix-like platform):\r\n\r\n```sh\r\nPS> /bin/echo '{ \"foo\" : 1 }'\r\n{ foo : 1 }  # !! double quotes were effectively stripped\r\n```\r\n\r\nThis is such blatantly broken behavior that you can't help but wonder why this hasn't been fixed - even if only on an opt-in basis - in the 14+ years of PowerShell's existence.\r\n\r\n\r\n\r\n<blockquote><img src=\"https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded\" width=\"48\" align=\"right\"><div>Stack Overflow</div><div><strong><a href=\"https://stackoverflow.com/\">Stack Overflow - Where Developers Learn, Share, & Build Careers</a></strong></div><div>Stack Overflow | The World\u2019s Largest Online Community for Developers</div></blockquote>\r\n<blockquote><img src=\"https://cdn.sstatic.net/Sites/superuser/Img/apple-touch-icon@2.png?v=e869e4459439\" width=\"48\" align=\"right\"><div>Super User</div><div><strong><a href=\"https://superuser.com/\">Super User</a></strong></div><div>Q&A for computer enthusiasts and power users</div></blockquote>",
      "created_at": "2021-02-24T17:54:16Z",
      "updated_at": "2021-02-24T17:55:54Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> Unfortunately, `--%`, the stop-parsing symbol:\r\n\r\nI mean the new one being proposed in a different issue somewhere.\r\n \r\n> I presume that's because you're a developer rather than a sysadmin or DevOps person.\r\n\r\nI'm a sysadmin.\r\n\r\n> As the following can attest:\r\n\r\nI included that last part as a disclaimer on my opinion, not as a dismissal of the need. Put more casually and a bit exaggerated it would be \"I think it should be X but what I do I know, I don't run into this problem\".",
      "created_at": "2021-02-24T18:12:37Z",
      "updated_at": "2021-02-24T18:12:37Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "> I mean the new one being proposed in a different issue somewhere.\r\n\r\nI assume you mean the aforementioned #13068  (\"native operator\") - its purpose is different, requires you to apply a _different shell's syntax_ and, without using a (here-)string as enclosure, is subject to the same conceptual headaches as `--%` while generally making it hard to integrate PowerShell variables / expressions in a given call. In short: it is _not_ meant to address the problem at hand, and it would so poorly - see https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-653319079\r\n\r\nThat said, a new call _operator_ - to be used explicitly, in lieu of `&`  (which also came up in the same thread, at https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-653526374) - might be a low-ceremony alternative that avoids the preference-variable scoping headaches.\r\n\r\nFinding the right sigil _combination_ (I don't think a single character is an option), may be a challenge (`&!` was mentioned), and, of course, it would be a very visible reminder in every call that extra effort is needed to get argument-passing to act correctly.\r\n\r\n\r\n> I'm a sysadmin.\r\n\r\nKudos on the extraordinary depth of your programming knowledge (just to be very clear: I mean it).\r\n\r\n> \"I think it should be X but what I do I know, I don't run into this problem\".\r\n\r\nUnderstood. I just wanted to complement that with a transpersonal perspective, to leave no doubt that many others do struggle with this.\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2021-02-24T18:33:56Z",
      "updated_at": "2021-03-29T22:54:43Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "I made a mistake (since corrected, and it is correct in the `ie` function) in the list of metacharacters that in batch-file calls should trigger double-quoting even for space-less arguments: the correct list is  `& | < > ^ , ;`\r\n\r\nThe reason that `,` and `;` are on that list is that `cmd.exe` interprets them as _argument separators_ in an _unquoted_ token; for instance,  in `.\\foo.cmd 'a,b'` and `.\\foo.cmd 'a;b'` the respective argument is currently (justifiably) passed as _unquoted_ `a,b` and `a;b` to batch files, and if they do _individual parameter processing_ with `%1`, ... or `shift` (as opposed to all-arguments pass-through with `%*`), they see _two_ arguments: `a` binds to `%1`, and `b` to `%2` - that is, the calls are effectively the same as using the usual whitespace-based argument separation: `.\\foo.cmd a b`.\r\n\r\n* Making PowerShell pass `\"1,2\"` and `\"1;2\"` in this case preserves the ability to pass such arguments as-is, without needing to resort to `--%` - and if truly   _two_ arguments are to be passed, whitespace separation can be used.\r\n\r\n* Note that that above additionally applies to `=`, but it is _not_ on the list, because it conflicts with the other accommodation, namely the one for `msiexec`-style programs: `<name>=<value>` should always leave the `<name>=` part _unquoted_.\r\n\r\n  * Given the diminishing importance of batch files (other than mere CLI entry points that pass all arguments through), it makes sense to me to prioritize this accommodation.\r\n  * The implication is that either `.\\foo.cmd --% \"a=b\"` or `cmd /c '.\\foo.cmd \"a=b\"'` must be used to pass verbatim `a=b` to a batch that does individual parameter processing.\r\n\r\nAgain, what we should strive for is accommodations that:\r\n\r\n* make the vast majority of calls \"just work\"\r\n* based on rules that are as easy to conceptualize and remember as possible, and are clearly documented along with workarounds for the rare remaining edge cases.\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2021-03-14T19:22:24Z",
      "updated_at": "2021-03-29T22:53:53Z"
    },
    {
      "author": "mklement0",
      "author_association": "CONTRIBUTOR",
      "body": "There is another accommodation we need to make (the [summary above](https://github.com/PowerShell/PowerShell/issues/14747#issuecomment-782892238) now links here):\r\n\r\n* _Direct_ `cmd.exe` calls that pass a command (line) to execute in the form of either `cmd.exe [<options>] /c <command>` or `cmd.exe [<options>] /k <command>`\r\n\r\n* For a _single_-argument `<command>` - which is ultimately the only _robust_ way to pass a command line - this currently works _as-is_ due to a _happy accident_:\r\n\r\n  * PowerShell's current lack of escaping of embedded `\"` is canceled out by `cmd.exe` not expecting any escaping and blindly stripping enclosing `\"...\"`.\r\n\r\n* If we don't keep handling this case the way we do now (see below), we would break something that currently works _as-is_ (no workaround needed).\r\n\r\n  * As an aside: Passing a command line as a single string to the platform-native shell - without having to worry about quirks and specific option names - is what the `Native` module's `ins` / `Invoke-NativeShell` cmdlet is designed to do, and I think such a cmdlet is called for as part of PowerShell, as the proper solution to #13068 (rationale in https://github.com/PowerShell/PowerShell/issues/13068#issuecomment-653319079).\r\n\r\nExample:\r\n\r\n```powershell\r\n# A command line to pass to cmd.exe for execution.\r\n# If executed correctly, the following should print verbatim:\r\n#       Ready to move on [Y,N]?Y\r\n$cmdLine = ' \"C:\\WINDOWS\\system32\\choice.exe\" /d Y /t 0 /m \"Ready to move on\" '\r\n\r\n# !! Despite the lack of behind-the-scenes escaping of the embedded double quotes, \r\n# !! this currently works *as intended*, in both editions:\r\ncmd /c $cmdLine\r\n```\r\n\r\nWhat PowerShell currently translates the list of arguments to behind the scenes and assigns to `.Arguments` is the following _verbatim_ string (I've prepended `cmd` so that it's easy to execute the command interactively from a `cmd.exe` session):\r\n\r\n```powershell\r\ncmd /c \" \"C:\\WINDOWS\\system32\\choice.exe\" /d Y /t 0 /m \"Ready to move on\" \"\r\n```\r\n\r\nThat is, the verbatim content of the string that PowerShell saw was _blindly_ enclosed in overall `\"...\"` (because the content contains spaces), _without_ escaping embedded `\"` chars.\r\n\r\nAs it turns out, that's exactly what `cmd.exe` expects - and that's the behavior we need to _retain_ in this case.\r\n\r\n---\r\n\r\nAs a *courtesy*, we could additionally do the following:\r\n\r\n`cmd.exe` _situationally_ allows you to pass a `/c` / `/k` command line as _multiple_ arguments, analogous to the PowerShell CLI's `-Command` / `-c` parameter.\r\n\r\nHowever, that _breaks_ - through `cmd.exe`'s own fault - if _both_ the _first_ argument (the executable) _and_ a _subsequent_ argument are double-quoted; e.g.:\r\n\r\n```powershell\r\n# Breaks from both cmd.exe and PowerShell, because both the first and a subsequent argument are double-quoted.\r\nC:[PS]> cmd /c \"C:\\Program Files\\PowerShell\\7\\pwsh\" -noprofile -c \" 'hi there' \"\r\n'C:\\Program' is not recognized as an internal or external command,\r\noperable program or batch file.\r\n```\r\n\r\nThis could be avoided if PowerShell - in the event that _multiple_ arguments follow `/c` or `/k` - transformed these multiple arguments into a _single_ one enclosed in overall `\"...\"` quoting, with the constituent arguments internally double-quoted as needed (but, again, _not_ escaped).\r\n\r\nThat is, PowerShell could automatically transform the above into the following verbatim string assigned to `.Arguments` (`cmd` again prepended to facilitate verification from an interactive `cmd.exe` session; spaces around the overall enclosing `\"` added for readability):\r\n\r\n```sh\r\n# OK - transformed to single-argument command line, which works robustly - outputs 'hi there'\r\ncmd /c \" \"C:\\Program Files\\PowerShell\\7\\pwsh\" -noprofile -c \" 'hi there' \" \"\r\n```\r\n\r\nIn fact, this is what the `ie` function from the `Native` module does as of v1.2.1:\r\n\r\n```powershell\r\n# Without `ie`, this breaks.\r\nPS> ie cmd /c 'C:\\Program Files\\PowerShell\\7\\pwsh' -noprofile -c \" 'hi there' \"\r\nhi there\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "created_at": "2021-03-16T15:44:22Z",
      "updated_at": "2021-03-23T19:31:04Z"
    },
    {
      "author": "SeeminglyScience",
      "author_association": "COLLABORATOR",
      "body": "> * _Direct_ `cmd.exe` calls that pass a command (line) to execute in the form of either `cmd.exe [<options>] /c <command>` or `cmd.exe [<options>] /k <command>`\r\n\r\nAhh that explains why I don't run into this issue much.  The few times that I need to invoke an executable with enough argument complication, I tend to build the whole command line as a single string and pass it to `cmd.exe /c`.",
      "created_at": "2021-03-16T16:34:01Z",
      "updated_at": "2021-03-16T16:34:01Z"
    }
  ],
  "created_at": "2021-02-09T18:58:30Z",
  "labels": [
    "Issue-Enhancement",
    "WG-Engine",
    "Needs-Triage"
  ],
  "number": 14747,
  "state": "open",
  "title": "Use ArgumentList when invoking native executables",
  "updated_at": "2022-03-17T23:01:27Z"
}