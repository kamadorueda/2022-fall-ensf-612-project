{
  "_url": "https://github.com/PowerShell/PowerShell/issues/6913",
  "author": "bergmeister",
  "body": "## PR Summary\r\n\r\n~~**travisez13: marking as WIP while I run compliance tools to make sure this doesn't break any compliance rules.  Don't remove WIP until I've signed off on compliance issues**~~\r\n\r\nCloses #6649 \r\n\r\nThis is a port of existing C++ Windows PowerShell code from [MainEntry.cpp](https://github.com/PowerShell/PowerShell/blob/master/src/powershell-native/nativemsh/pwrshexe/MainEntry.cpp)\r\nSome of the code has been copied and minified from the [WindowsApiPack](https://github.com/contre/Windows-API-Code-Pack-1.1).\r\n\r\nThe code is not compiled for `Linux` (not sure also another condition is needed for Windows on ARM?).\r\nThe code checks if the PowerShell process has a window handle by checking the startupinfo and only then tries to populate the list (and also checks if there is a slot available in the jumplist).\r\nTested on Windows 10 1803, jumpLists have been supported in Windows since Windows 7, which matches what PowerShell Core supports.\r\n\r\nThis is how it looks like:\r\n\r\n![image](https://user-images.githubusercontent.com/9250262/39961300-e2e43a0c-562a-11e8-972f-1821ad1cf621.png)\r\n\r\nNote that I found that on WinServer 2012 R2, the icon does not recognised and is empty instead, I tried using the `SetIconLocation` method to point it to the ico file instead (which works on Win10) but it did not work on WinServer2012R2, therefore I suspect I have either an odd VM or it is an OS bug. Since this is only a minor optical and non-functional detail on a less common OS, I think this is OK.\r\n\r\n## PR Checklist\r\n\r\n- [x] [PR has a meaningful title](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n    - Use the present tense and imperative mood when describing your changes\r\n- [x] [Summarized changes](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [x] [Change is not breaking](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#making-breaking-changes)\r\n- [x] [Make sure all `.h`, `.cpp`, `.cs`, `.ps1` and `.psm1` files have the correct copyright header](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n- [ ] This PR is ready to merge and is not [Work in Progress](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---work-in-progress).\r\n    - If the PR is work in progress, please add the prefix `WIP:` to the beginning of the title and remove the prefix when the PR is ready.\r\n- **User-facing changes**\r\n    - [ ] Not Applicable\r\n    - **OR**\r\n    - [ ] User-facing [Documentation needed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#pull-request---submission)\r\n        - [ ] Issue filed - Issue link:\r\n- **Testing - New and feature**\r\n    - [x] Not Applicable or can only be tested interactively\r\n    - **OR**\r\n    - [ ] [Make sure you've added a new test if existing tests do not effectively test the code changed](https://github.com/PowerShell/PowerShell/blob/master/.github/CONTRIBUTING.md#before-submitting)\r\n        - [ ] [Add `[feature]` if the change is significant or affects feature tests](https://github.com/PowerShell/PowerShell/blob/master/docs/testing-guidelines/testing-guidelines.md#requesting-additional-tests-for-a-pr)\r\n",
  "closed_at": "2018-05-31T19:24:20Z",
  "comments": [
    {
      "author": "TravisEz13",
      "author_association": "MEMBER",
      "body": "`[feature]` only works for commits",
      "created_at": "2018-05-21T21:36:35Z",
      "updated_at": "2018-05-21T21:36:35Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "@TravisEz13 Thanks for having a quick look and the helpful comments. I finished the last cleanup items and it is  now not WIP any more. I manually tested it already on a clean VM with one of the early AppVeyor build artifacts.",
      "created_at": "2018-05-21T21:43:23Z",
      "updated_at": "2018-05-22T11:36:23Z"
    },
    {
      "author": "TravisEz13",
      "author_association": "MEMBER",
      "body": "@bergmeister Would performance be better if you checked if we already are registered and don't register?\r\n\r\nAlso, I need to run compliance tools due to some changes you made.  I'm going to mark this as WIP again until the compliance tools say this change is good.",
      "created_at": "2018-05-21T21:54:28Z",
      "updated_at": "2018-05-21T21:54:28Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "@TravisEz13 By 'registered', do you mean if the jumplist has already been populated? As far as I am aware the Windows APIs for the jumplist, do not have 'Get' methods to check their current state (but I might be wrong). Any pointers are welcome.\r\nThere is no hurry for the review although getting it into the next preview might be good for testing exposure. So take your time, I will be on a conference from Wednesday on anyway.",
      "created_at": "2018-05-21T21:59:12Z",
      "updated_at": "2018-05-21T21:59:12Z"
    },
    {
      "author": "TravisEz13",
      "author_association": "MEMBER",
      "body": "@bergmeister No compliance issue with your new code\r\n> As far as I am aware the Windows APIs for the jumplist, do not have 'Get' methods to check their current state \r\n\r\nThat answered my question.",
      "created_at": "2018-05-22T00:36:55Z",
      "updated_at": "2018-05-22T00:37:08Z"
    },
    {
      "author": "TravisEz13",
      "author_association": "MEMBER",
      "body": "restarted macOS due to https://github.com/PowerShell/PowerShell/issues/6915",
      "created_at": "2018-05-22T00:41:45Z",
      "updated_at": "2018-05-22T00:41:45Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "@TravisEz13 I had a more detailed look and the WPF implementation seems to have a 'get' method: https://msdn.microsoft.com/en-us/library/system.windows.shell.jumplist.getjumplist(v=vs.110).aspx\r\nI was mostly reading the WindowsApiPack code and the IShellLink Windows Api docs. I would need to look at the decompiled WPF code to see if there is potential for optimisation (which would include/require at least setting the appId in order to persist the jumplist) but the implementation in Windows PowerShell does not perform such a check.\r\nThe WPF implementation seems to cache it:\r\n![image](https://user-images.githubusercontent.com/9250262/40346632-59c8f89e-5d95-11e8-97a2-3653673fb788.png)\r\n![image](https://user-images.githubusercontent.com/9250262/40346679-7f306216-5d95-11e8-9a21-40e23b7dc5c0.png)\r\n![image](https://user-images.githubusercontent.com/9250262/40346822-ea9e490a-5d95-11e8-8187-88a5fb01fa65.png)\r\n\r\nIn general I should also note that I managed to port a subset of the WindowsApiPack to .Net Core and also have a prototype to populate an elevated jumplist with that, which has slightly more advanced techniques (synclock, UI permission checks, etc.) but it would also require bringing in 100 times more code, hence why this PR aims only for a minimal port of the existing Windows PowerShell code, which should be at least better performance wise.",
      "created_at": "2018-05-22T06:24:18Z",
      "updated_at": "2018-05-22T07:06:32Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "Does that slow down the PowerShell Core start?",
      "created_at": "2018-05-23T04:17:58Z",
      "updated_at": "2018-05-23T04:17:58Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "I have not measured it but I could not feel a difference. It also only affects pwsh on Windows when it is being opened in an actual window.",
      "created_at": "2018-05-23T04:35:10Z",
      "updated_at": "2018-05-23T04:35:31Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "I guess we get this easily with .Net Core 3.0 - right?",
      "created_at": "2018-05-23T04:50:05Z",
      "updated_at": "2018-05-23T04:50:05Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "Maybe but even now I think WPF does not offer the APIs needed for elevation. .Net Core 3 development has only just started and realistically speaking, the chance that they will  be delayed is high and they are probably going to deliver a MVP first. But it is not a reason against this PR because one can just delete the folder that I added, so there is no deep integration that would make it difficult to take out in the future",
      "created_at": "2018-05-23T05:01:26Z",
      "updated_at": "2018-05-23T05:06:03Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": ".Net Framework has [System.Windows.Shell.JumpList ](https://msdn.microsoft.com/en-us/library/system.windows.shell.jumplist(v=vs.110).aspx) (STA only)",
      "created_at": "2018-05-23T07:10:17Z",
      "updated_at": "2018-05-23T07:11:13Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "Yes, but the classes in full .net do not support elevated JumpList entries.",
      "created_at": "2018-05-23T08:17:10Z",
      "updated_at": "2018-05-24T05:56:21Z"
    },
    {
      "author": "TravisEz13",
      "author_association": "MEMBER",
      "body": "@SteveL-MSFT Do we want to measure perf before accepting this?",
      "created_at": "2018-05-24T20:27:36Z",
      "updated_at": "2018-05-24T20:27:36Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "I could give you a measurement using the Stopwatch class when being compiled in Release and CrossGen'd to give you a rough number. Hardware would be either a 7th Gen i7 Notebook processor or an Azure VM size of your choice.\r\nIf you are worried, then we could potentially also implement the option of disabling the feature if a special environment variable is set. Otherwise it is a case of 'there is no such thing as free lunch'.",
      "created_at": "2018-05-25T06:26:45Z",
      "updated_at": "2018-05-25T06:26:45Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "The code remove one extra mouse click in GUI. This seems to be a very expensive solution, given that there are many non-interactive scenarios.",
      "created_at": "2018-05-25T06:31:25Z",
      "updated_at": "2018-05-25T06:31:25Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "Expensive in terms of what? In non-interactive scenarios, the only overhead is one call to get the startupinfo and then the algorithm will not proceed.",
      "created_at": "2018-05-25T08:50:46Z",
      "updated_at": "2018-05-25T08:50:46Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "> Expensive in terms of what?\r\n\r\nOver 600 code lines to add one menu item.",
      "created_at": "2018-05-25T09:39:26Z",
      "updated_at": "2018-05-25T09:39:26Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "The main code is just the 90 lines in the TaskbarJumpList file, which was a port of the existing Windows PowerShell C++ code in the referenced MainEntry.cpp\r\nThe other classes were taken from the WindowsApiPack and already minimized to include only the smallest set of required classes and methods.\r\nIs the concern more about the review or maintenance/support of this PR?",
      "created_at": "2018-05-25T13:10:52Z",
      "updated_at": "2018-05-25T13:11:45Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@bergmeister I'm trying to understand the need for this change, the difficulty in supporting and the negative impact on the start. So far I can take it but I don't see much benefits.",
      "created_at": "2018-05-25T13:31:09Z",
      "updated_at": "2018-05-25T13:31:09Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "The benefit of this feature is that it halves the time/clicks to open an elevated pwsh shell, brings consistency with Windows PowerShell in terms of user experience and having one less click to do reduces muscle strain in the long term. This issue got opened by a community member in the first place and other people are getting excited about this as well: https://twitter.com/CBergmeister/status/996873883268648960?s=19\r\n\r\nThe difficulty in writing/supporting this feature is the lack of support for this scenario from the Windows/.Net side:\r\nThe COM APIs are not very user friendly and require memory structs that are awkward to work with in .Net (especially `PropVariant`). Therefore the Windows team made the WindowsApiPack in .Net 3.5 and stopped supporting it because it got merged into WPF in .Net 4, but both implementations are missing overloads to support elevation and do not provide access to the low level shell object pointer)\r\nHence why I ripped out the minimum necessary code for us and added a call to the COM Api that enables elevation. But the whole algorithm is the same that Windows PowerShell uses as well.\r\n\r\nI have not measured the exact performance impact yet but I think it is minimal and negligible.",
      "created_at": "2018-05-25T15:13:41Z",
      "updated_at": "2018-05-27T14:24:22Z"
    },
    {
      "author": "bergmeister",
      "author_association": "CONTRIBUTOR",
      "body": "@TravisEz13 @iSazonov @SteveL-MSFT I measured the performance impact using the `StopWatch` class when compiling locally with `-CrossGen` and `Release` configuration: The first time it took 70 ms and after that the times were around **55 ms**, measurements fluctuated around 5-10 ms. When pwsh is launched inside an existing shell (or is non-interactive), then it is less than 1ms with the new commit.\r\n\r\nIs this OK performance wise since the performance impact only happens when a JumpList can be provided? Otherwise we would have to do something like kicking the work off in a background thread. I am not an expert on COM/Interop performance but I think there is not much potential for optimisation. When the PowerShell host moves back to STA I would expect a performance increase though.\r\n\r\n- OS: Windows 10 1803 (10.0.17134 Build 17134)\r\n- CPU: [Intel i7-7700HQ](https://ark.intel.com/products/97185/Intel-Core-i7-7700HQ-Processor-6M-Cache-up-to-3_80-GHz) (4 core Laptop version with 45 W TDP)\r\n- Disk: SSD - Samsung EVO 850",
      "created_at": "2018-05-26T21:06:43Z",
      "updated_at": "2018-05-27T20:15:36Z"
    },
    {
      "author": "iSazonov",
      "author_association": "COLLABORATOR",
      "body": "@bergmeister Thanks for your contribution! I am delighted that you have found this solution.",
      "created_at": "2018-06-01T03:06:44Z",
      "updated_at": "2018-06-01T03:06:44Z"
    }
  ],
  "created_at": "2018-05-21T20:56:56Z",
  "number": 6913,
  "state": "closed",
  "title": "Add Jumplist 'Run as Administrator' to Taskbar on Windows",
  "updated_at": "2018-06-01T03:06:44Z"
}