[
  {
    "author_association": "COLLABORATOR",
    "body": "For some history on why things are the way they are:\r\n\r\nWhile we were implementing workflows in version 3, we spent a lot of time looking into runspace creation performance. Unfortunately, after a lot of work runspace creation was still too slow for our purposes. (Remember - every command in a workflow runs in a separate runspace).  A big part of what makes it slow is processing initial session state and then loading any modules. To get \"reasonable\" performance, we finally went with runspace reuse instead, adding the ability to reset the runspace variables back to their initial state but leaving commands alone otherwise we'd be back where we started. Resetting a runspace is not blindingly fast but it's at least an order of magnitude faster than creating a new runspace.  As far as cross-contamination with commands goes, it's mostly not a problem (item 4 above). Considering that most people run with module autoloading turned on, what's in your runspace at any given time is theoretically random but practically not important (most of the time). If you do really care about a specific (version of a) module, then you can force-load it into your runspace. Of course this incurs a non-trivial cost. By allowing modules to be \"cached\" in runspaces, you only incur the overhead the first time you use that runspace. Subsequent uses don't have have the overhead of the module load so for an 8-core processor, assuming 1 runspace per core, you'd load the module 8 times. If you're iterating over a 1000 objects, that becomes reasonable. Loading the module 1000 times is probably not. As far as script module contention goes, we compile a script exactly once then cache the results because compiling a script takes time, uses up a *lot* of memory and creates many, many objects. We cache to minimize this memory use. This is why there is contention - we can't allow the script to be compiled on multiple threads. On the other hand, subsequent imports of a script module don't need to get compiled again, just looked up in the cache which is much faster. (I think this addresses your items 1 and 2 above). Item 3  - cloning the dynamic state of an evaluated scriptblock - that might be possible - deep-clone the contents of the session state scope object at initial module load, cache it then use it to initialize new instances of that module by deep-cloning the clone. It's a bit complicated and I'm not sure how much of a performance win you'd get but it would be interesting to investigate. Item 4 I discussed earlier in this message.\r\n",
    "created_at": "2018-08-15T01:28:03Z",
    "html_url": "https://github.com/PowerShell/PowerShell/issues/7524#issuecomment-413066601",
    "id": 413066601,
    "issue_url": "https://api.github.com/repos/PowerShell/PowerShell/issues/7524",
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMzA2NjYwMQ==",
    "performed_via_github_app": null,
    "reactions": {
      "+1": 1,
      "-1": 0,
      "confused": 0,
      "eyes": 0,
      "heart": 0,
      "hooray": 0,
      "laugh": 0,
      "rocket": 0,
      "total_count": 1,
      "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/413066601/reactions"
    },
    "updated_at": "2018-08-15T01:28:03Z",
    "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/413066601",
    "user": {
      "avatar_url": "https://avatars.githubusercontent.com/u/6876108?v=4",
      "events_url": "https://api.github.com/users/BrucePay/events{/privacy}",
      "followers_url": "https://api.github.com/users/BrucePay/followers",
      "following_url": "https://api.github.com/users/BrucePay/following{/other_user}",
      "gists_url": "https://api.github.com/users/BrucePay/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/BrucePay",
      "id": 6876108,
      "login": "BrucePay",
      "node_id": "MDQ6VXNlcjY4NzYxMDg=",
      "organizations_url": "https://api.github.com/users/BrucePay/orgs",
      "received_events_url": "https://api.github.com/users/BrucePay/received_events",
      "repos_url": "https://api.github.com/users/BrucePay/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/BrucePay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/BrucePay/subscriptions",
      "type": "User",
      "url": "https://api.github.com/users/BrucePay"
    }
  },
  {
    "author_association": "NONE",
    "body": "Thank you very much for the background @BrucePay, that has really helped to set my expectations to be consistent with how PowerShell is implemented.\r\n\r\n>As far as script module contention goes, we compile a script exactly once then cache the results because compiling a script takes time, uses up a lot of memory and creates many, many objects. We cache to minimize this memory use. This is why there is contention - we can't allow the script to be compiled on multiple threads. On the other hand, subsequent imports of a script module don't need to get compiled again, just looked up in the cache which is much faster. (I think this addresses your items 1 and 2 above).\r\n\r\nThis sounds really ideal.  Now that I have looked for this caching, I can indeed see the speedup from caching for single-threaded import.  For example,\r\n\r\n```PowerShell\r\n1..2 |\r\n    % {\r\n        Measure-Command {\r\n            [powershell]::Create().AddScript({\r\n                Import-Module Pester\r\n            }).Invoke()\r\n        }\r\n    } |\r\n        % TotalSeconds\r\n```\r\n\r\noutputs\r\n\r\n```none\r\n2.981724\r\n0.7399639\r\n```\r\n\r\nThis seems consistent with the caching story you described in your last post: The first import took 3 seconds because it had to first compile the module, and the second import took only 0.74 seconds because the cached compiled module was used.\r\n\r\nFor concurrent importing of modules, however, I'm not seeing the same speedup on subsequent module imports.  For example,\r\n\r\n```PowerShell\r\n$p = [System.Environment]::ProcessorCount\r\n\"Processors: $p\"\r\n& {\r\n    @{\r\n        Label = 'first import        '\r\n        Time  = Measure-Command { Import-Module Pester }\r\n    }\r\n\r\n    Remove-Module Pester\r\n\r\n    @{\r\n        Label = 'second import       '\r\n        Time  = Measure-Command { Import-Module Pester }\r\n    }\r\n\r\n    $invocations = 1..$p |\r\n        % {\r\n            $powershell = [powershell]::Create().AddScript({\r\n                Measure-Command {Import-Module Pester}\r\n            })\r\n            [pscustomobject]@{\r\n                PowerShell = $powershell\r\n                Invocation = $powershell.BeginInvoke()\r\n            }\r\n        }\r\n\r\n    $invocations | \r\n        % { \r\n            @{\r\n                Label = 'concurrent import'\r\n                Time = $_.PowerShell.EndInvoke($_.Invocation)\r\n            }\r\n        }\r\n} |\r\n    % {\r\n        [pscustomobject]@{\r\n            Label = $_.Label\r\n            Time = $_.Time.TotalSeconds | % {[System.Math]::Round($_,2)}\r\n        }\r\n    }\r\n```\r\n\r\noutputs\r\n\r\n```none\r\nProcessors: 16\r\n\r\nLabel                Time\r\n-----                ----\r\nfirst import         3.01\r\nsecond import        0.78\r\nconcurrent import    3.89\r\nconcurrent import    3.92\r\nconcurrent import    3.68\r\nconcurrent import    3.87\r\nconcurrent import     3.9\r\nconcurrent import    3.57\r\nconcurrent import    3.92\r\nconcurrent import    3.89\r\nconcurrent import    3.78\r\nconcurrent import    3.54\r\nconcurrent import    3.86\r\nconcurrent import     3.8\r\nconcurrent import    3.88\r\nconcurrent import    3.84\r\nconcurrent import    3.86\r\nconcurrent import    3.34\r\n```\r\n\r\nThe \"second import\" was imported when no other thread was importing, and it took only 0.78 seconds.  Then the module was imported into 16 runspaces concurrently.  Each such import took 3 to 4 seconds to complete.  \r\n\r\nI was expecting the concurrent importing of an already-compiled-and-cached module to take about the same amount of time as such a single-threaded import.  What should I be expecting here?\r\n\r\n_Sidenote: Importing the uncached module concurrently (by commenting out the first and second import) results in the following:_\r\n\r\n```none\r\nProcessors: 16\r\n\r\nLabel             Time\r\n-----             ----\r\nconcurrent import 8.19\r\nconcurrent import  8.2\r\nconcurrent import 8.16\r\nconcurrent import 8.16\r\nconcurrent import 8.14\r\nconcurrent import 8.17\r\nconcurrent import 8.19\r\nconcurrent import 8.17\r\nconcurrent import 8.15\r\nconcurrent import 8.15\r\nconcurrent import 8.16\r\nconcurrent import 8.19\r\nconcurrent import 8.18\r\nconcurrent import 8.14\r\nconcurrent import 8.14\r\nconcurrent import 8.16\r\n```\r\n\r\n_This slow importing seems consistent with the contention during compilation that you described._",
    "created_at": "2018-08-21T01:34:53Z",
    "html_url": "https://github.com/PowerShell/PowerShell/issues/7524#issuecomment-414520822",
    "id": 414520822,
    "issue_url": "https://api.github.com/repos/PowerShell/PowerShell/issues/7524",
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxNDUyMDgyMg==",
    "performed_via_github_app": null,
    "reactions": {
      "+1": 0,
      "-1": 0,
      "confused": 0,
      "eyes": 0,
      "heart": 0,
      "hooray": 0,
      "laugh": 0,
      "rocket": 0,
      "total_count": 0,
      "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/414520822/reactions"
    },
    "updated_at": "2018-08-21T01:34:53Z",
    "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/414520822",
    "user": {
      "avatar_url": "https://avatars.githubusercontent.com/u/11237922?v=4",
      "events_url": "https://api.github.com/users/alx9r/events{/privacy}",
      "followers_url": "https://api.github.com/users/alx9r/followers",
      "following_url": "https://api.github.com/users/alx9r/following{/other_user}",
      "gists_url": "https://api.github.com/users/alx9r/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/alx9r",
      "id": 11237922,
      "login": "alx9r",
      "node_id": "MDQ6VXNlcjExMjM3OTIy",
      "organizations_url": "https://api.github.com/users/alx9r/orgs",
      "received_events_url": "https://api.github.com/users/alx9r/received_events",
      "repos_url": "https://api.github.com/users/alx9r/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/alx9r/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alx9r/subscriptions",
      "type": "User",
      "url": "https://api.github.com/users/alx9r"
    }
  }
]
