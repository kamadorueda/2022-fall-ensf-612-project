[
  {
    "author_association": "COLLABORATOR",
    "body": "In any case you need to sync and it makes us think that Jobs is the best alternative.\r\n",
    "created_at": "2020-09-02T05:46:38Z",
    "html_url": "https://github.com/PowerShell/PowerShell/issues/13558#issuecomment-685315073",
    "id": 685315073,
    "issue_url": "https://api.github.com/repos/PowerShell/PowerShell/issues/13558",
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4NTMxNTA3Mw==",
    "performed_via_github_app": null,
    "reactions": {
      "+1": 0,
      "-1": 0,
      "confused": 0,
      "eyes": 0,
      "heart": 0,
      "hooray": 0,
      "laugh": 0,
      "rocket": 0,
      "total_count": 0,
      "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/685315073/reactions"
    },
    "updated_at": "2020-09-02T05:46:38Z",
    "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/685315073",
    "user": {
      "avatar_url": "https://avatars.githubusercontent.com/u/22290914?v=4",
      "events_url": "https://api.github.com/users/iSazonov/events{/privacy}",
      "followers_url": "https://api.github.com/users/iSazonov/followers",
      "following_url": "https://api.github.com/users/iSazonov/following{/other_user}",
      "gists_url": "https://api.github.com/users/iSazonov/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/iSazonov",
      "id": 22290914,
      "login": "iSazonov",
      "node_id": "MDQ6VXNlcjIyMjkwOTE0",
      "organizations_url": "https://api.github.com/users/iSazonov/orgs",
      "received_events_url": "https://api.github.com/users/iSazonov/received_events",
      "repos_url": "https://api.github.com/users/iSazonov/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/iSazonov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/iSazonov/subscriptions",
      "type": "User",
      "url": "https://api.github.com/users/iSazonov"
    }
  },
  {
    "author_association": "NONE",
    "body": "Using jobs just doesn't improve readability of the code. Maybe I'm just doing something wrong, so here is an example:\r\n![image](https://user-images.githubusercontent.com/2544867/92243123-3b58de00-eec1-11ea-937b-75872b824122.png)\r\n\r\nThe lines look like this:\r\n```\r\n[System.Management.Automation.Job[]]$xxInventory = Start-ThreadJob -ArgumentList (\"$PSScriptRoot/file.yaml\") {param([Parameter(Mandatory)][ValidateNotNullOrEmpty()][String]$PSPath);$a = Get-Content -Path $PSPath -Raw | ConvertFrom-Yaml; @{\"getContent\" = $a} }\r\n$xxInventory += Start-ThreadJob -ArgumentList ($xxToken,$xxAPIUrl) -ScriptBlock {param([Parameter(Mandatory)][ValidateNotNullOrEmpty()][String]$xxToken, [Parameter(Mandatory)][ValidateNotNullOrEmpty][String]$xxAPIUrl); $null = Connect-xxAPI -Token $xxToken -APIurl $xxAPIUrl; $a = Get-xxObjectListOfTypeA; @{\"xxInventoryObjectListOfTypeA\" = $a} }\r\n$xxInventory += Start-ThreadJob -ArgumentList ($xxToken,$xxAPIUrl) -ScriptBlock {param([Parameter(Mandatory)][ValidateNotNullOrEmpty()][String]$xxToken, [Parameter(Mandatory)][ValidateNotNullOrEmpty][String]$xxAPIUrl); $null = Connect-xxAPI -Token $xxToken -APIurl $xxAPIUrl; $a = Get-xxObjectListOfTypeB; @{\"xxInventoryObjectListOfTypeB= $a} }\r\n$xxInventory += Start-ThreadJob -ArgumentList ($xxToken,$xxAPIUrl) -ScriptBlock {param([Parameter(Mandatory)][ValidateNotNullOrEmpty()][String]$xxToken, [Parameter(Mandatory)][ValidateNotNullOrEmpty][String]$xxAPIUrl); $null = Connect-xxAPI -Token $xxToken -APIurl $xxAPIUrl; $a = Get-xxObjectListOfTypeC; @{\"xxInventoryObjectListOfTypeC\" = $a} }\r\n\r\nWait-Job -Job $xxInventory\r\n\r\n$joinedDictInventory = $xxInventory.Output | ForEach-Object -Begin {[Hashtable]$aa = @{}} -Process {foreach($element in ($_.GetEnumerator())) {$aa.Add($element.Key,$element.Value)}} -End {$aa}\r\n```\r\n",
    "created_at": "2020-09-04T13:20:55Z",
    "html_url": "https://github.com/PowerShell/PowerShell/issues/13558#issuecomment-687141129",
    "id": 687141129,
    "issue_url": "https://api.github.com/repos/PowerShell/PowerShell/issues/13558",
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4NzE0MTEyOQ==",
    "performed_via_github_app": null,
    "reactions": {
      "+1": 0,
      "-1": 0,
      "confused": 0,
      "eyes": 0,
      "heart": 0,
      "hooray": 0,
      "laugh": 0,
      "rocket": 0,
      "total_count": 0,
      "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/687141129/reactions"
    },
    "updated_at": "2020-09-04T13:20:55Z",
    "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/687141129",
    "user": {
      "avatar_url": "https://avatars.githubusercontent.com/u/2544867?v=4",
      "events_url": "https://api.github.com/users/agowa338/events{/privacy}",
      "followers_url": "https://api.github.com/users/agowa338/followers",
      "following_url": "https://api.github.com/users/agowa338/following{/other_user}",
      "gists_url": "https://api.github.com/users/agowa338/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/agowa338",
      "id": 2544867,
      "login": "agowa338",
      "node_id": "MDQ6VXNlcjI1NDQ4Njc=",
      "organizations_url": "https://api.github.com/users/agowa338/orgs",
      "received_events_url": "https://api.github.com/users/agowa338/received_events",
      "repos_url": "https://api.github.com/users/agowa338/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/agowa338/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/agowa338/subscriptions",
      "type": "User",
      "url": "https://api.github.com/users/agowa338"
    }
  },
  {
    "author_association": "COLLABORATOR",
    "body": "I would... suggest writing it with less duplication:\r\n```ps1\r\n$yamlJob = {\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [ValidateNotNullOrEmpty()]\r\n        [String]\r\n        $PSPath\r\n    )\r\n    $a = Get-Content -Path $PSPath -Raw | ConvertFrom-Yaml\r\n    @{\"getContent\" = $a } \r\n}\r\n\r\n$apiJob = {    \r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [ValidateNotNullOrEmpty()]\r\n        [String]\r\n        $xxToken, \r\n        \r\n        [Parameter(Mandatory)]\r\n        [ValidateNotNullOrEmpty]\r\n        [String]\r\n        $xxAPIUrl,\r\n\r\n        [Parameter(Mandatory)]\r\n        [scriptblock]\r\n        $ApiAction\r\n    )\r\n    $null = Connect-xxAPI -Token $xxToken -APIurl $xxAPIUrl\r\n    & $ApiAction\r\n}\r\n\r\n$xxInventory = @(\r\n    Start-ThreadJob -ScriptBlock $yamlJob -ArgumentList \"$PSScriptRoot/file.yaml\"\r\n    Start-ThreadJob -ScriptBlock $apiJob -ArgumentList $xxToken, $xxAPIUrl, {\r\n        @{\"xxInventoryObjectListOfTypeA\" = Get-xxObjectListOfTypeA }\r\n    }\r\n    Start-ThreadJob -ScriptBlock $apiJob -ArgumentList $xxToken, $xxAPIUrl, {\r\n        @{\"xxInventoryObjectListOfTypeB\" = Get-xxObjectListOfTypeB }\r\n    }\r\n    Start-ThreadJob -ScriptBlock $apiJob -ArgumentList $xxToken, $xxAPIUrl, {\r\n        @{\"xxInventoryObjectListOfTypeC\" = Get-xxObjectListOfTypeC }\r\n    }\r\n)\r\n\r\nWait-Job -Job $xxInventory\r\n\r\n$joinedDictInventory = $xxInventory.Output | ForEach-Object -Begin {[Hashtable]$aa = @{}} -Process {\r\n    foreach($element in ($_.Keys)) {\r\n        $aa.Add($element,$_[$element])\r\n    }\r\n} -End {$aa}\r\n```",
    "created_at": "2020-09-04T16:46:06Z",
    "html_url": "https://github.com/PowerShell/PowerShell/issues/13558#issuecomment-687263263",
    "id": 687263263,
    "issue_url": "https://api.github.com/repos/PowerShell/PowerShell/issues/13558",
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4NzI2MzI2Mw==",
    "performed_via_github_app": null,
    "reactions": {
      "+1": 1,
      "-1": 0,
      "confused": 0,
      "eyes": 0,
      "heart": 0,
      "hooray": 0,
      "laugh": 0,
      "rocket": 0,
      "total_count": 1,
      "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/687263263/reactions"
    },
    "updated_at": "2020-09-04T16:46:06Z",
    "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/687263263",
    "user": {
      "avatar_url": "https://avatars.githubusercontent.com/u/32407840?v=4",
      "events_url": "https://api.github.com/users/vexx32/events{/privacy}",
      "followers_url": "https://api.github.com/users/vexx32/followers",
      "following_url": "https://api.github.com/users/vexx32/following{/other_user}",
      "gists_url": "https://api.github.com/users/vexx32/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/vexx32",
      "id": 32407840,
      "login": "vexx32",
      "node_id": "MDQ6VXNlcjMyNDA3ODQw",
      "organizations_url": "https://api.github.com/users/vexx32/orgs",
      "received_events_url": "https://api.github.com/users/vexx32/received_events",
      "repos_url": "https://api.github.com/users/vexx32/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/vexx32/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vexx32/subscriptions",
      "type": "User",
      "url": "https://api.github.com/users/vexx32"
    }
  },
  {
    "author_association": "NONE",
    "body": "@vexx32 Thanks for your help, even though your solution looks better, sadly it doesn't work in my case. It leads to a powershell engine crash with either `tcache_thread_shutdown(): unaligned tcache chunk detected` or `malloc(): unaligned tcache chunk detected`\r\n\r\nEdit: It's working when I pass the scriptblock as string\r\n```powershell\r\n$apiJob = {    \r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [ValidateNotNullOrEmpty()]\r\n        [String]\r\n        $xxToken, \r\n        \r\n        [Parameter(Mandatory)]\r\n        [ValidateNotNullOrEmpty]\r\n        [String]\r\n        $xxAPIUrl,\r\n\r\n        [Parameter(Mandatory)]\r\n        [String]\r\n        $ApiAction\r\n    )\r\n    $null = Connect-xxAPI -Token $xxToken -APIurl $xxAPIUrl\r\n    & ([ScriptBlock]::Create($ApiAction))\r\n}\r\n\r\n$xxInventory = @(\r\n    Start-ThreadJob -ScriptBlock $yamlJob -ArgumentList \"$PSScriptRoot/file.yaml\"\r\n    '@{\"xxInventoryObjectListOfTypeC\" = Get-xxObjectListOfTypeA }', `\r\n    '@{\"xxInventoryObjectListOfTypeC\" = Get-xxObjectListOfTypeB }', `\r\n    '@{\"xxInventoryObjectListOfTypeC\" = Get-xxObjectListOfTypeC }' | ForEach-Object {\r\n        Start-ThreadJob -ScriptBlock $apiJob -ArgumentList $xxToken, $xxAPIUrl, $_\r\n    }\r\n)\r\n```",
    "created_at": "2020-09-07T14:54:09Z",
    "html_url": "https://github.com/PowerShell/PowerShell/issues/13558#issuecomment-688375354",
    "id": 688375354,
    "issue_url": "https://api.github.com/repos/PowerShell/PowerShell/issues/13558",
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4ODM3NTM1NA==",
    "performed_via_github_app": null,
    "reactions": {
      "+1": 0,
      "-1": 0,
      "confused": 0,
      "eyes": 0,
      "heart": 0,
      "hooray": 0,
      "laugh": 0,
      "rocket": 0,
      "total_count": 0,
      "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/688375354/reactions"
    },
    "updated_at": "2020-09-07T15:02:57Z",
    "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/688375354",
    "user": {
      "avatar_url": "https://avatars.githubusercontent.com/u/2544867?v=4",
      "events_url": "https://api.github.com/users/agowa338/events{/privacy}",
      "followers_url": "https://api.github.com/users/agowa338/followers",
      "following_url": "https://api.github.com/users/agowa338/following{/other_user}",
      "gists_url": "https://api.github.com/users/agowa338/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/agowa338",
      "id": 2544867,
      "login": "agowa338",
      "node_id": "MDQ6VXNlcjI1NDQ4Njc=",
      "organizations_url": "https://api.github.com/users/agowa338/orgs",
      "received_events_url": "https://api.github.com/users/agowa338/received_events",
      "repos_url": "https://api.github.com/users/agowa338/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/agowa338/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/agowa338/subscriptions",
      "type": "User",
      "url": "https://api.github.com/users/agowa338"
    }
  },
  {
    "author_association": "COLLABORATOR",
    "body": "Ah, I suppose I should have expected that, nice catch! Yeah, scriptblocks don't behave well at all between runspaces. I think somewhere there's an issue asking for them to be automatically serialized and re-created in the target process/runspace to fix the runspace affinity issue, but at present the string conversion is the way to go. 🙂 ",
    "created_at": "2020-09-07T16:52:25Z",
    "html_url": "https://github.com/PowerShell/PowerShell/issues/13558#issuecomment-688435109",
    "id": 688435109,
    "issue_url": "https://api.github.com/repos/PowerShell/PowerShell/issues/13558",
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4ODQzNTEwOQ==",
    "performed_via_github_app": null,
    "reactions": {
      "+1": 0,
      "-1": 0,
      "confused": 0,
      "eyes": 0,
      "heart": 0,
      "hooray": 0,
      "laugh": 0,
      "rocket": 0,
      "total_count": 0,
      "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/688435109/reactions"
    },
    "updated_at": "2020-09-07T16:52:25Z",
    "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/688435109",
    "user": {
      "avatar_url": "https://avatars.githubusercontent.com/u/32407840?v=4",
      "events_url": "https://api.github.com/users/vexx32/events{/privacy}",
      "followers_url": "https://api.github.com/users/vexx32/followers",
      "following_url": "https://api.github.com/users/vexx32/following{/other_user}",
      "gists_url": "https://api.github.com/users/vexx32/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/vexx32",
      "id": 32407840,
      "login": "vexx32",
      "node_id": "MDQ6VXNlcjMyNDA3ODQw",
      "organizations_url": "https://api.github.com/users/vexx32/orgs",
      "received_events_url": "https://api.github.com/users/vexx32/received_events",
      "repos_url": "https://api.github.com/users/vexx32/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/vexx32/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vexx32/subscriptions",
      "type": "User",
      "url": "https://api.github.com/users/vexx32"
    }
  },
  {
    "author_association": "NONE",
    "body": "Why not start by introducing the ability to declare a function/script-block/cmdLet as _pure_. That would then open up for powershell to optimize the execution in any way it sees fit.\r\n\r\nA function could even be automatically classified as _pure_ if it could  be determined that it has no side effects ( like only using other pure functions, only refer to the defined by-value-parameters of the function and so on)\r\n\r\nThe optimal solution would of course be if PowerShell enforced and allowed only \"pure stuff\" in a function declared as _pure_.\r\n\r\nWith this in place, stuff declared as _pure_ could be executed in parallel, async execution could be used when IO is involved, and so on....",
    "created_at": "2020-10-03T11:25:57Z",
    "html_url": "https://github.com/PowerShell/PowerShell/issues/13558#issuecomment-703088429",
    "id": 703088429,
    "issue_url": "https://api.github.com/repos/PowerShell/PowerShell/issues/13558",
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwMzA4ODQyOQ==",
    "performed_via_github_app": null,
    "reactions": {
      "+1": 0,
      "-1": 0,
      "confused": 0,
      "eyes": 0,
      "heart": 0,
      "hooray": 0,
      "laugh": 0,
      "rocket": 0,
      "total_count": 0,
      "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/703088429/reactions"
    },
    "updated_at": "2020-10-03T11:25:57Z",
    "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/703088429",
    "user": {
      "avatar_url": "https://avatars.githubusercontent.com/u/7513795?v=4",
      "events_url": "https://api.github.com/users/Bartolomeus-649/events{/privacy}",
      "followers_url": "https://api.github.com/users/Bartolomeus-649/followers",
      "following_url": "https://api.github.com/users/Bartolomeus-649/following{/other_user}",
      "gists_url": "https://api.github.com/users/Bartolomeus-649/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/Bartolomeus-649",
      "id": 7513795,
      "login": "Bartolomeus-649",
      "node_id": "MDQ6VXNlcjc1MTM3OTU=",
      "organizations_url": "https://api.github.com/users/Bartolomeus-649/orgs",
      "received_events_url": "https://api.github.com/users/Bartolomeus-649/received_events",
      "repos_url": "https://api.github.com/users/Bartolomeus-649/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/Bartolomeus-649/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Bartolomeus-649/subscriptions",
      "type": "User",
      "url": "https://api.github.com/users/Bartolomeus-649"
    }
  },
  {
    "author_association": "COLLABORATOR",
    "body": "> Why not start by introducing the ability to declare a function/script-block/cmdLet as _pure_. That would then open up for powershell to optimize the execution in any way it sees fit.\r\n\r\nIt's an interesting idea, though a pretty significant work item. Semantic checks would need to ensure that no state is changed, which for PowerShell would mean essentially calling no outside code, not using variables (aside from locals, and even then it would need to block dot sourcing), not inadvertently triggering events, etc.\r\n\r\nThe compiler would need to change how it handles some things like locals, they'd either need to be actual memory locations like `Expression.Variable` or restricted to `MutableTuple` items.\r\n\r\n> A function could even be automatically classified as _pure_ if it could be determined that it has no side effects ( like only using other pure functions, only refer to the defined by-value-parameters of the function and so on)\r\n\r\nThe difficulty there is that many things in PowerShell are determined not just a runtime, but at runtime of that expression. In order for the engine to automatically mark an item as pure, it would need to resolve it's command invocations recursively. This would be especially problematic with `CommandInvocationIntrincis.PreCommandLookupAction` (and similar) registrations.\r\n\r\nYou would pretty much only be able to automatically mark commands that just had constants and binary expressions.  Most of which won't actually see any benefit from being parallelized due to the overhead involved in spinning up a thread being greater than the cost of the function.\r\n \r\n> With this in place, stuff declared as _pure_ could be executed in parallel, async execution could be used when IO is involved, and so on....\r\n\r\nWould IO access be considered pure? Would you expect that the handling of the IO be parallelized or are you asking for asynchronous waiting of IO?",
    "created_at": "2020-10-03T12:05:47Z",
    "html_url": "https://github.com/PowerShell/PowerShell/issues/13558#issuecomment-703093091",
    "id": 703093091,
    "issue_url": "https://api.github.com/repos/PowerShell/PowerShell/issues/13558",
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwMzA5MzA5MQ==",
    "performed_via_github_app": null,
    "reactions": {
      "+1": 0,
      "-1": 0,
      "confused": 0,
      "eyes": 0,
      "heart": 0,
      "hooray": 0,
      "laugh": 0,
      "rocket": 0,
      "total_count": 0,
      "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/703093091/reactions"
    },
    "updated_at": "2020-10-03T12:05:47Z",
    "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/703093091",
    "user": {
      "avatar_url": "https://avatars.githubusercontent.com/u/24977523?v=4",
      "events_url": "https://api.github.com/users/SeeminglyScience/events{/privacy}",
      "followers_url": "https://api.github.com/users/SeeminglyScience/followers",
      "following_url": "https://api.github.com/users/SeeminglyScience/following{/other_user}",
      "gists_url": "https://api.github.com/users/SeeminglyScience/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/SeeminglyScience",
      "id": 24977523,
      "login": "SeeminglyScience",
      "node_id": "MDQ6VXNlcjI0OTc3NTIz",
      "organizations_url": "https://api.github.com/users/SeeminglyScience/orgs",
      "received_events_url": "https://api.github.com/users/SeeminglyScience/received_events",
      "repos_url": "https://api.github.com/users/SeeminglyScience/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/SeeminglyScience/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SeeminglyScience/subscriptions",
      "type": "User",
      "url": "https://api.github.com/users/SeeminglyScience"
    }
  },
  {
    "author_association": "NONE",
    "body": "> > With this in place, stuff declared as _pure_ could be executed in parallel, async execution could be used when IO is involved, and so on....\r\n> \r\n> Would IO access be considered pure? Would you expect that the handling of the IO be parallelized or are you asking for asynchronous waiting of IO?\r\n\r\nIt was more based on that you run CPU work in threads and use async for IO. No real thoughts if IO is _pure_ or not.\r\nPerhaps the _pure_ declaration has a few options (like C# attributes), where you op-in for lokal disk file IO to be considered _pure_ (or something like that).\r\n\r\n> > Why not start by introducing the ability to declare a function/script-block/cmdLet as _pure_. That would then open up for powershell to optimize the execution in any way it sees fit.\r\n> \r\n> It's an interesting idea, though a pretty significant work item. Semantic checks would need to ensure that no state is changed, which for PowerShell would mean essentially calling no outside code, not using variables (aside from locals, and even then it would need to block dot sourcing), not inadvertently triggering events, etc.\r\n\r\nWell, I guess you would have to start from the bottom up, by marking stuff as _pure_ all the way from `System.Object` and up. Perhaps a joint-venture with the .NET team, the Roslyn team and the C# team to make sure the _pure_ concept get introduced at the correct level. I would guess the Roslyn team are already familiar with the concept... \r\n\r\n> > A function could even be automatically classified as _pure_ if it could be determined that it has no side effects ( like only using other pure functions, only refer to the defined by-value-parameters of the function and so on)\r\n> \r\n> The difficulty there is that many things in PowerShell are determined not just a runtime, but at runtime of that expression. In order for the engine to automatically mark an item as pure, it would need to resolve it's command invocations recursively. This would be especially problematic with `CommandInvocationIntrincis.PreCommandLookupAction` (and similar) registrations.\r\n\r\nI would start with the simple approach by classifying stuff that can be determined for sure, and then perhaps other things can be checked at runtime, and if we are running in a _pure_ scope and try to write to anything outside that scope, then throw an exception.\r\n\r\n\r\n",
    "created_at": "2020-10-03T13:39:58Z",
    "html_url": "https://github.com/PowerShell/PowerShell/issues/13558#issuecomment-703105450",
    "id": 703105450,
    "issue_url": "https://api.github.com/repos/PowerShell/PowerShell/issues/13558",
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwMzEwNTQ1MA==",
    "performed_via_github_app": null,
    "reactions": {
      "+1": 0,
      "-1": 0,
      "confused": 0,
      "eyes": 0,
      "heart": 0,
      "hooray": 0,
      "laugh": 0,
      "rocket": 0,
      "total_count": 0,
      "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/703105450/reactions"
    },
    "updated_at": "2020-10-03T13:41:28Z",
    "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/703105450",
    "user": {
      "avatar_url": "https://avatars.githubusercontent.com/u/7513795?v=4",
      "events_url": "https://api.github.com/users/Bartolomeus-649/events{/privacy}",
      "followers_url": "https://api.github.com/users/Bartolomeus-649/followers",
      "following_url": "https://api.github.com/users/Bartolomeus-649/following{/other_user}",
      "gists_url": "https://api.github.com/users/Bartolomeus-649/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/Bartolomeus-649",
      "id": 7513795,
      "login": "Bartolomeus-649",
      "node_id": "MDQ6VXNlcjc1MTM3OTU=",
      "organizations_url": "https://api.github.com/users/Bartolomeus-649/orgs",
      "received_events_url": "https://api.github.com/users/Bartolomeus-649/received_events",
      "repos_url": "https://api.github.com/users/Bartolomeus-649/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/Bartolomeus-649/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Bartolomeus-649/subscriptions",
      "type": "User",
      "url": "https://api.github.com/users/Bartolomeus-649"
    }
  },
  {
    "author_association": "COLLABORATOR",
    "body": "> It was more based on that you run CPU work in threads and use async for IO. No real thoughts if IO is _pure_ or not.\r\n> Perhaps the _pure_ declaration has a few options (like C# attributes), where you op-in for lokal disk file IO to be considered _pure_ (or something like that).\r\n\r\nSomething I've always wanted to see come to PowerShell is a version of C#'s `async/await`.  I've thought a lot about it and even did a few small prototypes. Really cool idea, but to be honest it would either be too restrictive, or require too many architectural changes to PowerShell.  And realistically, it's pretty unlikely more than a handful of people would use it.\r\n\r\n> Well, I guess you would have to start from the bottom up, by marking stuff as _pure_ all the way from `System.Object` and up. Perhaps a joint-venture with the .NET team, the Roslyn team and the C# team to make sure the _pure_ concept get introduced at the correct level. I would guess the Roslyn team are already familiar with the concept...\r\n\r\nYou're welcome to bring it up over on dotnet/runtime. They don't really have the same types of problems that PowerShell does though. The majority of their state management isn't really thread based like PowerShell's is.\r\n\r\n> I would start with the simple approach by classifying stuff that can be determined for sure, and then perhaps other things can be checked at runtime, and if we are running in a _pure_ scope and try to write to anything outside that scope, then throw an exception.\r\n\r\nHonestly that would be one of the biggest work items in PowerShell's history.  Some more concrete examples of existing scripts or modules that would benefit would probably be needed for someone to take on writing an RFC.",
    "created_at": "2020-10-03T15:46:12Z",
    "html_url": "https://github.com/PowerShell/PowerShell/issues/13558#issuecomment-703123214",
    "id": 703123214,
    "issue_url": "https://api.github.com/repos/PowerShell/PowerShell/issues/13558",
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwMzEyMzIxNA==",
    "performed_via_github_app": null,
    "reactions": {
      "+1": 0,
      "-1": 0,
      "confused": 0,
      "eyes": 0,
      "heart": 0,
      "hooray": 0,
      "laugh": 0,
      "rocket": 0,
      "total_count": 0,
      "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/703123214/reactions"
    },
    "updated_at": "2020-10-03T15:46:12Z",
    "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/703123214",
    "user": {
      "avatar_url": "https://avatars.githubusercontent.com/u/24977523?v=4",
      "events_url": "https://api.github.com/users/SeeminglyScience/events{/privacy}",
      "followers_url": "https://api.github.com/users/SeeminglyScience/followers",
      "following_url": "https://api.github.com/users/SeeminglyScience/following{/other_user}",
      "gists_url": "https://api.github.com/users/SeeminglyScience/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/SeeminglyScience",
      "id": 24977523,
      "login": "SeeminglyScience",
      "node_id": "MDQ6VXNlcjI0OTc3NTIz",
      "organizations_url": "https://api.github.com/users/SeeminglyScience/orgs",
      "received_events_url": "https://api.github.com/users/SeeminglyScience/received_events",
      "repos_url": "https://api.github.com/users/SeeminglyScience/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/SeeminglyScience/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SeeminglyScience/subscriptions",
      "type": "User",
      "url": "https://api.github.com/users/SeeminglyScience"
    }
  },
  {
    "author_association": "NONE",
    "body": "> Would IO access be considered pure? Would you expect that the handling of the IO be parallelized or are you asking for asynchronous waiting of IO?\r\n\r\nIn general, that's a solved problem. As functional programs have less to no guarantees on sequential execution of instructions, doing io in a functional context is different. Therefore a function/instruction that writes to a file will do everything internally, e.g. open the file, write to it and close the file. If two functions write to the same file, there wouldn't be any guarantee of what gets written first (for some languages not even that they are written one after another). A programmer could solve this by simply either passing a handle to that file through both functions basically creating a dependency chain between them or by putting them inside of a sequential execution block. For the surrounding code that block would then be treated as one whole.\r\nFor reference I'm going to cite how haskell approached this problem ([haskell wiki](https://wiki.haskell.org/All_About_Monads#Introduction)):\r\n> A monad is a way to structure computations in terms of values and sequences of computations using those values. Monads allow the programmer to build up computations using sequential building blocks, which can themselves be sequences of computations. The monad determines how combined computations form a new computation and frees the programmer from having to code the combination manually each time it is required. (...)\r\n> Other monads exist for building computations that perform I/O, have state, may return multiple results, etc.\r\n\r\nas well as ([IO Monads](https://wiki.haskell.org/All_About_Monads#The_IO_monad)):\r\n> **Motivation**\r\n> Input/Output is incompatible with a pure functional language because it is not referentially transparent and side-effect free. The IO monad solves this problem by confining computations that perform I/O within the IO monad.\r\n> \r\n> **Definition**\r\n> In Haskell, the top-level main function must have type IO (), so that programs are typically structured at the top level as an imperative-style sequence of I/O actions and calls to functional-style code. The functions exported from the IO module do not perform I/O themselves. They return I/O actions, which describe an I/O operation to be performed. The I/O actions are combined within the IO monad (in a purely functional manner) to create more complex I/O actions, resulting in the final I/O action that is the main value of the program.\r\n\r\nIf full functional programming support should be added to powershell, having constructs like these Monads would be inevitable. For me however just being able to define functions as \"pure\" e.g. this function is \"self contained\" and doesn't cause side effects would be enough for now and issues like writing to the same file would have to be resolved by the programmer using either logical constraints, memory barriers or dumb synchronizations.\r\n\r\nAnd regarding:\r\n> And realistically, it's pretty unlikely more than a handful of people would use it.\r\n\r\nMaybe it's just me being more optimistic than about this than you are, but I see value for this for libraries and to simplify code of complex operations as well as reducing the time it takes to debug issues with side effects.",
    "created_at": "2020-10-06T02:45:23Z",
    "html_url": "https://github.com/PowerShell/PowerShell/issues/13558#issuecomment-703995225",
    "id": 703995225,
    "issue_url": "https://api.github.com/repos/PowerShell/PowerShell/issues/13558",
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwMzk5NTIyNQ==",
    "performed_via_github_app": null,
    "reactions": {
      "+1": 0,
      "-1": 0,
      "confused": 0,
      "eyes": 0,
      "heart": 0,
      "hooray": 0,
      "laugh": 0,
      "rocket": 0,
      "total_count": 0,
      "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/703995225/reactions"
    },
    "updated_at": "2020-10-06T02:57:03Z",
    "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/703995225",
    "user": {
      "avatar_url": "https://avatars.githubusercontent.com/u/2544867?v=4",
      "events_url": "https://api.github.com/users/agowa338/events{/privacy}",
      "followers_url": "https://api.github.com/users/agowa338/followers",
      "following_url": "https://api.github.com/users/agowa338/following{/other_user}",
      "gists_url": "https://api.github.com/users/agowa338/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/agowa338",
      "id": 2544867,
      "login": "agowa338",
      "node_id": "MDQ6VXNlcjI1NDQ4Njc=",
      "organizations_url": "https://api.github.com/users/agowa338/orgs",
      "received_events_url": "https://api.github.com/users/agowa338/received_events",
      "repos_url": "https://api.github.com/users/agowa338/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/agowa338/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/agowa338/subscriptions",
      "type": "User",
      "url": "https://api.github.com/users/agowa338"
    }
  },
  {
    "author_association": "COLLABORATOR",
    "body": "> Maybe it's just me being more optimistic than about this than you are, but I see value for this for libraries and to simplify code of complex operations as well as reducing the time it takes to debug issues with side effects.\r\n\r\nI should clarify that my concern is more about the amount of community adoption rather than whether it would be useful to those who did adopt.\r\n\r\nI've been wrong before though, so if you're passionate about it I'd recommend drafting [an RFC](https://github.com/PowerShell/PowerShell-RFC/blob/master/RFC0000-RFC-Process.md). I can't really see a way to make these changes without pretty significant rewrites of PowerShell's architecture, so an implementation proposal would be very helpful to move the conversation forward.",
    "created_at": "2020-10-06T13:03:58Z",
    "html_url": "https://github.com/PowerShell/PowerShell/issues/13558#issuecomment-704254200",
    "id": 704254200,
    "issue_url": "https://api.github.com/repos/PowerShell/PowerShell/issues/13558",
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwNDI1NDIwMA==",
    "performed_via_github_app": null,
    "reactions": {
      "+1": 0,
      "-1": 0,
      "confused": 0,
      "eyes": 0,
      "heart": 0,
      "hooray": 0,
      "laugh": 0,
      "rocket": 0,
      "total_count": 0,
      "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/704254200/reactions"
    },
    "updated_at": "2020-10-06T13:03:58Z",
    "url": "https://api.github.com/repos/PowerShell/PowerShell/issues/comments/704254200",
    "user": {
      "avatar_url": "https://avatars.githubusercontent.com/u/24977523?v=4",
      "events_url": "https://api.github.com/users/SeeminglyScience/events{/privacy}",
      "followers_url": "https://api.github.com/users/SeeminglyScience/followers",
      "following_url": "https://api.github.com/users/SeeminglyScience/following{/other_user}",
      "gists_url": "https://api.github.com/users/SeeminglyScience/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/SeeminglyScience",
      "id": 24977523,
      "login": "SeeminglyScience",
      "node_id": "MDQ6VXNlcjI0OTc3NTIz",
      "organizations_url": "https://api.github.com/users/SeeminglyScience/orgs",
      "received_events_url": "https://api.github.com/users/SeeminglyScience/received_events",
      "repos_url": "https://api.github.com/users/SeeminglyScience/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/SeeminglyScience/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SeeminglyScience/subscriptions",
      "type": "User",
      "url": "https://api.github.com/users/SeeminglyScience"
    }
  }
]
